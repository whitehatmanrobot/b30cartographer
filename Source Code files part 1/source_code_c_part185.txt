);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               if (IsmIsApplyObjectId (objectEnum.ObjectId)) {
                   IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
                   if (leaf && *leaf) {
                       // Check if we created this identity on the dest
                       filteredName = IsmFilterObject (g_RegType | PLATFORM_SOURCE,
                                                       objectEnum.ObjectName,
                                                       &destObjectTypeId,
                                                       &deleted,
                                                       &replaced);
                       if (filteredName) {
                           if (DoesDestRegExist(filteredName, REG_SZ) == FALSE) {
                               value++;
                           }
                           IsmDestroyObjectHandle(filteredName);
                       } else if (DoesDestRegExist(objectEnum.ObjectName, REG_SZ) == FALSE) {
                           value++;
                       }
                   }
                   IsmDestroyObjectString (node);
                   IsmDestroyObjectString (leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);

        // Update the value with the new Identity count
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertIdentityIndex(
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf);
        if (node && !StringMatch(node, TEXT("HKCU\\Identities"))) {
            // Only set this identity's index if this is new on the dest
            if (DoesDestRegExist(SrcObjectName, REG_DWORD)) {
                IsmClearApplyOnObject((g_RegType & (~PLATFORM_MASK)) | PLATFORM_SOURCE, SrcObjectName);
            } else {
                pSetDwordValue (NewContent, g_IdentityCount);
                g_IdentityCount++;
            }
        }
        IsmDestroyObjectString(node);
        IsmDestroyObjectString(leaf);
    }
    return TRUE;
}


BOOL
pIsAccountCollision (
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCTSTR OriginalName
    )
{
    PTSTR fullName;
    PTSTR destIdentity;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR ptr;
    MIG_OBJECTSTRINGHANDLE filteredName;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECTTYPEID destObjectTypeId;
    MIG_OBJECT_ENUM objectEnum;
    BOOL deleted;
    BOOL replaced;
    BOOL retval = FALSE;
    MIG_CONTENT objectContent;

    // This function detects account name collisions
    // Only collide if the same identity and same account string name

    // Check if this already exists
    if (HtFindString (g_AccountCollisionTable, SrcObjectName)) {
        return TRUE;
    }

    // Determine the destination location of this account
    filteredName = IsmFilterObject (g_RegType | PLATFORM_SOURCE,
                                    SrcObjectName,
                                    &destObjectTypeId,
                                    &deleted,
                                    &replaced);

    // Enumerate all of these accounts to look for dupes
    if (filteredName) {
        IsmCreateObjectStringsFromHandle (filteredName, &node, &leaf);
        if (node) {
            // Node is "HKR\Software\Microsoft\Internet Account Manager\Accounts\00000001"
            //      or "HKR\Identities\{GUID}\Software\Microsoft\Internet Account Manager\Accounts\00000001"
            ptr = (PTSTR)FindLastWack(node);
            *ptr = 0;

            enumPattern = IsmCreateSimpleObjectPattern (node,
                                                        TRUE,
                                                        TEXT("Account Name"),
                                                        FALSE);
            
            if (IsmEnumFirstDestinationObject (&objectEnum, g_RegType, enumPattern)) {
               do {
                   // don't collide with same identity on destination
                   if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, objectEnum.ObjectName, &objectContent)) {
                       if (IsValidRegSz(&objectContent)) {
                           if (StringIMatch (OriginalName, (PCTSTR) objectContent.MemoryContent.ContentBytes)) {
                               retval = TRUE;
                               IsmReleaseObject (&objectContent);
                               IsmAbortObjectEnum (&objectEnum);
                               break;
                           }
                       }
                       IsmReleaseObject (&objectContent);
                   }
               } while (IsmEnumNextObject (&objectEnum));
            }
            IsmDestroyObjectHandle (enumPattern);
            IsmDestroyObjectString(node);
        }
        IsmDestroyObjectString(leaf);
        IsmDestroyObjectHandle(filteredName);
    }

    return retval;
}


BOOL
pIsIdentityCollision (
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCTSTR OriginalUsername
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    BOOL retval = FALSE;

    // This function detects identity name collisions (i.e. 2 different "Main Identity"s)

    // Check if this already exists
    if (HtFindString (g_IdentityDestTable, OriginalUsername)) {
        return TRUE;
    }

    // Check for collisions on Destination
    enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"),
                                                TRUE,
                                                TEXT("Username"),
                                                FALSE);
    if (IsmEnumFirstDestinationObject (&objectEnum, g_RegType, enumPattern)) {
       do {
           // don't collide with same identity on destination
           if (!StringIMatch (SrcObjectName, objectEnum.ObjectName)) {
               if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, objectEnum.ObjectName, &objectContent)) {
                   if (IsValidRegSz(&objectContent)) {
                       if (StringIMatch (OriginalUsername, (PCTSTR) objectContent.MemoryContent.ContentBytes)) {
                           retval = TRUE;
                           IsmReleaseObject (&objectContent);
                           IsmAbortObjectEnum (&objectEnum);
                           break;
                       }
                   }
                   IsmReleaseObject (&objectContent);
               }
           }
       } while (IsmEnumNextObject (&objectEnum));
    }

    IsmDestroyObjectHandle (enumPattern);

    return retval;
}

PTSTR
pCollideName (
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCTSTR OriginalName,
    IN      LPISCOLLISION fnIsCollision,
    IN      HASHTABLE CollisionTable
    )
{
    PTSTR finalName = NULL;
    PTSTR tmpName;
    PTSTR testName = NULL;
    PTSTR openParen = NULL;
    PTSTR closeParen = NULL;
    PTSTR chr;
    TCHAR buff[20];
    UINT index = 1;
    BOOL replaceOk = TRUE;

    // This function handles name collisions for identities and accounts
    // For example, "Main Identity" becomes "Main Identity(2)"

    if (fnIsCollision (SrcObjectName, OriginalName))  {
        tmpName = DuplicateText (OriginalName);

        // Check if name already has a (number) tacked on
        openParen = _tcsrchr (tmpName, TEXT('('));
        closeParen = _tcsrchr (tmpName, TEXT(')'));

        if (closeParen && openParen &&
            closeParen > openParen &&
            closeParen - openParen > 1) {
            // Make sure it's purely numerical
            for (chr = openParen+1; chr < closeParen; chr++) {
                if (!_istdigit (*chr)) {
                    replaceOk = FALSE;
                    break;
                }
            }
            if (replaceOk == TRUE) {
                if (_stscanf (openParen, TEXT("(%d)"), &index)) {
                    *openParen = 0;
                }
            }
        }

        // Loop until we find a non-colliding name
        do {
            IsmReleaseMemory (finalName);
            index++;

            wsprintf (buff, TEXT("(%d)"), index);
            finalName = IsmGetMemory (ByteCount (OriginalName) + ByteCount (buff) + sizeof(TCHAR));
            StringCopy (finalName, tmpName);
            StringCat (finalName, buff);
        } while (fnIsCollision (SrcObjectName, finalName));

        FreeText (tmpName);

        // Put the new name in the hash tables
        HtAddStringEx (CollisionTable, finalName, &finalName, FALSE);
    } else {
        finalName = IsmGetMemory (ByteCount (OriginalName) + sizeof(TCHAR));
        StringCopy (finalName, OriginalName);
    }

    return finalName;
}


BOOL
WINAPI
pConvertIdentityGuid (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR newId;
    if (IsValidRegSz (CurrentContent)) {
        newId = OEGetRemappedId ((PCTSTR)CurrentContent->MemoryContent.ContentBytes);

        if (newId) {
            NewContent->Details.DetailsSize = sizeof(DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;
            NewContent->MemoryContent.ContentSize = ByteCount (newId) + sizeof(TCHAR);
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, newId);
            FreeText(newId);
        }
    }
    return TRUE;
}

BOOL
pConvertOE5Stationery (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    // Delete the destination's [Wide Stationery Name] value.
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;

    filteredName = IsmFilterObject (g_RegType | PLATFORM_SOURCE,
                                    SrcObjectName,
                                    &destObjectTypeId,
                                    &deleted,
                                    &replaced);
    if (filteredName) {
        IsmCreateObjectStringsFromHandle (filteredName, &node, &leaf);

        if (node) {
            destName = IsmCreateObjectHandle (node, TEXT("Wide Stationery Name"));
            IsmRemovePhysicalObject (g_RegType, destName);
            IsmDestroyObjectHandle(destName);

            destName = IsmCreateObjectHandle (node, TEXT("Stationery Name Converted"));
            IsmRemovePhysicalObject (g_RegType, destName);
            IsmDestroyObjectHandle(destName);

            IsmDestroyObjectString(node);
        }

        IsmDestroyObjectString(leaf);
        IsmDestroyObjectHandle(filteredName);
    }

    return TRUE;

}

BOOL
WINAPI
pConvertCollideAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegSz (OriginalContent)) {
        // Update the value with a potentially new account name
        NewContent->Details.DetailsSize = sizeof(DWORD);
        NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
        *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;

        NewContent->MemoryContent.ContentBytes = 
             (PBYTE) pCollideName (SrcObjectName, 
                                   (PCTSTR) OriginalContent->MemoryContent.ContentBytes,
                                   &pIsAccountCollision,
                                   g_AccountCollisionTable);
        NewContent->MemoryContent.ContentSize = ByteCount ((PCTSTR) NewContent->MemoryContent.ContentBytes) + sizeof(TCHAR);
    }
    return TRUE;
}


BOOL
WINAPI
pConvertIdentityUsername (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegSz (OriginalContent)) {
        // Update the value with a potentially new username
        NewContent->Details.DetailsSize = sizeof(DWORD);
        NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
        *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;

        NewContent->MemoryContent.ContentBytes = 
             (PBYTE) pCollideName (SrcObjectName, 
                                   (PCTSTR) OriginalContent->MemoryContent.ContentBytes,
                                   &pIsIdentityCollision,
                                   g_IdentityDestTable);
        NewContent->MemoryContent.ContentSize = ByteCount ((PCTSTR) NewContent->MemoryContent.ContentBytes) + sizeof(TCHAR);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertSetDwordTrue (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegType (OriginalContent, REG_DWORD)) {
        pSetDwordValue (NewContent, 1);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertSetDwordFalse (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegType (OriginalContent, REG_DWORD)) {
        pSetDwordValue (NewContent, 0);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertPSTBlob (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR originalStr = NULL;
    PCSTR finalStr = NULL;
    PTSTR joinedStr = NULL;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_OBJECTSTRINGHANDLE srcName = NULL;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;
    TCHAR *p = NULL;
    char *ptr;
    HALF_PTR oldSize;
    PCBYTE blob;

    if (IsValidRegType(OriginalContent, REG_BINARY)) {
        // Find the NULL before the PST filename
        blob = OriginalContent->MemoryContent.ContentBytes;
        ptr = (char *)(ULONG_PTR)((PBYTE)blob + OriginalContent->MemoryContent.ContentSize - 2);

        while ((ptr > blob) &&  (*ptr != 0)) {
            ptr--;
        }
        if (ptr <= blob) {
            // couldn't find it.. this isn't a PSTBlob
            return TRUE;
        }

        ptr++;

        oldSize = (HALF_PTR)(ptr - blob);
#ifdef UNICODE
        originalStr = ConvertAtoW(ptr);
#else
        originalStr = DuplicateText(ptr);
#endif

        if (originalStr) {
            p = (PTSTR)FindLastWack(originalStr);
            if (p) {
                *p = 0;
                srcName = IsmCreateObjectHandle (originalStr, p+1);

                if (srcName) {
                    filteredName = IsmFilterObject(MIG_FILE_TYPE | PLATFORM_SOURCE,
                                                   srcName,
                                                   &destObjectTypeId,
                                                   &deleted,
                                                   &replaced);
                    if (filteredName) {
                        IsmCreateObjectStringsFromHandle (filteredName, &node, &leaf);
                        IsmDestroyObjectHandle (filteredName);

                        joinedStr = JoinPaths (node, leaf);
                        if (joinedStr) {
#ifdef UNICODE
                            finalStr = ConvertWtoA(joinedStr);
#else
                            finalStr = DuplicateText(joinedStr);
#endif
                            FreePathString (joinedStr);
                        }
                        IsmDestroyObjectString (node);
                        IsmDestroyObjectString (leaf);
                    }
                    IsmDestroyObjectHandle (srcName);
                }
            }
#ifdef UNICODE
            FreeConvertedStr (originalStr);
#else
            FreeText(originalStr);
#endif
        }

        if (finalStr) {
            NewContent->Details.DetailsSize = sizeof(DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->Details.DetailsData) = REG_BINARY;
            NewContent->MemoryContent.ContentSize = oldSize + ByteCountA(finalStr) + 1;
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
            CopyMemory ((PVOID)NewContent->MemoryContent.ContentBytes,
                        OriginalContent->MemoryContent.ContentBytes,
                        oldSize);
            CopyMemory ((PVOID)(NewContent->MemoryContent.ContentBytes + oldSize),
                        finalStr,
                        NewContent->MemoryContent.ContentSize);

#ifdef UNICODE
            FreeConvertedStr (finalStr);
#else
            FreeText(finalStr);
#endif
        }
    }

    return TRUE;
}

DWORD
pCountSourceSubKeys (
    IN      PTSTR RootKey
    )
{
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    DWORD value = 0;

    enumPattern = IsmCreateSimpleObjectPattern (RootKey,  TRUE, NULL, FALSE);
    if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
       do {
           if (IsmIsApplyObjectId (objectEnum.ObjectId)) {
               value++;
           }
       } while (IsmEnumNextObject (&objectEnum));
    }
    IsmDestroyObjectHandle (enumPattern);

    // We enumerated the root key too, which we don't want to count
    value--;

    return value;
}

BOOL
WINAPI
pConvertIAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_CONTENT objectContent;
    PTSTR subKey;
    DWORD value = 1;
    PTSTR node;
    PTSTR leaf;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;

    // If this is a specific account's string name, name collide
    if (StrStrI(SrcObjectName, TEXT("\\Accounts\\"))) {
        return pConvertCollideAcctName (SrcObjectTypeId,
                                        SrcObjectName,
                                        OriginalContent,
                                        CurrentContent,
                                        NewContent,
                                        SourceOperationData,
                                        DestinationOperationData);
    }

    // Otherwise... Increment the base account count

    // Get the destination value where we are writing to
    filteredName = IsmFilterObject(g_RegType | PLATFORM_SOURCE,
                                   SrcObjectName,
                                   &destObjectTypeId,
                                   &deleted,
                                   &replaced);
    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                          filteredName ? filteredName : SrcObjectName,
                          &objectContent)) {
        if (IsValidRegType(&objectContent, REG_DWORD)) {
            value = *objectContent.MemoryContent.ContentBytes;
            if (value == 0) {
                value = 1;
            }
        }
        IsmReleaseObject (&objectContent);
    }

    if (filteredName) {
        IsmDestroyObjectHandle (filteredName);
    }

    // Now increment the value by the number of accounts we are writing from the source
    IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf);
    if (node) {
        subKey = JoinText(node, TEXT("\\Accounts"));
        if (subKey) {
            value += pCountSourceSubKeys (subKey);
            pSetDwordValue (NewContent, value);
            FreeText(subKey);
        }
        IsmDestroyObjectString(node);
    }
    if (leaf) {
        IsmDestroyObjectString(leaf);
    }

    return TRUE;
}

BOOL
WINAPI
pConvertOE5IAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 1;
    PTSTR srcIdentity;
    PTSTR tmpText;
    PTSTR tmpNode;
    PTSTR newIdentity = NULL;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {

        // Starting value is always in this location

        // Extract the source's associated ID.
        srcIdentity = OEGetAssociatedId (PLATFORM_SOURCE);
        if (srcIdentity) {
            newIdentity = OEGetRemappedId(srcIdentity);
            if (newIdentity) {
                if (OEIsIdentityAssociated(newIdentity)) {

                    // Migrating IAM to IAM
                    value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager"),
                                                TEXT("Account Name"));
                    if (value == 0) {
                        value = 1;
                    }
                } else {

                    // Migrating IAM to ID
                    tmpText = JoinText(TEXT("HKCU\\Identities\\"),
                                       newIdentity);
                    if (tmpText) {
                        tmpNode = JoinText(tmpText,
                                           TEXT("\\Software\\Microsoft\\Internet Account Manager"));
                        if (tmpNode) {
                            value = pGetDestDwordValue (tmpNode, TEXT("Account Name"));
                            if (value == 0) {
                                value = 1;
                            }
                            FreeText(tmpNode);
                        }
                        FreeText(tmpText);
                    }
                }
                FreeText(newIdentity);
            }
            FreeText(srcIdentity);
        }
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"));
        pSetDwordValue (NewContent, value);
    }

    return TRUE;
}

BOOL
WINAPI
pConvertOE4IAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR tmpName = NULL;
    PTSTR defaultId = NULL;
    DWORD value = 0;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        // Check if destination has Default ID.  If so, we're going to merge into that Identity.
        defaultId = OEGetDefaultId(PLATFORM_DESTINATION);
        if (defaultId) {
            tmpName = JoinPathsInPoolEx ((
                            NULL,
                            TEXT("HKCU\\Identities"),
                            defaultId,
                            TEXT("Software\\Microsoft\\Internet Account Manager"),
                            NULL
                            ));
            FreeText(defaultId);
        }

        // First try to get the AccountName from the identity key
        if (tmpName != NULL) {
            value = pGetDestDwordValue (tmpName, TEXT("Account Name"));
        }

        // If not there, look in the common key
        // NOTE: This might be a bad assumption. Shouldn't we check if the dest id is associated?
        //       It doesn't matter too much.. the worst case is the value is supposed to be 0, but
        //       we set this number higher, which doesn't really affect anything.
        if (tmpName == NULL || value == 0) {
            value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager"),
                                        TEXT("Account Name"));
        }
        if (value == 0) {
            value = 1;
        }
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"));

        pSetDwordValue (NewContent, value);
    }

    if (tmpName != NULL) {
        FreePathString (tmpName);
    }

    return TRUE;
}



BOOL
WINAPI
pConvertOMIAccountName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_CONTENT objectContent;
    DWORD value;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Office\\Outlook\\OMI Account Manager"),
                                    TEXT("Account Name"));
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Office\\Outlook\\OMI Account Manager\\Accounts"));
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}

BOOL
pConvertLangId (
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCTSTR OfficeApp
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    PTSTR node;
    PTSTR leaf;
    DWORD value;
    DWORD result = 0;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKLM\\Software\\Microsoft\\MS Setup (ACME)\\Table Files"),
                          TRUE,
                          NULL,
                          TRUE);

        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
            do {
                IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
                if (leaf && *leaf) {
                    if (StringIPrefix (leaf, TEXT("MS Office")) ||
                        StringIPrefix (leaf, OfficeApp)
                        ) {

                        result = _stscanf(leaf, TEXT("%*[^\\(](%d)"), &value);
                        // In Office installs, the Outlook entry may not have the (1033) piece,
                        // so we MUST check the result
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);

                if (result) {
                    IsmAbortObjectEnum (&objectEnum);
                    break;
                }
            } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);

        if (result) {
            pSetDwordValue (NewContent, value);
        }
    }
    return TRUE;
}

BOOL
WINAPI
pConvertOfficeLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("MS Office"));
    return TRUE;
}

BOOL
WINAPI
pConvertOutlookLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Outlook"));
    return TRUE;
}

BOOL
WINAPI
pConvertAccessLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Access"));
    return TRUE;
}

BOOL
WINAPI
pConvertExcelLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Excel"));
    return TRUE;
}

BOOL
WINAPI
pConvertFrontPageLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft FrontPage"));
    return TRUE;
}

BOOL
WINAPI
pConvertPowerPointLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft PowerPoint"));
    return TRUE;
}

BOOL
WINAPI
pConvertPublisherLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Publisher"));
    return TRUE;
}

BOOL
WINAPI
pConvertWordLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Word"));
    return TRUE;
}

BOOL
WINAPI
pConvertOffice2000LangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        value = pGetSrcDwordValue (TEXT("HKCU\\Software\\Microsoft\\Office\\9.0\\Common\\LanguageResources"),
                                   TEXT("EXEMode"));
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}


BOOL
WINAPI
pMigrateSoundSysTray (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    DWORD tempValue;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_DWORD) &&
            (*valueType2 == REG_DWORD)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just move the "Show volume control" bit.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if (IsValidRegType(&destContent, REG_DWORD)) {
                            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            *((PDWORD)NewContent->MemoryContent.ContentBytes) = (*((PDWORD)destContent.MemoryContent.ContentBytes)) &~ 0x00000004;
                            tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & 0x00000004);
                            *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) &~ 0x00000004;
                tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & 0x00000004);
                *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateAppearanceUPM (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    DWORD tempValue;

    if (IsValidRegType (OriginalContent, REG_BINARY) &&
        IsValidRegType (CurrentContent, REG_BINARY)) {

        // if the object was not changed yet we need to read the destination object and then
        // just move the appropriate bits.

        if ((!CurrentContent->MemoryContent.ContentBytes) ||
            (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
            ) {
            // find out the destination object and read it
            newObjectName = IsmFilterObject (
                                SrcObjectTypeId,
                                SrcObjectName,
                                &newObjectTypeId,
                                &deleted,
                                &replaced
                                );
            if ((!deleted || replaced) &&
                ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                ) {

                if (IsmAcquireObject (
                        (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                        newObjectName?newObjectName:SrcObjectName,
                        &destContent
                        )) {

                    if (IsValidRegType(&destContent, REG_BINARY)) {
                        NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) = (*((PDWORD)destContent.MemoryContent.ContentBytes)) &~ DISPLAY_BITMASK;
                        tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & DISPLAY_BITMASK);
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
                    }

                    IsmReleaseObject (&destContent);
                }

                if (newObjectName) {
                    IsmDestroyObjectHandle (newObjectName);
                    newObjectName = NULL;
                }
            }
        } else {
            // just transfer the appropriate bits.
            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) &~ DISPLAY_BITMASK;
            tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & DISPLAY_BITMASK);
            *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateMouseUPM (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    DWORD tempValue;

    if (IsValidRegType (OriginalContent, REG_BINARY) &&
        IsValidRegType (CurrentContent, REG_BINARY)) {

        // if the object was not changed yet we need to read the destination object and then
        // just move the appropriate bits.

        if ((!CurrentContent->MemoryContent.ContentBytes) ||
            (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
            ) {
            // find out the destination object and read it
            newObjectName = IsmFilterObject (
                                SrcObjectTypeId,
                                SrcObjectName,
                                &newObjectTypeId,
                                &deleted,
                                &replaced
                                );
            if ((!deleted || replaced) &&
                ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                ) {

                if (IsmAcquireObject (
                        (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                        newObjectName?newObjectName:SrcObjectName,
                        &destContent
                        )) {

                    if (IsValidRegType (&destContent, REG_BINARY)) {
                        NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) = (*((PDWORD)destContent.MemoryContent.ContentBytes)) &~ MOUSE_BITMASK;
                        tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & MOUSE_BITMASK);
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
                    }

                    IsmReleaseObject (&destContent);
                }

                if (newObjectName) {
                    IsmDestroyObjectHandle (newObjectName);
                    newObjectName = NULL;
                }
            }
        } else {
            // just transfer the appropriate bits.
            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) &~ MOUSE_BITMASK;
            tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & MOUSE_BITMASK);
            *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateOfflineSysTray (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_DWORD) &&
            (*valueType2 == REG_DWORD)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just move the "Enable offline folders" bit.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if (IsValidRegType (&destContent, REG_DWORD)) {
                            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)destContent.MemoryContent.ContentBytes);
                            if (*((PDWORD)OriginalContent->MemoryContent.ContentBytes) & 0x00000008) {
                                *((PDWORD)NewContent->MemoryContent.ContentBytes) |= 0x00000008;
                            } else {
                                *((PDWORD)NewContent->MemoryContent.ContentBytes) &= (~0x00000008);
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the "Enable offline folders" bit.
                NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                if (*((PDWORD)OriginalContent->MemoryContent.ContentBytes) & 0x00000008) {
                    *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) | 0x00000008;
                } else {
                    *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) & (~0x00000008);
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateTaskBarSS (
    IN      BOOL Force,
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    BYTE defShellState [sizeof (REGSHELLSTATE)] =
        {0x24, 0x00, 0x00, 0x00,
         0x20, 0x28, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x01, 0x00, 0x00, 0x00,
         0x0D, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x02, 0x00, 0x00, 0x00};
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the "fStartPanelOn" setting if present.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType (&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (Force) {
                                shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                                shellState2->ss.fStartPanelOn = FALSE;
                            } else {
                                if (OriginalContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE)) {
                                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                    if (shellState1->ss.version == SHELLSTATEVERSION) {
                                        shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                        shellState2->ss.fStartPanelOn = shellState1->ss.fStartPanelOn;
                                    }
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    } else {
                        if (Force) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                defShellState,
                                NewContent->MemoryContent.ContentSize
                                );
                            shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                            shellState2->ss.fStartPanelOn = FALSE;
                        }
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                if (Force) {
                    NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory (
                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                        CurrentContent->MemoryContent.ContentBytes,
                        NewContent->MemoryContent.ContentSize
                        );
                    shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                    shellState2->ss.fStartPanelOn = FALSE;
                } else {
                    // just transfer the "fStartPanelOn" setting if present.
                    if ((OriginalContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE)) &&
                        (CurrentContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                        ) {
                        shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                        if (shellState1->ss.version == SHELLSTATEVERSION) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                CurrentContent->MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                            shellState2->ss.fStartPanelOn = shellState1->ss.fStartPanelOn;
                        }
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateTaskBarSSPreserve (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pMigrateTaskBarSS (
                FALSE,
                SrcObjectTypeId,
                SrcObjectName,
                OriginalContent,
                CurrentContent,
                NewContent,
                SourceOperationData,
                DestinationOperationData
                );
}

BOOL
WINAPI
pMigrateTaskBarSSForce (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pMigrateTaskBarSS (
                TRUE,
                SrcObjectTypeId,
                SrcObjectName,
                OriginalContent,
                CurrentContent,
                NewContent,
                SourceOperationData,
                DestinationOperationData
                );
}

BOOL
WINAPI
pConvertShowIEOnDesktop (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL dontShowIE = FALSE;
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    MIG_CONTENT destContent;
    BOOL deleted = TRUE, replaced = FALSE;

    if (IsValidRegType(CurrentContent, REG_DWORD)) {
        dontShowIE = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) & 0x00100000;

        // find out the destination object and read it
        newObjectName = IsmFilterObject (
                            SrcObjectTypeId,
                            SrcObjectName,
                            &newObjectTypeId,
                            &deleted,
                            &replaced
                            );
        if ((!deleted || replaced) &&
            ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
            ) {

            if (IsmAcquireObject (
                    (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                    newObjectName?newObjectName:SrcObjectName,
                    &destContent
                    )) {

                if (IsValidRegType(&destContent, REG_DWORD)) {
                    NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory (
                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                        destContent.MemoryContent.ContentBytes,
                        NewContent->MemoryContent.ContentSize
                        );

                    if (dontShowIE) {
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= 0x00100000;
                    } else {
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) &= 0xFFEFFFFF;
                    }
                }

                IsmReleaseObject (&destContent);
            }

            if (newObjectName) {
                IsmDestroyObjectHandle (newObjectName);
                newObjectName = NULL;
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateActiveDesktop (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType(&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                shellState2->ss.fDesktopHTML= shellState1->ss.fDesktopHTML;
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                    shellState2->ss.fDesktopHTML = shellState1->ss.fDesktopHTML;
                }
            }
        }
    }

    return TRUE;
}

BOOL
CreateDwordRegObject (
    IN      PCTSTR KeyStr,
    IN      PCTSTR ValueName,
    IN      DWORD Value
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    DWORD regType = REG_DWORD;
    BOOL result = FALSE;

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;
    objectName = IsmCreateObjectHandle (KeyStr, ValueName);
    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ContentInFile = FALSE;
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE)&Value;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &regType;
    result = IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    return result;
}

BOOL
WINAPI
pMigrateDisplaySS (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType(&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+SHELLSTATE_SIZE_WIN95) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("Hidden"),
                                    shellState1->ss.fShowAllObjects?0x00000001:0x00000002
                                    );
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("HideFileExt"),
                                    shellState1->ss.fShowExtensions?0x00000000:0x00000001
                                    );
                                // on really old SHELLSTATE the "Show compressed folders" flag is in the place of fShowSysFiles
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("ShowCompColor"),
                                    shellState1->ss.fShowSysFiles?0x00000001:0x00000000
                                    );
                            }
                            if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                // If fWebView is not ON on the source system, fDoubleClickInWebView can have random
                                // values.
                                if (shellState1->ss.fWebView) {
                                    shellState2->ss.fDoubleClickInWebView = shellState1->ss.fDoubleClickInWebView;
                                } else {
                                    shellState2->ss.fDoubleClickInWebView = TRUE;
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+SHELLSTATE_SIZE_WIN95) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("Hidden"),
                        shellState1->ss.fShowAllObjects?0x00000001:0x00000002
                        );
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("HideFileExt"),
                        shellState1->ss.fShowExtensions?0x00000000:0x00000001
                        );
                    // on really old SHELLSTATE the "Show compressed folders" flag is in the place of fShowSysFiles
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("ShowCompColor"),
                        shellState1->ss.fShowSysFiles?0x00000001:0x00000000
                        );
                }
                if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+sizeof(SHELLSTATE)) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                    // If fWebView is not ON on the source system, fDoubleClickInWebView can have random
                    // values.
                    if (shellState1->ss.fWebView) {
                        shellState2->ss.fDoubleClickInWebView = shellState1->ss.fDoubleClickInWebView;
                    } else {
                        shellState2->ss.fDoubleClickInWebView = TRUE;
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateDisplayCS (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    LPCABINETSTATE cabState1 = NULL, cabState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType (&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (CABINETSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (CABINETSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );

                            if (OriginalContent->MemoryContent.ContentSize == sizeof(CABINETSTATE)) {
                                cabState1 = (LPCABINETSTATE)OriginalContent->MemoryContent.ContentBytes;
                                cabState2 = (LPCABINETSTATE)NewContent->MemoryContent.ContentBytes;
                                if (cabState1->nVersion >= 2) {
                                    CopyMemory (
                                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                                        OriginalContent->MemoryContent.ContentBytes,
                                        NewContent->MemoryContent.ContentSize
                                        );
                                } else {
                                    CreateDwordRegObject (
                                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CabinetState"),
                                        TEXT("FullPath"),
                                        cabState1->fFullPathTitle?0x00000001:0x00000000
                                        );
                                    cabState2->fNewWindowMode = cabState1->fNewWindowMode;
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize == sizeof(CABINETSTATE)) {
                    cabState1 = (LPCABINETSTATE)OriginalContent->MemoryContent.ContentBytes;
                    cabState2 = (LPCABINETSTATE)NewContent->MemoryContent.ContentBytes;
                    if (cabState1->nVersion < 2) {
                        CreateDwordRegObject (
                            TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CabinetState"),
                            TEXT("FullPath"),
                            cabState1->fFullPathTitle?0x00000001:0x00000000
                            );
                        cabState2->fNewWindowMode = cabState1->fNewWindowMode;
                    }
                }
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\unicode\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\access.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    access.c

Abstract:

    Implements Win9x accessiblity conversion by hooking the physical registry type
    and emulating the NT registry format.

Author:

    Jim Schmidt (jimschm) 29-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"

#define DBG_ACCESS     "Accessibility"

//
// Strings
//

#define S_ACCESSIBILITY_ROOT        TEXT("HKCU\\Control Panel\\Accessibility")

//
// Constants
//

#define SPECIAL_INVERT_OPTION   0x80000000

//
// Macros
//

// none

//
// Types
//

typedef struct {
    PCTSTR ValueName;
    DWORD FlagVal;
} ACCESS_OPTION, *PACCESS_OPTION;

typedef struct {
    PACCESS_OPTION AccessibilityMap;
    PCTSTR Win9xSubKey;
    PCTSTR NtSubKey;
} ACCESSIBILITY_MAPPINGS, *PACCESSIBILITY_MAPPINGS;

typedef struct {
    MEMDB_ENUM EnumStruct;
    DWORD RegType;
} ACCESSIBILITY_ENUM_STATE, *PACCESSIBILITY_ENUM_STATE;


//
// Globals
//

MIG_OBJECTTYPEID g_RegistryTypeId;
HASHTABLE g_ProhibitTable;

ACCESS_OPTION g_FilterKeys[] = {
    TEXT("On"),                     FKF_FILTERKEYSON,
    TEXT("Available"),              FKF_AVAILABLE,
    TEXT("HotKeyActive"),           FKF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          FKF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            FKF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    FKF_INDICATOR,
    TEXT("ClickOn"),                FKF_CLICKON,
    TEXT("OnOffFeedback"),          0,
    NULL
};

ACCESS_OPTION g_MouseKeys[] = {
    TEXT("On"),                     MKF_MOUSEKEYSON,
    TEXT("Available"),              MKF_AVAILABLE,
    TEXT("HotKeyActive"),           MKF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          MKF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            MKF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    MKF_INDICATOR,
    TEXT("Modifiers"),              MKF_MODIFIERS|SPECIAL_INVERT_OPTION,
    TEXT("ReplaceNumbers"),         MKF_REPLACENUMBERS,
    TEXT("OnOffFeedback"),          0,
    NULL
};

ACCESS_OPTION g_StickyKeys[] = {
    TEXT("On"),                     SKF_STICKYKEYSON,
    TEXT("Available"),              SKF_AVAILABLE,
    TEXT("HotKeyActive"),           SKF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          SKF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            SKF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    SKF_INDICATOR,
    TEXT("AudibleFeedback"),        SKF_AUDIBLEFEEDBACK,
    TEXT("TriState"),               SKF_TRISTATE,
    TEXT("TwoKeysOff"),             SKF_TWOKEYSOFF,
    TEXT("OnOffFeedback"),          0,
    NULL
};

ACCESS_OPTION g_SoundSentry[] = {
    TEXT("On"),                     SSF_SOUNDSENTRYON,
    TEXT("Available"),              SSF_AVAILABLE,
    TEXT("ShowStatusIndicator"),    SSF_INDICATOR,
    NULL
};

ACCESS_OPTION g_TimeOut[] = {
    TEXT("On"),                     ATF_TIMEOUTON,
    TEXT("OnOffFeedback"),          ATF_ONOFFFEEDBACK,
    NULL
};

ACCESS_OPTION g_ToggleKeys[] = {
    TEXT("On"),                     TKF_TOGGLEKEYSON,
    TEXT("Available"),              TKF_AVAILABLE,
    TEXT("HotKeyActive"),           TKF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          TKF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            TKF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    TKF_INDICATOR,
    TEXT("OnOffFeedback"),          0,
    NULL
};

ACCESS_OPTION g_HighContrast[] = {
    TEXT("On"),                     HCF_HIGHCONTRASTON,
    TEXT("Available"),              HCF_AVAILABLE,
    TEXT("HotKeyActive"),           HCF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          HCF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            HCF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    HCF_INDICATOR,
    TEXT("HotKeyAvailable"),        HCF_HOTKEYAVAILABLE,
    TEXT("OnOffFeedback"),          0,
    NULL
};


ACCESSIBILITY_MAPPINGS g_AccessibilityMappings[] = {
    {g_FilterKeys,      TEXT("KeyboardResponse"),   TEXT("Keyboard Response")},
    {g_MouseKeys,       TEXT("MouseKeys")},
    {g_StickyKeys,      TEXT("StickyKeys")},
    {g_SoundSentry,     TEXT("SoundSentry")},
    {g_TimeOut,         TEXT("TimeOut")},
    {g_ToggleKeys,      TEXT("ToggleKeys")},
    {g_HighContrast,    TEXT("HighContrast")},
    {NULL}
};


//
// Macro expansion list
//

// none

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// none

//
// Private prototypes
//

ETMINITIALIZE AccessibilityEtmInitialize;
MIG_PHYSICALENUMADD EmulatedEnumCallback;
MIG_PHYSICALACQUIREHOOK AcquireAccessibilityFlags;
MIG_PHYSICALACQUIREFREE ReleaseAccessibilityFlags;

//
// Code
//

VOID
pProhibit9xSetting (
    IN      PCTSTR Key,
    IN      PCTSTR ValueName        OPTIONAL
    )
{
    MIG_OBJECTSTRINGHANDLE handle;

    handle = IsmCreateObjectHandle (Key, ValueName);
    MYASSERT (handle);

    IsmProhibitPhysicalEnum (g_RegistryTypeId, handle, NULL, 0, NULL);
    HtAddString (g_ProhibitTable, handle);

    IsmDestroyObjectHandle (handle);
}


BOOL
pStoreEmulatedSetting (
    IN      PCTSTR Key,
    IN      PCTSTR ValueName,           OPTIONAL
    IN      DWORD Type,
    IN      PBYTE ValueData,
    IN      UINT ValueDataSize
    )
{
    MIG_OBJECTSTRINGHANDLE handle;
    PCTSTR memdbNode;
    BOOL stored = FALSE;

    handle = IsmCreateObjectHandle (Key, ValueName);
    memdbNode = JoinPaths (TEXT("~Accessibility"), handle);
    IsmDestroyObjectHandle (handle);

    if (MemDbAddKey (memdbNode)) {
        if (ValueData) {
            stored = (MemDbSetValue (memdbNode, Type) != 0);
            stored &= (MemDbSetUnorderedBlob (memdbNode, 0, ValueData, ValueDataSize) != 0);
        } else {
            stored = TRUE;
        }
    }

    FreePathString (memdbNode);

    return stored;
}


VOID
pMoveAccessibilityValue (
    IN      PCTSTR Win9xKey,
    IN      PCTSTR Win9xValue,
    IN      PCTSTR NtKey,
    IN      PCTSTR NtValue,
    IN      BOOL ForceDword
    )
{
    HKEY key;
    PBYTE data = NULL;
    PBYTE storeData;
    DWORD conversionDword;
    DWORD valueType;
    DWORD valueSize;
    MIG_OBJECTSTRINGHANDLE handle;
    BOOL prohibited;

    handle = IsmCreateObjectHandle (Win9xKey, Win9xValue);
    prohibited = (HtFindString (g_ProhibitTable, handle) != NULL);
    IsmDestroyObjectHandle (handle);

    if (prohibited) {
        return;
    }

    key = OpenRegKeyStr (Win9xKey);
    if (!key) {
        return;
    }

    __try {
        if (!GetRegValueTypeAndSize (key, Win9xValue, &valueType, &valueSize)) {
            __leave;
        }

        if (valueType != REG_SZ && valueType != REG_DWORD) {
            __leave;
        }

        data = GetRegValueData (key, Win9xValue);
        if (!data) {
            __leave;
        }

        if (ForceDword && valueType == REG_SZ) {
            storeData = (PBYTE) &conversionDword;
            conversionDword = _ttoi ((PCTSTR) data);
            valueType = REG_DWORD;
            valueSize = sizeof (DWORD);
        } else {
            storeData = data;
        }

        if (pStoreEmulatedSetting (NtKey, NtValue, valueType, storeData, valueSize)) {
            pProhibit9xSetting (Win9xKey, Win9xValue);
        }
    }
    __finally {
        CloseRegKey (key);

        if (data) {
            FreeAlloc (data);
        }
    }
}


VOID
pMoveAccessibilityKey (
    IN      PCTSTR Win9xKey,
    IN      PCTSTR NtKey
    )
{
    HKEY key;
    PBYTE data = NULL;
    DWORD valueType;
    DWORD valueSize;
    LONG rc;
    DWORD index = 0;
    TCHAR valueName[MAX_REGISTRY_KEY];
    DWORD valueNameSize;
    GROWBUFFER value = INIT_GROWBUFFER;
    MIG_OBJECTSTRINGHANDLE handle;
    BOOL prohibited;

    key = OpenRegKeyStr (Win9xKey);
    if (!key) {
        return;
    }

    __try {
        for (;;) {

            valueNameSize = ARRAYSIZE(valueName);
            valueSize = 0;
            rc = RegEnumValue (key, index, valueName, &valueNameSize, NULL, &valueType, NULL, &valueSize);

            if (rc != ERROR_SUCCESS) {
                break;
            }

            handle = IsmCreateObjectHandle (Win9xKey, valueName);
            prohibited = (HtFindString (g_ProhibitTable, handle) != NULL);
            IsmDestroyObjectHandle (handle);

            if (!prohibited) {

                value.End = 0;
                data = GbGrow (&value, valueSize);

                valueNameSize = ARRAYSIZE(valueName);
                rc = RegEnumValue (key, index, valueName, &valueNameSize, NULL, &valueType, value.Buf, &valueSize);

                if (rc != ERROR_SUCCESS) {
                    break;
                }

                if (pStoreEmulatedSetting (NtKey, valueName, valueType, data, valueSize)) {
                    pProhibit9xSetting (Win9xKey, valueName);
                }
            }

            index++;
        }

        if (pStoreEmulatedSetting (NtKey, NULL, 0, NULL, 0)) {
            pProhibit9xSetting (Win9xKey, NULL);
        }
    }
    __finally {
        CloseRegKey (key);

        GbFree (&value);
    }
}


VOID
pTranslateAccessibilityKey (
    IN      PCTSTR Win9xSubKey,
    IN      PCTSTR NtSubKey,
    IN      PACCESS_OPTION AccessibilityMap
    )
{
    TCHAR full9xKey[MAX_REGISTRY_KEY];
    TCHAR fullNtKey[MAX_REGISTRY_KEY];
    MIG_OBJECTSTRINGHANDLE handle = NULL;
    HKEY key = NULL;
    PCTSTR data;
    DWORD flags = 0;
    DWORD thisFlag;
    BOOL enabled;
    TCHAR buffer[32];

    __try {
        StringCopy (full9xKey, S_ACCESSIBILITY_ROOT TEXT("\\"));
        StringCopy (fullNtKey, full9xKey);
        StringCat (full9xKey, Win9xSubKey);
        StringCat (fullNtKey, NtSubKey);

        key = OpenRegKeyStr (full9xKey);
        if (!key) {
            __leave;
        }

        while (AccessibilityMap->ValueName) {
            //
            // Prohibit enum of this value
            //

            handle = IsmCreateObjectHandle (full9xKey, AccessibilityMap->ValueName);
            MYASSERT (handle);

            IsmProhibitPhysicalEnum (g_RegistryTypeId, handle, NULL, 0, NULL);
            HtAddString (g_ProhibitTable, handle);

            IsmDestroyObjectHandle (handle);
            handle = NULL;

            //
            // Update the emulated flags
            //

            data = GetRegValueString (key, AccessibilityMap->ValueName);
            if (data) {

                enabled = (_ttoi (data) != 0);
                thisFlag = (AccessibilityMap->FlagVal & (~SPECIAL_INVERT_OPTION));

                if (AccessibilityMap->FlagVal & SPECIAL_INVERT_OPTION) {
                    enabled = !enabled;
                }

                if (enabled) {
                    flags |= thisFlag;
                }

                FreeAlloc (data);
            }

            AccessibilityMap++;
        }

        //
        // Put the emulated value in the hash table
        //

        wsprintf (buffer, TEXT("%u"), flags);
        pStoreEmulatedSetting (fullNtKey, TEXT("Flags"), REG_SZ, (PBYTE) buffer, SizeOfString (buffer));
    }
    __finally {
        if (key) {
            CloseRegKey (key);
        }
    }
}


VOID
pFillTranslationTable (
    VOID
    )
{
    PACCESSIBILITY_MAPPINGS mappings;

    //
    // Loop through all flags that need translation. Disable enumeration of
    // the Win9x physical values and enable enumeration of the translated values
    // via population of the hash table.
    //

    mappings = g_AccessibilityMappings;

    while (mappings->AccessibilityMap) {

        pTranslateAccessibilityKey (
            mappings->Win9xSubKey,
            mappings->NtSubKey ? mappings->NtSubKey : mappings->Win9xSubKey,
            mappings->AccessibilityMap
            );

        mappings++;
    }

    //
    // Add all keys that have moved, ordered from most specific to least specific
    //

    // AutoRepeat values are transposed
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\KeyboardResponse"), TEXT("AutoRepeatDelay"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Response"), TEXT("AutoRepeatRate"),
        FALSE
        );

    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\KeyboardResponse"), TEXT("AutoRepeatRate"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Response"), TEXT("AutoRepeatDelay"),
        FALSE
        );

    // double c in DelayBeforeAcceptance value name
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\KeyboardResponse"), TEXT("DelayBeforeAcceptancce"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Response"), TEXT("DelayBeforeAcceptance"),
        FALSE
        );

    // add a space to the key name for the rest of the values
    pMoveAccessibilityKey (
        S_ACCESSIBILITY_ROOT TEXT("\\KeyboardResponse"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Response")
        );

    // change BaudRate to Baud & convert to DWORD
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\SerialKeys"), TEXT("BaudRate"),
        S_ACCESSIBILITY_ROOT TEXT("\\SerialKeys"), TEXT("Baud"),
        TRUE
        );

    // convert Flags to DWORD
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\SerialKeys"), TEXT("Flags"),
        S_ACCESSIBILITY_ROOT TEXT("\\SerialKeys"), TEXT("Flags"),
        TRUE
        );

    // add space between high and contrast
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\HighContrast"), TEXT("Pre-HighContrast Scheme"),
        S_ACCESSIBILITY_ROOT TEXT("\\HighContrast"), TEXT("Pre-High Contrast Scheme"),
        FALSE
        );

    // move two values from the root into their own subkeys
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT, TEXT("Blind Access"),
        S_ACCESSIBILITY_ROOT TEXT("\\Blind Access"), TEXT("On"),
        FALSE
        );

    pStoreEmulatedSetting (S_ACCESSIBILITY_ROOT TEXT("\\Blind Access"), NULL, 0, NULL, 0);

    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT, TEXT("Keyboard Preference"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Preference"), TEXT("On"),
        FALSE
        );

    pStoreEmulatedSetting (S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Preference"), NULL, 0, NULL, 0);

}


BOOL
WINAPI
AccessibilityEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL b = TRUE;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    if (ISWIN9X()) {
        g_RegistryTypeId = IsmGetObjectTypeId (S_REGISTRYTYPE);
        MYASSERT (g_RegistryTypeId);

        g_ProhibitTable = HtAlloc();
        MYASSERT (g_ProhibitTable);

        if (g_RegistryTypeId) {
            //
            // Add a callback for additional enumeration. If we are unable to do so, then
            // someone else is already doing something different for this key.
            //

            objectName = IsmCreateObjectHandle (S_ACCESSIBILITY_ROOT, NULL);

            b = IsmAddToPhysicalEnum (g_RegistryTypeId, objectName, EmulatedEnumCallback, 0);

            IsmDestroyObjectHandle (objectName);

            if (b) {
                //
                // Add a callback to acquire the data of the new physical objects
                //

                objectName = IsmCreateSimpleObjectPattern (
                                    S_ACCESSIBILITY_ROOT,
                                    TRUE,
                                    NULL,
                                    TRUE
                                    );

                b = IsmRegisterPhysicalAcquireHook (
                        g_RegistryTypeId,
                        objectName,
                        AcquireAccessibilityFlags,
                        ReleaseAccessibilityFlags,
                        0,
                        NULL
                        );

                IsmDestroyObjectHandle (objectName);
            }

            if (b) {

                //
                // Now load memdb with the current registry values and
                // prohibit the enumeration of Win9x values.
                //

                pFillTranslationTable ();
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "Not allowed to translate accessibility key"));
        }

        HtFree (g_ProhibitTable);
        g_ProhibitTable = NULL;
    }

    return b;
}


BOOL
WINAPI
EmulatedEnumCallback (
    IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      ULONG_PTR Arg,
    IN      BOOL Abort
    )
{
    PACCESSIBILITY_ENUM_STATE state = (PACCESSIBILITY_ENUM_STATE) ObjectEnum->EtmHandle;
    BOOL result = FALSE;
    BOOL cleanUpMemdb = TRUE;
    PCTSTR p;

    for (;;) {

        if (!Abort) {

            //
            // Begin or continue? If the EtmHandle is NULL, begin. Otherwise, continue.
            //

            if (!state) {
                state = (PACCESSIBILITY_ENUM_STATE) MemAllocUninit (sizeof (ACCESSIBILITY_ENUM_STATE));
                if (!state) {
                    MYASSERT (FALSE);
                    return FALSE;
                }

                ObjectEnum->EtmHandle = (LONG_PTR) state;

                result = MemDbEnumFirst (
                            &state->EnumStruct,
                            TEXT("~Accessibility\\*"),
                            ENUMFLAG_NORMAL,
                            1,
                            MEMDB_LAST_LEVEL
                            );

            } else {
                result = MemDbEnumNext (&state->EnumStruct);
            }

            //
            // If an item was found, populate the enum struct. Otherwise, set
            // Abort to TRUE to clean up.
            //

            if (result) {
                //
                // Test against pattern
                //

                if (!IsmParsedPatternMatch (ParsedPattern, 0, state->EnumStruct.KeyName)) {
                    continue;
                }

                MYASSERT ((ObjectEnum->ObjectTypeId & (~PLATFORM_MASK)) == g_RegistryTypeId);

                ObjectEnum->ObjectName = state->EnumStruct.KeyName;
                state->RegType = state->EnumStruct.Value;

                //
                // Fill in node, leaf and details
                //

                IsmDestroyObjectString (ObjectEnum->ObjectNode);
                IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
                IsmReleaseMemory (ObjectEnum->NativeObjectName);

                IsmCreateObjectStringsFromHandle (
                    ObjectEnum->ObjectName,
                    &ObjectEnum->ObjectNode,
                    &ObjectEnum->ObjectLeaf
                    );

                MYASSERT (ObjectEnum->ObjectNode);

                ObjectEnum->Level = 0;

                p = _tcschr (ObjectEnum->ObjectNode, TEXT('\\'));
                while (p) {
                    ObjectEnum->Level++;
                    p = _tcschr (p + 1, TEXT('\\'));
                }

                ObjectEnum->SubLevel = 0;

                if (ObjectEnum->ObjectLeaf) {
                    ObjectEnum->IsNode = FALSE;
                    ObjectEnum->IsLeaf = TRUE;
                } else {
                    ObjectEnum->IsNode = TRUE;
                    ObjectEnum->IsLeaf = FALSE;
                }

                if (state->RegType) {
                    ObjectEnum->Details.DetailsSize = sizeof (state->RegType);
                    ObjectEnum->Details.DetailsData = &state->RegType;
                } else {
                    ObjectEnum->Details.DetailsSize = 0;
                    ObjectEnum->Details.DetailsData = NULL;
                }

                //
                // Rely on base type to get the native object name
                //

                ObjectEnum->NativeObjectName = IsmGetNativeObjectName (
                                                    ObjectEnum->ObjectTypeId,
                                                    ObjectEnum->ObjectName
                                                    );


            } else {
                Abort = TRUE;
                cleanUpMemdb = FALSE;
            }
        }

        if (Abort) {
            //
            // Clean up our enum struct
            //

            if (state) {
                if (cleanUpMemdb) {
                    MemDbAbortEnum (&state->EnumStruct);
                }

                IsmDestroyObjectString (ObjectEnum->ObjectNode);
                ObjectEnum->ObjectNode = NULL;
                IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
                ObjectEnum->ObjectLeaf = NULL;
                IsmReleaseMemory (ObjectEnum->NativeObjectName);
                ObjectEnum->NativeObjectName = NULL;
                FreeAlloc (state);
            }

            // return value ignored in Abort case, and ObjectEnum is zeroed by the ISM
        }

        break;
    }

    return result;
}


BOOL
WINAPI
AcquireAccessibilityFlags(
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit,
    OUT     PMIG_CONTENT *NewObjectContent,         CALLER_INITIALIZED OPTIONAL
    IN      BOOL ReleaseContent,
    IN      ULONG_PTR Arg
    )
{
    BOOL result = TRUE;
    PDWORD details;
    PMIG_CONTENT ourContent;
    PCTSTR memdbNode;

    //
    // Is this object in our hash table?
    //

    if (ContentType == CONTENTTYPE_FILE) {
        DEBUGMSG ((DBG_ERROR, "Accessibility content cannot be saved to a file"));
        result = FALSE;
    } else {

        memdbNode = JoinPaths (TEXT("~Accessibility"), ObjectName);

        if (MemDbTestKey (memdbNode)) {

            //
            // Alloc updated content struct
            //

            ourContent = MemAllocZeroed (sizeof (MIG_CONTENT) + sizeof (DWORD));
            ourContent->EtmHandle = ourContent;
            details = (PDWORD) (ourContent + 1);

            //
            // Get the content from memdb
            //

            ourContent->MemoryContent.ContentBytes = MemDbGetUnorderedBlob (
                                                            memdbNode,
                                                            0,
                                                            &ourContent->MemoryContent.ContentSize
                                                            );

            if (ourContent->MemoryContent.ContentBytes) {
                MemDbGetValue (memdbNode, details);

                ourContent->Details.DetailsSize = sizeof (DWORD);
                ourContent->Details.DetailsData = details;

            } else {
                ourContent->MemoryContent.ContentSize = 0;

                ourContent->Details.DetailsSize = 0;
                ourContent->Details.DetailsData = NULL;
            }

            ourContent->ContentInFile = FALSE;

            //
            // Pass it to ISM
            //

            *NewObjectContent = ourContent;

        }

        FreePathString (memdbNode);
    }

    return result;      // always TRUE unless an error occurred
}

VOID
WINAPI
ReleaseAccessibilityFlags(
    IN      PMIG_CONTENT ObjectContent
    )
{
    //
    // This callback is called to free the content we allocated above.
    //

    if (ObjectContent->MemoryContent.ContentBytes) {
        MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    FreeAlloc ((PMIG_CONTENT) ObjectContent->EtmHandle);
}


BOOL
WINAPI
AccessibilitySourceInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    if (!g_RegistryTypeId) {
        g_RegistryTypeId = IsmGetObjectTypeId (S_REGISTRYTYPE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\dbaction.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dbaction.c

Abstract:

    This source implements action functions used by MigDb. There are two types
    of action functions here as the third parameter of the macro list is TRUE
    or FALSE.
    First type of action function is called whenever an action is triggered
    during file scanning. The second type of action function is called at the
    end of file scanning if the associated action was not triggered during
    file scanning phase.

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

  marcw     31-Aug-1999 Added BlockingHardware
  ovidiut   20-Jul-1999 Added Ignore
  ovidiut   28-May-1999 Added IniFileMappings
  marcw     23-Sep-1998 Added BlockingVirusScanner
  jimschm   13-Aug-1998 Added CompatibleFiles
  jimschm   19-May-1998 Added MinorProblems_NoLinkRequired
  jimschm   27-Feb-1998 Added UninstallSections
  calinn    18-Jan-1998 Added CompatibleModules action

--*/

#include "pch.h"
#include "logmsg.h"
#include "osfiles.h"

/*++

Macro Expansion List Description:

  GATHER_DATA_FUNCTIONS and ACTION_FUNCTIONS lists all valid actions to be performed
  by migdb when a context is met. Meeting a context means that all the sections
  associated with the context are satisfied (usually there is only one section).
  The difference is that GATHER_DATA_FUNCTIONS are called even if some function already
  handles a file.

Line Syntax:

   DEFMAC(ActionFn, ActionName, CallWhenTriggered, CanHandleVirtualFiles)

Arguments:

   ActionFn   - This is a boolean function that returnes TRUE if the specified action
                could be performed. It should return FALSE only if a serious error
                occures. You must implement a function with this name and required
                parameters.

   ActionName - This is the string that identifies the action function. It should
                have the same value as listed in migdb.inf.  This arg is declared
                as both a macro and the migdb.inf section name string.

   PatternFormat - The format in the INF for this section is the pattern format. The non
                pattern format is the file name followed by the attributes. The pattern
                format is the leaf pattern, node pattern and then the attributes.

   CallWhenTriggered - If the MigDbContext this action is associated with is triggered
                the action will be called if this field is TRUE, otherwise we will call
                the action at the end of file scan if the context was not triggered.

   CanHandleVirtualFiles - This is for treating files that are supposed to be in a fixed place
                but are not there (not installed or deleted). We need this in order to fix
                registry or links that point to this kind of files. A good example is backup.exe
                which is located in %ProgramFiles%\Accessories. The rules say that we should
                use ntbackup.exe instead but since this file is not existent we don't normalle fix
                registry settings pointing to this file. We do now, with this new variable

Variables Generated From List:

   g_ActionFunctions - do not touch!

For accessing the array there are the following functions:

   MigDb_GetActionAddr
   MigDb_GetActionIdx
   MigDb_GetActionName

--*/


/*
   Declare the macro list of action functions. If you need to add a new action just
   add a line in this list and implement the function.
*/
#define ACTION_FUNCTIONS        \
        DEFMAC(OsFiles,         TEXT("OsFiles"),            FALSE,  TRUE,   TRUE)  \
        DEFMAC(OsFiles,         TEXT("OsFilesPattern"),     TRUE,   TRUE,   TRUE)  \
        DEFMAC(NonCritical,     TEXT("NonCriticalFiles"),   TRUE,   TRUE,   TRUE)  \
        DEFMAC(OsFilesExcluded, TEXT("OsFilesExcluded"),    TRUE,   TRUE,   TRUE)  \


/*
   Declare the action functions
*/
#define DEFMAC(fn,id,pat,trig,call) ACTION_PROTOTYPE fn;
ACTION_FUNCTIONS
#undef DEFMAC


/*
   This is the structure used for handling action functions
*/
typedef struct {
    PCTSTR ActionName;
    PACTION_PROTOTYPE ActionFunction;
    BOOL PatternFormat;
    BOOL CallWhenTriggered;
    BOOL CallAlways;
} ACTION_STRUCT, *PACTION_STRUCT;


/*
   Declare a global array of functions and name identifiers for action functions
*/
#define DEFMAC(fn,id,pat,trig,call) {id,fn,pat,trig,call},
static ACTION_STRUCT g_ActionFunctions[] = {
                              ACTION_FUNCTIONS
                              {NULL, NULL, FALSE, FALSE, FALSE}
                              };
#undef DEFMAC

PACTION_PROTOTYPE
MigDb_GetActionAddr (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_GetActionAddr returns the address of the action function based on the action index

Arguments:

  ActionIdx - Action index.

Return value:

  Action function address. Note that no checking is made so the address returned could be invalid.
  This is not a problem since the parsing code did the right job.

--*/

{
    return g_ActionFunctions[ActionIdx].ActionFunction;
}

INT
MigDb_GetActionIdx (
    IN      PCTSTR ActionName
    )

/*++

Routine Description:

  MigDb_GetActionIdx returns the action index based on the action name

Arguments:

  ActionName - Action name.

Return value:

  Action index. If the name is not found, the index returned is -1.

--*/

{
    PACTION_STRUCT p = g_ActionFunctions;
    INT i = 0;
    while (p->ActionName != NULL) {
        if (StringIMatch (p->ActionName, ActionName)) {
            return i;
        }
        p++;
        i++;
    }
    return -1;
}

PCTSTR
MigDb_GetActionName (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_GetActionName returns the name of an action based on the action index

Arguments:

  ActionIdx - Action index.

Return value:

  Action name. Note that no checking is made so the returned pointer could be invalid.
  This is not a problem since the parsing code did the right job.

--*/

{
    return g_ActionFunctions[ActionIdx].ActionName;
}

BOOL
MigDb_IsPatternFormat (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_IsPatternFormat is called when we try to find what is the section format.

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the format is pattern like, FALSE otherwise.

--*/

{
    return g_ActionFunctions[ActionIdx].PatternFormat;
}

BOOL
MigDb_CallWhenTriggered (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_CallWhenTriggered is called every time when an action is triggered. Will return
  TRUE is the associated action function needs to be called, FALSE otherwise.

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the associated action function needs to be called, FALSE otherwise.

--*/

{
    return g_ActionFunctions[ActionIdx].CallWhenTriggered;
}

BOOL
MigDb_CallAlways (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_CallAlways returnes if an action should be called regardless of handled state.

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the associated action should be called every time.

--*/

{
    return g_ActionFunctions[ActionIdx].CallAlways;
}

BOOL
OsFiles (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when an OS file is found. Basically the file gets deleted to
  make room for NT version.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, (PCTSTR) Context->FileList.Buf)) {
        do {
            IsmSetAttributeOnObject (
                MIG_FILE_TYPE,
                fileEnum.CurrentString,
                g_OsFileAttribute
                );
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return TRUE;
}

BOOL
NonCritical (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when an non critical file is found.
  We are calling ISM to mark this file as NonCritical

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, (PCTSTR) Context->FileList.Buf)) {
        do {
            IsmMakeNonCriticalObject (
                MIG_FILE_TYPE,
                fileEnum.CurrentString
                );
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return TRUE;
}

BOOL
OsFilesExcluded (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when an file that is not an OS file is found.
  Since this file might have the OS file attribute (due to patterns in os files)
  we are calling ISM to remove the OsFile attribute from this file

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, (PCTSTR) Context->FileList.Buf)) {
        do {
            IsmClearAttributeOnObject (
                MIG_FILE_TYPE,
                fileEnum.CurrentString,
                g_OsFileAttribute
                );
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\renregfn.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    renregfn.c

Abstract:

    Implements code-based registry rename.

Author:

    Jim Schmidt (jimschm) 15-Sep-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_RENREGFN    "RenRegFn"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef VOID(RENREGFNINIT)(MIG_PLATFORMTYPEID);
typedef RENREGFNINIT *PRENREGFNINIT;

typedef BOOL (STDMETHODCALLTYPE RENAMERULE)(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    );
typedef RENAMERULE FAR *LPRENAMERULE;

//
// Globals
//

PTSTR g_DestIdentityGUID = NULL;
BOOL g_OERulesMigrated = FALSE;

//
// Macro expansion list
//

//
// DEFMAC(<script tag>, <enum callback>, <operation name>, <op init>, <operation callback>)
//
// It is assumed that <operation callback> is a tree filter (it can modify part of a path).
// The code does not currently support the contrary.
//

#define DEFAULT_ENUM        pDefaultRenRegFnQueueCallback
#define DEFAULT_INIT        pNulInit

#define RENAME_FUNCTIONS        \
    DEFMAC(ConvertOE4,          DEFAULT_ENUM, MOVE.ConvertOE4,          pConvertOE4Init,    pConvertOE4Move    ) \
    DEFMAC(ConvertOE4IAM,       DEFAULT_ENUM, MOVE.ConvertOE4IAM,       pConvertOE4Init,    pConvertOEIAMMove  ) \
    DEFMAC(ConvertOE5IAM,       DEFAULT_ENUM, MOVE.ConvertOE5IAM,       pConvertOE5IAMInit, pConvertOEIAMMove  ) \
    DEFMAC(ConvertOE5IdIAM,     DEFAULT_ENUM, MOVE.ConvertOE5IdIAM,     DEFAULT_INIT,       pConvertOEIdIAMMove) \
    DEFMAC(ConvertOE5MailRules, DEFAULT_ENUM, MOVE.ConvertOE5MailRules, DEFAULT_INIT,       pConvertOE5MailRulesMove) \
    DEFMAC(ConvertOE5NewsRules, DEFAULT_ENUM, MOVE.ConvertOE5NewsRules, DEFAULT_INIT,       pConvertOE5NewsRulesMove) \
    DEFMAC(ConvertOE5Block,     DEFAULT_ENUM, MOVE.ConvertOE5Block,     DEFAULT_INIT,       pConvertOE5BlockMove) \

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

//
// Declare special rename operation apply callback functions
//
#define DEFMAC(ifn,ec,opn,opi,opc) SGMENUMERATIONCALLBACK ec; RENREGFNINIT opi; OPMFILTERCALLBACK opc;
RENAME_FUNCTIONS
#undef DEFMAC

//
// This is the structure used for handling action functions
//
typedef struct {
    PCTSTR InfFunctionName;
    PSGMENUMERATIONCALLBACK EnumerationCallback;
    PCTSTR OperationName;
    MIG_OPERATIONID OperationId;
    PRENREGFNINIT OperationInit;
    POPMFILTERCALLBACK OperationCallback;
} RENAME_STRUCT, *PRENAME_STRUCT;

//
// Declare a global array of rename functions
//
#define DEFMAC(ifn,ec,opn,opi,opc) {TEXT("\\")TEXT(#ifn),ec,TEXT(#opn),0,opi,opc},
static RENAME_STRUCT g_RenameFunctions[] = {
                              RENAME_FUNCTIONS
                              {NULL, NULL, NULL, 0, NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//

VOID
pNulInit (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
}

UINT
pDefaultRenRegFnQueueCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PRENAME_STRUCT p = (PRENAME_STRUCT)CallerArg;

    IsmSetOperationOnObject (Data->ObjectTypeId, Data->ObjectName, p->OperationId, NULL, NULL);

    return CALLBACK_ENUM_CONTINUE;
}

PRENAME_STRUCT
pGetRenameStruct (
    IN      PCTSTR FunctionName
    )
{
    PRENAME_STRUCT p = g_RenameFunctions;
    INT i = 0;
    while (p->InfFunctionName != NULL) {
        if (StringIMatch (p->InfFunctionName, FunctionName)) {
            return p;
        }
        p++;
        i++;
    }
    return NULL;
}

VOID
InitSpecialRename (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PRENAME_STRUCT p = g_RenameFunctions;

    while (p->InfFunctionName) {
        p->OperationId = IsmRegisterOperation (p->OperationName, FALSE);
        if (Platform == PLATFORM_DESTINATION) {
            IsmRegisterOperationFilterCallback (p->OperationId, p->OperationCallback, TRUE, TRUE, FALSE);
        }

        p->OperationInit(Platform);
        p++;
    }
}

VOID
TerminateSpecialRename (
    VOID
    )
{
    if (g_DestIdentityGUID) {
        FreeText (g_DestIdentityGUID);
    }
}

BOOL
AddSpecialRenameRule (
    IN      PCTSTR Pattern,
    IN      PCTSTR Function
)
{
    PRENAME_STRUCT functionStruct = NULL;
    BOOL result = FALSE;

    functionStruct = pGetRenameStruct (Function);

    if (functionStruct) {
        result = IsmHookEnumeration (
            g_RegType,
            Pattern,
            functionStruct->EnumerationCallback?
                functionStruct->EnumerationCallback:
                pDefaultRenRegFnQueueCallback,
            (ULONG_PTR)functionStruct,
            functionStruct->InfFunctionName
            );
    } else {
        LOG ((
            LOG_ERROR,
            (PCSTR) MSG_DATA_RENAME_BAD_FN,
            Function,
            Pattern
            ));
    }

    return result;
}

BOOL
pProcessDataRenameSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR pattern;
    ENCODEDSTRHANDLE encodedPattern = NULL;
    PCTSTR functionName;
    BOOL result = FALSE;

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                pattern = InfGetStringField (InfStruct, 0);

                if (!pattern) {
                    continue;
                }
                encodedPattern = TurnRegStringIntoHandle (pattern, TRUE, NULL);

                functionName = InfGetStringField (InfStruct, 1);

                if (functionName) {
                    AddSpecialRenameRule(encodedPattern, functionName);
                } else {
                    LOG ((LOG_ERROR, (PCSTR) MSG_DATA_RENAME_NO_FN, pattern));
                }

                IsmDestroyObjectHandle (encodedPattern);
                encodedPattern = NULL;
            } while (InfFindNextLine (InfStruct));
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (InfStruct);
    }

    return result;
}

BOOL
DoRegistrySpecialRename (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pProcessDataRenameSection (&is, InfHandle, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (PLATFORM_SOURCE, &is, InfHandle, Section);

        if (osSpecificSection) {
            b = pProcessDataRenameSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}


//
// Helpers below
//

VOID
pConvertOE4Init (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    if (Platform == PLATFORM_DESTINATION &&
        IsmGetRealPlatform() == PLATFORM_DESTINATION &&
        IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE4_APPDETECT))
    {

        if (g_DestIdentityGUID != NULL) {
            // Already got it.. punt
            return;
        }

        // pull out the GUID from dest
        g_DestIdentityGUID = OEGetDefaultId (PLATFORM_DESTINATION);

        if (g_DestIdentityGUID == NULL)
        {
            // This is when we created a new user
            g_DestIdentityGUID = OECreateFirstIdentity();
        } else {
            // This is when applying to a user who never ran OE
            OEInitializeIdentity();
        }
    }
}

BOOL
WINAPI
pConvertOE4Move (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR ptr = NULL;
    MIG_OBJECTSTRINGHANDLE newName;

    if (g_DestIdentityGUID == NULL) {
        return FALSE;
    }

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);

    // srcNode should be "HKCU\Software\Microsoft\Outlook Express\..."

    if (!srcNode) {
        return FALSE;
    }

    ptr = (PTSTR)_tcsistr (srcNode, TEXT("\\Outlook Express"));
    if (!ptr) {
        return FALSE;
    }
    ptr += 16;

    newNode = JoinPathsInPoolEx ((
                    NULL,
                    TEXT("HKCU\\Identities"),
                    g_DestIdentityGUID,
                    TEXT("Software\\Microsoft\\Outlook Express\\5.0"),
                    ptr,
                    NULL
                    ));
    // newNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Outlook Express\5.0\..."

    newName = IsmCreateObjectHandle (newNode, srcLeaf);
    FreePathString (newNode);
    IsmDestroyObjectString (srcLeaf);
    IsmDestroyObjectString (srcNode);

    OutputData->NewObject.ObjectName = newName;

    return TRUE;
}

VOID
pConvertOE5IAMInit (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PTSTR srcAssocId;
    PTSTR newIdentity;

    if (Platform == PLATFORM_DESTINATION &&
        IsmGetRealPlatform() == PLATFORM_DESTINATION &&
        IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT))
    {
        // g_DestIdentityGUID should remain NULL if we do not want to remap the IAM tree
        // This is true when one of the following is true:
        // 1. Destination user profile has not been created yet
        // 2. When the IAM has not yet been initialized on the destination (assume that
        //    [AssociatedID] has not yet been written.. if this is not a valid assumption,
        //    compare to source's AssociatedID)
        // 3. The source's associated ID is being merged into the destination's associated ID

        if (g_DestIdentityGUID != NULL) {
            // Already got it.. punt
            return;
        }

        srcAssocId = OEGetAssociatedId (PLATFORM_SOURCE);
        if (srcAssocId) {
            newIdentity = OEGetRemappedId (srcAssocId);
            if (newIdentity) {
               // NOTE: OEIsIdentityAssociated checks to see if it's associated. If
               // the key does not exist, it automatically claims it and returns TRUE
               if (OEIsIdentityAssociated(newIdentity)) {
                   FreeText(newIdentity);
               } else {
                   g_DestIdentityGUID = newIdentity;
               }
            }
            FreeText(srcAssocId);
        }

        OEInitializeIdentity();
    }
}


BOOL
pConcatRuleIndex (
    IN      PCTSTR Node,
    IN      PCTSTR SearchStr
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PTSTR tmpNode;
    PTSTR ptr;
    TCHAR number[5];
    PTSTR newStr;

    // Node looks like "HKR\Identities\{GUID}\Software\Microsoft\Outlook Express\5.0\Rules\News\008\"
    // SearchStr looks like "\News\"

    tmpNode = DuplicateText(Node);
    if (tmpNode) {
        ptr = (PTSTR)_tcsistr (tmpNode, SearchStr);
        if (ptr) {
            ptr += TcharCount(SearchStr);
            StringCopyTcharCount(number, ptr, 4);
            number[4] = 0;
            *ptr = 0;

            // number should now look like "008"

            objectName = IsmCreateObjectHandle (tmpNode, TEXT("Order"));
            if (IsmAcquireObject(g_RegType | PLATFORM_DESTINATION,
                                 objectName,
                                 &objectContent)) {
                if (IsValidRegSz(&objectContent)) {

                    // Does this index already exist?
                    if (!_tcsistr ((PCTSTR)objectContent.MemoryContent.ContentBytes, number)) {

                        // Tack this onto the end of the data, separated by a space
                        newStr = IsmGetMemory (objectContent.MemoryContent.ContentSize + sizeof (TCHAR) + ByteCount (number));
                        StringCopy(newStr, (PCTSTR)objectContent.MemoryContent.ContentBytes);
                        StringCat(newStr, TEXT(" "));
                        StringCat(newStr, number);

                        IsmReleaseMemory(objectContent.MemoryContent.ContentBytes);
                        objectContent.MemoryContent.ContentSize = SizeOfString(newStr);
                        objectContent.MemoryContent.ContentBytes = (PCBYTE)newStr;

                        IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
                    }
                }
                IsmReleaseObject(&objectContent);
            }
            IsmDestroyObjectHandle(objectName);
        }
        FreeText(tmpNode);
    }
    return TRUE;
}

BOOL
pRenameEx
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    IN      PCTSTR PrevKey,
    IN      PCTSTR FormatStr,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL ZeroBase
    )
{
    BOOL result = FALSE;
    PTSTR patternNode;
    PTSTR tmpNode;
    PTSTR ptr;
    PTSTR searchStr;
    DWORD prevKeyLen;
    DWORD keySize = 1;
    MIG_FILTERINPUT filterInput;
    MIG_FILTEROUTPUT filterOutput;
    MIG_BLOB migBlob;
    MIG_BLOB zeroBaseBlob;
    PTSTR filteredNode = NULL;

    // This function basically manually generates a RenRegEx rule and runs the filter
    // Then for each base key it updates the associated [Order] key to add the new number, if needed

    // Rule keys are something like:
    //  HKR\Identities\{GUID}\Software\Microsoft\Outlook Express\5.0\Rules\Mail\000\*
    //  HKR\Identities\{GUID}\Software\Microsoft\Outlook Express\5.0\Rules\News\008\*
    //  HKR\Identities\{GUID}\Software\Microsoft\Outlook Express\5.0\Block Senders\Mail\Criteria\0AF\*
    // PrevKey is the string preceding the numbered key at the end. i.e. "Mail", "Criteria", etc

    tmpNode = DuplicateText(NewNode);
    if (tmpNode) {
        prevKeyLen = TcharCount(PrevKey);
        searchStr = AllocText(prevKeyLen + 3);
        if (searchStr) {
            _stprintf(searchStr, TEXT("\\%s\\"), PrevKey);

            ptr = (PTSTR)_tcsistr (tmpNode, searchStr);
            if (ptr) {
                ptr += (prevKeyLen + 2); // Advance to next portion
                *ptr = 0;
                ptr = _tcsinc(ptr);
                while (*ptr && *ptr != TEXT('\\')) {
                    ptr = _tcsinc(ptr);
                    keySize++;
                }

                patternNode = AllocText (CharCount (tmpNode) + (CharCount (FormatStr) - keySize));
                if (patternNode) {
                    StringCopy(patternNode, tmpNode);
                    StringCat(patternNode, FormatStr);
                    StringCat(patternNode, ptr);

                    filterInput.OriginalObject.ObjectTypeId = g_RegType;
                    filterInput.OriginalObject.ObjectName = IsmCreateObjectHandle (OldNode, NULL);
                    filterInput.CurrentObject.ObjectTypeId = g_RegType;
                    filterInput.CurrentObject.ObjectName = IsmCreateObjectHandle (OldNode, NULL);
                    migBlob.Type = BLOBTYPE_STRING;
                    migBlob.String = IsmCreateObjectHandle (patternNode, NULL);

                    if (ZeroBase) {
                        zeroBaseBlob.Type = BLOBTYPE_BINARY;
                        zeroBaseBlob.BinarySize = sizeof(PCBYTE);
                        zeroBaseBlob.BinaryData = (PCBYTE)TRUE;

                        FilterRenameExFilter (&filterInput, &filterOutput, NoRestoreObject, &zeroBaseBlob, &migBlob);
                    } else {
                        FilterRenameExFilter (&filterInput, &filterOutput, NoRestoreObject, NULL, &migBlob);
                    }

                    IsmDestroyObjectHandle (migBlob.String);
                    IsmDestroyObjectHandle (filterInput.CurrentObject.ObjectName);
                    IsmDestroyObjectHandle (filterInput.OriginalObject.ObjectName);

                    IsmCreateObjectStringsFromHandle (filterOutput.NewObject.ObjectName, &filteredNode, NULL);
                    IsmDestroyObjectHandle (filterOutput.NewObject.ObjectName);

                    OutputData->NewObject.ObjectName = IsmCreateObjectHandle (filteredNode, Leaf);

                    // If this is the root numeric key, then update the index
                    if (0 == *ptr) {
                        pConcatRuleIndex(filteredNode, searchStr);
                    }
                    FreeText (filteredNode);

                    FreeText(patternNode);
                }
            } else {
                OutputData->NewObject.ObjectName = IsmCreateObjectHandle (tmpNode, Leaf);
            }
            FreeText(searchStr);
        } else {
            OutputData->NewObject.ObjectName = IsmCreateObjectHandle (tmpNode, Leaf);
        }
        FreeText(tmpNode);
    }
    return TRUE;
}

BOOL
pRenameNewsRule
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    )
{
    return pRenameEx(OldNode, NewNode, Leaf, NoRestoreObject, TEXT("News"), TEXT("<%03x>"), OutputData, TRUE);
}

BOOL
pRenameMailRule
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    )
{
    return pRenameEx(OldNode, NewNode, Leaf, NoRestoreObject, TEXT("Mail"), TEXT("<%03x>"), OutputData, TRUE);
}

BOOL
pRenameBlockRule
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    )
{
    return pRenameEx(OldNode, NewNode, Leaf, NoRestoreObject, TEXT("Criteria"), TEXT("<%03x>"), OutputData, TRUE);
}



BOOL
pRenameAccount
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    )
{
    return pRenameEx(OldNode, NewNode, Leaf, NoRestoreObject, TEXT("Accounts"), TEXT("<%08d>"), OutputData, FALSE);
}

BOOL
WINAPI
pConvertOE5RulesMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      LPRENAMERULE fnRename
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR tmpText;
    TCHAR *endId;
    TCHAR *srcIdentity;
    PTSTR newIdentity;

    // Move tree and Merge account name
    // This function just changes the {GUID} to the new value, then calls fnRename to update the
    // numeric portion of the keyname

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);
    if (srcNode) {
        // srcNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Outlook Express\Rules\Mail\..."
        tmpText = DuplicateText(srcNode);
        if (tmpText) {
            srcIdentity = _tcschr(tmpText, TEXT('{'));
            if (srcIdentity) {
                endId = _tcschr(srcIdentity, TEXT('\\'));
                if (endId) {
                    *endId = 0;
                    endId = _tcsinc(endId);

                    // endId should be "Software\Microsoft\Outlook Express\Rules\Mail\..."
                    // srcIdentity should be "{GUID}"

                    newIdentity = OEGetRemappedId (srcIdentity);
                    if (newIdentity) {
                        newNode = JoinPathsInPoolEx ((
                                        NULL,
                                        TEXT("HKCU\\Identities"),
                                        newIdentity,
                                        endId,
                                        NULL
                                        ));

                        if (newNode) {
                            if (srcLeaf &&
                                !g_OERulesMigrated &&
                                !StringIMatch(srcLeaf, TEXT("Version"))) {
                                g_OERulesMigrated = TRUE;
                            }
                            fnRename(srcNode, newNode, srcLeaf, NoRestoreObject, OutputData);
                            FreePathString (newNode);
                        }
                        FreeText(newIdentity);
                    }
                }
            }
            FreeText(tmpText);
        }
        IsmDestroyObjectString (srcNode);
    }
    IsmDestroyObjectString (srcLeaf);

    return TRUE;
}

BOOL
WINAPI
pConvertOE5NewsRulesMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pConvertOE5RulesMove(InputData, OutputData, NoRestoreObject, pRenameNewsRule);
}

BOOL
WINAPI
pConvertOE5MailRulesMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pConvertOE5RulesMove(InputData, OutputData, NoRestoreObject, pRenameMailRule);
}

BOOL
WINAPI
pConvertOE5BlockMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pConvertOE5RulesMove(InputData, OutputData, NoRestoreObject, pRenameBlockRule);
}

BOOL
WINAPI
pConvertOEIdIAMMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR tmpText;
    TCHAR *endId;
    TCHAR *srcIdentity;
    PTSTR newIdentity;

    // Move tree and Merge account name

    // This moves the tree in one of the following ways:
    // 1. From Identities into HKCU\SoftwareMicrosoft\Internet Account Manager\
    // 2. From one Identity into another Identity (for merging case)
    // 3. From one Identity into the same Identity (nop)
    // In all cases, then call pRenameAccount to update the name (name is actually a DWORD index value)

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);
    if (srcNode) {
        // srcNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Internet Account Manager\..."
        tmpText = DuplicateText(srcNode);
        if (tmpText) {
            srcIdentity = _tcschr(tmpText, TEXT('{'));
            if (srcIdentity) {
                endId = _tcschr(srcIdentity, TEXT('\\'));
                if (endId) {
                    *endId = 0;
                    endId = _tcsinc(endId);

                    // endId should be "Software\Microsoft\Internet Account Manager\..."
                    // srcIdentity should be "{GUID}"

                    newIdentity = OEGetRemappedId (srcIdentity);
                    if (newIdentity) {
                        if (OEIsIdentityAssociated (newIdentity)) {
                            newNode = JoinPaths (TEXT("HKCU"), endId);
                            // newNode should be "HKCU\Software\Microsoft\Internet Account Manager\..."
                        } else {
                            newNode = JoinPathsInPoolEx ((
                                            NULL,
                                            TEXT("HKCU\\Identities"),
                                            newIdentity,
                                            endId,
                                            NULL
                                            ));
                        }

                        if (newNode) {
                            pRenameAccount(srcNode,
                                           newNode,
                                           srcLeaf,
                                           NoRestoreObject,
                                           OutputData);
                            FreePathString (newNode);
                        }
                        FreeText(newIdentity);
                    }
                }
            }
            FreeText(tmpText);
        }
        IsmDestroyObjectString (srcNode);
    }
    IsmDestroyObjectString (srcLeaf);

    return TRUE;
}

BOOL
WINAPI
pConvertOEIAMMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR filteredNode = NULL;
    PTSTR ptr = NULL;

    // Move tree and Merge account name

    // This moves the tree in one of the following ways:
    // 1. From HKCU\SoftwareMicrosoft\Internet Account Manager\ into an Identity
    // 2. From HKCU\SoftwareMicrosoft\Internet Account Manager\ into the same location (nop)
    // In all cases, then call pRenameAccount to update the name (name is actually a DWORD index value)

    // This might move the accounts from HKCU\Software\Microsoft\Internet Account Manager into an identity

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);
    if (srcNode) {
        // srcNode should be "HKCU\Software\Microsoft\Internet Account Manager\..."
        if (g_DestIdentityGUID != NULL &&
            !OEIsIdentityAssociated (g_DestIdentityGUID)) {

            ptr = _tcschr (srcNode, TEXT('\\'));
            if (ptr) {
                newNode = AllocText (TcharCount (srcNode) + TcharCount (g_DestIdentityGUID) + 13);
                StringCopy (newNode, TEXT("HKCU\\Identities\\"));    // +12
                StringCat (newNode, g_DestIdentityGUID);
                StringCat (newNode, ptr);

                // newNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Internet Account Manager\..."
            }
        } else {
            newNode = DuplicateText (srcNode);
        }

        if (newNode) {
            pRenameAccount(srcNode,
                           newNode,
                           srcLeaf,
                           NoRestoreObject,
                           OutputData);
            FreeText (newNode);
        }
        IsmDestroyObjectString (srcNode);
    }
    IsmDestroyObjectString (srcLeaf);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\cookies.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cookies.c

Abstract:

    Implements the cookies type module, which abstracts physical access to
    cookies, and queues all cookies to be migrated when the cookies component
    is enabled.

Author:

    Calin Negreanu (calinn) 11 July 2000

Revision History:

    jimschm 12-Oct-2000 Substantial redesign to work around several limiations
                        in wininet apis

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <wininet.h>

#define DBG_COOKIES     "Cookies"

//
// Strings
//

#define S_COOKIES_POOL_NAME     "Cookies"
#define S_COOKIES_NAME          TEXT("Cookies")
#define S_COOKIES_SHELL_FOLDER  TEXT("Cookies.CSIDL_COOKIES")

//
// Constants
//

#define MAX_COOKIE_FILE_SIZE    65536

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} COOKIES_ENUM, *PCOOKIES_ENUM;

//
// Globals
//

PMHANDLE g_CookiesPool = NULL;
BOOL g_DelayCookiesOp;
HASHTABLE g_CookiesTable;
MIG_OBJECTTYPEID g_CookieTypeId = 0;
GROWBUFFER g_CookieConversionBuff = INIT_GROWBUFFER;
PCTSTR g_Days[] = {
    TEXT("SUN"),
    TEXT("MON"),
    TEXT("TUE"),
    TEXT("WED"),
    TEXT("THU"),
    TEXT("FRI"),
    TEXT("SAT")
};

PCTSTR g_Months[] = {
    TEXT("JAN"),
    TEXT("FEB"),
    TEXT("MAR"),
    TEXT("APR"),
    TEXT("MAY"),
    TEXT("JUN"),
    TEXT("JUL"),
    TEXT("AUG"),
    TEXT("SEP"),
    TEXT("OCT"),
    TEXT("NOV"),
    TEXT("DEC")
};

typedef struct {
    PCTSTR Url;
    PCTSTR CookieName;
    PCTSTR CookieData;
    PCTSTR ExpirationString;
} COOKIE_ITEM, *PCOOKIE_ITEM;

typedef struct {
    // return value
    PCOOKIE_ITEM Item;

    // private enum members
    PCOOKIE_ITEM Array;
    UINT ArrayCount;
    UINT ArrayPos;
    INTERNET_CACHE_ENTRY_INFO *CacheEntry;
    HANDLE EnumHandle;
    GROWBUFFER CacheBuf;
    PMHANDLE Pool;

} COOKIE_ENUM, *PCOOKIE_ENUM;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstCookie;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextCookie;
TYPE_ABORTENUMPHYSICALOBJECT AbortCookieEnum;
TYPE_CONVERTOBJECTTOMULTISZ ConvertCookieToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToCookie;
TYPE_GETNATIVEOBJECTNAME GetNativeCookieName;
TYPE_ACQUIREPHYSICALOBJECT AcquireCookie;
TYPE_RELEASEPHYSICALOBJECT ReleaseCookie;
TYPE_DOESPHYSICALOBJECTEXIST DoesCookieExist;
TYPE_REMOVEPHYSICALOBJECT RemoveCookie;
TYPE_CREATEPHYSICALOBJECT CreateCookie;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertCookieContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertCookieContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedCookieContent;

BOOL
pEnumNextCookie (
    IN OUT  PCOOKIE_ENUM EnumPtr
    );

VOID
pAbortCookieEnum (
    IN      PCOOKIE_ENUM EnumPtr        ZEROED
    );

//
// Code
//

BOOL
CookiesInitialize (
    VOID
    )

/*++

Routine Description:

  CookiesInitialize is the ModuleInitialize entry point for the cookies
  module.

Arguments:

  None.

Return Value:

  TRUE if init succeeded, FALSE otherwise.

--*/

{
    g_CookiesTable = HtAllocEx (
                        CASE_SENSITIVE,
                        sizeof (PCTSTR),
                        DEFAULT_BUCKET_SIZE
                        );

    if (!g_CookiesTable) {
        return FALSE;
    }

    g_CookiesPool = PmCreateNamedPool (S_COOKIES_POOL_NAME);
    return (g_CookiesPool != NULL);
}


VOID
CookiesTerminate (
    VOID
    )

/*++

Routine Description:

  CookiesTerminate is the ModuleTerminate entry point for the cookies module.

Arguments:

  None.

Return Value:

  None.

--*/

{
    GbFree (&g_CookieConversionBuff);

    if (g_CookiesTable) {
        HtFree (g_CookiesTable);
        g_CookiesTable = NULL;
    }

    if (g_CookiesPool) {
        PmEmptyPool (g_CookiesPool);
        PmDestroyPool (g_CookiesPool);
        g_CookiesPool = NULL;
    }
}


VOID
WINAPI
CookiesEtmNewUserCreated (
    IN      PCTSTR UserName,
    IN      PCTSTR DomainName,
    IN      PCTSTR UserProfileRoot,
    IN      PSID UserSid
    )

/*++

Routine Description:

  CookiesEtmNewUserCreated is a callback that gets called when a new user
  account is created. In this case, we must delay the apply of cookies,
  because we can only apply to the current user.

Arguments:

  UserName        - Specifies the name of the user being created
  DomainName      - Specifies the NT domain name for the user (or NULL for no
                    domain)
  UserProfileRoot - Specifies the root path to the user profile directory
  UserSid         - Specifies the user's SID

Return Value:

  None.

--*/

{
    // a new user was created, the cookies operations need to be delayed
    CookiesTerminate ();
    g_DelayCookiesOp = TRUE;
}


BOOL
pGetCookiesPath (
    OUT     PTSTR Buffer
    )

/*++

Routine Description:

  pGetCookiesPath retreives the path to CSIDL_COOKIES. This path is needed
  for registration of a static exclusion (so that .txt files in CSIDL_COOKIES
  do not get processed).

Arguments:

  Buffer - Receives the path

Return Value:

  TRUE if the cookies directory was obtained, FALSE otherwise.

--*/

{
    HRESULT result;
    LPITEMIDLIST pidl;
    BOOL b;
    LPMALLOC malloc;

    result = SHGetMalloc (&malloc);
    if (result != S_OK) {
        return FALSE;
    }

    result = SHGetSpecialFolderLocation (NULL, CSIDL_COOKIES, &pidl);

    if (result != S_OK) {
        return FALSE;
    }

    b = SHGetPathFromIDList (pidl, Buffer);

    IMalloc_Free (malloc, pidl);

    return b;
}



/*++

  The following routines parse a cookie TXT file (specifically, the wininet
  form of a cookie file). They are fairly straight-forward.

--*/


BOOL
pGetNextLineFromFile (
    IN OUT  PCSTR *CurrentPos,
    OUT     PCSTR *LineStart,
    OUT     PCSTR *LineEnd,
    IN      PCSTR FileEnd
    )
{
    PCSTR pos;

    pos = *CurrentPos;
    *LineEnd = NULL;

    //
    // Find the first non-whitespace character
    //

    while (pos < FileEnd) {
        if (!_ismbcspace (_mbsnextc (pos))) {
            break;
        }

        pos = _mbsinc (pos);
    }

    *LineStart = pos;

    //
    // Find the end
    //

    if (pos < FileEnd) {
        pos = _mbsinc (pos);

        while (pos < FileEnd) {
            if (*pos == '\r' || *pos == '\n') {
                break;
            }

            pos = _mbsinc (pos);
        }

        *LineEnd = pos;
    }

    *CurrentPos = pos;

    return *LineEnd != NULL;
}


PCTSTR
pConvertStrToTchar (
    IN      PMHANDLE Pool,          OPTIONAL
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
#ifdef UNICODE
    return DbcsToUnicodeN (Pool, Start, CharCountABA (Start, End));
#else

    PTSTR dupStr;

    dupStr = AllocTextEx (Pool, (HALF_PTR) ((PBYTE) End - (PBYTE) Start) + 1);
    StringCopyAB (dupStr, Start, End);

    return dupStr;

#endif
}


VOID
pFreeUtilString (
    IN      PCTSTR String
    )
{
#ifdef UNICODE
    FreeConvertedStr (String);
#else
    FreeText (String);
#endif
}


PCOOKIE_ITEM
pGetCookiesFromFile (
    IN      PCTSTR LocalFileName,
    IN      PMHANDLE CookiePool,
    OUT     UINT *ItemCount
    )
{
    LONGLONG fileSize;
    HANDLE file;
    HANDLE map;
    PCSTR cookieFile;
    PCSTR currentPos;
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR endOfFile;
    PCTSTR convertedStr;
    PCTSTR cookieName;
    PCTSTR cookieData;
    PCTSTR cookieUrl;
    GROWBUFFER tempBuf = INIT_GROWBUFFER;
    PCOOKIE_ITEM cookieArray;
    BOOL b;
    FILETIME expireTime;
    SYSTEMTIME cookieSysTime;
    TCHAR dateBuf[64];
    PTSTR dateBufEnd;

    // Let's check the size of the file. We don't want a malformed cookie
    // file to force us to map a huge file into memory.
    fileSize = BfGetFileSize (LocalFileName);
    if (fileSize > MAX_COOKIE_FILE_SIZE) {
        return NULL;
    }

    cookieFile = MapFileIntoMemory (LocalFileName, &file, &map);
    if (!cookieFile) {
        return NULL;
    }

    //
    // Parse the file
    //

    endOfFile = cookieFile + GetFileSize (file, NULL);
    currentPos = cookieFile;

    do {
        //
        // Get the cookie name, cookie data, and url. Then skip a line. Then
        // get the expiration low and high values.
        //

        // cookie name
        b = pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            cookieName = pConvertStrToTchar (CookiePool, lineStart, lineEnd);
        }

        // cookie data
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            cookieData = pConvertStrToTchar (CookiePool, lineStart, lineEnd);
        }

        // url
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            convertedStr = pConvertStrToTchar (NULL, lineStart, lineEnd);
            cookieUrl = JoinTextEx (CookiePool, TEXT("http://"), convertedStr, NULL, 0, NULL);
            pFreeUtilString (convertedStr);
        }

        // don't care about the next line
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);

        // low DWORD for expire time
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            convertedStr = pConvertStrToTchar (NULL, lineStart, lineEnd);
            expireTime.dwLowDateTime = _tcstoul (convertedStr, NULL, 10);
            pFreeUtilString (convertedStr);
        }

        // high DWORD for expire time
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            convertedStr = pConvertStrToTchar (NULL, lineStart, lineEnd);
            expireTime.dwHighDateTime = _tcstoul (convertedStr, NULL, 10);
            pFreeUtilString (convertedStr);

            //
            // Got the cookie; now find a "*" line (the terminator for the cookie)
            //

            while (pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile)) {
                if (StringMatchABA ("*", lineStart, lineEnd)) {
                    break;
                }
            }

            //
            // Create an expiration string
            //

            if (FileTimeToSystemTime (&expireTime, &cookieSysTime)) {
                //
                // Need to make something like this: "expires = Sat, 01-Jan-2000 00:00:00 GMT"
                //

                dateBufEnd = StringCopy (dateBuf, TEXT("expires = "));

                dateBufEnd += wsprintf (
                                    dateBufEnd,
                                    TEXT("%s, %02u-%s-%04u %02u:%02u:%02u GMT"),
                                    g_Days[cookieSysTime.wDayOfWeek],
                                    (UINT) cookieSysTime.wDay,
                                    g_Months[cookieSysTime.wMonth - 1],
                                    (UINT) cookieSysTime.wYear,
                                    cookieSysTime.wHour,
                                    cookieSysTime.wMinute,
                                    cookieSysTime.wSecond
                                    );
            } else {
                *dateBuf = 0;
            }

            //
            // Add an entry to the array of cookie items
            //

            cookieArray = (PCOOKIE_ITEM) GbGrow (&tempBuf, sizeof (COOKIE_ITEM));

            cookieArray->Url = cookieUrl;
            cookieArray->CookieName = cookieName;
            cookieArray->CookieData = cookieData;
            cookieArray->ExpirationString = PmDuplicateString (CookiePool, dateBuf);
        }

    } while (b);

    //
    // Transfer array to caller's pool
    //

    *ItemCount = tempBuf.End / sizeof (COOKIE_ITEM);

    if (tempBuf.End) {
        cookieArray = (PCOOKIE_ITEM) PmDuplicateMemory (CookiePool, tempBuf.Buf, tempBuf.End);
    } else {
        cookieArray = NULL;
    }

    //
    // Clean up
    //

    GbFree (&tempBuf);

    UnmapFile (cookieFile, map, file);

    return cookieArray;
}


MIG_OBJECTSTRINGHANDLE
pCreateCookieHandle (
    IN      PCTSTR Url,
    IN      PCTSTR CookieName
    )

/*++

Routine Description:

  pCreateCookieHandle generates a MIG_OBJECTSTRINGHANDLE for a cookie object.
  This routine decorates the CookieName leaf so that case is preserved.

Arguments:

  Url        - Specifies the node portion (the URL associated with the cookie)
  CookieName - Specifies the case-sensitive name of the cookie

Return Value:

  A handle to the cookie object (which may be cast to a PCTSTR), or NULL if
  an error occurs.

--*/

{
    PTSTR buffer;
    PTSTR p;
    PCTSTR q;
    MIG_OBJECTSTRINGHANDLE result;
    CHARTYPE ch;

    //
    // Cobra object strings are case-insensitive, but CookieName is not. Here
    // we convert CookieName into all lower-case, decorating with a caret to
    // indicate uppercase
    //

    buffer = AllocText (TcharCount (CookieName) * 2 + 1);

    q = CookieName;
    p = buffer;

    while (*q) {
        ch = (CHARTYPE) _tcsnextc (q);

        if (_istupper (ch) || ch == TEXT('#')) {
            *p++ = TEXT('#');
        }

#ifndef UNICODE
        if (IsLeadByte (q)) {
            *p++ = *q++;
        }
#endif

        *p++ = *q++;
    }

    *p = 0;
    CharLower (buffer);

    result = IsmCreateObjectHandle (Url, buffer);

    FreeText (buffer);

    return result;
}


BOOL
pCreateCookieStrings (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PCTSTR *Url,
    OUT     PCTSTR *Cookie
    )

/*++

Routine Description:

  pCreateCookieStrings converts an object handle into the URL and cookie name
  strings. It performs decoding of the decoration needed to support
  case-sensitive cookie names.

Arguments:

  ObjectName - Specifies the encoded object name
  Url        - Receives the URL string, unencoded
  Cookie     - Receives the cookie name, unencoded

Return Value:

  TRUE of the object was converted to strings, FALSE otherwise. The caller
  must call pDestroyCookieStrings to clean up Url and Cookie.

--*/

{
    PCTSTR node;
    PCTSTR leaf;
    PTSTR buffer;
    PTSTR p;
    PCTSTR q;
    PTSTR p2;

    //
    // Cobra object strings are case-insensitive, but CookieName is not.
    // Therefore, we must convert the string from an encoded lowercase format
    // into the original form.
    //

    IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf);

    if (!node || !leaf) {
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);

        return FALSE;
    }

    *Url = node;

    //
    // Decode Cookie
    //

    buffer = AllocText (TcharCount (leaf) + 1);
    CharLower ((PTSTR) leaf);

    q = leaf;
    p = buffer;

    while (*q) {
        if (_tcsnextc (q) == TEXT('#')) {
            q = _tcsinc (q);
            if (*q == 0) {
                break;
            }

            p2 = p;
        } else {
            p2 = NULL;
        }

#ifndef UNICODE
        if (IsLeadByte (q)) {
            *p++ = *q++;
        }
#endif

        *p++ = *q++;

        if (p2) {
            *p = 0;
            CharUpper (p2);
        }
    }

    *p = 0;
    *Cookie = buffer;
    IsmDestroyObjectString (leaf);

    return TRUE;
}


VOID
pDestroyCookieStrings (
    IN      PCTSTR Url,
    IN      PCTSTR CookieName
    )
{
    IsmDestroyObjectString (Url);
    FreeText (CookieName);
}

VOID
pAbortCookieEnum (
    IN      PCOOKIE_ENUM EnumPtr        ZEROED
    )
{
    if (EnumPtr->Pool) {
        GbFree (&EnumPtr->CacheBuf);

        if (EnumPtr->EnumHandle) {
            FindCloseUrlCache (EnumPtr->EnumHandle);
        }

        PmDestroyPool (EnumPtr->Pool);
    }


    ZeroMemory (EnumPtr, sizeof (COOKIE_ENUM));
}



/*++

  The following enumeration routines enumerate the current user's cookies on
  the physical machine. They use wininet apis as much as possible, but
  they have to parse cookie TXT files because of api limitations.

--*/

BOOL
pEnumFirstCookie (
    OUT     PCOOKIE_ENUM EnumPtr
    )
{
    DWORD size;
    BOOL b = FALSE;

    ZeroMemory (EnumPtr, sizeof (COOKIE_ENUM));
    EnumPtr->Pool = PmCreatePoolEx (512);

    size = EnumPtr->CacheBuf.End;

    EnumPtr->EnumHandle = FindFirstUrlCacheEntry (TEXT("cookie:"), NULL, &size);

    if (!EnumPtr->EnumHandle) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            EnumPtr->CacheEntry = (INTERNET_CACHE_ENTRY_INFO *) GbGrow (&EnumPtr->CacheBuf, size);
            MYASSERT (EnumPtr->CacheEntry);

            EnumPtr->EnumHandle = FindFirstUrlCacheEntry (
                                        TEXT("cookie:"),
                                        EnumPtr->CacheEntry,
                                        &size
                                        );

            if (EnumPtr->EnumHandle) {
                b = TRUE;
            }
        }
    }

    if (!b) {
        pAbortCookieEnum (EnumPtr);
        return FALSE;
    }

    return pEnumNextCookie (EnumPtr);
}


BOOL
pEnumNextCookie (
    IN OUT  PCOOKIE_ENUM EnumPtr
    )
{
    DWORD size;
    BOOL b;
    INTERNET_CACHE_ENTRY_INFO *cacheEntry = EnumPtr->CacheEntry;

    for (;;) {

        //
        // Is the cookie array empty? If so, fill it now.
        //

        if (!EnumPtr->ArrayCount) {

            if (!cacheEntry) {
                return FALSE;
            }

            EnumPtr->Array = pGetCookiesFromFile (
                                cacheEntry->lpszLocalFileName,
                                EnumPtr->Pool,
                                &EnumPtr->ArrayCount
                                );

            if (EnumPtr->Array) {
                //
                // Array was filled. Return the first item.
                //

                EnumPtr->Item = EnumPtr->Array;
                EnumPtr->ArrayPos = 1;
                return TRUE;
            }

            DEBUGMSG ((DBG_ERROR, "Unable to get cookies from %s", cacheEntry->lpszLocalFileName));

        } else if (EnumPtr->ArrayPos < EnumPtr->ArrayCount) {
            //
            // Another element in the array is available. Return it.
            //

            EnumPtr->Item = &EnumPtr->Array[EnumPtr->ArrayPos];
            EnumPtr->ArrayPos++;
            return TRUE;
        }

        //
        // Current local file enumeration is done. Now get the next local file.
        //

        EnumPtr->ArrayCount = 0;
        PmEmptyPool (EnumPtr->Pool);

        size = EnumPtr->CacheBuf.End;

        b = FindNextUrlCacheEntry (
                EnumPtr->EnumHandle,
                (INTERNET_CACHE_ENTRY_INFO *) EnumPtr->CacheBuf.Buf,
                &size
                );

        if (!b) {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

                EnumPtr->CacheBuf.End = 0;

                EnumPtr->CacheEntry = (INTERNET_CACHE_ENTRY_INFO *) GbGrow (&EnumPtr->CacheBuf, size);
                MYASSERT (EnumPtr->CacheEntry);

                b = FindNextUrlCacheEntry (
                        EnumPtr->EnumHandle,
                        (INTERNET_CACHE_ENTRY_INFO *) EnumPtr->CacheBuf.Buf,
                        &size
                        );
            }
        }

        if (!b) {
            //
            // Enumeration is complete
            //

            break;
        }
    }

    pAbortCookieEnum (EnumPtr);
    return FALSE;
}


VOID
pAddCookieToHashTable (
    IN OUT  PGROWBUFFER TempBuf,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR Url,
    IN      PCTSTR CookieName,
    IN      PCTSTR CookieData,
    IN      PCTSTR ExpirationString
    )

/*++

Routine Description:

  pAddCookieToHashTable puts a cookie in a hash table that is used for cache
  purposes. Cookies cannot be read easily in a random order. Therefore, a
  hash table is used to store each cookie. This routine adds the cookie to
  the hash table, complete with its URL, cookie name, cookie data and
  expiration string.

Arguments:

  TempBuf          - Specifies an initialized grow buffer used for temporary
                     memory allocations, receives undefined temporary data.
  ObjectName       - Specifies the cookie URL and name
  Url              - Specifies the cookie URL (unencoded)
  CookieName       - Specifies the cookie name (unencoded)
  CookieData       - Specifies the cookie data string
  ExpirationString - Specifies the cookie expiration date, in string format

Return Value:

  None.

--*/

{
    PCTSTR dupData;

    //
    // Write the cookie to the hash table. The object string is stored in the
    // hash table, along with a pointer to the cookie data and expiration
    // string. The cookie data and expieration string are kept in a separate
    // pool.
    //

    if (!HtFindString (g_CookiesTable, ObjectName)) {
        TempBuf->End = 0;

        GbMultiSzAppend (TempBuf, CookieData);
        GbMultiSzAppend (TempBuf, ExpirationString);

        dupData = (PCTSTR) PmDuplicateMemory (g_CookiesPool, TempBuf->Buf, TempBuf->End);
        HtAddStringAndData (g_CookiesTable, ObjectName, &dupData);
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "Cookie already in the hash table: %s:%s", Url, CookieName));
}


BOOL
pLoadCookiesData (
    VOID
    )

/*++

Routine Description:

  pLoadCookieData fills the hash table with all of the current user's
  cookies. The hash table is later used to drive enumeration, to acquire the
  cookie, and to test its existence.

Arguments:

  None.

Return Value:

  TRUE if the cookie cache was filled, FALSE otherwise.

--*/

{
    COOKIE_ENUM e;
    GROWBUFFER tempBuf = INIT_GROWBUFFER;
    MIG_OBJECTSTRINGHANDLE objectName;

    if (pEnumFirstCookie (&e)) {

        do {
            //
            // Store the cookie in a hash table (used for caching)
            //

            objectName = pCreateCookieHandle (e.Item->Url, e.Item->CookieName);

            pAddCookieToHashTable (
                &tempBuf,
                objectName,
                e.Item->Url,
                e.Item->CookieName,
                e.Item->CookieData,
                e.Item->ExpirationString
                );

            IsmDestroyObjectHandle (objectName);

        } while (pEnumNextCookie (&e));
    }

    GbFree (&tempBuf);

    return TRUE;
}


BOOL
WINAPI
CookiesEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesEtmInitialize initializes the physical type module aspect of this
  code. The ETM module is responsible for abstracting all access to cookies.

Arguments:

  Platform    - Specifies the platform that the type is running on
                (PLATFORM_SOURCE or PLATFORM_DESTINATION)
  LogCallback - Specifies the arg to pass to the central logging mechanism
  Reserved    - Unused

Return Value:

  TRUE if initialization succeeded, FALSE otherwise.

--*/

{
    TYPE_REGISTER cookieTypeData;
    TCHAR cookiesDir[MAX_PATH];
    MIG_OBJECTSTRINGHANDLE handle;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    //
    // Initialize a hash table of all cookies
    //

    pLoadCookiesData ();

    //
    // Exclude the cookies .txt files from other processing
    //

    if (Platform == PLATFORM_SOURCE) {
        if (pGetCookiesPath (cookiesDir)) {

            handle = IsmCreateObjectHandle (cookiesDir, NULL);
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, handle);
            IsmSetEnvironmentString (PLATFORM_SOURCE, NULL, S_COOKIES_SHELL_FOLDER, handle);
            IsmDestroyObjectHandle (handle);
        }
        ELSE_DEBUGMSG ((DBG_COOKIES, "Unable to get cookies path"));
    } else {
        if (IsmCopyEnvironmentString (PLATFORM_SOURCE, NULL, S_COOKIES_SHELL_FOLDER, cookiesDir)) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, cookiesDir);
        }
    }

    //
    // Register the type module callbacks
    //

    ZeroMemory (&cookieTypeData, sizeof (TYPE_REGISTER));
    cookieTypeData.Priority = PRIORITY_COOKIE;

    if (Platform != PLATFORM_SOURCE) {
        cookieTypeData.RemovePhysicalObject = RemoveCookie;
        cookieTypeData.CreatePhysicalObject = CreateCookie;
    }

    cookieTypeData.DoesPhysicalObjectExist = DoesCookieExist;
    cookieTypeData.EnumFirstPhysicalObject = EnumFirstCookie;
    cookieTypeData.EnumNextPhysicalObject = EnumNextCookie;
    cookieTypeData.AbortEnumPhysicalObject = AbortCookieEnum;
    cookieTypeData.ConvertObjectToMultiSz = ConvertCookieToMultiSz;
    cookieTypeData.ConvertMultiSzToObject = ConvertMultiSzToCookie;
    cookieTypeData.GetNativeObjectName = GetNativeCookieName;
    cookieTypeData.AcquirePhysicalObject = AcquireCookie;
    cookieTypeData.ReleasePhysicalObject = ReleaseCookie;
    cookieTypeData.ConvertObjectContentToUnicode = ConvertCookieContentToUnicode;
    cookieTypeData.ConvertObjectContentToAnsi = ConvertCookieContentToAnsi;
    cookieTypeData.FreeConvertedObjectContent = FreeConvertedCookieContent;

    g_CookieTypeId = IsmRegisterObjectType (
                            S_COOKIES_NAME,
                            TRUE,
                            FALSE,
                            &cookieTypeData
                            );

    MYASSERT (g_CookieTypeId);
    return TRUE;
}


BOOL
WINAPI
CookiesSgmParse (
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesSgmParse registers a component with the engine.

Arguments:

  Reserved - Unused.

Return Value:

  Always TRUE.

--*/

{
    TCHAR cookiesDir[MAX_PATH];

    IsmAddComponentAlias (
        TEXT("$Browser"),
        MASTERGROUP_SYSTEM,
        S_COOKIES_NAME,
        COMPONENT_SUBCOMPONENT,
        FALSE
        );


    if (pGetCookiesPath (cookiesDir)) {
        IsmAddComponentAlias (
            S_COOKIES_NAME,
            MASTERGROUP_SYSTEM,
            cookiesDir,
            COMPONENT_FOLDER,
            FALSE
            );
    }

    return TRUE;
}


BOOL
WINAPI
CookiesSgmQueueEnumeration (
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesSgmQueueEnumeration queues all cookies to be processed if the
  cookies component is selected.

Arguments:

  Reserved - Unused

Return Value:

  Always TRUE.

--*/

{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_COOKIES_NAME, COMPONENT_SUBCOMPONENT)) {
        return TRUE;
    }

    //
    // Use the ISM's build-in callback
    //

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmQueueEnumeration (
        g_CookieTypeId,
        pattern,
        NULL,
        QUEUE_MAKE_APPLY|QUEUE_OVERWRITE_DEST|QUEUE_MAKE_NONCRITICAL,
        S_COOKIES_NAME
        );

    IsmDestroyObjectHandle (pattern);

    return TRUE;
}


BOOL
WINAPI
CookiesSourceInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesSourceInitialize initializes the SGM module.

Arguments:

  LogCallback - Specifies the argument to pass to the log APIs
  Reserved    - Unused

Return Value:

  Always TRUE.

--*/

{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}


BOOL
CookiesVcmQueueEnumeration (
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesVcmQueueEnumeration is similar to the SGM queue enumeration, except
  that it only marks cookies as persistent. There is no need to set
  destination priority or apply here.

Arguments:

  Reserved - Unused

Return Value:

  Always TRUE.

--*/

{
    if (!IsmIsComponentSelected (S_COOKIES_NAME, COMPONENT_SUBCOMPONENT)) {
        return TRUE;
    }

    IsmQueueEnumeration (g_CookieTypeId, NULL, NULL, QUEUE_MAKE_PERSISTENT|QUEUE_MAKE_NONCRITICAL, NULL);

    return TRUE;
}


/*++

  The following enumeration routines are the ETM entry points. They rely
  on the enumeration routines above to access the physical machine.

--*/


BOOL
pEnumCookieWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PCOOKIES_ENUM CookieEnum
    )
{
    PCTSTR expiresStr;

    //
    // Clean up previous enum resources
    //

    pDestroyCookieStrings (EnumPtr->ObjectNode, EnumPtr->ObjectLeaf);
    EnumPtr->ObjectNode = NULL;
    EnumPtr->ObjectLeaf = NULL;

    IsmReleaseMemory (EnumPtr->NativeObjectName);
    EnumPtr->NativeObjectName = NULL;

    //
    // Find the next match
    //

    for (;;) {
        EnumPtr->ObjectName = CookieEnum->HashData.String;

        if (ObsPatternMatch (CookieEnum->Pattern, EnumPtr->ObjectName)) {
            break;
        }

        if (!EnumNextHashTableString (&CookieEnum->HashData)) {
            AbortCookieEnum (EnumPtr);
            return FALSE;
        }
    }

    //
    // Fill the caller's structure and return success
    //

    if (!pCreateCookieStrings (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf)) {
        return FALSE;
    }

    EnumPtr->NativeObjectName = GetNativeCookieName (EnumPtr->ObjectName);
    EnumPtr->Level = 1;
    EnumPtr->SubLevel = 0;
    EnumPtr->IsLeaf = TRUE;
    EnumPtr->IsNode = TRUE;

    expiresStr = *((PCTSTR *) CookieEnum->HashData.ExtraData);
    expiresStr = GetEndOfString (expiresStr) + 1;

    EnumPtr->Details.DetailsSize = SizeOfString (expiresStr);
    EnumPtr->Details.DetailsData = (PCBYTE) expiresStr;

    return TRUE;
}


BOOL
EnumFirstCookie (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PCOOKIES_ENUM cookieEnum = NULL;

    if (!g_CookiesTable) {
        return FALSE;
    }

    cookieEnum = (PCOOKIES_ENUM) PmGetMemory (g_CookiesPool, sizeof (COOKIES_ENUM));
    cookieEnum->Pattern = PmDuplicateString (g_CookiesPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) cookieEnum;

    if (EnumFirstHashTableString (&cookieEnum->HashData, g_CookiesTable)) {
        return pEnumCookieWorker (EnumPtr, cookieEnum);
    } else {
        AbortCookieEnum (EnumPtr);
        return FALSE;
    }
}


BOOL
EnumNextCookie (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PCOOKIES_ENUM cookieEnum = NULL;

    cookieEnum = (PCOOKIES_ENUM)(EnumPtr->EtmHandle);
    if (!cookieEnum) {
        return FALSE;
    }

    if (EnumNextHashTableString (&cookieEnum->HashData)) {
        return pEnumCookieWorker (EnumPtr, cookieEnum);
    } else {
        AbortCookieEnum (EnumPtr);
        return FALSE;
    }
}


VOID
AbortCookieEnum (
    IN      PMIG_TYPEOBJECTENUM EnumPtr             ZEROED
    )
{
    PCOOKIES_ENUM cookieEnum;

    pDestroyCookieStrings (EnumPtr->ObjectNode, EnumPtr->ObjectLeaf);
    IsmReleaseMemory (EnumPtr->NativeObjectName);

    cookieEnum = (PCOOKIES_ENUM)(EnumPtr->EtmHandle);
    if (cookieEnum) {
        PmReleaseMemory (g_CookiesPool, cookieEnum->Pattern);
        PmReleaseMemory (g_CookiesPool, cookieEnum);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}


/*++

  The next set of functions implement the ETM entry points to acquire, test,
  create and remove cookies. They rely on the cookie hash table being
  accurate.

--*/

BOOL
AcquireCookie (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PCTSTR cookieData = NULL;

    MYASSERT (ObjectContent);

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        MYASSERT (FALSE);
        return FALSE;
    }

    if (HtFindStringEx (g_CookiesTable, ObjectName, (PVOID) (&cookieData), FALSE)) {
        ObjectContent->MemoryContent.ContentBytes = (PCBYTE) cookieData;
        ObjectContent->MemoryContent.ContentSize = SizeOfString (cookieData);

        cookieData = GetEndOfString (cookieData) + 1;
        ObjectContent->Details.DetailsData = (PCBYTE) cookieData;
        ObjectContent->Details.DetailsSize = SizeOfString (cookieData);

        return TRUE;
    }

    return FALSE;
}


BOOL
ReleaseCookie (
    IN      PMIG_CONTENT ObjectContent              ZEROED
    )
{
    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return TRUE;
}


BOOL
DoesCookieExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    if (g_DelayCookiesOp) {
        return FALSE;
    }

    if (HtFindString (g_CookiesTable, ObjectName)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pRemoveCookieWorker (
    IN      PCTSTR ObjectName,
    IN      PCTSTR Url,
    IN      PCTSTR CookieName
    )
{
    BOOL result = TRUE;

    if (InternetSetCookie (
            Url,
            CookieName,
            TEXT("foo; expires = Sat, 01-Jan-2000 00:00:00 GMT")
            )) {

        HtRemoveString (g_CookiesTable, ObjectName);

    } else {
        result = FALSE;
        DEBUGMSG ((
            DBG_ERROR,
            "Unable to delete cookie %s for URL %s\n",
            CookieName,
            Url
            ));
    }

    return result;
}


BOOL
RemoveCookie (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR url;
    PCTSTR cookieName;
    BOOL result = FALSE;

    if (pCreateCookieStrings (ObjectName, &url, &cookieName)) {
        if (url && cookieName) {

            if (g_DelayCookiesOp) {

                //
                // delay this cookie create because wininet apis do not work
                // for non-logged on users
                //

                IsmRecordDelayedOperation (
                    JRNOP_DELETE,
                    g_CookieTypeId,
                    ObjectName,
                    NULL
                    );
                result = TRUE;

            } else {
                //
                // add journal entry, then perform cookie deletion
                //

                IsmRecordOperation (
                    JRNOP_DELETE,
                    g_CookieTypeId,
                    ObjectName
                    );

                result = pRemoveCookieWorker (ObjectName, url, cookieName);
            }
        }

        pDestroyCookieStrings (url, cookieName);
    }

    return result;
}


BOOL
pCreateCookieWorker (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent,
    IN      PCTSTR Url,
    IN      PCTSTR CookieName
    )
{
    PCTSTR fixedCookieData;
    PCTSTR cookieData;
    PCTSTR expires;
    BOOL result = FALSE;
    GROWBUFFER tempBuf = INIT_GROWBUFFER;

    //
    // write the object by joining the content with the details
    //

    cookieData = (PCTSTR) (ObjectContent->MemoryContent.ContentBytes);
    expires = (PCTSTR) (ObjectContent->Details.DetailsData);
    fixedCookieData = JoinTextEx (
                            NULL,
                            cookieData,
                            expires,
                            TEXT(";"),
                            0,
                            NULL
                            );

    if (InternetSetCookie (Url, CookieName, fixedCookieData)) {

        pAddCookieToHashTable (
            &tempBuf,
            ObjectName,
            Url,
            CookieName,
            cookieData,
            expires
            );
        result = TRUE;

    } else {
        DEBUGMSG ((
            DBG_COOKIES,
            "Unable to set cookie %s for URL %s\n",
            CookieName,
            Url
            ));
    }

    FreeText (fixedCookieData);
    GbFree (&tempBuf);

    return result;
}


BOOL
CreateCookie (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR url;
    PCTSTR cookieName;
    BOOL result = FALSE;

    if (!ObjectContent->ContentInFile) {

        if (ObjectContent->MemoryContent.ContentBytes &&
            ObjectContent->MemoryContent.ContentSize &&
            ObjectContent->Details.DetailsSize &&
            ObjectContent->Details.DetailsData
            ) {

            if (pCreateCookieStrings (ObjectName, &url, &cookieName)) {
                if (url && cookieName) {

                    if (g_DelayCookiesOp) {

                        //
                        // delay this cookie create because wininet apis do not work
                        // for non-logged on users
                        //

                        IsmRecordDelayedOperation (
                            JRNOP_CREATE,
                            g_CookieTypeId,
                            ObjectName,
                            ObjectContent
                            );
                        result = TRUE;

                    } else {
                        //
                        // add journal entry, then create the cookie
                        //

                        IsmRecordOperation (
                            JRNOP_CREATE,
                            g_CookieTypeId,
                            ObjectName
                            );

                        if (DoesCookieExist (ObjectName)) {
                            //
                            // Fail because cookie cannot be overwritten
                            //

                            result = FALSE;
                        } else {
                            result = pCreateCookieWorker (
                                            ObjectName,
                                            ObjectContent,
                                            url,
                                            cookieName
                                            );
                        }
                    }
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "Invalid cookie node or leaf: %s", ObjectName));

                pDestroyCookieStrings (url, cookieName);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Invalid cookie object: %s", ObjectName));
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "Can't write incomplete cookie object"));
    }

    return result;
}


/*++

  The next group of functions converts a cookie object into a string format,
  suitable for output to an INF file. The reverse conversion is also
  implemented.

--*/

PCTSTR
ConvertCookieToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR url, cookieName;
    PTSTR result = NULL;
    PCTSTR data;

    if (pCreateCookieStrings (ObjectName, &url, &cookieName)) {

        MYASSERT (url);
        MYASSERT (cookieName);

        //
        // Build a multi-sz in the following format:
        //
        // <url>\0<cookie name>\0<cookie data>\0<expiration>\0\0
        //

        g_CookieConversionBuff.End = 0;

        // <url>
        GbCopyQuotedString (&g_CookieConversionBuff, url);

        // <cookie name>
        GbCopyQuotedString (&g_CookieConversionBuff, cookieName);

        // <cookie data>
        MYASSERT (!ObjectContent->ContentInFile);

        if ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentBytes)
            ) {

            data = (PCTSTR) ObjectContent->MemoryContent.ContentBytes;
            GbCopyQuotedString (&g_CookieConversionBuff, data);
        }

        // <expiration>
        MYASSERT (ObjectContent->Details.DetailsSize);

        if (ObjectContent->Details.DetailsSize &&
            ObjectContent->Details.DetailsData
            ) {
            data = (PCTSTR) ObjectContent->Details.DetailsData;
            GbCopyQuotedString (&g_CookieConversionBuff, data);
        }

        // nul terminator
        GbCopyString (&g_CookieConversionBuff, TEXT(""));

        //
        // Transfer multi-sz to ISM memory
        //

        result = IsmGetMemory (g_CookieConversionBuff.End);
        CopyMemory (result, g_CookieConversionBuff.Buf, g_CookieConversionBuff.End);

        //
        // Clean up
        //

        pDestroyCookieStrings (url, cookieName);
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "Invalid cookie object: %s", ObjectName));

    return result;
}

BOOL
ConvertMultiSzToCookie (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent              OPTIONAL CALLER_INITIALIZED
    )
{
    MULTISZ_ENUM e;
    PCTSTR strings[4];
    UINT field;

    g_CookieConversionBuff.End = 0;

    //
    // Fill the object content from the following multi-sz:
    //
    // <url>\0<cookie name>\0<cookie data>\0<expiration>\0\0
    //

    field = 0;

    if (EnumFirstMultiSz (&e, ObjectMultiSz)) {
        do {

            strings[field] = e.CurrentString;
            field++;

        } while (field < 4 && EnumNextMultiSz (&e));
    }

    //
    // Validate data (end-user can edit it!)
    //

    if (field != 4) {
        return FALSE;
    }

    if (!strings[0] || !strings[1] || !strings[3]) {
        return FALSE;
    }

    //
    // Create the content struct
    //

    if (ObjectContent) {

        ObjectContent->ContentInFile = FALSE;

        ObjectContent->MemoryContent.ContentSize = SizeOfString (strings[2]);
        if (ObjectContent->MemoryContent.ContentSize) {
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE) ObjectContent->MemoryContent.ContentBytes,
                strings[2],
                ObjectContent->MemoryContent.ContentSize
                );
        }

        ObjectContent->Details.DetailsSize = SizeOfString (strings[3]);
        ObjectContent->Details.DetailsData = IsmGetMemory (ObjectContent->Details.DetailsSize);

        CopyMemory (
            (PBYTE) ObjectContent->Details.DetailsData,
            strings[3],
            ObjectContent->Details.DetailsSize
            );
    }

    *ObjectName = pCreateCookieHandle (strings[0], strings[1]);

    return TRUE;
}


PCTSTR
GetNativeCookieName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )

/*++

Routine Description:

  GetNativeCookieName converts the standard Cobra object into a more friendly
  format. The Cobra object comes in the form of ^a<node>^b^c<leaf>, where
  <node> is the URL, and <leaf> is the cookie name. The Cookies native name is
  in the format of <CookieUrl>:<CookieName>.

  Here is an example:

    Cobra object:   ^ahttp://foo.com/^b^c#my#cookie
    Native object:  cookie://foo.com/:MyCookie

  (^a, ^b and ^c are placeholders for ISM-defined control characters.)

Arguments:

  ObjectName - Specifies the encoded object name

Return Value:

  A string that is equivalent to ObjectName, but is in a friendly format.
  This string must be freed with IsmReleaseMemory.

--*/

{
    PCTSTR cookieName;
    UINT size;
    PTSTR result = NULL;
    PCTSTR url;
    PCTSTR subUrl;
    PCTSTR cookieUrl;
    PCTSTR fullName;

    if (pCreateCookieStrings (ObjectName, &url, &cookieName)) {

        if (url && cookieName) {

            //
            // Skip beyond http:// prefix
            //

            subUrl = _tcschr (url, TEXT(':'));

            if (subUrl) {

                subUrl = _tcsinc (subUrl);

                if (_tcsnextc (subUrl) == TEXT('/')) {
                    subUrl = _tcsinc (subUrl);
                }

                if (_tcsnextc (subUrl) == TEXT('/')) {
                    subUrl = _tcsinc (subUrl);
                }

                //
                // Connect sub url with cookie:// prefix, then make full native name
                //

                cookieUrl = JoinText (TEXT("cookie://"), subUrl);

                fullName = JoinTextEx (
                                NULL,
                                cookieUrl,
                                cookieName,
                                TEXT(":"),
                                0,
                                NULL
                                );

                FreeText (cookieUrl);

                size = SizeOfString (fullName);
                result = IsmGetMemory (size);
                if (result) {
                    CopyMemory (result, fullName, size);
                }

                FreeText (fullName);
            }
        }

        pDestroyCookieStrings (url, cookieName);
    }

    return result;
}

PMIG_CONTENT
ConvertCookieContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert cookie content
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize * 2);
            if (result->MemoryContent.ContentBytes) {
                DirectDbcsToUnicodeN (
                    (PWSTR)result->MemoryContent.ContentBytes,
                    (PSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfStringW ((PWSTR)result->MemoryContent.ContentBytes);
            }
        }

        if ((ObjectContent->Details.DetailsSize != 0) &&
            (ObjectContent->Details.DetailsData != NULL)
            ) {
            // convert cookie details
            result->Details.DetailsData = IsmGetMemory (ObjectContent->Details.DetailsSize * 2);
            if (result->Details.DetailsData) {
                DirectDbcsToUnicodeN (
                    (PWSTR)result->Details.DetailsData,
                    (PSTR)ObjectContent->Details.DetailsData,
                    ObjectContent->Details.DetailsSize
                    );
                result->Details.DetailsSize = SizeOfStringW ((PWSTR)result->Details.DetailsData);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertCookieContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert cookie content
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            if (result->MemoryContent.ContentBytes) {
                DirectUnicodeToDbcsN (
                    (PSTR)result->MemoryContent.ContentBytes,
                    (PWSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfStringA ((PSTR)result->MemoryContent.ContentBytes);
            }
        }

        if ((ObjectContent->Details.DetailsSize != 0) &&
            (ObjectContent->Details.DetailsData != NULL)
            ) {
            // convert cookie details
            result->Details.DetailsData = IsmGetMemory (ObjectContent->Details.DetailsSize);
            if (result->Details.DetailsData) {
                DirectUnicodeToDbcsN (
                    (PSTR)result->Details.DetailsData,
                    (PWSTR)ObjectContent->Details.DetailsData,
                    ObjectContent->Details.DetailsSize
                    );
                result->Details.DetailsSize = SizeOfStringA ((PSTR)result->Details.DetailsData);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedCookieContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    if (ObjectContent->Details.DetailsData) {
        IsmReleaseMemory (ObjectContent->Details.DetailsData);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\entry.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the DLL entry point that provides all Cobra module entry points
    to the engine.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "sysmod.h"

#define NOPARSE NULL
#define NOQUEUE NULL
#define NOINIT  NULL
#define NOTERMINATE NULL
#define NOHIGHPRIQUEUE  NULL
#define NOEXECUTE NULL
#define NOPROGBAR NULL
#define NONOTIFY NULL

#define NO_SGM      NOINIT,NOPARSE,NOQUEUE,NOHIGHPRIQUEUE,NOTERMINATE
#define NO_SAM      NOINIT,NOEXECUTE,NOPROGBAR,NOTERMINATE
#define NO_DGM      NOINIT,NOQUEUE,NOHIGHPRIQUEUE,NOTERMINATE
#define NO_DAM      NOINIT,NOEXECUTE,NOPROGBAR,NOTERMINATE
#define NO_CSM      NOINIT,NOEXECUTE,NOPROGBAR,NOTERMINATE
#define NO_OPM      NOINIT,NOTERMINATE

typedef struct {
    PCTSTR Name;
    TYPE_ENTRYPOINTS EntryPoints;
} ETM_TABLE, *PETM_TABLE;

typedef struct {
    PCTSTR Name;
    VIRTUAL_COMPUTER_ENTRYPOINTS EntryPoints;
} VCM_TABLE, *PVCM_TABLE;

typedef struct {
    PCTSTR Name;
    SOURCE_ENTRYPOINTS EntryPoints;
} SOURCE_TABLE, *PSOURCE_TABLE;

typedef struct {
    PCTSTR Name;
    DESTINATION_ENTRYPOINTS EntryPoints;
} DESTINATION_TABLE, *PDESTINATION_TABLE;


//
// Add an entry for each ETM module in the DLL
//

ETM_TABLE g_EtmEntryPoints[] = {
    {   TEXT("ACCESSIBILITY"), ISM_VERSION,
        AccessibilityEtmInitialize, NOPARSE, NOTERMINATE, NONOTIFY
    },

    {   TEXT("COOKIES"), ISM_VERSION,
        CookiesEtmInitialize, NOPARSE, NOTERMINATE, CookiesEtmNewUserCreated
    },

    {   TEXT("NETDRIVES"), ISM_VERSION,
        NetDrivesEtmInitialize, NOPARSE, NOTERMINATE, NetDrivesEtmNewUserCreated
    },

    {   TEXT("NETSHARES"), ISM_VERSION,
        NetSharesEtmInitialize, NOPARSE, NOTERMINATE, NONOTIFY
    },

    {   TEXT("PRINTERS"), ISM_VERSION,
        PrintersEtmInitialize, NOPARSE, NOTERMINATE, PrintersEtmNewUserCreated
    },

    {   TEXT("RAS"), ISM_VERSION,
        RasMigEtmInitialize, NOPARSE, NOTERMINATE, RasMigEtmNewUserCreated
    },

    {NULL}
};

//
// Add an entry for each VCM module in the DLL
//

VCM_TABLE g_VcmEntryPoints[] = {
    {   TEXT("ACCESSIBILITY"), ISM_VERSION,
        AccessibilitySourceInitialize, NOPARSE, NOQUEUE, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("COOKIES"), ISM_VERSION,
        CookiesSourceInitialize, CookiesVcmParse, CookiesVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("LNKMIG"), ISM_VERSION,
        LnkMigVcmInitialize, NOPARSE, LnkMigVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("NETDRIVES"), ISM_VERSION,
        NetDrivesVcmInitialize, NetDrivesVcmParse, NetDrivesVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("NETSHARES"), ISM_VERSION,
        NetSharesVcmInitialize, NetSharesVcmParse, NetSharesVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("OSFILES"), ISM_VERSION,
        OsFilesVcmInitialize, NOPARSE, OsFilesVcmQueueEnumeration, OsFilesVcmQueueHighPriorityEnumeration, NOTERMINATE
    },

    {   TEXT("PRINTERS"), ISM_VERSION,
        PrintersVcmInitialize, PrintersVcmParse, PrintersVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("RAS"), ISM_VERSION,
        RasMigVcmInitialize, RasMigVcmParse, RasMigVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {NULL}
};

//
// Add an entry for each source module in the DLL
//

SOURCE_TABLE g_SourceEntryPoints[] = {
    {   TEXT("ACCESSIBILITY"), ISM_VERSION,
        (PSGMINITIALIZE) AccessibilitySourceInitialize, NOPARSE, NOQUEUE, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("COOKIES"), ISM_VERSION,
        (PSGMINITIALIZE) CookiesSourceInitialize, CookiesSgmParse, CookiesSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("LNKMIG"), ISM_VERSION,
        LnkMigSgmInitialize, NOPARSE, LnkMigSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("NETDRIVES"), ISM_VERSION,
        NetDrivesSgmInitialize, NetDrivesSgmParse, NetDrivesSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("NETSHARES"), ISM_VERSION,
        NetSharesSgmInitialize, NetSharesSgmParse, NetSharesSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("OSFILES"), ISM_VERSION,
        OsFilesSgmInitialize, NOPARSE, OsFilesSgmQueueEnumeration, OsFilesSgmQueueHighPriorityEnumeration, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("PRINTERS"), ISM_VERSION,
        PrintersSgmInitialize, PrintersSgmParse, PrintersSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("RAS"), ISM_VERSION,
        RasMigSgmInitialize, RasMigSgmParse, RasMigSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {NULL}
};

//
// Add an entry for each destination module in the DLL
//

DESTINATION_TABLE g_DestinationEntryPoints[] = {
    {   TEXT("ACCESSIBILITY"), ISM_VERSION,
        NO_DGM, NO_DAM, NO_CSM, NO_OPM
    },

    {   TEXT("LNKMIG"), ISM_VERSION,
        NO_DGM, NO_DAM, NO_CSM,
        LnkMigOpmInitialize, NOTERMINATE
    },

    {   TEXT("NETDRIVES"), ISM_VERSION,
        NO_DGM, NO_DAM,
        NetDrivesCsmInitialize, NetDrivesCsmExecute, NOPROGBAR, NOTERMINATE,
        NetDrivesOpmInitialize, NOTERMINATE
    },

    {   TEXT("RAS"), ISM_VERSION,
        NO_DGM, NO_DAM, NO_CSM,
        RasMigOpmInitialize, NOTERMINATE
    },

    {NULL}
};


EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }

    return TRUE;
}


EXPORT
BOOL
WINAPI
ModuleInitialize (
    VOID
    )
{
    TCHAR memDbDir[MAX_PATH];

    UtInitialize (NULL);
    RegInitialize ();           // for accessibility and ras
    InfGlobalInit (FALSE);      // for os files

    IsmGetTempDirectory (memDbDir, ARRAYSIZE (memDbDir));
    if (!MemDbInitializeEx (memDbDir)) {
        DEBUGMSG ((DBG_ERROR, "Failing to initialize unc transports because MemDb failed to initialize"));
        IsmSetCancel();
        return FALSE;
    }

#define DEFMAC(prefix)  if (!prefix##Initialize()) return FALSE;

MODULE_LIST

#undef DEFMAC

    return TRUE;
}

EXPORT
VOID
WINAPI
ModuleTerminate (
    VOID
    )
{
#define DEFMAC(prefix)  prefix##Terminate();

MODULE_LIST

#undef DEFMAC

    InfGlobalInit (TRUE);
    RegTerminate ();
    MemDbTerminateEx (TRUE);
    UtTerminate ();
}


BOOL
WINAPI
pFindModule (
    IN      PCTSTR ModuleId,
    OUT     PVOID IsmBuffer,
    IN      PCTSTR *TableEntry,
    IN      UINT StructureSize
    )
{

    while (*TableEntry) {
        if (StringIMatch (*TableEntry, ModuleId)) {
            CopyMemory (
                IsmBuffer,
                (PBYTE) (TableEntry + 1),
                StructureSize
                );
            return TRUE;
        }

        TableEntry = (PCTSTR *) ((PBYTE) (TableEntry + 1) + StructureSize);
    }

    return FALSE;
}



EXPORT
BOOL
WINAPI
TypeModule (
    IN      PCTSTR ModuleId,
    IN OUT  PTYPE_ENTRYPOINTS TypeEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) TypeEntryPoints,
                (PCTSTR *) g_EtmEntryPoints,
                sizeof (TYPE_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
VirtualComputerModule (
    IN      PCTSTR ModuleId,
    IN OUT  PVIRTUAL_COMPUTER_ENTRYPOINTS VirtualComputerEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) VirtualComputerEntryPoints,
                (PCTSTR *) g_VcmEntryPoints,
                sizeof (VIRTUAL_COMPUTER_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
SourceModule (
    IN      PCTSTR ModuleId,
    IN OUT  PSOURCE_ENTRYPOINTS SourceEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) SourceEntryPoints,
                (PCTSTR *) g_SourceEntryPoints,
                sizeof (SOURCE_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
DestinationModule (
    IN      PCTSTR ModuleId,
    IN OUT  PDESTINATION_ENTRYPOINTS DestinationEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) DestinationEntryPoints,
                (PCTSTR *) g_DestinationEntryPoints,
                sizeof (DESTINATION_ENTRYPOINTS)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\dbattrib.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dbattrib.c

Abstract:

    This source implements attribute functions used by MigDb

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

  28-May-1999   ovidiut     Added SECTIONKEY attribute
  22-Apr-1999   jimschm     Added UPTOBIN*VER attributes
  07-Jan-1999   jimschm     Added HASVERSION attribute
  18-May-1998   jimschm     Added INPARENTDIR attribute
  08-Apr-1998   calinn      Added two more attributes (ExeType and Description)
  29-Jan-1998   calinn      Modified CheckSum and FileSize to work with hex numbers
  19-Jan-1998   calinn      added CheckSum attribute

--*/

#include "pch.h"
#include "logmsg.h"
#include "osfiles.h"

/*++

Macro Expansion List Description:

  ATTRIBUTE_FUNCTIONS lists all valid attributes to query for a specific file.
  They are used by migdb in it's attempt to locate files.

Line Syntax:

   DEFMAC(AttribFn, AttribName, ReqArgs)

Arguments:

   AttribFn   - This is a boolean function that returnes TRUE if a specified file has
                the specified attribute. You must implement a function with this name
                and required parameters.

   AttribName - This is the string that identifies the attribute function. It should
                have the same value as listed in migdb.inf

   ReqArgs    - Specifies the number of args that are required for the action.  Used
                by the parser.

Variables Generated From List:

   g_AttributeFunctions - do not touch!

For accessing the array there are the following functions:

   MigDb_GetAttributeAddr
   MigDb_GetAttributeIdx
   MigDb_GetAttributeName
   MigDb_GetReqArgCount

--*/

#define ATTRIBUTE_FUNCTIONS        \
        DEFMAC(CompanyName,         COMPANYNAME,        1)  \
        DEFMAC(FileDescription,     FILEDESCRIPTION,    1)  \
        DEFMAC(FileVersion,         FILEVERSION,        1)  \
        DEFMAC(InternalName,        INTERNALNAME,       1)  \
        DEFMAC(LegalCopyright,      LEGALCOPYRIGHT,     1)  \
        DEFMAC(OriginalFilename,    ORIGINALFILENAME,   1)  \
        DEFMAC(ProductName,         PRODUCTNAME,        1)  \
        DEFMAC(ProductVersion,      PRODUCTVERSION,     1)  \
        DEFMAC(FileSize,            FILESIZE,           1)  \
        DEFMAC(IsMsBinary,          ISMSBINARY,         0)  \
        DEFMAC(CheckSum,            CHECKSUM,           1)  \
        DEFMAC(ExeType,             EXETYPE,            1)  \
        DEFMAC(Description,         DESCRIPTION,        1)  \
        DEFMAC(HasVersion,          HASVERSION,         0)  \
        DEFMAC(BinFileVer,          BINFILEVER,         1)  \
        DEFMAC(BinProductVer,       BINPRODUCTVER,      1)  \
        DEFMAC(FileDateHi,          FILEDATEHI,         1)  \
        DEFMAC(FileDateLo,          FILEDATELO,         1)  \
        DEFMAC(FileVerOs,           FILEVEROS,          1)  \
        DEFMAC(FileVerType,         FILEVERTYPE,        1)  \
        DEFMAC(SizeCheckSum,        FC,                 2)  \
        DEFMAC(UpToBinProductVer,   UPTOBINPRODUCTVER,  1)  \
        DEFMAC(UpToBinFileVer,      UPTOBINFILEVER,     1)  \


typedef struct {
    PCTSTR AttributeName;
    PATTRIBUTE_PROTOTYPE AttributeFunction;
    UINT RequiredArgs;
} ATTRIBUTE_STRUCT, *PATTRIBUTE_STRUCT;

//
// Declare the attribute functions
//
#define DEFMAC(fn,id,reqargs) ATTRIBUTE_PROTOTYPE fn;
ATTRIBUTE_FUNCTIONS
#undef DEFMAC

//
// Declare a global array of functions and name identifiers for attribute functions
//
#define DEFMAC(fn,id,regargs) {TEXT(#id), fn, regargs},
static ATTRIBUTE_STRUCT g_AttributeFunctions[] = {
                              ATTRIBUTE_FUNCTIONS
                              {NULL, NULL}
                              };
#undef DEFMAC

BOOL
pAlwaysFalseAttribute (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return FALSE;
}

PATTRIBUTE_PROTOTYPE
MigDb_GetAttributeAddr (
    IN      INT AttributeIdx
    )
/*++

Routine Description:

  MigDb_GetAttributeAddr returns the address of the attribute function based on the attribute index

Arguments:

  AttributeIdx - Attribute index.

Return value:

  Attribute function address. Note that no checking is made so the address returned could be invalid.
  This is not a problem since the parsing code did the right job.

--*/
{
    if (AttributeIdx == -1) {
        return &pAlwaysFalseAttribute;
    }

    return g_AttributeFunctions[AttributeIdx].AttributeFunction;
}

INT
MigDb_GetAttributeIdx (
    IN      PCTSTR AttributeName
    )
/*++

Routine Description:

  MigDb_GetAttributeIdx returns the attribute index based on the attribute name

Arguments:

  AttributeName - Attribute name.

Return value:

  Attribute index. If the name is not found, the index returned is -1.

--*/
{
    PATTRIBUTE_STRUCT p = g_AttributeFunctions;
    INT i = 0;
    while (p->AttributeName != NULL) {
        if (StringIMatch (p->AttributeName, AttributeName)) {
            return i;
        }
        p++;
        i++;
    }
    return -1;
}

PCTSTR
MigDb_GetAttributeName (
    IN      INT AttributeIdx
    )
/*++

Routine Description:

  MigDb_GetAttributeName returns the name of an attribute based on the attribute index

Arguments:

  AttributeIdx - Attribute index.

Return value:

  Attribute name. Note that no checking is made so the returned pointer could be invalid.
  This is not a problem since the parsing code did the right job.

--*/
{
    if (AttributeIdx == -1) {
        return TEXT("nul");
    }

    return g_AttributeFunctions[AttributeIdx].AttributeName;
}

UINT
MigDb_GetReqArgCount (
    IN      INT AttributeIndex
    )

/*++

Routine Description:

  MigDb_GetReqArgCount is called by the migdb parser to get the required
  argument count.  When the parser sees arguments that lack the required
  arguments, it skips them.

Arguments:

  Index - Specifies the argument index

Return Value:

  The required argument count, which can be zero or more.

--*/

{
    if (AttributeIndex == -1) {
        return 0;
    }

    return g_AttributeFunctions[AttributeIndex].RequiredArgs;
}

ULONGLONG
GetBinFileVer (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    ULONGLONG result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryFileVersion (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

ULONGLONG
GetBinProductVer (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    ULONGLONG result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryProductVersion (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

DWORD
GetFileDateHi (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    DWORD result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryFileDateHi (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

DWORD
GetFileDateLo (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    DWORD result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryFileDateLo (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

DWORD
GetFileVerOs (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    DWORD result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryOsVersion (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

DWORD
GetFileVerType (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    DWORD result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryFileType (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

/*++
  CompanyName, FileDescription, FileVersion, InternalName, LegalCopyright, OriginalFilename,
  ProductName, ProductVersion are attribute functions that are querying the version structure
  for their specific entries. They all return TRUE if the specific entry has specific value,
  FALSE otherwise.
--*/

BOOL
CompanyName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("CompanyName"), Args);
}

BOOL
FileDescription (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("FileDescription"), Args);
}

BOOL
FileVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("FileVersion"), Args);
}

BOOL
InternalName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("InternalName"), Args);
}

BOOL
LegalCopyright (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("LegalCopyright"), Args);
}

BOOL
OriginalFilename (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("OriginalFilename"), Args);
}

BOOL
ProductName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("ProductName"), Args);
}

BOOL
ProductVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("ProductVersion"), Args);
}

BOOL
FileSize (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  FileSize checks for the size of a file.

Arguments:

  Params - See definition.

  Args   - MultiSz. First Sz is the file size we need to check.

Return value:

  TRUE  - the file size matches Args
  FALSE - otherwise

--*/
{
    DWORD fileSize;

    _stscanf (Args, TEXT("%lx"), &fileSize);
    if (fileSize == AttribParams->FileParams->FindData->nFileSizeLow) {
        return TRUE;
    }
    else {
        return (_ttoi64 (Args) == AttribParams->FileParams->FindData->nFileSizeLow);
    }
}

BOOL
IsMsBinary (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  IsMsBinary checks to see if a certain file is Microsoft stuff. For 32 bit modules
  we query CompanyName for "Microsoft" somewhere inside. For other modules we are
  relying on InWinDir attribute

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is MS stuff
  FALSE - otherwise

--*/
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("CompanyName"), TEXT("*Microsoft*"));
}

BOOL
CheckSum (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  CheckSum returns TRUE if file's checksum equals the value in Args

Arguments:

  Params - See definition.

  Args   - checksum value.

Return value:

  TRUE  - the file's checksum equals the value in Args
  FALSE - otherwise

--*/
{
    UINT   checkSum   = 0;
    UINT   oldSum     = 0;

    checkSum = MdGetCheckSum (AttribParams->FileParams->NativeObjectName);

    _stscanf (Args, TEXT("%lx"), &oldSum);
    if (oldSum == checkSum) {
        return TRUE;
    }
    else {
        return (_ttoi64 (Args) == checkSum);
    }
}

BOOL
SizeCheckSum (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  Returns TRUE if file's size equals first arg and checksum equals to the second arg

Arguments:

  Params - See definition.

  Args   - checksum value.

Return value:

  TRUE  - the file's checksum equals the value in Args
  FALSE - otherwise

--*/
{
    PCTSTR currArg = Args;

    if (!FileSize (AttribParams, currArg)) {
        return FALSE;
    }
    currArg = GetEndOfString (currArg);
    if (!currArg) {
        return FALSE;
    }
    currArg = _tcsinc (currArg);
    if (!currArg) {
        return FALSE;
    }
    return (CheckSum (AttribParams, currArg));
}

PTSTR g_ExeTypes[] = {
    TEXT("NONE"),
    TEXT("DOS"),
    TEXT("WIN16"),
    TEXT("WIN32")
};

BOOL
ExeType (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  ExeType returns TRUE if file's type is according with Args. This can be:
  NONE, DOS, WIN16, WIN32

Arguments:

  Params - See definition.

  Args   - type of module.

Return value:

  TRUE  - the file's type is the same as Args
  FALSE - otherwise

--*/
{
    return IsPatternMatch (Args, g_ExeTypes[MdGetModuleType (AttribParams->FileParams->NativeObjectName)]);
}


BOOL
Description (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  Description returns TRUE if file's description matches Args

Arguments:

  Params - See definition.

  Args   - description

Return value:

  TRUE  - the file's description matches Args
  FALSE - otherwise

--*/
{
    PCTSTR descr = NULL;
    BOOL result = FALSE;

    descr = MdGet16ModuleDescription (AttribParams->FileParams->NativeObjectName);

    if (descr != NULL) {
        result = IsPatternMatch (Args, descr);
        FreePathString (descr);
    }
    return result;
}

BOOL
HasVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )

/*++

Routine Description:

  HasVersion determines if a file has any entries in its version
  stamp.

Arguments:

  Params - Specifies the helper params that give the files to test.
  Args   - Unused

Return Value:

  TRUE if the specified file has an entry in its version stamp,
  FALSE otherwsie.

--*/

{
    VRVALUE_ENUM Version;
    BOOL Result = FALSE;

    if (VrCreateEnumStruct (&Version, AttribParams->FileParams->NativeObjectName)) {
        Result = TRUE;
        VrDestroyEnumStruct (&Version);
    }

    return Result;
}

BOOL
pHexMatch (
    IN      DWORD NewValue,
    IN      PCTSTR Args
    )
{
    DWORD oldValue;

    _stscanf (Args, TEXT("%lx"), &oldValue);
    if (oldValue == NewValue) {
        return TRUE;
    }
    else {
        return (_ttoi64 (Args) == NewValue);
    }
}

BOOL
pConvertDotStringToValue (
    IN      PCTSTR String,
    OUT     ULONGLONG *Value
    )
{
    PWORD valueIdx;
    UINT index;

    valueIdx = (PWORD) Value + 3;

    for (index = 0 ; index < 4 ; index++) {

        if (*String == 0) {
            *valueIdx = 0xFFFF;
            valueIdx--;
            continue;
        }

        *valueIdx = (WORD) _tcstoul (String, &(PTSTR) String, 10);
        if (*String && (_tcsnextc (String) != TEXT('.'))) {
            return FALSE;
        }

        String = _tcsinc (String);
        valueIdx--;
    }

    return TRUE;
}

BOOL
pMaskHexMatch (
    IN      ULONGLONG NewValue,
    IN      PCTSTR Args
    )
{
    ULONGLONG oldValue = 0;
    ULONGLONG mask = 0;
    PWORD maskIdx;
    PWORD valueIdx;
    UINT index;

    maskIdx = (PWORD)&mask + 3;
    valueIdx = (PWORD)&oldValue + 3;
    index = 0;

    while (Args && *Args) {

        if (index >= 4) {
            return FALSE;
        }

        *valueIdx = (WORD) _tcstoul ((PTSTR)Args, &((PTSTR)Args), 10);

        if (*Args) {
            if (_tcsnextc (Args) != TEXT('.')) {
                return FALSE;
            }

            Args = _tcsinc (Args);
        }

        *maskIdx = 65535;

        valueIdx--;
        maskIdx--;
        index++;
    }

    NewValue = NewValue & mask;

    return (oldValue == NewValue);
}

BOOL
BinFileVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pMaskHexMatch (GetBinFileVer (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
BinProductVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pMaskHexMatch (GetBinProductVer (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
FileDateHi (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pHexMatch (GetFileDateHi (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
FileDateLo (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pHexMatch (GetFileDateLo (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
FileVerOs (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pHexMatch (GetFileVerOs (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
FileVerType (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pHexMatch (GetFileVerType (AttribParams->FileParams->NativeObjectName), Args);
}


BOOL
UpToBinProductVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    VRVALUE_ENUM Version;
    ULONGLONG versionStampValue = 0;
    ULONGLONG maxValue;

    if (VrCreateEnumStruct (&Version, AttribParams->FileParams->NativeObjectName)) {
        versionStampValue = VrGetBinaryProductVersion (&Version);
        VrDestroyEnumStruct (&Version);
    } else {
        return FALSE;
    }

    if (!pConvertDotStringToValue (Args, &maxValue)) {
        DEBUGMSG ((DBG_WHOOPS, "Invalid value of %s caused UpToBinProductVer to fail", Args));
        return FALSE;
    }

    return versionStampValue <= maxValue;
}


BOOL
UpToBinFileVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    VRVALUE_ENUM Version;
    ULONGLONG versionStampValue = 0;
    ULONGLONG maxValue;

    if (VrCreateEnumStruct (&Version, AttribParams->FileParams->NativeObjectName)) {
        versionStampValue = VrGetBinaryFileVersion (&Version);
        VrDestroyEnumStruct (&Version);
    } else {
        return FALSE;
    }

    if (!pConvertDotStringToValue (Args, &maxValue)) {
        DEBUGMSG ((DBG_WHOOPS, "Invalid value of %s caused UpToBinFileVer to fail", Args));
        return FALSE;
    }

    return versionStampValue <= maxValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\lnkmig.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    lnkmig.h

Abstract:

    Header file for implementing shell folders migration

Author:

    Calin Negreanu (calinn) 07-Ian-1998

Revision History:

    <alias> <date> <comments>

--*/

#define S_SFOLDERS_ATTRIBUTE       TEXT("SFOLDERS.SFOLDER")

#define S_LNKMIGATTR_SHORTCUT      TEXT("LNKMIG.ATTR.SHORTCUT")
#define S_LNKMIGPROP_TARGET        TEXT("LNKMIG.PROP.TARGET")
#define S_LNKMIGPROP_PARAMS        TEXT("LNKMIG.PROP.PARAMS")
#define S_LNKMIGPROP_WORKDIR       TEXT("LNKMIG.PROP.WORKDIR")
#define S_LNKMIGPROP_RAWWORKDIR    TEXT("LNKMIG.PROP.RAWWORKDIR")
#define S_LNKMIGPROP_ICONPATH      TEXT("LNKMIG.PROP.ICONPATH")
#define S_LNKMIGPROP_ICONNUMBER    TEXT("LNKMIG.PROP.ICONNUMBER")
#define S_LNKMIGPROP_ICONDATA      TEXT("LNKMIG.PROP.ICONDATA")
#define S_LNKMIGPROP_HOTKEY        TEXT("LNKMIG.PROP.HOTKEY")
#define S_LNKMIGPROP_DOSAPP        TEXT("LNKMIG.PROP.DOSAPP")
#define S_LNKMIGPROP_MSDOSMODE     TEXT("LNKMIG.PROP.MSDOSMODE")
#define S_LNKMIGPROP_EXTRADATA     TEXT("LNKMIG.PROP.EXTRADATA")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\lnkmig.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    lnkmig.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 08 Mar 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include "lnkmig.h"

#define DBG_LINKS       "Links"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_LinksPool = NULL;
MIG_ATTRIBUTEID g_LnkMigAttr_Shortcut = 0;
MIG_ATTRIBUTEID g_CopyIfRelevantAttr;
MIG_ATTRIBUTEID g_OsFileAttribute;

MIG_PROPERTYID g_LnkMigProp_Target = 0;
MIG_PROPERTYID g_LnkMigProp_Params = 0;
MIG_PROPERTYID g_LnkMigProp_WorkDir = 0;
MIG_PROPERTYID g_LnkMigProp_RawWorkDir = 0;
MIG_PROPERTYID g_LnkMigProp_IconPath = 0;
MIG_PROPERTYID g_LnkMigProp_IconNumber = 0;
MIG_PROPERTYID g_LnkMigProp_IconData = 0;
MIG_PROPERTYID g_LnkMigProp_HotKey = 0;
MIG_PROPERTYID g_LnkMigProp_DosApp = 0;
MIG_PROPERTYID g_LnkMigProp_MsDosMode = 0;
MIG_PROPERTYID g_LnkMigProp_ExtraData = 0;

MIG_OPERATIONID g_LnkMigOp_FixContent;

IShellLink *g_ShellLink = NULL;
IPersistFile *g_PersistFile = NULL;

BOOL g_VcmMode = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

MIG_OBJECTENUMCALLBACK LinksCallback;
MIG_PREENUMCALLBACK LnkMigPreEnumeration;
MIG_POSTENUMCALLBACK LnkMigPostEnumeration;
OPMAPPLYCALLBACK DoLnkContentFix;
MIG_RESTORECALLBACK LinkRestoreCallback;

BOOL
LinkDoesContentMatch (
    IN      BOOL AlreadyProcessed,
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PMIG_CONTENT SrcContent,
    IN      MIG_OBJECTTYPEID DestObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE DestObjectName,
    IN      PMIG_CONTENT DestContent,
    OUT     PBOOL Identical,
    OUT     PBOOL DifferentDetailsOnly
    );

//
// Code
//

BOOL
pIsUncPath (
    IN      PCTSTR Path
    )
{
    return (Path && (Path[0] == TEXT('\\')) && (Path[1] == TEXT('\\')));
}

BOOL
LinksInitialize (
    VOID
    )
{
    g_LinksPool = PmCreateNamedPool ("Links");
    return (g_LinksPool != NULL);
}

VOID
LinksTerminate (
    VOID
    )
{
    if (g_LinksPool) {
        PmDestroyPool (g_LinksPool);
        g_LinksPool = NULL;
    }
}

BOOL
pCommonInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_LnkMigAttr_Shortcut = IsmRegisterAttribute (S_LNKMIGATTR_SHORTCUT, FALSE);
    g_CopyIfRelevantAttr = IsmRegisterAttribute (S_ATTRIBUTE_COPYIFRELEVANT, FALSE);

    g_LnkMigProp_Target = IsmRegisterProperty (S_LNKMIGPROP_TARGET, FALSE);
    g_LnkMigProp_Params = IsmRegisterProperty (S_LNKMIGPROP_PARAMS, FALSE);
    g_LnkMigProp_WorkDir = IsmRegisterProperty (S_LNKMIGPROP_WORKDIR, FALSE);
    g_LnkMigProp_RawWorkDir = IsmRegisterProperty (S_LNKMIGPROP_RAWWORKDIR, FALSE);
    g_LnkMigProp_IconPath = IsmRegisterProperty (S_LNKMIGPROP_ICONPATH, FALSE);
    g_LnkMigProp_IconNumber = IsmRegisterProperty (S_LNKMIGPROP_ICONNUMBER, FALSE);
    g_LnkMigProp_IconData = IsmRegisterProperty (S_LNKMIGPROP_ICONDATA, FALSE);
    g_LnkMigProp_HotKey = IsmRegisterProperty (S_LNKMIGPROP_HOTKEY, FALSE);
    g_LnkMigProp_DosApp = IsmRegisterProperty (S_LNKMIGPROP_DOSAPP, FALSE);
    g_LnkMigProp_MsDosMode = IsmRegisterProperty (S_LNKMIGPROP_MSDOSMODE, FALSE);
    g_LnkMigProp_ExtraData = IsmRegisterProperty (S_LNKMIGPROP_EXTRADATA, FALSE);

    g_LnkMigOp_FixContent = IsmRegisterOperation (S_OPERATION_LNKMIG_FIXCONTENT, FALSE);

    return TRUE;
}

BOOL
WINAPI
LnkMigVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    g_VcmMode = TRUE;
    return pCommonInitialize (LogCallback);
}

BOOL
WINAPI
LnkMigSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    return pCommonInitialize (LogCallback);
}

BOOL
LnkMigPreEnumeration (
    VOID
    )
{
    if (!InitCOMLink (&g_ShellLink, &g_PersistFile)) {
        DEBUGMSG ((DBG_ERROR, "Error initializing COM %d", GetLastError ()));
    }
    return TRUE;
}

BOOL
LnkMigPostEnumeration (
    VOID
    )
{
    FreeCOMLink (&g_ShellLink, &g_PersistFile);
    g_ShellLink = NULL;
    g_PersistFile = NULL;
    return TRUE;
}

MIG_OBJECTSTRINGHANDLE
pBuildEncodedNameFromNativeName (
    IN      PCTSTR NativeName
    )
{
    PCTSTR nodeName;
    PTSTR leafName;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    MIG_OBJECT_ENUM objEnum;

    result = IsmCreateObjectHandle (NativeName, NULL);
    if (result) {
        if (IsmEnumFirstSourceObject (&objEnum, MIG_FILE_TYPE | PLATFORM_SOURCE, result)) {
            IsmAbortObjectEnum (&objEnum);
            return result;
        }
        IsmDestroyObjectHandle (result);
        result = NULL;
    }

    // we have to split this path because it could be a file
    nodeName = DuplicatePathString (NativeName, 0);
    leafName = _tcsrchr (nodeName, TEXT('\\'));
    if (leafName) {
        *leafName = 0;
        leafName ++;
        result = IsmCreateObjectHandle (nodeName, leafName);
    } else {
        // we have no \ in the name. This can only mean that the
        // file specification has only a leaf
        result = IsmCreateObjectHandle (NULL, NativeName);
    }
    FreePathString (nodeName);

    return result;
}

PCTSTR
pSpecialExpandEnvironmentString (
    IN      PCTSTR SrcString,
    IN      PCTSTR Context
    )
{
    PCTSTR result = NULL;
    PCTSTR srcWinDir = NULL;
    PCTSTR destWinDir = NULL;
    PTSTR newSrcString = NULL;
    PCTSTR copyPtr = NULL;

    if (IsmGetRealPlatform () == PLATFORM_DESTINATION) {
        // Special case where this is actually the destination machine and
        // first part of SrcString matches %windir%. In this case, it is likely that
        // the shell replaced the source windows directory with the destination one.
        // We need to change it back
        destWinDir = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT ("%windir%"), NULL);
        if (destWinDir) {
            if (StringIPrefix (SrcString, destWinDir)) {
                srcWinDir = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, TEXT ("%windir%"), NULL);
                if (srcWinDir) {
                    newSrcString = IsmGetMemory (SizeOfString (srcWinDir) + SizeOfString (SrcString));
                    if (newSrcString) {
                        copyPtr = SrcString + TcharCount (destWinDir);
                        StringCopy (newSrcString, srcWinDir);
                        StringCat (newSrcString, copyPtr);
                    }
                    IsmReleaseMemory (srcWinDir);
                    srcWinDir = NULL;
                }
            }
            IsmReleaseMemory (destWinDir);
            destWinDir = NULL;
        }
    }

    result = IsmExpandEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                newSrcString?newSrcString:SrcString,
                Context
                );

    if (newSrcString) {
        IsmReleaseMemory (newSrcString);
    }

    return result;
}

MIG_OBJECTSTRINGHANDLE
pTryObject (
    IN      PCTSTR LeafName,
    IN      PCTSTR EnvName
    )
{
    MIG_OBJECT_ENUM objEnum;
    PTSTR envData = NULL;
    DWORD envSize = 0;
    PATH_ENUM pathEnum;
    MIG_OBJECTSTRINGHANDLE result = NULL;

    if (IsmGetEnvironmentString (
            PLATFORM_SOURCE,
            S_SYSENVVAR_GROUP,
            EnvName,
            NULL,
            0,
            &envSize
            )) {
        envData = IsmGetMemory (envSize);
        if (envData) {
            if (IsmGetEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    EnvName,
                    envData,
                    envSize,
                    &envSize
                    )) {
                // let's enumerate the paths from this env variable (should be separated by ;)
                if (EnumFirstPathEx (&pathEnum, envData, NULL, NULL, FALSE)) {
                    do {
                        result = IsmCreateObjectHandle (pathEnum.PtrCurrPath, LeafName);
                        if (IsmEnumFirstSourceObject (&objEnum, MIG_FILE_TYPE | PLATFORM_SOURCE, result)) {
                            IsmAbortObjectEnum (&objEnum);
                        } else {
                            IsmDestroyObjectHandle (result);
                            result = NULL;
                        }
                        if (result) {
                            AbortPathEnum (&pathEnum);
                            break;
                        }
                    } while (EnumNextPath (&pathEnum));
                }
            }
            IsmReleaseMemory (envData);
            envData = NULL;
        }
    }
    return result;
}

MIG_OBJECTSTRINGHANDLE
pGetFullEncodedName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL;
    MIG_OBJECTSTRINGHANDLE result = NULL;

    // let's split the ObjectName into node and leaf.
    // If it's leaf only we are going to try to find
    // that leaf in %path%, %windir% and %system% and
    // reconstruct the object name.

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        if (!node) {
            // this is leaf only. We need to find out where this leaf
            // is located. We are going to look for the leaf in the
            // following directories (in this order)
            // 1. %system%
            // 2. %system16%
            // 3. %windir%
            // 4. All directories in %path% env. variable

            result = pTryObject (leaf, TEXT("system"));
            if (!result) {
                result = pTryObject (leaf, TEXT("system16"));
            }
            if (!result) {
                result = pTryObject (leaf, TEXT("windir"));
            }
            if (!result) {
                result = pTryObject (leaf, TEXT("path"));
            }
        }

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
pIsLnkExcluded (
    IN      MIG_OBJECTID ObjectId,
    IN      PCTSTR Target,
    IN      PCTSTR Params,
    IN      PCTSTR WorkDir
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR targetPattern = NULL;
    PCTSTR targetPatternExp = NULL;
    PCTSTR paramsPattern = NULL;
    PCTSTR paramsPatternExp = NULL;
    PCTSTR workDirPattern = NULL;
    PCTSTR workDirPatternExp = NULL;
    BOOL result = FALSE;

    if (IsmIsAttributeSetOnObjectId (ObjectId, g_CopyIfRelevantAttr)) {
        // let's look in the INFs in section [ExcludedLinks] and see if our LNK matches
        // one of the lines. If it does and it has the CopyIfRelevand attribute then
        // it's excluded
        if (IsmGetEnvironmentValue (
                IsmGetRealPlatform (),
                NULL,
                S_GLOBAL_INF_HANDLE,
                (PBYTE)(&infHandle),
                sizeof (HINF),
                &sizeNeeded,
                &dataType
                ) &&
            (sizeNeeded == sizeof (HINF)) &&
            (dataType == ENVENTRY_BINARY)
            ) {

            if (InfFindFirstLine (infHandle, TEXT("ExcludedLinks"), NULL, &is)) {

                do {
                    targetPattern = InfGetStringField (&is, 1);
                    targetPatternExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, targetPattern, NULL);
                    if (!targetPatternExp) {
                        targetPatternExp = targetPattern;
                    }
                    paramsPattern = InfGetStringField (&is, 2);
                    paramsPatternExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, paramsPattern, NULL);
                    if (!paramsPatternExp) {
                        paramsPatternExp = paramsPattern;
                    }
                    workDirPattern = InfGetStringField (&is, 3);
                    workDirPatternExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, workDirPattern, NULL);
                    if (!workDirPatternExp) {
                        workDirPatternExp = workDirPattern;
                    }
                    if (IsPatternMatch (targetPatternExp?targetPatternExp:TEXT("*"), Target?Target:TEXT("")) &&
                        IsPatternMatch (paramsPatternExp?paramsPatternExp:TEXT("*"), Params?Params:TEXT("")) &&
                        IsPatternMatch (workDirPatternExp?workDirPatternExp:TEXT("*"), WorkDir?WorkDir:TEXT(""))
                        ) {
                        result = TRUE;
                        if (workDirPatternExp && (workDirPatternExp != workDirPattern)) {
                            IsmReleaseMemory (workDirPatternExp);
                            workDirPatternExp = NULL;
                        }
                        if (paramsPatternExp && (paramsPatternExp != paramsPattern)) {
                            IsmReleaseMemory (paramsPatternExp);
                            paramsPatternExp = NULL;
                        }
                        if (targetPatternExp && (targetPatternExp != targetPattern)) {
                            IsmReleaseMemory (targetPatternExp);
                            targetPatternExp = NULL;
                        }
                        break;
                    }
                    if (workDirPatternExp && (workDirPatternExp != workDirPattern)) {
                        IsmReleaseMemory (workDirPatternExp);
                        workDirPatternExp = NULL;
                    }
                    if (paramsPatternExp && (paramsPatternExp != paramsPattern)) {
                        IsmReleaseMemory (paramsPatternExp);
                        paramsPatternExp = NULL;
                    }
                    if (targetPatternExp && (targetPatternExp != targetPattern)) {
                        IsmReleaseMemory (targetPatternExp);
                        targetPatternExp = NULL;
                    }
                } while (InfFindNextLine (&is));
            }

            InfNameHandle (infHandle, NULL, FALSE);

        } else {

            if (IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
                __try {
                    multiSz = AllocText (sizeNeeded);

                    if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                        __leave;
                    }

                    if (EnumFirstMultiSz (&e, multiSz)) {

                        do {

                            infHandle = InfOpenInfFile (e.CurrentString);
                            if (infHandle != INVALID_HANDLE_VALUE) {

                                if (InfFindFirstLine (infHandle, TEXT("ExcludedLinks"), NULL, &is)) {

                                    do {
                                        targetPattern = InfGetStringField (&is, 1);
                                        paramsPattern = InfGetStringField (&is, 2);
                                        workDirPattern = InfGetStringField (&is, 3);
                                        if (IsPatternMatch (targetPattern?targetPattern:TEXT("*"), Target?Target:TEXT("")) &&
                                            IsPatternMatch (paramsPattern?paramsPattern:TEXT("*"), Params?Params:TEXT("")) &&
                                            IsPatternMatch (workDirPattern?workDirPattern:TEXT("*"), WorkDir?WorkDir:TEXT(""))
                                            ) {
                                            result = TRUE;
                                            break;
                                        }
                                    } while (InfFindNextLine (&is));
                                }
                            }

                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;

                            if (result) {
                                break;
                            }

                        } while (EnumNextMultiSz (&e));

                    }
                }
                __finally {
                    FreeText (multiSz);
                }
            }
        }

        InfResetInfStruct (&is);
    }

    return result;
}

UINT
LinksCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    MIG_OBJECTID objectId;
    BOOL extractResult = FALSE;
    PCTSTR lnkTarget = NULL;
    PCTSTR newLnkTarget = NULL;
    PCTSTR expLnkTarget = NULL;
    PCTSTR lnkParams = NULL;
    PCTSTR lnkWorkDir = NULL;
    PCTSTR lnkIconPath = NULL;
    INT lnkIconNumber;
    WORD lnkHotKey;
    BOOL lnkDosApp;
    BOOL lnkMsDosMode;
    LNK_EXTRA_DATA lnkExtraData;
    MIG_OBJECTSTRINGHANDLE encodedName;
    MIG_OBJECTSTRINGHANDLE longEncodedName;
    MIG_OBJECTSTRINGHANDLE fullEncodedName;
    MIG_BLOB migBlob;
    PCTSTR expTmpStr;
    MIG_CONTENT lnkContent;
    MIG_CONTENT lnkIconContent;
    PICON_GROUP iconGroup = NULL;
    ICON_SGROUP iconSGroup;
    PCTSTR lnkIconResId = NULL;
    PCTSTR extPtr = NULL;
    BOOL exeDefaultIcon = FALSE;

    if (Data->IsLeaf) {

        objectId = IsmGetObjectIdFromName (MIG_FILE_TYPE, Data->ObjectName, TRUE);
        if (IsmIsPersistentObjectId (objectId)) {

            IsmSetAttributeOnObjectId (objectId, g_LnkMigAttr_Shortcut);

            if (IsmAcquireObjectEx (
                    Data->ObjectTypeId,
                    Data->ObjectName,
                    &lnkContent,
                    CONTENTTYPE_FILE,
                    0
                    )) {

                if (lnkContent.ContentInFile && lnkContent.FileContent.ContentPath) {

                    if (ExtractShortcutInfo (
                            lnkContent.FileContent.ContentPath,
                            &lnkTarget,
                            &lnkParams,
                            &lnkWorkDir,
                            &lnkIconPath,
                            &lnkIconNumber,
                            &lnkHotKey,
                            &lnkDosApp,
                            &lnkMsDosMode,
                            &lnkExtraData,
                            g_ShellLink,
                            g_PersistFile
                            )) {
                        // let's check if the LNK is excluded
                        if (pIsLnkExcluded (
                                objectId,
                                lnkTarget,
                                lnkParams,
                                lnkWorkDir
                                )) {
                            IsmClearPersistenceOnObjectId (objectId);
                        } else {
                            // let's get all the paths through the hooks and add everything as properties of this shortcut
                            if (lnkTarget) {
                                if (*lnkTarget) {
                                    // If we are on the destination system, we are going to have major problems here.
                                    // If the LNK had IDLISTs, we are going to get back a path that's local to the
                                    // destination machine. For example if the target was c:\Windows\Favorites on the
                                    // source system and that was the CSIDL_FAVORITES we are going to get back:
                                    // c:\Documents and Settings\username\Favorites.
                                    // Because of this problem we need to compress the path and then expand it back
                                    // using env. variables from the source system.
                                    if (IsmGetRealPlatform () == PLATFORM_DESTINATION) {
                                        newLnkTarget = IsmCompressEnvironmentString (
                                                            PLATFORM_DESTINATION,
                                                            S_SYSENVVAR_GROUP,
                                                            lnkTarget,
                                                            Data->NativeObjectName,
                                                            TRUE
                                                            );
                                    }
                                    // let's look if this is a valid file specification. If it is not, it might be
                                    // an URL or something else, so we will just migrate the thing
                                    expTmpStr = pSpecialExpandEnvironmentString (newLnkTarget?newLnkTarget:lnkTarget, Data->NativeObjectName);
                                    if (IsValidFileSpec (expTmpStr)) {
                                        // we are going to need this (maybe) later, if the icon path is NULL and this is an EXE
                                        expLnkTarget = DuplicatePathString (expTmpStr, 0);

                                        encodedName = pBuildEncodedNameFromNativeName (expTmpStr);
                                        longEncodedName = IsmGetLongName (MIG_FILE_TYPE|PLATFORM_SOURCE, encodedName);
                                        if (!longEncodedName) {
                                            longEncodedName = encodedName;
                                        }
                                        IsmExecuteHooks (MIG_FILE_TYPE|PLATFORM_SOURCE, longEncodedName);
                                        if (!g_VcmMode) {
                                            migBlob.Type = BLOBTYPE_STRING;
                                            migBlob.String = longEncodedName;
                                            IsmAddPropertyToObjectId (objectId, g_LnkMigProp_Target, &migBlob);
                                        } else {
                                            // persist the target so we can examine it later
                                            if (!IsmIsPersistentObject (MIG_FILE_TYPE, longEncodedName)) {
                                                IsmMakePersistentObject (MIG_FILE_TYPE, longEncodedName);
                                                IsmMakeNonCriticalObject (MIG_FILE_TYPE, longEncodedName);
                                            }
                                        }
                                        if (longEncodedName != encodedName) {
                                            IsmDestroyObjectHandle (longEncodedName);
                                        }
                                        if (encodedName) {
                                            IsmDestroyObjectHandle (encodedName);
                                        }
                                    } else {
                                        encodedName = pBuildEncodedNameFromNativeName (expTmpStr);
                                        if (!g_VcmMode) {
                                            migBlob.Type = BLOBTYPE_STRING;
                                            migBlob.String = encodedName;
                                            IsmAddPropertyToObjectId (objectId, g_LnkMigProp_Target, &migBlob);
                                        }
                                        if (encodedName) {
                                            IsmDestroyObjectHandle (encodedName);
                                        }
                                    }
                                    if (newLnkTarget) {
                                        IsmReleaseMemory (newLnkTarget);
                                        newLnkTarget = NULL;
                                    }
                                    IsmReleaseMemory (expTmpStr);
                                    expTmpStr = NULL;
                                } else {
                                    if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                                        IsmClearPersistenceOnObjectId (objectId);
                                    }
                                }
                                FreePathString (lnkTarget);
                            } else {
                                if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                                    IsmClearPersistenceOnObjectId (objectId);
                                }
                            }
                            if (lnkParams) {
                                if (*lnkParams) {
                                    if (!g_VcmMode) {
                                        migBlob.Type = BLOBTYPE_STRING;
                                        migBlob.String = lnkParams;
                                        IsmAddPropertyToObjectId (objectId, g_LnkMigProp_Params, &migBlob);
                                    }
                                }
                                FreePathString (lnkParams);
                            }
                            if (lnkWorkDir) {
                                if (*lnkWorkDir) {
                                    // let's save the raw working directory
                                    if (!g_VcmMode) {
                                        migBlob.Type = BLOBTYPE_STRING;
                                        migBlob.String = lnkWorkDir;
                                        IsmAddPropertyToObjectId (objectId, g_LnkMigProp_RawWorkDir, &migBlob);
                                    }
                                    expTmpStr = pSpecialExpandEnvironmentString (lnkWorkDir, Data->NativeObjectName);
                                    if (IsValidFileSpec (expTmpStr)) {
                                        encodedName = pBuildEncodedNameFromNativeName (expTmpStr);
                                        longEncodedName = IsmGetLongName (MIG_FILE_TYPE|PLATFORM_SOURCE, encodedName);
                                        if (!longEncodedName) {
                                            longEncodedName = encodedName;
                                        }
                                        IsmExecuteHooks (MIG_FILE_TYPE|PLATFORM_SOURCE, longEncodedName);
                                        if (!g_VcmMode) {
                                            migBlob.Type = BLOBTYPE_STRING;
                                            migBlob.String = longEncodedName;
                                            IsmAddPropertyToObjectId (objectId, g_LnkMigProp_WorkDir, &migBlob);
                                        } else {
                                            // persist the working directory (it has almost no space impact)
                                            // so we can examine it later
                                            if (!IsmIsPersistentObject (MIG_FILE_TYPE, longEncodedName)) {
                                                IsmMakePersistentObject (MIG_FILE_TYPE, longEncodedName);
                                                IsmMakeNonCriticalObject (MIG_FILE_TYPE, longEncodedName);
                                            }
                                        }
                                        if (longEncodedName != encodedName) {
                                            IsmDestroyObjectHandle (longEncodedName);
                                        }
                                        if (encodedName) {
                                            IsmDestroyObjectHandle (encodedName);
                                        }
                                    } else {
                                        encodedName = pBuildEncodedNameFromNativeName (expTmpStr);
                                        if (!g_VcmMode) {
                                            migBlob.Type = BLOBTYPE_STRING;
                                            migBlob.String = encodedName;
                                            IsmAddPropertyToObjectId (objectId, g_LnkMigProp_WorkDir, &migBlob);
                                        }
                                        if (encodedName) {
                                            IsmDestroyObjectHandle (encodedName);
                                        }
                                    }
                                    IsmReleaseMemory (expTmpStr);
                                    expTmpStr = NULL;
                                }
                                FreePathString (lnkWorkDir);
                            }
                            if (((!lnkIconPath) || (!(*lnkIconPath))) && expLnkTarget) {
                                extPtr = GetFileExtensionFromPath (expLnkTarget);
                                if (extPtr) {
                                    exeDefaultIcon = StringIMatch (extPtr, TEXT("EXE"));
                                    if (exeDefaultIcon) {
                                        if (lnkIconPath) {
                                            FreePathString (lnkIconPath);
                                        }
                                        lnkIconPath = expLnkTarget;
                                    }
                                }
                            }
                            if (lnkIconPath) {
                                if (*lnkIconPath) {
                                    // let's look if this is a valid file specification. If it is not, it might be
                                    // an URL or something else, so we will just migrate the thing
                                    expTmpStr = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, lnkIconPath, Data->NativeObjectName);
                                    if (IsValidFileSpec (expTmpStr)) {
                                        encodedName = pBuildEncodedNameFromNativeName (expTmpStr);
                                        longEncodedName = IsmGetLongName (MIG_FILE_TYPE|PLATFORM_SOURCE, encodedName);
                                        if (!longEncodedName) {
                                            longEncodedName = encodedName;
                                        }
                                        // Sometimes the icon is specified without full path (like foo.dll instead
                                        // of c:\windows\system\foo.dll). When this is the case we are going to
                                        // walk the %path% and %windir% and %system% and try to find the file there.
                                        fullEncodedName = pGetFullEncodedName (longEncodedName);
                                        if (fullEncodedName) {
                                            if (longEncodedName != encodedName) {
                                                IsmDestroyObjectHandle (longEncodedName);
                                            }
                                            longEncodedName = IsmGetLongName (MIG_FILE_TYPE|PLATFORM_SOURCE, fullEncodedName);
                                            if (!longEncodedName) {
                                                longEncodedName = fullEncodedName;
                                            } else {
                                                IsmDestroyObjectHandle (fullEncodedName);
                                                fullEncodedName = NULL;
                                            }
                                        }
                                        IsmExecuteHooks (MIG_FILE_TYPE|PLATFORM_SOURCE, longEncodedName);
                                        if (!g_VcmMode) {
                                            if (!exeDefaultIcon) {
                                                migBlob.Type = BLOBTYPE_STRING;
                                                migBlob.String = longEncodedName;
                                                IsmAddPropertyToObjectId (objectId, g_LnkMigProp_IconPath, &migBlob);
                                            }

                                            // one last thing: let's extract the icon and preserve it just in case.
                                            if (IsmAcquireObjectEx (
                                                    MIG_FILE_TYPE,
                                                    longEncodedName,
                                                    &lnkIconContent,
                                                    CONTENTTYPE_FILE,
                                                    0
                                                    )) {
                                                if (lnkIconContent.ContentInFile && lnkIconContent.FileContent.ContentPath) {
                                                    if (lnkIconNumber >= 0) {
                                                        iconGroup = IcoExtractIconGroupByIndexFromFile (
                                                                        lnkIconContent.FileContent.ContentPath,
                                                                        lnkIconNumber,
                                                                        NULL
                                                                        );
                                                    } else {
                                                        lnkIconResId = (PCTSTR) (LONG_PTR) (-lnkIconNumber);
                                                        iconGroup = IcoExtractIconGroupFromFile (
                                                                        lnkIconContent.FileContent.ContentPath,
                                                                        lnkIconResId,
                                                                        NULL
                                                                        );
                                                    }
                                                    if (iconGroup) {
                                                        if (IcoSerializeIconGroup (iconGroup, &iconSGroup)) {
                                                            migBlob.Type = BLOBTYPE_BINARY;
                                                            migBlob.BinaryData = (PCBYTE)(iconSGroup.Data);
                                                            migBlob.BinarySize = iconSGroup.DataSize;
                                                            IsmAddPropertyToObjectId (objectId, g_LnkMigProp_IconData, &migBlob);
                                                            IcoReleaseIconSGroup (&iconSGroup);
                                                        }
                                                        IcoReleaseIconGroup (iconGroup);
                                                    }
                                                }
                                                IsmReleaseObject (&lnkIconContent);
                                            }
                                        } else {
                                            // persist the icon file so we can examine it later
                                            if (!IsmIsPersistentObject (MIG_FILE_TYPE, longEncodedName)) {
                                                IsmMakePersistentObject (MIG_FILE_TYPE, longEncodedName);
                                                IsmMakeNonCriticalObject (MIG_FILE_TYPE, longEncodedName);
                                            }
                                        }

                                        if (longEncodedName != encodedName) {
                                            IsmDestroyObjectHandle (longEncodedName);
                                            longEncodedName = NULL;
                                        }
                                        if (encodedName) {
                                            IsmDestroyObjectHandle (encodedName);
                                            encodedName = NULL;
                                        }
                                    } else {
                                        encodedName = pBuildEncodedNameFromNativeName (expTmpStr);
                                        if (!g_VcmMode) {
                                            if (!exeDefaultIcon) {
                                                migBlob.Type = BLOBTYPE_STRING;
                                                migBlob.String = encodedName;
                                                IsmAddPropertyToObjectId (objectId, g_LnkMigProp_IconPath, &migBlob);
                                            }
                                        }
                                        if (encodedName) {
                                            IsmDestroyObjectHandle (encodedName);
                                        }
                                    }

                                    IsmReleaseMemory (expTmpStr);
                                    expTmpStr = NULL;
                                }
                                if (lnkIconPath != expLnkTarget) {
                                    FreePathString (lnkIconPath);
                                }
                            }

                            if (!g_VcmMode) {
                                migBlob.Type = BLOBTYPE_BINARY;
                                migBlob.BinaryData = (PCBYTE)(&lnkIconNumber);
                                migBlob.BinarySize = sizeof (INT);
                                IsmAddPropertyToObjectId (objectId, g_LnkMigProp_IconNumber, &migBlob);
                                migBlob.Type = BLOBTYPE_BINARY;
                                migBlob.BinaryData = (PCBYTE)(&lnkDosApp);
                                migBlob.BinarySize = sizeof (BOOL);
                                IsmAddPropertyToObjectId (objectId, g_LnkMigProp_DosApp, &migBlob);
                                if (lnkDosApp) {
                                    migBlob.Type = BLOBTYPE_BINARY;
                                    migBlob.BinaryData = (PCBYTE)(&lnkMsDosMode);
                                    migBlob.BinarySize = sizeof (BOOL);
                                    IsmAddPropertyToObjectId (objectId, g_LnkMigProp_MsDosMode, &migBlob);
                                    migBlob.Type = BLOBTYPE_BINARY;
                                    migBlob.BinaryData = (PCBYTE)(&lnkExtraData);
                                    migBlob.BinarySize = sizeof (LNK_EXTRA_DATA);
                                    IsmAddPropertyToObjectId (objectId, g_LnkMigProp_ExtraData, &migBlob);
                                } else {
                                    migBlob.Type = BLOBTYPE_BINARY;
                                    migBlob.BinaryData = (PCBYTE)(&lnkHotKey);
                                    migBlob.BinarySize = sizeof (WORD);
                                    IsmAddPropertyToObjectId (objectId, g_LnkMigProp_HotKey, &migBlob);
                                }
                                IsmSetOperationOnObjectId (
                                    objectId,
                                    g_LnkMigOp_FixContent,
                                    NULL,
                                    NULL
                                    );
                            }

                            if (expLnkTarget) {
                                FreePathString (expLnkTarget);
                                expLnkTarget = NULL;
                            }
                        }

                    } else {
                        if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                            IsmClearPersistenceOnObjectId (objectId);
                        }
                    }
                } else {
                    if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                        IsmClearPersistenceOnObjectId (objectId);
                    }
                }
                IsmReleaseObject (&lnkContent);
            } else {
                if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                    IsmClearPersistenceOnObjectId (objectId);
                }
            }
        }
    }
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
pCommonLnkMigQueueEnumeration (
    VOID
    )
{
    ENCODEDSTRHANDLE pattern;

    // hook all LNK files
    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, TEXT("*.lnk"), TRUE);
    if (pattern) {
        IsmHookEnumeration (MIG_FILE_TYPE, pattern, LinksCallback, (ULONG_PTR) 0, TEXT("Links.Files"));
        IsmDestroyObjectHandle (pattern);
    }

    // hook all PIF files
    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, TEXT("*.pif"), TRUE);
    if (pattern) {
        IsmHookEnumeration (MIG_FILE_TYPE, pattern, LinksCallback, (ULONG_PTR) 0, TEXT("Links.Files"));
        IsmDestroyObjectHandle (pattern);
    }

    // hook all URL files
    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, TEXT("*.url"), TRUE);
    if (pattern) {
        IsmHookEnumeration (MIG_FILE_TYPE, pattern, LinksCallback, (ULONG_PTR) 0, TEXT("Links.Files"));
        IsmDestroyObjectHandle (pattern);
    }

    IsmRegisterPreEnumerationCallback (LnkMigPreEnumeration, NULL);
    IsmRegisterPostEnumerationCallback (LnkMigPostEnumeration, NULL);

    return TRUE;
}

BOOL
WINAPI
LnkMigVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    return pCommonLnkMigQueueEnumeration ();
}

BOOL
WINAPI
LnkMigSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    return pCommonLnkMigQueueEnumeration ();
}

BOOL
pLnkFindFile (
    IN      PCTSTR FileName
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR node, leaf, leafPtr;
    BOOL result = FALSE;

    objectName = IsmCreateObjectHandle (FileName, NULL);
    if (objectName) {
        if (IsmGetObjectIdFromName (MIG_FILE_TYPE | PLATFORM_SOURCE, objectName, TRUE) != 0) {
            result = TRUE;
        }
        IsmDestroyObjectHandle (objectName);
    }
    if (!result) {
        node = DuplicateText (FileName);
        leaf = _tcsrchr (node, TEXT('\\'));
        if (leaf) {
            leafPtr = (PTSTR) leaf;
            leaf = _tcsinc (leaf);
            *leafPtr = 0;
            objectName = IsmCreateObjectHandle (node, leaf);
            if (objectName) {
                if (IsmGetObjectIdFromName (MIG_FILE_TYPE | PLATFORM_SOURCE, objectName, TRUE) != 0) {
                    result = TRUE;
                }
                IsmDestroyObjectHandle (objectName);
            }
            *leafPtr = TEXT('\\');
        }
        FreeText (node);
    }

    return result;
}

BOOL
pLnkSearchPath (
    IN      PCTSTR FileName,
    IN      DWORD BufferLength,
    OUT     PTSTR Buffer
    )
{
    return FALSE;
}

MIG_OBJECTSTRINGHANDLE
pLnkSimpleTryHandle (
    IN      PCTSTR FullPath
    )
{
    PCTSTR buffer;
    PTSTR leafPtr, leaf;
    MIG_OBJECTSTRINGHANDLE source = NULL;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    PTSTR workingPath;
    PCTSTR sanitizedPath;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    PCTSTR saved = NULL;

    sanitizedPath = SanitizePath (FullPath);
    if (!sanitizedPath) {
        return NULL;
    }

    source = IsmCreateObjectHandle (sanitizedPath, NULL);
    if (source) {
        result = IsmFilterObject (
                    MIG_FILE_TYPE | PLATFORM_SOURCE,
                    source,
                    NULL,
                    &orgDeleted,
                    &orgReplaced
                    );
        // we do not want replaced directories
        // since they can be false hits
        if (orgDeleted) {
            if (result) {
                saved = result;
                result = NULL;
            }
        }
        if (!result && !orgDeleted) {
            result = source;
        } else {
            IsmDestroyObjectHandle (source);
            source = NULL;
        }
    }

    if (result) {
        goto exit;
    }

    buffer = DuplicatePathString (sanitizedPath, 0);

    leaf = _tcsrchr (buffer, TEXT('\\'));

    if (leaf) {
        leafPtr = leaf;
        leaf = _tcsinc (leaf);
        *leafPtr = 0;
        source = IsmCreateObjectHandle (buffer, leaf);
        *leafPtr = TEXT('\\');
    }

    FreePathString (buffer);

    if (source) {
        result = IsmFilterObject (
                        MIG_FILE_TYPE | PLATFORM_SOURCE,
                        source,
                        NULL,
                        &orgDeleted,
                        &orgReplaced
                        );
        if (!result && !orgDeleted) {
            result = source;
        } else {
            if (!result) {
                result = saved;
            }
            IsmDestroyObjectHandle (source);
            source = NULL;
        }
    }

    if (result != saved) {
        IsmDestroyObjectHandle (saved);
        saved = NULL;
    }

exit:
    FreePathString (sanitizedPath);
    return result;
}

MIG_OBJECTSTRINGHANDLE
pLnkTryHandle (
    IN      PCTSTR FullPath,
    IN      PCTSTR Hint,
    OUT     PCTSTR *TrimmedResult
    )
{
    PATH_ENUM pathEnum;
    PCTSTR newPath;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    PCTSTR nativeName = NULL;
    PCTSTR lastSegPtr;

    if (TrimmedResult) {
        *TrimmedResult = NULL;
    }

    result = pLnkSimpleTryHandle (FullPath);
    if (result || (!Hint)) {
        return result;
    }
    if (EnumFirstPathEx (&pathEnum, Hint, NULL, NULL, FALSE)) {
        do {
            newPath = JoinPaths (pathEnum.PtrCurrPath, FullPath);
            result = pLnkSimpleTryHandle (newPath);
            if (result) {
                AbortPathEnum (&pathEnum);
                FreePathString (newPath);
                // now, if the initial FullPath did not have any wack in it
                // we will take the last segment of the result and put it
                // in TrimmedResult
                if (TrimmedResult && (!_tcschr (FullPath, TEXT('\\')))) {
                    nativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, result);
                    if (nativeName) {
                        lastSegPtr = _tcsrchr (nativeName, TEXT('\\'));
                        if (lastSegPtr) {
                            lastSegPtr = _tcsinc (lastSegPtr);
                            if (lastSegPtr) {
                                *TrimmedResult = DuplicatePathString (lastSegPtr, 0);
                            }
                        }
                    }
                }
                return result;
            }
            FreePathString (newPath);
        } while (EnumNextPath (&pathEnum));
    }
    AbortPathEnum (&pathEnum);
    return NULL;
}

PCTSTR
pFilterBuffer (
    IN      PCTSTR SourceBuffer,
    IN      PCTSTR HintBuffer
    )
{
    PCTSTR result = NULL;
    PCTSTR expBuffer = NULL;
    MIG_OBJECTSTRINGHANDLE destination;
    PCTSTR trimmedResult = NULL;
    BOOL replaced = FALSE;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    GROWBUFFER resultBuffer = INIT_GROWBUFFER;
    PCTSTR nativeDest;
    BOOL newContent = TRUE;
    PCTSTR destResult = NULL;
    PCTSTR newData, oldData;
    PCMDLINE cmdLine;
    GROWBUFFER cmdLineBuffer = INIT_GROWBUFFER;
    UINT u;
    PCTSTR p;

    expBuffer = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    SourceBuffer,
                    NULL
                    );

    if (expBuffer) {

        destination = pLnkTryHandle (expBuffer, HintBuffer, &trimmedResult);

        if (destination) {
            replaced = TRUE;
            if (trimmedResult) {
                GbAppendString (&resultBuffer, trimmedResult);
                FreePathString (trimmedResult);
            } else {
                nativeDest = IsmGetNativeObjectName (MIG_FILE_TYPE, destination);
                GbAppendString (&resultBuffer, nativeDest);
                IsmReleaseMemory (nativeDest);
            }
        }

        // finally, if we failed we are going to assume it's a command line
        if (!replaced) {
            newData = DuplicatePathString (expBuffer, 0);
            cmdLine = ParseCmdLineEx (expBuffer, NULL, &pLnkFindFile, &pLnkSearchPath, &cmdLineBuffer);
            if (cmdLine) {

                //
                // Find the file referenced in the list or command line
                //
                for (u = 0 ; u < cmdLine->ArgCount ; u++) {
                    p = cmdLine->Args[u].CleanedUpArg;

                    // first we try it as is

                    destination = pLnkTryHandle (p, HintBuffer, &trimmedResult);

                    // maybe we have something like /m:c:\foo.txt
                    // we need to go forward until we find a sequence of
                    // <alpha>:\<something>
                    if (!destination && p[0] && p[1]) {

                        while (p[2]) {
                            if (_istalpha ((CHARTYPE) _tcsnextc (p)) &&
                                p[1] == TEXT(':') &&
                                p[2] == TEXT('\\')
                                ) {

                                destination = pLnkTryHandle (p, HintBuffer, &trimmedResult);

                                if (destination) {
                                    break;
                                }
                            }
                            p ++;
                        }
                    }
                    if (destination) {
                        replaced = TRUE;
                        if (trimmedResult) {
                            oldData = StringSearchAndReplace (newData, p, trimmedResult);
                            if (oldData) {
                                FreePathString (newData);
                                newData = oldData;
                            }
                            FreePathString (trimmedResult);
                        } else {
                            nativeDest = IsmGetNativeObjectName (MIG_FILE_TYPE, destination);
                            oldData = StringSearchAndReplace (newData, p, nativeDest);
                            if (oldData) {
                                FreePathString (newData);
                                newData = oldData;
                            }
                            IsmReleaseMemory (nativeDest);
                        }
                        IsmDestroyObjectHandle (destination);
                        destination = NULL;
                    }
                }
            }
            GbFree (&cmdLineBuffer);
            if (!replaced) {
                if (newData) {
                    FreePathString (newData);
                }
            } else {
                if (newData) {
                    GbAppendString (&resultBuffer, newData);
                    FreePathString (newData);
                }
            }
        }

        if (destination) {
            IsmDestroyObjectHandle (destination);
            destination = NULL;
        }

        if (replaced && resultBuffer.Buf) {
            // looks like we have new content
            // Let's do one more check. If this is a REG_EXPAND_SZ we will do our best to
            // keep the stuff unexpanded. So if the source string expanded on the destination
            // machine is the same as the destination string we won't do anything.
            newContent = TRUE;
            destResult = IsmExpandEnvironmentString (
                            PLATFORM_DESTINATION,
                            S_SYSENVVAR_GROUP,
                            SourceBuffer,
                            NULL
                            );
            if (destResult && StringIMatch (destResult, (PCTSTR)resultBuffer.Buf)) {
                newContent = FALSE;
            }
            if (destResult) {
                IsmReleaseMemory (destResult);
                destResult = NULL;
            }
            if (newContent) {
                result = DuplicatePathString ((PCTSTR)resultBuffer.Buf, 0);
            }
        }

        GbFree (&resultBuffer);
    }

    return result;
}

BOOL
WINAPI
DoLnkContentFix (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_PROPERTYDATAID propDataId;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;
    BOOL lnkTargetPresent = FALSE;
    PCTSTR lnkTargetNode = NULL;
    PCTSTR lnkTargetLeaf = NULL;
    PCTSTR objectNode = NULL;
    PCTSTR objectLeaf = NULL;
    MIG_OBJECTSTRINGHANDLE lnkTarget = NULL;
    MIG_OBJECTTYPEID lnkTargetDestType = 0;
    MIG_OBJECTSTRINGHANDLE lnkTargetDest = NULL;
    BOOL lnkTargetDestDel = FALSE;
    BOOL lnkTargetDestRepl = FALSE;
    PCTSTR lnkTargetDestNative = NULL;
    PCTSTR lnkParams = NULL;
    PCTSTR lnkParamsNew = NULL;
    MIG_OBJECTSTRINGHANDLE lnkWorkDir = NULL;
    MIG_OBJECTTYPEID lnkWorkDirDestType = 0;
    MIG_OBJECTSTRINGHANDLE lnkWorkDirDest = NULL;
    BOOL lnkWorkDirDestDel = FALSE;
    BOOL lnkWorkDirDestRepl = FALSE;
    PCTSTR lnkWorkDirDestNative = NULL;
    PCTSTR lnkRawWorkDir = NULL;
    PCTSTR lnkRawWorkDirExp = NULL;
    MIG_OBJECTSTRINGHANDLE lnkIconPath = NULL;
    MIG_OBJECTTYPEID lnkIconPathDestType = 0;
    MIG_OBJECTSTRINGHANDLE lnkIconPathDest = NULL;
    BOOL lnkIconPathDestDel = FALSE;
    BOOL lnkIconPathDestRepl = FALSE;
    PCTSTR lnkIconPathDestNative = NULL;
    INT lnkIconNumber = 0;
    PICON_GROUP lnkIconGroup = NULL;
    ICON_SGROUP lnkIconSGroup = {0, NULL};
    WORD lnkHotKey = 0;
    BOOL lnkDosApp = FALSE;
    BOOL lnkMsDosMode = FALSE;
    PLNK_EXTRA_DATA lnkExtraData = NULL;
    BOOL comInit = FALSE;
    BOOL modifyFile = FALSE;
    PTSTR iconLibPath = NULL;
    PTSTR newShortcutPath = NULL;
    MIG_CONTENT lnkIconContent;

    // now it's finally time to fix the LNK file content
    if ((g_ShellLink == NULL) || (g_PersistFile == NULL)) {
        comInit = TRUE;
        if (!InitCOMLink (&g_ShellLink, &g_PersistFile)) {
            DEBUGMSG ((DBG_ERROR, "Error initializing COM %d", GetLastError ()));
            return TRUE;
        }
    }

    // first, retrieve the properties
    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_Target);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkTarget = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkTarget, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_Params);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkParams = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkParams, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_WorkDir);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkWorkDir = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkWorkDir, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId | PLATFORM_SOURCE, SrcObjectName, g_LnkMigProp_RawWorkDir);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkRawWorkDir = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkRawWorkDir, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_IconPath);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkIconPath = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkIconPath, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_IconNumber);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            if (requiredSize == sizeof (INT)) {
                IsmGetPropertyData (propDataId, (PBYTE)(&lnkIconNumber), requiredSize, NULL, &propDataType);
            }
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_IconData);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkIconSGroup.DataSize = requiredSize;
            lnkIconSGroup.Data = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkIconSGroup.Data, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_HotKey);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            if (requiredSize == sizeof (WORD)) {
                IsmGetPropertyData (propDataId, (PBYTE)(&lnkHotKey), requiredSize, NULL, &propDataType);
            }
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_DosApp);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            if (requiredSize == sizeof (BOOL)) {
                IsmGetPropertyData (propDataId, (PBYTE)(&lnkDosApp), requiredSize, NULL, &propDataType);
            }
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_MsDosMode);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            if (requiredSize == sizeof (BOOL)) {
                IsmGetPropertyData (propDataId, (PBYTE)(&lnkMsDosMode), requiredSize, NULL, &propDataType);
            }
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_ExtraData);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkExtraData = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkExtraData, requiredSize, NULL, &propDataType);
        }
    }

    // let's examine the target, see if it was migrated
    if (lnkTarget) {
        lnkTargetDest = IsmFilterObject (
                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                            lnkTarget,
                            &lnkTargetDestType,
                            &lnkTargetDestDel,
                            &lnkTargetDestRepl
                            );
        if (((lnkTargetDestDel == FALSE) || (lnkTargetDestRepl == TRUE)) &&
            ((lnkTargetDestType & (~PLATFORM_MASK)) == MIG_FILE_TYPE)
            ) {
            if (lnkTargetDest) {
                // the target changed location, we need to adjust the link
                modifyFile = TRUE;
                lnkTargetDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkTargetDest);
            }
        }
        lnkTargetPresent = !lnkTargetDestDel;
    }

    // let's examine the parameters
    if (lnkParams) {
        lnkParamsNew = pFilterBuffer (lnkParams, NULL);
        if (lnkParamsNew) {
            modifyFile = TRUE;
        }
    }

    // let's examine the working directory
    if (lnkWorkDir) {
        lnkWorkDirDest = IsmFilterObject (
                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                            lnkWorkDir,
                            &lnkWorkDirDestType,
                            &lnkWorkDirDestDel,
                            &lnkWorkDirDestRepl
                            );
        if (((lnkWorkDirDestDel == FALSE) || (lnkWorkDirDestRepl == TRUE)) &&
            ((lnkWorkDirDestType & (~PLATFORM_MASK)) == MIG_FILE_TYPE)
            ) {
            if (lnkWorkDirDest) {
                // the working directory changed location
                // Normally we would want to adjust the link's working directory
                // to point to the new location. However, let's take the raw working directory,
                // expand it and see if it matches the lnkWorkDirDest. If it does we won't touch
                // it since the raw working directory is working great. If it doesn't we will
                // modify the link
                lnkWorkDirDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkWorkDirDest);
                lnkRawWorkDirExp = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, lnkRawWorkDir, NULL);
                if ((!lnkWorkDirDestNative) ||
                    (!lnkRawWorkDirExp) ||
                    (!StringIMatch (lnkRawWorkDirExp, lnkWorkDirDestNative))) {
                    modifyFile = TRUE;
                } else {
                    IsmReleaseMemory (lnkWorkDirDestNative);
                    lnkWorkDirDestNative = NULL;
                }
                if (lnkRawWorkDirExp) {
                    IsmReleaseMemory (lnkRawWorkDirExp);
                    lnkRawWorkDirExp = NULL;
                }
            }
        } else {
            // seems like the working directory is gone. If the target is still present, we will adjust
            // the working directory to point where the target is located
            if (lnkTargetPresent) {
                if (IsmCreateObjectStringsFromHandle (lnkTargetDest?lnkTargetDest:lnkTarget, &lnkTargetNode, &lnkTargetLeaf)) {
                    lnkWorkDirDest = IsmCreateObjectHandle (lnkTargetNode, NULL);
                    if (lnkWorkDirDest) {
                        modifyFile = TRUE;
                        lnkWorkDirDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkWorkDirDest);
                    }
                    IsmDestroyObjectString (lnkTargetNode);
                    IsmDestroyObjectString (lnkTargetLeaf);
                }
            }
        }
    }

    // let's examine the icon path
    if (lnkIconPath) {
        lnkIconPathDest = IsmFilterObject (
                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                            lnkIconPath,
                            &lnkIconPathDestType,
                            &lnkIconPathDestDel,
                            &lnkIconPathDestRepl
                            );
        // if the icon holder is deleted we will extract the icon and put it in our lib.
        // The point is, even if the icon holder is replaced (that is, exists on the destination
        // machine), we cannot guarantee that the icon indexes will be the same. Typically, shell32.dll
        // icon indexes changed from version to version, and if a user picked an shell32.dll icon on Win9x,
        // he will have a surprise on Win XP. If we wanted to keep the icon from the replacement file, we just
        // need to check for lnkIconPathDestRepl.
        if ((lnkIconPathDestDel == FALSE) &&
            ((lnkIconPathDestType & (~PLATFORM_MASK)) == MIG_FILE_TYPE)
            ) {
            if (lnkIconPathDest) {
                // the icon path changed location, we need to adjust the link
                modifyFile = TRUE;
                lnkIconPathDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkIconPathDest);
            }
        } else {
            // seems like the icon path is gone. If the we have the icon extracted we will try to add it to the
            // icon library and adjust this link to point there.
            if (lnkIconSGroup.DataSize) {
                lnkIconGroup = IcoDeSerializeIconGroup (&lnkIconSGroup);
                if (lnkIconGroup) {
                    if (IsmGetEnvironmentString (
                            PLATFORM_DESTINATION,
                            NULL,
                            S_ENV_ICONLIB,
                            NULL,
                            0,
                            &requiredSize
                            )) {
                        iconLibPath = PmGetMemory (g_LinksPool, requiredSize);
                        if (IsmGetEnvironmentString (
                                PLATFORM_DESTINATION,
                                NULL,
                                S_ENV_ICONLIB,
                                iconLibPath,
                                requiredSize,
                                NULL
                                )) {
                            if (IcoWriteIconGroupToPeFile (iconLibPath, lnkIconGroup, NULL, &lnkIconNumber)) {
                                modifyFile = TRUE;
                                lnkIconPathDestNative = IsmGetMemory (SizeOfString (iconLibPath));
                                StringCopy ((PTSTR)lnkIconPathDestNative, iconLibPath);
                                IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_SAVE_ICONLIB);
                            }
                        }
                        PmReleaseMemory (g_LinksPool, iconLibPath);
                    }
                    IcoReleaseIconGroup (lnkIconGroup);
                }
            } else {
                // we don't have the icon extracted. Let's just do our best and update the
                // icon path to point to the destination replacement.
                if (((lnkIconPathDestType & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
                    (lnkIconPathDest)
                    ) {
                    // the icon path changed location, we need to adjust the link
                    modifyFile = TRUE;
                    lnkIconPathDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkIconPathDest);
                }
            }
        }
    } else {
        // If we have an icon extracted, but the icon path is NULL, it
        // means that the original LNK had no icon associated with it
        // but it's target was an EXE. In this case the icon that was
        // displayed was the first icon from the EXE. Now we want to
        // make sure that the destination target has at least one icon
        // in it. If it doesn't we will just hook the source extracted icon.
        if (lnkIconSGroup.DataSize) {
            // let's see if the destination target has at least one icon
            if (IsmAcquireObjectEx (
                    MIG_FILE_TYPE | PLATFORM_DESTINATION,
                    lnkTargetDest?lnkTargetDest:lnkTarget,
                    &lnkIconContent,
                    CONTENTTYPE_FILE,
                    0
                    )) {
                if (lnkIconContent.ContentInFile && lnkIconContent.FileContent.ContentPath) {
                    lnkIconGroup = IcoExtractIconGroupByIndexFromFile (
                                    lnkIconContent.FileContent.ContentPath,
                                    0,
                                    NULL
                                    );
                    if (lnkIconGroup) {
                        // Yes, it has at least one icon, we're safe
                        IcoReleaseIconGroup (lnkIconGroup);
                        lnkIconGroup = NULL;
                    } else {
                        // Nope, it does not have any icons
                        lnkIconGroup = IcoDeSerializeIconGroup (&lnkIconSGroup);
                        if (lnkIconGroup) {
                            if (IsmGetEnvironmentString (
                                    PLATFORM_DESTINATION,
                                    NULL,
                                    S_ENV_ICONLIB,
                                    NULL,
                                    0,
                                    &requiredSize
                                    )) {
                                iconLibPath = PmGetMemory (g_LinksPool, requiredSize);
                                if (IsmGetEnvironmentString (
                                        PLATFORM_DESTINATION,
                                        NULL,
                                        S_ENV_ICONLIB,
                                        iconLibPath,
                                        requiredSize,
                                        NULL
                                        )) {
                                    if (IcoWriteIconGroupToPeFile (iconLibPath, lnkIconGroup, NULL, &lnkIconNumber)) {
                                        modifyFile = TRUE;
                                        lnkIconPathDestNative = IsmGetMemory (SizeOfString (iconLibPath));
                                        StringCopy ((PTSTR)lnkIconPathDestNative, iconLibPath);
                                        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_SAVE_ICONLIB);
                                    }
                                }
                                PmReleaseMemory (g_LinksPool, iconLibPath);
                            }
                            IcoReleaseIconGroup (lnkIconGroup);
                        }
                    }
                }
                IsmReleaseObject (&lnkIconContent);
            }
        }
    }

    if (modifyFile) {
        if (CurrentContent->ContentInFile) {
            if (IsmCreateObjectStringsFromHandle (SrcObjectName, &objectNode, &objectLeaf)) {
                // We need to modify the shortcut. Unfortunately, if this is the command
                // line tool, the shortcut we are going to modify is not some temporary file,
                // it is the actual shortcut from the store. As a result, if you try to
                // apply a second time, the shortcut would be already modified and problems
                // may appear. For this, we will get a temporary directory from ISM,
                // copy the current shortcut (CurrentContent->FileContent.ContentPath) and
                // modify it and generate a new content.
                newShortcutPath = IsmGetMemory (MAX_PATH);
                if (newShortcutPath) {
                    if (IsmGetTempFile (newShortcutPath, MAX_PATH)) {
                        if (CopyFile (
                                (PCTSTR) CurrentContent->FileContent.ContentPath,
                                newShortcutPath,
                                FALSE
                                )) {
                            if (ModifyShortcutFileEx (
                                    newShortcutPath,
                                    GetFileExtensionFromPath (objectLeaf),
                                    lnkTargetDestNative,
                                    lnkParamsNew,
                                    lnkWorkDirDestNative,
                                    lnkIconPathDestNative,
                                    lnkIconNumber,
                                    lnkHotKey,
                                    NULL,
                                    g_ShellLink,
                                    g_PersistFile
                                    )) {
                                NewContent->FileContent.ContentPath = newShortcutPath;
                            }
                        }
                    }
                }
                IsmDestroyObjectString (objectNode);
                IsmDestroyObjectString (objectLeaf);
            }
        } else {
            // something is wrong, the content of this shortcut should be in a file
            MYASSERT (FALSE);
        }
    }

    if (lnkIconPathDestNative) {
        IsmReleaseMemory (lnkIconPathDestNative);
        lnkIconPathDestNative = NULL;
    }

    if (lnkWorkDirDestNative) {
        IsmReleaseMemory (lnkWorkDirDestNative);
        lnkWorkDirDestNative = NULL;
    }

    if (lnkTargetDestNative) {
        IsmReleaseMemory (lnkTargetDestNative);
        lnkTargetDestNative = NULL;
    }

    if (lnkIconPathDest) {
        IsmDestroyObjectHandle (lnkIconPathDest);
        lnkIconPathDest = NULL;
    }

    if (lnkWorkDirDest) {
        IsmDestroyObjectHandle (lnkWorkDirDest);
        lnkWorkDirDest = NULL;
    }

    if (lnkTargetDest) {
        IsmDestroyObjectHandle (lnkTargetDest);
        lnkTargetDest = NULL;
    }

    if (lnkExtraData) {
        PmReleaseMemory (g_LinksPool, lnkExtraData);
        lnkExtraData = NULL;
    }

    if (lnkIconSGroup.DataSize && lnkIconSGroup.Data) {
        PmReleaseMemory (g_LinksPool, lnkIconSGroup.Data);
        lnkIconSGroup.DataSize = 0;
        lnkIconSGroup.Data = NULL;
    }

    if (lnkIconPath) {
        PmReleaseMemory (g_LinksPool, lnkIconPath);
        lnkIconPath = NULL;
    }

    if (lnkWorkDir) {
        PmReleaseMemory (g_LinksPool, lnkWorkDir);
        lnkWorkDir = NULL;
    }

    if (lnkParams) {
        PmReleaseMemory (g_LinksPool, lnkParams);
        lnkParams = NULL;
    }

    if (lnkTarget) {
        PmReleaseMemory (g_LinksPool, lnkTarget);
        lnkTarget = NULL;
    }

    if (comInit) {
        FreeCOMLink (&g_ShellLink, &g_PersistFile);
        g_ShellLink = NULL;
        g_PersistFile = NULL;
    }

    return TRUE;
}

BOOL
LinkRestoreCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    MIG_PROPERTYDATAID propDataId;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;
    MIG_OBJECTSTRINGHANDLE lnkTarget = NULL;
    MIG_OBJECTTYPEID lnkTargetDestType = 0;
    MIG_OBJECTSTRINGHANDLE lnkTargetDest = NULL;
    BOOL lnkTargetDestDel = FALSE;
    BOOL lnkTargetDestRepl = FALSE;
    PCTSTR lnkTargetNative = NULL;
    PCTSTR objectNode = NULL;
    PCTSTR objectLeaf = NULL;
    PCTSTR extPtr = NULL;
    PCTSTR userProfile = NULL;
    PCTSTR allUsersProfile = NULL;
    PCTSTR newObjectNode = NULL;
    MIG_OBJECTSTRINGHANDLE newObjectName = NULL;
    MIG_CONTENT oldContent;
    MIG_CONTENT newContent;
    BOOL identical = FALSE;
    BOOL diffDetailsOnly = FALSE;
    BOOL result = TRUE;

    if (IsmIsAttributeSetOnObjectId (ObjectId, g_CopyIfRelevantAttr)) {
        if (IsmCreateObjectStringsFromHandle (ObjectName, &objectNode, &objectLeaf)) {
            if (objectLeaf) {
                extPtr = GetFileExtensionFromPath (objectLeaf);
                if (extPtr &&
                    (StringIMatch (extPtr, TEXT("LNK")) ||
                     StringIMatch (extPtr, TEXT("PIF"))
                     )
                    ) {
                    propDataId = IsmGetPropertyFromObject (ObjectTypeId, ObjectName, g_LnkMigProp_Target);
                    if (propDataId) {
                        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
                            lnkTarget = PmGetMemory (g_LinksPool, requiredSize);
                            IsmGetPropertyData (propDataId, (PBYTE)lnkTarget, requiredSize, NULL, &propDataType);
                            lnkTargetNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkTarget);
                            if (lnkTargetNative) {
                                if (pIsUncPath (lnkTargetNative)) {
                                    result = TRUE;
                                } else {
                                    lnkTargetDest = IsmFilterObject (
                                                        MIG_FILE_TYPE | PLATFORM_SOURCE,
                                                        lnkTarget,
                                                        &lnkTargetDestType,
                                                        &lnkTargetDestDel,
                                                        &lnkTargetDestRepl
                                                        );
                                    result = (lnkTargetDestDel == FALSE) || (lnkTargetDestRepl == TRUE);
                                    if (lnkTargetDest) {
                                        IsmDestroyObjectHandle (lnkTargetDest);
                                    }
                                }
                                IsmReleaseMemory (lnkTargetNative);
                            } else {
                                result = FALSE;
                            }
                            PmReleaseMemory (g_LinksPool, lnkTarget);
                        }
                    }
                    if (result) {
                        // one more thing. If this LNK is in %USERPROFILE% and an equivalent LNK
                        // (same name, same target, same arguments, same working dir) can be found
                        // in %ALLUSERSPROFILE% then we won't restore this LNK. Similarly, if the
                        // LNK is in %ALLUSERSPROFILE% and an equivalent LNK exists in %USERPROFILE%
                        // we won't restore the LNK.
                        userProfile = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, TEXT ("%USERPROFILE%"), NULL);
                        allUsersProfile = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT ("%ALLUSERSPROFILE%"), NULL);
                        if (userProfile && allUsersProfile && objectNode) {
                            if (StringIPrefix (objectNode, userProfile)) {
                                newObjectNode = StringSearchAndReplace (objectNode, userProfile, allUsersProfile);
                                if (newObjectNode) {
                                    newObjectName = IsmCreateObjectHandle (newObjectNode, objectLeaf);
                                    if (newObjectName) {
                                        if (IsmAcquireObjectEx (
                                                (ObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                                                newObjectName,
                                                &newContent,
                                                CONTENTTYPE_FILE,
                                                0
                                                )) {
                                            if (IsmAcquireObjectEx (
                                                    ObjectTypeId,
                                                    ObjectName,
                                                    &oldContent,
                                                    CONTENTTYPE_FILE,
                                                    0
                                                    )) {
                                                if (LinkDoesContentMatch (
                                                        FALSE,
                                                        ObjectTypeId,
                                                        ObjectName,
                                                        &oldContent,
                                                        (ObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                                                        newObjectName,
                                                        &newContent,
                                                        &identical,
                                                        &diffDetailsOnly
                                                        )) {
                                                    result = (!identical) && (!diffDetailsOnly);
                                                }
                                                IsmReleaseObject (&oldContent);
                                            }
                                            IsmReleaseObject (&newContent);
                                        }
                                        IsmDestroyObjectHandle (newObjectName);
                                        newObjectName = NULL;
                                    }
                                    FreePathString (newObjectNode);
                                    newObjectNode = NULL;
                                }
                            }
                        }
                        if (userProfile) {
                            IsmReleaseMemory (userProfile);
                            userProfile = NULL;
                        }
                        if (allUsersProfile) {
                            IsmReleaseMemory (allUsersProfile);
                            allUsersProfile = NULL;
                        }
                        allUsersProfile = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, TEXT ("%ALLUSERSPROFILE%"), NULL);
                        userProfile = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT ("%USERPROFILE%"), NULL);
                        if (userProfile && allUsersProfile && objectNode) {
                            if (StringIPrefix (objectNode, allUsersProfile)) {
                                newObjectNode = StringSearchAndReplace (objectNode, allUsersProfile, userProfile);
                                if (newObjectNode) {
                                    newObjectName = IsmCreateObjectHandle (newObjectNode, objectLeaf);
                                    if (newObjectName) {
                                        if (IsmAcquireObjectEx (
                                                (ObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                                                newObjectName,
                                                &newContent,
                                                CONTENTTYPE_FILE,
                                                0
                                                )) {
                                            if (IsmAcquireObjectEx (
                                                    ObjectTypeId,
                                                    ObjectName,
                                                    &oldContent,
                                                    CONTENTTYPE_FILE,
                                                    0
                                                    )) {
                                                if (LinkDoesContentMatch (
                                                        FALSE,
                                                        ObjectTypeId,
                                                        ObjectName,
                                                        &oldContent,
                                                        (ObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                                                        newObjectName,
                                                        &newContent,
                                                        &identical,
                                                        &diffDetailsOnly
                                                        )) {
                                                    result = (!identical) || (!diffDetailsOnly);
                                                }
                                                IsmReleaseObject (&oldContent);
                                            }
                                            IsmReleaseObject (&newContent);
                                        }
                                        IsmDestroyObjectHandle (newObjectName);
                                        newObjectName = NULL;
                                    }
                                    FreePathString (newObjectNode);
                                    newObjectNode = NULL;
                                }
                            }
                        }
                        if (userProfile) {
                            IsmReleaseMemory (userProfile);
                            userProfile = NULL;
                        }
                        if (allUsersProfile) {
                            IsmReleaseMemory (allUsersProfile);
                            allUsersProfile = NULL;
                        }
                    }
                }
            }
            IsmDestroyObjectString (objectNode);
            IsmDestroyObjectString (objectLeaf);
        }
    }
    return result;
}

BOOL
pMatchWinSysFiles (
    IN      PCTSTR Source,
    IN      PCTSTR Destination
    )
{
    PCTSTR srcLeaf;
    PCTSTR destLeaf;
    PCTSTR winDir = NULL;
    PCTSTR sysDir = NULL;
    BOOL result = FALSE;

    __try {
        if ((!Source) || (!Destination)) {
            __leave;
        }
        srcLeaf = _tcsrchr (Source, TEXT('\\'));
        destLeaf = _tcsrchr (Destination, TEXT('\\'));
        if ((!srcLeaf) || (!destLeaf)) {
            __leave;
        }
        if (!StringIMatch (srcLeaf, destLeaf)) {
            __leave;
        }
        // now let's see if the directory for each is either
        // %windir% or %system%
        // Source is already modified to what it would look like on the destination machine,
        // let's just expand the PLATFORM_DESTINATION env. variables.
        winDir = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT("%windir%"), NULL);
        sysDir = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT("%system%"), NULL);
        if ((!winDir) || (!sysDir)) {
            __leave;
        }
        if (!StringIPrefix (Source, winDir) && !StringIPrefix (Source, sysDir)) {
            __leave;
        }
        IsmReleaseMemory (winDir);
        winDir = NULL;
        IsmReleaseMemory (sysDir);
        sysDir = NULL;

        winDir = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT("%windir%"), NULL);
        sysDir = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT("%system%"), NULL);
        if ((!winDir) || (!sysDir)) {
            __leave;
        }
        if (!StringIPrefix (Destination, winDir) && !StringIPrefix (Destination, sysDir)) {
            __leave;
        }
        IsmReleaseMemory (winDir);
        winDir = NULL;
        IsmReleaseMemory (sysDir);
        sysDir = NULL;

        result = TRUE;
    }
    __finally {
        if (winDir) {
            IsmReleaseMemory (winDir);
            winDir = NULL;
        }
        if (sysDir) {
            IsmReleaseMemory (sysDir);
            sysDir = NULL;
        }
    }
    return result;
}

BOOL
pForcedLnkMatch (
    IN      PCTSTR SrcTarget,
    IN      PCTSTR SrcParams,
    IN      PCTSTR SrcWorkDir,
    IN      PCTSTR DestTarget,
    IN      PCTSTR DestParams,
    IN      PCTSTR DestWorkDir
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR srcTargetPat = NULL;
    PCTSTR srcParamsPat = NULL;
    PCTSTR srcWorkDirPat = NULL;
    PCTSTR destTargetPat = NULL;
    PCTSTR destParamsPat = NULL;
    PCTSTR destWorkDirPat = NULL;
    BOOL result = FALSE;

    // let's look in the INFs in section [EquivalentLinks] and see if our LNKs match
    // one of the lines. If they do then they are equivalent
    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (InfFindFirstLine (infHandle, TEXT("EquivalentLinks"), NULL, &is)) {

            do {
                srcTargetPat = InfGetStringField (&is, 1);
                srcParamsPat = InfGetStringField (&is, 2);
                srcWorkDirPat = InfGetStringField (&is, 3);
                destTargetPat = InfGetStringField (&is, 4);
                destParamsPat = InfGetStringField (&is, 5);
                destWorkDirPat = InfGetStringField (&is, 6);
                if (IsPatternMatch (srcTargetPat?srcTargetPat:TEXT("*"), SrcTarget?SrcTarget:TEXT("")) &&
                    IsPatternMatch (srcParamsPat?srcParamsPat:TEXT("*"), SrcParams?SrcParams:TEXT("")) &&
                    IsPatternMatch (srcWorkDirPat?srcWorkDirPat:TEXT("*"), SrcWorkDir?SrcWorkDir:TEXT("")) &&
                    IsPatternMatch (destTargetPat?destTargetPat:TEXT("*"), DestTarget?DestTarget:TEXT("")) &&
                    IsPatternMatch (destParamsPat?destParamsPat:TEXT("*"), DestParams?DestParams:TEXT("")) &&
                    IsPatternMatch (destWorkDirPat?destWorkDirPat:TEXT("*"), DestWorkDir?DestWorkDir:TEXT(""))
                    ) {
                    result = TRUE;
                    break;
                }
                if (IsPatternMatch (srcTargetPat?srcTargetPat:TEXT("*"), DestTarget?DestTarget:TEXT("")) &&
                    IsPatternMatch (srcParamsPat?srcParamsPat:TEXT("*"), DestParams?DestParams:TEXT("")) &&
                    IsPatternMatch (srcWorkDirPat?srcWorkDirPat:TEXT("*"), DestWorkDir?DestWorkDir:TEXT("")) &&
                    IsPatternMatch (destTargetPat?destTargetPat:TEXT("*"), SrcTarget?SrcTarget:TEXT("")) &&
                    IsPatternMatch (destParamsPat?destParamsPat:TEXT("*"), SrcParams?SrcParams:TEXT("")) &&
                    IsPatternMatch (destWorkDirPat?destWorkDirPat:TEXT("*"), SrcWorkDir?SrcWorkDir:TEXT(""))
                    ) {
                    result = TRUE;
                    break;
                }
            } while (InfFindNextLine (&is));
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            __try {
                multiSz = AllocText (sizeNeeded);

                if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                    __leave;
                }

                if (EnumFirstMultiSz (&e, multiSz)) {

                    do {

                        infHandle = InfOpenInfFile (e.CurrentString);
                        if (infHandle != INVALID_HANDLE_VALUE) {

                            if (InfFindFirstLine (infHandle, TEXT("EquivalentLinks"), NULL, &is)) {

                                do {
                                    srcTargetPat = InfGetStringField (&is, 1);
                                    srcParamsPat = InfGetStringField (&is, 2);
                                    srcWorkDirPat = InfGetStringField (&is, 3);
                                    destTargetPat = InfGetStringField (&is, 4);
                                    destParamsPat = InfGetStringField (&is, 5);
                                    destWorkDirPat = InfGetStringField (&is, 6);
                                    if (IsPatternMatch (srcTargetPat?srcTargetPat:TEXT("*"), SrcTarget?SrcTarget:TEXT("")) &&
                                        IsPatternMatch (srcParamsPat?srcParamsPat:TEXT("*"), SrcParams?SrcParams:TEXT("")) &&
                                        IsPatternMatch (srcWorkDirPat?srcWorkDirPat:TEXT("*"), SrcWorkDir?SrcWorkDir:TEXT("")) &&
                                        IsPatternMatch (destTargetPat?destTargetPat:TEXT("*"), DestTarget?DestTarget:TEXT("")) &&
                                        IsPatternMatch (destParamsPat?destParamsPat:TEXT("*"), DestParams?DestParams:TEXT("")) &&
                                        IsPatternMatch (destWorkDirPat?destWorkDirPat:TEXT("*"), DestWorkDir?DestWorkDir:TEXT(""))
                                        ) {
                                        result = TRUE;
                                        break;
                                    }
                                    if (IsPatternMatch (srcTargetPat?srcTargetPat:TEXT("*"), DestTarget?DestTarget:TEXT("")) &&
                                        IsPatternMatch (srcParamsPat?srcParamsPat:TEXT("*"), DestParams?DestParams:TEXT("")) &&
                                        IsPatternMatch (srcWorkDirPat?srcWorkDirPat:TEXT("*"), DestWorkDir?DestWorkDir:TEXT("")) &&
                                        IsPatternMatch (destTargetPat?destTargetPat:TEXT("*"), SrcTarget?SrcTarget:TEXT("")) &&
                                        IsPatternMatch (destParamsPat?destParamsPat:TEXT("*"), SrcParams?SrcParams:TEXT("")) &&
                                        IsPatternMatch (destWorkDirPat?destWorkDirPat:TEXT("*"), SrcWorkDir?SrcWorkDir:TEXT(""))
                                        ) {
                                        result = TRUE;
                                        break;
                                    }
                                } while (InfFindNextLine (&is));
                            }
                        }

                        InfCloseInfFile (infHandle);
                        infHandle = INVALID_HANDLE_VALUE;

                        if (result) {
                            break;
                        }

                    } while (EnumNextMultiSz (&e));

                }
            }
            __finally {
                FreeText (multiSz);
            }
        }
    }

    InfResetInfStruct (&is);

    return result;
}

BOOL
LinkDoesContentMatch (
    IN      BOOL AlreadyProcessed,
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PMIG_CONTENT SrcContent,
    IN      MIG_OBJECTTYPEID DestObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE DestObjectName,
    IN      PMIG_CONTENT DestContent,
    OUT     PBOOL Identical,
    OUT     PBOOL DifferentDetailsOnly
    )
{
    PCTSTR objectNode = NULL;
    PCTSTR objectLeaf = NULL;
    PCTSTR extPtr = NULL;
    MIG_PROPERTYDATAID propDataId;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;
    MIG_OBJECTSTRINGHANDLE srcTarget = NULL;
    PCTSTR srcTargetNative = NULL;
    PCTSTR srcParams = NULL;
    PCTSTR srcParamsNew = NULL;
    MIG_OBJECTSTRINGHANDLE srcWorkDir = NULL;
    PCTSTR srcWorkDirNative = NULL;
    PCTSTR srcRawWorkDir = NULL;
    BOOL lnkWorkDirDestDel = FALSE;
    BOOL lnkWorkDirDestRepl = FALSE;
    PCTSTR destTarget = NULL;
    PCTSTR destParams = NULL;
    PCTSTR destWorkDir = NULL;
    PCTSTR destIconPath = NULL;
    PCTSTR expTmpStr;
    PCTSTR longExpTmpStr;
    INT destIconNumber;
    WORD destHotKey;
    BOOL destDosApp;
    BOOL destMsDosMode;
    BOOL comInit = FALSE;
    MIG_OBJECTSTRINGHANDLE lnkDest = NULL;
    PCTSTR lnkNative = NULL;
    BOOL targetOsFile = FALSE;
    BOOL match = FALSE;
    BOOL result = FALSE;

    if ((SrcObjectTypeId & ~PLATFORM_MASK) != MIG_FILE_TYPE) {
        return FALSE;
    }

    if ((DestObjectTypeId & ~PLATFORM_MASK) != MIG_FILE_TYPE) {
        return FALSE;
    }

    // let's check that the source is a shortcut
    if (IsmCreateObjectStringsFromHandle (SrcObjectName, &objectNode, &objectLeaf)) {
        if (objectLeaf) {
            extPtr = GetFileExtensionFromPath (objectLeaf);
            if (extPtr &&
                (StringIMatch (extPtr, TEXT("LNK")) ||
                 StringIMatch (extPtr, TEXT("PIF")) ||
                 StringIMatch (extPtr, TEXT("URL"))
                 )
                ) {
                result = TRUE;
            }
        }
        IsmDestroyObjectString (objectNode);
        IsmDestroyObjectString (objectLeaf);
    }
    if (!result) {
        return FALSE;
    }
    result = FALSE;

    // let's check that the destination is a shortcut
    if (IsmCreateObjectStringsFromHandle (DestObjectName, &objectNode, &objectLeaf)) {
        if (objectLeaf) {
            extPtr = GetFileExtensionFromPath (objectLeaf);
            if (extPtr &&
                (StringIMatch (extPtr, TEXT("LNK")) ||
                 StringIMatch (extPtr, TEXT("PIF")) ||
                 StringIMatch (extPtr, TEXT("URL"))
                 )
                ) {
                result = TRUE;
            }
        }
        IsmDestroyObjectString (objectNode);
        IsmDestroyObjectString (objectLeaf);
    }
    if (!result) {
        return FALSE;
    }

    // some safety checks
    if (!SrcContent->ContentInFile) {
        return FALSE;
    }
    if (!SrcContent->FileContent.ContentPath) {
        return FALSE;
    }
    if (!DestContent->ContentInFile) {
        return FALSE;
    }
    if (!DestContent->FileContent.ContentPath) {
        return FALSE;
    }

    result = FALSE;

    __try {

        // let's get info from the source. We will not look inside the LNK file, we will
        // just get it's properties. If there are no properties, we'll just exit, leaving
        // the default compare to solve the problem.

        // first, retrieve the properties
        propDataId = IsmGetPropertyFromObject (SrcObjectTypeId | PLATFORM_SOURCE, SrcObjectName, g_LnkMigProp_Target);
        if (propDataId) {
            if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
                srcTarget = PmGetMemory (g_LinksPool, requiredSize);
                IsmGetPropertyData (propDataId, (PBYTE)srcTarget, requiredSize, NULL, &propDataType);
            }
        }

        propDataId = IsmGetPropertyFromObject (SrcObjectTypeId | PLATFORM_SOURCE, SrcObjectName, g_LnkMigProp_Params);
        if (propDataId) {
            if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
                srcParams = PmGetMemory (g_LinksPool, requiredSize);
                IsmGetPropertyData (propDataId, (PBYTE)srcParams, requiredSize, NULL, &propDataType);
            }
        }

        propDataId = IsmGetPropertyFromObject (SrcObjectTypeId | PLATFORM_SOURCE, SrcObjectName, g_LnkMigProp_RawWorkDir);
        if (propDataId) {
            if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
                srcRawWorkDir = PmGetMemory (g_LinksPool, requiredSize);
                IsmGetPropertyData (propDataId, (PBYTE)srcRawWorkDir, requiredSize, NULL, &propDataType);
            }
        }

        propDataId = IsmGetPropertyFromObject (SrcObjectTypeId | PLATFORM_SOURCE, SrcObjectName, g_LnkMigProp_WorkDir);
        if (propDataId) {
            if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
                srcWorkDir = PmGetMemory (g_LinksPool, requiredSize);
                IsmGetPropertyData (propDataId, (PBYTE)srcWorkDir, requiredSize, NULL, &propDataType);
            }
        }

        // now, let's get the info from the destination shortcut
        if ((g_ShellLink == NULL) || (g_PersistFile == NULL)) {
            comInit = TRUE;
            if (!InitCOMLink (&g_ShellLink, &g_PersistFile)) {
                DEBUGMSG ((DBG_ERROR, "Error initializing COM %d", GetLastError ()));
                return TRUE;
            }
        }
        if (!ExtractShortcutInfo (
                DestContent->FileContent.ContentPath,
                &destTarget,
                &destParams,
                &destWorkDir,
                &destIconPath,
                &destIconNumber,
                &destHotKey,
                &destDosApp,
                &destMsDosMode,
                NULL,
                g_ShellLink,
                g_PersistFile
                )) {
            __leave;
        }

        srcTargetNative = IsmGetNativeObjectName (MIG_FILE_TYPE, srcTarget);
        srcWorkDirNative = IsmGetNativeObjectName (MIG_FILE_TYPE, srcWorkDir);

        if (pForcedLnkMatch (
                srcTargetNative,
                srcParams,
                srcWorkDirNative,
                destTarget,
                destParams,
                destWorkDir
                )) {
            if (srcTargetNative) {
                IsmReleaseMemory (srcTargetNative);
                srcTargetNative = NULL;
            }
            if (srcWorkDirNative) {
                IsmReleaseMemory (srcWorkDirNative);
                srcWorkDirNative = NULL;
            }
            result = TRUE;
            if (Identical) {
                *Identical = TRUE;
            }
            if (DifferentDetailsOnly) {
                *DifferentDetailsOnly = FALSE;
            }
            __leave;
        }
        if (srcTargetNative) {
            IsmReleaseMemory (srcTargetNative);
            srcTargetNative = NULL;
        }
        if (srcWorkDirNative) {
            IsmReleaseMemory (srcWorkDirNative);
            srcWorkDirNative = NULL;
        }

        // let's filter the source target and see if it matches the dest target
        match = TRUE;
        if (srcTarget && *srcTarget && destTarget && *destTarget) {

            // let's see if the source target is an OS file
            targetOsFile = IsmIsAttributeSetOnObject (MIG_FILE_TYPE|PLATFORM_SOURCE, srcTarget, g_OsFileAttribute);

            lnkDest = IsmFilterObject (
                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                            srcTarget,
                            NULL,
                            NULL,
                            NULL
                            );
            if (!lnkDest) {
                lnkDest = srcTarget;
            }
            lnkNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkDest);
            if (lnkNative) {
                expTmpStr = IsmExpandEnvironmentString (
                                PLATFORM_DESTINATION,
                                S_SYSENVVAR_GROUP,
                                destTarget,
                                NULL
                                );
                if (!expTmpStr) {
                    expTmpStr = destTarget;
                }
                longExpTmpStr = BfGetLongFileName (expTmpStr);
                if (!longExpTmpStr) {
                    longExpTmpStr = expTmpStr;
                }
                if (!StringIMatch (lnkNative, longExpTmpStr)) {
                    // different targets
                    // Let's try another trick to catch some OS files getting moved.
                    // For example, in Win9x systems, notepad.exe is in %windir%.
                    // In XP, it was moved to %system%. We'll try to match the target
                    // if the last segment is the same and the rest is either %windir%
                    // or %system%
                    if (!pMatchWinSysFiles (lnkNative, longExpTmpStr)) {
                        match = FALSE;
                    }
                }
                if (longExpTmpStr != expTmpStr) {
                    FreePathString (longExpTmpStr);
                }
                if (expTmpStr != destTarget) {
                    IsmReleaseMemory (expTmpStr);
                }
                IsmReleaseMemory (lnkNative);
                lnkNative = NULL;
            } else {
                match = FALSE;
            }
            if (lnkDest != srcTarget) {
                IsmDestroyObjectHandle (lnkDest);
            }
            lnkDest = NULL;
        } else {
            if (srcTarget && *srcTarget) {
                match = FALSE;
            }
            if (destTarget && *destTarget) {
                match = FALSE;
            }
        }

        // the target did not match
        if (!match) {
            __leave;
        }

        // let's match the src and dest parameters
        match = TRUE;
        if (srcParams && *srcParams && destParams && *destParams) {
            // srcParams might have source paths embedded in them.
            // Let's try to filter them and get the parameters as
            // they would look on the destination machine
            srcParamsNew = pFilterBuffer (srcParams, NULL);
            if (!StringIMatch (srcParamsNew?srcParamsNew:srcParams, destParams)) {
                // different parameters
                match = FALSE;
            }
            if (srcParamsNew) {
                FreePathString (srcParamsNew);
                srcParamsNew = NULL;
            }
        } else {
            if (srcParams && *srcParams) {
                match = FALSE;
            }
            if (destParams && *destParams) {
                match = FALSE;
            }
        }

        // the parameters did not match
        if (!match) {
            __leave;
        }

        // let's filter the source work dir and see if it matches the dest work dir.
        match = TRUE;
        // if the source target was an OS file we will ignore the working directory match
        if (!targetOsFile) {
            if (srcWorkDir && *srcWorkDir && destWorkDir && *destWorkDir) {
                lnkDest = IsmFilterObject (
                                MIG_FILE_TYPE | PLATFORM_SOURCE,
                                srcWorkDir,
                                NULL,
                                &lnkWorkDirDestDel,
                                &lnkWorkDirDestRepl
                                );
                if (!lnkDest) {
                    // if the working directory is deleted and not
                    // replaced it means it will go away. In that case
                    // we don't really care about working directory
                    // matching the destination one.
                    if ((!lnkWorkDirDestDel) || lnkWorkDirDestRepl) {
                        lnkDest = srcWorkDir;
                    }
                }
                if (lnkDest) {
                    lnkNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkDest);
                    if (lnkNative) {
                        expTmpStr = IsmExpandEnvironmentString (
                                        PLATFORM_DESTINATION,
                                        S_SYSENVVAR_GROUP,
                                        destWorkDir,
                                        NULL
                                        );
                        if (!expTmpStr) {
                            expTmpStr = destWorkDir;
                        }
                        longExpTmpStr = BfGetLongFileName (expTmpStr);
                        if (!longExpTmpStr) {
                            longExpTmpStr = expTmpStr;
                        }
                        if (!StringIMatch (lnkNative, longExpTmpStr)) {
                            // different working directories
                            // let's test the raw versions just in case
                            if (!srcRawWorkDir || !StringIMatch (srcRawWorkDir, destWorkDir)) {
                                match = FALSE;
                            }
                        }
                        if (longExpTmpStr != expTmpStr) {
                            FreePathString (longExpTmpStr);
                        }
                        if (expTmpStr != destWorkDir) {
                            IsmReleaseMemory (expTmpStr);
                        }
                        IsmReleaseMemory (lnkNative);
                        lnkNative = NULL;
                    } else {
                        match = FALSE;
                    }
                    if (lnkDest != srcWorkDir) {
                        IsmDestroyObjectHandle (lnkDest);
                    }
                    lnkDest = NULL;
                }
            } else {
                if (srcWorkDir && *srcWorkDir) {
                    match = FALSE;
                }
                if (destWorkDir && *destWorkDir) {
                    match = FALSE;
                }
            }
        }

        // the working directory did not match
        if (!match) {
            __leave;
        }

        result = TRUE;

        if (Identical) {
            *Identical = TRUE;
        }
        if (DifferentDetailsOnly) {
            *DifferentDetailsOnly = FALSE;
        }

    }
    __finally {
        if (srcTarget) {
            PmReleaseMemory (g_LinksPool, srcTarget);
            srcTarget = NULL;
        }
        if (srcParams) {
            PmReleaseMemory (g_LinksPool, srcParams);
            srcParams = NULL;
        }
        if (srcRawWorkDir) {
            PmReleaseMemory (g_LinksPool, srcRawWorkDir);
            srcRawWorkDir = NULL;
        }
        if (srcWorkDir) {
            PmReleaseMemory (g_LinksPool, srcWorkDir);
            srcWorkDir = NULL;
        }
        if (destTarget) {
            FreePathString (destTarget);
            destTarget = NULL;
        }
        if (destParams) {
            FreePathString (destParams);
            destParams = NULL;
        }
        if (destWorkDir) {
            FreePathString (destWorkDir);
            destWorkDir = NULL;
        }
        if (destIconPath) {
            FreePathString (destIconPath);
            destIconPath = NULL;
        }
        if (comInit) {
            FreeCOMLink (&g_ShellLink, &g_PersistFile);
            g_ShellLink = NULL;
            g_PersistFile = NULL;
        }
        if (lnkNative) {
            IsmReleaseMemory (lnkNative);
            lnkNative = NULL;
        }
    }

    return result;
}

BOOL
WINAPI
LnkMigOpmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_LnkMigAttr_Shortcut = IsmRegisterAttribute (S_LNKMIGATTR_SHORTCUT, FALSE);
    g_CopyIfRelevantAttr = IsmRegisterAttribute (S_ATTRIBUTE_COPYIFRELEVANT, FALSE);
    g_OsFileAttribute = IsmRegisterAttribute (S_ATTRIBUTE_OSFILE, FALSE);

    g_LnkMigProp_Target = IsmRegisterProperty (S_LNKMIGPROP_TARGET, FALSE);
    g_LnkMigProp_Params = IsmRegisterProperty (S_LNKMIGPROP_PARAMS, FALSE);
    g_LnkMigProp_WorkDir = IsmRegisterProperty (S_LNKMIGPROP_WORKDIR, FALSE);
    g_LnkMigProp_IconPath = IsmRegisterProperty (S_LNKMIGPROP_ICONPATH, FALSE);
    g_LnkMigProp_IconNumber = IsmRegisterProperty (S_LNKMIGPROP_ICONNUMBER, FALSE);
    g_LnkMigProp_IconData = IsmRegisterProperty (S_LNKMIGPROP_ICONDATA, FALSE);
    g_LnkMigProp_HotKey = IsmRegisterProperty (S_LNKMIGPROP_HOTKEY, FALSE);
    g_LnkMigProp_DosApp = IsmRegisterProperty (S_LNKMIGPROP_DOSAPP, FALSE);
    g_LnkMigProp_MsDosMode = IsmRegisterProperty (S_LNKMIGPROP_MSDOSMODE, FALSE);
    g_LnkMigProp_ExtraData = IsmRegisterProperty (S_LNKMIGPROP_EXTRADATA, FALSE);

    g_LnkMigOp_FixContent = IsmRegisterOperation (S_OPERATION_LNKMIG_FIXCONTENT, FALSE);

    IsmRegisterRestoreCallback (LinkRestoreCallback);
    IsmRegisterCompareCallback (MIG_FILE_TYPE, LinkDoesContentMatch);
    IsmRegisterOperationApplyCallback (g_LnkMigOp_FixContent, DoLnkContentFix, TRUE);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\migdb.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdb.c

Abstract:

    This source implements old AppDb functionality

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

    jimschm     23-Sep-1998 Updated for new fileops code
    jimschm     25-Feb-1998 Added UninstallSection support
    calinn      19-Jan-1998 Added CANCELLED response

--*/

#include "pch.h"
#include "logmsg.h"
#include "osfiles.h"

#define DBG_MIGDB           "MigDb"
#define S_STRINGS           TEXT("Strings")

//
// Globals
//

PMHANDLE            g_MigDbPool     = NULL;
PMIGDB_CONTEXT      g_ContextList   = NULL;
HASHTABLE           g_FileTable     = NULL;
PMIGDB_TYPE_RULE    g_TypeRule      = NULL;
GROWBUFFER          g_TypeRuleList  = INIT_GROWBUFFER;
HINF                g_OsFilesInf    = INVALID_HANDLE_VALUE;

GROWBUFFER          g_AttrGrowBuff  = INIT_GROWBUFFER;
GROWBUFFER          g_TypeGrowBuff  = INIT_GROWBUFFER;

static PINFCONTEXT g_Line;
PMIGDB_HOOK_PROTOTYPE g_MigDbHook = NULL;


#define ArgFunction     TEXT("ARG")
#define ArgFunctionLen  3


BOOL
pCallAction (
    IN      PMIGDB_CONTEXT MigDbContext
    );

PMIGDB_ATTRIB
pLoadAttribData (
    IN      PCTSTR MultiSzStr
    );

PMIGDB_HOOK_PROTOTYPE
SetMigDbHook (
    PMIGDB_HOOK_PROTOTYPE HookFunction
    )
{
    PMIGDB_HOOK_PROTOTYPE savedHook;

    savedHook = g_MigDbHook;
    g_MigDbHook = HookFunction;
    return savedHook;
}

INT
pGetAttribIndex (
    IN      PCTSTR AttribName
    )

/*++

Routine Description:

  This routine returns the index in attribute functions array for a specified attribute.

Arguments:

  AttribName - Attribute name

Return value:

  -1 - no such attribute in attribute table

--*/

{
    INT attribIndex;
    INT rc = 0;
    PTSTR attrEnd = NULL;
    TCHAR savedChar = 0;

    attrEnd = (PTSTR) SkipSpaceR (AttribName, GetEndOfString (AttribName));
    if (attrEnd != NULL) {
        attrEnd = _tcsinc (attrEnd);
        savedChar = attrEnd [0];
        attrEnd [0] = 0;
    }
    __try {
        attribIndex = MigDb_GetAttributeIdx (AttribName);
        if (attribIndex == -1) {
            LOG((LOG_ERROR, (PCSTR) MSG_MIGDB_ATTRIBUTE_NOT_FOUND, AttribName));
        }
        rc = attribIndex;
    }
    __finally {
        if (attrEnd != NULL) {
            attrEnd [0] = savedChar;
        }
    }

    return rc;
}

BOOL
pValidateArg (
    IN OUT  PMIGDB_ATTRIB AttribStruct
    )
{
    MYASSERT (AttribStruct);

    if (AttribStruct->ArgCount != MigDb_GetReqArgCount (AttribStruct->AttribIndex)) {

#ifdef DEBUG
        if (AttribStruct->AttribIndex != -1) {
            TCHAR Buffer[16384];

            SetupGetLineText (g_Line, NULL, NULL, NULL, Buffer, ARRAYSIZE(Buffer), NULL);
            DEBUGMSG ((
                DBG_WHOOPS,
                "Discarding attribute %s because of too few arguments.\n"
                    "  Line: %s\n",
                MigDb_GetAttributeName (AttribStruct->AttribIndex),
                Buffer
                ));
        }
#endif

        AttribStruct->AttribIndex = -1;
        return FALSE;
    }

    return TRUE;
}


#define STATE_ATTRNAME  1
#define STATE_ATTRARG   2

PMIGDB_ATTRIB
pLoadAttribData (
    IN      PCTSTR MultiSzStr
    )

/*++

Routine Description:

  This routine creates a list of MIGDB_ATTRIBs from a multisz.

Arguments:

  MultiSzStr - multisz to be processed

Return value:

  MIGDB_ATTRIB nodes

--*/

{
    MULTISZ_ENUM multiSzEnum;
    PMIGDB_ATTRIB result  = NULL;
    PMIGDB_ATTRIB tmpAttr = NULL;
    INT state = STATE_ATTRNAME;
    PTSTR currStrPtr = NULL;
    PTSTR currArgPtr = NULL;
    PTSTR endArgPtr  = NULL;
    TCHAR savedChar  = 0;

    g_AttrGrowBuff.End = 0;

    if (EnumFirstMultiSz (&multiSzEnum, MultiSzStr)) {
        do {
            currStrPtr = (PTSTR) SkipSpace (multiSzEnum.CurrentString);
            if (state == STATE_ATTRNAME) {
                tmpAttr = (PMIGDB_ATTRIB) PmGetMemory (g_MigDbPool, sizeof (MIGDB_ATTRIB));

                ZeroMemory (tmpAttr, sizeof (MIGDB_ATTRIB));

                if (_tcsnextc (currStrPtr) == TEXT('!')) {
                    currStrPtr = _tcsinc (currStrPtr);
                    currStrPtr = (PTSTR) SkipSpace (currStrPtr);
                    tmpAttr->NotOperator = TRUE;
                }

                currArgPtr = _tcschr (currStrPtr, TEXT('('));

                if (currArgPtr) {
                    endArgPtr = _tcsdec (currStrPtr, currArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PTSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _tcsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }
                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    *endArgPtr = savedChar;
                    currStrPtr = _tcsinc (currArgPtr);
                    state = STATE_ATTRARG;
                }
                else {
                    // this attribute has no arguments.
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                    continue;
                }
            }
            if (state == STATE_ATTRARG) {
                currStrPtr = (PTSTR) SkipSpace (currStrPtr);
                endArgPtr = _tcsrchr (currStrPtr, TEXT(')'));
                if (endArgPtr) {
                    endArgPtr = _tcsdec (currStrPtr, endArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PTSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _tcsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }
                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                }

                GbMultiSzAppend (&g_AttrGrowBuff, currStrPtr);

                tmpAttr->ArgCount++;

                if (endArgPtr) {
                    *endArgPtr = savedChar;
                    tmpAttr->Arguments = PmDuplicateMultiSz (g_MigDbPool, (PTSTR)g_AttrGrowBuff.Buf);
                    g_AttrGrowBuff.End = 0;
                    state = STATE_ATTRNAME;
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                }
            }
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    return result;
}


BOOL
AddFileToMigDbLinkage (
    IN      PCTSTR FileName,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex            OPTIONAL
    )
{
    TCHAR tempField [MEMDB_MAX];
    DWORD fieldIndex = FieldIndex;
    PMIGDB_FILE   migDbFile   = NULL;
    PMIGDB_ATTRIB migDbAttrib = NULL;
    HASHITEM stringId;
    FILE_LIST_STRUCT fileList;

    //creating MIGDB_FILE structure for current file
    migDbFile = (PMIGDB_FILE) PmGetMemory (g_MigDbPool, sizeof (MIGDB_FILE));
    if (migDbFile != NULL) {
        ZeroMemory (migDbFile, sizeof (MIGDB_FILE));
        migDbFile->Section = g_ContextList->Sections;

        if (Context) {
            fieldIndex ++;

            if (SetupGetMultiSzField (Context, fieldIndex, tempField, MEMDB_MAX, NULL)) {

                g_Line = Context;
                migDbFile->Attributes = pLoadAttribData (tempField);

                if (g_MigDbHook != NULL) {
                    migDbAttrib = migDbFile->Attributes;
                    while (migDbAttrib) {
                        g_MigDbHook (FileName, g_ContextList, g_ContextList->Sections, migDbFile, migDbAttrib);
                        migDbAttrib = migDbAttrib->Next;
                    }
                }
            }
        }

        //adding this file into string table and create a MIGDB_FILE node. If file
        //already exists in string table then just create another MIGDB_FILE node
        //chained with already existing ones.
        stringId = HtFindString (g_FileTable, FileName);

        if (stringId) {
            HtCopyStringData (g_FileTable, stringId, &fileList);

            fileList.Last->Next = migDbFile;
            fileList.Last = migDbFile;

            HtSetStringData (g_FileTable, stringId, &fileList);

        } else {
            fileList.First = fileList.Last = migDbFile;
            HtAddStringAndData (g_FileTable, FileName, &fileList);
        }
    }

    return TRUE;
}


BOOL
pScanForFile (
    IN      PINFCONTEXT Context,
    IN      DWORD FieldIndex
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified file info from inf file.
  Creates a migdb file node and the file is added in a string table for fast query.

Arguments:

  SectionStr  - section to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    TCHAR fileName [MEMDB_MAX];

    //scanning for file name
    if (!SetupGetStringField (Context, FieldIndex, fileName, MEMDB_MAX, NULL)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_FILENAME));
        return FALSE;
    }

    return AddFileToMigDbLinkage (fileName, Context, FieldIndex);
}


BOOL
pMigDbAddRuleToTypeRule (
    IN      PMIGDB_TYPE_RULE TypeRule,
    IN      PMIGDB_RULE Rule
    )
{
    PMIGDB_CHAR_NODE node, currNode, prevNode;
    PTSTR nodeBase;
    PCTSTR p;
    WORD w;
    BOOL found;

    if (Rule->NodeBase) {
        currNode = TypeRule->FirstLevel;
        prevNode = currNode;
        nodeBase = DuplicatePathString (Rule->NodeBase, 0);
        CharLower (nodeBase);
        p = nodeBase;
        while (*p) {
            w = (WORD) _tcsnextc (p);
            p = _tcsinc (p);
            if (currNode) {
                if (currNode->Char == w) {
                    if (!*p) {
                        Rule->NextRule = currNode->RuleList;
                        currNode->RuleList = Rule;
                    }
                    prevNode = currNode;
                    currNode = currNode->NextLevel;
                } else {
                    found = FALSE;
                    while (!found && currNode->NextPeer) {
                        if (currNode->NextPeer->Char == w) {
                            if (!*p) {
                                Rule->NextRule = currNode->NextPeer->RuleList;
                                currNode->NextPeer->RuleList = Rule;
                            }
                            prevNode = currNode->NextPeer;
                            currNode = prevNode->NextLevel;
                            found = TRUE;
                            break;
                        }
                        currNode = currNode->NextPeer;
                    }
                    if (!found) {
                        node = PmGetMemory (g_MigDbPool, sizeof (MIGDB_CHAR_NODE));
                        ZeroMemory (node, sizeof (MIGDB_CHAR_NODE));
                        if (!*p) {
                            node->RuleList = Rule;
                        }
                        node->Char = w;
                        node->NextPeer = currNode->NextPeer;
                        currNode->NextPeer = node;
                        prevNode = node;
                        currNode = node->NextLevel;
                    }
                }
            } else {
                node = PmGetMemory (g_MigDbPool, sizeof (MIGDB_CHAR_NODE));
                ZeroMemory (node, sizeof (MIGDB_CHAR_NODE));
                if (!*p) {
                    node->RuleList = Rule;
                }
                node->Char = w;
                if (prevNode) {
                    prevNode->NextLevel = node;
                } else {
                    TypeRule->FirstLevel = node;
                }
                prevNode = node;
                currNode = prevNode->NextLevel;
            }
        }
        FreePathString (nodeBase);
    } else {
        Rule->NextRule = TypeRule->RuleList;
        TypeRule->RuleList = Rule;
    }
    return TRUE;
}


BOOL
AddPatternToMigDbLinkage (
    IN      PCTSTR LeafPattern,
    IN      PCTSTR NodePattern,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex,
    IN      INT IncludeNodes
    )
{
    PMIGDB_RULE rule;
    MIG_SEGMENTS nodeSegment;
    MIG_SEGMENTS leafSegment;
    PCTSTR ourEncodedString;
    PCTSTR nodeBase;
    TCHAR tempField [MEMDB_MAX];
    DWORD fieldIndex = FieldIndex;

    nodeSegment.Segment = NodePattern ? NodePattern : TEXT("*");
    nodeSegment.IsPattern = TRUE;

    leafSegment.Segment = LeafPattern ? LeafPattern : TEXT("*");
    leafSegment.IsPattern = TRUE;

    ourEncodedString = IsmCreateObjectPattern (
                            &nodeSegment,
                            1,
                            &leafSegment,
                            1
                            );

    //
    // build the rule
    //
    rule = PmGetMemory (g_MigDbPool, sizeof (MIGDB_RULE));
    ZeroMemory (rule, sizeof (MIGDB_RULE));

    if (NodePattern) {
        nodeBase = GetPatternBase (NodePattern);
        if (nodeBase) {
            rule->NodeBase = PmDuplicateString (g_MigDbPool, nodeBase);
            FreePathString (nodeBase);
        }
    }
    rule->ObjectPattern = PmDuplicateString (g_MigDbPool, ourEncodedString);
    rule->ParsedPattern = ObsCreateParsedPatternEx (g_MigDbPool, ourEncodedString, FALSE);
    MYASSERT (rule->ParsedPattern);
    if (rule->ParsedPattern) {

        // add aditional information
        rule->Section = g_ContextList->Sections;
        if (Context) {

            fieldIndex ++;

            if (SetupGetMultiSzField (Context, fieldIndex, tempField, MEMDB_MAX, NULL)) {

                g_Line = Context;
                rule->Attributes = pLoadAttribData (tempField);
            }
        }

        rule->IncludeNodes = IncludeNodes;

        pMigDbAddRuleToTypeRule (g_TypeRule, rule);
    }

    IsmDestroyObjectHandle (ourEncodedString);

    return TRUE;
}


BOOL
pScanForFilePattern (
    IN      PINFCONTEXT Context,
    IN      DWORD FieldIndex
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified file pattern info from inf file.
  Creates a migdb file node and the file is added in a string table for fast query.

Arguments:

  Context - inf context for the section that we are currently processing
  FieldIndex - field index to start with

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    TCHAR leafPattern [MEMDB_MAX];
    PCTSTR leafPatternExp = NULL;
    TCHAR nodePattern [MEMDB_MAX];
    PCTSTR nodePatternExp = NULL;
    PCTSTR sanitizedPath = NULL;
    INT includeNodes = 0;
    BOOL result = TRUE;

    //scanning for leaf pattern
    if (!SetupGetStringField (Context, FieldIndex, leafPattern, MEMDB_MAX, NULL)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_FILENAME));
        return FALSE;
    }
    leafPatternExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, leafPattern, NULL);

    FieldIndex ++;

    //scanning for node pattern
    if (!SetupGetStringField (Context, FieldIndex, nodePattern, MEMDB_MAX, NULL)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_FILENAME));
        return FALSE;
    }
    nodePatternExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, nodePattern, NULL);

    if (nodePatternExp) {
        sanitizedPath = SanitizePath (nodePatternExp);
    }

    FieldIndex ++;

    //scanning for indicator if we should include the nodes as well
    if (!SetupGetIntField (Context, FieldIndex, &includeNodes)) {
        includeNodes = 0;
    }

    result =  AddPatternToMigDbLinkage (
                    leafPatternExp?leafPatternExp:leafPattern,
                    sanitizedPath?sanitizedPath:nodePattern,
                    Context,
                    FieldIndex,
                    includeNodes
                    );

    if (leafPatternExp) {
        IsmReleaseMemory (leafPatternExp);
        leafPatternExp = NULL;
    }

    if (nodePatternExp) {
        IsmReleaseMemory (nodePatternExp);
        nodePatternExp = NULL;
    }
    if (sanitizedPath) {
        FreePathString (sanitizedPath);
    }

    return result;
}


/*++

Routine Description:

  The subsequent two routines enumerate the sections with a particular name and
  with .999 extension from an inf file.

Arguments:

  SectEnum  - enumeration structure

Return value:

  TRUE  - enumeration continues
  FALSE - enumeration ended

--*/

typedef struct _SECT_ENUM {
    HINF InfHandle;
    INT  SectIndex;
    PTSTR SectNameEnd;
    PTSTR SectName;
} SECT_ENUM, *PSECT_ENUM;


VOID
pAbortSectionEnum (
    IN OUT  PSECT_ENUM SectEnum
    )
{
    if (SectEnum && SectEnum->SectName) {
        FreePathString (SectEnum->SectName);
        SectEnum->SectName = NULL;
        SectEnum->SectNameEnd = NULL;
    }
}


BOOL
pEnumNextSection (
    IN OUT  PSECT_ENUM SectEnum
    )
{
    INFCONTEXT context;
    BOOL result = FALSE;

    if (SectEnum->SectIndex == -1) {
        pAbortSectionEnum (SectEnum);
        return FALSE;
    }
    SectEnum->SectIndex ++;
    _stprintf (SectEnum->SectNameEnd, TEXT(".%d"), SectEnum->SectIndex);
    result = SetupFindFirstLine (SectEnum->InfHandle, SectEnum->SectName, NULL, &context);
    if (!result) {
        pAbortSectionEnum (SectEnum);
    }
    return result;
}


BOOL
pEnumFirstSection (
    OUT     PSECT_ENUM SectEnum,
    IN      PCTSTR SectionStr,
    IN      HINF InfHandle
    )
{
    INFCONTEXT context;

    ZeroMemory (SectEnum, sizeof (SECT_ENUM));
    SectEnum->SectIndex = -1;
    if (SetupFindFirstLine (InfHandle, SectionStr, NULL, &context)) {
        //good, only one section
        SectEnum->SectName = DuplicatePathString (SectionStr, 0);
        return TRUE;
    }
    else {
        //more than one section
        SectEnum->SectIndex = 0;
        SectEnum->InfHandle = InfHandle;
        SectEnum->SectName = DuplicatePathString (SectionStr, 32);
        if (SectEnum->SectName) {
            SectEnum->SectNameEnd = GetEndOfString (SectEnum->SectName);
            if (SectEnum->SectNameEnd) {
                return pEnumNextSection (SectEnum);
            }
        }
    }
    // something went wrong, let's get out of here
    return FALSE;
}


BOOL
pLoadSectionData (
    IN      PCTSTR SectionStr,
    IN      BOOL PatternScan
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified section from inf file. For
  every line in the section there is a migdb file node created. Also the file is added in
  a string table for fast query.

Arguments:

  SectionStr  - section to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    INFCONTEXT context;
    SECT_ENUM sectEnum;
    PMIGDB_SECTION migDbSection;
    BOOL result = TRUE;

    MYASSERT (g_OsFilesInf != INVALID_HANDLE_VALUE);

    if (pEnumFirstSection (&sectEnum, SectionStr, g_OsFilesInf)) {
        do {
            //initialize the section (this context can have multiple sections)
            //and parse the file info
            migDbSection = (PMIGDB_SECTION) PmGetMemory (g_MigDbPool, sizeof (MIGDB_SECTION));
            if (migDbSection != NULL) {

                ZeroMemory (migDbSection, sizeof (MIGDB_SECTION));
                migDbSection->Context = g_ContextList;
                migDbSection->Next = g_ContextList->Sections;
                g_ContextList->Sections = migDbSection;
                if (SetupFindFirstLine (g_OsFilesInf, sectEnum.SectName, NULL, &context)) {
                    do {
                        if (PatternScan) {
                            if (!pScanForFilePattern (&context, 1)) {
                                return FALSE;
                            }
                        } else {
                            if (!pScanForFile (&context, 1)) {
                                return FALSE;
                            }
                        }
                    }
                    while (SetupFindNextLine (&context, &context));
                }
            }
            else {
                DEBUGMSG ((DBG_ERROR, "Unable to create section for %s", SectionStr));
            }
        }
        while (pEnumNextSection (&sectEnum));
    }
    return result;
}

BOOL
pLoadTypeData (
    IN      PCTSTR TypeStr,
    IN      BOOL PatternScan
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified type data from inf file. For
  every line in type section there is a migdb context created. Also for every migdb context
  the coresponding section(s) is processed.

Arguments:

  TypeStr     - file type to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    TCHAR section [MEMDB_MAX];
    TCHAR locSection [MEMDB_MAX];
    TCHAR message [MEMDB_MAX];
    TCHAR tempField [MEMDB_MAX];
    PTSTR tempFieldPtr;
    PTSTR endOfArg  = NULL;
    DWORD fieldIndex;
    PMIGDB_CONTEXT migDbContext = NULL;
    INFCONTEXT context, context1;
    BOOL result = TRUE;
    INT actionIndex;

    MYASSERT (g_OsFilesInf != INVALID_HANDLE_VALUE);

    g_TypeGrowBuff.End = 0;

    if (SetupFindFirstLine (g_OsFilesInf, TypeStr, NULL, &context)) {
        //let's identify the action function index to update MIGDB_CONTEXT structure
        actionIndex = MigDb_GetActionIdx (TypeStr);
        if (actionIndex == -1) {
            LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_ACTION, TypeStr));
        }

        do {
            if (!SetupGetStringField (&context, 1, section, MEMDB_MAX, NULL)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_OR_MISSING_SECTION, TypeStr));
                return FALSE;
            }

            if (!SetupGetStringField (&context, 2, message, MEMDB_MAX, NULL)) {
                message [0] = 0;
            }

            migDbContext = (PMIGDB_CONTEXT) PmGetMemory (g_MigDbPool, sizeof (MIGDB_CONTEXT));
            if (migDbContext == NULL) {
                DEBUGMSG ((DBG_ERROR, "Unable to create context for %s.", TypeStr));
                return FALSE;
            }

            ZeroMemory (migDbContext, sizeof (MIGDB_CONTEXT));
            migDbContext->Next = g_ContextList;
            g_ContextList = migDbContext;

            // update ActionIndex with known value
            migDbContext->ActionIndex = actionIndex;

            // update SectName field
            migDbContext->SectName = PmDuplicateString (g_MigDbPool, section);

            // update SectLocalizedName field
            if (SetupFindFirstLine (g_OsFilesInf, S_STRINGS, section, &context1)) {
                if (SetupGetStringField (&context1, 1, locSection, MEMDB_MAX, NULL)) {
                    migDbContext->SectLocalizedName = PmDuplicateString (g_MigDbPool, locSection);
                }
            }

            // set SectNameForDisplay to localized name, or sect name if no localized name
            if (migDbContext->SectLocalizedName) {
                migDbContext->SectNameForDisplay = migDbContext->SectLocalizedName;
            } else {
                migDbContext->SectNameForDisplay = migDbContext->SectName;
            }

            // update Message field
            if (message[0] != 0) {
                migDbContext->Message  = PmDuplicateString (g_MigDbPool, message);
            }

            // OK, now let's scan all the remaining fields
            fieldIndex = 3;
            do {
                tempField [0] = 0;

                if (SetupGetStringField (&context, fieldIndex, tempField, MEMDB_MAX, NULL)) {
                    if (StringIMatchCharCount (tempField, ArgFunction, ArgFunctionLen)) {
                        //we have an additional argument for action function
                        tempFieldPtr = _tcschr (tempField, TEXT('('));
                        if (tempFieldPtr != NULL) {

                            tempFieldPtr = (PTSTR) SkipSpace (_tcsinc (tempFieldPtr));

                            if (tempFieldPtr != NULL) {

                                endOfArg = _tcschr (tempFieldPtr, TEXT(')'));

                                if (endOfArg != NULL) {
                                    *endOfArg = 0;
                                    endOfArg = (PTSTR) SkipSpaceR (tempFieldPtr, endOfArg);
                                }

                                if (endOfArg != NULL) {
                                    *_tcsinc (endOfArg) = 0;
                                    GbMultiSzAppend (&g_TypeGrowBuff, tempFieldPtr);
                                }
                                ELSE_DEBUGMSG ((
                                    DBG_WHOOPS,
                                    "Improperly formatted arg: %s in %s",
                                    tempField,
                                    TypeStr
                                    ));
                            }
                        }
                    }
                    else {
                        //we have something else, probably file name and attributes

                        if (!PatternScan) {
                            if (_tcschr (tempField, TEXT('.')) == NULL) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_DOT_SYNTAX_ERROR, TypeStr, section));
                            }
                        }

                        //therefore we initialize the section (this context will have
                        //only one section) and parse the file info
                        migDbContext->Sections = (PMIGDB_SECTION) PmGetMemory (
                                                                        g_MigDbPool,
                                                                        sizeof (MIGDB_SECTION)
                                                                        );
                        if (migDbContext->Sections != NULL) {
                            ZeroMemory (migDbContext->Sections, sizeof (MIGDB_SECTION));
                            migDbContext->Sections->Context = migDbContext;
                            migDbContext->Arguments = PmDuplicateMultiSz (g_MigDbPool, (PTSTR)g_TypeGrowBuff.Buf);
                            g_TypeGrowBuff.End = 0;
                            if (PatternScan) {
                                if (!pScanForFilePattern (&context, fieldIndex)) {
                                    return FALSE;
                                }
                            } else {
                                if (!pScanForFile (&context, fieldIndex)) {
                                    return FALSE;
                                }
                            }
                            tempField [0] = 0;
                        }
                        else {
                            DEBUGMSG ((DBG_ERROR, "Unable to create section for %s/%s", TypeStr, section));
                            return FALSE;
                        }
                    }
                }

                fieldIndex ++;
            } while (tempField [0] != 0);

            if (migDbContext->Sections == NULL) {
                //now let's add action function arguments in MIGDB_CONTEXT structure
                migDbContext->Arguments = PmDuplicateMultiSz (g_MigDbPool, (PTSTR)g_TypeGrowBuff.Buf);
                g_TypeGrowBuff.End = 0;

                //let's go to the sections and scan all files
                if (!pLoadSectionData (section, PatternScan)) {
                    return FALSE;
                }
            }

        }
        while (SetupFindNextLine (&context, &context));
    }
    return result;
}

BOOL
InitMigDb (
    IN      PCTSTR MigDbFile
    )

/*++

Routine Description:

  This routine initialize memory and data structures used by MigDb.

Arguments:

  NONE

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    INT i;
    BOOL patternFormat;
    PCTSTR typeStr;

    MYASSERT (g_OsFilesInf == INVALID_HANDLE_VALUE);

    g_OsFilesInf = InfOpenInfFile (MigDbFile);
    if (g_OsFilesInf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    g_MigDbPool = PmCreateNamedPool ("MigDb Pool");

    PmDisableTracking (g_MigDbPool);
    g_FileTable = HtAllocWithData (sizeof (FILE_LIST_STRUCT));

    if (g_FileTable == NULL) {
        DEBUGMSG ((DBG_ERROR, "Cannot initialize memory for migdb operations"));
        return FALSE;
    }

    //load known types from migdb
    i = 0;
    do {
        typeStr = MigDb_GetActionName (i);
        if (typeStr != NULL) {
            patternFormat = MigDb_IsPatternFormat (i);
            if (!pLoadTypeData (typeStr, patternFormat)) {
                GbFree (&g_AttrGrowBuff);
                GbFree (&g_TypeGrowBuff);
                return FALSE;
            }
        }
        i++;
    }
    while (typeStr != NULL);

    GbFree (&g_AttrGrowBuff);
    GbFree (&g_TypeGrowBuff);

    return TRUE;
}

BOOL
InitMigDbEx (
    IN      HINF InfHandle
    )
{
    INT i;
    BOOL patternFormat;
    PCTSTR typeStr;

    MYASSERT (g_OsFilesInf == INVALID_HANDLE_VALUE);
    MYASSERT (InfHandle != INVALID_HANDLE_VALUE);

    g_OsFilesInf = InfHandle;
    if (g_OsFilesInf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    g_MigDbPool = PmCreateNamedPool ("MigDb Pool");

    PmDisableTracking (g_MigDbPool);
    g_FileTable = HtAllocWithData (sizeof (FILE_LIST_STRUCT));
    g_TypeRule = PmGetMemory (g_MigDbPool, sizeof (MIGDB_TYPE_RULE));
    ZeroMemory (g_TypeRule, sizeof (MIGDB_TYPE_RULE));

    if (g_FileTable == NULL) {
        DEBUGMSG ((DBG_ERROR, "Cannot initialize memory for migdb operations"));
        return FALSE;
    }

    //load known types from migdb
    i = 0;
    do {
        typeStr = MigDb_GetActionName (i);
        if (typeStr != NULL) {
            patternFormat = MigDb_IsPatternFormat (i);
            if (!pLoadTypeData (typeStr, patternFormat)) {
                GbFree (&g_AttrGrowBuff);
                GbFree (&g_TypeGrowBuff);
                return FALSE;
            }
        }
        i++;
    }
    while (typeStr != NULL);

    GbFree (&g_AttrGrowBuff);
    GbFree (&g_TypeGrowBuff);

    return TRUE;
}

BOOL
DoneMigDbEx (
    VOID
    )

/*++

Routine Description:

  This routine cleans up all memory used by MigDb.

Arguments:

  NONE

Return value:

  always TRUE

--*/

{
    PMIGDB_CONTEXT migDbContext = NULL;

    // first, let's walk through any context and check if it's a required one
    migDbContext = g_ContextList;

    while (migDbContext) {
        if ((!MigDb_CallWhenTriggered (migDbContext->ActionIndex)) &&
            (migDbContext->TriggerCount == 0)
            ) {

            pCallAction (migDbContext);
        }
        migDbContext = migDbContext->Next;
    }

    if (g_FileTable != NULL) {
        HtFree (g_FileTable);
        g_FileTable = NULL;
    }

    if (g_MigDbPool != NULL) {
        PmEmptyPool (g_MigDbPool);
        PmDestroyPool (g_MigDbPool);
        g_MigDbPool = NULL;
    }

    g_ContextList = NULL;
    return TRUE;
}

BOOL
DoneMigDb (
    VOID
    )

/*++

Routine Description:

  This routine cleans up all memory used by MigDb.

Arguments:

  NONE

Return value:

  always TRUE

--*/

{
    if (!DoneMigDbEx ()) {
        return FALSE;
    }

    if (g_OsFilesInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_OsFilesInf);
        g_OsFilesInf = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    )

/*++

Routine Description:

  This routine calls a specified attribute function for a specified file.

Arguments:

  MigDbAttrib - See definition.
  AttribParams - See definition

Return value:

  TRUE  - if attribute function succeded
  FALSE - otherwise

--*/

{
    PATTRIBUTE_PROTOTYPE p;
    BOOL b;

    if (MigDbAttrib->AttribIndex == -1) {
        //invalid index for attribute function
        return FALSE;
    }

    p = MigDb_GetAttributeAddr (MigDbAttrib->AttribIndex);
    MYASSERT (p);

    if (MigDbAttrib->NotOperator) {
        b = !(p (AttribParams, MigDbAttrib->Arguments));
    } else {
        b = p (AttribParams, MigDbAttrib->Arguments);
    }

    return b;
}


BOOL
pCallAction (
    IN      PMIGDB_CONTEXT MigDbContext
    )

/*++

Routine Description:

  This routine calls an appropriate action for a specified migdb context.

Arguments:

  MigDbContext - See definition.

Return value:

  TRUE  - if action function succeded
  FALSE - otherwise

--*/

{
    PACTION_PROTOTYPE p;
    BOOL b;

    p = MigDb_GetActionAddr (MigDbContext->ActionIndex);

    MYASSERT (p);

    b = p (MigDbContext);

    return b;
}


BOOL
pCheckContext (
    IN      PMIGDB_CONTEXT MigDbContext,
    IN      BOOL Handled
    )

/*++

Routine Description:

  This routine checkes to see if a migdb context is met, that is if all sections
  have Satisfied field TRUE.

Arguments:

  MigDbContext - See definition.

Return value:

  always TRUE

--*/

{
    PMIGDB_SECTION migDbSection;
    BOOL contextSelected;
    BOOL result = FALSE;

    migDbSection = MigDbContext->Sections;
    contextSelected = TRUE;
    while (migDbSection) {
        if (!migDbSection->Satisfied) {
            contextSelected = FALSE;
            break;
        }
        migDbSection = migDbSection->Next;
    }
    if (contextSelected) {
        MigDbContext->TriggerCount ++;

        if (MigDbContext->ActionIndex == -1) {
            //
            // invalid index for action function
            //
            DEBUGMSG ((DBG_ERROR, "MigDb: Invalid action index"));
            return FALSE;
        }

        //
        // if appropriate call the action
        //
        if (MigDb_CallWhenTriggered (MigDbContext->ActionIndex)) {
            if ((!Handled) ||
                (MigDb_CallAlways (MigDbContext->ActionIndex))
                ) {
                result = pCallAction (MigDbContext);
            }
        }
        //clean up the grow buffer with file list
        GbFree (&MigDbContext->FileList);
    }
    return result;
}

BOOL
pQueryRule (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR ObjectNode
    )
{
    PTSTR objectBase = NULL;
    PMIGDB_RULE rule;
    PMIGDB_CHAR_NODE charNode;
    PCTSTR p;
    WORD w;
    BOOL result = FALSE;

    if (ObjectNode) {
        objectBase = DuplicatePathString (ObjectNode, 0);
        CharLower (objectBase);
    }

    g_TypeRuleList.End = 0;
    p = objectBase;
    if (p) {
        w = (WORD) _tcsnextc (p);
        charNode = g_TypeRule->FirstLevel;
        while (charNode && *p) {
            if (charNode->Char == w) {
                if (charNode->RuleList) {
                    rule = charNode->RuleList;
                    while (rule) {
                        if (IsmParsedPatternMatch (
                                (MIG_PARSEDPATTERN)rule->ParsedPattern,
                                MIG_FILE_TYPE,
                                ObjectName
                                )) {
                            CopyMemory (
                                GbGrow (&g_TypeRuleList, sizeof (PMIGDB_RULE)),
                                &(rule),
                                sizeof (PMIGDB_RULE)
                                );
                            result = TRUE;
                        }
                        rule = rule->NextRule;
                    }
                }
                charNode = charNode->NextLevel;
                p = _tcsinc (p);
                w = (WORD) _tcsnextc (p);
            } else {
                charNode = charNode->NextPeer;
            }
        }
    }

    if (objectBase) {
        FreePathString (objectBase);
    }

    return result;
}

BOOL
MigDbTestFile (
    IN OUT  PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  This is a callback function called for every file scanned. If the file is not handled we try
  to see if we have this file in database. If so then we check for attributes, update the migdb
  context and if necessarry call the appropriate action.

Arguments:

  Params - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    HASHITEM stringId;
    PMIGDB_RULE rule;
    PMIGDB_FILE migDbFile;
    PMIGDB_ATTRIB migDbAttrib;
    DBATTRIB_PARAMS attribParams;
    BOOL fileSelected;
    PCTSTR fileName;
    PCTSTR fileExt;
    FILE_LIST_STRUCT fileList;
    UINT index;

    // we don't check the Handled field here because the code will be carefull enough not
    // to call actions that are not gathering informations if the Handled field is not 0.

    fileName = GetFileNameFromPath (Params->NativeObjectName);
    fileExt  = GetFileExtensionFromPath (fileName);

    if (g_FileTable) {

        stringId = HtFindString (g_FileTable, fileName);

        if (stringId) {

            //The string table has extra data (a pointer to a MigDbFile node)

            HtCopyStringData (g_FileTable, stringId, &fileList);
            migDbFile = fileList.First;

            while (migDbFile) {

                //check all attributes for this file
                migDbAttrib = migDbFile->Attributes;
                fileSelected = TRUE;
                while (migDbAttrib != NULL) {
                    attribParams.FileParams = Params;
                    if (!CallAttribute (migDbAttrib, &attribParams)) {
                        fileSelected = FALSE;
                        break;
                    }
                    migDbAttrib = migDbAttrib->Next;
                }
                if (fileSelected) {
                    MYASSERT (migDbFile->Section);
                    //go to section and mark it as satisfied
                    migDbFile->Section->Satisfied = TRUE;
                    //go to context and add there the file we found in file list
                    GbMultiSzAppend (&migDbFile->Section->Context->FileList, Params->ObjectName);
                    //check if context is satisfied and if so then call the appropriate action
                    if (pCheckContext (migDbFile->Section->Context, Params->Handled)) {
                        Params->Handled = TRUE;
                    }
                }
                migDbFile = migDbFile->Next;
            }
        }
    }
    if (g_TypeRule) {
        g_TypeRuleList.End = 0;
        if (pQueryRule (Params->ObjectName, Params->ObjectNode)) {
            // let's enumerate all the matching rules to check for attributes
            index = 0;
            while (index < g_TypeRuleList.End) {
                CopyMemory (&rule, &(g_TypeRuleList.Buf[index]), sizeof (PMIGDB_RULE));

                //check all attributes for this file
                migDbAttrib = rule->Attributes;
                fileSelected = TRUE;
                while (migDbAttrib != NULL) {
                    attribParams.FileParams = Params;
                    if (!CallAttribute (migDbAttrib, &attribParams)) {
                        fileSelected = FALSE;
                        break;
                    }
                    migDbAttrib = migDbAttrib->Next;
                }
                if (fileSelected) {
                    //One last thing. See if this object is a node and the rule accepts nodes
                    if (!rule->IncludeNodes) {
                        if (IsmIsObjectHandleNodeOnly (Params->ObjectName)) {
                            fileSelected = FALSE;
                        }
                    }
                    if (fileSelected) {
                        MYASSERT (rule->Section);
                        //go to section and mark it as satisfied
                        rule->Section->Satisfied = TRUE;
                        //go to context and add there the file we found in file list
                        GbMultiSzAppend (&rule->Section->Context->FileList, Params->ObjectName);
                        //check if context is satisfied and if so then call the appropriate action
                        if (pCheckContext (rule->Section->Context, Params->Handled)) {
                            Params->Handled = TRUE;
                        }
                    }
                }
                index += sizeof (PMIGDB_RULE);
            }

        }
        g_TypeRuleList.End = 0;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\netdrives.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nettype.c

Abstract:

    <abstract>

Author:

    Jay Thaler (jthaler) 21 Apr 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <Winnetwk.h>

#define DBG_NETRESOURCES    "MappedDrives"

//
// Strings
//

#define S_MAPPEDDRIVES_POOL_NAME        "MappedDrives"
#define S_MAPPEDDRIVES_NAME             TEXT("MappedDrives")
#define S_CORPNET_NAME                  TEXT("Net Printers and Drives")

//
// Constants
//

// none

//
// Macros
//

// none

//
// Types
//

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} NETRESOURCE_ENUM, *PNETRESOURCE_ENUM;

typedef struct {
    DWORD DisplayType;
    DWORD Usage;
    CHAR Comment[MAX_PATH];
} NETDRIVE_DATAA, *PNETDRIVE_DATAA;

typedef struct {
    DWORD DisplayType;
    DWORD Usage;
    WCHAR Comment[MAX_PATH];
} NETDRIVE_DATAW, *PNETDRIVE_DATAW;

#ifdef UNICODE
#define NETDRIVE_DATA   NETDRIVE_DATAW
#define PNETDRIVE_DATA  PNETDRIVE_DATAW
#else
#define NETDRIVE_DATA   NETDRIVE_DATAA
#define PNETDRIVE_DATA  PNETDRIVE_DATAA
#endif

//
// Globals
//

PMHANDLE g_MappedDrivesPool = NULL;
HASHTABLE g_MappedDrivesTable;
HASHTABLE g_DriveCollisionTable;
MIG_OBJECTTYPEID g_MappedDriveTypeId = 0;
GROWBUFFER g_MappedDriveConversionBuff = INIT_GROWBUFFER;
BOOL g_MappedDrivesMigEnabled = FALSE;
DWORD g_AvailableDrives = 0;
MIG_OPERATIONID g_MappedDriveOp;
BOOL g_DelayNetDrivesOp = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

SGMENUMERATIONCALLBACK SgmMappedDrivesCallback;
VCMENUMERATIONCALLBACK VcmMappedDrivesCallback;

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstMappedDrive;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextMappedDrive;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumMappedDrive;
TYPE_CONVERTOBJECTTOMULTISZ ConvertMappedDriveToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToMappedDrive;
TYPE_GETNATIVEOBJECTNAME GetNativeMappedDriveName;
TYPE_ACQUIREPHYSICALOBJECT AcquireMappedDrive;
TYPE_RELEASEPHYSICALOBJECT ReleaseMappedDrive;
TYPE_DOESPHYSICALOBJECTEXIST DoesMappedDriveExist;
TYPE_REMOVEPHYSICALOBJECT RemoveMappedDrive;
TYPE_CREATEPHYSICALOBJECT CreateMappedDrive;
TYPE_REPLACEPHYSICALOBJECT ReplaceMappedDrive;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertMappedDriveContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertMappedDriveContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedMappedDriveContent;

OPMFILTERCALLBACK FilterMappedDrive;

//
// Code
//

BOOL
NetDrivesInitialize (
    VOID
    )
{
    g_MappedDrivesTable = HtAllocWithData (sizeof (PNETDRIVE_DATA));
    g_MappedDrivesPool = PmCreateNamedPool (S_MAPPEDDRIVES_POOL_NAME);

    return (g_MappedDrivesPool != NULL);
}

VOID
NetDrivesTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PNETDRIVE_DATA netdriveData;

    GbFree (&g_MappedDriveConversionBuff);

    if (g_MappedDrivesTable) {
        if (EnumFirstHashTableString (&e, g_MappedDrivesTable)) {
            do {
                netdriveData = *((PNETDRIVE_DATA *) e.ExtraData);
                if (netdriveData) {
                    PmReleaseMemory (g_MappedDrivesPool, netdriveData);
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_MappedDrivesTable);
        g_MappedDrivesTable = NULL;
    }
    if (g_MappedDrivesPool) {
        PmDestroyPool (g_MappedDrivesPool);
        g_MappedDrivesPool = NULL;
    }
}

BOOL
pLoadMappedDrivesData (
    VOID
    )
{
    DWORD error;
    LPNETRESOURCE netBuffer = NULL;
    HANDLE netHandle;
    DWORD netBufferSize = 16384;   // 16K is a good size
    DWORD netNumEntries = -1;      // enumerate all possible entries
    DWORD i;
    PNETDRIVE_DATA netDriveData;
    MIG_OBJECTSTRINGHANDLE netObject = NULL;

    error = WNetOpenEnum (RESOURCE_REMEMBERED, RESOURCETYPE_DISK, 0, netBuffer, &netHandle);
    if (error != NO_ERROR) {
        return FALSE;
    }

    netBuffer = PmGetMemory (g_MappedDrivesPool, netBufferSize);

    do {
        ZeroMemory(netBuffer, netBufferSize);

        error = WNetEnumResource (netHandle, &netNumEntries, netBuffer, &netBufferSize);

        if (error == ERROR_NO_MORE_ITEMS) {
            break;
        }

        if (error != NO_ERROR) {
            PmReleaseMemory (g_MappedDrivesPool, netBuffer);
            return FALSE;
        }

        for (i=0; i<netNumEntries; i++) {
            if (netBuffer[i].lpLocalName != NULL) {
                netObject = IsmCreateObjectHandle (netBuffer[i].lpLocalName, netBuffer[i].lpRemoteName);
                if (netObject) {
                    netDriveData = (PNETDRIVE_DATA) PmGetMemory (g_MappedDrivesPool, sizeof (NETDRIVE_DATA));
                    ZeroMemory (netDriveData, sizeof (NETDRIVE_DATA));
                    netDriveData->DisplayType = netBuffer[i].dwDisplayType;
                    netDriveData->Usage = netBuffer[i].dwUsage;
                    if (netBuffer[i].lpComment) {
                        StringCopyTcharCount (netDriveData->Comment, netBuffer[i].lpComment, MAX_PATH);
                    }
                    HtAddStringEx (g_MappedDrivesTable, netObject, &netDriveData, FALSE);
                    IsmDestroyObjectHandle (netObject);
                }
            }
        }
    } while (error != ERROR_NO_MORE_ITEMS);

    PmReleaseMemory (g_MappedDrivesPool, netBuffer);
    return TRUE;
}

BOOL
WINAPI
NetDrivesEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TYPE_REGISTER mappedDrivesTypeData;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    pLoadMappedDrivesData ();

    ZeroMemory (&mappedDrivesTypeData, sizeof (TYPE_REGISTER));
    mappedDrivesTypeData.Priority = PRIORITY_MAPPEDDRIVE;

    if (Platform == PLATFORM_SOURCE) {

        mappedDrivesTypeData.EnumFirstPhysicalObject = EnumFirstMappedDrive;
        mappedDrivesTypeData.EnumNextPhysicalObject = EnumNextMappedDrive;
        mappedDrivesTypeData.AbortEnumPhysicalObject = AbortEnumMappedDrive;
        mappedDrivesTypeData.ConvertObjectToMultiSz = ConvertMappedDriveToMultiSz;
        mappedDrivesTypeData.ConvertMultiSzToObject = ConvertMultiSzToMappedDrive;
        mappedDrivesTypeData.GetNativeObjectName = GetNativeMappedDriveName;
        mappedDrivesTypeData.AcquirePhysicalObject = AcquireMappedDrive;
        mappedDrivesTypeData.ReleasePhysicalObject = ReleaseMappedDrive;
        mappedDrivesTypeData.ConvertObjectContentToUnicode = ConvertMappedDriveContentToUnicode;
        mappedDrivesTypeData.ConvertObjectContentToAnsi = ConvertMappedDriveContentToAnsi;
        mappedDrivesTypeData.FreeConvertedObjectContent = FreeConvertedMappedDriveContent;

        g_MappedDriveTypeId = IsmRegisterObjectType (
                                    S_MAPPEDDRIVES_NAME,
                                    TRUE,
                                    FALSE,
                                    &mappedDrivesTypeData
                                    );
    } else {

        mappedDrivesTypeData.EnumFirstPhysicalObject = EnumFirstMappedDrive;
        mappedDrivesTypeData.EnumNextPhysicalObject = EnumNextMappedDrive;
        mappedDrivesTypeData.AbortEnumPhysicalObject = AbortEnumMappedDrive;
        mappedDrivesTypeData.ConvertObjectToMultiSz = ConvertMappedDriveToMultiSz;
        mappedDrivesTypeData.ConvertMultiSzToObject = ConvertMultiSzToMappedDrive;
        mappedDrivesTypeData.GetNativeObjectName = GetNativeMappedDriveName;
        mappedDrivesTypeData.AcquirePhysicalObject = AcquireMappedDrive;
        mappedDrivesTypeData.ReleasePhysicalObject = ReleaseMappedDrive;
        mappedDrivesTypeData.DoesPhysicalObjectExist = DoesMappedDriveExist;
        mappedDrivesTypeData.RemovePhysicalObject = RemoveMappedDrive;
        mappedDrivesTypeData.CreatePhysicalObject = CreateMappedDrive;
        mappedDrivesTypeData.ReplacePhysicalObject = ReplaceMappedDrive;
        mappedDrivesTypeData.ConvertObjectContentToUnicode = ConvertMappedDriveContentToUnicode;
        mappedDrivesTypeData.ConvertObjectContentToAnsi = ConvertMappedDriveContentToAnsi;
        mappedDrivesTypeData.FreeConvertedObjectContent = FreeConvertedMappedDriveContent;

        g_MappedDriveTypeId = IsmRegisterObjectType (
                                    S_MAPPEDDRIVES_NAME,
                                    TRUE,
                                    FALSE,
                                    &mappedDrivesTypeData
                                    );
    }

    MYASSERT (g_MappedDriveTypeId);
    return TRUE;
}

VOID
WINAPI
NetDrivesEtmNewUserCreated (
    IN      PCTSTR UserName,
    IN      PCTSTR DomainName,
    IN      PCTSTR UserProfileRoot,
    IN      PSID UserSid
    )
{
    // a new user was created, the network drives operations need to be delayed
    NetDrivesTerminate ();
    g_DelayNetDrivesOp = TRUE;
}

BOOL
WINAPI
NetDrivesSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    return TRUE;
}

BOOL
WINAPI
NetDrivesSgmParse (
    IN      PVOID Reserved
    )
{
    PCTSTR friendlyName;

    friendlyName = GetStringResource (MSG_NET_DRIVES_NAME);

    //IsmAddComponentAlias (
    //    S_MAPPEDDRIVES_NAME,
    //    MASTERGROUP_SYSTEM,
    //    friendlyName,
    //    COMPONENT_NAME,
    //    FALSE
    //    );

    IsmAddComponentAlias (
        S_CORPNET_NAME,
        MASTERGROUP_SYSTEM,
        friendlyName,
        COMPONENT_NAME,
        FALSE
        );

    FreeStringResource (friendlyName);
    return TRUE;
}

UINT
SgmMappedDrivesCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);
    IsmSetOperationOnObject (Data->ObjectTypeId, Data->ObjectName, g_MappedDriveOp, NULL, NULL);
    IsmMakeNonCriticalObject (Data->ObjectTypeId, Data->ObjectName);
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
pEnumMappedDriveWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PNETRESOURCE_ENUM MappedDriveEnum
    )
{
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        PmReleaseMemory (g_MappedDrivesPool, EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    do {
        EnumPtr->ObjectName = MappedDriveEnum->HashData.String;
        if (!ObsPatternMatch (MappedDriveEnum->Pattern, EnumPtr->ObjectName)) {
            if (!EnumNextHashTableString (&MappedDriveEnum->HashData)) {
                AbortEnumMappedDrive (EnumPtr);
                return FALSE;
            }
            continue;
        }
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        EnumPtr->NativeObjectName = JoinPathsInPoolEx ((
                                        g_MappedDrivesPool,
                                        EnumPtr->ObjectNode,
                                        TEXT("<=>"),
                                        EnumPtr->ObjectLeaf,
                                        NULL
                                        ));
        EnumPtr->Level = 1;
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = FALSE;
        EnumPtr->IsNode = TRUE;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;
        return TRUE;
    } while (TRUE);
}

BOOL
EnumFirstMappedDrive (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PNETRESOURCE_ENUM netResourceEnum = NULL;

    if (!g_MappedDrivesTable) {
        AbortEnumMappedDrive (EnumPtr);
        return FALSE;
    }
    netResourceEnum = (PNETRESOURCE_ENUM) PmGetMemory (g_MappedDrivesPool, sizeof (NETRESOURCE_ENUM));
    netResourceEnum->Pattern = PmDuplicateString (g_MappedDrivesPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) netResourceEnum;

    if (EnumFirstHashTableString (&netResourceEnum->HashData, g_MappedDrivesTable)) {
        return pEnumMappedDriveWorker (EnumPtr, netResourceEnum);
    } else {
        AbortEnumMappedDrive (EnumPtr);
        return FALSE;
    }
}

BOOL
EnumNextMappedDrive (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PNETRESOURCE_ENUM netResourceEnum = NULL;

    netResourceEnum = (PNETRESOURCE_ENUM)(EnumPtr->EtmHandle);
    if (!netResourceEnum) {
        AbortEnumMappedDrive (EnumPtr);
        return FALSE;
    }
    if (EnumNextHashTableString (&netResourceEnum->HashData)) {
        return pEnumMappedDriveWorker (EnumPtr, netResourceEnum);
    } else {
        AbortEnumMappedDrive (EnumPtr);
        return FALSE;
    }
}

VOID
AbortEnumMappedDrive (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PNETRESOURCE_ENUM netResourceEnum = NULL;

    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        PmReleaseMemory (g_MappedDrivesPool, EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    netResourceEnum = (PNETRESOURCE_ENUM)(EnumPtr->EtmHandle);
    if (!netResourceEnum) {
        ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
        return;
    }
    PmReleaseMemory (g_MappedDrivesPool, netResourceEnum->Pattern);
    PmReleaseMemory (g_MappedDrivesPool, netResourceEnum);
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

BOOL
AcquireMappedDrive (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    BOOL result = FALSE;
    PNETDRIVE_DATA netdriveData;

    if (!ObjectContent) {
        return FALSE;
    }

    // NOTE: Do not zero ObjectContent; some of its members were already set

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        DEBUGMSG ((
            DBG_WHOOPS,
            "Unexpected acquire request for %s: Can't acquire mapped drives as files",
            ObjectName
            ));
        return FALSE;
    }

    if (HtFindStringEx (g_MappedDrivesTable, ObjectName, (PVOID) &netdriveData, FALSE)) {
        //
        // Fill in all the content members.  We already zeroed the struct,
        // so most of the members are taken care of because they are zero.
        //
        ObjectContent->MemoryContent.ContentBytes = (PBYTE)netdriveData;
        ObjectContent->MemoryContent.ContentSize = sizeof(NETDRIVE_DATA);

        result = TRUE;
    }
    return result;
}

BOOL
ReleaseMappedDrive (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return TRUE;
}

BOOL
DoesMappedDriveExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    if (!g_MappedDrivesTable) {
        return FALSE;
    }
    return (HtFindStringEx (g_MappedDrivesTable, ObjectName, NULL, FALSE) != NULL);
}

BOOL
RemoveMappedDrive (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    DWORD result = ERROR_NOT_FOUND;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node && (leaf)) {
            IsmRecordOperation (JRNOP_DELETE,
                                g_MappedDriveTypeId,
                                ObjectName);

            // Only set CONNECT_UPDATE_PROFILE when deleting a connection that persists
            result = WNetCancelConnection2 ((LPCTSTR)node, CONNECT_UPDATE_PROFILE, TRUE);
            if (result != ERROR_SUCCESS) {
                DEBUGMSG ((DBG_NETRESOURCES, "Failed to delete existent net resource %s", node));
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return (result == ERROR_SUCCESS);
}

BOOL
CreateMappedDrive (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node;
    PCTSTR leaf;
    NETRESOURCE netResource;
    BOOL result = ERROR_NOT_FOUND;
    PNETDRIVE_DATA netDriveData = NULL;


    if (!ObjectContent->ContentInFile) {
        if (ObjectContent->MemoryContent.ContentBytes && ObjectContent->MemoryContent.ContentSize) {
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
                if (node && (leaf)) {

                    if (g_DelayNetDrivesOp) {

                        // we need to delay this operation
                        // record delayed printer create operation
                        IsmRecordDelayedOperation (
                            JRNOP_CREATE,
                            g_MappedDriveTypeId,
                            ObjectName,
                            ObjectContent
                            );
                        result = TRUE;

                    } else {

                        netDriveData = (PNETDRIVE_DATA) PmGetMemory (g_MappedDrivesPool, sizeof (NETDRIVE_DATA));
                        CopyMemory (netDriveData, ObjectContent->MemoryContent.ContentBytes, sizeof (NETDRIVE_DATA));

                        ZeroMemory (&netResource, sizeof (NETRESOURCE));
                        netResource.dwScope = RESOURCE_REMEMBERED;
                        netResource.dwType = RESOURCETYPE_DISK;
                        netResource.dwDisplayType = netDriveData->DisplayType;
                        netResource.dwUsage = netDriveData->Usage;
                        netResource.lpLocalName = (LPTSTR)node;
                        netResource.lpRemoteName = (LPTSTR)leaf;
                        netResource.lpComment = netDriveData->Comment;
                        netResource.lpProvider = NULL;  // Let the API determine the provider

                        IsmRecordOperation (JRNOP_CREATE,
                                            g_MappedDriveTypeId,
                                            ObjectName);

                        result = WNetAddConnection2 (&netResource, NULL, NULL, CONNECT_UPDATE_PROFILE);
                        if (result != ERROR_SUCCESS) {
                            DEBUGMSG ((DBG_NETRESOURCES, "Failed to add net resource for %s", node));
                        }

                        PmReleaseMemory (g_MappedDrivesPool, netDriveData);
                    }
                }
            }
        }
    }
    SetLastError (result);
    return (result == ERROR_SUCCESS);
}


BOOL
ReplaceMappedDrive (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    BOOL result = TRUE;

    if (g_DelayNetDrivesOp) {

        // we need to delay this operation
        // record delayed printer replace operation
        IsmRecordDelayedOperation (
            JRNOP_REPLACE,
            g_MappedDriveTypeId,
            ObjectName,
            ObjectContent
            );
        result = TRUE;

    } else {

        // we are going to delete any existing net share with this name,
        // and create a new one
        if (DoesMappedDriveExist (ObjectName)) {
            result = RemoveMappedDrive (ObjectName);
        }
        if (result) {
            result = CreateMappedDrive (ObjectName, ObjectContent);
        }
    }
    return result;
}


PCTSTR
ConvertMappedDriveToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    PNETDRIVE_DATA netDriveData;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        MYASSERT (leaf);

        g_MappedDriveConversionBuff.End = 0;

        GbCopyQuotedString (&g_MappedDriveConversionBuff, node);

        GbCopyQuotedString (&g_MappedDriveConversionBuff, leaf);

        MYASSERT (ObjectContent->Details.DetailsSize == 0);
        MYASSERT (!ObjectContent->ContentInFile);
        MYASSERT (ObjectContent->MemoryContent.ContentSize = sizeof (NETDRIVE_DATA));

        if (ObjectContent->MemoryContent.ContentBytes) {
            netDriveData = (PNETDRIVE_DATA)ObjectContent->MemoryContent.ContentBytes;
            wsprintf (
                (PTSTR) GbGrow (&g_MappedDriveConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                netDriveData->DisplayType
                );
            wsprintf (
                (PTSTR) GbGrow (&g_MappedDriveConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                netDriveData->Usage
                );

            GbCopyQuotedString (&g_MappedDriveConversionBuff, netDriveData->Comment);
        } else {
            bresult = FALSE;
        }

        if (bresult) {
            GbCopyString (&g_MappedDriveConversionBuff, TEXT(""));
            result = IsmGetMemory (g_MappedDriveConversionBuff.End);
            CopyMemory (result, g_MappedDriveConversionBuff.Buf, g_MappedDriveConversionBuff.End);
        }

        g_MappedDriveConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);
        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToMappedDrive (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          CALLER_INITIALIZED OPTIONAL
    )
{
    MULTISZ_ENUM multiSzEnum;
    PCTSTR localName = NULL;
    PCTSTR remoteName = NULL;
    NETDRIVE_DATA netDriveData;
    DWORD dummy;
    UINT index;

    g_MappedDriveConversionBuff.End = 0;

    //
    // Parse the multi-sz into the net drive content and details.
    // The user may have edited the text (and potentially introduced
    // errors).
    //

    ZeroMemory (&netDriveData, sizeof (NETDRIVE_DATA));

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == 0) {
                localName = multiSzEnum.CurrentString;
            }
            if (index == 1) {
                remoteName = multiSzEnum.CurrentString;
            }
            if (index == 2) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                netDriveData.DisplayType = dummy;
            }
            if (index == 3) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                netDriveData.Usage = dummy;
            }
            if (index == 4) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                    StringCopyTcharCount (netDriveData.Comment, multiSzEnum.CurrentString, MAX_PATH);
                }
            }
            index++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!localName || !remoteName) {
        //
        // Bogus data, fail
        //
        return FALSE;
    }

    //
    // Fill in all the members of the content structure.
    //

    if (ObjectContent) {
        ObjectContent->ContentInFile = FALSE;
        ObjectContent->MemoryContent.ContentSize = sizeof (NETDRIVE_DATA);
        ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
        CopyMemory (
            (PBYTE)ObjectContent->MemoryContent.ContentBytes,
            &netDriveData,
            ObjectContent->MemoryContent.ContentSize
            );

        ObjectContent->Details.DetailsSize = 0;
        ObjectContent->Details.DetailsData = NULL;
    }
    *ObjectName = IsmCreateObjectHandle (localName, remoteName);

    return TRUE;
}

PCTSTR
GetNativeMappedDriveName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR leafPtr = NULL, leafBegin = NULL, nodePtr = NULL;
    UINT strSize = 0;
    PCTSTR nameMsg;
    PCTSTR argArray[3];
    PCTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (leaf) {
            leafPtr = _tcsrchr (leaf, TEXT('\\'));
            if (leafPtr) {
                *leafPtr = 0;
                leafPtr ++;
            }
            leafBegin = (PTSTR)leaf;
            while (*leafBegin == TEXT('\\')) {
                leafBegin ++;
            }
        }
        if (node) {
            nodePtr = _tcsrchr (node, TEXT('\\'));
            if (nodePtr) {
                *nodePtr = 0;
            }
        }
        if (leafPtr) {
            if (node) {
                argArray[0] = (PCTSTR) leafPtr;
                argArray[1] = (PCTSTR) leafBegin;
                argArray[2] = (PCTSTR) node;
                nameMsg = ParseMessageID (MSG_MAPPEDDRIVENAME_1, argArray);
                if (nameMsg) {
                    result = IsmDuplicateString (nameMsg);
                    FreeStringResource (nameMsg);
                }
            } else {
                argArray[0] = (PCTSTR) leafPtr;
                argArray[1] = (PCTSTR) leafBegin;
                nameMsg = ParseMessageID (MSG_MAPPEDDRIVENAME_2, argArray);
                if (nameMsg) {
                    result = IsmDuplicateString (nameMsg);
                    FreeStringResource (nameMsg);
                }
            }
        } else {
            if (leafBegin) {
                if (node) {
                    argArray[0] = (PCTSTR) leafBegin;
                    argArray[1] = (PCTSTR) node;
                    nameMsg = ParseMessageID (MSG_MAPPEDDRIVENAME_3, argArray);
                    if (nameMsg) {
                        result = IsmDuplicateString (nameMsg);
                        FreeStringResource (nameMsg);
                    }
                } else {
                    argArray[0] = (PCTSTR) leafBegin;
                    nameMsg = ParseMessageID (MSG_MAPPEDDRIVENAME_4, argArray);
                    if (nameMsg) {
                        result = IsmDuplicateString (nameMsg);
                        FreeStringResource (nameMsg);
                    }
                }
            } else {
                if (node) {
                    argArray[0] = (PCTSTR) node;
                    nameMsg = ParseMessageID (MSG_MAPPEDDRIVENAME_5, argArray);
                    if (nameMsg) {
                        result = IsmDuplicateString (nameMsg);
                        FreeStringResource (nameMsg);
                    }
                }
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

PMIG_CONTENT
ConvertMappedDriveContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Mapped Drive content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETDRIVE_DATAW));
            if (result->MemoryContent.ContentBytes) {
                ((PNETDRIVE_DATAW)result->MemoryContent.ContentBytes)->DisplayType =
                ((PNETDRIVE_DATAA)ObjectContent->MemoryContent.ContentBytes)->DisplayType;
                ((PNETDRIVE_DATAW)result->MemoryContent.ContentBytes)->Usage =
                ((PNETDRIVE_DATAA)ObjectContent->MemoryContent.ContentBytes)->Usage;
                DirectDbcsToUnicodeN (
                    ((PNETDRIVE_DATAW)result->MemoryContent.ContentBytes)->Comment,
                    ((PNETDRIVE_DATAA)ObjectContent->MemoryContent.ContentBytes)->Comment,
                    MAX_PATH
                    );
                result->MemoryContent.ContentSize = sizeof (NETDRIVE_DATAW);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertMappedDriveContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Mapped Drive content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETDRIVE_DATAA));
            if (result->MemoryContent.ContentBytes) {
                ((PNETDRIVE_DATAA)result->MemoryContent.ContentBytes)->DisplayType =
                ((PNETDRIVE_DATAW)ObjectContent->MemoryContent.ContentBytes)->DisplayType;
                ((PNETDRIVE_DATAA)result->MemoryContent.ContentBytes)->Usage =
                ((PNETDRIVE_DATAW)ObjectContent->MemoryContent.ContentBytes)->Usage;
                DirectUnicodeToDbcsN (
                    ((PNETDRIVE_DATAA)result->MemoryContent.ContentBytes)->Comment,
                    ((PNETDRIVE_DATAW)ObjectContent->MemoryContent.ContentBytes)->Comment,
                    MAX_PATH
                    );
                result->MemoryContent.ContentSize = sizeof (NETDRIVE_DATAA);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedMappedDriveContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}

BOOL
WINAPI
NetDrivesVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
NetDrivesVcmParse (
    IN      PVOID Reserved
    )
{
    return NetDrivesSgmParse (Reserved);
}

UINT
VcmMappedDrivesCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
pCommonNetDrivesQueueEnumeration (
    IN      BOOL VcmMode
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_MAPPEDDRIVES_NAME, 0) &&
        !IsmIsComponentSelected (S_CORPNET_NAME, 0)
        ) {
        g_MappedDrivesMigEnabled = FALSE;
        return TRUE;
    }
    g_MappedDrivesMigEnabled = TRUE;

    g_MappedDriveOp = IsmRegisterOperation (S_OPERATION_DRIVEMAP_FIXCONTENT, TRUE);

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmQueueEnumeration (
        g_MappedDriveTypeId,
        pattern,
        VcmMode ? VcmMappedDrivesCallback : SgmMappedDrivesCallback,
        (ULONG_PTR) 0,
        S_MAPPEDDRIVES_NAME
        );

    IsmDestroyObjectHandle (pattern);

    return TRUE;
}


BOOL
WINAPI
NetDrivesSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    return pCommonNetDrivesQueueEnumeration (FALSE);
}


BOOL
WINAPI
NetDrivesVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    return pCommonNetDrivesQueueEnumeration (TRUE);
}


BOOL
WINAPI
NetDrivesCsmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    g_AvailableDrives = GetLogicalDrives ();
    g_DriveCollisionTable = HtAllocWithData (sizeof (TCHAR));
    return TRUE;
}

DWORD
pConvertDriveToBit (
    PCTSTR driveString
    )
{
    DWORD bit = 0;
    TCHAR driveLetter;

    if (driveString && *driveString) {
        driveLetter = (TCHAR)_totlower (*driveString);
        if (driveLetter >= TEXT('a') && driveLetter <= TEXT('z')) {
            bit = 0x1 << (driveLetter - TEXT('a'));
        }
    }
    return bit;
}

BOOL
pReserveAvailableDrive (
    TCHAR *driveLetter
    )
{
    DWORD bit;
    BOOL success = FALSE;

    // Start at bit 2 so we only map to C: or higher
    for (bit = 2; bit < 26; bit++) {
        if (!(g_AvailableDrives & (1 << bit))) {
            success = TRUE;
            g_AvailableDrives |= (1 << bit);
            *driveLetter = (TCHAR)(TEXT('a') + bit);
            break;
        }
    }

    return success;
}

BOOL
WINAPI
NetDrivesCsmExecute (
    VOID
    )
{
    GROWBUFFER collisions = INIT_GROWBUFFER;
    DWORD driveBit;
    TCHAR existingPath[MAX_PATH + 1];
    MULTISZ_ENUM e;
    TCHAR freeDrive;
    DWORD bufferSize;
    MIG_OBJECTSTRINGHANDLE pattern;
    MIG_OBJECT_ENUM objectEnum;
    PCTSTR node;
    PCTSTR leaf;
    DWORD result;

    // First, enumerate all the mapped drives and look for collisions
    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);  // *,*
    if (IsmEnumFirstSourceObject (&objectEnum, g_MappedDriveTypeId, pattern)) {
        do {
            IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
            // Leaf is the remote name.

            driveBit = pConvertDriveToBit (node);

            if (g_AvailableDrives & driveBit) {
                // Something is already there.  Is it the same thing?
                ZeroMemory (existingPath, MAX_PATH + 1);
                bufferSize = MAX_PATH + 1;
                result = WNetGetConnection (node, existingPath, &bufferSize);
                if (result != NO_ERROR) {
                    // this might be a fixed drive
                    GbMultiSzAppend (&collisions, node);
                } else {
                    if (!StringIMatch (existingPath, leaf)) {
                        // Whoops, we have a collision.  Save it for later
                        GbMultiSzAppend (&collisions, node);
                    }
                }
            } else {
                // It's free, so let's reserve it.
                g_AvailableDrives |= driveBit;
            }
            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        } while (IsmEnumNextObject (&objectEnum));
    }

    IsmDestroyObjectHandle (pattern);
    INVALID_POINTER (pattern);

    // Enumerate collided mappings and find new destinations
    if (EnumFirstMultiSz (&e, (PCTSTR) collisions.Buf)) {
        do {
            if (pReserveAvailableDrive (&freeDrive)) {
                HtAddStringEx (g_DriveCollisionTable, e.CurrentString, &freeDrive, FALSE);
            }
        } while (EnumNextMultiSz (&e));
    }

    GbFree (&collisions);

    return TRUE;
}

BOOL
WINAPI
NetDrivesOpmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Get attribute and operation types
    //
    g_MappedDriveOp = IsmRegisterOperation (S_OPERATION_DRIVEMAP_FIXCONTENT, TRUE);

    //
    // Register operation callbacks
    //
    IsmRegisterOperationFilterCallback (g_MappedDriveOp, FilterMappedDrive, TRUE, TRUE, FALSE);

    return TRUE;
}

BOOL
WINAPI
FilterMappedDrive (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR node = NULL;
    PCTSTR leaf = NULL;
    MIG_OBJECTSTRINGHANDLE destHandle;
    TCHAR driveLetter;

    try {
        if ((InputData->CurrentObject.ObjectTypeId & (~PLATFORM_MASK)) != g_MappedDriveTypeId) {
            DEBUGMSG ((DBG_ERROR, "Unexpected object type in FilterMappedDrive"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                InputData->OriginalObject.ObjectName,
                &node,
                &leaf
                )) {
            __leave;
        }
        MYASSERT (node);
        MYASSERT (leaf);
        if (node) {
            if (HtFindStringEx (g_DriveCollisionTable, node, &driveLetter, FALSE)) {
                node[0] = driveLetter;
            }

            destHandle = IsmCreateObjectHandle (node, leaf);
            if (destHandle) {
                OutputData->NewObject.ObjectName = destHandle;
            }
        }
    }
    __finally {
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\osfiles.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    osfiles.h

Abstract:

    Header file for implementing migdb functionality

Author:

    Calin Negreanu (calinn) 07-Ian-1998

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    ENCODEDSTRHANDLE  ObjectName;
    PCTSTR            NativeObjectName;
    PCTSTR            ObjectNode;
    PCTSTR            ObjectLeaf;
    BOOL              IsNode;
    BOOL              IsLeaf;
    DWORD             Handled;
    WIN32_FIND_DATA * FindData;
} FILE_HELPER_PARAMS, * PFILE_HELPER_PARAMS;

typedef struct _MIGDB_ATTRIB {
    INT     AttribIndex;
    UINT    ArgCount;
    PCTSTR  Arguments;
    BOOL    NotOperator;
    struct _MIGDB_ATTRIB *Next;
} MIGDB_ATTRIB, *PMIGDB_ATTRIB;

typedef struct _MIGDB_CONTEXT;

typedef struct _MIGDB_SECTION {
    BOOL    Satisfied;
    struct _MIGDB_CONTEXT *Context;
    struct _MIGDB_SECTION *Next;
} MIGDB_SECTION, *PMIGDB_SECTION;

typedef struct _MIGDB_CONTEXT {
    INT     ActionIndex;
    UINT    TriggerCount;
    PCTSTR  SectName;
    PCTSTR  SectLocalizedName;
    PCTSTR  SectNameForDisplay;     // SectLocalizedName, or SectName if not localized
    PCTSTR  Message;
    PCTSTR  Arguments;
    GROWBUFFER FileList;
    PMIGDB_SECTION Sections;
    struct _MIGDB_CONTEXT *Next;
} MIGDB_CONTEXT, *PMIGDB_CONTEXT;

typedef struct _MIGDB_FILE {
    PMIGDB_SECTION Section;
    PMIGDB_ATTRIB  Attributes;
    struct _MIGDB_FILE *Next;
} MIGDB_FILE, *PMIGDB_FILE;

typedef struct {
    PMIGDB_FILE First;
    PMIGDB_FILE Last;
} FILE_LIST_STRUCT, *PFILE_LIST_STRUCT;

typedef struct {
    PFILE_HELPER_PARAMS FileParams;
} DBATTRIB_PARAMS, *PDBATTRIB_PARAMS;

typedef struct _TAG_MIGDB_RULE {
    PCTSTR NodeBase;
    MIG_OBJECTSTRINGHANDLE ObjectPattern;
    POBSPARSEDPATTERN ParsedPattern;
    PMIGDB_SECTION Section;
    PMIGDB_ATTRIB  Attributes;
    INT IncludeNodes;
    struct _TAG_MIGDB_RULE *NextRule;
} MIGDB_RULE, *PMIGDB_RULE;

typedef struct _TAG_CHAR_NODE {
    PMIGDB_RULE RuleList;
    WORD Char;
    WORD Flags;
    struct _TAG_CHAR_NODE *NextLevel;
    struct _TAG_CHAR_NODE *NextPeer;
} MIGDB_CHAR_NODE, *PMIGDB_CHAR_NODE;

typedef struct {
    PMIGDB_RULE RuleList;
    PMIGDB_CHAR_NODE FirstLevel;
} MIGDB_TYPE_RULE, *PMIGDB_TYPE_RULE;

//
// Declare the attribute functions prototype
//
typedef BOOL (ATTRIBUTE_PROTOTYPE) (PDBATTRIB_PARAMS AttribParams, PCTSTR Args);
typedef ATTRIBUTE_PROTOTYPE * PATTRIBUTE_PROTOTYPE;

//
// Declare the action functions prototype
//
typedef BOOL (ACTION_PROTOTYPE) (PMIGDB_CONTEXT Context);
typedef ACTION_PROTOTYPE * PACTION_PROTOTYPE;

//
// Declare MigDb hook function prototype
//
typedef BOOL (MIGDB_HOOK_PROTOTYPE) (PCTSTR FileName, PMIGDB_CONTEXT Context, PMIGDB_SECTION Section, PMIGDB_FILE File, PMIGDB_ATTRIB Attrib);
typedef MIGDB_HOOK_PROTOTYPE * PMIGDB_HOOK_PROTOTYPE;

//
// Globals
//

extern HINF g_OsFilesInf;
extern MIG_ATTRIBUTEID g_OsFileAttribute;

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Public function declarations
//

PATTRIBUTE_PROTOTYPE
MigDb_GetAttributeAddr (
    IN      INT AttributeIdx
    );

INT
MigDb_GetAttributeIdx (
    IN      PCTSTR AttributeStr
    );

UINT
MigDb_GetReqArgCount (
    IN      INT AttributeIndex
    );

PCTSTR
MigDb_GetAttributeName (
    IN      INT AttributeIdx
    );

PACTION_PROTOTYPE
MigDb_GetActionAddr (
    IN      INT ActionIdx
    );

INT
MigDb_GetActionIdx (
    IN      PCTSTR ActionStr
    );

PCTSTR
MigDb_GetActionName (
    IN      INT ActionIdx
    );

BOOL
MigDb_IsPatternFormat (
    IN      INT ActionIdx
    );

BOOL
MigDb_CallWhenTriggered (
    IN      INT ActionIdx
    );

BOOL
MigDb_CallAlways (
    IN      INT ActionIdx
    );

PMIGDB_HOOK_PROTOTYPE
SetMigDbHook (
    PMIGDB_HOOK_PROTOTYPE HookFunction
    );

BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    );

ULONGLONG
GetBinFileVer (
    IN      PCTSTR FileName
    );

ULONGLONG
GetBinProductVer (
    IN      PCTSTR FileName
    );

DWORD
GetFileDateHi (
    IN      PCTSTR FileName
    );

DWORD
GetFileDateLo (
    IN      PCTSTR FileName
    );

DWORD
GetFileVerOs (
    IN      PCTSTR FileName
    );

DWORD
GetFileVerType (
    IN      PCTSTR FileName
    );

BOOL
InitMigDb (
    IN      PCTSTR MigDbFile
    );

BOOL
InitMigDbEx (
    IN      HINF InfHandle
    );

BOOL
DoneMigDbEx (
    VOID
    );

BOOL
DoneMigDb (
    VOID
    );

BOOL
MigDbTestFile (
    IN      PFILE_HELPER_PARAMS Params
    );

BOOL
IsKnownMigDbFile (
    IN      PCTSTR FileName
    );

BOOL
AddFileToMigDbLinkage (
    IN      PCTSTR FileName,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex            OPTIONAL
    );

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\netshares.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    netshares.c

Abstract:

    <abstract>

Author:

    Jay Thaler (jthaler) 21 Apr 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <Winnetwk.h>
#include <Lm.h>
#include <Lmshare.h>

#define DBG_NETSHARES    "NetShares"

//
// Strings
//

#define S_NETSHARES_NAME          TEXT("NetShares")

//
// Constants
//

/* These flags are relevant for share-level security on VSERVER
 * When operating with user-level security, use SHI50F_FULL - the actual
 * access rights are determined by the NetAccess APIs.
 */
#define SHI50F_RDONLY       0x0001
#define SHI50F_FULL         0x0002
#define SHI50F_ACCESSMASK   (SHI50F_RDONLY|SHI50F_FULL)

/* The share is restored on system startup */
#define SHI50F_PERSIST      0x0100
/* The share is not normally visible  */
#define SHI50F_SYSTEM       0x0200
//
// Win9x migration net share flag, used to distinguish user-level security and
// password-level security.  When it is specified, user-level
// security is enabled, and NetShares\<share>\ACL\<list> exists.
//
#define SHI50F_ACLS         0x1000

//
// Flags that help determine when custom access is enabled
//

#define READ_ACCESS_FLAGS   0x0081
#define READ_ACCESS_MASK    0x7fff
#define FULL_ACCESS_FLAGS   0x00b7
#define FULL_ACCESS_MASK    0x7fff

#define INDEXLOCAL   0
#define INDEXREMOTE  1

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} NETSHARE_ENUM, *PNETSHARE_ENUM;

typedef struct {
    CHAR sharePath[MAX_PATH + 1];
} NETSHARE_DATAA, *PNETSHARE_DATAA;

typedef struct {
    WCHAR sharePath[MAX_PATH + 1];
} NETSHARE_DATAW, *PNETSHARE_DATAW;

#ifdef UNICODE
#define NETSHARE_DATA   NETSHARE_DATAW
#define PNETSHARE_DATA  PNETSHARE_DATAW
#else
#define NETSHARE_DATA   NETSHARE_DATAA
#define PNETSHARE_DATA  PNETSHARE_DATAA
#endif

//
// types not defined by public headers
//

typedef NET_API_STATUS (* ScanNetShareEnumNT) (
        LMSTR servername,
        DWORD level,
        PBYTE *bufptr,
        DWORD prefmaxlen,
        PDWORD entriesread,
        PDWORD totalentries,
        PDWORD resume_handle
        );

typedef NET_API_STATUS (* ScanNetShareEnum9x) (
        const char *      servername,
        short             level,
        char *            bufptr,
        unsigned short    prefmaxlen,
        unsigned short *  entriesread,
        unsigned short *  totalentries
        );

typedef NET_API_STATUS (* ScanNetApiBufferFreeNT) ( void *);

typedef NET_API_STATUS (* ScanNetAccessEnum9x) (
        const char *     pszServer,
        char *           pszBasePath,
        short            fsRecursive,
        short            sLevel,
        char *           pbBuffer,
        unsigned short   cbBuffer,
        unsigned short * pcEntriesRead,
        unsigned short * pcTotalAvail
        );

#pragma pack(push)
#pragma pack(1)         /* Assume byte packing throughout */

struct _share_info_50 {
        char            shi50_netname[LM20_NNLEN+1];
        unsigned char   shi50_type;
        unsigned short  shi50_flags;
        char *          shi50_remark;
        char *          shi50_path;
        char            shi50_rw_password[SHPWLEN+1];
        char            shi50_ro_password[SHPWLEN+1];
};

struct access_list_2
{
        char *          acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */

struct access_info_2
{
        char *          acc2_resource_name;
        short           acc2_attr;
        unsigned short  acc2_count;
};      /* access_info_2 */

#pragma pack(pop)

//
// netapi functions
//

typedef NET_API_STATUS(WINAPI NETSHAREADDW)(
                        IN      PWSTR servername,
                        IN      DWORD level,
                        IN      PBYTE buf,
                        OUT     PDWORD parm_err
                        );
typedef NETSHAREADDW *PNETSHAREADDW;

typedef NET_API_STATUS(WINAPI NETSHAREDELW)(
                        IN      PWSTR servername,
                        IN      PWSTR netname,
                        IN      DWORD reserved
                        );
typedef NETSHAREDELW *PNETSHAREDELW;

//
// Globals
//

PMHANDLE g_NetSharesPool = NULL;
PMHANDLE g_PathPool = NULL;
HASHTABLE g_NetSharesTable;
MIG_OBJECTTYPEID g_NetShareTypeId = 0;
static BOOL g_IsWin9x = FALSE;
GROWBUFFER g_NetShareConversionBuff = INIT_GROWBUFFER;
BOOL g_NetSharesMigEnabled = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstNetShare;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextNetShare;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumNetShare;
TYPE_CONVERTOBJECTTOMULTISZ ConvertNetShareToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToNetShare;
TYPE_GETNATIVEOBJECTNAME GetNativeNetShareName;
TYPE_ACQUIREPHYSICALOBJECT AcquireNetShare;
TYPE_RELEASEPHYSICALOBJECT ReleaseNetShare;
TYPE_DOESPHYSICALOBJECTEXIST DoesNetShareExist;
TYPE_REMOVEPHYSICALOBJECT RemoveNetShare;
TYPE_CREATEPHYSICALOBJECT CreateNetShare;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertNetShareContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertNetShareContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedNetShareContent;

//
// netapi functions
//

PNETSHAREADDW g_NetShareAddW = NULL;
PNETSHAREDELW g_NetShareDelW = NULL;

//
// Code
//

BOOL
NetSharesInitialize (
    VOID
    )
{
    OSVERSIONINFO versionInfo;

    ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
    versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&versionInfo)) {
        return FALSE;
    }
    g_IsWin9x = (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    g_PathPool = PmCreateNamedPool ("NetShares Paths");
    g_NetSharesTable = HtAllocWithData (sizeof (PNETSHARE_DATA));
    g_NetSharesPool = PmCreateNamedPool ("NetShares");

    return TRUE;
}

VOID
NetSharesTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PNETSHARE_DATA netshareData;

    if (g_NetSharesTable) {
        if (EnumFirstHashTableString (&e, g_NetSharesTable)) {
            do {
                netshareData = *((PNETSHARE_DATA *) e.ExtraData);
                if (netshareData) {
                    PmReleaseMemory (g_NetSharesPool, netshareData);
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_NetSharesTable);
        g_NetSharesTable = NULL;
    }

    PmDestroyPool (g_NetSharesPool);
    g_NetSharesPool = NULL;

    PmDestroyPool (g_PathPool);
    g_PathPool = NULL;
}

BOOL
pLoadNetSharesData (
    VOID
    )
{
    DWORD  error;
    PBYTE  netBuffer = NULL;
    CHAR netBuf9x[16384];   // static because NetShareEnum is unreliable
    DWORD  netNumEntries = 0;
    DWORD  totalEntries = 0;
    DWORD  i;
    DWORD  j;
    DWORD  level;
    HINSTANCE hInst;
    PCTSTR name = NULL;
    PCTSTR path = NULL;
    PNETSHARE_DATA netshareData;

    //
    // Get the net share info from the machine
    //

    level = (g_IsWin9x ? 50 : 502);
    hInst = LoadLibraryA (g_IsWin9x ? "svrapi.dll" : "netapi32.dll");
    if (hInst == 0) {
        SetLastError (ERROR_INVALID_DLL);
        return FALSE;
    }

    if (g_IsWin9x) {
        struct _share_info_50 *tmpBuf;
        ScanNetShareEnum9x  pNetShareEnum9x  = NULL;
        ScanNetAccessEnum9x pNetAccessEnum9x = NULL;

        pNetShareEnum9x = (ScanNetShareEnum9x) GetProcAddress (hInst, "NetShareEnum");
        if (pNetShareEnum9x == NULL) {
            SetLastError (ERROR_INVALID_DLL);
            return FALSE;
        }
        pNetAccessEnum9x = (ScanNetAccessEnum9x) GetProcAddress (hInst, "NetAccessEnum");
        if (pNetAccessEnum9x == NULL) {
            SetLastError (ERROR_INVALID_DLL);
            return FALSE;
        }

        error = (*pNetShareEnum9x)(NULL,
                                   (short)level,
                                   netBuf9x,
                                   sizeof (netBuf9x),
                                   (USHORT *)&netNumEntries,
                                   (USHORT *)&totalEntries);

        if ((error == ERROR_SUCCESS) || (error == ERROR_MORE_DATA)) {

            for (i = 0; i < netNumEntries; i++) {
                DWORD dwPerms = 0;
                tmpBuf = (struct _share_info_50 *)(netBuf9x + (i * sizeof(struct _share_info_50)));

                // Require share to be a user-defined, persistent disk share
                if ((tmpBuf->shi50_flags & SHI50F_SYSTEM) ||
                   !(tmpBuf->shi50_flags & SHI50F_PERSIST) ||
                    tmpBuf->shi50_type != STYPE_DISKTREE ) {
                    continue;
                }

                if (tmpBuf->shi50_flags & SHI50F_RDONLY) {
                    dwPerms = ACCESS_READ;
                } else if (tmpBuf->shi50_flags & SHI50F_FULL) {
                    dwPerms = ACCESS_ALL;
                }

                // JTJTJT: Also store dwPerms

                //
                // Process custom access permissions
                //
                if ((tmpBuf->shi50_flags & SHI50F_ACCESSMASK) ==
                                                SHI50F_ACCESSMASK) {
                   static CHAR AccessInfoBuf[16384];
                   WORD wItemsAvail, wItemsRead;
                   error = (*pNetAccessEnum9x) (NULL,
                                     tmpBuf->shi50_path,
                                     0,
                                     2,
                                     AccessInfoBuf,
                                     sizeof (AccessInfoBuf),
                                     &wItemsRead,
                                     &wItemsAvail
                                     );

                   if (error != NERR_ACFNotLoaded) {
                       BOOL LostCustomAccess = FALSE;
                       if (error == ERROR_SUCCESS) {
                            struct access_info_2 *pai;
                            struct access_list_2 *pal;
                            pai = (struct access_info_2 *) AccessInfoBuf;
                            pal = (struct access_list_2 *) (&pai[1]);

                            for (j = 0 ; j < pai->acc2_count ; j++) {
#if 0
                    // turn off custom access support
                    // implementation is incomplete
                                if (pal->acl2_access & READ_ACCESS_FLAGS) {
                                    Win32Printf (h, "  %s, read\r\n",
                                                    pal->acl2_ugname);
                                } else if(pal->acl2_access & FULL_ACCESS_FLAGS) {
                                    Win32Printf (h, "  %s, full\r\n",
                                                    pal->acl2_ugname);
                                } else
#endif
                                    LostCustomAccess = TRUE;

                                pal++;
                            }
                            if (LostCustomAccess) {
                                DEBUGMSG ((DBG_NETSHARES, "Share %s not migrated.", tmpBuf->shi50_netname));
                                continue;
                            }
                            tmpBuf->shi50_flags |= SHI50F_ACLS;
                       } else if (error != ERROR_SUCCESS) {
                            return FALSE;
                       }
                   }
                }
                if (!(tmpBuf->shi50_flags & SHI50F_ACLS) &&
                         (tmpBuf->shi50_rw_password[0] ||
                          tmpBuf->shi50_ro_password[0])) {
                    //  IDS_SHARE_PASSWORD_NOT_MIGRATED, tmpBuf->shi50_netname
                    DEBUGMSG ((DBG_NETSHARES, "Share %s not migrated.", tmpBuf->shi50_netname));
                    continue;
                }

                // everything looks OK, let's add this entry
                name = ConvertAtoT (tmpBuf->shi50_netname);
                path = ConvertAtoT (tmpBuf->shi50_path);

                netshareData = (PNETSHARE_DATA) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_DATA));
                ZeroMemory (netshareData, sizeof (NETSHARE_DATA));

                StringCopyTcharCount (netshareData->sharePath, path, MAX_PATH + 1);
                HtAddStringEx (g_NetSharesTable, name, &netshareData, FALSE);

                FreeAtoT (name);
                INVALID_POINTER (name);
                FreeAtoT (path);
                INVALID_POINTER (path);
            }
        } else if (error == NERR_ServerNotStarted) {
             error = ERROR_SUCCESS;
        }
    } else {
        ScanNetShareEnumNT  pNetShareEnum    = NULL;
        SHARE_INFO_502* tmpBuf = NULL;

        pNetShareEnum = (ScanNetShareEnumNT) GetProcAddress(hInst, "NetShareEnum");
        if (pNetShareEnum == NULL) {
            SetLastError (ERROR_INVALID_DLL);
            return FALSE;
        }
        //
        // Call the NetShareEnum function to list the
        //  shares, specifying information level 502.
        //
        error = (*pNetShareEnum)(NULL,
                                 level,
                                 (BYTE **) &netBuffer,
                                 MAX_PREFERRED_LENGTH,
                                 &netNumEntries,
                                 &totalEntries,
                                 NULL);

        //
        // Loop through the entries; process errors.
        //
        if (error == ERROR_SUCCESS) {
            if ((tmpBuf = (SHARE_INFO_502 *)netBuffer) != NULL) {
                for (i = 0; (i < netNumEntries); i++) {
                    if (!(tmpBuf->shi502_type & STYPE_SPECIAL)) {

                        name = ConvertWtoT (tmpBuf->shi502_netname);
                        path = ConvertWtoT (tmpBuf->shi502_path);

                        netshareData = (PNETSHARE_DATA) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_DATA));
                        ZeroMemory (netshareData, sizeof (NETSHARE_DATA));

                        StringCopyTcharCount (netshareData->sharePath, path, MAX_PATH + 1);
                        HtAddStringEx (g_NetSharesTable, name, &netshareData, FALSE);
                        // JTJTJT: also store tmpBuf->shi502_permissions, tmpBuf->shi502_remark));

                        FreeWtoT (name);
                        INVALID_POINTER (name);
                        FreeWtoT (path);
                        INVALID_POINTER (path);
                    }
                    tmpBuf++;
                }
            }
        } else {
            //SetLastError (IDS_CANNOT_ENUM_NETSHARES);
            return FALSE;
        }

        if (netBuffer != NULL) {
           ScanNetApiBufferFreeNT pNetApiBufferFree = NULL;

           pNetApiBufferFree = (ScanNetApiBufferFreeNT) GetProcAddress (hInst, "NetApiBufferFree");
           if (pNetApiBufferFree != NULL)
               (*pNetApiBufferFree) (netBuffer);
        }
    }

    return TRUE;
}

BOOL
pLoadNetEntries (
    VOID
    )
{
    HMODULE netDll = NULL;
    BOOL result = FALSE;

    //
    // Get the net api entry points. Sometimes networking isn't installed.
    //

    __try {
        netDll = LoadLibrary (TEXT("NETAPI32.DLL"));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        netDll = NULL;
    }
    if (netDll) {
        g_NetShareAddW = (PNETSHAREADDW) GetProcAddress (netDll, "NetShareAdd");
        g_NetShareDelW = (PNETSHAREDELW) GetProcAddress (netDll, "NetShareDel");
        if (g_NetShareAddW && g_NetShareDelW) {
            result = TRUE;
        } else {
            result = FALSE;
            DEBUGMSG ((DBG_NETSHARES, "Not all NETAPI32 entry points were found."));
        }
    } else {
        DEBUGMSG ((DBG_NETSHARES, "NETAPI32 is not installed on this computer."));
    }
    return result;
}


BOOL
WINAPI
NetSharesEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TYPE_REGISTER netSharesTypeData;

    //
    // We need to register our type callback functions. Types allow us to
    // abstract net shares into generalized objects. The engine can perform
    // global operations with this abstraction (such as undo or compare), and
    // modules can access net shares without knowing the complexities of
    // OS-specific APIs, bugs & workarounds, storage formats, etc.  Script
    // modules can implement script capabilities that control net shares
    // without actually inventing special net share syntaxes (or even knowing
    // about net shares).
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    pLoadNetSharesData ();

    ZeroMemory (&netSharesTypeData, sizeof (TYPE_REGISTER));
    netSharesTypeData.Priority = PRIORITY_NETSHARE;

    if (Platform == PLATFORM_SOURCE) {

        netSharesTypeData.EnumFirstPhysicalObject = EnumFirstNetShare;
        netSharesTypeData.EnumNextPhysicalObject = EnumNextNetShare;
        netSharesTypeData.AbortEnumPhysicalObject = AbortEnumNetShare;
        netSharesTypeData.ConvertObjectToMultiSz = ConvertNetShareToMultiSz;
        netSharesTypeData.ConvertMultiSzToObject = ConvertMultiSzToNetShare;
        netSharesTypeData.GetNativeObjectName = GetNativeNetShareName;
        netSharesTypeData.AcquirePhysicalObject = AcquireNetShare;
        netSharesTypeData.ReleasePhysicalObject = ReleaseNetShare;
        netSharesTypeData.ConvertObjectContentToUnicode = ConvertNetShareContentToUnicode;
        netSharesTypeData.ConvertObjectContentToAnsi = ConvertNetShareContentToAnsi;
        netSharesTypeData.FreeConvertedObjectContent = FreeConvertedNetShareContent;

        g_NetShareTypeId = IsmRegisterObjectType (
                                S_NETSHARES_NAME,
                                TRUE,
                                FALSE,
                                &netSharesTypeData
                                );
    } else {

        netSharesTypeData.EnumFirstPhysicalObject = EnumFirstNetShare;
        netSharesTypeData.EnumNextPhysicalObject = EnumNextNetShare;
        netSharesTypeData.AbortEnumPhysicalObject = AbortEnumNetShare;
        netSharesTypeData.ConvertObjectToMultiSz = ConvertNetShareToMultiSz;
        netSharesTypeData.ConvertMultiSzToObject = ConvertMultiSzToNetShare;
        netSharesTypeData.GetNativeObjectName = GetNativeNetShareName;
        netSharesTypeData.AcquirePhysicalObject = AcquireNetShare;
        netSharesTypeData.ReleasePhysicalObject = ReleaseNetShare;
        netSharesTypeData.DoesPhysicalObjectExist = DoesNetShareExist;
        netSharesTypeData.RemovePhysicalObject = RemoveNetShare;
        netSharesTypeData.CreatePhysicalObject = CreateNetShare;
        netSharesTypeData.ConvertObjectContentToUnicode = ConvertNetShareContentToUnicode;
        netSharesTypeData.ConvertObjectContentToAnsi = ConvertNetShareContentToAnsi;
        netSharesTypeData.FreeConvertedObjectContent = FreeConvertedNetShareContent;

        g_NetShareTypeId = IsmRegisterObjectType (
                                S_NETSHARES_NAME,
                                TRUE,
                                FALSE,
                                &netSharesTypeData
                                );
        pLoadNetEntries ();
    }

    MYASSERT (g_NetShareTypeId);
    return TRUE;
}

UINT
NetSharesCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    //
    // This callback gets called for each net share.  We simply mark the
    // share to be applied.
    //

    IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);

    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
NetSharesSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Set the log callback (so all log messages to to the app)
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
NetSharesSgmParse (
    IN      PVOID Reserved
    )
{
    PCTSTR friendlyName;

    friendlyName = GetStringResource (MSG_NET_SHARE_NAME);

    IsmAddComponentAlias (
        S_NETSHARES_NAME,
        MASTERGROUP_SYSTEM,
        friendlyName,
        COMPONENT_NAME,
        FALSE
        );

    FreeStringResource (friendlyName);
    return TRUE;
}

BOOL
WINAPI
NetSharesSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_NETSHARES_NAME, 0)) {
        g_NetSharesMigEnabled = FALSE;
        return TRUE;
    }
    g_NetSharesMigEnabled = TRUE;

    //
    // Queue all net shares to be applied. This could be enhanced to allow a
    // script to drive what should be restored.
    //

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, FALSE);
    IsmQueueEnumeration (g_NetShareTypeId, pattern, NetSharesCallback, (ULONG_PTR) 0, S_NETSHARES_NAME);
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
NetSharesVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Set the log callback (so all log messages to to the app)
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
NetSharesVcmParse (
    IN      PVOID Reserved
    )
{
    return NetSharesSgmParse (Reserved);
}

BOOL
WINAPI
NetSharesVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_NETSHARES_NAME, 0)) {
        g_NetSharesMigEnabled = FALSE;
        return TRUE;
    }
    g_NetSharesMigEnabled = TRUE;

    //
    // Queue all net share objects to be marked as persistent
    //

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, FALSE);
    IsmQueueEnumeration (g_NetShareTypeId, pattern, NetSharesCallback, (ULONG_PTR) 0, S_NETSHARES_NAME);
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}


BOOL
pEnumNetShareWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PNETSHARE_ENUM NetShareEnum
    )
{
    //
    // Test enumerated item against the pattern, and return only
    // when the pattern matches. Also, fill the entire enum
    // structure upon successful enumeration.
    //

    IsmDestroyObjectString (EnumPtr->ObjectNode);
    EnumPtr->ObjectNode = NULL;

    IsmDestroyObjectString (EnumPtr->ObjectLeaf);
    EnumPtr->ObjectLeaf = NULL;

    for (;;) {
        EnumPtr->ObjectName = IsmCreateObjectHandle (NetShareEnum->HashData.String, NULL);

        if (!ObsPatternMatch (NetShareEnum->Pattern, EnumPtr->ObjectName)) {
            if (!EnumNextHashTableString (&NetShareEnum->HashData)) {
                AbortEnumNetShare (EnumPtr);
                return FALSE;
            }
            continue;
        }

        EnumPtr->NativeObjectName = NetShareEnum->HashData.String;

        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);

        EnumPtr->Level = 1;
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = FALSE;
        EnumPtr->IsNode = TRUE;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;

        break;
    }

    return TRUE;
}

BOOL
EnumFirstNetShare (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PNETSHARE_ENUM netShareEnum = NULL;

    if (!g_NetSharesTable) {
        return FALSE;
    }

    netShareEnum = (PNETSHARE_ENUM) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_ENUM));
    netShareEnum->Pattern = PmDuplicateString (g_NetSharesPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) netShareEnum;

    if (EnumFirstHashTableString (&netShareEnum->HashData, g_NetSharesTable)) {
        return pEnumNetShareWorker (EnumPtr, netShareEnum);
    }

    AbortEnumNetShare (EnumPtr);
    return FALSE;
}

BOOL
EnumNextNetShare (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PNETSHARE_ENUM netShareEnum = NULL;

    netShareEnum = (PNETSHARE_ENUM)(EnumPtr->EtmHandle);
    if (!netShareEnum) {
        return FALSE;
    }

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }

    if (EnumNextHashTableString (&netShareEnum->HashData)) {
        return pEnumNetShareWorker (EnumPtr, netShareEnum);
    }

    AbortEnumNetShare (EnumPtr);
    return FALSE;
}


VOID
AbortEnumNetShare (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PNETSHARE_ENUM netShareEnum = NULL;

    MYASSERT (EnumPtr);

    netShareEnum = (PNETSHARE_ENUM)(EnumPtr->EtmHandle);
    if (!netShareEnum) {
        return;
    }

    IsmDestroyObjectHandle (EnumPtr->ObjectName);
    IsmDestroyObjectString (EnumPtr->ObjectNode);
    IsmDestroyObjectString (EnumPtr->ObjectLeaf);
    PmReleaseMemory (g_NetSharesPool, netShareEnum->Pattern);
    PmReleaseMemory (g_NetSharesPool, netShareEnum);

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}


BOOL
AcquireNetShare (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN OUT  PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PNETSHARE_DATA netshareData;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    //
    // NOTE: Do not zero ObjectContent; some of its members were already set
    //

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        DEBUGMSG ((
            DBG_WHOOPS,
            "Unexpected acquire request for %s: Can't acquire net shares as files",
            ObjectName
            ));

        return FALSE;
    }

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (HtFindStringEx (g_NetSharesTable, node, (PVOID)&netshareData, FALSE)) {

            //
            // Fill in all the content members.  We already zeroed the struct,
            // so most of the members are taken care of because they are zero.
            //

            ObjectContent->MemoryContent.ContentBytes = (PBYTE)netshareData;
            ObjectContent->MemoryContent.ContentSize = sizeof(NETSHARE_DATA);

            result = TRUE;
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }
    return result;
}


BOOL
ReleaseNetShare (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    //
    // Clean up routine for the AcquireNetShare function
    //

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    return TRUE;
}


BOOL
DoesNetShareExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    BOOL result = FALSE;

    //
    // Given an object name (the net share), we must test to see if the
    // share exists on the machine.  A table was built at initialization
    // time to provide fast access to net shares.
    //

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (HtFindStringEx (g_NetSharesTable, node, NULL, FALSE)) {
            result = TRUE;
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }
    return result;
}

BOOL
RemoveNetShare (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    DWORD result = ERROR_NOT_FOUND;
    PCWSTR name;

    //
    // Given an object name (the net share), we must delete the share.
    //

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node && (!leaf)) {
            if (g_IsWin9x) {
               // JTJT: add here
            } else {

                name = CreateUnicode (node);

                if (g_NetShareDelW) {
                    // record value name deletion
                    IsmRecordOperation (JRNOP_DELETE,
                                        g_NetShareTypeId,
                                        ObjectName);
                    result = g_NetShareDelW (NULL, (PWSTR) name, 0);
                } else {
                    result = ERROR_CALL_NOT_IMPLEMENTED;
                }

                DestroyUnicode (name);
            }
            if (result != NERR_Success) {
                DEBUGMSG ((DBG_NETSHARES, "Failed to delete existent net share %s", name));
            } else {
                HtRemoveString (g_NetSharesTable, node);
            }
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }
    return (result == NERR_Success);
}


BOOL
CreateNetShare (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node;
    PCTSTR leaf;
    DWORD result = NERR_Success;
    DWORD level;
    SHARE_INFO_502 shareInfo;
    PNETSHARE_DATA netshareData = NULL;

    //
    // The name of the net share is in the object name's node. The net share
    // content provides the path of the share.  Details provide the net share
    // ACLs.
    //
    // Our job is to take the object name, content and details, and create a
    // share.  We ignore the case where the content is in a file.  This should
    // not apply to net shares.
    //

    if (!ObjectContent->ContentInFile) {
        if (ObjectContent->MemoryContent.ContentBytes && ObjectContent->MemoryContent.ContentSize) {
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
                if (node && (!leaf)) {
                    level = (g_IsWin9x ? 50 : 502);

                    netshareData = (PNETSHARE_DATA) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_DATA));
                    CopyMemory (netshareData,
                                ObjectContent->MemoryContent.ContentBytes,
                                sizeof(NETSHARE_DATA));

                    if (DoesFileExist (netshareData->sharePath)) {

                        if (g_IsWin9x) {
                           // JTJT: add here
                        } else {
                            shareInfo.shi502_netname = (PWSTR) CreateUnicode (node);
                            shareInfo.shi502_path = (PWSTR) CreateUnicode (netshareData->sharePath);

                            shareInfo.shi502_type = STYPE_DISKTREE;       // JTJTJT: retrieve type
                            shareInfo.shi502_remark = NULL;               // JTJTJT: retrieve remark
                            shareInfo.shi502_permissions = ACCESS_ALL;    // JTJTJT: retrieve perms
                            shareInfo.shi502_max_uses = -1;               // JTJTJT: retrieve max uses
                            shareInfo.shi502_current_uses = 0;
                            shareInfo.shi502_passwd = NULL;               // JTJTJT: retrieve password
                            shareInfo.shi502_reserved = 0;
                            shareInfo.shi502_security_descriptor = NULL;  // JTJTJT: retrieve ACLs

                            if (g_NetShareAddW) {
                                IsmRecordOperation (JRNOP_CREATE,
                                                    g_NetShareTypeId,
                                                    ObjectName);
                                result = g_NetShareAddW (NULL, level, (PBYTE)&shareInfo, NULL);
                            } else {
                                result = ERROR_CALL_NOT_IMPLEMENTED;
                            }

                            DestroyUnicode (shareInfo.shi502_netname);
                            DestroyUnicode (shareInfo.shi502_path);
                        }

                        if (result != NERR_Success) {
                            DEBUGMSG ((DBG_NETSHARES, "Failed to add net share for %s", node));
                        } else {
                            HtAddStringEx (g_NetSharesTable, node, &netshareData, FALSE);
                        }
                    }
                    PmReleaseMemory (g_NetSharesPool, netshareData);
                }

                IsmDestroyObjectString (node);
                INVALID_POINTER (node);

                IsmDestroyObjectString (leaf);
                INVALID_POINTER (leaf);
            }
        }
    } else {
        DEBUGMSG ((DBG_WHOOPS, "Did not expect content to come in the form of a file."));
    }

    return (result == NERR_Success);
}

PCTSTR
ConvertNetShareToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR result;
    PNETSHARE_DATA netshareData;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        //
        // Copy field 1 (share name) and field 2 (share path) to a temp
        // multi-sz buffer
        //

        MYASSERT (!ObjectContent->ContentInFile);
        MYASSERT (ObjectContent->MemoryContent.ContentBytes);
        g_NetShareConversionBuff.End = 0;

        GbCopyQuotedString (&g_NetShareConversionBuff, node);

        if (ObjectContent->MemoryContent.ContentBytes) {
            netshareData = (PNETSHARE_DATA) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_DATA));
            CopyMemory (&netshareData->sharePath, ObjectContent->MemoryContent.ContentBytes, sizeof(NETSHARE_DATA));

            GbCopyQuotedString (&g_NetShareConversionBuff, netshareData->sharePath);

            PmReleaseMemory (g_NetSharesPool, netshareData);
            netshareData = NULL;
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }

    //
    // Terminate the multi-sz
    //

    GbCopyString (&g_NetShareConversionBuff, TEXT(""));

    //
    // Transfer temp buffer to an ISM-allocated buffer and forget about it
    //

    result = IsmGetMemory (g_NetShareConversionBuff.End);
    CopyMemory (result, g_NetShareConversionBuff.Buf, g_NetShareConversionBuff.End);

    return result;
}


BOOL
ConvertMultiSzToNetShare (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    MULTISZ_ENUM e;
    PCTSTR localName = NULL;
    UINT index;
    NETSHARE_DATA netshareData;
    BOOL pathFound = FALSE;

    //
    // Parse the multi-sz into the net share content and details.
    // The user may have edited the text (and potentially introduced
    // errors).
    //

    ZeroMemory (&netshareData, sizeof (NETSHARE_DATA));

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&e, ObjectMultiSz)) {
        index = 0;
        do {
            switch (index) {
            case INDEXLOCAL:
               localName = e.CurrentString;
               break;
            case INDEXREMOTE:
               pathFound = TRUE;
               StringCopyTcharCount (netshareData.sharePath, e.CurrentString, MAX_PATH + 1);
               break;
            default:
               // Ignore extra data
               DEBUGMSG ((DBG_WARNING, "Extra net share string ignored: %s", e.CurrentString));
               break;
            }

            index++;

        } while (EnumNextMultiSz (&e));
    }

    if (!localName || !pathFound) {
        //
        // Bogus data, fail
        //

        return FALSE;
    }

    //
    // Fill in all the members of the content structure. Keep in mind
    // we already zeroed the buffer.
    //

    *ObjectName = IsmCreateObjectHandle (localName, NULL);

    if (ObjectContent) {
        ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETSHARE_DATA));
        CopyMemory ((PBYTE) ObjectContent->MemoryContent.ContentBytes, &netshareData, sizeof (NETSHARE_DATA));
        ObjectContent->MemoryContent.ContentSize = sizeof (NETSHARE_DATA);
    }

    return TRUE;
}


PCTSTR
GetNativeNetShareName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node, leaf;
    UINT size;
    PTSTR result = NULL;

    //
    // The "native" format is what most people would use to describe our
    // object.  For the net share case, we simply get the share name from the
    // node; the node is not encoded in any way, and the leaf is not used.
    //

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node) {
            size = SizeOfString (node);
            if (size) {
                result = IsmGetMemory (size);
                CopyMemory (result, node, size);
            }
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }

    return result;
}

PMIG_CONTENT
ConvertNetShareContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Mapped Drive content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETSHARE_DATAW));
            if (result->MemoryContent.ContentBytes) {
                DirectDbcsToUnicodeN (
                    ((PNETSHARE_DATAW)result->MemoryContent.ContentBytes)->sharePath,
                    ((PNETSHARE_DATAA)ObjectContent->MemoryContent.ContentBytes)->sharePath,
                    MAX_PATH + 1
                    );
                result->MemoryContent.ContentSize = sizeof (NETSHARE_DATAW);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertNetShareContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Mapped Drive content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETSHARE_DATAA));
            if (result->MemoryContent.ContentBytes) {
                DirectUnicodeToDbcsN (
                    ((PNETSHARE_DATAA)result->MemoryContent.ContentBytes)->sharePath,
                    ((PNETSHARE_DATAW)ObjectContent->MemoryContent.ContentBytes)->sharePath,
                    MAX_PATH + 1
                    );
                result->MemoryContent.ContentSize = sizeof (NETSHARE_DATAA);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedNetShareContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\ansi\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cookies.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\osfiles.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    osfiles.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 08 Mar 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include "osfiles.h"

#define DBG_OSFILES     "OsFiles"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_ATTRIBUTEID g_OsFileAttribute;
PCTSTR g_InfPath = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

SGMENUMERATIONCALLBACK SgmOsFilesCallback;
VCMENUMERATIONCALLBACK VcmOsFilesCallback;

//
// Code
//

BOOL
WINAPI
OsFilesSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    HINF infHandle;
    UINT sizeNeeded;
    ENVENTRY_TYPE dataType;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_OsFileAttribute = IsmRegisterAttribute (S_ATTRIBUTE_OSFILE, FALSE);

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {
        if (!InitMigDbEx (infHandle)) {
            DEBUGMSG((DBG_ERROR, "Error initializing OsFiles database"));
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
WINAPI
OsFilesSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmHookEnumeration (MIG_FILE_TYPE, pattern, SgmOsFilesCallback, (ULONG_PTR) 0, TEXT("OsFiles"));
    IsmDestroyObjectHandle (pattern);
    return TRUE;
}

BOOL
WINAPI
OsFilesSgmQueueHighPriorityEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmHookEnumeration (MIG_FILE_TYPE, pattern, SgmOsFilesCallback, (ULONG_PTR) 0, TEXT("OsFiles"));
    IsmDestroyObjectHandle (pattern);
    return TRUE;
}

UINT
SgmOsFilesCallback (
    PCMIG_OBJECTENUMDATA Data,
    ULONG_PTR CallerArg
    )
{
    FILE_HELPER_PARAMS params;

    params.ObjectName = Data->ObjectName;
    params.NativeObjectName = Data->NativeObjectName;
    params.Handled = FALSE;
    params.FindData = (PWIN32_FIND_DATA)(Data->Details.DetailsData);
    params.ObjectNode = Data->ObjectNode;
    params.ObjectLeaf = Data->ObjectLeaf;
    params.IsNode = Data->IsNode;
    params.IsLeaf = Data->IsLeaf;

    MigDbTestFile (&params);

    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
OsFilesVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    HINF infHandle;
    UINT sizeNeeded;
    ENVENTRY_TYPE dataType;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    if (IsmGetRealPlatform () == PLATFORM_DESTINATION) {
        // we don't have any work to do
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    g_OsFileAttribute = IsmRegisterAttribute (S_ATTRIBUTE_OSFILE, FALSE);

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {
        if (!InitMigDbEx (infHandle)) {
            DEBUGMSG((DBG_ERROR, "Error initializing OsFiles database"));
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
WINAPI
OsFilesVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmHookEnumeration (MIG_FILE_TYPE, pattern, VcmOsFilesCallback, (ULONG_PTR) 0, TEXT("OsFiles"));
    IsmDestroyObjectHandle (pattern);
    return TRUE;
}

BOOL
WINAPI
OsFilesVcmQueueHighPriorityEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmHookEnumeration (MIG_FILE_TYPE, pattern, VcmOsFilesCallback, (ULONG_PTR) 0, TEXT("OsFiles"));
    IsmDestroyObjectHandle (pattern);
    return TRUE;
}

UINT
VcmOsFilesCallback (
    PCMIG_OBJECTENUMDATA Data,
    ULONG_PTR CallerArg
    )
{
    FILE_HELPER_PARAMS params;

    params.ObjectName = Data->ObjectName;
    params.NativeObjectName = Data->NativeObjectName;
    params.Handled = FALSE;
    params.FindData = (PWIN32_FIND_DATA)(Data->Details.DetailsData);
    params.ObjectNode = Data->ObjectNode;
    params.ObjectLeaf = Data->ObjectLeaf;
    params.IsNode = Data->IsNode;
    params.IsLeaf = Data->IsLeaf;

    MigDbTestFile (&params);

    return CALLBACK_ENUM_CONTINUE;
}

BOOL
OsFilesInitialize (
    VOID
    )
{
    return TRUE;
}


VOID
OsFilesTerminate (
    VOID
    )
{
    DoneMigDbEx ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\unicode\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\sources.inc ===
!include ..\..\modules.mk

MINORCOMP=sysmod

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\entry.c          \
    ..\cookies.c        \
    ..\lnkmig.c         \
    ..\netdrives.c      \
    ..\netshares.c      \
    ..\osfiles.c        \
    ..\dbattrib.c       \
    ..\dbaction.c       \
    ..\migdb.c          \
    ..\printers.c       \
    ..\rasmig.c         \
    ..\access.c         \
    ..\sysmod.rc        \
    ..\logmsg.mc        \


DLLENTRY=_DllMainCRTStartup
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00
WINVER_VERSION=0x0500


# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(SDK_LIB_PATH)\winspool.lib            \
            $(SDK_LIB_PATH)\wininet.lib             \
            $(COBRA_ROOT)\lib\$(O)\version.lib      \
            $(COBRA_ROOT)\lib\$(O)\modimage.lib     \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\reg.lib          \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\icons.lib        \
            $(COBRA_ROOT)\lib\$(O)\modimage.lib     \
            $(COBRA_ROOT)\lib\$(O)\linkpif.lib      \

PRECOMPILED_INCLUDE=pch.h

DLLDEF=..\sysmod.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\rasmig.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    rasmig.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 08 Mar 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"

#include <ras.h>
#include <raserror.h>

#define DBG_RASMIG  "RasMig"
#define SIZEOF_STRUCT(structname, uptomember)  ((int)((LPBYTE)(&((structname*)0)->uptomember) - ((LPBYTE)((structname*)0))))

//
// Strings
//

#define S_RAS_POOL_NAME                 "RasConnection"
#define S_RAS_NAME                      TEXT("RasConnection")
#define S_PBKFILE_ATTRIBUTE             TEXT("PbkFile")
#ifdef UNICODE
#define S_RASAPI_RASSETCREDENTIALS      "RasSetCredentialsW"
#define S_RASAPI_RASDELETEENTRY         "RasDeleteEntryW"
#else
#define S_RASAPI_RASSETCREDENTIALS      "RasSetCredentialsA"
#define S_RASAPI_RASDELETEENTRY         "RasDeleteEntryA"
#endif

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// RAS api functions

typedef DWORD(WINAPI RASGETCREDENTIALSA)(
                        IN      LPCSTR lpszPhonebook,
                        IN      LPCSTR lpszEntry,
                        OUT     LPRASCREDENTIALSA lpRasCredentials
                        );
typedef RASGETCREDENTIALSA *PRASGETCREDENTIALSA;

typedef DWORD(WINAPI RASSETCREDENTIALS)(
                        IN      LPCTSTR lpszPhonebook,
                        IN      LPCTSTR lpszEntry,
                        IN      LPRASCREDENTIALS lpRasCredentials,
                        IN      BOOL fClearCredentials
                        );
typedef RASSETCREDENTIALS *PRASSETCREDENTIALS;

typedef DWORD(WINAPI RASDELETEENTRY)(
                        IN      LPCTSTR lpszPhonebook,
                        IN      LPCTSTR lpszEntry
                        );
typedef RASDELETEENTRY *PRASDELETEENTRY;

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} RAS_ENUM, *PRAS_ENUM;

//
// Globals
//

PMHANDLE g_RasPool = NULL;
HASHTABLE g_RasTable;
MIG_OBJECTTYPEID g_RasTypeId = 0;
static MIG_OBJECTTYPEID g_FileTypeId = 0;
MIG_ATTRIBUTEID g_PbkFileAttribute = 0;
BOOL g_AllowPbkRestore = FALSE;
GROWBUFFER g_RasConversionBuff = INIT_GROWBUFFER;
MIG_OBJECTSTRINGHANDLE g_Win9xPbkFile = NULL;
BOOL g_SrcOSNT4 = FALSE;
BOOL g_FirstRasPair = FALSE;
BOOL g_DelayRasOp = FALSE;

// RAS api functions
PRASGETCREDENTIALSA g_RasGetCredentialsA = NULL;
PRASSETCREDENTIALS g_RasSetCredentials = NULL;
PRASDELETEENTRY g_RasDeleteEntry = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

SGMENUMERATIONCALLBACK SgmRasConnectionsCallback;
VCMENUMERATIONCALLBACK VcmRasConnectionsCallback;

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstRasConnection;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextRasConnection;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumRasConnection;
TYPE_CONVERTOBJECTTOMULTISZ ConvertRasConnectionToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToRasConnection;
TYPE_GETNATIVEOBJECTNAME GetNativeRasConnectionName;
TYPE_ACQUIREPHYSICALOBJECT AcquireRasConnection;
TYPE_RELEASEPHYSICALOBJECT ReleaseRasConnection;
TYPE_DOESPHYSICALOBJECTEXIST DoesRasConnectionExist;
TYPE_REMOVEPHYSICALOBJECT RemoveRasConnection;
TYPE_CREATEPHYSICALOBJECT CreateRasConnection;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertRasConnectionContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertRasConnectionContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedRasConnectionContent;
MIG_OBJECTENUMCALLBACK PbkFilesCallback;
MIG_RESTORECALLBACK PbkRestoreCallback;
OPMFILTERCALLBACK FilterRasAutoFilter;

PCTSTR
pCreate9xPbkFile (
    VOID
    );

//
// Code
//

BOOL
RasMigInitialize (
    VOID
    )
{
    g_RasTable = HtAllocWithData (sizeof (PCTSTR));
    if (!g_RasTable) {
        return FALSE;
    }
    g_RasPool = PmCreateNamedPool (S_RAS_POOL_NAME);
    if (!g_RasPool) {
        return FALSE;
    }
    return TRUE;
}

VOID
RasMigTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PCTSTR nativeName;
    PCTSTR rasData = NULL;

    if (g_Win9xPbkFile) {
        nativeName = IsmGetNativeObjectName (
                        g_FileTypeId,
                        g_Win9xPbkFile
                        );
        if (nativeName) {
            DeleteFile (nativeName);
            IsmReleaseMemory (nativeName);
        }
        IsmDestroyObjectHandle (g_Win9xPbkFile);
        g_Win9xPbkFile = NULL;
    }

    GbFree (&g_RasConversionBuff);

    if (g_RasTable) {
        if (EnumFirstHashTableString (&e, g_RasTable)) {
            do {
                rasData = *(PCTSTR *)(e.ExtraData);
                PmReleaseMemory (g_RasPool, rasData);
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_RasTable);
        g_RasTable = NULL;
    }

    if (g_RasPool) {
        PmDestroyPool (g_RasPool);
        g_RasPool = NULL;
    }
}

BOOL
pLoadRasEntries (
    BOOL LeftSide
    )
{
    HMODULE rasDll = NULL;
    BOOL result = FALSE;

    __try {
        rasDll = LoadLibrary (TEXT("RASAPI32.DLL"));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        rasDll = NULL;
    }
    if (rasDll) {
        if (LeftSide) {
            g_RasGetCredentialsA = (PRASGETCREDENTIALSA) GetProcAddress (rasDll, "RasGetCredentialsA");
        } else {
            g_RasSetCredentials = (PRASSETCREDENTIALS) GetProcAddress (rasDll, S_RASAPI_RASSETCREDENTIALS);
            g_RasDeleteEntry = (PRASDELETEENTRY) GetProcAddress (rasDll, S_RASAPI_RASDELETEENTRY);
        }
    } else {
        DEBUGMSG ((DBG_RASMIG, "RAS is not installed on this computer."));
    }
    return result;
}

BOOL
pAddWin9xPbkObject (
    VOID
    )
{
    g_Win9xPbkFile = pCreate9xPbkFile ();

    return (g_Win9xPbkFile != NULL);
}

BOOL
WINAPI
RasMigEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    MIG_OSVERSIONINFO versionInfo;
    TYPE_REGISTER rasConnTypeData;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_FileTypeId = MIG_FILE_TYPE;

    ZeroMemory (&rasConnTypeData, sizeof (TYPE_REGISTER));
    rasConnTypeData.Priority = PRIORITY_RASCONNECTION;

    if (Platform == PLATFORM_SOURCE) {
        rasConnTypeData.EnumFirstPhysicalObject = EnumFirstRasConnection;
        rasConnTypeData.EnumNextPhysicalObject = EnumNextRasConnection;
        rasConnTypeData.AbortEnumPhysicalObject = AbortEnumRasConnection;
        rasConnTypeData.ConvertObjectToMultiSz = ConvertRasConnectionToMultiSz;
        rasConnTypeData.ConvertMultiSzToObject = ConvertMultiSzToRasConnection;
        rasConnTypeData.GetNativeObjectName = GetNativeRasConnectionName;
        rasConnTypeData.AcquirePhysicalObject = AcquireRasConnection;
        rasConnTypeData.ReleasePhysicalObject = ReleaseRasConnection;
        rasConnTypeData.ConvertObjectContentToUnicode = ConvertRasConnectionContentToUnicode;
        rasConnTypeData.ConvertObjectContentToAnsi = ConvertRasConnectionContentToAnsi;
        rasConnTypeData.FreeConvertedObjectContent = FreeConvertedRasConnectionContent;

        g_RasTypeId = IsmRegisterObjectType (
                            S_RAS_NAME,
                            TRUE,
                            FALSE,
                            &rasConnTypeData
                            );

        pLoadRasEntries (TRUE);
        if (IsmGetOsVersionInfo (Platform, &versionInfo)) {
            if (versionInfo.OsType == OSTYPE_WINDOWS9X) {
                // now it's time to convert registry into a PBK file
                pAddWin9xPbkObject ();
            }
            if ((versionInfo.OsType == OSTYPE_WINDOWSNT) &&
                (versionInfo.OsMajorVersion == OSMAJOR_WINNT4)
                ) {
                g_SrcOSNT4 = TRUE;
            }
        }
    } else {
        rasConnTypeData.ConvertObjectToMultiSz = ConvertRasConnectionToMultiSz;
        rasConnTypeData.ConvertMultiSzToObject = ConvertMultiSzToRasConnection;
        rasConnTypeData.GetNativeObjectName = GetNativeRasConnectionName;
        rasConnTypeData.DoesPhysicalObjectExist = DoesRasConnectionExist;
        rasConnTypeData.RemovePhysicalObject = RemoveRasConnection;
        rasConnTypeData.CreatePhysicalObject = CreateRasConnection;
        rasConnTypeData.ConvertObjectContentToUnicode = ConvertRasConnectionContentToUnicode;
        rasConnTypeData.ConvertObjectContentToAnsi = ConvertRasConnectionContentToAnsi;
        rasConnTypeData.FreeConvertedObjectContent = FreeConvertedRasConnectionContent;

        g_RasTypeId = IsmRegisterObjectType (
                            S_RAS_NAME,
                            TRUE,
                            FALSE,
                            &rasConnTypeData
                            );
        pLoadRasEntries (FALSE);
        if (IsmGetOsVersionInfo (Platform, &versionInfo)) {
            if ((versionInfo.OsType == OSTYPE_WINDOWSNT) &&
                (versionInfo.OsMajorVersion == OSMAJOR_WINNT4)
                ) {
                g_SrcOSNT4 = TRUE;
            }
        }
    }
    MYASSERT (g_RasTypeId);

    return TRUE;
}

PCTSTR
pGetNextRasConnection (
    IN      HANDLE PbkHandle
    )
{
    CHAR input = 0;
    ULONGLONG beginPos = 0;
    ULONGLONG endPos = 0;
    ULONGLONG lastPos = 0;
    PSTR resultTmp = NULL;
    PTSTR result = NULL;
#ifdef UNICODE
    WORD oldCodePage;
    DWORD sizeW = 0;
    PWSTR resultW = NULL;
#endif

    while (TRUE) {
        if (!BfReadFile (PbkHandle, (PBYTE)(&input), sizeof (CHAR))) {
            break;
        }
        if (input == '[') {
            if (!beginPos) {
                BfGetFilePointer (PbkHandle, &beginPos);
            }
        }
        if (input == ']') {
            if (beginPos) {
                if (!endPos) {
                    BfGetFilePointer (PbkHandle, &endPos);
                    endPos --;
                } else {
                    beginPos = 0;
                    endPos = 0;
                }
            }
        }
        if (input == '\n') {
            if (beginPos && endPos && (endPos > beginPos)) {
                BfGetFilePointer (PbkHandle, &lastPos);
                BfSetFilePointer (PbkHandle, beginPos);
                resultTmp = PmGetMemory (g_RasPool, ((UINT) (endPos - beginPos) + 1) * sizeof (CHAR));
                if (!BfReadFile (PbkHandle, (PBYTE) resultTmp, (UINT) (endPos - beginPos) + 1)) {
                    PmReleaseMemory (g_RasPool, resultTmp);
                    resultTmp = NULL;
                } else {
                    resultTmp [(UINT) (endPos - beginPos)] = 0;
                }
                BfSetFilePointer (PbkHandle, lastPos);
                break;
            }
            beginPos = 0;
            endPos = 0;
        }
    }
#ifdef UNICODE
    if (resultTmp) {
        if (!g_SrcOSNT4) {
            // make sure that the conversion is using UTF8
            oldCodePage = SetConversionCodePage (CP_UTF8);
        }
        sizeW = SizeOfStringA(resultTmp);
        resultW = PmGetMemory (g_RasPool, sizeW * sizeof (WCHAR));
        if (resultW) {
            KnownSizeAtoW (resultW, resultTmp);
        }
        if (!g_SrcOSNT4) {
            SetConversionCodePage (oldCodePage);
        }
        if (resultW) {
            result = PmDuplicateStringW (g_RasPool, resultW);
            PmReleaseMemory (g_RasPool, resultW);
            resultW = NULL;
        }
    }
#else
    result = resultTmp;
#endif
    return result;
}

BOOL
pGetNextRasPair (
    IN      HANDLE PbkHandle,
    OUT     PCTSTR *ValueName,
    OUT     PCTSTR *Value
    )
{
    BOOL error = FALSE;
    CHAR input = 0;
    ULONGLONG beginPos = 0;
    ULONGLONG endPos = 0;
    ULONGLONG lastPos = 0;
    BOOL begin = TRUE;
    BOOL inValue = FALSE;
    PSTR valueName = NULL;
    PSTR value = NULL;
#ifdef UNICODE
    WORD oldCodePage;
    DWORD sizeW = 0;
    PWSTR valueNameW = NULL;
    PWSTR valueW = NULL;
#endif

    BfGetFilePointer (PbkHandle, &beginPos);
    while (TRUE) {
        if (!BfReadFile (PbkHandle, (PBYTE)(&input), sizeof (CHAR))) {
            error = TRUE;
            break;
        }
        if ((input == '[') && begin) {
            BfSetFilePointer (PbkHandle, beginPos);
            error = TRUE;
            break;
        }
        if ((input == ' ') && begin) {
            continue;
        }
        begin = FALSE;
        if (input == '=') {
            if (!inValue) {
                BfGetFilePointer (PbkHandle, &endPos);
                endPos --;
                if (endPos > beginPos) {
                    BfGetFilePointer (PbkHandle, &lastPos);
                    BfSetFilePointer (PbkHandle, beginPos);
                    valueName = PmGetMemory (g_RasPool, ((UINT) (endPos - beginPos) + 1) * sizeof (CHAR));
                    if (!BfReadFile (PbkHandle, (PBYTE) valueName, (UINT) (endPos - beginPos) + 1)) {
                        error = TRUE;
                        break;
                    } else {
                        valueName [(UINT) (endPos - beginPos)] = 0;
                    }
                    BfSetFilePointer (PbkHandle, lastPos);
                }
                BfGetFilePointer (PbkHandle, &beginPos);
                inValue = TRUE;
            }
            continue;
        }
        if (input == '\r') {
            BfGetFilePointer (PbkHandle, &endPos);
            endPos --;
            continue;
        }
        if (input == '\n') {
            if (endPos > beginPos) {
                BfGetFilePointer (PbkHandle, &lastPos);
                BfSetFilePointer (PbkHandle, beginPos);
                if (inValue) {
                    value = PmGetMemory (g_RasPool, ((UINT) (endPos - beginPos) + 1) * sizeof (CHAR));
                    if (!BfReadFile (PbkHandle, (PBYTE) value, (UINT) (endPos - beginPos) + 1)) {
                        error = TRUE;
                        break;
                    } else {
                        value [(UINT) (endPos - beginPos)] = 0;
                    }
                } else {
                    valueName = PmGetMemory (g_RasPool, ((UINT) (endPos - beginPos) + 1) * sizeof (CHAR));
                    if (!BfReadFile (PbkHandle, (PBYTE) valueName, (UINT) (endPos - beginPos) + 1)) {
                        error = TRUE;
                        break;
                    } else {
                        valueName [(UINT) (endPos - beginPos)] = 0;
                    }
                }
                BfSetFilePointer (PbkHandle, lastPos);
            }
            break;
        }
    }

    if (error) {
        if (valueName) {
            PmReleaseMemory (g_RasPool, valueName);
            valueName = NULL;
        }
        if (value) {
            PmReleaseMemory (g_RasPool, value);
            value = NULL;
        }
    }

    // if this is NT4 and this is the first time we are called,
    // we look to see if the first pair is the "Encoding=1" one.
    // If not, we are going to return it anyway and leave the
    // current read pair for the next time.
    if (g_SrcOSNT4 &&
        valueName &&
        g_FirstRasPair &&
        !StringIMatchA (valueName, "Encoding")
        ) {
        g_FirstRasPair = FALSE;
        // set the pointer to where we initially found it
        BfSetFilePointer (PbkHandle, beginPos);
        // free the valueName and value if needed
        PmReleaseMemory (g_RasPool, valueName);
        if (value) {
            PmReleaseMemory (g_RasPool, value);
        }
        valueName = PmDuplicateStringA (g_RasPool, "Encoding");
        value = PmDuplicateStringA (g_RasPool, "1");
    }

#ifdef UNICODE
    if (ValueName) {
        if (valueName) {
            if (!g_SrcOSNT4) {
                // make sure that the conversion is using UTF8
                oldCodePage = SetConversionCodePage (CP_UTF8);
            }
            sizeW = SizeOfStringA (valueName);
            valueNameW = PmGetMemory (g_RasPool, sizeW * sizeof (WCHAR));
            if (valueNameW) {
                KnownSizeAtoW (valueNameW, valueName);
            }
            if (!g_SrcOSNT4) {
                SetConversionCodePage (oldCodePage);
            }
            if (valueNameW) {
                *ValueName = PmDuplicateStringW (g_RasPool, valueNameW);
                PmReleaseMemory (g_RasPool, valueNameW);
            }
        } else {
            *ValueName = NULL;
        }
    }
    if (Value) {
        if (value) {
            if (!g_SrcOSNT4) {
                // make sure that the conversion is using UTF8
                oldCodePage = SetConversionCodePage (CP_UTF8);
            }
            sizeW = SizeOfStringA(value);
            valueW = PmGetMemory (g_RasPool, sizeW * sizeof (WCHAR));
            if (valueW) {
                KnownSizeAtoW (valueW, value);
            }
            if (!g_SrcOSNT4) {
                SetConversionCodePage (oldCodePage);
            }
            if (valueW) {
                *Value = PmDuplicateStringW (g_RasPool, valueW);
                PmReleaseMemory (g_RasPool, valueW);
            }
        } else {
            *Value = NULL;
        }
    }
#else
    if (ValueName) {
        *ValueName = valueName;
    }
    if (Value) {
        *Value = value;
    }
#endif
    return !error;
}

PCTSTR
pGetRasLineValue (
    IN      PCTSTR RasLines,
    IN      PCTSTR ValueName
    )
{
    MULTISZ_ENUM multiSzEnum;
    BOOL first = TRUE;
    BOOL found = FALSE;

    if (EnumFirstMultiSz (&multiSzEnum, RasLines)) {
        do {
            if (found) {
                return multiSzEnum.CurrentString;
            }
            if (first && StringIMatch (multiSzEnum.CurrentString, ValueName)) {
                found = TRUE;
            }
            first = !first;
        } while (EnumNextMultiSz (&multiSzEnum));
    }
    return NULL;
}

BOOL
pLoadRasConnections (
    IN      PCTSTR PbkFileName,
    IN      HASHTABLE RasTable
    )
{
    HANDLE pbkFileHandle;
    PCTSTR entryName;
    PCTSTR valueName;
    PCTSTR value;
    GROWBUFFER rasLines = INIT_GROWBUFFER;
    PTSTR rasLinesStr;
    MIG_OBJECTSTRINGHANDLE rasConnectionName;
    RASCREDENTIALSA rasCredentials;
    TCHAR valueStr [sizeof (DWORD) * 2 + 3];
    DWORD err;
    MIG_OSVERSIONINFO versionInfo;
    BOOL versionOk = FALSE;
    BOOL inMedia = FALSE;
    BOOL result = FALSE;
#ifdef UNICODE
    PCSTR tempStr1 = NULL;
    PCSTR tempStr2 = NULL;
    PCWSTR tempStr3 = NULL;
#endif

    if (!RasTable) {
        return FALSE;
    }

    pbkFileHandle = BfOpenReadFile (PbkFileName);
    if (pbkFileHandle) {
        while (TRUE) {
            // get the next RAS connection
            entryName = pGetNextRasConnection (pbkFileHandle);
            if (!entryName) {
                break;
            }
            rasLines.End = 0;
            GbMultiSzAppend (&rasLines, TEXT("ConnectionName"));
            GbMultiSzAppend (&rasLines, entryName);
            versionOk = IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo);
            // we use credentials API only on NT, on win9x the conversion code will automatically insert the fields
            if (!versionOk || (versionInfo.OsType != OSTYPE_WINDOWS9X)) {
                err = ERROR_INVALID_DATA;
                if (g_RasGetCredentialsA) {
                    ZeroMemory (&rasCredentials, sizeof (RASCREDENTIALSA));
                    rasCredentials.dwSize = sizeof (RASCREDENTIALSA);
                    rasCredentials.dwMask = RASCM_UserName | RASCM_Domain | RASCM_Password;
#ifdef UNICODE
                    tempStr1 = ConvertWtoA (PbkFileName);
                    tempStr2 = ConvertWtoA (entryName);
                    err = g_RasGetCredentialsA (tempStr1, tempStr2, &rasCredentials);
                    FreeConvertedStr (tempStr1);
                    FreeConvertedStr (tempStr2);
#else
                    err = g_RasGetCredentialsA (PbkFileName, entryName, &rasCredentials);
#endif
                    if (!err) {
                        wsprintf (valueStr, TEXT("0x%08X"), rasCredentials.dwMask);
                        GbMultiSzAppend (&rasLines, TEXT("CredMask"));
                        GbMultiSzAppend (&rasLines, valueStr);
                        GbMultiSzAppend (&rasLines, TEXT("CredName"));
#ifndef UNICODE
                        GbMultiSzAppend (&rasLines, (*rasCredentials.szUserName)?rasCredentials.szUserName:TEXT("<empty>"));
#else
                        tempStr3 = ConvertAtoW (rasCredentials.szUserName);
                        GbMultiSzAppend (&rasLines, (*tempStr3)?tempStr3:TEXT("<empty>"));
                        FreeConvertedStr (tempStr3);
#endif
                        GbMultiSzAppend (&rasLines, TEXT("CredDomain"));
#ifndef UNICODE
                        GbMultiSzAppend (&rasLines, (*rasCredentials.szDomain)?rasCredentials.szDomain:TEXT("<empty>"));
#else
                        tempStr3 = ConvertAtoW (rasCredentials.szDomain);
                        GbMultiSzAppend (&rasLines, (*tempStr3)?tempStr3:TEXT("<empty>"));
                        FreeConvertedStr (tempStr3);
#endif
                        GbMultiSzAppend (&rasLines, TEXT("CredPassword"));
#ifndef UNICODE
                        GbMultiSzAppend (&rasLines, (*rasCredentials.szPassword)?rasCredentials.szPassword:TEXT("<empty>"));
#else
                        tempStr3 = ConvertAtoW (rasCredentials.szPassword);
                        GbMultiSzAppend (&rasLines, (*tempStr3)?tempStr3:TEXT("<empty>"));
                        FreeConvertedStr (tempStr3);
#endif
                    }
                }
                if (err) {
                    GbMultiSzAppend (&rasLines, TEXT("CredMask"));
                    GbMultiSzAppend (&rasLines, TEXT("<empty>"));
                    GbMultiSzAppend (&rasLines, TEXT("CredName"));
                    GbMultiSzAppend (&rasLines, TEXT("<empty>"));
                    GbMultiSzAppend (&rasLines, TEXT("CredDomain"));
                    GbMultiSzAppend (&rasLines, TEXT("<empty>"));
                    GbMultiSzAppend (&rasLines, TEXT("CredPassword"));
                    GbMultiSzAppend (&rasLines, TEXT("<empty>"));
                }
            }
            inMedia = FALSE;
            g_FirstRasPair = TRUE;
            while (TRUE) {
                // get the next RAS connection line
                if (!pGetNextRasPair (pbkFileHandle, &valueName, &value)) {
                    break;
                }
                if (valueName &&
                    StringMatch (valueName, TEXT("MEDIA")) &&
                    value &&
                    StringIMatch (value, TEXT("serial"))
                    ) {
                    inMedia = TRUE;
                }
                if (inMedia &&
                    valueName &&
                    StringMatch (valueName, TEXT("DEVICE"))
                    ) {
                    inMedia = FALSE;
                }
                if (inMedia &&
                    valueName &&
                    StringIMatch (valueName, TEXT("Port"))
                    ) {
                    if (value) {
                        PmReleaseMemory (g_RasPool, value);
                        value = NULL;
                    }
                }
                if (inMedia &&
                    valueName &&
                    StringMatch (valueName, TEXT("Device"))
                    ) {
                    if (value) {
                        PmReleaseMemory (g_RasPool, value);
                        value = NULL;
                    }
                }
                GbMultiSzAppend (&rasLines, valueName?valueName:TEXT("<empty>"));
                GbMultiSzAppend (&rasLines, value?value:TEXT("<empty>"));
                if (valueName) {
                    PmReleaseMemory (g_RasPool, valueName);
                    valueName = NULL;
                }
                if (value) {
                    PmReleaseMemory (g_RasPool, value);
                    value = NULL;
                }
            }
            GbMultiSzAppend (&rasLines, TEXT(""));
            if (rasLines.End) {
                // now add the RAS connection
                rasLinesStr = PmGetMemory (g_RasPool, rasLines.End);
                CopyMemory (rasLinesStr, rasLines.Buf, rasLines.End);
                rasConnectionName = IsmCreateObjectHandle (PbkFileName, entryName);
                MYASSERT (rasConnectionName);
                if (rasConnectionName) {
                    result = TRUE;
                    HtAddStringEx (RasTable, rasConnectionName, &rasLinesStr, FALSE);
                }
                IsmDestroyObjectHandle (rasConnectionName);
            }
            PmReleaseMemory (g_RasPool, entryName);
        }

        CloseHandle (pbkFileHandle);
    }

    return result;
}

UINT
PbkFilesCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    if (Data->IsLeaf) {
        // do this only if somebody actually persisted the object
        if (IsmIsPersistentObject (Data->ObjectTypeId, Data->ObjectName) ||
            IsmIsApplyObject (Data->ObjectTypeId, Data->ObjectName)
            ) {
            // record all connections from this PBK file
            if (pLoadRasConnections (Data->NativeObjectName, g_RasTable)) {
                // this is really a PBK file and at least one valid
                // connection was found
                // set the PbkFile attribute so we won't restore this one as a file (if it survives)
                IsmSetAttributeOnObject (Data->ObjectTypeId, Data->ObjectName, g_PbkFileAttribute);
            }
        }
    }
    return CALLBACK_ENUM_CONTINUE;
}

VOID
WINAPI
RasMigEtmNewUserCreated (
    IN      PCTSTR UserName,
    IN      PCTSTR DomainName,
    IN      PCTSTR UserProfileRoot,
    IN      PSID UserSid
    )
{
    // a new user was created, the RAS operations on object that
    // belong exclusively to that user need to be delayed
    g_DelayRasOp = TRUE;
}

BOOL
WINAPI
RasMigSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
RasMigSgmParse (
    IN      PVOID Reserved
    )
{
    return TRUE;
}

UINT
SgmRasConnectionsCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCTSTR node, nodePtr, leaf;
    PTSTR leafPtr;
    PCTSTR rasLines;
    PCTSTR rasValue;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PCTSTR nativeName;
    MIG_OSVERSIONINFO versionInfo;
    BOOL versionOk = FALSE;

    if (IsmGetRealPlatform () == PLATFORM_DESTINATION) {
        // let's reset the PbkFileAttribute on the source of this connection
        // because the attribute was lost during the transport
        if (IsmCreateObjectStringsFromHandle (Data->ObjectName, &node, &leaf)) {
            if (node) {
                leafPtr = _tcsrchr (node, TEXT('\\'));
                if (leafPtr) {
                    *leafPtr = 0;
                    leafPtr ++;
                    objectName = IsmCreateObjectHandle (node, leafPtr);
                    if (objectName) {
                        IsmSetAttributeOnObject (g_FileTypeId, objectName, g_PbkFileAttribute);
                        IsmDestroyObjectHandle (objectName);
                    }
                }
            }
            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        }
    }
    // let's see if we can actually migrate this RAS connection
    if (IsmAcquireObject (Data->ObjectTypeId, Data->ObjectName, &objectContent)) {
        versionOk = IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo);
        rasLines = (PCTSTR) objectContent.MemoryContent.ContentBytes;
        rasValue = pGetRasLineValue (rasLines, TEXT("BaseProtocol"));
        if (rasValue && (StringIMatch (rasValue, TEXT("1")) || StringIMatch (rasValue, TEXT("2")))) {
            IsmAbandonObjectOnCollision (Data->ObjectTypeId, Data->ObjectName);
            IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);

            // now it's a good time to force the migration of the script file
            // if this connection has one
            rasValue = NULL;
            if (versionOk) {
                if (versionInfo.OsType == OSTYPE_WINDOWSNT) {
                    if (versionInfo.OsMajorVersion == OSMAJOR_WINNT4) {
                        rasValue = pGetRasLineValue (rasLines, TEXT("Type"));
                    }
                    if (versionInfo.OsMajorVersion == OSMAJOR_WINNT5) {
                        rasValue = pGetRasLineValue (rasLines, TEXT("Name"));
                    }
                }
                if (versionInfo.OsType == OSTYPE_WINDOWS9X) {
                    rasValue = pGetRasLineValue (rasLines, TEXT("Name"));
                }
            }
            if (rasValue && *rasValue) {
                node = DuplicatePathString (rasValue, 0);
                if (_tcsnextc (node) == TEXT('[')) {
                    nodePtr = _tcsinc (node);
                } else {
                    nodePtr = node;
                }
                leafPtr = _tcsrchr (nodePtr, TEXT('\\'));
                if (leafPtr) {
                    *leafPtr = 0;
                    leafPtr ++;
                    objectName = IsmCreateObjectHandle (nodePtr, leafPtr);
                    if (objectName) {
                        IsmMakeApplyObject (g_FileTypeId, objectName);
                        IsmDestroyObjectHandle (objectName);
                    }
                }
                FreePathString (node);
            }
        } else {
            // this is an unsupported framing protocol
            // we will log a message and abandon this connection
            nativeName = IsmGetNativeObjectName (Data->ObjectTypeId, Data->ObjectName);
            LOG ((LOG_WARNING, (PCSTR) MSG_RASMIG_UNSUPPORTEDSETTINGS, nativeName));
            IsmReleaseMemory (nativeName);
        }
        IsmReleaseObject (&objectContent);
    }
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
RasMigSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    g_PbkFileAttribute = IsmRegisterAttribute (S_PBKFILE_ATTRIBUTE, FALSE);
    MYASSERT (g_PbkFileAttribute);

    if (IsmGetRealPlatform () == PLATFORM_SOURCE) {

        // hook all PBK files enumeration, we will not migrate the files but the connections within
        pattern = IsmCreateSimpleObjectPattern (NULL, FALSE, TEXT("*.PBK"), TRUE);

        IsmHookEnumeration (
            g_FileTypeId,
            pattern,
            PbkFilesCallback,
            (ULONG_PTR) 0,
            TEXT("PbkFiles")
            );

        IsmDestroyObjectHandle (pattern);
    }

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmQueueEnumeration (
        g_RasTypeId,
        pattern,
        SgmRasConnectionsCallback,
        (ULONG_PTR) 0,
        S_RAS_NAME
        );
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
WINAPI
RasMigVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
RasMigVcmParse (
    IN      PVOID Reserved
    )
{
    return RasMigSgmParse (Reserved);
}

UINT
VcmRasConnectionsCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCTSTR node, nodePtr;
    PTSTR leafPtr;
    PCTSTR rasLines;
    PCTSTR rasValue;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PCTSTR nativeName;
    MIG_OSVERSIONINFO versionInfo;
    BOOL versionOk = FALSE;

    // let's see if we can actually migrate this RAS connection
    if (IsmAcquireObject (Data->ObjectTypeId, Data->ObjectName, &objectContent)) {
        versionOk = IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo);
        rasLines = (PCTSTR) objectContent.MemoryContent.ContentBytes;
        rasValue = pGetRasLineValue (rasLines, TEXT("BaseProtocol"));
        if (rasValue && (StringIMatch (rasValue, TEXT("1")) || StringIMatch (rasValue, TEXT("2")))) {
            IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);

            // now it's a good time to force the migration of the script file
            // if this connection has one
            rasValue = NULL;
            if (versionOk) {
                if (versionInfo.OsType == OSTYPE_WINDOWSNT) {
                    if (versionInfo.OsMajorVersion == OSMAJOR_WINNT4) {
                        rasValue = pGetRasLineValue (rasLines, TEXT("Type"));
                    }
                    if (versionInfo.OsMajorVersion == OSMAJOR_WINNT5) {
                        rasValue = pGetRasLineValue (rasLines, TEXT("Name"));
                    }
                }
                if (versionInfo.OsType == OSTYPE_WINDOWS9X) {
                    rasValue = pGetRasLineValue (rasLines, TEXT("Name"));
                }
            }
            if (rasValue && *rasValue) {
                node = DuplicatePathString (rasValue, 0);
                if (_tcsnextc (node) == TEXT('[')) {
                    nodePtr = _tcsinc (node);
                } else {
                    nodePtr = node;
                }
                leafPtr = _tcsrchr (nodePtr, TEXT('\\'));
                if (leafPtr) {
                    *leafPtr = 0;
                    leafPtr ++;
                    objectName = IsmCreateObjectHandle (nodePtr, leafPtr);
                    if (objectName) {
                        IsmMakePersistentObject (g_FileTypeId, objectName);
                        IsmDestroyObjectHandle (objectName);
                    }
                }
                FreePathString (node);
            }
        } else {
            // this is an unsupported framing protocol
            // we will log a message and abandon this connection
            nativeName = IsmGetNativeObjectName (Data->ObjectTypeId, Data->ObjectName);
            LOG ((LOG_WARNING, (PCSTR) MSG_RASMIG_UNSUPPORTEDSETTINGS, nativeName));
            IsmReleaseMemory (nativeName);
        }
        IsmReleaseObject (&objectContent);
    }
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
RasMigVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    g_PbkFileAttribute = IsmRegisterAttribute (S_PBKFILE_ATTRIBUTE, FALSE);
    MYASSERT (g_PbkFileAttribute);

    // hook all PBK files enumeration, we will not migrate the files but the connections within
    pattern = IsmCreateSimpleObjectPattern (NULL, FALSE, TEXT("*.PBK"), TRUE);

    IsmHookEnumeration (
        g_FileTypeId,
        pattern,
        PbkFilesCallback,
        (ULONG_PTR) 0,
        TEXT("PbkFiles")
        );

    IsmDestroyObjectHandle (pattern);

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmQueueEnumeration (
        g_RasTypeId,
        pattern,
        VcmRasConnectionsCallback,
        (ULONG_PTR) 0,
        S_RAS_NAME
        );
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
PbkRestoreCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    // if this is a PBK file we won't allow it to be restored like a file,
    // we will add the proper connections ourselves.
    return ((!IsmIsAttributeSetOnObjectId (ObjectId, g_PbkFileAttribute)) || g_AllowPbkRestore);
}

BOOL
WINAPI
FilterRasAutoFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    // This function will split the RAS connection, filter the PBK file
    // so we know where it ends up, and rebuild the object name.

    PCTSTR srcFile = NULL;
    PTSTR srcFilePtr = NULL;
    PCTSTR srcConn = NULL;
    MIG_OBJECTSTRINGHANDLE pbkFile = NULL;
    MIG_OBJECTSTRINGHANDLE newPbkFile = NULL;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    PCTSTR newPbkNative = NULL;

    //
    // Filter the object name
    //

    IsmCreateObjectStringsFromHandle (
        InputData->CurrentObject.ObjectName,
        &srcFile,
        &srcConn
        );

    if (srcFile && srcConn) {
        srcFilePtr = _tcsrchr (srcFile, TEXT('\\'));
        if (srcFilePtr) {
            // we know that \ is not a dbcs character so this is safe
            *srcFilePtr = 0;
            srcFilePtr ++;
            pbkFile = IsmCreateObjectHandle (srcFile, srcFilePtr);
            if (pbkFile) {
                g_AllowPbkRestore = TRUE;
                newPbkFile = IsmFilterObject (
                                g_FileTypeId | PLATFORM_SOURCE,
                                pbkFile,
                                NULL,
                                &orgDeleted,
                                &orgReplaced
                                );
                g_AllowPbkRestore = FALSE;
                if (newPbkFile) {
                    newPbkNative = IsmGetNativeObjectName (g_FileTypeId | PLATFORM_SOURCE, newPbkFile);
                    if (newPbkNative) {
                        OutputData->NewObject.ObjectName = IsmCreateObjectHandle (newPbkNative, srcConn);
                        IsmReleaseMemory (newPbkNative);
                        newPbkNative = NULL;
                    }
                    IsmDestroyObjectHandle (newPbkFile);
                    newPbkFile = NULL;
                }
                IsmDestroyObjectHandle (pbkFile);
                pbkFile = NULL;
            }
        }
    }

    IsmDestroyObjectString (srcFile);
    IsmDestroyObjectString (srcConn);

    return TRUE;
}

BOOL
WINAPI
RasMigOpmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    g_PbkFileAttribute = IsmRegisterAttribute (S_PBKFILE_ATTRIBUTE, FALSE);
    MYASSERT (g_PbkFileAttribute);

    IsmRegisterRestoreCallback (PbkRestoreCallback);

    IsmRegisterGlobalFilterCallback (g_RasTypeId | PLATFORM_SOURCE, TEXT("AutoFilter"), FilterRasAutoFilter, TRUE, TRUE);

    return TRUE;
}

BOOL
pEnumRasConnectionWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PRAS_ENUM RasEnum
    )
{
    PCTSTR rasLines;
    PCTSTR connName;
    PCTSTR node, leaf;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        IsmDestroyObjectHandle (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    do {
        IsmCreateObjectStringsFromHandle (RasEnum->HashData.String, &node, &leaf);
        if (RasEnum->HashData.ExtraData) {
            rasLines = *((PCTSTR *) RasEnum->HashData.ExtraData);
            connName = pGetRasLineValue (rasLines, TEXT("ConnectionName"));
            EnumPtr->ObjectName = IsmCreateObjectHandle (node, connName?connName:leaf);
            EnumPtr->NativeObjectName = IsmCreateObjectHandle (node, connName?connName:leaf);
        } else {
            EnumPtr->ObjectName = IsmCreateObjectHandle (node, leaf);
            EnumPtr->NativeObjectName = IsmCreateObjectHandle (node, leaf);
        }
        if (!ObsPatternMatch (RasEnum->Pattern, EnumPtr->ObjectName)) {
            if (!EnumNextHashTableString (&RasEnum->HashData)) {
                AbortEnumRasConnection (EnumPtr);
                return FALSE;
            }
            continue;
        }
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        EnumPtr->Level = 1;
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = TRUE;
        EnumPtr->IsNode = FALSE;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;
        return TRUE;
    } while (TRUE);
}

BOOL
EnumFirstRasConnection (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PRAS_ENUM rasEnum = NULL;

    if (!g_RasTable) {
        return FALSE;
    }
    rasEnum = (PRAS_ENUM) PmGetMemory (g_RasPool, sizeof (RAS_ENUM));
    rasEnum->Pattern = PmDuplicateString (g_RasPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) rasEnum;

    if (EnumFirstHashTableString (&rasEnum->HashData, g_RasTable)) {
        return pEnumRasConnectionWorker (EnumPtr, rasEnum);
    } else {
        AbortEnumRasConnection (EnumPtr);
        return FALSE;
    }
}

BOOL
EnumNextRasConnection (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PRAS_ENUM rasEnum = NULL;

    rasEnum = (PRAS_ENUM)(EnumPtr->EtmHandle);
    if (!rasEnum) {
        return FALSE;
    }
    if (EnumNextHashTableString (&rasEnum->HashData)) {
        return pEnumRasConnectionWorker (EnumPtr, rasEnum);
    } else {
        AbortEnumRasConnection (EnumPtr);
        return FALSE;
    }
}

VOID
AbortEnumRasConnection (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PRAS_ENUM rasEnum = NULL;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        IsmDestroyObjectHandle (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    rasEnum = (PRAS_ENUM)(EnumPtr->EtmHandle);
    if (!rasEnum) {
        return;
    }
    PmReleaseMemory (g_RasPool, rasEnum->Pattern);
    PmReleaseMemory (g_RasPool, rasEnum);
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

BOOL
AcquireRasConnection (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PTSTR rasLines;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        MYASSERT (FALSE);
        return FALSE;
    }

    if (HtFindStringEx (g_RasTable, ObjectName, &rasLines, FALSE)) {

        ObjectContent->MemoryContent.ContentBytes = (PCBYTE) rasLines;
        ObjectContent->MemoryContent.ContentSize = SizeOfMultiSz (rasLines);

        result = TRUE;
    }
    return result;
}

BOOL
ReleaseRasConnection (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    return TRUE;
}

BOOL
DoesRasConnectionExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    HASHTABLE rasTable;
    BOOL result = FALSE;

    if (ObjectName) {

        if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

            rasTable = HtAllocWithData (sizeof (PCTSTR));

            if (rasTable) {

                if (pLoadRasConnections (node, rasTable)) {

                    result = (HtFindStringEx (rasTable, ObjectName, NULL, FALSE) != NULL);
                }

                HtFree (rasTable);
            }

            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        }
    }

    return result;
}

BOOL
RemoveRasConnection (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node, leaf;
    DWORD err = 0;
    BOOL result = FALSE;

    if (g_RasDeleteEntry) {
        if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
            MYASSERT (node);
            MYASSERT (leaf);
            if (node && leaf) {
                err = g_RasDeleteEntry (node, leaf);
                if (err == ERROR_SUCCESS) {
                    result = TRUE;
                }
            }
            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        }
    }
    return result;
}

PCTSTR
pGetNewFileLocation (
    IN      PCTSTR SrcFile
    )
{
    PTSTR node, nodePtr, leaf;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    BOOL deleted;
    BOOL replaced;
    PCTSTR result = NULL;

    node = PmDuplicateString (g_RasPool, SrcFile);
    if (*node) {
        if (_tcsnextc (node) == TEXT('[')) {
            nodePtr = _tcsinc (node);
        } else {
            nodePtr = node;
        }
        leaf = _tcsrchr (nodePtr, TEXT('\\'));
        if (leaf) {
            *leaf = 0;
            leaf++;
            objectName = IsmCreateObjectHandle (nodePtr, leaf);
            PmReleaseMemory (g_RasPool, node);
            newObjectName = IsmFilterObject (
                                g_FileTypeId | PLATFORM_SOURCE,
                                objectName,
                                NULL,
                                &deleted,
                                &replaced
                                );
            if (!deleted || replaced) {
                if (!newObjectName) {
                    newObjectName = objectName;
                }
                if (IsmCreateObjectStringsFromHandle (newObjectName, &node, &leaf)) {
                    result = JoinPaths (node, leaf);
                }
            }
            if (newObjectName && (newObjectName != objectName)) {
                IsmDestroyObjectHandle (newObjectName);
            }
            IsmDestroyObjectHandle (objectName);
        } else {
            PmReleaseMemory (g_RasPool, node);
        }
    } else {
        PmReleaseMemory (g_RasPool, node);
    }
    return result;
}

BOOL
pTrackedCreateDirectory (
    IN      PCTSTR DirName
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR pathCopy;
    PTSTR p;
    BOOL result = TRUE;

    pathCopy = DuplicatePathString (DirName, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == TEXT(':') && pathCopy[2] == TEXT('\\')) {
        //
        // <drive>:\ case
        //

        p = _tcschr (&pathCopy[3], TEXT('\\'));

    } else if (pathCopy[0] == TEXT('\\') && pathCopy[1] == TEXT('\\')) {

        //
        // UNC case
        //

        p = _tcschr (pathCopy + 2, TEXT('\\'));
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
        }

    } else {

        //
        // Relative dir case
        //

        p = _tcschr (pathCopy, TEXT('\\'));
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;

        if (!DoesFileExist (pathCopy)) {

            // record directory creation
            objectName = IsmCreateObjectHandle (pathCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_FileTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            result = CreateDirectory (pathCopy, NULL);
            if (!result) {
                break;
            }
        }

        *p = TEXT('\\');
        p = _tcschr (p + 1, TEXT('\\'));
    }

    FreePathString (pathCopy);

    return result;
}

BOOL
CreateRasConnection (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR rasLines;
    MULTISZ_ENUM multiSzEnum;
    PCTSTR pbkFileName = NULL;
    PCTSTR connName = NULL;
    HANDLE pbkFileHandle = NULL;
    BOOL first = TRUE;
    MIG_OSVERSIONINFO versionInfo;
    BOOL versionOk = FALSE;
    BOOL fileField = FALSE;
    PCTSTR destFileName;
    RASCREDENTIALS rasCredentials;
    BOOL lastVNEmpty = FALSE;
    BOOL result = FALSE;
    WORD oldCodePage;
    PCTSTR newUserProfile = NULL;
    DWORD credResult;

    __try {

        if (ObjectContent->ContentInFile) {
            __leave;
        }

        if (!ObjectContent->MemoryContent.ContentBytes) {
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (ObjectName, &pbkFileName, &connName)) {
            __leave;
        }

        MYASSERT (pbkFileName);
        if (!pbkFileName) {
            __leave;
        }

        MYASSERT (connName);
        if (!connName) {
            __leave;
        }

        if (g_DelayRasOp) {

            // we know that we created a new user (we are in cmd line mode).
            // Let's try to see if this connection belongs to that user.
            // If it does, we are going to delay the creation because
            // we set credentials for the connection, and they need to be
            // set in that user's context.
            // If not, it means that this is a common connection so we are
            // just going to go ahead and add it.

            newUserProfile = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT ("%userprofile%"), NULL);
            if (newUserProfile) {
                if (StringIPrefix (pbkFileName, newUserProfile)) {
                    // we need to delay this operation
                    // record delayed printer replace operation
                    IsmRecordDelayedOperation (
                        JRNOP_CREATE,
                        g_RasTypeId,
                        ObjectName,
                        ObjectContent
                        );
                    result = TRUE;
                    __leave;
                }
                IsmReleaseMemory (newUserProfile);
                newUserProfile = NULL;
            }
        }

        ZeroMemory (&rasCredentials, sizeof (RASCREDENTIALS));
        rasCredentials.dwSize = sizeof (RASCREDENTIALS);

        rasLines = (PCTSTR) ObjectContent->MemoryContent.ContentBytes;

        // record RAS entry creation
        IsmRecordOperation (
            JRNOP_CREATE,
            g_RasTypeId,
            ObjectName
            );

        if (EnumFirstMultiSz (&multiSzEnum, rasLines)) {
            // get the first 8 fields as being part of rasCredentials structure

            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("ConnectionName")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            // we are just skipping the connection name

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("CredMask")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(rasCredentials.dwMask));
            }

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("CredName")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                StringCopyTcharCount (rasCredentials.szUserName, multiSzEnum.CurrentString, UNLEN + 1);
            }

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("CredDomain")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                StringCopyTcharCount (rasCredentials.szDomain, multiSzEnum.CurrentString, DNLEN + 1);
            }

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("CredPassword")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                StringCopyTcharCount (rasCredentials.szPassword, multiSzEnum.CurrentString, PWLEN + 1);
            }

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }

            pbkFileHandle = BfOpenFile (pbkFileName);
            if (!pbkFileHandle) {
                pTrackedCreateDirectory (pbkFileName);
                pbkFileHandle = BfCreateFile (pbkFileName);
            }
            if (!pbkFileHandle) {
                __leave;
            }
            BfGoToEndOfFile (pbkFileHandle, NULL);
            WriteFileString (pbkFileHandle, TEXT("\r\n["));
            // make sure that the conversion is using UTF8
            oldCodePage = SetConversionCodePage (CP_UTF8);
            WriteFileString (pbkFileHandle, connName);
            SetConversionCodePage (oldCodePage);
            WriteFileString (pbkFileHandle, TEXT("]\r\n"));
            first = TRUE;
            versionOk = IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo);
            do {
                if (first) {
                    if (StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        lastVNEmpty = TRUE;
                    } else {
                        lastVNEmpty = FALSE;
                        if (versionOk) {
                            if (versionInfo.OsType == OSTYPE_WINDOWSNT) {
                                if (versionInfo.OsMajorVersion == OSMAJOR_WINNT4) {
                                    fileField = StringIMatch (multiSzEnum.CurrentString, TEXT("Type"));
                                }
                                if (versionInfo.OsMajorVersion == OSMAJOR_WINNT5) {
                                    fileField = StringIMatch (multiSzEnum.CurrentString, TEXT("Name"));
                                }
                            }
                            if (versionInfo.OsType == OSTYPE_WINDOWS9X) {
                                fileField = StringIMatch (multiSzEnum.CurrentString, TEXT("Name"));
                            }
                        }
                        fileField = fileField || StringIMatch (multiSzEnum.CurrentString, TEXT("CustomDialDll"));
                        fileField = fileField || StringIMatch (multiSzEnum.CurrentString, TEXT("CustomRasDialDll"));
                        fileField = fileField || StringIMatch (multiSzEnum.CurrentString, TEXT("PrerequisitePbk"));
                        WriteFileString (pbkFileHandle, multiSzEnum.CurrentString);
                    }
                } else {
                    if (StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        if (!lastVNEmpty) {
                            WriteFileString (pbkFileHandle, TEXT("="));
                        }
                        WriteFileString (pbkFileHandle, TEXT("\r\n"));
                    } else {
                        WriteFileString (pbkFileHandle, TEXT("="));
                        if (fileField) {
                            destFileName = pGetNewFileLocation (multiSzEnum.CurrentString);
                        } else {
                            destFileName = NULL;
                        }
                        if (destFileName) {
                            // make sure that the conversion is using UTF8
                            oldCodePage = SetConversionCodePage (CP_UTF8);
                            WriteFileString (pbkFileHandle, destFileName);
                            SetConversionCodePage (oldCodePage);
                            FreePathString (destFileName);
                            destFileName = NULL;
                        } else {
                            // make sure that the conversion is using UTF8
                            oldCodePage = SetConversionCodePage (CP_UTF8);
                            WriteFileString (pbkFileHandle, multiSzEnum.CurrentString);
                            oldCodePage = SetConversionCodePage (oldCodePage);
                        }
                        WriteFileString (pbkFileHandle, TEXT("\r\n"));
                    }
                    fileField = FALSE;
                }
                first = !first;
            } while (EnumNextMultiSz (&multiSzEnum));
            WriteFileString (pbkFileHandle, TEXT("\r\n"));

            result = TRUE;
        }
        if (pbkFileHandle) {
            CloseHandle (pbkFileHandle);
            pbkFileHandle = NULL;
        }
        if (result) {
            if (g_RasSetCredentials && rasCredentials.dwMask) {
                credResult = g_RasSetCredentials (pbkFileName, connName, &rasCredentials, FALSE);
            }
        }
    }
    __finally {

        IsmDestroyObjectString (pbkFileName);
        IsmDestroyObjectString (connName);
    }

    return result;
}

PCTSTR
ConvertRasConnectionToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    PCTSTR rasLines;
    MULTISZ_ENUM multiSzEnum;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        MYASSERT (leaf);

        g_RasConversionBuff.End = 0;

        if (node) {
            GbCopyQuotedString (&g_RasConversionBuff, node);
        } else {
            GbCopyQuotedString (&g_RasConversionBuff, TEXT(""));
        }

        GbCopyQuotedString (&g_RasConversionBuff, leaf);

        MYASSERT (ObjectContent->Details.DetailsSize == 0);
        MYASSERT (!ObjectContent->ContentInFile);

        if ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentBytes)
            ) {
            rasLines = (PCTSTR)ObjectContent->MemoryContent.ContentBytes;
            if (EnumFirstMultiSz (&multiSzEnum, rasLines)) {
                do {
                    if (StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        GbCopyQuotedString (&g_RasConversionBuff, TEXT(""));
                    } else {
                        GbCopyQuotedString (&g_RasConversionBuff, multiSzEnum.CurrentString);
                    }
                } while (EnumNextMultiSz (&multiSzEnum));
            }
        } else {
            bresult = FALSE;
        }

        if (bresult) {
            GbCopyString (&g_RasConversionBuff, TEXT(""));
            result = IsmGetMemory (g_RasConversionBuff.End);
            CopyMemory (result, g_RasConversionBuff.Buf, g_RasConversionBuff.End);
        }

        g_RasConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToRasConnection (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    MULTISZ_ENUM multiSzEnum;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    UINT index;

    g_RasConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == 0) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                    node = multiSzEnum.CurrentString;
                }
            }
            if (index == 1) {
                leaf = multiSzEnum.CurrentString;
            }
            if (index > 1) {
                if (*multiSzEnum.CurrentString) {
                    GbMultiSzAppend (&g_RasConversionBuff, multiSzEnum.CurrentString);
                } else {
                    GbMultiSzAppend (&g_RasConversionBuff, TEXT("<empty>"));
                }
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }
    GbMultiSzAppend (&g_RasConversionBuff, TEXT(""));

    if (!leaf) {
        GbFree (&g_RasConversionBuff);
        return FALSE;
    }

    if (ObjectContent) {

        if (g_RasConversionBuff.End) {
            ObjectContent->MemoryContent.ContentSize = g_RasConversionBuff.End;
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE)ObjectContent->MemoryContent.ContentBytes,
                g_RasConversionBuff.Buf,
                ObjectContent->MemoryContent.ContentSize
                );
        } else {
            ObjectContent->MemoryContent.ContentSize = 0;
            ObjectContent->MemoryContent.ContentBytes = NULL;
        }
        ObjectContent->Details.DetailsSize = 0;
        ObjectContent->Details.DetailsData = NULL;
    }
    *ObjectName = IsmCreateObjectHandle (node, leaf);

    GbFree (&g_RasConversionBuff);

    return TRUE;
}

PCTSTR
GetNativeRasConnectionName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL;
    UINT size;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (leaf) {
            size = SizeOfString (leaf);
            if (size) {
                result = IsmGetMemory (size);
                CopyMemory (result, leaf, size);
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

PMIG_CONTENT
ConvertRasConnectionContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Ras Connection content
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize * 2);
            if (result->MemoryContent.ContentBytes) {
                DirectDbcsToUnicodeN (
                    (PWSTR)result->MemoryContent.ContentBytes,
                    (PSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfMultiSzW ((PWSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertRasConnectionContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Ras Connection content
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            if (result->MemoryContent.ContentBytes) {
                DirectUnicodeToDbcsN (
                    (PSTR)result->MemoryContent.ContentBytes,
                    (PWSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfMultiSzA ((PSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedRasConnectionContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}




//
// Win9x specific code. Converts registry format into a PBK file
//

//
// AddrEntry serves as a header for the entire block of data in the <entry>
// blob. entries in it are offsets to the strings which follow it..in many cases
// (i.e. all of the *Off* members...)
//
typedef struct  _AddrEntry     {
    DWORD       dwVersion;
    DWORD       dwCountryCode;
    UINT        uOffArea;
    UINT        uOffPhone;
    DWORD       dwCountryID;
    UINT        uOffSMMCfg;
    UINT        uOffSMM;
    UINT        uOffDI;
}   ADDRENTRY, *PADDRENTRY;

typedef struct {
    DWORD Size;
    DWORD Unknown1;
    DWORD ModemUiOptions; // num seconds in high byte.
    DWORD Unknown2;
    DWORD Unknown3;
    DWORD Unknown4;
    DWORD ConnectionSpeed;
    DWORD UnknownFlowControlData; //Somehow related to flow control.
    DWORD Unknown5;
    DWORD Unknown6;
    DWORD Unknown7;
    DWORD Unknown8;
    DWORD Unknown9;
    DWORD Unknown10;
    DWORD Unknown11;
    DWORD Unknown12;
    DWORD Unknown13;
    DWORD Unknown14;
    DWORD Unknown15;
    DWORD CancelSeconds; //Num seconds to wait before cancel if not connected. (0xFF equals off.)
    DWORD IdleDisconnectSeconds; // 0 = Not Set.
    DWORD Unknown16;
    DWORD SpeakerVolume; // 0|1
    DWORD ConfigOptions;
    DWORD Unknown17;
    DWORD Unknown18;
    DWORD Unknown19;
} MODEMDEVINFO, *PMODEMDEVINFO;

typedef struct _SubConnEntry {
    DWORD       dwSize;
    DWORD       dwFlags;
    CHAR        szDeviceType[RAS_MaxDeviceType+1];
    CHAR        szDeviceName[RAS_MaxDeviceName+1];
    CHAR        szLocal[RAS_MaxPhoneNumber+1];
}   SUBCONNENTRY, *PSUBCONNENTRY;

typedef struct  _SMMCFG  {
    DWORD       dwSize;
    DWORD       fdwOptions;
    DWORD       fdwProtocols;
}   SMMCFG, *PSMMCFG;

typedef struct  _DEVICEINFO  {
    DWORD       dwVersion;
    UINT        uSize;
    CHAR        szDeviceName[RAS_MaxDeviceName+1];
    CHAR        szDeviceType[RAS_MaxDeviceType+1];
}   DEVICEINFO, *PDEVICEINFO;

typedef struct _IPData   {
    DWORD     dwSize;
    DWORD     fdwTCPIP;
    DWORD     dwIPAddr;
    DWORD     dwDNSAddr;
    DWORD     dwDNSAddrAlt;
    DWORD     dwWINSAddr;
    DWORD     dwWINSAddrAlt;
}   IPDATA, *PIPDATA;

typedef struct {
    PCTSTR String;
    UINT   Value;
    WORD   DataType;
} MEMDB_RAS_DATA, *PMEMDB_RAS_DATA;

#define PAESMMCFG(pAE)          ((PSMMCFG)(((PBYTE)pAE)+(pAE->uOffSMMCfg)))
#define PAESMM(pAE)             ((PSTR)(((PBYTE)pAE)+(pAE->uOffSMM)))
#define PAEDI(pAE)              ((PDEVICEINFO)(((PBYTE)pAE)+(pAE->uOffDI    )))
#define PAEAREA(pAE)            ((PSTR)(((PBYTE)pAE)+(pAE->uOffArea)))
#define PAEPHONE(pAE)           ((PSTR)(((PBYTE)pAE)+(pAE->uOffPhone)))
#define DECRYPTENTRY(x, y, z)   EnDecryptEntry(x, (LPBYTE)y, z)

#define S_REMOTE_ACCESS_KEY             TEXT("HKCU\\RemoteAccess")
#define S_DIALUI                        TEXT("DialUI")
#define S_ENABLE_REDIAL                 TEXT("EnableRedial")
#define S_REDIAL_TRY                    TEXT("RedialTry")
#define S_REDIAL_WAIT                   TEXT("RedialWait")
#define S_ENABLE_IMPLICIT               TEXT("EnableImplicit")
#define S_PHONE_NUMBER                  TEXT("Phone Number")
#define S_AREA_CODE                     TEXT("Area Code")
#define S_SMM                           TEXT("SMM")
#define S_COUNTRY_CODE                  TEXT("Country Code")
#define S_COUNTRY_ID                    TEXT("Country Id")
#define S_DEVICE_NAME                   TEXT("Device Name")
#define S_DEVICE_TYPE                   TEXT("Device Type")
#define S_PROTOCOLS                     TEXT("Protocols")
#define S_SMM_OPTIONS                   TEXT("SMM Options")
#define S_IPINFO                        TEXT("IP")
#define S_IP_FTCPIP                     TEXT("_IP_FTCPIP")
#define S_IP_IPADDR                     TEXT("IpAddress")
#define S_IP_DNSADDR                    TEXT("IpDnsAddress")
#define S_IP_DNSADDR2                   TEXT("IpDns2Address")
#define S_IP_WINSADDR                   TEXT("IpWinsAddress")
#define S_IP_WINSADDR2                  TEXT("IpWins2Address")
#define S_DOMAIN                        TEXT("Domain")
#define S_USER                          TEXT("User")

#define S_MODEMS                        TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class\\Modem")
#define S_ATTACHEDTO                    TEXT("AttachedTo")
#define S_DRIVERDESC                    TEXT("DriverDesc")
#define S_TERMINAL                      TEXT("Terminal")
#define S_MODE                          TEXT("Mode")
#define S_MULTILINK                     TEXT("MultiLink")

#define S_MODEM                         TEXT("Modem")
#define S_MODEMA                        "Modem"
#define S_MODEM_UI_OPTIONS              TEXT("__UiOptions")
#define S_MODEM_SPEED                   TEXT("__Speed")
#define S_MODEM_SPEAKER_VOLUME          TEXT("__SpeakerVolume")
#define S_MODEM_IDLE_DISCONNECT_SECONDS TEXT("__IdleDisconnect")
#define S_MODEM_CANCEL_SECONDS          TEXT("__CancelSeconds")
#define S_MODEM_CFG_OPTIONS             TEXT("__CfgOptions")
#define S_MODEM_COM_PORT                TEXT("ComPort")
#define S_DEVICECOUNT                   TEXT("__DeviceCount")

#define S_PPP                           TEXT("PPP")
#define S_PPPA                          "PPP"
#define S_SLIP                          TEXT("Slip")
#define S_SLIPA                         "Slip"
#define S_CSLIP                         TEXT("CSlip")
#define S_CSLIPA                        "CSlip"

#define S_SERVICEREMOTEACCESS           TEXT("HKLM\\System\\CurrentControlSet\\Services\\RemoteAccess")
#define S_REMOTE_ACCESS_KEY             TEXT("HKCU\\RemoteAccess")
#define S_PROFILE_KEY                   TEXT("HKCU\\RemoteAccess\\Profile")
#define S_ADDRESSES_KEY                 TEXT("HKCU\\RemoteAccess\\Addresses")
#define S_SUBENTRIES                    TEXT("SubEntries")

#define S_EMPTY                         TEXT("")

#define S_PPPSCRIPT                     TEXT("PPPSCRIPT")

#define MEMDB_CATEGORY_RAS_INFO         TEXT("RAS Info")
#define MEMDB_CATEGORY_RAS_USER         TEXT("RAS User")
#define MEMDB_CATEGORY_RAS_DATA         TEXT("Ras Data")
#define MEMDB_FIELD_USER_SETTINGS       TEXT("User Settings")

#define RASTYPE_PHONE 1
#define RASTYPE_VPN 2

#define S_VPN TEXT("VPN")
#define S_ZERO TEXT("0")
#define S_ONE TEXT("1")

#define SMMCFG_SW_COMPRESSION       0x00000001  // Software compression is on
#define SMMCFG_PW_ENCRYPTED         0x00000002  // Encrypted password only
#define SMMCFG_NW_LOGON             0x00000004  // Logon to the network

// Negotiated protocols
//
#define SMMPROT_NB                  0x00000001  // NetBEUI
#define SMMPROT_IPX                 0x00000002  // IPX
#define SMMPROT_IP                  0x00000004  // TCP/IP

#define IPF_IP_SPECIFIED    0x00000001
#define IPF_NAME_SPECIFIED  0x00000002
#define IPF_NO_COMPRESS     0x00000004
#define IPF_NO_WAN_PRI      0x00000008

#define RAS_UI_FLAG_TERMBEFOREDIAL      0x1
#define RAS_UI_FLAG_TERMAFTERDIAL       0x2
#define RAS_UI_FLAG_OPERATORASSISTED    0x4
#define RAS_UI_FLAG_MODEMSTATUS         0x8

#define RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL  0x00000010
#define RAS_CFG_FLAG_SOFTWARE_FLOW_CONTROL  0x00000020
#define RAS_CFG_FLAG_STANDARD_EMULATION     0x00000040
#define RAS_CFG_FLAG_COMPRESS_DATA          0x00000001
#define RAS_CFG_FLAG_USE_ERROR_CONTROL      0x00000002
#define RAS_CFG_FLAG_ERROR_CONTROL_REQUIRED 0x00000004
#define RAS_CFG_FLAG_USE_CELLULAR_PROTOCOL  0x00000008
#define RAS_CFG_FLAG_NO_WAIT_FOR_DIALTONE   0x00000200

#define DIALUI_DONT_PROMPT_FOR_INFO         0x01
#define DIALUI_DONT_SHOW_ICON               0x04


//
// For each entry, the following basic information is stored.
//
#define ENTRY_SETTINGS                              \
    FUNSETTING(CredMask)                            \
    FUNSETTING(CredName)                            \
    FUNSETTING(CredDomain)                          \
    FUNSETTING(CredPassword)                        \
    STRSETTING(Encoding,S_ONE)                      \
    FUNSETTING(Type)                                \
    STRSETTING(Autologon,S_ZERO)                    \
    STRSETTING(DialParamsUID,S_EMPTY)               \
    STRSETTING(Guid,S_EMPTY)                        \
    STRSETTING(UsePwForNetwork,S_EMPTY)             \
    STRSETTING(ServerType,S_EMPTY)                  \
    FUNSETTING(BaseProtocol)                        \
    FUNSETTING(VpnStrategy)                         \
    STRSETTING(Authentication,S_EMPTY)              \
    FUNSETTING(ExcludedProtocols)                   \
    STRSETTING(LcpExtensions,S_ONE)                 \
    FUNSETTING(DataEncryption)                      \
    STRSETTING(SkipNwcWarning,S_EMPTY)              \
    STRSETTING(SkipDownLevelDialog,S_EMPTY)         \
    FUNSETTING(SwCompression)                       \
    FUNSETTING(ShowMonitorIconInTaskBar)            \
    STRSETTING(CustomAuthKey,S_EMPTY)               \
    STRSETTING(CustomAuthData,S_EMPTY)              \
    FUNSETTING(AuthRestrictions)                    \
    STRSETTING(OverridePref,TEXT("15"))             \
    STRSETTING(DialMode,S_EMPTY)                    \
    STRSETTING(DialPercent,S_EMPTY)                 \
    STRSETTING(DialSeconds,S_EMPTY)                 \
    STRSETTING(HangUpPercent,S_EMPTY)               \
    STRSETTING(HangUpSeconds,S_EMPTY)               \
    FUNSETTING(RedialAttempts)                      \
    FUNSETTING(RedialSeconds)                       \
    FUNSETTING(IdleDisconnectSeconds)               \
    STRSETTING(RedialOnLinkFailure,S_EMPTY)         \
    STRSETTING(CallBackMode,S_EMPTY)                \
    STRSETTING(CustomDialDll,S_EMPTY)               \
    STRSETTING(CustomDialFunc,S_EMPTY)              \
    STRSETTING(AuthenticateServer,S_EMPTY)          \
    STRSETTING(SecureLocalFiels,S_EMPTY)            \
    STRSETTING(ShareMsFilePrint,S_EMPTY)            \
    STRSETTING(BindMsNetClient,S_EMPTY)             \
    STRSETTING(SharedPhoneNumbers,S_EMPTY)          \
    STRSETTING(PrerequisiteEntry,S_EMPTY)           \
    FUNSETTING(PreviewUserPw)                       \
    FUNSETTING(PreviewDomain)                       \
    FUNSETTING(PreviewPhoneNumber)                  \
    STRSETTING(ShowDialingProgress,S_ONE)           \
    FUNSETTING(IpPrioritizeRemote)                  \
    FUNSETTING(IpHeaderCompression)                 \
    FUNSETTING(IpAddress)                           \
    FUNSETTING(IpAssign)                            \
    FUNSETTING(IpDnsAddress)                        \
    FUNSETTING(IpDns2Address)                       \
    FUNSETTING(IpWINSAddress)                       \
    FUNSETTING(IpWINS2Address)                      \
    FUNSETTING(IpNameAssign)                        \
    STRSETTING(IpFrameSize,S_EMPTY)                 \

//
// There can be multiple media sections for each entry.
//
#define MEDIA_SETTINGS                              \
    FUNSETTING(MEDIA)                               \
    FUNSETTING(Port)                                \
    FUNSETTING(Device)                              \
    FUNSETTING(ConnectBps)                          \

//
// There can be multiple device sections for each entry.
//
#define SWITCH_DEVICE_SETTINGS                      \
    FUNSETTING(DEVICE)                              \
    FUNSETTING(Name)                                \
    FUNSETTING(Terminal)                            \
    FUNSETTING(Script)                              \

#define MODEM_DEVICE_SETTINGS                       \
    FUNSETTING(DEVICE)                              \
    FUNSETTING(PhoneNumber)                         \
    FUNSETTING(AreaCode)                            \
    FUNSETTING(CountryCode)                         \
    FUNSETTING(CountryID)                           \
    FUNSETTING(UseDialingRules)                     \
    STRSETTING(Comment,S_EMPTY)                     \
    STRSETTING(LastSelectedPhone,S_EMPTY)           \
    STRSETTING(PromoteAlternates,S_EMPTY)           \
    STRSETTING(TryNextAlternateOnFail,S_EMPTY)      \
    FUNSETTING(HwFlowControl)                       \
    FUNSETTING(Protocol)                            \
    FUNSETTING(Compression)                         \
    FUNSETTING(Speaker)                             \

#define PAD_DEVICE_SETTINGS                         \
    STRSETTING(X25Pad,S_EMPTY)                      \
    STRSETTING(X25Address,S_EMPTY)                  \
    STRSETTING(UserData,S_EMPTY)                    \
    STRSETTING(Facilities,S_EMPTY)                  \

#define ISDN_DEVICE_SETTINGS                        \
    FUNSETTING(PhoneNumber)                         \
    FUNSETTING(AreaCode)                            \
    FUNSETTING(CountryCode)                         \
    FUNSETTING(CountryID)                           \
    FUNSETTING(UseDialingRules)                     \
    STRSETTING(Comment,S_EMPTY)                     \
    STRSETTING(LastSelectedPhone,S_EMPTY)           \
    STRSETTING(PromoteAlternates,S_EMPTY)           \
    STRSETTING(TryNextAlternateOnFail,S_EMPTY)      \
    STRSETTING(LineType,S_EMPTY)                    \
    STRSETTING(FallBack,S_EMPTY)                    \
    STRSETTING(EnableCompressiong,S_EMPTY)          \
    STRSETTING(ChannelAggregation,S_EMPTY)          \

#define X25_DEVICE_SETTINGS                         \
    STRSETTING(X25Address,S_EMPTY)                  \
    STRSETTING(UserData,S_EMPTY)                    \
    STRSETTING(Facilities,S_EMPTY)                  \

//
// Function prototypes.
//
typedef PCTSTR (DATA_FUNCTION_PROTOTYPE)(VOID);
typedef DATA_FUNCTION_PROTOTYPE * DATA_FUNCTION;

#define FUNSETTING(Data) DATA_FUNCTION_PROTOTYPE pGet##Data;
#define STRSETTING(x,y)

ENTRY_SETTINGS
MEDIA_SETTINGS
SWITCH_DEVICE_SETTINGS
MODEM_DEVICE_SETTINGS
PAD_DEVICE_SETTINGS
ISDN_DEVICE_SETTINGS
X25_DEVICE_SETTINGS

#undef FUNSETTING
#undef STRSETTING

#define FUNSETTING(x) {TEXT(#x), pGet##x, NULL},
#define STRSETTING(x,y) {TEXT(#x), NULL, y},
#define LASTSETTING {NULL,NULL,NULL}

typedef struct {
    PCTSTR SettingName;
    DATA_FUNCTION SettingFunction;
    PCTSTR SettingValue;
} RAS_SETTING, * PRAS_SETTING;


RAS_SETTING g_EntrySettings[] = {ENTRY_SETTINGS LASTSETTING};
RAS_SETTING g_MediaSettings[] = {MEDIA_SETTINGS LASTSETTING};
RAS_SETTING g_SwitchDeviceSettings[] = {SWITCH_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_ModemDeviceSettings[] = {MODEM_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_PadDeviceSettings[] = {PAD_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_IsdnDeviceSettings[] = {ISDN_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_X25DeviceSettings[] = {X25_DEVICE_SETTINGS LASTSETTING};

BOOL g_InSwitchSection = FALSE;
PCTSTR g_CurrentConnection = NULL;
UINT g_CurrentDevice = 0;
UINT g_CurrentDeviceType = 0;
#define RAS_BUFFER_SIZE MEMDB_MAX
TCHAR g_TempBuffer [RAS_BUFFER_SIZE];
HASHTABLE  g_DeviceTable = NULL;


BOOL
pIs9xRasInstalled (
    void
    )
{
    HKEY testKey = NULL;
    BOOL rf = FALSE;

    testKey = OpenRegKeyStr (S_SERVICEREMOTEACCESS);

    if (testKey) {
        //
        // Open key succeeded. Assume RAS is installed.
        //
        rf = TRUE;
        CloseRegKey(testKey);
    }

    return rf;
}

static BYTE NEAR PASCAL GenerateEncryptKey (LPCSTR szKey)
{
    BYTE   bKey;
    LPBYTE lpKey;

    for (bKey = 0, lpKey = (LPBYTE)szKey; *lpKey != 0; lpKey++)
    {
        bKey += *lpKey;
    };

    return bKey;
}

DWORD NEAR PASCAL EnDecryptEntry (LPCSTR szEntry, LPBYTE lpEnt,
                                  DWORD cb)
{
    BYTE   bKey;

    // Generate the encryption key from the entry name
    bKey = GenerateEncryptKey(szEntry);

    // Encrypt the address entry one byte at a time
    for (;cb > 0; cb--, lpEnt++)
    {
        *lpEnt ^= bKey;
    };
    return ERROR_SUCCESS;
}

PTSTR
pGetComPort (
    IN PCTSTR DriverDesc
    )
{
    PTSTR rPort = NULL;

    if (!HtFindStringEx (g_DeviceTable, DriverDesc, &rPort, FALSE)) {
        DEBUGMSG ((DBG_WARNING, "Could not find com port for device %s."));
    }

    if (!rPort) {
        rPort = S_EMPTY;
    }

    return rPort;
}

VOID
pInitializeDeviceTable (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE encodedRegPattern;
    REGTREE_ENUM e;
    PTSTR com;
    PTSTR desc;
    PTSTR p;

    encodedRegPattern = IsmCreateSimpleObjectPattern (S_MODEMS, TRUE, TEXT("*"), TRUE);

    if (EnumFirstRegObjectInTreeEx (
            &e,
            encodedRegPattern,
            TRUE,
            TRUE,
            TRUE,
            TRUE,
            1,
            FALSE,
            TRUE,
            RegEnumDefaultCallback
            )) {
        do {
            // we don't care about value names, we only want subkeys
            if (!e.CurrentValueData) {
                com = desc = NULL;
                com = GetRegValueString (e.CurrentKeyHandle, S_ATTACHEDTO);
                desc = GetRegValueString (e.CurrentKeyHandle, S_DRIVERDESC);

                if (com && desc) {
                    p = PmDuplicateString (g_RasPool, com);

                    HtAddStringEx (g_DeviceTable, desc, (PBYTE) &p, FALSE);

                    DEBUGMSG ((DBG_RASMIG, "%s on %s added to driver table.", desc, com));
                }

                if (com) {
                    MemFree (g_hHeap, 0, com);
                }
                if (desc) {
                    MemFree (g_hHeap, 0, desc);
                }
            }
        } while (EnumNextRegObjectInTree (&e));
    }

    //
    // Clean up resources.
    //
    IsmDestroyObjectHandle (encodedRegPattern);
}

BOOL
pGetPerUserSettings (
    VOID
    )
{
    HKEY settingsKey;
    PDWORD data;
    PCTSTR entryStr;
    BOOL rSuccess = TRUE;

    settingsKey = OpenRegKeyStr (S_REMOTE_ACCESS_KEY);

    if (settingsKey) {

        //
        // Get UI settings.
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_DIALUI);

        //
        // Save Dial User Interface info into memdb for this user.
        //
        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_DIALUI, NULL));

            rSuccess &= (MemDbSetValue (entryStr, *data) != 0);

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user UI settings found for current user."));

        //
        // Get Redial information.
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_ENABLE_REDIAL);

        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_ENABLE_REDIAL, NULL));

            rSuccess &= (MemDbSetValue (entryStr, *data) != 0);

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user redial information found for current user."));

        data = (PDWORD) GetRegValueBinary (settingsKey, S_REDIAL_TRY);

        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_REDIAL_TRY, NULL));

            rSuccess &= (MemDbSetValue (entryStr, *data) != 0);

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user redial information found for current user."));

        data = (PDWORD) GetRegValueBinary (settingsKey, S_REDIAL_WAIT);

        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_REDIAL_WAIT, NULL));

            rSuccess &= (MemDbSetValue (entryStr, HIWORD(*data) * 60 + LOWORD(*data)) != 0);

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user redial information found for current user."));

        //
        // Get implicit connection information. (Controls wether connection ui should be displayed or not)
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_ENABLE_IMPLICIT);

        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_ENABLE_IMPLICIT, NULL));

            rSuccess &= (MemDbSetValue (entryStr, *data) != 0);

            MemFree(g_hHeap,0,data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user implicit connection information found for current user."));

        CloseRegKey(settingsKey);
    }

    return rSuccess;
}

VOID
pSaveConnectionDataToMemDb (
    IN PCTSTR Entry,
    IN PCTSTR ValueName,
    IN DWORD  ValueType,
    IN PBYTE  Value
    )
{
    KEYHANDLE keyHandle;
    PCTSTR entryStr;
    PCTSTR entryTmp;

    entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_INFO, Entry, ValueName, NULL));

    switch (ValueType) {
        case REG_SZ:
        case REG_MULTI_SZ:
        case REG_EXPAND_SZ:
            DEBUGMSG ((DBG_RASMIG, "String Data - %s = %s", ValueName, (PCTSTR) Value));

            entryTmp = JoinPaths (MEMDB_CATEGORY_RAS_DATA, (PCTSTR) Value);

            keyHandle = MemDbSetKey (entryTmp);

            if (!keyHandle) {
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }

            FreePathString (entryTmp);

            if (!MemDbSetValueAndFlagsEx (entryStr, TRUE, keyHandle, TRUE, REG_SZ, 0)) {
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }

            break;

        case REG_DWORD:

            DEBUGMSG ((DBG_RASMIG, "DWORD Data - %s = %u", ValueName, (DWORD)(ULONG_PTR) Value));

            if (!MemDbSetValueAndFlagsEx (entryStr, TRUE, (DWORD)(ULONG_PTR) Value, TRUE, ValueType, 0)) {
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }

            break;

        case REG_BINARY:

            DEBUGMSG ((DBG_RASMIG, "Binary data for %s.", ValueName));

            if (StringIMatch (S_IPINFO, ValueName)) {

                //
                // Save IP address information.
                //
                pSaveConnectionDataToMemDb (Entry, S_IP_FTCPIP, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> fdwTCPIP);
                pSaveConnectionDataToMemDb (Entry, S_IP_IPADDR, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwIPAddr);
                pSaveConnectionDataToMemDb (Entry, S_IP_DNSADDR, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwDNSAddr);
                pSaveConnectionDataToMemDb (Entry, S_IP_DNSADDR2, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwDNSAddrAlt);
                pSaveConnectionDataToMemDb (Entry, S_IP_WINSADDR, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwWINSAddr);
                pSaveConnectionDataToMemDb (Entry, S_IP_WINSADDR2, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwWINSAddrAlt);

            } else if (StringIMatch (S_TERMINAL, ValueName)) {

                //
                // save information on the showcmd state. This will tell us how to set the ui display.
                //
                pSaveConnectionDataToMemDb (Entry, ValueName, REG_DWORD, (PBYTE)(ULONG_PTR)((PWINDOWPLACEMENT) Value) -> showCmd);

            } else if (StringIMatch (S_MODE, ValueName)) {

                //
                // This value tells what to do with scripting.
                //
                pSaveConnectionDataToMemDb (Entry, ValueName, REG_DWORD, (PBYTE)(ULONG_PTR) *((PDWORD) Value));

            } else if (StringIMatch (S_MULTILINK, ValueName)) {

                //
                //  Save wether or not multilink is enabled.
                //
                pSaveConnectionDataToMemDb (Entry, ValueName, REG_DWORD,(PBYTE)(ULONG_PTR) *((PDWORD) Value));

            } ELSE_DEBUGMSG ((DBG_WARNING, "Don't know how to handle binary data %s. It will be ignored.", ValueName));

            break;

        default:
            DEBUGMSG ((DBG_WHOOPS, "Unknown type of registry data found in RAS settings. %s", ValueName));
            break;
    }

    FreePathString (entryStr);
}

BOOL
pGetRasEntryAddressInfo (
    IN PCTSTR KeyName,
    IN PCTSTR EntryName
    )
{
    BOOL rSuccess = TRUE;

    MIG_OBJECTSTRINGHANDLE encodedRegPattern;
    MIG_OBJECTSTRINGHANDLE encodedSubPattern;
    PBYTE           data = NULL;
    UINT            count = 0;
    UINT            type  = 0;
    PADDRENTRY      entry;
    PSUBCONNENTRY   subEntry;
    PSMMCFG         smmCfg;
    PDEVICEINFO     devInfo;
    REGTREE_ENUM    e;
    PTSTR           subEntriesKeyStr;
    UINT            sequencer = 0;
    REGTREE_ENUM    eSubEntries;
    TCHAR           buffer[MAX_TCHAR_PATH];
    PMODEMDEVINFO   modemInfo;
#ifdef UNICODE
    PCSTR tempStr = NULL;
    PCWSTR tempStrW = NULL;
#endif

    //
    // First we have to get the real entry name. It must match exactly even case. Unfortunately, it isn't neccessarily a given
    // that the case between HKCU\RemoteAccess\Profiles\<Foo> and HKCU\RemoteAccess\Addresses\[Foo] is the same. The registry
    // apis will of course work fine because they work case insensitively. However, I will be unable to decrypt the value
    // if I use the wrong name.
    //


    encodedRegPattern = IsmCreateSimpleObjectPattern (KeyName, FALSE, TEXT("*"), TRUE);

    if (EnumFirstRegObjectInTreeEx (
            &e,
            encodedRegPattern,
            TRUE,
            TRUE,
            TRUE,
            TRUE,
            REGENUM_ALL_SUBLEVELS,
            FALSE,
            TRUE,
            RegEnumDefaultCallback
            )) {
        do {
            if (StringIMatch (e.Name, EntryName)) {

                //
                // Found the correct entry. Use it.
                //
                data = e.CurrentValueData;

                if (data) {

                    entry   = (PADDRENTRY) data;

#ifdef UNICODE
                    tempStr = ConvertWtoA (e.Name);
                    DECRYPTENTRY(tempStr, entry, e.CurrentValueDataSize);
                    FreeConvertedStr (tempStr);
#else
                    DECRYPTENTRY(e.Name, entry, e.CurrentValueDataSize);
#endif

                    smmCfg  = PAESMMCFG(entry);
                    devInfo = PAEDI(entry);

                    pSaveConnectionDataToMemDb (EntryName, S_PHONE_NUMBER, REG_SZ, (PBYTE) PAEPHONE(entry));
                    pSaveConnectionDataToMemDb (EntryName, S_AREA_CODE, REG_SZ, (PBYTE) PAEAREA(entry));
                    pSaveConnectionDataToMemDb (EntryName, S_SMM, REG_SZ, (PBYTE) PAESMM(entry));
                    pSaveConnectionDataToMemDb (EntryName, S_COUNTRY_CODE, REG_DWORD, (PBYTE)(ULONG_PTR) entry -> dwCountryCode);
                    pSaveConnectionDataToMemDb (EntryName, S_COUNTRY_ID, REG_DWORD, (PBYTE)(ULONG_PTR) entry -> dwCountryID);
                    pSaveConnectionDataToMemDb (EntryName, S_DEVICE_NAME, REG_SZ, (PBYTE) devInfo -> szDeviceName);
                    pSaveConnectionDataToMemDb (EntryName, S_DEVICE_TYPE, REG_SZ, (PBYTE) devInfo -> szDeviceType);
                    pSaveConnectionDataToMemDb (EntryName, S_PROTOCOLS, REG_DWORD, (PBYTE)(ULONG_PTR) smmCfg -> fdwProtocols);
                    pSaveConnectionDataToMemDb (EntryName, S_SMM_OPTIONS, REG_DWORD, (PBYTE)(ULONG_PTR) smmCfg -> fdwOptions);

                    //
                    // Save device information away.
                    //
                    if (StringIMatchA (devInfo -> szDeviceType, S_MODEMA)) {

                        modemInfo = (PMODEMDEVINFO) (devInfo->szDeviceType + RAS_MaxDeviceType + 3);

                        if (modemInfo -> Size >= sizeof (MODEMDEVINFO)) {
                            DEBUGMSG_IF ((modemInfo -> Size > sizeof (MODEMDEVINFO), DBG_RASMIG, "Structure size larger than our known size."));

                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_UI_OPTIONS, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> ModemUiOptions);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_SPEED, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> ConnectionSpeed);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_SPEAKER_VOLUME, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> SpeakerVolume);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_IDLE_DISCONNECT_SECONDS, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> IdleDisconnectSeconds);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_CANCEL_SECONDS, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> CancelSeconds);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_CFG_OPTIONS, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> ConfigOptions);
#ifdef UNICODE
                            tempStrW = ConvertAtoW (devInfo->szDeviceName);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_COM_PORT, REG_SZ, (PBYTE) pGetComPort (tempStrW));
                            FreeConvertedStr (tempStrW);
#else
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_COM_PORT, REG_SZ, (PBYTE) pGetComPort (devInfo->szDeviceName));
#endif

                        }
                        ELSE_DEBUGMSG ((DBG_WHOOPS, "No modem configuration data saved. Size smaller than known structure. Investigate."));
                    }

                    //
                    // If SMM is not SLIP, CSLIP or PPP, we need to add a message to the upgrade report.
                    //
                    if (!StringIMatchA (PAESMM(entry), S_SLIPA) && !StringIMatchA (PAESMM(entry), S_PPPA) && !StringIMatchA (PAESMM(entry), S_CSLIPA)) {
                        LOG ((LOG_WARNING, (PCSTR) MSG_RASMIG_UNSUPPORTEDSETTINGS, EntryName));
                    }
                }

                //
                // Check to see if there are any sub-entries for this connection (MULTILINK settings..)
                //
                //
                // Luckily, we don't have to do the same enumeration of these entries as we had to above to get around
                // the case sensitivity bug. the 9x code uses the address key name above for encryption/decryption.
                //

                subEntriesKeyStr = JoinPathsInPoolEx ((NULL, KeyName, S_SUBENTRIES, e.Name, NULL));
                sequencer = 1;

                encodedSubPattern = IsmCreateSimpleObjectPattern (subEntriesKeyStr, FALSE, TEXT("*"), TRUE);

                if (EnumFirstRegObjectInTreeEx (
                        &eSubEntries,
                        encodedSubPattern,
                        TRUE,
                        TRUE,
                        TRUE,
                        TRUE,
                        REGENUM_ALL_SUBLEVELS,
                        FALSE,
                        TRUE,
                        RegEnumDefaultCallback
                        )) {
                    do {

                        DEBUGMSG ((DBG_RASMIG, "Multi-Link Subentries found for entry %s. Processing.", e.Name));

                        data = eSubEntries.CurrentValueData;

                        if (data) {

                            subEntry = (PSUBCONNENTRY) data;
#ifdef UNICODE
                            tempStr = ConvertWtoA (e.Name);
                            DECRYPTENTRY (tempStr, subEntry, eSubEntries.CurrentValueDataSize);
                            FreeConvertedStr (tempStr);
#else
                            DECRYPTENTRY (e.Name, subEntry, eSubEntries.CurrentValueDataSize);
#endif
                            wsprintf (buffer, TEXT("ml%d%s"), sequencer, S_DEVICE_TYPE);
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) subEntry->szDeviceType);

                            wsprintf (buffer, TEXT("ml%d%s"), sequencer, S_DEVICE_NAME);
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) subEntry->szDeviceName);

                            wsprintf (buffer, TEXT("ml%d%s"), sequencer, S_PHONE_NUMBER);
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) subEntry->szLocal);

                            wsprintf (buffer, TEXT("ml%d%s"), sequencer, S_MODEM_COM_PORT);
#ifdef UNICODE
                            tempStrW = ConvertAtoW (subEntry->szDeviceName);
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) pGetComPort (tempStrW));
                            FreeConvertedStr (tempStrW);
#else
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) pGetComPort (subEntry->szDeviceName));
#endif
                        }

                        sequencer++;

                    } while (EnumNextRegObjectInTree (&eSubEntries));
                }

                IsmDestroyObjectHandle (encodedSubPattern);
                FreePathString (subEntriesKeyStr);

                //
                // Save away the number of devices associated with this connection
                //
                pSaveConnectionDataToMemDb (EntryName, S_DEVICECOUNT, REG_DWORD, (PBYTE)(ULONG_PTR) sequencer);

                //
                // We're done. Break out of the enumeration.
                //
                AbortRegObjectInTreeEnum (&e);
                break;
            }

        } while (EnumNextRegObjectInTree (&e));
    }

    IsmDestroyObjectHandle (encodedRegPattern);

    return rSuccess;
}

BOOL
pGetRasEntrySettings (
    IN PCTSTR KeyName,
    IN PCTSTR EntryName
    )
{
    REGTREE_ENUM e;
    MIG_OBJECTSTRINGHANDLE encodedRegPattern;
    PBYTE curData = NULL;
    BOOL rSuccess = TRUE;

    encodedRegPattern = IsmCreateSimpleObjectPattern (KeyName, FALSE, TEXT("*"), TRUE);

    if (EnumFirstRegObjectInTreeEx (
            &e,
            encodedRegPattern,
            TRUE,
            TRUE,
            TRUE,
            TRUE,
            REGENUM_ALL_SUBLEVELS,
            FALSE,
            TRUE,
            RegEnumDefaultCallback
            )) {
        do {
            if (e.CurrentValueData) {
                pSaveConnectionDataToMemDb (
                        EntryName,
                        e.Name,
                        e.CurrentValueType,
                        e.CurrentValueType == REG_DWORD ? (PBYTE)(ULONG_PTR) (*((PDWORD)e.CurrentValueData)) : e.CurrentValueData
                        );
            }
        } while (EnumNextRegObjectInTree (&e));
    }

    IsmDestroyObjectHandle (encodedRegPattern);

    return rSuccess;
}

BOOL
pGetPerConnectionSettings (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE encodedRegPattern;
    REGTREE_ENUM e;
    PCTSTR entryKey = NULL;
    BOOL rSuccess = TRUE;

    encodedRegPattern = IsmCreateSimpleObjectPattern (S_ADDRESSES_KEY, FALSE, TEXT("*"), TRUE);

    //
    // Enumerate each entry for this user.
    //
    if (EnumFirstRegObjectInTreeEx (
            &e,
            encodedRegPattern,
            TRUE,
            TRUE,
            TRUE,
            TRUE,
            REGENUM_ALL_SUBLEVELS,
            FALSE,
            TRUE,
            RegEnumDefaultCallback
            )) {
        do {
            //
            // Get base connection info -- stored as binary blob under address key.
            // All connections will have this info -- It contains such things
            // as the phone number, area code, dialing rules, etc.. It does
            // not matter wether the connection has been used or not.
            //
            rSuccess &= pGetRasEntryAddressInfo (S_ADDRESSES_KEY, e.Name);

            //
            // Under the profile key are negotiated options for the connection.
            // This key will only exist if the entry has actually been connected
            // to by the user.
            //
            entryKey = JoinPaths (S_PROFILE_KEY, e.Name);

            if (entryKey) {
                rSuccess &= pGetRasEntrySettings (entryKey, e.Name);
                FreePathString (entryKey);
            }

        } while (EnumNextRegObjectInTree (&e));
    }

    //
    // Clean up resources.
    //
    IsmDestroyObjectHandle (encodedRegPattern);

    return rSuccess;
}

BOOL
pGetRasDataFromMemDb (
    IN      PCTSTR DataName,
    OUT     PMEMDB_RAS_DATA Data
    )
{
    BOOL rSuccess = FALSE;
    PCTSTR key;
    DWORD value;
    DWORD flags;
    PCTSTR tempBuffer;

    MYASSERT(DataName && Data && g_CurrentConnection);

    key = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_INFO, g_CurrentConnection, DataName, NULL));
    rSuccess = MemDbGetValueAndFlags (key, &value, &flags);
    FreePathString (key);

    //
    // If that wasn't successful, we need to look in the per-user settings.
    //
    if (!rSuccess) {
        key = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, DataName, NULL));
        rSuccess = MemDbGetValueAndFlags (key, &value, &flags);
        flags = REG_DWORD;
    }

    if (rSuccess) {
        //
        // There is information stored here. Fill it in and send it back to the user.
        //
        if (flags == REG_SZ) {

            //
            // String data, the value points to the offset for the string.
            //
            tempBuffer = MemDbGetKeyFromHandle (value, 1);
            if (!tempBuffer) {
                DEBUGMSG ((
                    DBG_ERROR,
                    "Could not retrieve RAS string information stored in Memdb. Entry=%s,Setting=%s",
                    g_CurrentConnection,
                    DataName
                    ));
                 return FALSE;
            }

            Data -> String = PmDuplicateString (g_RasPool, tempBuffer);
            MemDbReleaseMemory (tempBuffer);
        }
        else {

            //
            // Not string data. The data is stored as the value.
            //
            Data -> Value = value;

        }

        Data -> DataType = (WORD) flags;

    }

    return rSuccess;
}

BOOL
pWritePhoneBookLine (
    IN HANDLE FileHandle,
    IN PCTSTR SettingName,
    IN PCTSTR SettingValue
    )
{
    BOOL rSuccess = TRUE;

    rSuccess &= WriteFileString (FileHandle, SettingName);
    rSuccess &= WriteFileString (FileHandle, TEXT("="));
    rSuccess &= WriteFileString (FileHandle, SettingValue ? SettingValue : S_EMPTY);
    rSuccess &= WriteFileString (FileHandle, TEXT("\r\n"));

    return rSuccess;
}

BOOL
pWriteSettings (
    IN      HANDLE FileHandle,
    IN      PRAS_SETTING SettingList
    )
{

    BOOL rSuccess = TRUE;

    while (SettingList->SettingName) {
        rSuccess &= pWritePhoneBookLine (
            FileHandle,
            SettingList->SettingName,
            SettingList->SettingValue ?
                SettingList->SettingValue :
                SettingList->SettingFunction ());

        SettingList++;
    }

    return rSuccess;
}

PCTSTR
pGetSpeaker (
    VOID
    )
{

    MEMDB_RAS_DATA d;

    if (g_CurrentDevice) {
        return S_ONE;
    }

    if (!pGetRasDataFromMemDb (S_MODEM_SPEAKER_VOLUME, &d)) {
        return S_ONE;
    }

    if (d.Value) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDevice) {
        return S_EMPTY;
    }

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_EMPTY;
    }

    if (d.Value & RAS_CFG_FLAG_COMPRESS_DATA) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetProtocol (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDevice) {
        return S_EMPTY;
    }

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_EMPTY;
    }

    if (d.Value & RAS_CFG_FLAG_USE_ERROR_CONTROL) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetHwFlowControl (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDevice) {
        return S_EMPTY;
    }

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_EMPTY;
    }

    if (d.Value & RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetUseDialingRules (
    VOID
    )
{
    MEMDB_RAS_DATA d;
    //
    // Win9x sets the areacode, countrycode, countryid to zero if
    // use dialing rules is disabled. For ease, we test off of country
    // code. If we can't get it, or, it is set to zero, we assume
    // that we should _not_ use dialing rules.
    //
    if (!pGetRasDataFromMemDb(S_COUNTRY_CODE, &d) || !d.Value) {
        return S_ZERO;
    }

    return S_ONE;
}

PCTSTR
pGetCountryID (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_COUNTRY_ID, &d) || !d.Value) {
        return S_EMPTY;
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetCountryCode (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb(S_COUNTRY_CODE, &d) || !d.Value) {
        return S_EMPTY;
    }
    wsprintf(g_TempBuffer,TEXT("%d"),d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetAreaCode (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb(S_AREA_CODE, &d)) {
        return S_EMPTY;
    }



    return d.String;
}

PCTSTR
pGetPhoneNumber (
    VOID
    )
{
    MEMDB_RAS_DATA d;
    TCHAR buffer[MAX_TCHAR_PATH];

    if (g_CurrentDevice == 0) {
        if (!pGetRasDataFromMemDb(S_PHONE_NUMBER, &d)) {
            return S_EMPTY;
        }
    }
    else {

        wsprintf(buffer,TEXT("ml%d%s"),g_CurrentDevice,S_PHONE_NUMBER);
        if (!pGetRasDataFromMemDb(buffer, &d)) {
            return S_EMPTY;
        }

    }

    return d.String;
}

PCTSTR
pGetScript (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) {

        return S_ZERO;
    }

    return S_ONE;
}

PCTSTR
pGetTerminal (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_UI_OPTIONS, &d)) {

        return S_EMPTY;
    }

    if (d.Value & (RAS_UI_FLAG_TERMBEFOREDIAL | RAS_UI_FLAG_TERMAFTERDIAL)) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetName (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) {

        return S_EMPTY;
    }
    else {

        return d.String;
    }

}

PCTSTR
pGetDEVICE (
    VOID
    )
{
    if (g_InSwitchSection) {
        return TEXT("Switch");
    }

    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return TEXT("rastapi");
    }

    return TEXT("modem");

}

PCTSTR
pGetConnectBps (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!g_CurrentDevice) {

        if (!pGetRasDataFromMemDb (S_MODEM_SPEED, &d)) {
            return S_EMPTY;
        }

        wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

        return g_TempBuffer;
    }

    return S_EMPTY;
}

PCTSTR
pGetDevice (
    VOID
    )
{

    PTSTR p = S_MODEM_COM_PORT;
    PTSTR value = NULL;
    MEMDB_RAS_DATA d;


    //
    // Very easy if this is a vpn connection.
    //
    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return TEXT("rastapi");
    }



    if (g_CurrentDevice) {
        wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice, S_MODEM_COM_PORT);
        p = g_TempBuffer;
    }

    if (!pGetRasDataFromMemDb (p, &d)) {
        return S_EMPTY;
    }

    if (!HtFindStringEx (g_DeviceTable, d.String, &value, FALSE)) {
        return S_EMPTY;
    }

    return value;
}

PCTSTR
pGetPort (
    VOID
    )
{
    PTSTR value = NULL;
    MEMDB_RAS_DATA d;
    PTSTR p = S_MODEM_COM_PORT;

    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return TEXT("VPN2-0");
    }


    if (g_CurrentDevice) {
        wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice, S_MODEM_COM_PORT);
        p = g_TempBuffer;
    }

    if (!pGetRasDataFromMemDb (p, &d)) {
        return S_EMPTY;
    }

    if (!HtFindStringEx (g_DeviceTable, d.String, &value, FALSE)) {
        return S_EMPTY;
    }

    return d.String;
}

PCTSTR
pGetMEDIA (
    VOID
    )
{

    if (g_CurrentDeviceType == RASTYPE_VPN) {

        return TEXT("rastapi");
    }
    else {

        return TEXT("Serial");
    }

}

PCTSTR
pGetIpNameAssign (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_EMPTY;
    }
    else if (d.Value & IPF_NAME_SPECIFIED) {
        return TEXT("2");
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetNetAddress (
    IN PCTSTR Setting
    )
{
    MEMDB_RAS_DATA d;
    BYTE address[4];

    if (!pGetRasDataFromMemDb (Setting, &d) || !d.Value) {
        return S_EMPTY;
    }

    //
    // Data is stored as a REG_DWORD.
    // We need to write it in dotted decimal form.
    //

    *((LPDWORD)address) = d.Value;
    wsprintf (
        g_TempBuffer,
        TEXT("%d.%d.%d.%d"),
        address[3],
        address[2],
        address[1],
        address[0]
        );

    return g_TempBuffer;
}

PCTSTR
pGetIpWINS2Address (
    VOID
    )
{
   return pGetNetAddress (S_IP_WINSADDR2);
}

PCTSTR
pGetIpWINSAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_WINSADDR);
}

PCTSTR
pGetIpDns2Address (
    VOID
    )
{
    return pGetNetAddress (S_IP_DNSADDR2);
}

PCTSTR
pGetIpDnsAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_DNSADDR);
}

PCTSTR
pGetIpAssign (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_EMPTY;
    }
    else if (d.Value & IPF_IP_SPECIFIED) {
        return TEXT("2");
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetIpAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_IPADDR);
}

PCTSTR
pGetIpHeaderCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_EMPTY;
    }
    else if (d.Value & IPF_NO_COMPRESS) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetIpPrioritizeRemote (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_ONE;
    }
    else if (d.Value & IPF_NO_WAN_PRI) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }

}

PCTSTR
pGetPreviewUserPw (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_DIALUI, &d)) {
        return S_ONE;
    }

    if (d.Value & DIALUI_DONT_PROMPT_FOR_INFO) {
        return S_ZERO;
    }


    return S_ONE;
}

PCTSTR
pGetPreviewPhoneNumber (
    VOID
    )
{
    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return S_ZERO;
    }

    return pGetPreviewUserPw ();
}

PCTSTR
pGetPreviewDomain (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_ONE;
    }

    //
    // if 0x04 is set, then preview domain, otherwise don't.
    //

    if (d.Value & SMMCFG_NW_LOGON) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetIdleDisconnectSeconds (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_IDLE_DISCONNECT_SECONDS, &d)) {
        return S_EMPTY;
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetRedialSeconds (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // NT wants this as a total number of seconds. The data we have from 9x has
    // the number of minutes in the hiword and the number of seconds in the loword.
    //

    if (!pGetRasDataFromMemDb (S_REDIAL_WAIT, &d)) {
        return S_EMPTY;
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;

}

PCTSTR
pGetRedialAttempts (
    VOID
    )
{

    MEMDB_RAS_DATA d;

    //
    // Before getting the number of redial attempts on windows 9x,
    // we need to ensure that redialing is enabled. If it is not
    // enabled, we set this field to zero, regardless.
    //


    if (pGetRasDataFromMemDb (S_ENABLE_REDIAL, &d)) {
        if (!d.Value) {
            return S_ZERO;
        }
    }

    //
    // If we have gotten this far, then redialing is enabled.
    //
    if (!pGetRasDataFromMemDb (S_REDIAL_TRY, &d)) {
        DEBUGMSG((DBG_WARNING, "Redialing enabled, but no redial attempts info found."));
        return S_ZERO;

    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetAuthRestrictions (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_EMPTY;
    }

    //
    // password should be encrypted if 0x02 is set.
    //
    if (d.Value & SMMCFG_PW_ENCRYPTED) {
        return TEXT("2");
    }

    return S_EMPTY;
}

PCTSTR
pGetShowMonitorIconInTaskBar (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // This information is stored packed with other Dialing UI on
    // windows 9x. All we need to do is look for the specific
    // bit which is set when this is turned off.
    //

    if (pGetRasDataFromMemDb (S_DIALUI, &d) && (d.Value & DIALUI_DONT_SHOW_ICON)) {
        return S_ZERO;
    }
    return S_ONE;
}

PCTSTR
pGetSwCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_EMPTY;
    }

    //
    // the 1 bit in SMM_OPTIONS controls software based compression.
    // if it is set, the connection is able to handled compression,
    // otherwise, it cannot.
    //
    if (d.Value & SMMCFG_SW_COMPRESSION) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetDataEncryption (
    VOID
    )
{
    MEMDB_RAS_DATA d;
    BOOL reqDataEncrypt;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_EMPTY;
    }

    //
    // data should be encrypted if 0x1000 is set.
    //
    reqDataEncrypt = (d.Value & 0x1000);
    if (!reqDataEncrypt) {
        reqDataEncrypt = (d.Value & 0x200);
    }

    return reqDataEncrypt ? TEXT("256") : TEXT("8");
}

PCTSTR
pGetExcludedProtocols (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Excluded protocols lists what protocols
    // are _not_ available for a particular ras connection.
    // This is a bit field where bits are set for each protocol
    // that is excluded.
    // NP_Nbf (0x1), NP_Ipx (0x2), NP_Ip (0x4)
    // Luckily, these are the same definitions as for win9x, except
    // each bit represents a protocol that is _enabled_ not
    // _disabled_. Therefore, all we need to do is reverse the bottom
    // three bits of the number.
    //

    if (!pGetRasDataFromMemDb (S_PROTOCOLS, &d)) {
        //
        // No data found, so we default to all protocols enabled.
        //
        return S_ZERO;
    }

    wsprintf (g_TempBuffer, TEXT("%d"), ~d.Value & 0x7);

    return g_TempBuffer;
}

PCTSTR
pGetVpnStrategy (
    VOID
    )
{

    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return TEXT("2");
    }

    return S_EMPTY;
}

PCTSTR
pGetBaseProtocol (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Only supported protocol types for NT 5 are
    // BP_PPP (0x1), BP_SLIP (0x2), and BP_RAS (0x3)
    //
    // If we can't find one, we default to BP_PPP.
    //
    if (!pGetRasDataFromMemDb (S_SMM, &d) || StringIMatch (d.String, S_PPP)) {
        return S_ONE;
    }

    //
    // MaP CSLIP to SLIP -- Header Compression will be on.
    //
    if (StringIMatch (d.String, S_SLIP) || StringIMatch (d.String, S_CSLIP)) {
        return TEXT("2");
    }

    DEBUGMSG ((
        DBG_WARNING,
        "RAS Migration: Unusable base protocol type (%s) for entry %s. Forcing PPP.",
        d.String,
        g_CurrentConnection
        ));

    // we are going to return an invalid protocol so the connection
    // does not get migrated.
    return TEXT("3");
}

PCTSTR
pGetCredPassword (
    VOID
    )
{
    return S_EMPTY;
}

PCTSTR
pGetCredDomain (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_DOMAIN, &d)) {
        return S_EMPTY;
    }


    return d.String;
}

PCTSTR
pGetCredName (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_USER, &d)) {
        return S_EMPTY;
    }

    return d.String;
}

PCTSTR
pGetCredMask (
    VOID
    )
{
    return TEXT("0x00000005");
}

PCTSTR
pGetType (
    VOID
    )
{

    if (g_CurrentDeviceType == RASTYPE_VPN) {

        return TEXT("2");
    }
    else {
        return S_ONE;
    }

}

BOOL
pCreateUserPhonebook (
    IN      PCTSTR PbkFile
    )
{
    PCTSTR tempKey;
    BOOL noError = FALSE;
    MEMDB_RAS_DATA d;
    MEMDB_ENUM e;
    HANDLE file;
    UINT i;
    UINT count;

    tempKey = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_INFO, TEXT("\\*"), NULL));

    if (MemDbEnumFirst (&e, tempKey, ENUMFLAG_ALL, 1, 1)) {

        //
        // Open the phonebook file and set the file pointer to the EOF.
        //

        file = CreateFile (
            PbkFile,
            GENERIC_READ | GENERIC_WRITE,
            0,                                  // No sharing.
            NULL,                               // No inheritance
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                                // No template file.
            );

        if (file == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Unable to open the phonebook file (%s)", PbkFile));
            FreePathString (tempKey);
            return FALSE;
        }

        SetFilePointer (file, 0, NULL, FILE_END);

        //
        // Now, enumerate all of the entries and write a phonebook entry to this
        // file for each.
        //

        do {

            g_CurrentConnection = e.KeyName;
            g_CurrentDevice = 0;
            if (!pGetRasDataFromMemDb (S_DEVICE_TYPE, &d)) {
                g_CurrentDeviceType = RASTYPE_PHONE;
            }
            else {
                if (StringIMatch (d.String, S_MODEM)) {
                    g_CurrentDeviceType = RASTYPE_PHONE;
                }
                else if (StringIMatch (d.String, S_VPN)) {
                    g_CurrentDeviceType = RASTYPE_VPN;
                }
                else {
                    g_CurrentDeviceType = RASTYPE_PHONE;
                }
            }


            noError = TRUE;

            //
            // Add this entry to the phonebook.
            //

            //
            // Write title.
            //
            noError &= WriteFileString (file, TEXT("["));
            noError &= WriteFileString (file, g_CurrentConnection);
            noError &= WriteFileString (file, TEXT("]\r\n"));


            //
            // Write base entry settings.
            //
            noError &= pWriteSettings (file, g_EntrySettings);




            if (!pGetRasDataFromMemDb (S_DEVICECOUNT, &d)) {
                count = 1;
                DEBUGMSG ((DBG_WHOOPS, "No devices listed in memdb for connections %s.", g_CurrentConnection));
            }
            else {
                count = d.Value;
            }
            for (i = 0; i < count; i++) {

                g_CurrentDevice = i;

                //
                // Write media settings.
                //
                noError &= WriteFileString (file, TEXT("\r\n"));
                noError &= pWriteSettings (file, g_MediaSettings);

                //
                // Write modem Device settings.
                //
                noError &= WriteFileString (file, TEXT("\r\n"));
                noError &= pWriteSettings (file, g_ModemDeviceSettings);
                noError &= WriteFileString (file, TEXT("\r\n\r\n"));


            }

            g_InSwitchSection = TRUE;

            noError &= WriteFileString (file, TEXT("\r\n"));
            noError &= pWriteSettings (file, g_SwitchDeviceSettings);
            noError &= WriteFileString (file, TEXT("\r\n\r\n"));

            g_InSwitchSection = FALSE;


            if (!noError) {
                LOG ((
                    LOG_ERROR,
                    "Error while writing phonebook for %s.",
                    g_CurrentConnection
                    ));
            }

        } while (MemDbEnumNext (&e));

        //
        // Close the handle to the phone book file.
        //
        CloseHandle (file);
    }
    ELSE_DEBUGMSG ((DBG_RASMIG, "No dial-up entries for current user."));

    FreePathString (tempKey);

    return noError;
}

MIG_OBJECTSTRINGHANDLE
pCreate9xPbkFile (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE result = NULL;
    PCTSTR nativeName = NULL;
    TCHAR windir [MAX_PATH];
    BOOL b = FALSE;

    GetWindowsDirectory (windir, MAX_PATH);
    result = IsmCreateObjectHandle (windir, TEXT("usmt.pbk"));
    if (!result) {
        return NULL;
    }
    nativeName = IsmGetNativeObjectName (g_FileTypeId, result);
    if (!nativeName) {
        IsmDestroyObjectHandle (result);
        return NULL;
    }

    if (pIs9xRasInstalled ()) {

        g_DeviceTable = HtAllocWithData (sizeof (PTSTR));
        MYASSERT (g_DeviceTable);

        pInitializeDeviceTable ();

        __try {
            b = pGetPerUserSettings ();
            b = b && pGetPerConnectionSettings ();
            b = b && pCreateUserPhonebook (nativeName);
        }
        __except (TRUE) {
            DEBUGMSG ((DBG_WHOOPS, "Caught an exception while processing ras settings."));
        }
        HtFree (g_DeviceTable);
    }

    IsmReleaseMemory (nativeName);

    if (!b) {
        IsmDestroyObjectHandle (result);
        result = NULL;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\sysmod.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sysmod.h

Abstract:

    Header file for prototypes of modules combined into sysmod.dll.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

// Accessiblity
ETMINITIALIZE AccessibilityEtmInitialize;
VCMINITIALIZE AccessibilitySourceInitialize;
VCMQUEUEENUMERATION AccessibilityQueueEnumeration;
VCMPARSE AccessibilityParse;

// Cookies
ETMINITIALIZE CookiesEtmInitialize;
VCMINITIALIZE CookiesSourceInitialize;
#define CookiesVcmParse     ((PVCMPARSE) CookiesSgmParse)
VCMQUEUEENUMERATION CookiesVcmQueueEnumeration;
SGMPARSE CookiesSgmParse;
SGMQUEUEENUMERATION CookiesSgmQueueEnumeration;
ETMNEWUSERCREATED CookiesEtmNewUserCreated;

// LnkMig
VCMINITIALIZE LnkMigVcmInitialize;
VCMQUEUEENUMERATION LnkMigVcmQueueEnumeration;
SGMINITIALIZE LnkMigSgmInitialize;
SGMQUEUEENUMERATION LnkMigSgmQueueEnumeration;
OPMINITIALIZE LnkMigOpmInitialize;

// NetDrives
ETMINITIALIZE NetDrivesEtmInitialize;
ETMNEWUSERCREATED NetDrivesEtmNewUserCreated;
SGMINITIALIZE NetDrivesSgmInitialize;
SGMPARSE NetDrivesSgmParse;
SGMQUEUEENUMERATION NetDrivesSgmQueueEnumeration;
VCMINITIALIZE NetDrivesVcmInitialize;
VCMPARSE NetDrivesVcmParse;
VCMQUEUEENUMERATION NetDrivesVcmQueueEnumeration;
CSMINITIALIZE NetDrivesCsmInitialize;
CSMEXECUTE NetDrivesCsmExecute;
OPMINITIALIZE NetDrivesOpmInitialize;

// NetShares
ETMINITIALIZE NetSharesEtmInitialize;
SGMINITIALIZE NetSharesSgmInitialize;
SGMPARSE NetSharesSgmParse;
SGMQUEUEENUMERATION NetSharesSgmQueueEnumeration;
VCMINITIALIZE NetSharesVcmInitialize;
VCMPARSE NetSharesVcmParse;
VCMQUEUEENUMERATION NetSharesVcmQueueEnumeration;

// OsFiles
SGMINITIALIZE OsFilesSgmInitialize;
SGMQUEUEENUMERATION OsFilesSgmQueueEnumeration;
SGMQUEUEHIGHPRIORITYENUMERATION OsFilesSgmQueueHighPriorityEnumeration;
VCMINITIALIZE OsFilesVcmInitialize;
VCMQUEUEENUMERATION OsFilesVcmQueueEnumeration;
VCMQUEUEHIGHPRIORITYENUMERATION OsFilesVcmQueueHighPriorityEnumeration;

// Printers
ETMINITIALIZE PrintersEtmInitialize;
ETMNEWUSERCREATED PrintersEtmNewUserCreated;
SGMINITIALIZE PrintersSgmInitialize;
SGMPARSE PrintersSgmParse;
SGMQUEUEENUMERATION PrintersSgmQueueEnumeration;
VCMINITIALIZE PrintersVcmInitialize;
VCMPARSE PrintersVcmParse;
VCMQUEUEENUMERATION PrintersVcmQueueEnumeration;

// RasMig
ETMINITIALIZE RasMigEtmInitialize;
ETMNEWUSERCREATED RasMigEtmNewUserCreated;
SGMINITIALIZE RasMigSgmInitialize;
SGMPARSE RasMigSgmParse;
SGMQUEUEENUMERATION RasMigSgmQueueEnumeration;
VCMINITIALIZE RasMigVcmInitialize;
VCMPARSE RasMigVcmParse;
VCMQUEUEENUMERATION RasMigVcmQueueEnumeration;
OPMINITIALIZE RasMigOpmInitialize;

#define MODULE_LIST             \
    DEFMAC(Cookies)             \
    DEFMAC(Links)               \
    DEFMAC(NetDrives)           \
    DEFMAC(NetShares)           \
    DEFMAC(OsFiles)             \
    DEFMAC(Printers)            \
    DEFMAC(RasMig)              \

typedef BOOL(OURMODULEINIT)(VOID);
typedef OURMODULEINIT *POURMODULEINIT;

typedef VOID(OURMODULETERMINATE)(VOID);
typedef OURMODULETERMINATE *POURMODULETERMINATE;

#define DEFMAC(prefix)  OURMODULEINIT prefix##Initialize; OURMODULETERMINATE prefix##Terminate;

MODULE_LIST

#undef DEFMAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\sysmod\printers.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    printers.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 08 Mar 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <winspool.h>

#define DBG_PRINTERS    "Printers"

//
// Strings
//

#define S_PRINTERS_POOL_NAME     "Printers"
#define S_PRINTERS_NAME          TEXT("Printers")
#define S_CORPNET_NAME           TEXT("Net Printers and Drives")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} PRINTER_ENUM, *PPRINTER_ENUM;

typedef struct {
    BOOL Default;
    DWORD dmFields;
    SHORT dmOrientation;
    SHORT dmPaperSize;
    SHORT dmPaperLength;
    SHORT dmPaperWidth;
    POINTL dmPosition;
    SHORT dmScale;
    SHORT dmCopies;
    SHORT dmDefaultSource;
    SHORT dmPrintQuality;
    SHORT dmColor;
    SHORT dmDuplex;
    SHORT dmYResolution;
    SHORT dmTTOption;
    SHORT dmCollate;
    CHAR dmFormName[CCHFORMNAME];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    DWORD dmDisplayFlags;
    DWORD dmNup;
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
} PRINTER_DATAA, *PPRINTER_DATAA;

typedef struct {
    BOOL Default;
    DWORD dmFields;
    SHORT dmOrientation;
    SHORT dmPaperSize;
    SHORT dmPaperLength;
    SHORT dmPaperWidth;
    POINTL dmPosition;
    SHORT dmScale;
    SHORT dmCopies;
    SHORT dmDefaultSource;
    SHORT dmPrintQuality;
    SHORT dmColor;
    SHORT dmDuplex;
    SHORT dmYResolution;
    SHORT dmTTOption;
    SHORT dmCollate;
    WCHAR dmFormName[CCHFORMNAME];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    DWORD dmDisplayFlags;
    DWORD dmNup;
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
} PRINTER_DATAW, *PPRINTER_DATAW;

#ifdef UNICODE
#define PRINTER_DATA    PRINTER_DATAW
#define PPRINTER_DATA   PPRINTER_DATAW
#else
#define PRINTER_DATA    PRINTER_DATAA
#define PPRINTER_DATA   PPRINTER_DATAA
#endif

//
// Globals
//

BOOL g_PrinterMigEnabled = FALSE;
PMHANDLE g_PrintersPool = NULL;
HASHTABLE g_PrintersTable;
MIG_OBJECTTYPEID g_PrinterTypeId = 0;
static BOOL g_IsWin9x = FALSE;
GROWBUFFER g_PrinterConversionBuff = INIT_GROWBUFFER;
BOOL g_DelayPrintersOp = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

SGMENUMERATIONCALLBACK SgmPrintersCallback;
VCMENUMERATIONCALLBACK VcmPrintersCallback;

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPrinter;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextPrinter;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumPrinter;
TYPE_CONVERTOBJECTTOMULTISZ ConvertPrinterToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToPrinter;
TYPE_GETNATIVEOBJECTNAME GetNativePrinterName;
TYPE_ACQUIREPHYSICALOBJECT AcquirePrinter;
TYPE_RELEASEPHYSICALOBJECT ReleasePrinter;
TYPE_DOESPHYSICALOBJECTEXIST DoesPrinterExist;
TYPE_REMOVEPHYSICALOBJECT RemovePrinter;
TYPE_CREATEPHYSICALOBJECT CreatePrinter;
TYPE_REPLACEPHYSICALOBJECT ReplacePrinter;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertPrinterContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertPrinterContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedPrinterContent;

//
// Code
//

BOOL
PrintersInitialize (
    VOID
    )
{
    OSVERSIONINFO versionInfo;

    ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
    versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&versionInfo)) {
        return FALSE;
    }
    g_IsWin9x = (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
    g_PrintersTable = HtAllocWithData (sizeof (PPRINTER_DATA));
    if (!g_PrintersTable) {
        return FALSE;
    }
    g_PrintersPool = PmCreateNamedPool (S_PRINTERS_POOL_NAME);
    return (g_PrintersPool != NULL);
}

BOOL
pLoadPrintersData (
    VOID
    )
{
    PTSTR defaultPrinter = NULL;
    PTSTR defaultPrinterPtr = NULL;
    DWORD defaultGap = 1024;
    DWORD initialSize = 0;
    DWORD resultSize = 0;
    PBYTE prnBuffer = NULL;
    DWORD prnBufferSize = 0;
    DWORD prnNumbers = 0;
    DWORD error;
    PPRINTER_INFO_2 prnInfo;
    PPRINTER_DATA printerData;

    do {
        initialSize = initialSize + defaultGap;
        defaultPrinter = (PTSTR) PmGetMemory (g_PrintersPool, initialSize * sizeof (TCHAR));
        resultSize = GetProfileString (TEXT("windows"), TEXT("device"), TEXT(",,"), defaultPrinter, initialSize);
        if (resultSize < (initialSize - 1)) {
            break;
        }
        PmReleaseMemory (g_PrintersPool, defaultPrinter);
    } while (TRUE);
    defaultPrinterPtr = _tcschr (defaultPrinter, TEXT(','));
    if (defaultPrinterPtr) {
        *defaultPrinterPtr = 0;
    }

    if (!EnumPrinters (PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS, NULL, 2, NULL, 0, &prnBufferSize, &prnNumbers)) {
        error = GetLastError ();
        if (error != ERROR_INSUFFICIENT_BUFFER) {
            PmReleaseMemory (g_PrintersPool, defaultPrinter);
            return FALSE;
        }
    }
    if (prnBufferSize) {
        prnBuffer = PmGetMemory (g_PrintersPool, prnBufferSize);
        if (!EnumPrinters (PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS, NULL, 2, prnBuffer, prnBufferSize, &prnBufferSize, &prnNumbers)) {
            PmReleaseMemory (g_PrintersPool, defaultPrinter);
            PmReleaseMemory (g_PrintersPool, prnBuffer);
            return FALSE;
        }
        prnInfo = (PPRINTER_INFO_2) (prnBuffer);
        while (prnNumbers) {
            if (prnInfo->Attributes & PRINTER_ATTRIBUTE_NETWORK) {
                printerData = (PPRINTER_DATA) PmGetMemory (g_PrintersPool, sizeof (PRINTER_DATA));
                ZeroMemory (printerData, sizeof (PRINTER_DATA));
                if (prnInfo->pDevMode) {
                    // let's save printer settings
                    printerData->dmFields = prnInfo->pDevMode->dmFields;
                    if (prnInfo->pDevMode->dmFields & DM_ORIENTATION) {
                        printerData->dmOrientation = prnInfo->pDevMode->dmOrientation;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PAPERSIZE) {
                        printerData->dmPaperSize = prnInfo->pDevMode->dmPaperSize;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PAPERLENGTH) {
                        printerData->dmPaperLength = prnInfo->pDevMode->dmPaperLength;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PAPERWIDTH) {
                        printerData->dmPaperWidth = prnInfo->pDevMode->dmPaperWidth;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_SCALE) {
                        printerData->dmScale = prnInfo->pDevMode->dmScale;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_POSITION) {
                        CopyMemory (&printerData->dmPosition, &prnInfo->pDevMode->dmPosition, sizeof(POINTL));
                    }
                    if (prnInfo->pDevMode->dmFields & DM_NUP) {
                        printerData->dmNup = prnInfo->pDevMode->dmNup;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_COPIES) {
                        printerData->dmCopies = prnInfo->pDevMode->dmCopies;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DEFAULTSOURCE) {
                        printerData->dmDefaultSource = prnInfo->pDevMode->dmDefaultSource;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PRINTQUALITY) {
                        printerData->dmPrintQuality = prnInfo->pDevMode->dmPrintQuality;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_COLOR) {
                        printerData->dmColor = prnInfo->pDevMode->dmColor;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DUPLEX) {
                        printerData->dmDuplex = prnInfo->pDevMode->dmDuplex;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_YRESOLUTION) {
                        printerData->dmYResolution = prnInfo->pDevMode->dmYResolution;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_TTOPTION) {
                        printerData->dmTTOption = prnInfo->pDevMode->dmTTOption;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_COLLATE) {
                        printerData->dmCollate = prnInfo->pDevMode->dmCollate;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_FORMNAME) {
                        CopyMemory (printerData->dmFormName, prnInfo->pDevMode->dmFormName, sizeof (printerData->dmFormName));
                    }
                    if (prnInfo->pDevMode->dmFields & DM_LOGPIXELS) {
                        printerData->dmLogPixels = prnInfo->pDevMode->dmLogPixels;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_BITSPERPEL) {
                        printerData->dmBitsPerPel = prnInfo->pDevMode->dmBitsPerPel;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PELSWIDTH) {
                        printerData->dmPelsWidth = prnInfo->pDevMode->dmPelsWidth;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PELSHEIGHT) {
                        printerData->dmPelsHeight = prnInfo->pDevMode->dmPelsHeight;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DISPLAYFLAGS) {
                        printerData->dmDisplayFlags = prnInfo->pDevMode->dmDisplayFlags;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DISPLAYFREQUENCY) {
                        printerData->dmDisplayFrequency = prnInfo->pDevMode->dmDisplayFrequency;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_ICMMETHOD) {
                        printerData->dmICMMethod = prnInfo->pDevMode->dmICMMethod;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_ICMINTENT) {
                        printerData->dmICMIntent = prnInfo->pDevMode->dmICMIntent;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_MEDIATYPE) {
                        printerData->dmMediaType = prnInfo->pDevMode->dmMediaType;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DITHERTYPE) {
                        printerData->dmDitherType = prnInfo->pDevMode->dmDitherType;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PANNINGWIDTH) {
                        printerData->dmPanningWidth = prnInfo->pDevMode->dmPanningWidth;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PANNINGHEIGHT) {
                        printerData->dmPanningHeight = prnInfo->pDevMode->dmPanningHeight;
                    }
                }
                printerData->Default = StringIMatch (prnInfo->pPrinterName, defaultPrinter);
                if (g_IsWin9x) {
                    HtAddStringEx (g_PrintersTable, prnInfo->pPortName, &printerData, FALSE);
                } else {
                    HtAddStringEx (g_PrintersTable, prnInfo->pPrinterName, &printerData, FALSE);
                }
            }
            prnInfo ++;
            prnNumbers --;
        }
        PmReleaseMemory (g_PrintersPool, prnBuffer);
    }
    PmReleaseMemory (g_PrintersPool, defaultPrinter);
    return TRUE;
}

VOID
PrintersTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PPRINTER_DATA printerData;

    GbFree (&g_PrinterConversionBuff);

    if (g_PrintersTable) {
        if (EnumFirstHashTableString (&e, g_PrintersTable)) {
            do {
                printerData = *((PPRINTER_DATA *) e.ExtraData);
                if (printerData) {
                    PmReleaseMemory (g_PrintersPool, printerData);
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_PrintersTable);
        g_PrintersTable = NULL;
    }
    if (g_PrintersPool) {
        PmDestroyPool (g_PrintersPool);
        g_PrintersPool = NULL;
    }
}

BOOL
WINAPI
PrintersEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TYPE_REGISTER printerTypeData;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    pLoadPrintersData ();

    ZeroMemory (&printerTypeData, sizeof (TYPE_REGISTER));
    printerTypeData.Priority = PRIORITY_PRINTER;

    if (Platform == PLATFORM_SOURCE) {

        printerTypeData.EnumFirstPhysicalObject = EnumFirstPrinter;
        printerTypeData.EnumNextPhysicalObject = EnumNextPrinter;
        printerTypeData.AbortEnumPhysicalObject = AbortEnumPrinter;
        printerTypeData.ConvertObjectToMultiSz = ConvertPrinterToMultiSz;
        printerTypeData.ConvertMultiSzToObject = ConvertMultiSzToPrinter;
        printerTypeData.GetNativeObjectName = GetNativePrinterName;
        printerTypeData.AcquirePhysicalObject = AcquirePrinter;
        printerTypeData.ReleasePhysicalObject = ReleasePrinter;
        printerTypeData.ConvertObjectContentToUnicode = ConvertPrinterContentToUnicode;
        printerTypeData.ConvertObjectContentToAnsi = ConvertPrinterContentToAnsi;
        printerTypeData.FreeConvertedObjectContent = FreeConvertedPrinterContent;

        g_PrinterTypeId = IsmRegisterObjectType (
                                S_PRINTERS_NAME,
                                TRUE,
                                FALSE,
                                &printerTypeData
                                );
    } else {

        printerTypeData.EnumFirstPhysicalObject = EnumFirstPrinter;
        printerTypeData.EnumNextPhysicalObject = EnumNextPrinter;
        printerTypeData.AbortEnumPhysicalObject = AbortEnumPrinter;
        printerTypeData.ConvertObjectToMultiSz = ConvertPrinterToMultiSz;
        printerTypeData.ConvertMultiSzToObject = ConvertMultiSzToPrinter;
        printerTypeData.GetNativeObjectName = GetNativePrinterName;
        printerTypeData.AcquirePhysicalObject = AcquirePrinter;
        printerTypeData.ReleasePhysicalObject = ReleasePrinter;
        printerTypeData.DoesPhysicalObjectExist = DoesPrinterExist;
        printerTypeData.RemovePhysicalObject = RemovePrinter;
        printerTypeData.CreatePhysicalObject = CreatePrinter;
        printerTypeData.ReplacePhysicalObject = ReplacePrinter;
        printerTypeData.ConvertObjectContentToUnicode = ConvertPrinterContentToUnicode;
        printerTypeData.ConvertObjectContentToAnsi = ConvertPrinterContentToAnsi;
        printerTypeData.FreeConvertedObjectContent = FreeConvertedPrinterContent;

        g_PrinterTypeId = IsmRegisterObjectType (
                                S_PRINTERS_NAME,
                                TRUE,
                                FALSE,
                                &printerTypeData
                                );
    }
    MYASSERT (g_PrinterTypeId);
    return TRUE;
}

VOID
WINAPI
PrintersEtmNewUserCreated (
    IN      PCTSTR UserName,
    IN      PCTSTR DomainName,
    IN      PCTSTR UserProfileRoot,
    IN      PSID UserSid
    )
{
    // a new user was created, the printer operations need to be delayed
    PrintersTerminate ();
    g_DelayPrintersOp = TRUE;
}

BOOL
WINAPI
PrintersSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
PrintersSgmParse (
    IN      PVOID Reserved
    )
{
    PCTSTR friendlyName;

    friendlyName = GetStringResource (MSG_PRINTERS_NAME);

    //IsmAddComponentAlias (
    //    S_PRINTERS_NAME,
    //    MASTERGROUP_SYSTEM,
    //    friendlyName,
    //    COMPONENT_NAME,
    //    FALSE
    //    );

    IsmAddComponentAlias (
        S_CORPNET_NAME,
        MASTERGROUP_SYSTEM,
        friendlyName,
        COMPONENT_NAME,
        FALSE
        );

    FreeStringResource (friendlyName);
    return TRUE;
}

UINT
SgmPrintersCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmAbandonObjectOnCollision (Data->ObjectTypeId, Data->ObjectName);
    IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
PrintersSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_PRINTERS_NAME, 0) &&
        !IsmIsComponentSelected (S_CORPNET_NAME, 0)
        ) {
        g_PrinterMigEnabled = FALSE;
        return TRUE;
    }
    g_PrinterMigEnabled = TRUE;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, FALSE);
    IsmQueueEnumeration (
        g_PrinterTypeId,
        pattern,
        SgmPrintersCallback,
        (ULONG_PTR) 0,
        S_PRINTERS_NAME
        );
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
WINAPI
PrintersVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
PrintersVcmParse (
    IN      PVOID Reserved
    )
{
    return PrintersSgmParse (Reserved);
}

UINT
VcmPrintersCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
PrintersVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_PRINTERS_NAME, 0) &&
        !IsmIsComponentSelected (S_CORPNET_NAME, 0)
        ) {
        g_PrinterMigEnabled = FALSE;
        return TRUE;
    }
    g_PrinterMigEnabled = TRUE;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, FALSE);
    IsmQueueEnumeration (
        g_PrinterTypeId,
        pattern,
        VcmPrintersCallback,
        (ULONG_PTR) 0,
        S_PRINTERS_NAME
        );
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
pEnumPrinterWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PPRINTER_ENUM PrinterEnum
    )
{
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    do {
        EnumPtr->ObjectName = IsmCreateObjectHandle (PrinterEnum->HashData.String, NULL);
        if (!ObsPatternMatch (PrinterEnum->Pattern, EnumPtr->ObjectName)) {
            if (!EnumNextHashTableString (&PrinterEnum->HashData)) {
                AbortEnumPrinter (EnumPtr);
                return FALSE;
            }
            continue;
        }
        EnumPtr->NativeObjectName = PrinterEnum->HashData.String;
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        EnumPtr->Level = 1;
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = FALSE;
        EnumPtr->IsNode = TRUE;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;
        return TRUE;
    } while (TRUE);
}

BOOL
EnumFirstPrinter (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PPRINTER_ENUM printerEnum = NULL;

    if (!g_PrintersTable) {
        return FALSE;
    }
    printerEnum = (PPRINTER_ENUM) PmGetMemory (g_PrintersPool, sizeof (PRINTER_ENUM));
    printerEnum->Pattern = PmDuplicateString (g_PrintersPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) printerEnum;

    if (EnumFirstHashTableString (&printerEnum->HashData, g_PrintersTable)) {
        return pEnumPrinterWorker (EnumPtr, printerEnum);
    } else {
        AbortEnumPrinter (EnumPtr);
        return FALSE;
    }
}

BOOL
EnumNextPrinter (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PPRINTER_ENUM printerEnum = NULL;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    printerEnum = (PPRINTER_ENUM)(EnumPtr->EtmHandle);
    if (!printerEnum) {
        return FALSE;
    }
    if (EnumNextHashTableString (&printerEnum->HashData)) {
        return pEnumPrinterWorker (EnumPtr, printerEnum);
    } else {
        AbortEnumPrinter (EnumPtr);
        return FALSE;
    }
}

VOID
AbortEnumPrinter (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PPRINTER_ENUM printerEnum = NULL;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    printerEnum = (PPRINTER_ENUM)(EnumPtr->EtmHandle);
    if (!printerEnum) {
        return;
    }
    PmReleaseMemory (g_PrintersPool, printerEnum->Pattern);
    PmReleaseMemory (g_PrintersPool, printerEnum);
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

BOOL
AcquirePrinter (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,                 CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PPRINTER_DATA printerData = NULL;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        MYASSERT (FALSE);
        return FALSE;
    }

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (HtFindStringEx (g_PrintersTable, node, (PVOID)(&printerData), FALSE)) {

            ObjectContent->MemoryContent.ContentBytes = (PCBYTE)printerData;
            ObjectContent->MemoryContent.ContentSize = sizeof (PRINTER_DATA);

            result = TRUE;
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
ReleasePrinter (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return TRUE;
}

BOOL
DoesPrinterExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PPRINTER_DATA printerData = NULL;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (g_PrintersTable &&
            HtFindStringEx (g_PrintersTable, node, (PVOID)(&printerData), FALSE)
            ) {
            result = TRUE;
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
RemovePrinter (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node && (!leaf)) {
            result = DeletePrinterConnection ((PTSTR)node);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
CreatePrinter (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PPRINTER_DATA printerData;
    HANDLE printerHandle = NULL;
    BOOL result = FALSE;
    UINT devModeSize;
    PPRINTER_INFO_2 printerInfo;
    UINT printerInfoSize;
    PDEVMODE devMode;

    if (!ObjectContent->ContentInFile) {
        if (ObjectContent->MemoryContent.ContentBytes && ObjectContent->MemoryContent.ContentSize) {
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
                if (node && (!leaf)) {

                    if (g_DelayPrintersOp) {

                        // we need to delay this operation
                        // record delayed printer replace operation
                        IsmRecordDelayedOperation (
                            JRNOP_CREATE,
                            g_PrinterTypeId,
                            ObjectName,
                            ObjectContent
                            );
                        result = TRUE;

                    } else {

                        // record printer creation
                        IsmRecordOperation (
                            JRNOP_CREATE,
                            g_PrinterTypeId,
                            ObjectName
                            );

                        result = AddPrinterConnection ((PTSTR)node);
                        if (result) {
                            printerData = (PPRINTER_DATA)(ObjectContent->MemoryContent.ContentBytes);
                            if (printerData->dmFields) {
                                // let's restore printer settings
                                if (OpenPrinter ((PTSTR)node, &printerHandle, NULL)) {
                                    if (GetPrinter (printerHandle, 2, 0, 0, &printerInfoSize) || (GetLastError () == ERROR_INSUFFICIENT_BUFFER)) {
                                        printerInfo = PmGetMemory (g_PrintersPool, (printerInfoSize > sizeof (PRINTER_INFO_2))?printerInfoSize:sizeof (PRINTER_INFO_2));
                                        ZeroMemory (printerInfo, (printerInfoSize > sizeof (PRINTER_INFO_2))?printerInfoSize:sizeof (PRINTER_INFO_2));
                                        if (GetPrinter (printerHandle, 2, (PBYTE)printerInfo, printerInfoSize, &printerInfoSize)) {
                                            if (printerInfo->pDevMode) {
                                                devMode = printerInfo->pDevMode;
                                            } else {
                                                devModeSize = DocumentProperties (NULL, printerHandle, (PTSTR)node, NULL, NULL, 0);
                                                if (devModeSize) {
                                                    devMode = PmGetMemory (g_PrintersPool, (devModeSize > sizeof (DEVMODE))?devModeSize:sizeof (DEVMODE));
                                                    if (!DocumentProperties (NULL, printerHandle, (PTSTR)node, devMode, NULL, DM_OUT_BUFFER) == IDOK) {
                                                        PmReleaseMemory (g_PrintersPool, devMode);
                                                        devMode = NULL;
                                                    } else {
                                                        printerInfo->pDevMode = devMode;
                                                    }
                                                }
                                            }
                                            if (devMode) {
                                                if ((devMode->dmFields & DM_ORIENTATION) && (printerData->dmFields & DM_ORIENTATION)) {
                                                    devMode->dmOrientation = printerData->dmOrientation;
                                                }
                                                if ((devMode->dmFields & DM_PAPERSIZE) && (printerData->dmFields & DM_PAPERSIZE)) {
                                                    devMode->dmPaperSize = printerData->dmPaperSize;
                                                }
                                                if ((devMode->dmFields & DM_PAPERLENGTH) && (printerData->dmFields & DM_PAPERLENGTH)) {
                                                    devMode->dmPaperLength = printerData->dmPaperLength;
                                                }
                                                if ((devMode->dmFields & DM_PAPERWIDTH) && (printerData->dmFields & DM_PAPERWIDTH)) {
                                                    devMode->dmPaperWidth = printerData->dmPaperWidth;
                                                }
                                                if ((devMode->dmFields & DM_SCALE) && (printerData->dmFields & DM_SCALE)) {
                                                    devMode->dmScale = printerData->dmScale;
                                                }
                                                if ((devMode->dmFields & DM_POSITION) && (printerData->dmFields & DM_POSITION)) {
                                                    CopyMemory (&devMode->dmScale, &printerData->dmScale, sizeof(POINTL));
                                                }
                                                if ((devMode->dmFields & DM_NUP) && (printerData->dmFields & DM_NUP)) {
                                                    devMode->dmNup = printerData->dmNup;
                                                }
                                                if ((devMode->dmFields & DM_COPIES) && (printerData->dmFields & DM_COPIES)) {
                                                    devMode->dmCopies = printerData->dmCopies;
                                                }
                                                if ((devMode->dmFields & DM_DEFAULTSOURCE) && (printerData->dmFields & DM_DEFAULTSOURCE)) {
                                                    devMode->dmDefaultSource = printerData->dmDefaultSource;
                                                }
                                                if ((devMode->dmFields & DM_PRINTQUALITY) && (printerData->dmFields & DM_PRINTQUALITY)) {
                                                    devMode->dmPrintQuality = printerData->dmPrintQuality;
                                                }
                                                if ((devMode->dmFields & DM_COLOR) && (printerData->dmFields & DM_COLOR)) {
                                                    devMode->dmColor = printerData->dmColor;
                                                }
                                                if ((devMode->dmFields & DM_DUPLEX) && (printerData->dmFields & DM_DUPLEX)) {
                                                    devMode->dmDuplex = printerData->dmDuplex;
                                                }
                                                if ((devMode->dmFields & DM_YRESOLUTION) && (printerData->dmFields & DM_YRESOLUTION)) {
                                                    devMode->dmYResolution = printerData->dmYResolution;
                                                }
                                                if ((devMode->dmFields & DM_TTOPTION) && (printerData->dmFields & DM_TTOPTION)) {
                                                    devMode->dmTTOption = printerData->dmTTOption;
                                                }
                                                if ((devMode->dmFields & DM_COLLATE) && (printerData->dmFields & DM_COLLATE)) {
                                                    devMode->dmCollate = printerData->dmCollate;
                                                }
                                                if ((devMode->dmFields & DM_FORMNAME) && (printerData->dmFields & DM_FORMNAME)) {
                                                    CopyMemory (devMode->dmFormName, printerData->dmFormName, sizeof (devMode->dmFormName));
                                                }
                                                if ((devMode->dmFields & DM_LOGPIXELS) && (printerData->dmFields & DM_LOGPIXELS)) {
                                                    devMode->dmLogPixels = printerData->dmLogPixels;
                                                }
                                                if ((devMode->dmFields & DM_BITSPERPEL) && (printerData->dmFields & DM_BITSPERPEL)) {
                                                    devMode->dmBitsPerPel = printerData->dmBitsPerPel;
                                                }
                                                if ((devMode->dmFields & DM_PELSWIDTH) && (printerData->dmFields & DM_PELSWIDTH)) {
                                                    devMode->dmPelsWidth = printerData->dmPelsWidth;
                                                }
                                                if ((devMode->dmFields & DM_PELSHEIGHT) && (printerData->dmFields & DM_PELSHEIGHT)) {
                                                    devMode->dmPelsHeight = printerData->dmPelsHeight;
                                                }
                                                if ((devMode->dmFields & DM_DISPLAYFLAGS) && (printerData->dmFields & DM_DISPLAYFLAGS)) {
                                                    devMode->dmDisplayFlags = printerData->dmDisplayFlags;
                                                }
                                                if ((devMode->dmFields & DM_DISPLAYFREQUENCY) && (printerData->dmFields & DM_DISPLAYFREQUENCY)) {
                                                    devMode->dmDisplayFrequency = printerData->dmDisplayFrequency;
                                                }
                                                if ((devMode->dmFields & DM_ICMMETHOD) && (printerData->dmFields & DM_ICMMETHOD)) {
                                                    devMode->dmICMMethod = printerData->dmICMMethod;
                                                }
                                                if ((devMode->dmFields & DM_ICMINTENT) && (printerData->dmFields & DM_ICMINTENT)) {
                                                    devMode->dmICMIntent = printerData->dmICMIntent;
                                                }
                                                if ((devMode->dmFields & DM_MEDIATYPE) && (printerData->dmFields & DM_MEDIATYPE)) {
                                                    devMode->dmMediaType = printerData->dmMediaType;
                                                }
                                                if ((devMode->dmFields & DM_DITHERTYPE) && (printerData->dmFields & DM_DITHERTYPE)) {
                                                    devMode->dmDitherType = printerData->dmDitherType;
                                                }
                                                if ((devMode->dmFields & DM_PANNINGWIDTH) && (printerData->dmFields & DM_PANNINGWIDTH)) {
                                                    devMode->dmPanningWidth = printerData->dmPanningWidth;
                                                }
                                                if ((devMode->dmFields & DM_PANNINGHEIGHT) && (printerData->dmFields & DM_PANNINGHEIGHT)) {
                                                    devMode->dmPanningHeight = printerData->dmPanningHeight;
                                                }
                                                if (DocumentProperties (NULL, printerHandle, (PTSTR)node, devMode, devMode, DM_IN_BUFFER | DM_OUT_BUFFER) == IDOK) {
                                                    SetPrinter (printerHandle, 2, (PBYTE)printerInfo, 0);
                                                } else {
                                                    DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                                }
                                                if (devMode != printerInfo->pDevMode) {
                                                    PmReleaseMemory (g_PrintersPool, devMode);
                                                }
                                            } else {
                                                DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                            }
                                        } else {
                                            DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                        }
                                        PmReleaseMemory (g_PrintersPool, printerInfo);
                                    } else {
                                        DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                    }
                                    ClosePrinter (printerHandle);
                                } else {
                                    DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                }
                            }
                            if (printerData && printerData->Default) {
                                result = SetDefaultPrinter (node);
                                if (!result) {
                                    DEBUGMSG ((DBG_PRINTERS, "Failed to set %s as default printer", node));
                                }
                            }
                        } else {
                            DEBUGMSG ((DBG_PRINTERS, "Failed to add printer connection for %s", node));
                        }
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);
            }
        }
    }
    return result;
}

BOOL
ReplacePrinter (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    BOOL result = TRUE;

    if (g_DelayPrintersOp) {

        // we need to delay this operation
        // record delayed printer replace operation
        IsmRecordDelayedOperation (
            JRNOP_REPLACE,
            g_PrinterTypeId,
            ObjectName,
            ObjectContent
            );
        result = TRUE;

    } else {

        // we are going to delete any existing printers with this name,
        // and create a new one
        if (DoesPrinterExist (ObjectName)) {
            result = RemovePrinter (ObjectName);
        }
        if (result) {
            result = CreatePrinter (ObjectName, ObjectContent);
        }
    }
    return result;
}

PCTSTR
ConvertPrinterToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    PPRINTER_DATA printerData;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        MYASSERT (!leaf);

        g_PrinterConversionBuff.End = 0;

        GbCopyQuotedString (&g_PrinterConversionBuff, node);

        MYASSERT (ObjectContent->Details.DetailsSize == 0);
        MYASSERT (!ObjectContent->ContentInFile);
        MYASSERT (ObjectContent->MemoryContent.ContentSize = sizeof (PRINTER_DATA));

        if ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentSize == sizeof (PRINTER_DATA)) &&
            (ObjectContent->MemoryContent.ContentBytes)
            ) {
            printerData = (PPRINTER_DATA)ObjectContent->MemoryContent.ContentBytes;
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->Default
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmFields
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmOrientation
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPaperSize
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPaperLength
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPaperWidth
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPosition.x
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPosition.y
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmScale
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmCopies
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDefaultSource
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPrintQuality
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmColor
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDuplex
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmYResolution
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmTTOption
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmCollate
                );
            GbCopyQuotedString (&g_PrinterConversionBuff, printerData->dmFormName);
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmLogPixels
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmBitsPerPel
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPelsWidth
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPelsHeight
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDisplayFlags
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmNup
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDisplayFrequency
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmICMMethod
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmICMIntent
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmMediaType
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDitherType
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPanningWidth
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPanningHeight
                );
        } else {
            bresult = FALSE;
        }

        if (bresult) {
            GbCopyString (&g_PrinterConversionBuff, TEXT(""));
            result = IsmGetMemory (g_PrinterConversionBuff.End);
            CopyMemory (result, g_PrinterConversionBuff.Buf, g_PrinterConversionBuff.End);
        }

        g_PrinterConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToPrinter (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    MULTISZ_ENUM multiSzEnum;
    PCTSTR name = NULL;
    PRINTER_DATA printerData;
    DWORD dummy;
    UINT index;

    g_PrinterConversionBuff.End = 0;

    ZeroMemory (&printerData, sizeof (PRINTER_DATA));

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == 0) {
                name = multiSzEnum.CurrentString;
            }
            if (index == 1) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.Default = dummy;
            }
            if (index == 2) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmFields = dummy;
            }
            if (index == 3) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmOrientation = (SHORT)dummy;
            }
            if (index == 4) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPaperSize = (SHORT)dummy;
            }
            if (index == 5) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPaperLength = (SHORT)dummy;
            }
            if (index == 6) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPaperWidth = (SHORT)dummy;
            }
            if (index == 7) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPosition.x = dummy;
            }
            if (index == 8) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPosition.y = dummy;
            }
            if (index == 9) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmScale = (SHORT)dummy;
            }
            if (index == 10) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmCopies = (SHORT)dummy;
            }
            if (index == 11) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDefaultSource = (SHORT)dummy;
            }
            if (index == 12) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPrintQuality = (SHORT)dummy;
            }
            if (index == 13) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmColor = (SHORT)dummy;
            }
            if (index == 14) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDuplex = (SHORT)dummy;
            }
            if (index == 15) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmYResolution = (SHORT)dummy;
            }
            if (index == 16) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmTTOption = (SHORT)dummy;
            }
            if (index == 17) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmCollate = (SHORT)dummy;
            }
            if (index == 18) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                    StringCopyTcharCount (printerData.dmFormName, multiSzEnum.CurrentString, CCHFORMNAME);
                }
            }
            if (index == 19) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmLogPixels = (WORD)dummy;
            }
            if (index == 20) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmBitsPerPel = dummy;
            }
            if (index == 21) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPelsWidth = dummy;
            }
            if (index == 22) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPelsHeight = dummy;
            }
            if (index == 23) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDisplayFlags = dummy;
            }
            if (index == 24) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmNup = dummy;
            }
            if (index == 25) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDisplayFrequency = dummy;
            }
            if (index == 26) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmICMMethod = dummy;
            }
            if (index == 27) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmICMIntent = dummy;
            }
            if (index == 28) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmMediaType = dummy;
            }
            if (index == 29) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDitherType = dummy;
            }
            if (index == 30) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPanningWidth = dummy;
            }
            if (index == 31) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPanningHeight = dummy;
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!name) {
        return FALSE;
    }

    if (ObjectContent) {

        ObjectContent->ContentInFile = FALSE;
        ObjectContent->MemoryContent.ContentSize = sizeof (PRINTER_DATA);
        ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
        CopyMemory (
            (PBYTE)ObjectContent->MemoryContent.ContentBytes,
            &printerData,
            ObjectContent->MemoryContent.ContentSize
            );

        ObjectContent->Details.DetailsSize = 0;
        ObjectContent->Details.DetailsData = NULL;
    }
    *ObjectName = IsmCreateObjectHandle (name, NULL);

    return TRUE;
}

PCTSTR
GetNativePrinterName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node, leaf;
    PTSTR nodePtr = NULL, nodeBegin = NULL;
    UINT strSize = 0;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node) {
            nodePtr = _tcsrchr (node, TEXT('\\'));
            if (nodePtr) {
                *nodePtr = 0;
                nodePtr ++;
            }
            nodeBegin = (PTSTR)node;
            while (*nodeBegin == TEXT('\\')) {
                nodeBegin ++;
            }
            if (nodePtr) {
                strSize = CharCount (nodePtr) +         \
                          CharCount (TEXT(" on ")) +    \
                          CharCount (nodeBegin) +       \
                          1;
                result = IsmGetMemory (strSize * sizeof (TCHAR));
                _tcscpy (result, nodePtr);
                _tcscat (result, TEXT(" on "));
                _tcscat (result, nodeBegin);
            } else {
                strSize = CharCount (nodeBegin) +       \
                          1;
                result = IsmGetMemory (strSize * sizeof (TCHAR));
                _tcscpy (result, nodeBegin);
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

PMIG_CONTENT
ConvertPrinterContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Printer content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (PRINTER_DATAW));
            if (result->MemoryContent.ContentBytes) {
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->Default =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->Default;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmFields =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmFields;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmOrientation =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmOrientation;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPaperSize =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPaperSize;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPaperLength =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPaperLength;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPaperWidth =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPaperWidth;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPosition.x =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPosition.x;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPosition.y =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPosition.y;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmScale =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmScale;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmCopies =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmCopies;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDefaultSource =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDefaultSource;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPrintQuality =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPrintQuality;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmColor =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmColor;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDuplex =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDuplex;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmYResolution =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmYResolution;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmTTOption =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmTTOption;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmCollate =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmCollate;
                DirectDbcsToUnicodeN (
                    ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmFormName,
                    ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmFormName,
                    CCHFORMNAME
                    );
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmLogPixels =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmLogPixels;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmBitsPerPel =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmBitsPerPel;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPelsWidth =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPelsWidth;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPelsHeight =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPelsHeight;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDisplayFlags =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDisplayFlags;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmNup =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmNup;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDisplayFrequency =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDisplayFrequency;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmICMMethod =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmICMMethod;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmICMIntent =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmICMIntent;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmMediaType =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmMediaType;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDitherType =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDitherType;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPanningWidth =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPanningWidth;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPanningHeight =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPanningHeight;
                result->MemoryContent.ContentSize = sizeof (PRINTER_DATAW);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertPrinterContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Printer content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (PRINTER_DATAW));
            if (result->MemoryContent.ContentBytes) {
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->Default =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->Default;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmFields =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmFields;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmOrientation =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmOrientation;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPaperSize =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPaperSize;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPaperLength =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPaperLength;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPaperWidth =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPaperWidth;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPosition.x =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPosition.x;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPosition.y =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPosition.y;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmScale =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmScale;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmCopies =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmCopies;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDefaultSource =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDefaultSource;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPrintQuality =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPrintQuality;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmColor =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmColor;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDuplex =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDuplex;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmYResolution =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmYResolution;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmTTOption =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmTTOption;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmCollate =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmCollate;
                DirectUnicodeToDbcsN (
                    ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmFormName,
                    ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmFormName,
                    CCHFORMNAME
                    );
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmLogPixels =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmLogPixels;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmBitsPerPel =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmBitsPerPel;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPelsWidth =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPelsWidth;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPelsHeight =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPelsHeight;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDisplayFlags =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDisplayFlags;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmNup =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmNup;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDisplayFrequency =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDisplayFrequency;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmICMMethod =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmICMMethod;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmICMIntent =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmICMIntent;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmMediaType =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmMediaType;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDitherType =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDitherType;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPanningWidth =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPanningWidth;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPanningHeight =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPanningHeight;
                result->MemoryContent.ContentSize = sizeof (PRINTER_DATAA);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedPrinterContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\unctrans\ansi\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\unctrans\unicode\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\unctrans\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tmlrel.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\unctrans\sources.inc ===
!include ..\..\modules.mk

MINORCOMP=unctrans

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\inftrans.c       \
    ..\unctrans.rc      \
    ..\opaque.c         \
    ..\entry.c          \
    ..\logmsg.mc        \


DLLENTRY=_DllMainCRTStartup
DLLBASE=0x02900000
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \
            $(COBRA_ROOT)\lib\$(O)\cablib.lib       \
            $(SDK_LIB_PATH)\cabinet.lib

PRECOMPILED_INCLUDE=pch.h

DLLDEF=..\unctrans.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\unctrans\entry.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the DLL entry point that provides all Cobra module entry points
    to the engine.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "unctrans.h"

typedef struct {
    PCTSTR Name;
    TRANSPORT_ENTRYPOINTS EntryPoints;
} TRANSPORT_TABLE, *PTRANSPORT_TABLE;

#define NOPROGBAR NULL
#define NORESET NULL
#define NORESUME NULL

//
// Add an entry for each transport module in the DLL
//

TRANSPORT_TABLE g_TransportEntryPoints[] = {
    {   TEXT("INF_BASED_UNC_TRANSPORT"), ISM_VERSION,
        InfTransTransportInitialize,
        InfTransTransportEstimateProgressBar,
        InfTransTransportQueryCapabilities,
        InfTransTransportSetStorage,
        NORESET,
        InfTransTransportTerminate,
        InfTransTransportSaveState,
        NORESUME,
        InfTransTransportBeginApply,
        NORESUME,
        InfTransTransportAcquireObject,
        InfTransTransportReleaseObject,
        InfTransTransportEndApply
    },

    {   TEXT("OPAQUE_UNC_TRANSPORT"), ISM_VERSION,
        OpaqueTransportInitialize,
        OpaqueTransportEstimateProgressBar,
        OpaqueTransportQueryCapabilities,
        OpaqueTransportSetStorage,
        NORESET,
        OpaqueTransportTerminate,
        OpaqueTransportSaveState,
        NORESUME,
        OpaqueTransportBeginApply,
        NORESUME,
        OpaqueTransportAcquireObject,
        OpaqueTransportReleaseObject,
        OpaqueTransportEndApply
    },

    {NULL}
};

EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }

    return TRUE;
}


EXPORT
BOOL
WINAPI
ModuleInitialize (
    VOID
    )
{
    TCHAR memDbDir[MAX_PATH];

    UtInitialize (NULL);

    IsmGetTempDirectory (memDbDir, ARRAYSIZE (memDbDir));
    if (!MemDbInitializeEx (memDbDir)) {
        DEBUGMSG ((DBG_ERROR, "Failing to initialize unc transports because MemDb failed to initialize"));
        IsmSetCancel();
        return FALSE;
    }

    InfGlobalInit (FALSE);

    return TRUE;
}

EXPORT
VOID
WINAPI
ModuleTerminate (
    VOID
    )
{
    InfGlobalInit (TRUE);
    MemDbTerminateEx (TRUE);
    UtTerminate ();
}


BOOL
WINAPI
pFindModule (
    IN      PCTSTR ModuleId,
    OUT     PVOID IsmBuffer,
    IN      PCTSTR *TableEntry,
    IN      UINT StructureSize
    )
{

    while (*TableEntry) {
        if (StringIMatch (*TableEntry, ModuleId)) {
            CopyMemory (
                IsmBuffer,
                (PBYTE) (TableEntry + 1),
                StructureSize
                );
            return TRUE;
        }

        TableEntry = (PCTSTR *) ((PBYTE) (TableEntry + 1) + StructureSize);
    }

    return FALSE;
}



EXPORT
BOOL
WINAPI
TransportModule (
    IN      PCTSTR ModuleId,
    IN OUT  PTRANSPORT_ENTRYPOINTS TransportEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) TransportEntryPoints,
                (PCTSTR *) g_TransportEntryPoints,
                sizeof (TRANSPORT_ENTRYPOINTS)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\unctrans\opaque.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    opaque.c

Abstract:

    Implements a basic secure server transport module

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"

#define DBG_OPAQUE   "OpaqueUnc"

//
// Strings
//

#define S_TRANSPORT_DIR         TEXT("USMT2.UNC")
#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")
#define S_TRANSPORT_DSK_FILE    TEXT("DSK%05X")
#define S_TRANSPORT_STATUS_FILE TEXT("status")
#define S_FILEOBJECT_NAME       TEXT("File")
#define S_REGOBJECT_NAME        TEXT("Registry")
#define S_DATABASEOBJECT_NAME   TEXT("Database")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//

#define TRFLAG_FILE     0x01
#define TRFLAG_MEMORY   0x02
#define OPAQUETR_SIG    0x55534D32  //USM2

#define TRSTATUS_DIRTY  0x00000001
#define TRSTATUS_READY  0x00000002
#define TRSTATUS_LOCKED 0x00000003

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_ReliableStorageId;
PCTSTR g_TransportPath = NULL;
PCTSTR g_TransportTempPath = NULL;
PCTSTR g_TransportStatus = NULL;
HANDLE g_TransportStatusHandle = NULL;
BOOL g_OtCompressData = FALSE;
UINT g_Platform;
MIG_PROGRESSSLICEID g_DatabaseSlice;
MIG_PROGRESSSLICEID g_PersistentSlice;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pOtSaveAllState (
    IN      BOOL Compressed
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pSetOpaqueTransportStatus (
    IN      HANDLE TrJournalHandle,
    IN      BOOL Compressed,
    IN      DWORD Status
    )
{
    DWORD signature = OPAQUETR_SIG;
    BOOL result = FALSE;

    if (BfSetFilePointer (TrJournalHandle, 0)) {
        result = TRUE;
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&signature), sizeof (DWORD));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Compressed), sizeof (BOOL));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Status), sizeof (DWORD));
        result = result && FlushFileBuffers (TrJournalHandle);
    }
    return result;
}

DWORD
pGetOpaqueTransportStatus (
    IN      PCTSTR TrJournal,
    OUT     PBOOL Compressed    OPTIONAL
    )
{
    HANDLE trJrnHandle;
    BOOL compressed = FALSE;
    DWORD signature = 0;
    DWORD error;
    DWORD result = 0;

    if (TrJournal && TrJournal [0]) {
        trJrnHandle = BfOpenReadFile (TrJournal);
        if (trJrnHandle) {
            if (BfSetFilePointer (trJrnHandle, 0)) {
                if (BfReadFile (trJrnHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    if (signature == OPAQUETR_SIG) {
                        if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                            BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                        }
                    }
                }
            }
            CloseHandle (trJrnHandle);
        } else {
            error = GetLastError ();
            if ((error == ERROR_ACCESS_DENIED) ||
                (error == ERROR_SHARING_VIOLATION)
                ) {
                result = TRSTATUS_LOCKED;
            }
        }
    }
    if (Compressed) {
        *Compressed = compressed;
    }
    return result;
}

PCTSTR
pGetOpaqueImageFile (
    IN      PCTSTR BasePath,
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (BasePath, imageFileName);
}

PCTSTR
pGetRealTransportPath (
    VOID
    )
{
    return g_OtCompressData?g_TransportTempPath:g_TransportPath;
}

BOOL
WINAPI
OpaqueTransportInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_ReliableStorageId = IsmRegisterTransport (S_RELIABLE_STORAGE_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
OpaqueTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    MIG_OBJECTSTRINGHANDLE pattern;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on
        // the count of the persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        ticks = 0;

        pattern = IsmCreateObjectPattern (ALL_PATTERN, 0, ALL_PATTERN, 0);

        IsmDestroyObjectHandle (pattern);

        g_DatabaseSlice = IsmRegisterProgressSlice (ticks, ticks * 3);

    } else {
        //
        // If restoring, we have almost no work to account for, since
        // we download from the secure server file-by-file.
        //

        DEBUGMSG ((DBG_VERBOSE, "Assuming transport download has no progress impact"));
    }
}

BOOL
WINAPI
OpaqueTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_ReliableStorageId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED;
    *FriendlyDescription = TEXT("Local computer or another computer on the Network");
    return TRUE;
}

VOID
pOtCleanUpTempDir (
    VOID
    )
{
    if (g_TransportTempPath) {
        FiRemoveAllFilesInTree (g_TransportTempPath);
    }
}

PCTSTR
pOtCreateTemporaryDir (
    VOID
    )
{
    TCHAR tempFile[MAX_PATH];

    if (!IsmGetTempDirectory (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }
    return DuplicatePathString (tempFile, 0);
}

BOOL
WINAPI
OpaqueTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    PCTSTR transportPath;
    PCTSTR transportStatus;
    MIG_OBJECTSTRINGHANDLE encodedPath;
    DWORD status;
    BOOL result = FALSE;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_ReliableStorageId) {

        if ((!RequiredCapabilities) || (RequiredCapabilities == CAPABILITY_COMPRESSED)) {

            if (RequiredCapabilities == CAPABILITY_COMPRESSED) {
                g_OtCompressData = TRUE;
            } else {
                g_OtCompressData = FALSE;
            }

            transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
            transportStatus = JoinPaths (transportPath, S_TRANSPORT_STATUS_FILE);

            if (!DoesFileExist (transportPath)) {

                // we require UNC path or a full path (like c:\...)
                if (transportPath[0] == '\\' && transportPath[1] == '\\') {
                    // this is a UNC path
                    *Valid = TRUE;
                } else if (transportPath[1] == ':') {
                    // this is a normal full path
                    *Valid = TRUE;
                } else {
                    *Valid = FALSE;
                }

                *ImageExists = FALSE;

            } else {

                status = pGetOpaqueTransportStatus (transportStatus, NULL);

                switch (status) {
                case TRSTATUS_LOCKED:
                    *ImageExists = TRUE;
                    *Valid = FALSE;
                    break;
                case TRSTATUS_READY:
                    *ImageExists = TRUE;
                    *Valid = TRUE;
                    break;
                case TRSTATUS_DIRTY:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                    break;
                default:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                }
            }

            FreePathString (transportStatus);
            FreePathString (transportPath);
            result = TRUE;
        }
    }

    if (result && *Valid) {

        if (g_TransportPath) {
            FreePathString (g_TransportPath);
            g_TransportPath = NULL;
        }

        g_TransportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
        g_TransportStatus = JoinPaths (g_TransportPath, S_TRANSPORT_STATUS_FILE);

        encodedPath = IsmCreateSimpleObjectPattern (g_TransportPath, FALSE, NULL, FALSE);
        if (encodedPath) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, encodedPath);
            IsmDestroyObjectHandle (encodedPath);
        }
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportSaveState (
    VOID
    )
{
    DWORD status;
    BOOL result = FALSE;
    BOOL allowDelete = FALSE;

    if (!g_TransportPath) {
        DEBUGMSG ((DBG_ERROR, "Transport Path is not selected"));
        return FALSE;
    }

    if (DoesFileExist (g_TransportPath)) {

        status = pGetOpaqueTransportStatus (g_TransportStatus, NULL);

        switch (status) {
        case TRSTATUS_LOCKED:
            SetLastError (ERROR_ACCESS_DENIED);
            LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_TransportPath));
            return FALSE;
        case TRSTATUS_DIRTY:
            result = FiRemoveAllFilesInTree (g_TransportPath);
            if (!result) {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR, g_TransportPath));
                return FALSE;
            }
            break;
        case TRSTATUS_READY:
        default:
            if (IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_EXISTS, 0)) {
                if (!FiRemoveAllFilesInTree (g_TransportPath)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR, g_TransportPath));
                    return FALSE;
                }
            } else {
                LOG ((LOG_ERROR, (PCSTR) MSG_NOT_EMPTY, g_TransportPath));
                SetLastError (ERROR_ALREADY_EXISTS);
                return FALSE;
            }
            break;
        }
    }

    allowDelete = TRUE;

    if (!BfCreateDirectory (g_TransportPath)) {
        PushError ();
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_DIR, g_TransportPath));
        PopError ();
        return FALSE;
    }

    g_TransportStatusHandle = BfCreateFile (g_TransportStatus);
    if (!g_TransportStatusHandle) {
        PushError ();
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_STATUS_FILE, g_TransportStatus));
        PopError ();
        return FALSE;
    }

    pSetOpaqueTransportStatus (g_TransportStatusHandle, g_OtCompressData, TRSTATUS_DIRTY);

    g_Platform = PLATFORM_SOURCE;
    result = pOtSaveAllState (g_OtCompressData);

    if (result) {
        pSetOpaqueTransportStatus (g_TransportStatusHandle, g_OtCompressData, TRSTATUS_READY);
    }
    CloseHandle (g_TransportStatusHandle);
    g_TransportStatusHandle = NULL;

    if (allowDelete && (!result)) {
        FiRemoveAllFilesInTree (g_TransportPath);
    }

    return result;
}

BOOL
pOtReadAllImages (
    VOID
    )
{
    PCTSTR imageFile = NULL;
    UINT imageIdx = 1;
    OCABHANDLE cabHandle;
    BOOL result = TRUE;

    while (result) {
        imageFile = pGetOpaqueImageFile (g_TransportPath, imageIdx);
        if (!DoesFileExist (imageFile)) {
            FreePathString (imageFile);
            return TRUE;
        }
        cabHandle = CabOpenCabinet (imageFile);
        if (cabHandle) {
            if (!CabExtractAllFiles (cabHandle, g_TransportTempPath)) {
                result = FALSE;
            }
            CabCloseCabinet (cabHandle);
        }
        FreePathString (imageFile);
        imageIdx ++;
    }
    return result;
}

BOOL
WINAPI
OpaqueTransportBeginApply (
    VOID
    )
{
    DWORD status = 0;
    PCTSTR memDbFile;
    BOOL b;

    g_Platform = PLATFORM_DESTINATION;

    if (!g_TransportPath) {
        DEBUGMSG ((DBG_ERROR, "Transport Path is not selected"));
        return FALSE;
    }

    while (status != TRSTATUS_READY) {

        status = pGetOpaqueTransportStatus (g_TransportStatus, &g_OtCompressData);

        switch (status) {
        case TRSTATUS_LOCKED:
            if (!IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_LOCKED, 0)) {
                SetLastError (ERROR_ACCESS_DENIED);
                LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_TransportPath));
                return FALSE;
            }
            break;
        case TRSTATUS_DIRTY:
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
            return FALSE;
        case TRSTATUS_READY:
            break;
        default:
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
            return FALSE;
        }
    }

    g_TransportStatusHandle = BfOpenReadFile (g_TransportStatus);
    if (!g_TransportStatusHandle) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_STATUS_FILE, g_TransportStatus));
        return FALSE;
    }

    if (g_OtCompressData) {
        g_TransportTempPath = pOtCreateTemporaryDir ();

        if (!g_TransportTempPath) {
            CloseHandle (g_TransportStatusHandle);
            g_TransportStatusHandle = NULL;
            return FALSE;
        }

        if (!pOtReadAllImages ()) {
            CloseHandle (g_TransportStatusHandle);
            g_TransportStatusHandle = NULL;
            return FALSE;
        }
        CloseHandle (g_TransportStatusHandle);
        g_TransportStatusHandle = NULL;
    }

    memDbFile = JoinPaths (pGetRealTransportPath (), S_TRANSPORT_DAT_FILE);

    b = MemDbLoad (memDbFile);
    FreePathString (memDbFile);

    return b;
}

VOID
WINAPI
OpaqueTransportEndApply (
    VOID
    )
{
    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    if (g_OtCompressData) {
        pOtCleanUpTempDir ();
    } else {
        CloseHandle (g_TransportStatusHandle);
        g_TransportStatusHandle = NULL;
    }
}

VOID
WINAPI
OpaqueTransportTerminate (
    VOID
    )
{
    pOtCleanUpTempDir();

    if (g_TransportTempPath) {
        FreePathString (g_TransportTempPath);
        g_TransportTempPath = NULL;
    }
    if (g_TransportStatus) {
        FreePathString (g_TransportStatus);
        g_TransportStatus = NULL;
    }
    if (g_TransportPath) {
        FreePathString (g_TransportPath);
        g_TransportPath = NULL;
    }
}

static
VOID
pGetTempFileName (
    OUT     PTSTR Buffer
    )
{
    static fileIndex = 0;

    fileIndex ++;
    wsprintf (Buffer, TEXT("%08X.DAT"), fileIndex);
}

PCTSTR
pOpaqueAllocStorageFileName (
    IN      PCTSTR FileName         OPTIONAL
    )
{
    TCHAR buffer[32];

    if (FileName) {
        StringCopy (buffer, FileName);
    } else {
        pGetTempFileName (buffer);
    }

    return JoinPaths (g_TransportPath, buffer);
}

VOID
pFreeStorageFileName (
    IN      PCTSTR FileName
    )
{
    FreePathString (FileName);
}

BOOL
pOpaqueSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

    FreeText (key);

    return b;
}

BOOL
pOtAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR CabName,
    IN OUT  CCABHANDLE CabHandle
    )
{
    return CabAddFileToCabinet (CabHandle, FileName, CabName);
}

BOOL
pOtSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  CCABHANDLE CabHandle    OPTIONAL
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use the CopyFile API to move the file from local to storage.
    //

    __try {
        if (!Content->FileContent.ContentSize) {

            // this must be a directory, let's just write the key

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = pOpaqueAllocStorageFileName (NULL);
            if (!destPath) {
                __leave;
            }

            if (CabHandle) {
                if (!pOtAddFileToImage (Content->FileContent.ContentPath, GetFileNameFromPath (destPath), CabHandle)) {
                    __leave;
                }
            } else {
                if (!CopyFile (Content->FileContent.ContentPath, destPath, FALSE)) {
                    __leave;
                }
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, GetFileNameFromPath (destPath), 0)) {
                __leave;
            }
        }

        //
        // Save details
        //

        result = pOpaqueSaveDetails (DecoratedObject, &(Content->Details));

    }
    __finally {
        pFreeStorageFileName (destPath);
        INVALID_POINTER (destPath);
    }

    return result;
}

BOOL
pOtSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content
    )
{
    BOOL result = FALSE;

    MYASSERT (!Content->ContentInFile);
    if (Content->ContentInFile) {
        return FALSE;
    }

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (Content->MemoryContent.ContentBytes && Content->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            Content->MemoryContent.ContentBytes,
            Content->MemoryContent.ContentSize
            );
    }

    result = pOpaqueSaveDetails (DecoratedObject, &(Content->Details));

    return result;
}

PCTSTR
pOpaqueBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    PCTSTR typeStr;

    typeStr = IsmGetObjectTypeName (ObjectTypeId);
    if (!typeStr) {
        return NULL;
    }

    return JoinPaths (typeStr, ObjectName);
}

VOID
pOtDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pOtWriteAllImages (
    VOID
    )
{
    UINT imageIdx = 1;
    PCTSTR imageFile;
    PCTSTR imageDest;
    BOOL result = FALSE;

    while (TRUE) {
        imageFile = pGetOpaqueImageFile (g_TransportTempPath, imageIdx);
        imageDest = pGetOpaqueImageFile (g_TransportPath, imageIdx);
        if (DoesFileExist (imageFile)) {
            if (!CopyFile (imageFile, imageDest, FALSE)) {
                break;
            }
        } else {
            result = TRUE;
            break;
        }
        FreePathString (imageDest);
        FreePathString (imageFile);
        imageIdx ++;
    }
    return result;
}

BOOL
pOtSaveAllState (
    IN      BOOL Compressed
    )
{
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    ULONGLONG size;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR ourDbFile = NULL;
    PCTSTR decoratedObject = NULL;
    ULONGLONG bytesSaved = 0;
    UINT lastTick = GetTickCount();
    TCHAR text[64];
    UINT fraction;
    CCABHANDLE cabHandle = NULL;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
    BOOL result = FALSE;

    __try {

        if (Compressed) {
            g_TransportTempPath = pOtCreateTemporaryDir ();

            if (!g_TransportTempPath) {
                __leave;
            }

            cabHandle = CabCreateCabinet (g_TransportTempPath, S_TRANSPORT_IMG_FILE, S_TRANSPORT_DSK_FILE, IsmGetTempFile, 0);
            if (!cabHandle) {
                __leave;
            }
        }

        //
        // Enumerate all objects with "save" attribute
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((
                                LOG_WARNING,
                                (PCSTR) MSG_IGNORE_COPYSOURCE,
                                transCopyError.ObjectName,
                                GetLastError (),
                                GetLastError ()
                                ));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = pOpaqueBuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pOtSaveContentInFile (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue, cabHandle)) {

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((
                                        LOG_WARNING,
                                        (PCSTR) MSG_IGNORE_COPYSOURCE,
                                        transCopyError.ObjectName,
                                        GetLastError (),
                                        GetLastError ()
                                        ));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->FileContent.ContentSize;
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pOtSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((
                                        LOG_WARNING,
                                        (PCSTR) MSG_IGNORE_COPYSOURCE,
                                        transCopyError.ObjectName,
                                        GetLastError (),
                                        GetLastError ()
                                        ));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->MemoryContent.ContentSize;
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    pOtDestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                if (!IsmTickProgressBar (g_PersistentSlice, 1)) {
                    IsmAbortPersistentObjectEnum (&objEnum);
                    __leave;
                }

                //
                // Send bytes saved to app every 3 seconds
                //

                bytesSaved += size;

                if (GetTickCount() - lastTick > 3000) {

                    if (bytesSaved < 1048576) {
                        wsprintf (text, TEXT("Saved: %u K"), (UINT) (bytesSaved / 1024));
                    } else if (bytesSaved < 8388608) {
                        fraction = (UINT) (bytesSaved / 10485);
                        wsprintf (text, TEXT("Saved: %u.%02u M"), fraction / 100, fraction % 100);
                    } else if (bytesSaved < 1073741824) {
                        wsprintf (text, TEXT("Saved: %u M"), (UINT) (bytesSaved / 1048576));
                    } else {
                        fraction = (UINT) (bytesSaved / 10737418);
                        wsprintf (text, TEXT("Saved: %u.%02u G"), fraction / 100, fraction % 100);
                    }

                    IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, (ULONG_PTR) text);

                    lastTick = GetTickCount();
                }

            } while (IsmEnumNextPersistentObject (&objEnum));
        }

        if (Compressed) {
            ourDbFile = JoinPaths (g_TransportTempPath, S_TRANSPORT_DAT_FILE);
        } else {
            ourDbFile = pOpaqueAllocStorageFileName (S_TRANSPORT_DAT_FILE);
            if (!ourDbFile) {
                __leave;
            }
        }

        if (!MemDbSave (ourDbFile)) {
            __leave;
        }

        if (Compressed) {
            if (!pOtAddFileToImage (ourDbFile, S_TRANSPORT_DAT_FILE, cabHandle)) {
                __leave;
            }
            if (!CabFlushAndCloseCabinet (cabHandle)) {
                __leave;
            }
            if (!pOtWriteAllImages ()) {
                __leave;
            }
        }

        IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, 0);
        result = TRUE;

    }
    __finally {
        pFreeStorageFileName (ourDbFile);
        INVALID_POINTER (ourDbFile);

        pOtDestroyDecoratedObject (decoratedObject);
        INVALID_POINTER (decoratedObject);

        if (g_OtCompressData && g_TransportTempPath) {
            pOtCleanUpTempDir ();
        }
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,                 CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_Platform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pOpaqueBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = JoinPaths (pGetRealTransportPath (), fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = JoinPaths (pGetRealTransportPath (), fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreePathString (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                MemDbReleaseMemory (fileValue);
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
OpaqueTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\unctrans\inftrans.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    inftrans.c

Abstract:

    Implements a basic secure server transport module

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <conio.h>

#define DBG_INFTRANS      "InfTrans"

//
// Strings
//

#define S_TRANSPORT_DIR             TEXT("USMT2I.UNC")
#define S_TRANSPORT_DIR_E           TEXT("USMT2E.UNC")
#define S_TRANSPORT_INF_FILE        TEXT("migration.inf")
#define S_TRANSPORT_STATUS_FILE     TEXT("status")
#define S_TRANSPORT_ESTIMATE_FILE   TEXT("USMTSIZE.TXT")
#define S_DETAILS_PREFIX            TEXT("details")

#define S_DATABASEFILE_LITE TEXT("|MainDatabaseFile\\LITE")   // pipe is to decorate for uniqueness

//
// Constants
//

#define TRFLAG_FILE     0x01
#define TRFLAG_MEMORY   0x02
#define INFTR_SIG       0x55534D32  //USM2

#define TRSTATUS_DIRTY  0x00000001
#define TRSTATUS_READY  0x00000002
#define TRSTATUS_LOCKED 0x00000003

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

typedef struct {
    UINT ClusterSize;
    ULONGLONG StoreSize;
} ESTIMATE_SIZE, *PESTIMATE_SIZE;

//
// Globals
//

BOOL g_EstimateSizeOnly = FALSE;
MIG_TRANSPORTSTORAGEID g_ReliableStorageId;
PCTSTR g_InfTransStoragePath = NULL;
PCTSTR g_InfTransTransportPath = NULL;
PCTSTR g_InfTransTransportStatus = NULL;
HANDLE g_InfTransTransportStatusHandle = NULL;
UINT g_Platform;
MIG_PROGRESSSLICEID g_DatabaseSlice;
MIG_PROGRESSSLICEID g_PersistentSlice;
ESTIMATE_SIZE g_EstimateSize [] =
    {
    {512,       0},
    {1024,      0},
    {2048,      0},
    {4096,      0},
    {8192,      0},
    {16384,     0},
    {32768,     0},
    {65536,     0},
    {131072,    0},
    {262144,    0},
    {524288,    0},
    {1048576,   0},
    {0,         0}
    };

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// see unctrans.h

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
pSetInfTransStatus (
    IN      HANDLE TrJournalHandle,
    IN      DWORD Status
    )
{
    DWORD signature = INFTR_SIG;
    BOOL result = FALSE;

    if (BfSetFilePointer (TrJournalHandle, 0)) {
        result = TRUE;
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&signature), sizeof (DWORD));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Status), sizeof (DWORD));
        result = result && FlushFileBuffers (TrJournalHandle);
    }
    return TRUE;
}

DWORD
pGetInfTransStatus (
    IN      PCTSTR TrJournal
    )
{
    HANDLE trJrnHandle;
    DWORD signature = 0;
    DWORD error;
    DWORD result = 0;

    if (TrJournal && TrJournal [0]) {
        trJrnHandle = BfOpenReadFile (TrJournal);
        if (trJrnHandle) {
            if (BfSetFilePointer (trJrnHandle, 0)) {
                if (BfReadFile (trJrnHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    if (signature == INFTR_SIG) {
                        if (!BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD))) {
                            result = 0;
                        }
                    }
                }
            }
            CloseHandle (trJrnHandle);
        } else {
            error = GetLastError ();
            if ((error == ERROR_ACCESS_DENIED) ||
                (error == ERROR_SHARING_VIOLATION)
                ) {
                result = TRSTATUS_LOCKED;
            }
        }
    }
    return result;
}

BOOL
WINAPI
InfTransTransportInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_ReliableStorageId = IsmRegisterTransport (S_RELIABLE_STORAGE_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
InfTransTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    DEBUGMSG ((DBG_VERBOSE, "Assuming transport download has no progress impact"));
}

BOOL
WINAPI
InfTransTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_ReliableStorageId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_LIGHT;
    *Capabilities = CAPABILITY_SPACEESTIMATE;
    *FriendlyDescription = TEXT("Another Computer on the Network");
    return TRUE;
}

BOOL
WINAPI
InfTransTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    PCTSTR transportPath;
    PCTSTR transportStatus;
    MIG_OBJECTSTRINGHANDLE encodedPath;
    DWORD status;
    BOOL result = FALSE;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_ReliableStorageId) {

        if (!RequiredCapabilities ||
            (RequiredCapabilities & CAPABILITY_SPACEESTIMATE)
            ) {

            if (RequiredCapabilities & CAPABILITY_SPACEESTIMATE) {
                g_EstimateSizeOnly = TRUE;
            }

            if (g_EstimateSizeOnly) {
                transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR_E);
            } else {
                transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
            }
            transportStatus = JoinPaths (transportPath, S_TRANSPORT_STATUS_FILE);

            if (!DoesFileExist (transportPath)) {

                // we require UNC path or a full path (like c:\...)
                if (transportPath[0] == '\\' && transportPath[1] == '\\') {
                    // this is a UNC path
                    *Valid = TRUE;
                } else if (transportPath[1] == ':') {
                    // this is a normal full path
                    *Valid = TRUE;
                } else {
                    *Valid = FALSE;
                }

                *ImageExists = FALSE;

            } else {

                status = pGetInfTransStatus (transportStatus);

                switch (status) {
                case TRSTATUS_LOCKED:
                    *ImageExists = TRUE;
                    *Valid = FALSE;
                    break;
                case TRSTATUS_READY:
                    *ImageExists = TRUE;
                    *Valid = TRUE;
                    break;
                case TRSTATUS_DIRTY:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                    break;
                default:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                }
            }

            FreePathString (transportStatus);
            FreePathString (transportPath);
            result = TRUE;
        }
    }

    if (result && *Valid) {

        if (g_InfTransStoragePath) {
            FreePathString (g_InfTransStoragePath);
            g_InfTransStoragePath = NULL;
        }

        if (g_InfTransTransportPath) {
            FreePathString (g_InfTransTransportPath);
            g_InfTransTransportPath = NULL;
        }

        g_InfTransStoragePath = DuplicatePathString (StoragePath, 0);
        if (g_EstimateSizeOnly) {
            g_InfTransTransportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR_E);
        } else {
            g_InfTransTransportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
        }
        g_InfTransTransportStatus = JoinPaths (g_InfTransTransportPath, S_TRANSPORT_STATUS_FILE);

        encodedPath = IsmCreateSimpleObjectPattern (g_InfTransTransportPath, FALSE, NULL, FALSE);
        if (encodedPath) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, encodedPath);
            IsmDestroyObjectHandle (encodedPath);
        }
    }

    return result;
}

BOOL
pInfTransSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

    FreeText (key);

    return b;
}

PCTSTR
pInfTransBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    TCHAR prefix[32];

    wsprintf (prefix, TEXT("%u"), ObjectTypeId & (~PLATFORM_MASK));

    return JoinPaths (prefix, ObjectName);
}


VOID
pInfTransDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pObjectNameToFileName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PCTSTR *FileName,
    OUT     PCTSTR *DirName     OPTIONAL
    )
{
    PCTSTR node, leaf;
    PCTSTR newNode, dirName;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        newNode = StringSearchAndReplace (node, TEXT(":"), TEXT(""));
        if (newNode) {
            result = TRUE;
            if (leaf) {
                dirName = JoinPaths (g_InfTransTransportPath, newNode);
                *FileName = JoinPaths (dirName, leaf);
                if (!DirName) {
                    FreePathString (dirName);
                } else {
                    *DirName = dirName;
                }
                FreePathString (newNode);
            } else {
                *FileName = JoinPaths (g_InfTransTransportPath, newNode);
                if (DirName) {
                    *DirName = *FileName;
                }
                FreePathString (newNode);
            }
        } else {
            dirName = JoinPaths (g_InfTransTransportPath, node);
            *FileName = JoinPaths (dirName, leaf);
            FreePathString (dirName);
            if (DirName) {
                *DirName = JoinPaths (g_InfTransTransportPath, node);
            }
            result = TRUE;
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
pIsShortFileName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR TempDir
    )
{
    PCTSTR nativeFileName;
    PCTSTR fileNamePtr;
    PCTSTR testFileName;
    HANDLE fileHandle;
    WIN32_FIND_DATA fileInfo;
    BOOL result = FALSE;

    nativeFileName = IsmGetNativeObjectName (ObjectTypeId, ObjectName);
    if (nativeFileName) {
        fileNamePtr = GetFileNameFromPath (nativeFileName);
        if (fileNamePtr) {
            testFileName = JoinPaths (TempDir, fileNamePtr);
            fileHandle = BfCreateFile (testFileName);
            if (fileHandle) {
                CloseHandle (fileHandle);
                if (DoesFileExistEx (testFileName, &fileInfo)) {
                    result = (fileInfo.cAlternateFileName [0] == 0) ||
                             StringIMatch (fileInfo.cFileName, fileInfo.cAlternateFileName);
                }
                DeleteFile (testFileName);
            }
        }
        IsmReleaseMemory (nativeFileName);
    }
    return result;
}

UINT
pGetClusterSize (
    IN      PCTSTR  Path
    )
{
    PTSTR drivePath = NULL;
    PTSTR wackPtr;
    DWORD sectPerClust = 0;
    DWORD bytesPerSect = 0;
    DWORD freeClust = 0;
    DWORD totalClust = 0;
    UINT result = 0;
    DWORD err = 0;

    if (!Path) {
        return result;
    }

    // if this is a UNC drive
    if (Path [0] && (Path [0] == TEXT('\\')) && (Path [1] == TEXT('\\'))) {
        // we need to leave exactly 2 segments (like \\server\share) and
        // add a wack at the end
        drivePath = DuplicatePathString (Path, 1);
        // we know the first two characters are wacks. Wack is a single byte
        // character so the next call is safe
        wackPtr = _tcschr (drivePath + 2, TEXT('\\'));
        if (wackPtr) {
            wackPtr = _tcsinc (wackPtr);
            if (wackPtr) {
                wackPtr = _tcschr (wackPtr, TEXT('\\'));
                if (wackPtr) {
                    // there are more than two segments here
                    // wack is a single byte char so this is safe
                    *wackPtr = 0;
                }
                AppendWack (drivePath);
            } else {
                // something is wrong, we could not advance one character?
                FreePathString (drivePath);
                drivePath = NULL;
            }
        } else {
            // something is wrong, we don't even have one segment
            FreePathString (drivePath);
            drivePath = NULL;
        }
    } else {
        if (Path [0] && (Path [1] == TEXT (':')) && (Path [2] == TEXT ('\\'))) {
            drivePath = DuplicatePathString (Path, 0);
            drivePath [3] = 0;
        }
    }

    if (drivePath) {
        if (GetDiskFreeSpace (drivePath, &sectPerClust, &bytesPerSect, &freeClust, &totalClust)) {
            result = bytesPerSect * sectPerClust;
        } else {
            LOG ((LOG_WARNING, (PCSTR) MSG_CLUSTER_SIZE_ERROR, GetLastError ()));
        }
        FreePathString (drivePath);
        drivePath = NULL;
    }

    return result;
}

BOOL
pStoreStatusOK (
    IN      PCTSTR StorePath,
    IN      PCTSTR StoreStatusPath
    )
{
    DWORD status;
    BOOL result = FALSE;

    if (DoesFileExist (StorePath)) {

        status = pGetInfTransStatus (StoreStatusPath);

        switch (status) {
        case TRSTATUS_LOCKED:
            SetLastError (ERROR_ACCESS_DENIED);
            LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, StorePath));
            return FALSE;
        case TRSTATUS_DIRTY:
            result = FiRemoveAllFilesInTree (StorePath);
            if (!result) {
                PushError ();
                SetLastError (ERROR_ACCESS_DENIED);
                LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, StorePath));
                PopError ();
                return FALSE;
            }
            break;
        case TRSTATUS_READY:
        default:
            if (IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_EXISTS, 0)) {
                result = FiRemoveAllFilesInTree (StorePath);
                if (!result) {
                    PushError ();
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR , StorePath));
                    PopError ();
                    return FALSE;
                }
            } else {
                SetLastError (ERROR_ALREADY_EXISTS);
                LOG ((LOG_ERROR, (PCSTR) MSG_NOT_EMPTY, StorePath));
                return FALSE;
            }
            break;
        }
    }

    if (!BfCreateDirectory (StorePath)) {
        PushError ();
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_DIR, StorePath));
        PopError ();
        return FALSE;
    }

    g_InfTransTransportStatusHandle = BfCreateFile (StoreStatusPath);
    if (!g_InfTransTransportStatusHandle) {
        PushError ();
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_STATUS_FILE, StoreStatusPath));
        PopError ();
        return FALSE;
    }

    pSetInfTransStatus (g_InfTransTransportStatusHandle, TRSTATUS_DIRTY);

    return TRUE;
}

BOOL
pWriteEstimateFile (
    VOID
    )
{
    PCTSTR infFile = NULL;
    HANDLE infFileHandle = NULL;
    PCTSTR estimateFile = NULL;
    HANDLE estimateFileHandle = NULL;
    UINT index = 0;
    LONGLONG fileSize = 0;
    UINT currClusterSize = 0;
    ULONGLONG currStoreSize = 0;
    TCHAR estimateBuff1 [MAX_PATH];
    TCHAR estimateBuff2 [MAX_PATH];
    BOOL result = TRUE;

    // now it's a good time to add all other files that we used to
    // the estimate, delete them and then write the estimate file
    // in the root of the transport directory (g_InfTransStoragePath)

    // let's add the status file to the estimate
    if (g_InfTransTransportStatus) {
        fileSize = BfGetFileSize (g_InfTransTransportStatus);
        if (fileSize) {
            index = 0;
            while (TRUE) {
                if (g_EstimateSize [index].ClusterSize == 0) {
                    break;
                }
                g_EstimateSize [index].StoreSize +=
                    ((fileSize / g_EstimateSize [index].ClusterSize) + 1) * g_EstimateSize [index].ClusterSize;
                index ++;
            }
        }
    }

    // OK, now let's add the migration.inf file to the estimate
    infFile = JoinPaths (g_InfTransTransportPath, S_TRANSPORT_INF_FILE);
    if (infFile) {
        fileSize = BfGetFileSize (infFile);
        if (fileSize) {
            index = 0;
            while (TRUE) {
                if (g_EstimateSize [index].ClusterSize == 0) {
                    break;
                }
                g_EstimateSize [index].StoreSize +=
                    ((fileSize / g_EstimateSize [index].ClusterSize) + 1) * g_EstimateSize [index].ClusterSize;
                index ++;
            }
        }
        FreePathString (infFile);
        infFile = NULL;
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_ISM_INF));
        result = FALSE;
    }

    if (result) {

        // Now, let's delete the USMT2E.UNC directory
        FiRemoveAllFilesInTree (g_InfTransTransportPath);

        // Finally, let's write the estimate file
        estimateFile = JoinPaths (g_InfTransStoragePath, S_TRANSPORT_ESTIMATE_FILE);
        if (estimateFile) {
            if (DoesFileExist (estimateFile)) {
                if (IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_EXISTS, 0)) {
                    result = DeleteFile (estimateFile);
                } else {
                    SetLastError (ERROR_ALREADY_EXISTS);
                    LOG ((LOG_ERROR, (PCSTR) MSG_NOT_EMPTY, estimateFile));
                    result = FALSE;
                }
            }
            if (result) {
                estimateFileHandle = BfCreateFile (estimateFile);
                if (estimateFileHandle && (estimateFileHandle != INVALID_HANDLE_VALUE)) {
                    // finally, let's write the stuff

                    // first write the requirement for current cluster size
                    currClusterSize = pGetClusterSize (g_InfTransStoragePath);
                    if (currClusterSize) {
                        currStoreSize = 0;
                        index = 0;
                        while (TRUE) {
                            if (g_EstimateSize [index].ClusterSize == 0) {
                                break;
                            }
                            if (g_EstimateSize [index].ClusterSize == currClusterSize) {
                                currStoreSize = g_EstimateSize [index].StoreSize;
                                break;
                            }
                            index ++;
                        }
                    }
                    _ui64tot (
                        currStoreSize,
                        estimateBuff2,
                        10
                        );
                    wsprintf (
                        estimateBuff1,
                        TEXT("%u\t%s\r\n"),
                        currClusterSize,
                        estimateBuff2
                        );
                    WriteFileString (estimateFileHandle, estimateBuff1);


                    // then write all cluster sizes
                    index = 0;
                    while (TRUE) {
                        if (g_EstimateSize [index].ClusterSize == 0) {
                            break;
                        }
                        _ui64tot (
                            g_EstimateSize [index].StoreSize,
                            estimateBuff2,
                            10
                            );
                        wsprintf (
                            estimateBuff1,
                            TEXT("%u\t%s\r\n"),
                            g_EstimateSize [index].ClusterSize,
                            estimateBuff2
                            );
                        WriteFileString (estimateFileHandle, estimateBuff1);
                        index ++;
                    }
                    CloseHandle (estimateFileHandle);
                } else {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_ESTIMATE_FILE));
                    result = FALSE;
                }
            } else {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_ESTIMATE_FILE));
            }
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_ESTIMATE_FILE));
            result = FALSE;
        }
    }

    return result;
}

BOOL
pAddFileSize (
    IN      PCTSTR FileName
    )
{
    UINT index = 0;
    LONGLONG fileSize = 0;

    fileSize = BfGetFileSize (FileName);
    if (fileSize) {
        index = 0;
        while (TRUE) {
            if (g_EstimateSize [index].ClusterSize == 0) {
                break;
            }
            g_EstimateSize [index].StoreSize +=
                ((fileSize / g_EstimateSize [index].ClusterSize) + 1) * g_EstimateSize [index].ClusterSize;
            index ++;
        }
    }
    return TRUE;
}

BOOL
pAddOneCluster (
    VOID
    )
{
    UINT index = 0;
    LONGLONG fileSize = 0;

    index = 0;
    while (TRUE) {
        if (g_EstimateSize [index].ClusterSize == 0) {
            break;
        }
        g_EstimateSize [index].StoreSize += g_EstimateSize [index].ClusterSize;
        index ++;
    }
    return TRUE;
}

BOOL
pSaveObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      BOOL ForceNoncritical,
    IN OUT  PGROWBUFFER Buffer
    )
{
    MIG_CONTENT objectContent;
    TRANSCOPY_ERROR transCopyError;
    INT_PTR appReply;
    PCTSTR objMultiSz;
    MULTISZ_ENUM multiSzEnum;
    BOOL firstMultiSz;
    PTSTR encodedString = NULL;
    PCTSTR fileName;
    PCTSTR dirName;
    PCTSTR nativeObjectName;
    BOOL okSave = FALSE;
    BOOL forceLogError = FALSE;

    okSave = FALSE;
    while (!okSave) {

        if (!IsmAcquireObjectEx (
                ObjectTypeId,
                ObjectName,
                &objectContent,
                CONTENTTYPE_ANY,
                0
                )) {

            transCopyError.ObjectType = IsmGetObjectTypeName (ObjectTypeId);
            transCopyError.ObjectName = IsmGetNativeObjectName (ObjectTypeId, ObjectName);
            transCopyError.Error = GetLastError ();

            if (ForceNoncritical || IsmIsNonCriticalObject (ObjectTypeId, ObjectName)) {
                appReply = APPRESPONSE_IGNORE;
            } else {
                appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                if ((appReply == APPRESPONSE_NONE) ||
                    (appReply == APPRESPONSE_FAIL)
                    ) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                    IsmReleaseMemory (transCopyError.ObjectName);
                    return FALSE;
                }
            }
            if (appReply == APPRESPONSE_IGNORE) {
                LOG ((
                    LOG_WARNING,
                    (PCSTR) MSG_IGNORE_COPYSOURCE,
                    transCopyError.ObjectName,
                    GetLastError (),
                    GetLastError ()
                    ));
                IsmReleaseMemory (transCopyError.ObjectName);
                break;
            }
            IsmReleaseMemory (transCopyError.ObjectName);
            continue;
        }
        okSave = TRUE;
    }

    if (okSave) {

        // we have an object let's write it to the migration.inf
        objMultiSz = IsmConvertObjectToMultiSz (
                        ObjectName,
                        &objectContent
                        );
        if (objMultiSz) {
            if (EnumFirstMultiSz (&multiSzEnum, objMultiSz)) {
                firstMultiSz = TRUE;
                do {
                    if (firstMultiSz) {
                        firstMultiSz = FALSE;
                    } else {
                        GbAppendString (Buffer, TEXT(","));
                    }
                    encodedString = AllocPathString (SizeOfString (multiSzEnum.CurrentString) * 6);
                    if (EncodeRuleCharsEx (encodedString, multiSzEnum.CurrentString, TEXT("~\r\n%")) != NULL) {
                        GbAppendString (Buffer, encodedString);
                    } else {
                        GbAppendString (Buffer, multiSzEnum.CurrentString);
                    }
                    FreePathString (encodedString);
                } while (EnumNextMultiSz (&multiSzEnum));
                GbAppendString (Buffer, TEXT("\r\n"));
            }
            IsmReleaseMemory (objMultiSz);
            if (objectContent.ContentInFile) {
                if (objectContent.FileContent.ContentPath) {
                    // Let's see if we only want to estimate the size
                    if (g_EstimateSizeOnly) {

                        if (pObjectNameToFileName (ObjectName, &fileName, &dirName)) {
                            // let's add info about directory. The rule is: every new full
                            // directory is considered to take one cluster
                            if (!DoesFileExist (dirName)) {
                                pAddOneCluster ();
                            }
                            if (dirName != fileName) {
                                FreePathString (dirName);
                            }
                            FreePathString (fileName);
                        }
                        pAddFileSize (objectContent.FileContent.ContentPath);

                    } else {

                        // transform the object name into a file name and copy the
                        // content file there
                        if (!pObjectNameToFileName (ObjectName, &fileName, &dirName)) {
                            SetLastError (ERROR_INVALID_DATA);
                            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, objectContent.FileContent.ContentPath));
                            return FALSE;
                        }
                        if (!BfCreateDirectory (dirName)) {

                            LOG ((
                                LOG_ERROR,
                                (PCSTR) MSG_CREATE_FAILURE,
                                dirName,
                                objectContent.FileContent.ContentPath
                                ));

                            if (GetLastError () == ERROR_FILENAME_EXCED_RANGE) {
                                // now we want to see if the app wants us to continue or just quit the transport
                                transCopyError.ObjectType = IsmGetObjectTypeName (ObjectTypeId);
                                transCopyError.ObjectName = dirName;
                                transCopyError.Error = GetLastError ();

                                appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                if (appReply == APPRESPONSE_IGNORE) {
                                    return TRUE;
                                }
                            }

                            return FALSE;
                        }
                        okSave = FALSE;
                        while (!okSave) {
                            if (!CopyFile (objectContent.FileContent.ContentPath, fileName, TRUE)) {

                                if ((TcharCount (fileName) >= MAX_PATH) && (GetLastError () == ERROR_PATH_NOT_FOUND)) {
                                    // we tried to copy a file to a location that was bigger than MAX_PATH
                                    // Normally this should return the error 206 (ERROR_FILENAME_EXCED_RANGE).
                                    // However, in my tests this returns error 3 (ERROR_PATH_NOT_FOUND).
                                    // Let's just guard for this case:
                                    SetLastError (ERROR_FILENAME_EXCED_RANGE);
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (ObjectTypeId, ObjectName);
                                transCopyError.Error = GetLastError ();

                                forceLogError = FALSE;

                                if (ForceNoncritical || IsmIsNonCriticalObject (ObjectTypeId, ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        return FALSE;
                                    }
                                    if (GetLastError () == ERROR_FILENAME_EXCED_RANGE) {
                                        forceLogError = TRUE;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    if (forceLogError) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                    } else {
                                        LOG ((
                                            LOG_WARNING,
                                            (PCSTR) MSG_IGNORE_COPYSOURCE,
                                            transCopyError.ObjectName,
                                            GetLastError (),
                                            GetLastError ()
                                            ));
                                    }
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        if (dirName != fileName) {
                            FreePathString (dirName);
                        }
                        FreePathString (fileName);
                    }
                } else {
                    // this is just a directory. Let's record that we saved this
                    nativeObjectName = IsmGetNativeObjectName (ObjectTypeId, ObjectName);
                    MemDbSetValue (nativeObjectName, TRFLAG_FILE);
                    IsmReleaseMemory (nativeObjectName);
                }
            }
        } else {
            GbAppendString (Buffer, TEXT("\r\n"));
        }
        IsmReleaseObject (&objectContent);
    }
    return TRUE;
}

BOOL
WINAPI
InfTransTransportSaveState (
    VOID
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECT_ENUM objEnum;
    MIG_OBJECTSTRINGHANDLE objectPattern = NULL;
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_OBJECTSTRINGHANDLE tempObjectName = NULL;
    MIG_CONTENT objectContent;
    PCTSTR infFile = NULL;
    HANDLE infFileHandle = NULL;
    MIG_OBJECTTYPEID dataTypeId;
    MIG_OBJECTTYPEID fileTypeId;
    TCHAR tempDir [MAX_PATH] = TEXT("");
    BOOL firstPass = TRUE;
    BOOL process = TRUE;
    GROWBUFFER writeBuffer = INIT_GROWBUFFER;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;
    PCTSTR node, leaf;
    PTSTR nodePtr;
    TCHAR savedNode;
    DWORD value;
    BOOL result = FALSE;

    if (!pStoreStatusOK (g_InfTransTransportPath, g_InfTransTransportStatus)) {
        return FALSE;
    }

    __try {

        IsmGetTempDirectory (tempDir, MAX_PATH);

        g_Platform = PLATFORM_SOURCE;

        objectName = IsmCreateObjectHandle (S_DATABASEFILE_LITE, NULL);
        if (IsmAcquireObjectEx (
                MIG_DATA_TYPE | PLATFORM_SOURCE,
                objectName,
                &objectContent,
                CONTENTTYPE_FILE,
                0
                )) {
            // we have the database file, we assume it's an INF file
            // and we copy it to our transport location with the
            // migration.inf name.
            infFile = JoinPaths (g_InfTransTransportPath, S_TRANSPORT_INF_FILE);
            if (!CopyFile (objectContent.FileContent.ContentPath, infFile, FALSE)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_SAVE_ISM_INF));
                __leave;
            }
            IsmReleaseObject (&objectContent);
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_ISM_INF));
            __leave;
        }

        infFileHandle = BfOpenFile (infFile);
        if (!infFileHandle) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_ISM_INF));
            __leave;
        }
        BfGoToEndOfFile (infFileHandle, 0);

        objectPattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);

        dataTypeId = MIG_DATA_TYPE;
        fileTypeId = MIG_FILE_TYPE;

        if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
            do {

                objectTypeId = objTypeIdEnum.ObjectTypeId;

                if (firstPass) {
                    WriteFileString (infFileHandle, TEXT("["));
                    WriteFileString (infFileHandle, IsmGetObjectTypeName (objectTypeId));
                    WriteFileString (infFileHandle, TEXT("]\r\n"));
                }

                if (IsmEnumFirstSourceObjectEx (&objEnum, objectTypeId, objectPattern, TRUE)) {
                    do {

                        writeBuffer.End = 0;

                        if (IsmCheckCancel()) {
                            IsmAbortObjectTypeIdEnum (&objTypeIdEnum);
                            IsmAbortObjectEnum (&objEnum);
                            __leave;
                        }

                        if (objectTypeId == dataTypeId && StringIMatch(objEnum.ObjectName, objectName)) {
                            continue;
                        }
                        if (IsmIsPersistentObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {

                            process = TRUE;
                            if (objectTypeId == fileTypeId) {
                                if (firstPass) {
                                    process = pIsShortFileName (objectTypeId, objEnum.ObjectName, tempDir);
                                } else {
                                    process = !pIsShortFileName (objectTypeId, objEnum.ObjectName, tempDir);
                                }
                            }

                            if (process) {

                                if (objectTypeId == fileTypeId) {
                                    // for files and folders we want to save all parent folders in this INF.
                                    // The reason why we do this, is to be able to reconstruct the short-long
                                    // information from this source machine once we get on the destination
                                    // machine

                                    // extract the directory information from ObjectName
                                    if (IsmCreateObjectStringsFromHandle (objEnum.ObjectName, &node, &leaf)) {
                                        // Let's walk the node and see if we saved it already.
                                        // If not, save it.
                                        nodePtr = (PTSTR)node;
                                        while (nodePtr) {
                                            nodePtr = _tcschr (nodePtr, TEXT('\\'));
                                            if (nodePtr) {
                                                savedNode = *nodePtr;
                                                *nodePtr = 0;
                                            }
                                            if (IsValidFileSpec (node)) {
                                                // let's check to see if we already added this directory
                                                value = 0;
                                                if (!MemDbGetValue (node, &value) || (value != TRFLAG_FILE)) {
                                                    tempObjectName = IsmCreateObjectHandle (node, NULL);
                                                    if (tempObjectName) {
                                                        writeBuffer.End = 0;
                                                        if (!pSaveObject (
                                                                fileTypeId|PLATFORM_SOURCE,
                                                                tempObjectName,
                                                                TRUE,
                                                                &writeBuffer
                                                                )) {
                                                            IsmAbortObjectTypeIdEnum (&objTypeIdEnum);
                                                            IsmAbortObjectEnum (&objEnum);
                                                            __leave;
                                                        }
                                                        if (writeBuffer.End) {
                                                            WriteFileString (infFileHandle, (PTSTR) writeBuffer.Buf);
                                                        }
                                                        IsmDestroyObjectHandle (tempObjectName);
                                                    }
                                                }
                                            }
                                            if (nodePtr) {
                                                *nodePtr = savedNode;
                                                nodePtr = _tcsinc (nodePtr);
                                            }
                                        };
                                        IsmDestroyObjectString (node);
                                        IsmDestroyObjectString (leaf);
                                    }
                                    // if it's node only it was already saved above, so save only leaf ones
                                    if (leaf) {
                                        writeBuffer.End = 0;
                                        if (!pSaveObject (
                                                objEnum.ObjectTypeId,
                                                objEnum.ObjectName,
                                                FALSE,
                                                &writeBuffer
                                                )) {
                                            IsmAbortObjectTypeIdEnum (&objTypeIdEnum);
                                            IsmAbortObjectEnum (&objEnum);
                                            __leave;
                                        }
                                        if (writeBuffer.End) {
                                            WriteFileString (infFileHandle, (PTSTR) writeBuffer.Buf);
                                        }
                                    }
                                } else {
                                    writeBuffer.End = 0;
                                    if (!pSaveObject (
                                            objEnum.ObjectTypeId,
                                            objEnum.ObjectName,
                                            FALSE,
                                            &writeBuffer
                                            )) {
                                        IsmAbortObjectTypeIdEnum (&objTypeIdEnum);
                                        IsmAbortObjectEnum (&objEnum);
                                        __leave;
                                    }
                                    if (writeBuffer.End) {
                                        WriteFileString (infFileHandle, (PTSTR) writeBuffer.Buf);
                                    }
                                }
                            }
                        }
                    } while (IsmEnumNextObject (&objEnum));
                }
                if (!firstPass || objectTypeId != fileTypeId) {
                    WriteFileString (infFileHandle, TEXT("\r\n\r\n"));
                }

                if ((objectTypeId == fileTypeId) && firstPass) {
                    firstPass = FALSE;
                } else {
                    if (!IsmEnumNextObjectTypeId (&objTypeIdEnum)) {
                        break;
                    }
                    firstPass = TRUE;
                }
            } while (TRUE);
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (tempDir [0]) {
            FiRemoveAllFilesInTree (tempDir);
        }
        IsmDestroyObjectHandle (objectName);
        if (infFileHandle != NULL) {
            CloseHandle (infFileHandle);
        }
        IsmDestroyObjectHandle (objectPattern);
        FreePathString (infFile);
        infFile = NULL;
        PopError ();
    }

    PushError ();

    if (result) {
        pSetInfTransStatus (g_InfTransTransportStatusHandle, TRSTATUS_READY);
    }
    CloseHandle (g_InfTransTransportStatusHandle);
    g_InfTransTransportStatusHandle = NULL;

    GbFree (&writeBuffer);

    if (result && g_EstimateSizeOnly) {
        result = pWriteEstimateFile ();
    }

    if (!result) {
        FiRemoveAllFilesInTree (g_InfTransTransportPath);
    }

    PopError ();

    return result;
}

BOOL
pSaveObjectContent (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR fileName;
    BOOL result = FALSE;

    if (ObjectContent->ContentInFile) {
        MemDbSetValue (DecoratedObject, TRFLAG_FILE);
        if (pObjectNameToFileName (ObjectName, &fileName, NULL)) {
            if (DoesFileExist (fileName)) {
                MemDbAddSingleLinkage (DecoratedObject, fileName, 0);
            }
            FreePathString (fileName);
        }
    } else {
        MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);
        if (ObjectContent->MemoryContent.ContentSize &&
            ObjectContent->MemoryContent.ContentBytes
            ) {

            MemDbSetUnorderedBlob (
                DecoratedObject,
                0,
                ObjectContent->MemoryContent.ContentBytes,
                ObjectContent->MemoryContent.ContentSize
                );
        }
    }

    result = pInfTransSaveDetails (DecoratedObject, &(ObjectContent->Details));

    return result;
}

BOOL
WINAPI
InfTransTransportBeginApply (
    VOID
    )
{
    PCTSTR infFile;
    HINF infHandle;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    MIG_OBJECTTYPEID objectTypeId;
    GROWBUFFER buff = INIT_GROWBUFFER;
    PCTSTR field;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;
    UINT index;
    PCTSTR decoratedObject = NULL;
    DWORD status = 0;
    PTSTR decodedString = NULL;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;
    DWORD error;

    g_Platform = PLATFORM_DESTINATION;

    while (status != TRSTATUS_READY) {

        status = pGetInfTransStatus (g_InfTransTransportStatus);

        switch (status) {
        case TRSTATUS_LOCKED:
            if (!IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_LOCKED, 0)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY , g_InfTransTransportPath));
                error = GetLastError ();
                if ((error != ERROR_ACCESS_DENIED) &&
                    (error != ERROR_SHARING_VIOLATION)
                    ) {
                    SetLastError (ERROR_ACCESS_DENIED);
                }
                return FALSE;
            }
            break;
        case TRSTATUS_DIRTY:
            SetLastError (ERROR_ACCESS_DENIED);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_InfTransTransportPath));
            return FALSE;
        case TRSTATUS_READY:
            break;
        default:
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_InfTransTransportPath));
            return FALSE;
        }
    }

    g_InfTransTransportStatusHandle = BfOpenReadFile (g_InfTransTransportStatus);
    if (!g_InfTransTransportStatusHandle) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_STATUS_FILE, g_InfTransTransportStatus));
        return FALSE;
    }

    infFile = JoinPaths (g_InfTransTransportPath, S_TRANSPORT_INF_FILE);

    // add the database file in memdb so we can serve AcquireObject from the ISM

    objectName = IsmCreateObjectHandle (S_DATABASEFILE_LITE, NULL);
    decoratedObject = pInfTransBuildDecoratedObject (MIG_DATA_TYPE | PLATFORM_SOURCE, objectName);
    MemDbSetValue (decoratedObject, TRFLAG_FILE);
    MemDbAddSingleLinkage (decoratedObject, infFile, 0);
    pInfTransDestroyDecoratedObject (decoratedObject);
    IsmDestroyObjectHandle (objectName);

    infHandle = InfOpenInfFile (infFile);

    if (infHandle == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_ISM_INF, infFile));
        FreePathString (infFile);
        return FALSE;
    }

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        do {

            objectTypeId = objTypeIdEnum.ObjectTypeId;

            if (InfFindFirstLine (infHandle, IsmGetObjectTypeName (objectTypeId), NULL, &is)) {
                do {
                    index = 1;
                    buff.End = 0;
                    for (;;) {
                        field = InfGetStringField (&is, index);
                        if (!field) {
                            break;
                        }
                        if (*field) {
                            decodedString = DuplicatePathString (field, 0);
                            if (DecodeRuleChars (decodedString, field) != NULL) {
                                GbCopyString (&buff, decodedString);
                            } else {
                                GbCopyString (&buff, field);
                            }
                            FreePathString (decodedString);
                        } else {
                            GbCopyString (&buff, TEXT("<empty>"));
                        }
                        index ++;
                    }
                    if (buff.End) {
                        GbCopyString (&buff, TEXT(""));
                        if (IsmConvertMultiSzToObject (
                                objectTypeId,
                                (PCTSTR)buff.Buf,
                                &objectName,
                                &objectContent
                                )) {
                            // now save the object data into our database
                            // for future reference

                            decoratedObject = pInfTransBuildDecoratedObject (objectTypeId | PLATFORM_SOURCE, objectName);
                            pSaveObjectContent (objectTypeId | g_Platform, objectName, decoratedObject, &objectContent);
                            pInfTransDestroyDecoratedObject (decoratedObject);

                            IsmDestroyObjectHandle (objectName);
                            if ((objectContent.Details.DetailsSize) &&
                                (objectContent.Details.DetailsData)
                                ) {
                                IsmReleaseMemory (objectContent.Details.DetailsData);
                            }
                            if (objectContent.ContentInFile) {
                                if (objectContent.FileContent.ContentPath) {
                                    IsmReleaseMemory (objectContent.FileContent.ContentPath);
                                }
                            } else {
                                if ((objectContent.MemoryContent.ContentSize) &&
                                    (objectContent.MemoryContent.ContentBytes)
                                    ) {
                                    IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
                                }
                            }
                        }
                    }

                } while (InfFindNextLine (&is));
            }
        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    GbFree (&buff);

    InfCleanUpInfStruct (&is);

    InfCloseInfFile (infHandle);

    FreePathString (infFile);

    return TRUE;
}

VOID
WINAPI
InfTransTransportEndApply (
    VOID
    )
{
    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    CloseHandle (g_InfTransTransportStatusHandle);
    g_InfTransTransportStatusHandle = NULL;
}

VOID
WINAPI
InfTransTransportTerminate (
    VOID
    )
{
    if (g_InfTransStoragePath) {
        FreePathString (g_InfTransStoragePath);
        g_InfTransStoragePath = NULL;
    }
    if (g_InfTransTransportPath) {
        FreePathString (g_InfTransTransportPath);
        g_InfTransTransportPath = NULL;
    }
    if (g_InfTransTransportStatus) {
        FreePathString (g_InfTransTransportStatus);
        g_InfTransTransportStatus = NULL;
    }
}

BOOL
WINAPI
InfTransTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_Platform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pInfTransBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = DuplicatePathString (fileValue, 0);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (fileValue);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        fileValue,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                MemDbReleaseMemory (fileValue);
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
InfTransTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\sources.inc ===
#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

TARGETNAME=inf
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\gui\makefile.inc ===
APPTYPE=g
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\console\makefile.inc ===
APPTYPE=c
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\unctrans\unctrans.h ===
//
// Module entry points
//

// inftrans.c
TRANSPORTINITIALIZE InfTransTransportInitialize;
TRANSPORTQUERYCAPABILITIES InfTransTransportQueryCapabilities;
TRANSPORTSETSTORAGE InfTransTransportSetStorage;
TRANSPORTSAVESTATE InfTransTransportSaveState;
TRANSPORTBEGINAPPLY InfTransTransportBeginApply;
TRANSPORTACQUIREOBJECT InfTransTransportAcquireObject;
TRANSPORTRELEASEOBJECT InfTransTransportReleaseObject;
TRANSPORTENDAPPLY InfTransTransportEndApply;
TRANSPORTTERMINATE InfTransTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR InfTransTransportEstimateProgressBar;

// opaque.c
TRANSPORTINITIALIZE OpaqueTransportInitialize;
TRANSPORTQUERYCAPABILITIES OpaqueTransportQueryCapabilities;
TRANSPORTSETSTORAGE OpaqueTransportSetStorage;
TRANSPORTSAVESTATE OpaqueTransportSaveState;
TRANSPORTBEGINAPPLY OpaqueTransportBeginApply;
TRANSPORTACQUIREOBJECT OpaqueTransportAcquireObject;
TRANSPORTRELEASEOBJECT OpaqueTransportReleaseObject;
TRANSPORTENDAPPLY OpaqueTransportEndApply;
TRANSPORTTERMINATE OpaqueTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR OpaqueTransportEstimateProgressBar;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\makefile.inc ===
LCID=409
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

#
# ANSI_CODEPAGE:  ANSI codepage for a given language.
#
# LCID:  Locale ID in hex.
#
# UNITEXT_OPT:  Unitext.exe command line options to specify the ANSI codepage
#   for a given language.  Used for Multibuyte -> Unicode conversion.
#

# Defaults
ANSI_CODEPAGE=1252
LANGUAGE_DRVCAB=$(LANGUAGE)

!if "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
ANSI_CODEPAGE=936
LCID=804

!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional
ANSI_CODEPAGE=950
LCID=404

!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
ANSI_CODEPAGE=932
LCID=411

!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
ANSI_CODEPAGE=949
LCID=412

!elseif "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
ANSI_CODEPAGE=1256
LCID=401

!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
ANSI_CODEPAGE=1255
LCID=40D

!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
ANSI_CODEPAGE=1250
LCID=405

!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
ANSI_CODEPAGE=1250
LCID=40E

!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
ANSI_CODEPAGE=1250
LCID=415

!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
ANSI_CODEPAGE=1251
LCID=419

!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
ANSI_CODEPAGE=1254
LCID=41F

!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
ANSI_CODEPAGE=1253
LCID=408
!endif

UNITEXT_OPT=-m -$(ANSI_CODEPAGE)

STAMP=stampinf -f $@
PLACE=binplace -p .\placefil.txt $@

_LNG=..\$(LANGUAGE)
_INX=..
PREFLAGS=/DLANGUAGE_ID=0x0$(LCID) /EP

make_infs_g:  $(O)\migism.inf     \
              $(O)\usmtdef.inf    \
              $(O)\sysfiles.inf   \
              $(O)\migwiz.inf     \
              $(O)\miguser.inf    \
              $(O)\migsys.inf     \
              $(O)\migapp.inf     \
              $(O)\migwiz.htm     \
              $(O)\migwiz2.htm    \

make_infs_c:  $(O)\migism.inf     \
              $(O)\usmtdef.inf    \
              $(O)\sysfiles.inf   \
              $(O)\migwiz.inf     \
              $(O)\miguser.inf    \
              $(O)\migsys.inf     \
              $(O)\migapp.inf     \
              $(O)\UsmtInfCommands.doc \



$(O)\migism.inf: $(_INX)\migism.inx $(_LNG)\migism.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\usmtdef.inf: $(_INX)\usmtdef.inx $(_LNG)\usmtdef.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\sysfiles.inf: $(_INX)\sysfiles.inx $(_LNG)\sysfiles.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\migwiz.inf: $(_INX)\migwiz.inx $(_LNG)\migwiz.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\migsys.inf: $(_INX)\migsys.inx $(_LNG)\migsys.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\miguser.inf: $(_INX)\miguser.inx $(_LNG)\miguser.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\migapp.inf: $(_INX)\migapp.inx $(_LNG)\migapp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\migwiz.htm: $(_INX)\migwiz.htm
    copy $(_INX)\$(@B).htm $(O)\$(@B).htm
    $(PLACE)

$(O)\migwiz2.htm: $(_INX)\migwiz2.htm
    copy $(_INX)\$(@B).htm $(O)\$(@B).htm
    $(PLACE)

$(O)\UsmtInfCommands.doc: $(_LNG)\UsmtInfCommands.doc
    copy $(_LNG)\UsmtInfCommands.doc $(O)\UsmtInfCommands.doc
    $(PLACE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\branches\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\branches\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

#define MAX_BRANCHES        16

HANDLE g_hHeap;
HINSTANCE g_hInst;
BOOL g_Commit;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "\nDescription:\n\n"

        "  SDPB.EXE executes sd branch and sd client for a specific branch.\n"
        "  It maps in the branch into view, or removes the branch from view if\n"
        "  the -d argument is specified.\n\n"

        "  This utility assumes a specific format of the branch layout:\n\n"

        "       //depot/private/{branch}/{project}/{path}\n\n"

        "  {branch} specifies the private branch, and the last path member must\n"
        "           match the <branchname> arg.\n\n"

        "           Examples: (assume <branchname> is \"foo\")\n"
        "               //depot/private/foo/root\n"
        "               //depot/private/foo/bar\n"
        "               //depot/private/cat/foo/bar\n\n"

        "  {project} specifies the depot, such as root or base\n\n"

        "  {path} specifies the rest of the path\n\n"

        "  The local path is computed by %%_NTBINDIR%%\\{project}\\{path}, unless\n"
        "  {project} == \"root\" (%%_NTBINDIR%%\\{path} is used for root).\n\n"

        "  The -p switch overrides local path computation.\n\n"

        "  Example: (a private branch of winnt32)\n\n"

        "       //depot/private/migration/base/ntsetup/winnt32\n\n"

        "  NOTE: SDPB.EXE changes have no affect until sd sync is executed.\n\n"

        "Command Line Syntax:\n\n"

        "  sdpb <branchname(s)> [-p:<local_proj_root>] [-d] [-o] [-c]\n"

        "\nArguments: (order-insensitive)\n\n"

        "  <branchname> specifies the Source Depot branch name to map in. A max of\n"
        "       16 branches can be specified.\n\n"

        "  -p:<local_proj_root> specifies an alternative local subdirectory to\n"
        "       use as the path base. If specified, //depot/private/{branch}/{project}\n"
        "       is replaced by <local_proj_root>.\n\n"

        "  -d enables delete mode, to remove a branch from the client view\n\n"

        "  -o outputs various interesting data about the branch views (no changes)\n\n"

        "  -c commits changes to sd client\n"

        );

    exit (1);
}


BOOL
pGetNextLine (
    IN      PCSTR Start,
    IN      PCSTR Eof,
    OUT     PCSTR *PrintableStart,
    OUT     PCSTR *End,
    OUT     PCSTR *NextLine
    )
{
    PCSTR pos;

    pos = Start;
    *End = NULL;

    while (pos < Eof) {
        if (pos[0] != ' ' && pos[0] != '\t') {
            break;
        }
        pos++;
    }

    *PrintableStart = pos;

    while (pos < Eof) {
        if (pos[0] == '\r' || pos[0] == '\n') {
            break;
        }
        pos++;
    }

    *End = pos;

    if (pos < Eof && pos[0] == '\r') {
        pos++;
    }
    if (pos < Eof && pos[0] == '\n') {
        pos++;
    }
    *NextLine = pos;

    return Start != *NextLine;
}

PCSTR
pFindNextCharAB (
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      CHAR FindChar
    )
{
    if (!Start) {
        return NULL;
    }

    while (Start < End) {
        if (*Start == FindChar) {
            return Start;
        }

        Start++;
    }

    return NULL;
}


BOOL
pParseViewLines (
    IN OUT  PCSTR *FilePos,
    IN      PCSTR Eof,
    IN OUT  PGROWLIST LeftSide,     OPTIONAL
    IN OUT  PGROWLIST RightSide     OPTIONAL
    )
{
    UINT count = 0;
    PCSTR pos;
    PCSTR nextPos;
    PSTR midString;
    PCSTR rightSideStart;
    PCSTR rightSideEnd;
    PSTR p;
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR leftSideStart;
    PCSTR leftSideEnd;
    PCSTR dash;
    BOOL b;

    pos = *FilePos;

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &nextPos)) {
        if (pos == lineStart) {
            break;
        }

        //
        // Extract the left side string
        //

        leftSideStart = pFindNextCharAB (lineStart, lineEnd, '/');
        if (!leftSideStart || (leftSideStart + 1 >= lineEnd) || leftSideStart[1] != '/') {
            break;
        }

        leftSideEnd = leftSideStart + 2;

        dash = pFindNextCharAB (lineStart, lineEnd, '-');
        if (dash == leftSideStart - 1) {
            leftSideStart = dash;
        }

        for (;;) {
            leftSideEnd = pFindNextCharAB (leftSideEnd, lineEnd, '/');
            if (!leftSideEnd || (leftSideEnd + 1 >= lineEnd)) {
                leftSideEnd = NULL;
                break;
            }

            if (leftSideEnd[1] == '/') {
                leftSideEnd--;
                break;
            }

            leftSideEnd++;
        }

        if (!leftSideEnd) {
            break;
        }

        rightSideStart = pFindNextCharAB (leftSideEnd, lineEnd, '/');
        if (!rightSideStart || (rightSideStart + 1 >= lineEnd) || rightSideStart[1] != '/') {
            break;
        }

        while (leftSideEnd > leftSideStart) {
            leftSideEnd--;
            if (!isspace (*leftSideEnd)) {
                leftSideEnd++;
                break;
            }
        }

        if (leftSideEnd == leftSideStart) {
            break;
        }

        //
        // Extract the right side string
        //

        rightSideEnd = lineEnd;
        while (rightSideEnd > rightSideStart) {
            rightSideEnd--;
            if (!isspace (*rightSideEnd)) {
                rightSideEnd++;
                break;
            }
        }

        if (rightSideEnd == rightSideStart) {
            break;
        }

        if (LeftSide) {
            if (!GlAppendStringAB (LeftSide, leftSideStart, leftSideEnd)) {
                break;
            }
        }

        if (RightSide) {
            if (!GlAppendStringAB (RightSide, rightSideStart, rightSideEnd)) {
                break;
            }
        }

        count++;

        pos = nextPos;
    }

    *FilePos = pos;

    return count > 0;
}


VOID
pDumpOutput (
    IN      PCSTR SdClientOutput,
    IN      PCSTR Eof
    )
{
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR pos;
    PSTR dup;
    PCSTR root;
    BOOL viewFound = FALSE;

    pos = SdClientOutput;

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &pos)) {
        if (lineEnd == lineStart) {
            printf ("\n");
            continue;
        }

        dup = AllocText (lineEnd - lineStart);
        StringCopyAB (dup, lineStart, lineEnd);

        _tprintf ("%s\n", dup);

        FreeText (dup);
    }
}


BOOL
pParseClientMapping (
    IN      PCSTR SdClientOutput,
    IN      PCSTR Eof,
    OUT     PSTR Client,
    OUT     PSTR RootPath,
    IN OUT  PGROWLIST LeftSide,     OPTIONAL
    IN OUT  PGROWLIST RightSide     OPTIONAL
    )
{
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR pos;
    PSTR dup;
    PCSTR data;
    BOOL viewFound = FALSE;

    //
    // Find Client:, Root: or View:
    //

    pos = SdClientOutput;
    *RootPath = 0;

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &pos)) {
        if (lineStart == lineEnd) {
            continue;
        }

        if (*lineStart == '#') {
            continue;
        }

        dup = AllocText (lineEnd - lineStart);
        StringCopyAB (dup, lineStart, lineEnd);

        if (StringIPrefix (dup, "Client:")) {
            data = dup + 7;
            while (isspace (*data)) {
                data++;
            }

            StringCopy (Client, data);

        } else if (StringIPrefix (dup, "Root:")) {
            data = dup + 5;
            while (isspace (*data)) {
                data++;
            }

            StringCopy (RootPath, data);

        } else if (StringIPrefix (dup, "View:")) {
            if (!(*RootPath)) {
                break;
            }

            viewFound = pParseViewLines (&pos, Eof, LeftSide, RightSide);
        }

        FreeText (dup);
        dup = NULL;
    }

    FreeText (dup);

    return *RootPath && viewFound;
}


BOOL
pParseBranchMapping (
    IN      PCSTR SdClientOutput,
    IN      PCSTR Eof,
    IN OUT  PGROWLIST LeftSide,     OPTIONAL
    IN OUT  PGROWLIST RightSide     OPTIONAL
    )
{
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR pos;
    PSTR dup;
    PCSTR root;
    BOOL viewFound = FALSE;

    //
    // Find View:
    //

    pos = SdClientOutput;

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &pos)) {
        if (lineStart == lineEnd) {
            continue;
        }

        if (*lineStart == '#') {
            continue;
        }

        dup = AllocText (lineEnd - lineStart);
        StringCopyAB (dup, lineStart, lineEnd);

        if (StringIPrefix (dup, "View:")) {
            viewFound = pParseViewLines (&pos, Eof, LeftSide, RightSide);
        }

        FreeText (dup);
        dup = NULL;
    }

    FreeText (dup);

    return viewFound;
}


BOOL
pVerifyBranch (
    IN      PCSTR BranchName,
    IN      PGROWLIST BranchStorage,
    OUT     PGROWLIST BranchProject,        OPTIONAL
    OUT     PGROWLIST BranchPath,           OPTIONAL
    IN      PCSTR LocalRoot,                OPTIONAL
    IN      PCSTR ClientViewRoot            OPTIONAL
    )
{
    UINT u;
    UINT count;
    BOOL result = TRUE;
    PCSTR projectStart;
    PCSTR projectEnd;
    UINT branchNameTchars;
    PCSTR localPathBase = NULL;
    PCSTR p;
    PSTR localSubPath = NULL;
    PCSTR restOfPath = NULL;
    PSTR q;
    PCSTR fullSubPath = NULL;

    if (LocalRoot) {
        p = LocalRoot + TcharCountA (ClientViewRoot);
        if (*p == '\\') {
            p++;
        }

        localSubPath = DuplicatePathString (p, 0);
        q = localSubPath;
        while (*q) {
            if (*q == '\\') {
                *q = '/';
            }

            q++;
        }
    }

    branchNameTchars = TcharCountA (BranchName);

    count = GlGetSize (BranchStorage);

    for (u = 0 ; u < count ; u++) {
        projectStart = GlGetString (BranchStorage, u);
        if (!projectStart || !StringIPrefix (projectStart, "//depot/private/")) {
            result = FALSE;
            break;
        }

        projectStart += sizeof ("//depot/private/") - 1;       // minus one for nul

        while (*projectStart) {
            if (StringIPrefix (projectStart, BranchName)) {

                if (projectStart[branchNameTchars] == '/') {
                    //
                    // Recall syntax is:
                    //
                    // //depot/private/[subdir/]{branch}/{project}/{path}
                    //
                    // If -p switch is specified, we don't have {project}.
                    //

                    //
                    // We just found {branch}, locate start and end ptrs of {project},
                    // leave them equal if there is no {project}. projectEnd must
                    // point to /{path}.
                    //

                    projectStart += branchNameTchars;
                    projectEnd = projectStart;

                    if (!LocalRoot) {
                        projectStart++;
                        projectEnd = strchr (projectStart, '/');
                        if (!projectEnd) {
                            //
                            // Assumption failure -- break now
                            //

                            projectStart = NULL;
                            break;
                        }
                    }

                    //
                    // prepare the base path from -p switch
                    //

                    if (localSubPath) {
                        localPathBase = localSubPath;
                    } else {
                        localPathBase = "";
                    }

                    //
                    // After projectEnd comes optional {path}, find {path}
                    //

                    restOfPath = projectEnd;
                    if (*restOfPath && !(*localPathBase)) {
                        restOfPath++;
                    }

                    // done
                    break;
                }
            }

            //
            // {project} not found yet, keep searching
            //

            projectStart = strchr (projectStart, '/');
            if (projectStart) {
                projectStart++;
            } else {
                break;
            }
        }

        if (!projectStart || !restOfPath || !localPathBase) {
            result = FALSE;
            fprintf (
                stderr,
                "\nThe branch spec below does not fit assumptions. See help (/? switch).\n\n%s\n\n",
                GlGetString (BranchStorage, u)
                );
            break;
        }

        fullSubPath = JoinText (localPathBase, restOfPath);
        if (!fullSubPath) {
            result = FALSE;
            break;
        }

        localPathBase = NULL;
        restOfPath = NULL;

        if (BranchProject) {
            if (!GlAppendStringAB (BranchProject, projectStart, projectEnd)) {
                result = FALSE;
                break;
            }
        }

        if (BranchPath) {
            if (!GlAppendString (BranchPath, fullSubPath)) {
                result = FALSE;
                break;
            }
        }

        FreeText (fullSubPath);
        fullSubPath = NULL;
    }

    FreeText (fullSubPath);
    FreePathString (localSubPath);

    return result;
}


BOOL
pLaunchSd (
    IN      PSTR CmdLine,
    IN      HANDLE TempInput,
    IN      HANDLE TempOutput,
    IN      PCSTR Msg,
    OUT     HANDLE *Mapping,
    OUT     PCSTR *FileContent,
    OUT     PCSTR *Eof
    )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    LONG rc;

    if (TempInput != INVALID_HANDLE_VALUE) {
        SetFilePointer (TempInput, 0, NULL, FILE_BEGIN);
    }

    if (TempOutput != INVALID_HANDLE_VALUE) {
        SetFilePointer (TempOutput, 0, NULL, FILE_BEGIN);
        SetEndOfFile (TempOutput);
    }

    ZeroMemory (&si, sizeof (si));

    si.dwFlags = STARTF_USESTDHANDLES;

    if (TempInput == INVALID_HANDLE_VALUE) {
        si.hStdInput = GetStdHandle (STD_INPUT_HANDLE);
    } else {
        if (!DuplicateHandle (
                GetCurrentProcess(),
                TempInput,
                GetCurrentProcess(),
                &si.hStdInput,
                0,
                TRUE,
                DUPLICATE_SAME_ACCESS
                )) {
            printf ("Can't dup temp input file handle\n");
            return FALSE;
        }
    }

    if (!DuplicateHandle (
            GetCurrentProcess(),
            TempOutput,
            GetCurrentProcess(),
            &si.hStdOutput,
            0,
            TRUE,
            DUPLICATE_SAME_ACCESS
            )) {
        printf ("Can't dup temp output file handle\n");
        return FALSE;
    }

    si.hStdError = GetStdHandle (STD_ERROR_HANDLE);

    if (!CreateProcess (
            NULL,
            CmdLine,
            NULL,
            NULL,
            TRUE,
            0,
            NULL,
            NULL,
            &si,
            &pi
            )) {
        printf ("Can't launch sd describe\n");
        CloseHandle (si.hStdOutput);
        return FALSE;
    }

    printf ("%s", Msg);
    rc = WaitForSingleObject (pi.hProcess, INFINITE);
    printf ("\n");

    CloseHandle (pi.hProcess);
    CloseHandle (pi.hThread);
    CloseHandle (si.hStdOutput);

    if (rc != WAIT_OBJECT_0) {
        return FALSE;
    }

    if (!GetFileSize (TempOutput, NULL)) {
        return FALSE;
    }

    *Mapping = CreateFileMapping (TempOutput, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(*Mapping)) {
        printf ("Can't map temp file into memory\n");
        return FALSE;
    }

    *FileContent = (PCSTR) MapViewOfFile (*Mapping, FILE_MAP_READ, 0, 0, 0);
    if (!*FileContent) {
        printf ("Can't map temp file data into memory\n");
        CloseHandle (*Mapping);
        return FALSE;
    }

    *Eof = *FileContent + GetFileSize (TempOutput, NULL);

    return TRUE;
}

PCSTR
pSkipMachineName (
    IN      PCSTR LocalView
    )
{
    if (LocalView[0] == '-' && LocalView[1] == '/' && LocalView[2] == '/') {
        return strchr (LocalView + 3, '/');
    }
    
    if (LocalView[0] == '/' && LocalView[1] == '/') {
        return strchr (LocalView + 2, '/');
    }

    return NULL;
}


BOOL
pIsBranchInView (
    IN      PCSTR ViewInLocalPath,
    IN      PGROWLIST StoredSpec,
    OUT     UINT *Index                 OPTIONAL
    )
{
    UINT subPathTchars;
    UINT u;
    UINT count;
    PCSTR localSpecPath;
    PCSTR p1;
    PCSTR p2;

    p2 = pSkipMachineName (ViewInLocalPath);
    if (!p2) {
        return FALSE;
    }

    subPathTchars = TcharCount (p2);

    count = GlGetSize (StoredSpec);

    for (u = 0 ; u < count ; u++) {
        p1 = pSkipMachineName (GlGetString (StoredSpec, u));
        if (!p1) {
            continue;
        }

        if (StringIPrefix (p1, p2)) {
            if (p1[subPathTchars] == 0 || p1[subPathTchars] == '/') {
                if (Index) {
                    *Index = u;
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}


VOID
pDumpBranchStatus (
    IN      PGROWLIST BranchParent,
    IN      PGROWLIST BranchStorage,
    IN      PGROWLIST BranchProject,
    IN      PGROWLIST BranchPath,
    IN      PGROWLIST StoredSpec,
    IN      PGROWLIST LocalSpec,
    IN      PCSTR LocalRoot,
    IN      PCSTR NtBinDir,
    IN      PCSTR Root,
    IN      PCSTR ComputerName
    )
{
    UINT count;
    UINT u;
    UINT rootTchars;
    PCSTR p;
    PCSTR localBase;
    PSTR q;
    PCSTR baseOfPath;
    PCSTR fullPath;
    CHAR fullSpec[MAX_PATH * 2];
    BOOL outOfView = FALSE;

    count = GlGetSize (BranchParent);
    if (count != GlGetSize (BranchStorage)) {
        exit (1);
    }

    for (u = 0 ; u < count ; u++) {
        wsprintf (fullSpec, "//%s/%s", ComputerName, GlGetString (BranchPath, u));

        if (!pIsBranchInView (GlGetString (BranchStorage, u), StoredSpec, NULL)) {
            outOfView = TRUE;
            break;
        }
    }

    if (outOfView) {
        printf ("All Branch View Mappings:\n");
    } else {
        printf ("Branch View Mappings: (all are in client view)\n");
    }

    for (u = 0 ; u < count ; u++) {
        _tprintf (
            "  %s //%s/%s\n",
            GlGetString (BranchStorage, u),
            ComputerName,
            GlGetString (BranchPath, u)
            );
    }

    if (outOfView) {
        printf ("\nOut-of-View Mapping:\n");
        for (u = 0 ; u < count ; u++) {
            wsprintf (fullSpec, "//%s/%s", ComputerName, GlGetString (BranchPath, u));

            if (!pIsBranchInView (GlGetString (BranchStorage, u), StoredSpec, NULL)) {
                _tprintf (
                    "  %s %s\n",
                    GlGetString (BranchStorage, u),
                    fullSpec
                    );
            }
        }
    }

    rootTchars = TcharCount (Root);

    printf ("\nLocal View: (%s)\n", Root);
    for (u = 0 ; u < count ; u++) {
        p = GlGetString (BranchProject, u);

        if (!LocalRoot) {
            if (!p || StringIMatch (p, "root")) {
                baseOfPath = DuplicatePathString (NtBinDir, 0);
            } else {
                baseOfPath = JoinPaths (NtBinDir, p);
            }
        } else {
            baseOfPath = DuplicatePathString (LocalRoot, 0);
        }

        if (!baseOfPath) {
            exit (1);
        }

        fullPath = JoinPaths (baseOfPath, GlGetString (BranchPath, u));
        if (!fullPath) {
            exit (1);
        }

        FreePathString (baseOfPath);

        q = (PSTR) fullPath;
        while (*q) {
            if (*q == '/') {
                *q = '\\';
            }

            q++;
        }

        if (StringIPrefix (fullPath, Root) && (fullPath[rootTchars] == 0 || fullPath[rootTchars] == '\\')) {
            printf ("  %s\n", fullPath);
        }

        FreePathString (fullPath);
    }

    printf ("\n");

}


BOOL
pAddAllMappings (
    IN      PGROWLIST BranchStorage,
    IN      PGROWLIST BranchPath,
    IN OUT  PGROWLIST StoredSpec,
    IN OUT  PGROWLIST LocalSpec,
    IN      PCSTR ComputerName
    )
{
    UINT u;
    UINT count;
    CHAR fullSpec[MAX_PATH * 2];
    BOOL heading = TRUE;

    count = GlGetSize (BranchPath);

    for (u = 0 ; u < count ; u++) {
        wsprintf (fullSpec, "//%s/%s", ComputerName, GlGetString (BranchPath, u));

        if (!pIsBranchInView (GlGetString (BranchStorage, u), StoredSpec, NULL)) {
            if (heading) {
                heading = FALSE;
                printf ("Add to client view:\n");
            }

            printf ("  %s %s\n", GlGetString (BranchStorage, u), fullSpec);

            GlAppendString (StoredSpec, GlGetString (BranchStorage, u));
            GlAppendString (LocalSpec, fullSpec);
        }
    }

    return heading == FALSE;
}


BOOL
pDeleteAllMappings (
    IN      PGROWLIST BranchStorage,
    IN      PGROWLIST BranchPath,
    IN OUT  PGROWLIST StoredSpec,
    IN OUT  PGROWLIST LocalSpec,
    IN      PCSTR ComputerName
    )
{
    UINT u;
    UINT count;
    CHAR fullSpec[MAX_PATH * 2];
    BOOL heading = TRUE;
    BOOL restart;
    UINT delIndex;

    do {
        restart = FALSE;

        count = GlGetSize (BranchPath);

        for (u = 0 ; u < count ; u++) {
            wsprintf (fullSpec, "//%s/%s", ComputerName, GlGetString (BranchPath, u));

            if (pIsBranchInView (GlGetString (BranchStorage, u), StoredSpec, &delIndex)) {
                if (heading) {
                    heading = FALSE;
                    printf ("Remove from client view:\n");
                }

                printf ("  %s %s\n", GlGetString (BranchStorage, u), fullSpec);

                GlDeleteItem (StoredSpec, delIndex);
                GlDeleteItem (LocalSpec, delIndex);

                restart = TRUE;
                break;
            }
        }
    } while (restart);

    return heading == FALSE;
}


BOOL
pDumpClientView (
    IN      HANDLE Output,
    IN      PGROWLIST StoredSpec,
    IN      PGROWLIST LocalSpec,
    IN      PCSTR Client,
    IN      PCSTR Root
    )
{
    UINT u;
    UINT count;
    CHAR buffer[1024];

    wsprintf (buffer, "Client: %s\n\n", Client);
    if (!WriteFileString (Output, buffer)) {
        return FALSE;
    }

    wsprintf (buffer, "Root: %s\n\n", Root);
    if (!WriteFileString (Output, buffer)) {
        return FALSE;
    }

    wsprintf (buffer, "View:\n");
    if (!WriteFileString (Output, buffer)) {
        return FALSE;
    }

    count = GlGetSize (StoredSpec);

    for (u = 0 ; u < count ; u++) {
        wsprintf (buffer, "  %s %s\n", GlGetString (StoredSpec, u), GlGetString (LocalSpec, u));
        if (!WriteFileString (Output, buffer)) {
            return FALSE;
        }
    }

    return TRUE;
}



INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCSTR branchName[MAX_BRANCHES];
    UINT branches = 0;
    UINT u;
    UINT count;
    PCSTR localRoot = NULL;
    CHAR fullRoot[MAX_PATH];
    BOOL dumpStatus = FALSE;
    BOOL deleteMode = FALSE;
    PSTR dontCare;
    DWORD rc;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (tolower (argv[i][1])) {

            case 'o':
                if (dumpStatus) {
                    HelpAndExit();
                }

                dumpStatus = TRUE;
                break;

            case 'd':
                if (deleteMode) {
                    HelpAndExit();
                }

                deleteMode = TRUE;
                break;

            case 'p':
                if (localRoot) {
                    HelpAndExit();
                }

                if (argv[i][2] == ':') {
                    localRoot = &(argv[i][3]);
                } else {
                    i++;
                    if (i == argc) {
                        HelpAndExit();
                    }

                    localRoot = argv[i];
                }

                rc = GetFullPathName (localRoot, ARRAYSIZE(fullRoot), fullRoot, &dontCare);
                if (rc == 0 || rc >= ARRAYSIZE(fullRoot)) {
                    fprintf (stderr, "Can't get full path of %s\n", localRoot);
                    exit (1);
                }

                localRoot = fullRoot;
                break;

            case 'c':
                if (g_Commit) {
                    HelpAndExit();
                }

                g_Commit = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (branches == MAX_BRANCHES) {
                HelpAndExit();
            }

            branchName[branches++] = argv[i];
        }
    }

    if (!branches) {
        HelpAndExit();
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // TODO: Do work here
    //
    {
        TCHAR cmd[MAX_PATH];
        HANDLE tempInput;
        HANDLE tempOut;
        HANDLE mapping;
        PCSTR fileData;
        PCSTR endOfFile;
        CHAR root[MAX_PATH];
        CHAR client[MAX_PATH];
        GROWLIST parentBranch = INIT_GROWLIST;
        GROWLIST branchStorage = INIT_GROWLIST;
        GROWLIST branchProject = INIT_GROWLIST;
        GROWLIST branchPath = INIT_GROWLIST;
        GROWLIST storedSpec = INIT_GROWLIST;
        GROWLIST localSpec = INIT_GROWLIST;
        PCTSTR ntBinDir;
        BOOL changed = FALSE;
        UINT currentBranch;

        ntBinDir = getenv ("_NTBINDIR");
        if (!ntBinDir && !localRoot) {
            fprintf (stderr, "%%_NTBINDIR%% required to be set\n");
            exit (1);
        }

        tempInput = BfGetTempFile ();   // handle & file cleans up with process termination

        if (!tempInput) {
            printf ("Can't create temp input file\n");
            exit (1);
        }

        tempOut = BfGetTempFile ();     // handle & file cleans up with process termination

        if (!tempOut) {
            printf ("Can't create temp output file\n");
            exit (1);
        }

        for (currentBranch = 0 ; currentBranch < branches ; currentBranch++) {

            printf ("Branch: %s\n\n", branchName[currentBranch]);

            wsprintf (cmd, TEXT("sd branch -o %s"), branchName[currentBranch]);
            if (!pLaunchSd (
                    cmd,
                    INVALID_HANDLE_VALUE,
                    tempOut,
                    "Getting branch mapping...",
                    &mapping,
                    &fileData,
                    &endOfFile
                    )) {
                exit (1);
            }

            if (!pParseBranchMapping (fileData, endOfFile, &parentBranch, &branchStorage)) {
                exit (1);
            }

            if (!pLaunchSd (
                    TEXT("sd client -o"),
                    INVALID_HANDLE_VALUE,
                    tempOut,
                    "Getting client mapping...",
                    &mapping,
                    &fileData,
                    &endOfFile
                    )) {
                exit (1);
            }

            if (!pParseClientMapping (fileData, endOfFile, client, root, &storedSpec, &localSpec)) {
                exit (1);
            }

            if (localRoot) {
                if (!StringIPrefix (localRoot, root)) {
                    fprintf (stderr, "Local root %s must be in client root of %s\n", localRoot, root);
                    exit (1);
                }
            }

            if (!pVerifyBranch (branchName[currentBranch], &branchStorage, &branchProject, &branchPath, localRoot, root)) {
                exit (1);
            }

            printf ("\n\n");

            if (dumpStatus) {

                pDumpBranchStatus (
                    &parentBranch,
                    &branchStorage,
                    &branchProject,
                    &branchPath,
                    &storedSpec,
                    &localSpec,
                    localRoot,
                    ntBinDir,
                    root,
                    client
                    );

            } else if (deleteMode) {
                changed = pDeleteAllMappings (
                                &branchStorage,
                                &branchPath,
                                &storedSpec,
                                &localSpec,
                                client
                                );
            } else {
                changed = pAddAllMappings (
                                &branchStorage,
                                &branchPath,
                                &storedSpec,
                                &localSpec,
                                client
                                );
            }

            if (changed) {
                if (!g_Commit) {
                    printf ("\nChanges not committed -- specify -c to commit\n");
                } else {

                    SetFilePointer (tempInput, 0, NULL, FILE_BEGIN);
                    if (!pDumpClientView (tempInput, &storedSpec, &localSpec, client, root)) {
                        fprintf (stderr, "Error writing to temp file\n");
                        exit (1);
                    }

                    printf ("\n");

                    if (!pLaunchSd (
                            TEXT("sd client -i"),
                            tempInput,
                            tempOut,
                            "Setting client mapping...",
                            &mapping,
                            &fileData,
                            &endOfFile
                            )) {
                        exit (1);
                    }

                    printf ("\nChanges committed. Run sd sync to update your enlistment.\n\n");
                }
            } else {
                printf ("No changes made.\n\n");
            }

            GlFree (&parentBranch);
            GlFree (&branchStorage);
            GlFree (&branchProject);
            GlFree (&branchPath);
            GlFree (&storedSpec);
            GlFree (&localSpec);
        }

    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\changes\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;
GROWLIST g_WindiffCmds = INIT_GROWLIST;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        "  changes <changenumber>\n"

        "\nDescription:\n\n"

        //
        // TODO: Describe tool, indent 2 spaces
        //

        "  changes.exe executes sd describe and windiff for a specific change.\n"

        "\nArguments:\n\n"

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        "  <changenumber>   Specifies the Source Depot change number\n"

        );

    exit (1);
}


BOOL
pGetNextLine (
    IN      PCSTR Start,
    IN      PCSTR Eof,
    OUT     PCSTR *PrintableStart,
    OUT     PCSTR *End,
    OUT     PCSTR *NextLine
    )
{
    PCSTR pos;

    pos = Start;
    *End = NULL;

    while (pos < Eof) {
        if (pos[0] != ' ' && pos[0] != '\t') {
            break;
        }
        pos++;
    }

    *PrintableStart = pos;

    while (pos < Eof) {
        if (pos[0] == '\r' || pos[0] == '\n') {
            break;
        }
        pos++;
    }

    *End = pos;

    if (pos < Eof && pos[0] == '\r') {
        pos++;
    }
    if (pos < Eof && pos[0] == '\n') {
        pos++;
    }
    *NextLine = pos;

    return Start != *NextLine;
}

PCSTR
pFindNextCharAB (
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      CHAR FindChar
    )
{
    if (!Start) {
        return NULL;
    }

    while (Start < End) {
        if (*Start == FindChar) {
            return Start;
        }

        Start++;
    }

    return NULL;
}


BOOL
pParseViewLines (
    IN OUT  PCSTR *FilePos,
    IN      PCSTR Eof,
    IN      PCSTR Root,
    IN      PMAPSTRUCT Map
    )
{
    UINT count = 0;
    PCSTR pos;
    PCSTR nextPos;
    PSTR prefix;
    PCSTR prefixEnd;
    PSTR subDir;
    PCSTR localPath;
    PCSTR clientPathStart;
    PCSTR clientPathEnd;
    PSTR p;
    PCSTR lineStart;
    PCSTR lineEnd;

    pos = *FilePos;

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &nextPos)) {
        if (pos == lineStart) {
            break;
        }

        //
        // Find depot prefix
        //

        prefixEnd = lineStart;
        for (;;) {
            prefixEnd = pFindNextCharAB (prefixEnd, lineEnd, '.');
            if (!prefixEnd) {
                break;
            }

            if (prefixEnd[1] == '.' && prefixEnd[2] == '.' &&
                isspace(prefixEnd[3]) &&
                prefixEnd[4] == '/' && prefixEnd[5] == '/'
                ) {
                break;
            }

            prefixEnd++;
        }

        if (!prefixEnd || prefixEnd == lineStart) {
            break;
        }

        //
        // Find client path
        //

        clientPathStart = pFindNextCharAB (prefixEnd + 6, lineEnd, '/');
        if (!clientPathStart) {
            break;
        }

        clientPathStart++;

        clientPathEnd = clientPathStart;
        for (;;) {
            clientPathEnd = pFindNextCharAB (clientPathEnd, lineEnd, '.');
            if (!clientPathEnd) {
                break;
            }

            if (clientPathEnd[1] == '.' && clientPathEnd[2] == '.' &&
                clientPathEnd + 3 == lineEnd
                ) {
                break;
            }

            clientPathEnd++;
        }

        if (!clientPathEnd) {
            break;
        }

        if (clientPathEnd > clientPathStart) {
            clientPathEnd--;    // account for last slash
        }

        //
        // Clean the strings and add to mapping
        //

        prefix = AllocText (prefixEnd - lineStart);
        StringCopyAB (prefix, lineStart, prefixEnd);

        subDir = AllocText ((clientPathEnd - clientPathStart) + 1);
        if (clientPathEnd > clientPathStart) {
            StringCopyAB (subDir, clientPathStart, clientPathEnd);
        }

        p = strchr (subDir, '/');
        while (p) {
            *p++ = '\\';
            p = strchr (p, '/');
        }

        AppendWack (subDir);

        localPath = JoinPaths (Root, subDir);

        AddStringMappingPair (Map, prefix, localPath);

        FreeText (prefix);
        FreeText (subDir);
        FreePathString (localPath);

        count++;

        pos = nextPos;
    }


    *FilePos = pos;

    return count > 0;
}

BOOL
pParseClientMapping (
    IN      PCSTR SdClientOutput,
    IN      PCSTR Eof,
    OUT     PSTR RootPath,
    IN      PMAPSTRUCT Map
    )
{
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR pos;
    PSTR dup;
    PCSTR root;
    BOOL viewFound = FALSE;

    //
    // Find Root: or View:
    //

    pos = SdClientOutput;
    *RootPath = 0;

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &pos)) {
        if (lineStart == lineEnd) {
            continue;
        }

        if (*lineStart == '#') {
            continue;
        }

        dup = AllocText (lineEnd - lineStart);
        StringCopyAB (dup, lineStart, lineEnd);

        if (StringIPrefix (dup, "Root:")) {
            root = dup + 5;
            while (isspace (*root)) {
                root++;
            }

            StringCopy (RootPath, root);

        } else if (StringIPrefix (dup, "View:")) {
            if (!(*RootPath)) {
                break;
            }

            viewFound = pParseViewLines (&pos, Eof, RootPath, Map);
        }

        FreeText (dup);
        dup = NULL;
    }

    FreeText (dup);

    return *RootPath && viewFound;
}


BOOL
pParseChangeList (
    IN      PCSTR SdDescribeOutput,
    IN      PCSTR Eof,
    IN      PMAPSTRUCT Map
    )
{
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR pos;
    PCSTR nextPos;
    PSTR dup;
    BOOL result = FALSE;
    PSTR p;
    UINT num;
    CHAR bigBuf[2048];
    PSTR change;
    CHAR cmdLine[2048];

    //
    // Find the line Affected files
    //

    pos = SdDescribeOutput;
    printf ("\n\n");

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &nextPos)) {
        if (lineEnd > lineStart &&
            StringMatchAB ("Affected files ...", lineStart, lineEnd)
            ) {
            result = TRUE;
            break;
        }

        dup = AllocText ((lineEnd - pos) + 1);

        if (lineEnd > pos) {
            StringCopyAB (dup, pos, lineEnd);
        }

        printf ("%s\n", dup);
        FreeText (dup);

        pos = nextPos;
    }

    if (result) {
        //
        // Files listed in output
        //

        while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &nextPos)) {
            pos = nextPos;

            if (lineStart[0] != '.') {
                continue;
            }

            lineStart += 4;
            if (lineStart > lineEnd) {
                continue;
            }

            //
            // Translate depot path into local path
            //

            StringCopyAB (bigBuf, lineStart, lineEnd);

            p = strrchr (bigBuf, '#');
            if (!p) {
                continue;
            }

            *p = 0;
            num = strtoul (p + 1, &change, 10);

            while (isspace (*change)) {
                change++;
            }

            MappingSearchAndReplace (Map, bigBuf, ARRAYSIZE(bigBuf));

            p = strchr (bigBuf, '/');
            while (p) {
                *p++ = '\\';
                p = strchr (p, '/');
            }

            if (StringIMatch (change, "edit") && num > 1) {
                wsprintf (cmdLine, "windiff.exe %s#%u %s#%u", bigBuf, num - 1, bigBuf, num);
                GlAppendString (&g_WindiffCmds, cmdLine);
            }

            printf ("%s: %s#%u\n", change, bigBuf, num);

        }
    }

    return GlGetSize (&g_WindiffCmds) > 0;
}


BOOL
pLaunchSd (
    IN      PSTR CmdLine,
    IN      HANDLE TempFile,
    IN      PCSTR Msg,
    OUT     HANDLE *Mapping,
    OUT     PCSTR *FileContent,
    OUT     PCSTR *Eof
    )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    LONG rc;

    SetFilePointer (TempFile, 0, NULL, FILE_BEGIN);
    SetEndOfFile (TempFile);

    ZeroMemory (&si, sizeof (si));

    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = GetStdHandle (STD_INPUT_HANDLE);

    if (!DuplicateHandle (
            GetCurrentProcess(),
            TempFile,
            GetCurrentProcess(),
            &si.hStdOutput,
            0,
            TRUE,
            DUPLICATE_SAME_ACCESS
            )) {
        printf ("Can't dup temp file handle\n");
        return FALSE;
    }

    si.hStdError = GetStdHandle (STD_ERROR_HANDLE);

    if (!CreateProcess (
            NULL,
            CmdLine,
            NULL,
            NULL,
            TRUE,
            0,
            NULL,
            NULL,
            &si,
            &pi
            )) {
        printf ("Can't launch sd describe\n");
        CloseHandle (si.hStdOutput);
        return FALSE;
    }

    printf ("%s", Msg);
    rc = WaitForSingleObject (pi.hProcess, INFINITE);
    printf ("\n");

    CloseHandle (pi.hProcess);
    CloseHandle (pi.hThread);
    CloseHandle (si.hStdOutput);

    if (rc != WAIT_OBJECT_0) {
        return FALSE;
    }

    if (!GetFileSize (TempFile, NULL)) {
        return FALSE;
    }

    *Mapping = CreateFileMapping (TempFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(*Mapping)) {
        printf ("Can't map temp file into memory\n");
        return FALSE;
    }

    *FileContent = (PCSTR) MapViewOfFile (*Mapping, FILE_MAP_READ, 0, 0, 0);
    if (!*FileContent) {
        printf ("Can't map temp file data into memory\n");
        CloseHandle (*Mapping);
        return FALSE;
    }

    *Eof = *FileContent + GetFileSize (TempFile, NULL);

    return TRUE;
}


BOOL
pLaunchWindiff (
    IN      PCSTR CmdLine
    )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    LONG rc;
    PSTR writableCmdLine = DuplicateText (CmdLine);

    ZeroMemory (&si, sizeof (si));

    if (!CreateProcess (
            NULL,
            writableCmdLine,
            NULL,
            NULL,
            TRUE,
            0,
            NULL,
            NULL,
            &si,
            &pi
            )) {
        FreeText (writableCmdLine);
        printf ("Can't launch %s\n", CmdLine);
        return FALSE;
    }

    FreeText (writableCmdLine);

    rc = WaitForSingleObject (pi.hProcess, INFINITE);

    CloseHandle (pi.hProcess);
    CloseHandle (pi.hThread);

    return TRUE;
}



INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    UINT change = 0;
    UINT u;
    UINT count;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            HelpAndExit();
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (change) {
                HelpAndExit();
            }

            change = _tcstoul (argv[i], NULL, 10);
            if (!change) {
                HelpAndExit();
            }
        }
    }

    if (!change) {
        HelpAndExit();
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // TODO: Do work here
    //
    {
        TCHAR cmd[MAX_PATH];
        HANDLE tempFile;
        HANDLE mapping;
        PCSTR fileData;
        PCSTR endOfFile;
        BOOL runWinDiff = FALSE;
        CHAR root[MAX_PATH];
        PMAPSTRUCT map;

        tempFile = BfGetTempFile ();
        map = CreateStringMapping();

        if (!tempFile) {
            printf ("Can't create temp file\n");
            exit (1);
        }

        if (!pLaunchSd ("sd client -o", tempFile, "Getting client mapping...", &mapping, &fileData, &endOfFile)) {
            exit (1);
        }

        pParseClientMapping (fileData, endOfFile, root, map);

        wsprintf (cmd, TEXT("sd describe -s %u"), change);
        if (!pLaunchSd (cmd, tempFile, "Getting change list...", &mapping, &fileData, &endOfFile)) {
            exit (1);
        }

        runWinDiff = pParseChangeList (fileData, endOfFile, map);

        UnmapViewOfFile (fileData);
        CloseHandle (mapping);

        DestroyStringMapping (map);
        CloseHandle (tempFile);

        if (runWinDiff) {
            count = GlGetSize (&g_WindiffCmds);

            for (u = 0 ; u < count ; u++) {
                if (!pLaunchWindiff (GlGetString (&g_WindiffCmds, u))) {
                    break;
                }
            }

        }

        GlFree (&g_WindiffCmds);

    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\datalist.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    datalist.c

Abstract:

    functions handling the operation of the listview
    that displays key data in memdbe.exe

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"
#include <commdlg.h>


HWND g_hListData;

#define LISTITEMTEXT_MAX            1024

#define LINEHEADER_VALUE            "VALUE"
#define LINEHEADER_FLAGS            "FLAGS"
#define LINEHEADER_BINARY           "BINARY"
#define LINEHEADER_SINGLE_LINKAGE   "SINGLE LINKAGE"
#define LINEHEADER_DOUBLE_LINKAGE   "DOUBLE LINKAGE"


BOOL
IsDataList (
    HWND hwnd
    )
{
    return (hwnd == g_hListData);
}


BOOL
pIsDataLine (
    BYTE DataFlag,
    PSTR Line
    )
{
    CHAR LineCmp[16];
    switch (DataFlag) {
    case DATAFLAG_VALUE:
        StringCopyA (LineCmp, LINEHEADER_VALUE);
        break;
    case DATAFLAG_FLAGS:
        StringCopyA (LineCmp, LINEHEADER_FLAGS);
        break;
    case DATAFLAG_UNORDERED:
        StringCopyA (LineCmp, LINEHEADER_BINARY);
        break;
    case DATAFLAG_SINGLELINK:
        StringCopyA (LineCmp, LINEHEADER_SINGLE_LINKAGE);
        break;
    case DATAFLAG_DOUBLELINK:
        StringCopyA (LineCmp, LINEHEADER_DOUBLE_LINKAGE);
        break;
    default:
        return FALSE;
    }

    return StringMatchCharCountA (LineCmp, Line, CharCountA (LineCmp));
}



BOOL
DataListInit (
    HWND hdlg
    )
{
    g_hListData = GetDlgItem (hdlg, IDC_LIST_DATA);
    return TRUE;
}


BOOL
DataListClear (
    VOID
    )
{
    if (!ListView_DeleteAllItems (g_hListData)) {
        DEBUGMSG ((DBG_ERROR, "Could not clear List View!"));
        return FALSE;
    }

    return TRUE;
}

BOOL
DataListRefresh (
    VOID
    )
{
    if (!DataListClear ()) {
        return FALSE;
    }
    return TRUE;
}




INT
pDataListAddString (
    PSTR Str,
    LPARAM lParam
    )
{
    INT Index;
    LVITEM ListItem;

    ListItem.mask = LVIF_TEXT | LVIF_PARAM ;
    ListItem.pszText = Str;
    ListItem.iSubItem = 0;
    ListItem.lParam = lParam;

    ListItem.iItem = ListView_GetItemCount (g_hListData);

    Index = ListView_InsertItem (g_hListData, &ListItem);
    if (Index < 0) {
        DEBUGMSG ((DBG_ERROR, "Could not add list item!"));
    }
    return Index;
}


INT
DataListAddData (
    BYTE DataFlag,
    UINT DataValue,
    PBYTE DataPtr
    )
{
    INT i;
    PSTR Ptr;
    LPARAM lParam = 0;
    CHAR ListItemText[LISTITEMTEXT_MAX];

    switch (DataFlag) {
    case DATAFLAG_VALUE:
        sprintf (ListItemText, "%s: 0x%08lX", LINEHEADER_VALUE, DataValue);
        break;
    case DATAFLAG_FLAGS:
        sprintf (ListItemText, "%s: 0x%08lX", LINEHEADER_FLAGS, DataValue);
        break;
    case DATAFLAG_UNORDERED:
        sprintf (ListItemText, "%s: \"", LINEHEADER_BINARY);
        Ptr = GetEndOfStringA (ListItemText);

        for (i=0;i<(INT)(DataValue) && i<LISTITEMTEXT_MAX-2;i++) {
            *(Ptr++) = isprint(DataPtr[i]) ? DataPtr[i] : '.';
        }
        *(Ptr++) = '\"';
        *Ptr = 0;
        ListItemText[LISTITEMTEXT_MAX] = 0;
        break;

    case DATAFLAG_SINGLELINK:
        sprintf (ListItemText, "%s: %s", LINEHEADER_SINGLE_LINKAGE, (PSTR)DataPtr);
        lParam = DataValue;
        break;

    case DATAFLAG_DOUBLELINK:
        sprintf (ListItemText, "%s: %s", LINEHEADER_DOUBLE_LINKAGE, (PSTR)DataPtr);
        lParam = DataValue;
        break;

    }

    return pDataListAddString (ListItemText, lParam);
}



BOOL
DataListRightClick (
    HWND hdlg,
    POINT pt
    )
{
    HMENU hMenu;
    RECT rect;
    if (!(hMenu = LoadMenu (g_hInst, MAKEINTRESOURCE(IDR_MENU_POPUP))) ||
        (!(hMenu = GetSubMenu (hMenu, MENUINDEX_POPUP_KEY))) ||
        (!(hMenu = GetSubMenu (hMenu, MENUINDEX_POPUP_KEY_ADDDATA)))
        ) {
        return FALSE;
    }

    if (!GetWindowRect (g_hListData, &rect)) {
        return FALSE;
    }

    if (!TrackPopupMenu (hMenu, TPM_LEFTALIGN, pt.x+rect.left, pt.y+rect.top, 0, hdlg, NULL)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
DataListDblClick (
    HWND hdlg,
    INT iItem,
    INT iSubItem
    )
{
    CHAR ListItemText[LISTITEMTEXT_MAX];
    LVITEM Item;

    if (iItem<0) {
        return FALSE;
    }

    Item.mask = LVIF_TEXT | LVIF_PARAM;
    Item.iItem = iItem;
    Item.iSubItem = iSubItem;
    Item.pszText = ListItemText;
    Item.cchTextMax = LISTITEMTEXT_MAX;

    if (!ListView_GetItem (g_hListData, &Item)) {
        return FALSE;
    }

    if (pIsDataLine (DATAFLAG_SINGLELINK, ListItemText)) {
        SendMessage (hdlg, WM_SELECT_KEY, Item.lParam, 0);
        return TRUE;
    }

    if (pIsDataLine (DATAFLAG_DOUBLELINK, ListItemText)) {
        SendMessage (hdlg, WM_SELECT_KEY, Item.lParam, 0);
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\changes\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\dbedit.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdbe.c

Abstract:

    main file for memdbe.exe, containing winmain().
    this creates the application framework, and then
    the child window dialog which has the controls and
    displays.

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"
#include "dialogs.h"

#define MAX_LOADSTRING 100

HWND g_hChildWindow = NULL;
HMENU g_hMenuMain;

#define DEFAULT_WINDOW_TITLE    "MemDb Editor"

#define DEFAULT_FILENAME        "ntsetup.dat"

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);



VOID
HelpAndExit (
    VOID
    )
{
    MessageBox (
        NULL,
        "Command Line Syntax:\n\n"
            "\tmemdbe [database file]\n"
            "\n"
            "If no database file is specified, \"ntsetup.dat\" is opened if it exists.",
        "MemDb Editor",
        MB_OK|MB_ICONINFORMATION
        );

    exit(1);
}


int WINAPI WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpPtr,
    int nCmdShow
    )
{
    HACCEL hAccel;
    static char AppName[] = "MemDbEdit";
    MSG msg;
    HWND hwnd;
    WNDCLASSEX wndclass;
    RECT DialogRect;

    g_hInst = hInstance;

    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW|CS_VREDRAW;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon (NULL, MAKEINTRESOURCE(IDI_ICON_SPHERE));
    wndclass.hCursor = LoadCursor (NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = AppName;
    wndclass.hIconSm = NULL;
    //LoadIcon (NULL, MAKEINTRESOURCE(IDI_ICON1));

    RegisterClassEx (&wndclass);

    hwnd = CreateWindow (
        AppName,
        DEFAULT_WINDOW_TITLE,
        WS_OVERLAPPEDWINDOW & (~WS_MAXIMIZEBOX) & (~WS_THICKFRAME),
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        lpPtr
        );

    ShowWindow (hwnd, nCmdShow);
    UpdateWindow (hwnd);

    hAccel = LoadAccelerators (hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR));

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator (hwnd, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}


VOID
pInitializeSystemMenu (
    HWND hwnd
    )
{
    HMENU hMenu;

    hMenu = GetSystemMenu (hwnd, FALSE);
    RemoveMenu (hMenu, SC_MAXIMIZE, MF_BYCOMMAND);
    RemoveMenu (hMenu, SC_SIZE, MF_BYCOMMAND);

}



BOOL
pInitializeWindows (
    HWND hwnd
    )
{
    RECT rect, rect2;

    g_hMenuMain = LoadMenu (g_hInst, MAKEINTRESOURCE(IDR_MENU_MAIN));
    SetMenu (hwnd, g_hMenuMain);

    g_hChildWindow = CreateDialog (
                        g_hInst,
                        MAKEINTRESOURCE(IDD_DIALOG_CHILD),
                        hwnd,
                        MainDlgProc
                        );

    if (!g_hChildWindow) {
        DEBUGMSG ((DBG_ERROR, "Could not create child window!"));
    }

    GetWindowRect(hwnd, &rect);
    GetWindowRect(g_hChildWindow, &rect2);

    MoveWindow (
        hwnd,
        rect.left,
        rect.top,
        (rect2.right-rect2.left) + 2*GetSystemMetrics(SM_CXDLGFRAME),
        (rect2.bottom-rect2.top) + 2*GetSystemMetrics(SM_CYDLGFRAME) + GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYMENU),
        FALSE
        );

    ShowWindow (g_hChildWindow, SW_SHOWNORMAL);

    return TRUE;
}

BOOL
pDestroyWindows (
    HWND hwnd
    )
{
    DestroyWindow (g_hChildWindow);
    DestroyMenu (GetMenu(hwnd));

    return TRUE;
}


BOOL
pUpdateWindowTitle (
    HWND hwnd,
    LPSTR OpenFile,
    BOOL IsFileModified
    )
{
    char TempString[512];

    if (OpenFile && (OpenFile[0] != '\0')) {
        StringCopyA (TempString, OpenFile);
        StringCatA (TempString, " - ");
    } else {
        TempString[0] = '\0';
    }

    StringCatA (TempString, DEFAULT_WINDOW_TITLE);

    if (IsFileModified) {
        StringCatA (TempString, " *");
    }

    SetWindowText (hwnd, TempString);

    return TRUE;
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL b;
    LPSTR Ptr;
    POINT pt;
    HWND hChildWnd;
    static LPCREATESTRUCT pCS;

    if (WantProcess (message, wParam, lParam)) {
        //
        // if the dialog window message handler wants to process the message
        // send it to it (in MemdbInt.c)
        //
        return SendMessage (g_hChildWindow, message, wParam, lParam);
    }

    switch (message)
    {
    case WM_CREATE:
        pInitializeSystemMenu (hwnd);

        InitializeMemDb (hwnd);
        pInitializeWindows (hwnd);

        pUpdateWindowTitle (hwnd, "", FALSE);

        pCS = (LPCREATESTRUCT)lParam;
        Ptr = (LPSTR)pCS->lpCreateParams;
        if (_mbschr (Ptr, '?')) {
            HelpAndExit ();
        }

        if (Ptr[0]!='\0') {
            SendMessage (g_hChildWindow, WM_FILE_LOAD, (WPARAM)Ptr, 0);
        } else if (DoesFileExistA (DEFAULT_FILENAME)) {
            SendMessage (g_hChildWindow, WM_FILE_LOAD, (WPARAM)(DEFAULT_FILENAME), 0);
        }

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case ID_HELP_ABOUT:
            AboutDialog (hwnd);
            break;

        case ID_FILE_QUIT:
            SendMessage (g_hChildWindow, WM_QUIT_CHECK, (WPARAM)&b, 0);
            if (b) {
                DestroyWindow(hwnd);
            }
            break;
        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;

    case WM_SYSCOMMAND:
        switch (wParam) {
        case SC_CLOSE:
            SendMessage (g_hChildWindow, WM_QUIT_CHECK, (WPARAM)&b, 0);
            if (b) {
                DestroyWindow(hwnd);
            }
            break;

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
        }

        break;

    case WM_FILE_UPDATE:

        pUpdateWindowTitle (hwnd, (LPSTR)wParam, (BOOL)lParam);
        break;

    case WM_DESTROY:
        pDestroyWindows (hwnd);
        DestroyMemDb ();

        PostQuitMessage (0);
        break;

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\dbeditp.h ===
#include "resource.h"

#define INVALID_KEY_HANDLE          0

extern HINSTANCE g_hInst;


#define WM_FILE_LOAD                (WM_APP + 1)
#define WM_FILE_UPDATE              (WM_APP + 2)
#define WM_QUIT_CHECK               (WM_APP + 3)
#define WM_SELECT_KEY               (WM_APP + 4)


#define MENUINDEX_POPUP_KEY             0
#define MENUINDEX_POPUP_KEY_ADDDATA     0
#define MENUINDEX_MAIN_FILE             0
#define MENUINDEX_MAIN_KEY              1


PSTR
GetPieceOfKey (
    PSTR KeyPtr,
    PSTR PieceBuf
    );


VOID
KeyAddClear (
    VOID
    );

HTREEITEM
KeyAddItem (
    PSTR ItemName,
    HTREEITEM Parent,
    UINT Index
    );


VOID
KeyAddSetFilterPattern (
    PSTR Pattern
    );


BOOL
KeyAddSubLevels (
    HTREEITEM ParentItem
    );



HTREEITEM
KeyAddCreateItem (
    PSTR Key
    );


BOOL
KeyAddCreateChildItem (
    HWND hdlg,
    HTREEITEM hItem
    );





BOOL
IsKeyTree (
    HWND hwnd
    );


BOOL
KeyTreeInit (
    HWND hParent
    );

VOID
KeyTreeDestroy (
    VOID
    );

BOOL
KeyTreeClear (
    VOID
    );

BOOL
KeyTreeRefresh (
    VOID
    );



BOOL
KeyTreeSetIndexOfItem (
    HTREEITEM hItem,
    UINT Index
    );

UINT
KeyTreeGetIndexOfItem (
    HTREEITEM hItem
    );

BOOL
KeyTreeGetNameOfItem (
    HTREEITEM hItem,
    PSTR Buffer
    );






VOID
KeyTreeSelectItem (
    HTREEITEM hItem
    );

VOID
KeyTreeSelectKey (
    UINT Index
    );

VOID
KeyTreeSelectRClickItem (
    VOID
    );


HTREEITEM
KeyTreeSelChanged (
    HWND hdlg,
    LPNMTREEVIEW pnmtv
    );



BOOL
KeyTreeBeginDrag (
    HWND hWnd,
    LPNMTREEVIEW pnmtv
    );


BOOL
KeyTreeMoveDrag (
    POINTS pt
    );


BOOL
KeyTreeEndDrag (
    BOOL TakeAction,
    POINTS *pt
    );







BOOL
KeyTreeRenameItem (
    HTREEITEM hItem,
    LPSTR Name
    );


BOOL
KeyTreeDeleteKey (
    HTREEITEM hItem
    );

BOOL
KeyTreeDeleteItem (
    HTREEITEM hItem
    );




VOID
KeyTreeExpandItem (
    HTREEITEM hItem,
    BOOL Expand,
    BOOL Recurse
    );




BOOL
KeyTreeRightClick (
    HWND hdlg,
    HTREEITEM hItem
    );

BOOL
KeyTreeForceEditLabel (
    HTREEITEM hItem
    );




BOOL
KeyTreeCreateItem (
    HWND hdlg
    );

BOOL
KeyTreeCreateChildItem (
    HWND hdlg,
    HTREEITEM hItem
    );


HTREEITEM
KeyTreeFindChildItem (
    HTREEITEM hItem,
    PSTR Str
    );

BOOL
KeyTreeFindNext (
    VOID
    );

BOOL
KeyTreeFind (
    HWND hdlg
    );




BOOL
KeyTreeCreateEmptyKey (
    HTREEITEM hItem
    );


BOOL
KeyTreeAddShortData (
    HWND hwnd,
    HTREEITEM hItem,
    BYTE DataFlag
    );

BOOL
KeyTreeClearData (
    HTREEITEM hItem
    );


VOID
KeyTreeSetFilterPattern (
    PSTR Pattern
    );

BOOL
KeyTreeCreateLinkage (
    HWND hdlg,
    HTREEITEM hItem,
    BOOL SingleLinkage,
    BYTE Instance
    );






BOOL
IsDataList (
    HWND hwnd
    );


BOOL
DataListInit (
    HWND hdlg
    );


BOOL
DataListClear (
    VOID
    );

BOOL
DataListRefresh (
    VOID
    );





INT
DataListAddData (
    BYTE DataFlag,
    UINT DataValue,
    PBYTE DataPtr
    );

BOOL
DataListRightClick (
    HWND hdlg,
    POINT pt
    );

BOOL
DataListDblClick (
    HWND hdlg,
    INT iItem,
    INT iSubItem
    );


BOOL
CALLBACK
MainDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
WantProcess (
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
InitializeMemDb (
    HWND hWnd
    );

BOOL
DestroyMemDb (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\dialogs.h ===
VOID
AboutDialog (
    HWND hwnd
    );

BOOL
KeyFindDialog (
    HWND hwnd,
    PSTR StringBuffer,
    PBOOL UsePattern
    );

BOOL
ShortDataDialog (
    HWND hwnd,
    BYTE DataFlag,
    PDWORD DataValue,
    PBOOL AddData,
    PBYTE Instance
    );

BOOL
LinkageDialog (
    HWND hwnd,
    PSTR Key1,
    PSTR Key2
    );


BOOL
CreateKeyDialog (
    HWND hwnd,
    PSTR KeyName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\fileenum\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\dialogs.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    functions handling the dialog boxes in memdbe.exe

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/



#include "pch.h"

#include "dbeditp.h"



BOOL CALLBACK pAboutProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            break;
    }
    return FALSE;
}


VOID
AboutDialog (
    HWND hwnd
    )
{
    DialogBox(g_hInst, MAKEINTRESOURCE(IDD_DIALOG_ABOUT), hwnd, pAboutProc);
}





typedef struct {
    PSTR StringBuffer;
    BOOL UsePattern;
} FINDSTRUCT, *PFINDSTRUCT;


BOOL CALLBACK pKeyFindDialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL UsePatternState = TRUE;
    static PFINDSTRUCT fs;

    switch (uMsg) {
    case WM_INITDIALOG:
        fs = (PFINDSTRUCT)lParam;
        if (fs->StringBuffer) {
            SetDlgItemText (hdlg, IDC_EDIT_KEYPATTERN, fs->StringBuffer);
        }

        SetFocus (GetDlgItem (hdlg, IDC_EDIT_KEYPATTERN));
        SendMessage(GetDlgItem (hdlg, IDC_EDIT_KEYPATTERN), EM_SETSEL, 0, -1);
        CheckDlgButton (hdlg, IDC_CHECK_USEPATTERN, UsePatternState ? BST_CHECKED : BST_UNCHECKED);

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDOK:
            if (fs->StringBuffer) {
                GetDlgItemText (hdlg, IDC_EDIT_KEYPATTERN, fs->StringBuffer, MEMDB_MAX);
            }
            UsePatternState = (IsDlgButtonChecked (hdlg, IDC_CHECK_USEPATTERN) == BST_CHECKED);
            fs->UsePattern = UsePatternState;
            EndDialog (hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog (hdlg, FALSE);
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        };

        break;
    };

    return FALSE;
}


BOOL
KeyFindDialog (
    HWND hwnd,
    PSTR StringBuffer,
    PBOOL UsePattern
    )
{
    BOOL b;
    FINDSTRUCT fs;

    fs.StringBuffer = StringBuffer;

    if (!DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG_KEYFIND),
        hwnd,
        pKeyFindDialogProc,
        (LPARAM)&fs
        )) {
        return FALSE;
    }

    if (UsePattern) {
        *UsePattern = fs.UsePattern;
    }

    return TRUE;
}






typedef struct {
    BYTE DataFlag;
    UINT DataValue;
    BOOL AddData;
    BYTE Instance;
} DATASTRUCT, *PDATASTRUCT;



#define DATA_STR_LEN        16

BOOL
CALLBACK
pShortDataDialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static INT InitBaseButtonCheck = IDC_RADIO_HEX;
    static BOOL AddButtonCheck = FALSE;
    static PDATASTRUCT pds = NULL;
    static CHAR DataStr[DATA_STR_LEN];

    switch (uMsg) {

    case WM_INITDIALOG:
        pds = (PDATASTRUCT)lParam;
        pds->DataValue = 0;
        CheckDlgButton (hdlg, InitBaseButtonCheck, BST_CHECKED);
        CheckDlgButton (hdlg, AddButtonCheck ? IDC_RADIO_ADDDATA : IDC_RADIO_SETDATA, BST_CHECKED);

        switch (pds->DataFlag) {
        case DATAFLAG_VALUE:
            SetWindowText (hdlg, "Set Value");
            break;
        case DATAFLAG_FLAGS:
            SetWindowText (hdlg, "Set Flags");
            break;
        };

        SetFocus (GetDlgItem (hdlg, IDC_EDIT_DATA));
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText (hdlg, IDC_EDIT_DATA, DataStr, DATA_STR_LEN);

            if (IsDlgButtonChecked (hdlg, IDC_RADIO_HEX) == BST_CHECKED) {
                pds->DataValue = strtol (DataStr, NULL, 16);
                InitBaseButtonCheck = IDC_RADIO_HEX;
            } else {
                pds->DataValue = strtol (DataStr, NULL, 10);
                InitBaseButtonCheck = IDC_RADIO_DEC;
            }

            pds->AddData = (IsDlgButtonChecked (hdlg, IDC_RADIO_ADDDATA) == BST_CHECKED);
            AddButtonCheck = pds->AddData;

            EndDialog (hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog (hdlg, FALSE);
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        };

        break;
    };

    return FALSE;
}


BOOL
ShortDataDialog (
    HWND hwnd,
    BYTE DataFlag,
    PDWORD DataValue,
    PBOOL AddData,
    PBYTE Instance
    )
{

    DATASTRUCT ds;

    if ((DataFlag != DATAFLAG_VALUE) && (DataFlag != DATAFLAG_FLAGS)) {
        return FALSE;
    }

    ZeroMemory (&ds, sizeof (ds));
    ds.DataFlag = DataFlag;

    if (!DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG_SHORTDATA),
        hwnd,
        pShortDataDialogProc,
        (LPARAM)&ds
        )) {

        return FALSE;
    }

    if (DataValue) {
        *DataValue = ds.DataValue;
    }

    if (AddData) {
        *AddData = ds.AddData;
    }

    if (Instance) {
        *Instance = ds.Instance;
    }

    return TRUE;
}




typedef struct {
    PSTR Key1, Key2;
} LINKAGESTRUCT, *PLINKAGESTRUCT;


BOOL CALLBACK pLinkageDialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PLINKAGESTRUCT pls = NULL;

    switch (uMsg) {

    case WM_INITDIALOG:
        pls = (PLINKAGESTRUCT)lParam;

        SetDlgItemText (hdlg, IDC_EDIT_KEY1, pls->Key1);
        SetDlgItemText (hdlg, IDC_EDIT_KEY2, pls->Key2);

        SetFocus (GetDlgItem (hdlg, (pls->Key1[0]=='\0') ? IDC_EDIT_KEY1 : IDC_EDIT_KEY2));
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText (hdlg, IDC_EDIT_KEY1, pls->Key1, MEMDB_MAX);
            GetDlgItemText (hdlg, IDC_EDIT_KEY2, pls->Key2, MEMDB_MAX);
            EndDialog (hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog (hdlg, FALSE);
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        };

        break;
    };

    return FALSE;
}


BOOL
LinkageDialog (
    HWND hwnd,
    PSTR Key1,
    PSTR Key2
    )
{
    LINKAGESTRUCT ls;

    if (!Key1 || !Key2) {
        return FALSE;
    }

    ls.Key1 = Key1;
    ls.Key2 = Key2;

    if (!DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG_LINKAGE),
        hwnd,
        pLinkageDialogProc,
        (LPARAM)&ls
        )) {
        return FALSE;
    }

    return (Key1[0]!='\0' && Key2[0]!='\0');
}




BOOL CALLBACK pCreateKeyDialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PSTR Str = NULL;

    switch (uMsg) {

    case WM_INITDIALOG:
        Str = (PSTR)lParam;
        SetFocus (GetDlgItem (hdlg, IDC_EDIT_KEY));
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText (hdlg, IDC_EDIT_KEY, Str, MEMDB_MAX);
            EndDialog (hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog (hdlg, FALSE);
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        };

        break;
    };

    return FALSE;
}


BOOL
CreateKeyDialog (
    HWND hwnd,
    PSTR KeyName
    )
{
    if (!KeyName) {
        return FALSE;
    }

    return DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG_CREATEKEY),
        hwnd,
        pCreateKeyDialogProc,
        (LPARAM)KeyName
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\keyadd.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    keytree.c

Abstract:

    functions handling the operation of the treeview
    that displays the keys in a memdb tree in memdbe.exe

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"

//
// controls in display
//
extern HWND g_hTreeKey;

//
// when we put items in the treeview, instead of just inserting
// them, we create a growlist which we fill with relevant data.
// then we go through that and filter if necessary, and then
// we put the remaining stuff in the tree.
//
INT g_LastItem = -1;
CHAR g_LastItemName[MEMDB_MAX] = "";
GROWLIST g_AddList = INIT_GROWLIST;
typedef struct {
    INT ParentListIndex;
    UINT KeyIndex;
    HTREEITEM TreeItem;
    BYTE Flags;
    CHAR Name[];
} ADDLISTITEM, *PADDLISTITEM;

#define ADDLISTFLAG_ENDPOINT    0x01
#define ADDLISTFLAG_KEEP        0x02


extern BOOL g_ParsePaths = TRUE;

CHAR g_KeyPiece[MEMDB_MAX] = "";

CHAR g_FilterPattern[MEMDB_MAX] = "";






//
// functions we need from keytree.c
//
extern BOOL
KeyTreeGetNameOfItem (
    HTREEITEM hItem,
    PSTR Buffer
    );

extern HTREEITEM
KeyTreeFindChildItem (
    HTREEITEM hItem,
    PSTR Str
    );



#define ISDRIVELETTER(Str) ((Str) && (Str)[1]==':' && ((Str)[2]=='\0' || (Str)[2]=='\\'))

PSTR
GetPieceOfKey (
    PSTR KeyPtr,
    PSTR PieceBuf
    )
{
    PSTR Cur;
    if (!KeyPtr || (*KeyPtr=='\0') || (*KeyPtr=='\\')) {
        return NULL;
    }

    while ((*KeyPtr!='\0') && (*KeyPtr!='\\')) {
        *(PieceBuf++) = *(KeyPtr++);
    }

    *PieceBuf = '\0';
    if (*KeyPtr == '\\') {
        KeyPtr++;
    }

    return KeyPtr;
}


HTREEITEM
pKeyAddEnumFirstChild (
    HTREEITEM hParent
    )
{
    if (hParent == NULL) {
        return TreeView_GetRoot (g_hTreeKey);
    }
    return TreeView_GetChild (g_hTreeKey, hParent);
}

HTREEITEM
pKeyAddEnumNextChild (
    HTREEITEM hPrevChild
    )
{
    return TreeView_GetNextSibling (g_hTreeKey, hPrevChild);
}





VOID
KeyAddClear (
    VOID
    )
{
    g_LastItem = -1;
    g_LastItemName[0] = '\0';
}


HTREEITEM
KeyAddItem (
    PSTR ItemName,
    HTREEITEM Parent,
    KEYHANDLE Index
    )
{
    HTREEITEM Item;
    TVINSERTSTRUCT tvis;
    tvis.hParent = Parent;
    tvis.hInsertAfter = TVI_LAST;
    tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvis.item.pszText = ItemName;
    tvis.item.iImage = 0;
    tvis.item.iSelectedImage = 1;
    tvis.item.lParam = Index;

    Item = TreeView_InsertItem (g_hTreeKey, &tvis);
    return Item;
}




INT
pKeyAddItemToList (
    PSTR ItemName,
    INT ParentListIndex,
    KEYHANDLE Index,
    BOOL EndPoint
    )
{
    PADDLISTITEM pItem;
    ADDLISTITEM ali;

    ali.TreeItem = NULL;
    ali.KeyIndex = Index;
    ali.ParentListIndex = ParentListIndex;
    ali.Flags = EndPoint ? ADDLISTFLAG_ENDPOINT : 0;

    if (!(pItem = (PADDLISTITEM) GlAppend (
        &g_AddList,
        (PBYTE)&ali,
        sizeof(ADDLISTITEM) + CharCountA (ItemName) + 1
        )))
    {
        DEBUGMSG ((DBG_ERROR, "Could not add item because GrowListAppend failed"));
        return -1;
    }

    StringCopyA (pItem->Name, ItemName);
    return GlGetSize (&g_AddList) - 1;
}


INT
pKeyAddKeyToList (
    PSTR Name,
    KEYHANDLE Index,
    BOOL EndPoint
    )
{
    PADDLISTITEM ali;
    INT Len;
    PSTR Next, NameLeft;
    INT ItemIndex;

    NameLeft = Name;

    while (g_LastItem >= 0) {
        Len = CharCountA (g_LastItemName);

        if (StringIMatchCharCountA (g_LastItemName, Name, Len) && (Name[Len]=='\\')) {
            //
            // we have found the parent of the new item
            //
            NameLeft = Name + Len + 1;
            break;
        }

        ali = (PADDLISTITEM) GlGetItem (&g_AddList, g_LastItem);
        if (((g_LastItem = ali->ParentListIndex) < 0) ||
            !(Next = _mbsrchr (g_LastItemName, '\\')))
        {
            g_LastItem = -1;
            g_LastItemName[0] = '\0';
            NameLeft = Name;
            break;
        }

        *Next = '\0';
    }

    if (ISDRIVELETTER (NameLeft) && g_ParsePaths)
    {
        if (EndPoint) {
            return pKeyAddItemToList (NameLeft, g_LastItem, Index, TRUE);
        } else {
            return -1;
        }
    }

    ItemIndex = pKeyAddItemToList (NameLeft, g_LastItem, Index, EndPoint);
    if (g_LastItem >= 0) {
        StringCatA (g_LastItemName, "\\");
        StringCatA (g_LastItemName, NameLeft);
    } else {
        StringCopyA (g_LastItemName, NameLeft);
    }
    g_LastItem = ItemIndex;
    return ItemIndex;
}


VOID
pKeyAddKeepListIndex (
    INT Index
    )
{
    PADDLISTITEM ali;

    if (Index < 0) {
        return;
    }
    ali = (PADDLISTITEM) GlGetItem (&g_AddList, Index);
    ali->Flags |= ADDLISTFLAG_KEEP;

    //
    // recurse up tree, marking all parent index items to keep them.
    //
    pKeyAddKeepListIndex (ali->ParentListIndex);
}

BOOL
pKeyAddApplyFilterToList (
    VOID
    )
{
    PCTSTR key;
    INT i, count;
    PADDLISTITEM ali;
    PPARSEDPATTERN parsedPattern;

    if (g_FilterPattern[0] == 0) {
        return TRUE;
    }

    parsedPattern = CreateParsedPattern (g_FilterPattern);

    count = GlGetSize (&g_AddList);

    for (i=0; i < count; i++) {

        ali = (PADDLISTITEM) GlGetItem (&g_AddList, i);
        if (ali->Flags & ADDLISTFLAG_ENDPOINT) {
            key = MemDbGetKeyFromHandle (ali->KeyIndex, 0);

            if (key) {
                if (TestParsedPattern (parsedPattern, key)) {
                    //
                    // we have found an endpoint that matches the pattern, so
                    // mark it and all its parents to keep them.
                    //
                    pKeyAddKeepListIndex (i);
                }

                MemDbReleaseMemory (key);
            }
        }
    }

    DestroyParsedPattern (parsedPattern);

    return TRUE;
}


BOOL
pKeyAddList (
    VOID
    )
{
    PADDLISTITEM ali, temp;
    HTREEITEM hParent;
    INT i, count;
    BOOL NoFilter;

    count = GlGetSize (&g_AddList);

    NoFilter = (g_FilterPattern[0] == '\0');

    for (i=0; i<count; i++) {

        ali = (PADDLISTITEM) GlGetItem (&g_AddList, i);
        if (ali->ParentListIndex >= 0) {
            //
            // get the index of the additem that is the parent of this
            // item, and then get the treeitem handle from that.
            //
            temp = (PADDLISTITEM) GlGetItem (&g_AddList, ali->ParentListIndex);
            hParent = temp->TreeItem;
        } else {
            hParent = NULL;
        }

        if (NoFilter || (ali->Flags & ADDLISTFLAG_KEEP)) {
            if (!(ali->TreeItem = KeyAddItem (ali->Name, hParent, ali->KeyIndex))) {
                DEBUGMSG ((DBG_ERROR, "Could not add item!"));
                return FALSE;
            }
        }
    }

    return TRUE;
}



BOOL
KeyAddSubLevels (
    HTREEITEM ParentItem
    )
{
    HTREEITEM hItem;
    MEMDB_ENUM e;
    TCHAR Key[MEMDB_MAX];

    g_LastItem = -1;

    ZeroMemory (&g_AddList, sizeof (g_AddList));

    if (ParentItem) {
        KeyTreeGetNameOfItem (ParentItem, Key);
        StringCat (Key, TEXT("\\*"));
    } else {
        StringCopy (Key, TEXT("*"));
    }

    if (MemDbEnumFirst (&e, Key, ENUMFLAG_ALL, 0, ENUMLEVEL_ALLLEVELS)) {
        do {
            pKeyAddKeyToList (e.FullKeyName, e.KeyHandle, e.EndPoint);

        } while (MemDbEnumNext (&e));
    }

    pKeyAddApplyFilterToList ();
    pKeyAddList ();

    GlFree (&g_AddList);
    ZeroMemory (&g_AddList, sizeof (g_AddList));

    return TRUE;
}



VOID
KeyAddSetFilterPattern (
    PSTR Pattern
    )
{
    if (Pattern) {
        StringCopyA (g_FilterPattern, Pattern);
    } else {
        g_FilterPattern[0] = '\0';
    }
}












HTREEITEM
KeyAddCreateItem (
    PSTR Key
    )
{
    BOOL Created = FALSE;
    CHAR NewKey[MEMDB_MAX];
    PSTR Next, End;
    KEYHANDLE Index;
    HTREEITEM hParent = NULL, hItem;

    NewKey[0] = '\0';

    while (Next = GetPieceOfKey (Key, g_KeyPiece)) {

        if (NewKey[0] != '\0') {
            StringCatA (NewKey, "\\");
        }
        StringCat (NewKey, g_KeyPiece);

        if (!(hItem = KeyTreeFindChildItem (hParent, g_KeyPiece))) {

            Created = TRUE;

            if (Next) {
                Index = MemDbAddKey (NewKey);
                if (!Index) {
                    return NULL;
                }
            } else {
                Index = MemDbAddKey (NewKey);
                if (!Index) {
                    return NULL;
                }
            }

            if (!(hItem = KeyAddItem (g_KeyPiece, hParent, Index))) {
                return NULL;
            }
        }

        hParent = hItem;
        Key = Next;
    }

    if (!Created) {
        MessageBox (NULL, "Key already exists", "MemDb Editor", MB_OK|MB_ICONEXCLAMATION);
    }

    return hParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\memdbint.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdbint.c

Abstract:

    operates the main child window of memdbe.exe.

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"
#include <commdlg.h>

HINSTANCE g_hInst;
HANDLE g_hHeap;


extern HMENU g_hMenuMain;
BOOL g_ParsePaths;

OPENFILENAME g_Ofn;

BOOL g_IsFileModified;
CHAR g_FileName[_MAX_PATH];

HTREEITEM g_hSelItem;



BOOL
WantProcess (
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg) {
    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case ID_FILE_NEW:
        case ID_FILE_LOAD:
        case ID_FILE_SAVE:
        case ID_FILE_SAVEAS:
        case ID_FILE_REVERT:
        case ID_KEY_COPYNAME:
        case ID_KEY_CREATENEW:
        case ID_KEY_CREATECHILD:
        case ID_KEY_DELETE:
        case ID_KEY_FIND:
        case ID_KEY_FINDNEXT:
        case ID_KEY_PARSEPATHS:
        case ID_KEY_RENAME:
            return TRUE;
        }
        break;

    }
    return FALSE;
}


BOOL
InitializeMemDb (
    HWND hWnd
    )
{
    g_FileName[0] = '\0';

    g_Ofn.lStructSize = sizeof(OPENFILENAME);
    g_Ofn.hwndOwner = hWnd;
    g_Ofn.hInstance = NULL;
    g_Ofn.lpstrFilter = "DAT files\0*.dat\0All files\0*.*\0";
    g_Ofn.lpstrCustomFilter = NULL;
    g_Ofn.nMaxCustFilter = 0;
    g_Ofn.nFilterIndex = 1;
    g_Ofn.lpstrFile = g_FileName;
    g_Ofn.nMaxFile = _MAX_PATH;
    g_Ofn.lpstrFileTitle = NULL;
    g_Ofn.lpstrInitialDir = NULL;
    g_Ofn.lpstrTitle = NULL;
    g_Ofn.Flags = 0;
    g_Ofn.nFileOffset = 0;
    g_Ofn.nFileExtension = 0;
    g_Ofn.lpstrDefExt = "dat";
    g_Ofn.lCustData = 0L;
    g_Ofn.lpfnHook = NULL;
    g_Ofn.lpTemplateName = NULL;

    UtInitialize (NULL);
    MemDbInitialize ();

    return TRUE;
}


BOOL
DestroyMemDb (
    VOID
    )
{
    g_FileName[0] = '\0';

    MemDbTerminate();
    UtTerminate();

    return FALSE;
}


VOID
pDisplayInit (
    HWND hdlg
    )
{
    HMENU hMenu;

    SetDlgItemText (hdlg, IDC_STATIC_KEYNAME, "");

    if (hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_KEY)) {
        EnableMenuItem (hMenu, ID_KEY_FINDNEXT, MF_GRAYED);
    }

}



BOOL
pUpdateFileStatus (
    HWND hdlg,
    BOOL FileModified
    )
{
    HMENU hMenu;
    HWND hWnd;
    hWnd = GetParent (hdlg);

    g_IsFileModified = FileModified;

    if (hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_FILE)) {
        EnableMenuItem (hMenu, ID_FILE_REVERT, g_IsFileModified ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem (hMenu, ID_FILE_SAVE, g_IsFileModified ? MF_ENABLED : MF_GRAYED);
    }


    if (hWnd) {
        SendMessage (
            hWnd,
            WM_FILE_UPDATE,
            (WPARAM)GetFileNameFromPathA(g_FileName),
            (LPARAM)g_IsFileModified
            );
    }

    return TRUE;
}





BOOL
pRefreshView (
    HWND hdlg
    )
{
    SetDlgItemText (hdlg, IDC_STATIC_KEYNAME, "");
    g_hSelItem = NULL;
    KeyTreeRefresh ();
    DataListRefresh ();

    return TRUE;
}










BOOL
pLoadFile (
    LPSTR FileName
    )
{
    BOOL b;
    if (FileName) {
        b = TRUE;
        if (FileName != g_FileName) {
            //
            // (FileName == g_FileName) when we are reloading the same database
            //
            StringCopyA (g_FileName, FileName);
        }
    } else {
        g_Ofn.Flags = OFN_HIDEREADONLY;
        b = GetOpenFileName (&g_Ofn);
    }

    KeyTreeClear ();
    DataListClear ();
    if (b) {
        if (!(b = MemDbLoadA (g_FileName))) {
            if (GetLastError () == ERROR_BAD_FORMAT) {
                MessageBox (NULL, "Invalid database file format", "Error", MB_OK|MB_ICONEXCLAMATION);
            }
        }
    }

    return b;
}

BOOL
pSaveFile (
    BOOL UseCurrentName
    )
{
    BOOL b = TRUE;
    if (!UseCurrentName || (g_FileName[0] == '\0')) {
        g_Ofn.Flags = OFN_OVERWRITEPROMPT;
        b = GetSaveFileName (&g_Ofn);
    }

    if (b) {
        b = MemDbSaveA (g_FileName);
#ifdef DEBUG
        if (!b) {
            DEBUGMSG ((DBG_ERROR, "Could not save file \"%s\"!", g_FileName));
        }
#endif
    }

    return b;
}


BOOL
pVerifyClose (
    VOID
    )
{
    int Temp;

    if (!g_IsFileModified) {
        return TRUE;
    }

    Temp = MessageBox (
        NULL,
        "Database is modified, save?",
        "MemDb Editor",
        MB_YESNOCANCEL | MB_ICONQUESTION
        );

    if (Temp == IDYES) {
        pSaveFile (TRUE);
    }

    return Temp != IDCANCEL;
}

BOOL
pResetView (
    VOID
    )
{
    KeyTreeSetFilterPattern (NULL);
    return TRUE;
}




VOID
AlertBadNewItemName (
    HTREEITEM hItem,
    PSTR ErrorStr
    )
{
    if (MessageBox (
        NULL,
        ErrorStr ? ErrorStr : "Error",
        "Error",
        MB_OKCANCEL | MB_ICONEXCLAMATION
        ) == IDOK)
    {
        KeyTreeForceEditLabel (hItem);
    } else {
        KeyTreeDeleteItem (hItem);
    }
}


BOOL
pFindKey (
    HWND hdlg
    )
{
    BOOL b;
    HMENU hMenu;

    b = KeyTreeFind (hdlg);

    if (b) {
        if (hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_KEY)) {
            EnableMenuItem (hMenu, ID_KEY_FINDNEXT, MF_ENABLED);
        }
    }

    return b;
}

BOOL
pFindNextKey (
    HWND hdlg
    )
{
    BOOL b;
    HMENU hMenu;

    b = KeyTreeFindNext ();

    if (!b) {
        if (hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_KEY)) {
            EnableMenuItem (hMenu, ID_KEY_FINDNEXT, MF_GRAYED);
        }
    }

    return b;
}


BOOL
pToggleParsePaths (
    HWND hdlg
    )
{
    HMENU hMenu;

    if (!(hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_KEY))) {
        return FALSE;
    }

    g_ParsePaths = !(GetMenuState (hMenu, ID_KEY_PARSEPATHS, MF_BYCOMMAND) & MF_CHECKED);
    CheckMenuItem (hMenu, ID_KEY_PARSEPATHS, MF_BYCOMMAND | (g_ParsePaths?MF_CHECKED:MF_UNCHECKED));

    pRefreshView (hdlg);

    return FALSE;
}


VOID
pSetFilter (
    HWND hdlg,
    BOOL UseInput
    )
{
    CHAR Filter[MEMDB_MAX];

    if (UseInput) {
        GetDlgItemText (hdlg, IDC_EDIT_FILTERPATTERN, Filter, MEMDB_MAX);
    } else {
        Filter[0] = '\0';
    }

    KeyTreeSetFilterPattern (Filter);
    pRefreshView (hdlg);
}


BOOL
pCopyKeyNameToClipboard (
    HWND hdlg,
    HTREEITEM hItem
    )
{
    CHAR KeyName[MEMDB_MAX];

    if (!KeyTreeGetNameOfItem (hItem, KeyName)) {
        DEBUGMSG ((DBG_ERROR, "Could not get name of item"));
        return FALSE;
    }

    SetDlgItemText (hdlg, IDC_EDIT_KEYNAMEHIDDEN, KeyName);

    SendMessage (GetDlgItem (hdlg, IDC_EDIT_KEYNAMEHIDDEN), EM_SETSEL, 0, -1);
    SendMessage (GetDlgItem (hdlg, IDC_EDIT_KEYNAMEHIDDEN), WM_COPY, 0, 0);

    return TRUE;
}







BOOL
CALLBACK
MainDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL InDrag = FALSE;
    BOOL b = FALSE;

    switch (uMsg) {

    case WM_INITDIALOG:

        pDisplayInit (hdlg);
        KeyTreeInit (hdlg);
        DataListInit (hdlg);

        g_FileName[0] = '\0';
        pUpdateFileStatus (hdlg, FALSE);

        InDrag = FALSE;
        g_hSelItem = NULL;

        g_ParsePaths = TRUE;

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDC_BUTTON_EXPANDALL:
            if (HIWORD(wParam) == BN_CLICKED) {
                KeyTreeExpandItem (NULL, TRUE, TRUE);
            }
            break;

        case IDC_BUTTON_COLLAPSEALL:
            if (HIWORD(wParam) == BN_CLICKED) {
                KeyTreeExpandItem (NULL, FALSE, TRUE);
            }
            break;

        case IDC_BUTTON_REFRESH:
            if (HIWORD(wParam) == BN_CLICKED) {
                pRefreshView (hdlg);
            }
            break;

        case IDC_BUTTON_APPLYFILTER:
            if (HIWORD(wParam) == BN_CLICKED) {
                pSetFilter (hdlg, TRUE);
            }
            break;

        case IDC_BUTTON_SHOWALL:
            if (HIWORD(wParam) == BN_CLICKED) {
                pSetFilter (hdlg, FALSE);
            }
            break;

        case ID_FILE_NEW:

            if (pVerifyClose ()) {
                g_FileName[0] = '\0';
                pUpdateFileStatus (hdlg, FALSE);
                //MemDbReset();
                pResetView ();
                pRefreshView (hdlg);
            }
            break;

        case ID_FILE_REVERT:

            if (MessageBox (
                NULL,
                "Revert to saved database?",
                "MemDb Editor",
                MB_YESNO | MB_ICONQUESTION
                ) == IDYES)
            {
                if (g_FileName[0]=='\0') {
                    //MemDbReset();
                } else {
                    pLoadFile (g_FileName);
                }

                pRefreshView (hdlg);
                pUpdateFileStatus (hdlg, FALSE);
            }

            break;
        case ID_FILE_LOAD:

            if (pVerifyClose () && pLoadFile (NULL)) {
                pResetView ();
                pRefreshView (hdlg);
                pUpdateFileStatus (hdlg, FALSE);
            }
            break;

        case ID_FILE_SAVE:
        case ID_FILE_SAVEAS:
            //
            // if command is saveas, we dont use same filename.
            //
            if (pSaveFile (LOWORD(wParam) == ID_FILE_SAVE)) {
                pUpdateFileStatus (hdlg, FALSE);
            }
            break;

        case ID_KEY_CREATENEW:
            KeyTreeCreateItem (hdlg);
            break;

        case ID_KEY_CREATECHILD:
            if (g_hSelItem) {
                KeyTreeCreateChildItem (hdlg, g_hSelItem);
            }
            break;

        case ID_KEY_DELETE:
            if (g_hSelItem && KeyTreeDeleteKey (g_hSelItem)) {
                pUpdateFileStatus (hdlg, TRUE);
            }
            break;

        case ID_KEY_CREATELINKAGE:

            if (g_hSelItem && KeyTreeCreateLinkage (hdlg, g_hSelItem, FALSE, 0)) {
                pUpdateFileStatus (hdlg, TRUE);
            }
            break;

        case ID_KEY_COPYNAME:
            if (g_hSelItem) {
                pCopyKeyNameToClipboard (hdlg, g_hSelItem);
            }
            break;

        case ID_KEY_RENAME:
            if (g_hSelItem) {
                KeyTreeForceEditLabel (g_hSelItem);
                KeyTreeSelectItem (g_hSelItem);
            }
            break;

        case ID_KEY_FIND:
            pFindKey (hdlg);
            break;

        case ID_KEY_FINDNEXT:
            pFindNextKey (hdlg);
            break;

        case ID_KEY_PARSEPATHS:

            pToggleParsePaths (hdlg);
            break;

        case ID_KEY_CLEARDATA:
            if (g_hSelItem && KeyTreeClearData (g_hSelItem)) {
                pUpdateFileStatus (hdlg, TRUE);
            }
            break;

        case ID_DATA_ADDVALUE:
        case ID_DATA_ADDFLAGS:
            if (g_hSelItem && KeyTreeAddShortData (
                hdlg,
                g_hSelItem,
                (BYTE)((LOWORD(wParam)==ID_DATA_ADDVALUE) ? DATAFLAG_VALUE : DATAFLAG_FLAGS)
                ))
            {
                pUpdateFileStatus (hdlg, TRUE);
            }
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        }
        break;

    case WM_NOTIFY:

        if (IsKeyTree(((LPNMHDR)lParam)->hwndFrom))
        {
            switch (((LPNMHDR)lParam)->code) {
            case TVN_SELCHANGED:

                g_hSelItem = KeyTreeSelChanged (hdlg, (LPNMTREEVIEW)lParam);
                break;

            case TVN_KEYDOWN:

                switch (((LPNMTVKEYDOWN)lParam)->wVKey) {
                case VK_DELETE:
                    return SendMessage (hdlg, WM_COMMAND, MAKEWPARAM (ID_KEY_DELETE, 0), (LPARAM)NULL);
                case VK_INSERT:
                    return SendMessage (hdlg, WM_COMMAND, MAKEWPARAM (ID_KEY_RENAME, 0), (LPARAM)NULL);
                default:
                    return DefWindowProc(hdlg, uMsg, wParam, lParam);
                }
                break;

            case TVN_BEGINDRAG:

                if (InDrag) {
                    KeyTreeEndDrag (FALSE, NULL);
                    InDrag = FALSE;
                }

                if (KeyTreeBeginDrag (hdlg, (LPNMTREEVIEW)lParam)) {
                    InDrag = TRUE;
                }
                break;

            case TVN_ENDLABELEDIT:

                b = (KeyTreeGetIndexOfItem (g_hSelItem) == INVALID_KEY_HANDLE);
                b = FALSE;  // rename is not implemented

                if (((LPNMTVDISPINFO)lParam)->item.pszText) {
                    if (KeyTreeRenameItem (
                        ((LPNMTVDISPINFO)lParam)->item.hItem,
                        ((LPNMTVDISPINFO)lParam)->item.pszText
                        ))
                    {
                        pUpdateFileStatus (hdlg, TRUE);

                        if (b) {
                            if (!KeyTreeCreateEmptyKey (((LPNMTVDISPINFO)lParam)->item.hItem)) {
                                KeyTreeDeleteItem (((LPNMTVDISPINFO)lParam)->item.hItem);
                            }
                        }
                    }
                } else if (b) {
                    //
                    // for some reason the label edit failed, and this is a new
                    // item (meaning we need a label)
                    //
                    AlertBadNewItemName (g_hSelItem, "New keys must have name");
                }

                break;

            case NM_RCLICK:

                KeyTreeSelectRClickItem ();
                KeyTreeRightClick (hdlg, g_hSelItem);

                break;

            default:
                return DefWindowProc(hdlg, uMsg, wParam, lParam);
            }
        } else if (IsDataList (((LPNMHDR)lParam)->hwndFrom)) {
            switch (((LPNMHDR)lParam)->code) {
            case NM_RCLICK:

                if (g_hSelItem) {
                    DataListRightClick (hdlg, ((LPNMITEMACTIVATE)lParam)->ptAction);
                }
                break;

            case NM_DBLCLK:

                if (g_hSelItem) {
                    DataListDblClick (
                        hdlg,
                        ((LPNMITEMACTIVATE)lParam)->iItem,
                        ((LPNMITEMACTIVATE)lParam)->iSubItem
                        );
                }

                break;

            default:
                return DefWindowProc(hdlg, uMsg, wParam, lParam);
            }
        }
        break;

    case WM_CAPTURECHANGED:
        if (InDrag) {
            //
            // something grabbed the capture away from us while
            // we were dragging, so stop dragging without taking
            // any action.
            //
            InDrag = FALSE;
            KeyTreeEndDrag (FALSE, NULL);
        }
        break;

    case WM_MOUSEMOVE:
        if (InDrag) {
            KeyTreeMoveDrag (MAKEPOINTS(lParam));
        }
        break;

    case WM_LBUTTONUP:

        if (InDrag) {
            InDrag = FALSE;
            if (KeyTreeEndDrag (TRUE, &MAKEPOINTS(lParam))) {
                pUpdateFileStatus (hdlg, TRUE);
            }
        }
        break;

    case WM_FILE_LOAD:

        if (pVerifyClose () && pLoadFile ((LPSTR)wParam)) {
            pRefreshView (hdlg);
            pUpdateFileStatus (hdlg, FALSE);
        }
        break;

    case WM_QUIT_CHECK:

        *((PBOOL)wParam) = pVerifyClose ();
        break;

    case WM_SELECT_KEY:

        KeyTreeSelectKey ((UINT)wParam);
        break;

    case WM_DESTROY:
        KeyTreeDestroy ();
        break;

    default:
        return DefWindowProc(hdlg, uMsg, wParam, lParam);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\fileenum\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include <conio.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    //
    // Initialize the common libs
    //

    if (Reason == DLL_PROCESS_ATTACH) {
        UtInitialize (NULL);
        if (!FileEnumInitialize ()) {
            return FALSE;
        }

    } else {
        FileEnumTerminate ();
        UtTerminate ();
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        "  fileenum [/N] [/S] [/W] [/F] [/L:MaxSubLevel] [/X] <NodePattern> <LeafPattern>\n"

        "\nDescription:\n\n"

        //
        // TODO: Describe tool, indent 2 spaces
        //

        "  Enumerates the part of file system that matches <Pattern>.\n"
        "  Uses C:\\exclude.inf if present and /X not specified to determine what paths/files\n"
        "  are excluded.\n"

        "\nArguments:\n\n"

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        "  /N  Specifies exclusion of directory names from enumeration; optional\n"
        "  /S  Specifies sub-directories to be enumerated before files for any dir; optional\n"
        "  /W  Specifies enumeration should be width-first; optional\n"
        "  /F  Specifies output should use \"dir <filename>\" format; optional\n"
        "  /L:MaxSubLevel  Specifies the maximum sub-level starting from the root of enum;\n"
        "                  -1 = all levels, 0 = only the root level etc.; optional\n"
        "  /X  Specifies to use exclusions in C:\\exclude.inf; optional\n"
        "  <NodePattern>  Specifies the dir pattern\n"
        "  <LeafPattern>  Specifies the file pattern\n"

        );

    exit (1);
}


BOOL
BuildExclusionList (
    IN      PCTSTR FileName
    )
{
    HINF h;
    INFCONTEXT ic;
    TCHAR buf[256];

    h = SetupOpenInfFile (FileName, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    if (SetupFindFirstLine (h, TEXT("Paths"), NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, buf, DWSIZEOF (buf) / DWSIZEOF (TCHAR), NULL)) {
                ElAdd (ELT_PATH, buf);
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    if (SetupFindFirstLine (h, TEXT("Files"), NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, buf, DWSIZEOF (buf) / DWSIZEOF (TCHAR), NULL)) {
                ElAdd (ELT_FILE, buf);
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    SetupCloseInfFile (h);
    return TRUE;
}

BOOL
FileEnumCallback (
    IN      PDIRNODE DirNode        OPTIONAL
    )
{
    BOOL b;

    if (!DirNode) {
        _ftprintf (stderr, TEXT("\nOut of memory\n"));
        return FALSE;
    }
    _ftprintf (stderr, TEXT("Error creating dir node: %s; continue anyway ? (yn):"), DirNode->DirName);
    b = _totupper(_getche ()) == TEXT('Y');
    _ftprintf (stderr, TEXT("\n"));
    return b;
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR nodePattern = NULL;
    PCTSTR leafPattern = NULL;
    PTSTR encodedPattern = NULL;
    PTSTR p;
    PCTSTR level;
    BOOL enumDirNames = TRUE;
    BOOL filesFirst = TRUE;
    BOOL depthFirst = TRUE;
    BOOL nativeFormat = TRUE;
    UINT maxSubLevel = -1;
    BOOL exclusions = FALSE;
    INT pos;
    FILETREE_ENUM e;

    //
    // TODO: Parse command line here
    //
    if (argc < 2) {
        HelpAndExit ();
    }

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('x'):
                exclusions = TRUE;
                break;
            case TEXT('n'):
                enumDirNames = FALSE;
                break;
            case TEXT('s'):
                filesFirst = FALSE;
                break;
            case TEXT('w'):
                depthFirst = FALSE;
                break;
            case TEXT('f'):
                nativeFormat = FALSE;
                break;
            case TEXT('l'):
                if (argv[i][2] == TEXT(':')) {
                    level = &argv[i][3];
                } else if (i + 1 < argc) {
                    level = argv[++i];
                } else {
                    HelpAndExit();
                }
                if (!_stscanf (level, TEXT("%ld%n"), &maxSubLevel, &pos) || level[pos]) {
                    HelpAndExit();
                }
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (nodePattern || leafPattern) {
                HelpAndExit();
            }
            nodePattern = argv[i];
            if (*nodePattern == TEXT('\"')) {
                nodePattern++;
                p = _tcsdec2 (nodePattern, GetEndOfString (nodePattern));
                if (p && *p == TEXT('\"')) {
                    *p = 0;
                }
            }
            leafPattern = argv[i+1];
            i++;
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 2;
    }

    //
    // TODO: Do work here
    //

    if (exclusions) {
        BuildExclusionList (TEXT("C:\\exclude.inf"));
    }

    encodedPattern = ObsBuildEncodedObjectStringEx (nodePattern, leafPattern, FALSE);

    if (EnumFirstFileInTreeEx (
            &e,
            encodedPattern,
            DRIVEENUM_ALLVALID,
            enumDirNames,
            filesFirst,
            depthFirst,
            maxSubLevel,
            exclusions,
            FileEnumCallback
            )) {
        do {
            _putts (nativeFormat ? e.NativeFullName : e.EncodedFullName);
        } while (EnumNextFileInTree (&e));
    }

    //
    // End of processing
    //

    if (exclusions) {
        ElRemoveAll ();
    }

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by memdbe.rc
//
#define IDI_ICON_SPHERE                 101
#define IDD_DIALOG_ABOUT                102
#define IDD_DIALOG_CHILD                105
#define IDR_MENU_MAIN                   106
#define IDB_BITMAP_KEY                  107
#define IDB_BITMAP_KEYSEL               108
#define IDR_ACCELERATOR                 110
#define IDR_MENU_POPUP                  111
#define IDD_DIALOG_SHORTDATA            112
#define IDD_DIALOG_KEYFIND              113
#define IDD_DIALOG_LINKAGE              114
#define IDD_DIALOG_CREATEKEY            115
#define IDC_LIST_DATA                   1003
#define IDC_TREE_KEY                    1004
#define IDC_BUTTON_EXPANDALL            1005
#define IDC_BUTTON_COLLAPSEALL          1006
#define IDC_BUTTON_REFRESH              1008
#define IDC_RADIO_DEC                   1015
#define IDC_RADIO_HEX                   1016
#define IDC_EDIT_DATA                   1017
#define IDC_EDIT_KEYPATTERN             1020
#define IDC_EDIT_FILTERPATTERN          1021
#define IDC_BUTTON_APPLYFILTER          1022
#define IDC_BUTTON_SHOWALL              1023
#define IDC_STATIC_KEYNAME              1024
#define IDC_EDIT_KEYNAMEHIDDEN          1026
#define IDC_EDIT_KEY1                   1027
#define IDC_EDIT_KEY2                   1028
#define IDC_CHECK_USEPATTERN            1031
#define IDC_EDIT_KEY                    1032
#define IDC_RADIO_SETDATA               1033
#define IDC_RADIO_ADDDATA               1034
#define ID_HELP_ABOUT                   40001
#define ID_QUIT                         40002
#define ID_FILE_NEW                     40003
#define ID_FILE_LOAD                    40004
#define ID_FILE_SAVE                    40005
#define ID_FILE_QUIT                    40006
#define ID_FILE_SAVEAS                  40007
#define ID_FILE_REVERT                  40008
#define ID_KEY_CREATECHILD              40009
#define ID_KEY_DELETEITEM               40010
#define ID_KEY_DELETE                   40011
#define ID_KEY_PARSEPATHS               40012
#define ID_KEY_ADDDATA                  40013
#define ID_DATA_ADDVALUE                40014
#define ID_DATA_ADDFLAGS                40015
#define ID_DATA_ADDBINARYDATA           40016
#define ID_DATA_ADDLINKAGE              40018
#define ID_KEY_RENAME                   40019
#define ID_KEY_CLEARDATA                40020
#define ID_KEY_FIND                     40021
#define ID_KEY_FINDNEXT                 40022
#define ID_KEY_COPYNAME                 40023
#define ID_KEY_CREATELINKAGE            40024
#define ID_KEY_CREATENEW                40032
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40033
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\filler\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\homenet\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\icontool\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\lsstub\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\osver\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\regenum\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\dbedit\keytree.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    keytree.c

Abstract:

    functions handling the operation of the treeview
    that displays the keys in a memdb tree in memdbe.exe

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"
#include <commdlg.h>
#include "dialogs.h"

//
// controls in display
//
HWND g_hTreeKey;

//
// distance from corner of client window to
// corner of tree view
//
int g_TreeView_OffsetX, g_TreeView_OffsetY;

//
// handle of item being dragged
//
HTREEITEM g_hDragItem;


CHAR g_Key1[MEMDB_MAX] = "";
CHAR g_Key2[MEMDB_MAX] = "";

CHAR g_FindString[MEMDB_MAX] = "";
HTREEITEM g_hFindItem = NULL;
PPARSEDPATTERNA g_FindParsedPattern = NULL;


BOOL g_UpdateSel = TRUE;

extern VOID
AlertBadNewItemName (
    HTREEITEM hItem,
    PSTR ErrorStr
    );





HTREEITEM
pKeyTreeEnumNextItem (
    HTREEITEM hItem
    )
{
    HTREEITEM hNext;

    if (!hItem) {
        return TreeView_GetRoot (g_hTreeKey);
    }

    if (hNext = TreeView_GetChild (g_hTreeKey, hItem)) {
        return hNext;
    }

    do {
        if (hNext = TreeView_GetNextSibling (g_hTreeKey, hItem)) {
            return hNext;
        }
    } while (hItem = TreeView_GetParent (g_hTreeKey, hItem));

    return NULL;
}





PSTR
pIsChildKey (
    PSTR Parent,
    PSTR Child
    )
{
    INT ParentLen;
    ParentLen = CharCountA (Parent);
    if ((ParentLen > 0) &&
        StringIMatchCharCountA (Parent, Child, ParentLen) &&
        (Child[ParentLen] == '\\')) {
        return Child + ParentLen + 1;
    } else {
        return NULL;
    }
}








BOOL
IsKeyTree (
    HWND hwnd
    )
{
    return (hwnd == g_hTreeKey);
}


BOOL
KeyTreeInit (
    HWND hdlg
    )
{
    HBITMAP hBmp;
    HIMAGELIST ImgList;
    RECT r1, r2;

    g_hTreeKey = GetDlgItem (hdlg, IDC_TREE_KEY);

    GetWindowRect (g_hTreeKey, &r1);
    GetWindowRect (hdlg, &r2);

    g_TreeView_OffsetX = r1.left - r2.left;
    g_TreeView_OffsetY = r1.top - r2.top;

    if ((ImgList = ImageList_Create (16, 16, ILC_COLOR, 2, 0)) == NULL)
        return FALSE;

    hBmp = LoadBitmap (g_hInst, MAKEINTRESOURCE(IDB_BITMAP_KEY));
    ImageList_AddMasked (ImgList, hBmp, RGB (0, 255, 0));
    DeleteObject (hBmp);
    hBmp = LoadBitmap (g_hInst, MAKEINTRESOURCE(IDB_BITMAP_KEYSEL));
    ImageList_AddMasked (ImgList, hBmp, RGB (0, 255, 0));
    DeleteObject (hBmp);

    TreeView_SetImageList (g_hTreeKey, ImgList, TVSIL_NORMAL);

    return TRUE;
}


VOID
KeyTreeDestroy (
    VOID
    )
{
    if (g_FindParsedPattern) {
        DestroyParsedPatternA (g_FindParsedPattern);
    }
}

BOOL
KeyTreeClear (
    VOID
    )
{
    g_UpdateSel = FALSE;
    if (!TreeView_DeleteAllItems (g_hTreeKey)) {
        DEBUGMSG ((DBG_ERROR, "Could not clear Tree View!"));
        return FALSE;
    }
    g_UpdateSel = TRUE;

    KeyTreeSelectItem (NULL);

    KeyAddClear ();
    g_hFindItem = NULL;

    g_hDragItem = NULL;
    return TRUE;
}


BOOL
KeyTreeRefresh (
    VOID
    )
{
    TurnOnWaitCursor ();

    if (!KeyTreeClear ()) {
        return FALSE;
    }

    if (!KeyAddSubLevels (NULL)) {
        DEBUGMSG ((DBG_ERROR, "Could not fill Tree View!"));
        TurnOffWaitCursor ();
        return FALSE;
    }

    InvalidateRect (g_hTreeKey, NULL, TRUE);

    TurnOffWaitCursor ();

    return TRUE;
}



UINT
KeyTreeGetIndexOfItem (
    HTREEITEM hItem
    )
{
    TVITEM tvi;

    if (!hItem) {
        return INVALID_KEY_HANDLE;
    }

    tvi.hItem = hItem;
    tvi.mask = TVIF_PARAM;
    TreeView_GetItem (g_hTreeKey, &tvi);

    return tvi.lParam;
}

BOOL
KeyTreeGetNameOfItem (
    HTREEITEM hItem,
    PSTR Buffer
    )
{
    UINT Index;
    PCSTR key;

    Index = KeyTreeGetIndexOfItem (hItem);

    if (Index == INVALID_KEY_HANDLE) {
        return FALSE;
    }

    key = MemDbGetKeyFromHandleA (Index, 0);

    if (!key) {
        return FALSE;
    }

    StringCopyA (Buffer, key);
    MemDbReleaseMemory (key);

    return TRUE;
}









VOID
KeyTreeSelectItem (
    HTREEITEM hItem
    )
{
    HTREEITEM hItemCur;
    hItemCur = TreeView_GetDropHilight (g_hTreeKey);
    if (hItemCur != hItem) {
        TreeView_SelectDropTarget (g_hTreeKey, hItem);
    }
    hItemCur = TreeView_GetSelection (g_hTreeKey);
    if (hItemCur != hItem) {
        TreeView_SelectItem (g_hTreeKey, hItem);
    }
}

VOID
KeyTreeSelectKey (
    UINT Index
    )
{
    HTREEITEM hItem = NULL;
    PSTR Ptr;
    PCSTR key;

    key = MemDbGetKeyFromHandleA (Index, 0);
    if (!key) {
        return;
    }

    StringCopy (g_Key1, key);
    MemDbReleaseMemory (key);

    Ptr = g_Key1;

    while (Ptr = GetPieceOfKey (Ptr, g_Key2)) {

        if (!(hItem = KeyTreeFindChildItem (hItem, g_Key2))) {
            return;
        }
    }

    KeyTreeSelectItem (hItem);
}





VOID
KeyTreeSelectRClickItem (
    VOID
    )
{
    HTREEITEM hItem;
    hItem = TreeView_GetDropHilight (g_hTreeKey);
    KeyTreeSelectItem (hItem);
}


VOID
pKeyTreeDisplayItemData (
    HTREEITEM hItem
    )
{
    INT i, j;
    INT count;
    CHAR Linkage[MEMDB_MAX];
    KEYHANDLE memdbHandle;
    UINT value;
    UINT flags;
    UINT size;
    PBYTE p;
    KEYHANDLE *keyArray;
    PCSTR key;

    DataListClear ();

    //
    // Fill control with values and flags
    //

    memdbHandle = KeyTreeGetIndexOfItem (hItem);
    if (!memdbHandle) {
        return;
    }

    if (MemDbGetValueAndFlagsByHandle (memdbHandle, &value, &flags)) {
        DataListAddData (DATAFLAG_VALUE, value, NULL);
        DataListAddData (DATAFLAG_FLAGS, flags, NULL);
    }

    //
    // Fill control with unordered binary blobs
    //

    for (i = 0 ; i < 4 ; i++) {
        p = MemDbGetUnorderedBlobByKeyHandle (memdbHandle, (BYTE) i, &size);
        if (p) {
            DataListAddData (DATAFLAG_UNORDERED, size, p);
            MemDbReleaseMemory (p);
        }
    }

    //
    // Fill control with unidirectional linkage
    //

    for (i = 0 ; i < 4 ; i++) {
        keyArray = MemDbGetSingleLinkageArrayByKeyHandle (memdbHandle, (BYTE) i, &size);
        if (keyArray) {
            count = (INT) size / sizeof (KEYHANDLE);
            for (j = 0 ; j < count ; j++) {
                key = MemDbGetKeyFromHandle (keyArray[j], 0);
                DataListAddData (DATAFLAG_SINGLELINK, keyArray[j], (PBYTE) key);
                MemDbReleaseMemory (key);
            }

            MemDbReleaseMemory (keyArray);
        }
    }

    //
    // Fill control with bi-directional linkage
    //

    for (i = 0 ; i < 4 ; i++) {
        keyArray = MemDbGetDoubleLinkageArrayByKeyHandle (memdbHandle, (BYTE) i, &size);
        if (keyArray) {
            count = (INT) size / sizeof (KEYHANDLE);
            for (j = 0 ; j < count ; j++) {
                key = MemDbGetKeyFromHandle (keyArray[j], 0);
                DataListAddData (DATAFLAG_DOUBLELINK, keyArray[j], (PBYTE) key);
                MemDbReleaseMemory (key);
            }

            MemDbReleaseMemory (keyArray);
        }
    }
}


HTREEITEM
KeyTreeSelChanged (
    HWND hdlg,
    LPNMTREEVIEW pnmtv
    )
{
    if (!g_UpdateSel) {
        return NULL;
    }

    KeyTreeSelectItem (pnmtv->itemNew.hItem);

    if (!pnmtv->itemNew.hItem)
    {
        SetDlgItemText (hdlg, IDC_STATIC_KEYNAME, "");
        DataListClear ();
    } else {

        if (KeyTreeGetNameOfItem (pnmtv->itemNew.hItem, g_Key1)) {
            SetDlgItemText (hdlg, IDC_STATIC_KEYNAME, g_Key1);
        }

        pKeyTreeDisplayItemData (pnmtv->itemNew.hItem);
    }

    return pnmtv->itemNew.hItem;
}






BOOL
KeyTreeBeginDrag (
    HWND hWnd,
    LPNMTREEVIEW pnmtv
    )
{
    HIMAGELIST hDragImgList;

    if (!(hDragImgList = TreeView_CreateDragImage (g_hTreeKey, pnmtv->itemNew.hItem))) {
        DEBUGMSG ((DBG_ERROR, "Could not get drag image!"));
        return FALSE;
    }

    if (!ImageList_BeginDrag (hDragImgList, 0, 8, 8)) {
        DEBUGMSG ((DBG_ERROR, "Could not begin drag!"));
        return FALSE;
    }

    if (!ImageList_DragEnter(g_hTreeKey, pnmtv->ptDrag.x, pnmtv->ptDrag.y)) {
        DEBUGMSG ((DBG_ERROR, "Could not enter drag!"));
        return FALSE;
    }

    SetCapture (hWnd);
    g_hDragItem = pnmtv->itemNew.hItem;

    return TRUE;
}


BOOL
KeyTreeMoveDrag (
    POINTS pt
    )
{
    static HTREEITEM hItem, hItem2;
    static RECT TreeRect;
    static TVHITTESTINFO tvht;
    static int x, y, count;

    x = pt.x-g_TreeView_OffsetX;
    y = pt.y-g_TreeView_OffsetY;

    if (!ImageList_DragLeave (g_hTreeKey)) {
        DEBUGMSG ((DBG_ERROR, "Could not leave drag!"));
        return FALSE;
    }

    if (!ImageList_DragMove (x, y)) {
        DEBUGMSG ((DBG_ERROR, "Could not move drag!"));
        return FALSE;
    }

    tvht.pt.x = x;
    tvht.pt.y = y;
    TreeView_HitTest (g_hTreeKey, &tvht);
    if (tvht.flags & TVHT_ONITEM) {
        //
        // if we are over an item and it is not already selected, select it.
        //
        if (TreeView_GetSelection (g_hTreeKey) != tvht.hItem) {
            KeyTreeSelectItem (tvht.hItem);
        }
    } else if (tvht.flags & TVHT_ONITEMBUTTON) {
        //
        // if we are over a plus/minus sign, expand tree
        //
        TreeView_Expand (g_hTreeKey, tvht.hItem, TVE_EXPAND);
    } else if (tvht.flags & TVHT_ABOVE) {
        if (hItem = TreeView_GetFirstVisible (g_hTreeKey)) {
            if (hItem2 = TreeView_GetPrevVisible (g_hTreeKey, hItem)) {
                TreeView_EnsureVisible (g_hTreeKey, hItem2);
            }
        }
    } else if (tvht.flags & TVHT_BELOW) {
        if ((hItem = TreeView_GetFirstVisible (g_hTreeKey)) &&
            ((count = TreeView_GetVisibleCount (g_hTreeKey)) > 0))
        {
            hItem2 = hItem;
            while (hItem2 && count > 0) {
                hItem = hItem2;
                hItem2 = TreeView_GetNextVisible (g_hTreeKey, hItem);
                count --;
            }

            if (hItem2) {
                TreeView_EnsureVisible (g_hTreeKey, hItem2);
            }
        }
    }

    UpdateWindow (g_hTreeKey);

    if (!ImageList_DragEnter(g_hTreeKey, x, y)) {
        DEBUGMSG ((DBG_ERROR, "Could not enter drag!"));
        return FALSE;
    }

    return TRUE;
}




BOOL
KeyTreeEndDrag (
    BOOL TakeAction,
    POINTS *pt
    )
/*++

  only returns TRUE if the memdb database is altered

--*/
{
    TVITEM Item;
    HTREEITEM hItem;
    TVINSERTSTRUCT tvis;
    static TVHITTESTINFO tvht;
    int x, y;

    ReleaseCapture ();

    if (!ImageList_DragLeave (g_hTreeKey)) {
        DEBUGMSG ((DBG_ERROR, "Could not leave drag!"));
        return FALSE;
    }

    ImageList_EndDrag();

    if (!TakeAction) {
        KeyTreeSelectItem (NULL);
        return FALSE;
    }

    x = pt->x-g_TreeView_OffsetX;
    y = pt->y-g_TreeView_OffsetY;

    tvht.pt.x = x;
    tvht.pt.y = y;
    TreeView_HitTest (g_hTreeKey, &tvht);
    if (!(tvht.flags & TVHT_ONITEM)) {
        return FALSE;
    }

    if (!KeyTreeGetNameOfItem (g_hDragItem, g_Key1) ||
        !KeyTreeGetNameOfItem (tvht.hItem, g_Key2)) {
        return FALSE;
    }

    StringCatA (g_Key2, "\\");
    Item.hItem = g_hDragItem;
    Item.mask = TVIF_TEXT;
    Item.pszText = GetEndOfStringA (g_Key2);
    Item.cchTextMax = MEMDB_MAX;
    TreeView_GetItem (g_hTreeKey, &Item);

    //
    // MemDbMoveTree is not implemented
    //

    return FALSE;
/*
    if (!MemDbMoveTreeA (g_Key1, g_Key2)) {
        Beep (200, 50);
        return FALSE;
    }

    //
    // get the dragitem data, then delete it and children,
    // then add to new parent, then fill in child levels.
    //
    tvis.item.hItem = g_hDragItem;
    tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvis.item.pszText = g_Key1;
    tvis.item.cchTextMax = MEMDB_MAX;
    if (!TreeView_GetItem (g_hTreeKey, &tvis.item)) {
        DEBUGMSG ((DBG_ERROR, "Could not get item data!"));
    }

    if (!TreeView_DeleteItem (g_hTreeKey, g_hDragItem)) {
        DEBUGMSG ((DBG_ERROR, "Could not delete item!"));
    }

    tvis.hParent = tvht.hItem;
    tvis.hInsertAfter = TVI_FIRST;
    if (!(hItem = TreeView_InsertItem (g_hTreeKey, &tvis))) {
        DEBUGMSG ((DBG_ERROR, "Could not insert item!"));
    }


    KeyAddSubLevels (hItem);

    KeyTreeSelectItem (hItem);

    return TRUE;
*/
}




BOOL
KeyTreeCreateItem (
    HWND hdlg
    )
{
    HTREEITEM hItem;

    if (!CreateKeyDialog (hdlg, g_Key1)) {
        return FALSE;
    }

    if (!(hItem = KeyAddCreateItem (g_Key1))) {
        return FALSE;
    }

    KeyTreeSelectItem (hItem);
    return TRUE;
}

BOOL
KeyTreeCreateChildItem (
    HWND hdlg,
    HTREEITEM hItem
    )
{
    if (!(hItem = KeyAddItem ("", hItem, INVALID_KEY_HANDLE))) {
        return FALSE;
    }

    KeyTreeSelectItem (hItem);

    if (!KeyTreeForceEditLabel (hItem)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
KeyTreeRenameItem (
    HTREEITEM hItem,
    LPSTR Name
    )
/*++

  only returns TRUE if the memdb database is altered

--*/
{
    HTREEITEM hParent;
    TVITEM Item;
    BOOL NewItem;

    if (!hItem || !Name) {
        return FALSE;
    }

    //
    // MemDbMove is not implemented
    //

    return FALSE;

/*
    hParent = TreeView_GetParent (g_hTreeKey, hItem);

    NewItem = (KeyTreeGetIndexOfItem (hItem) == INVALID_KEY_HANDLE);

    if (KeyTreeFindChildItem (hParent, Name)) {
        if (NewItem) {
            AlertBadNewItemName (hItem, "Name already exists at this level");
        } else {
            MessageBox (NULL, "Name already exists at this level", "Error", MB_OK|MB_ICONEXCLAMATION);
        }
        return FALSE;
    }

    if (NewItem) {
        if (Name[0]=='\0') {
            AlertBadNewItemName (hItem, "New keys must have name");
            return FALSE;
        }
    } else {
        if (!KeyTreeGetNameOfItem (hItem, g_Key1) ||
            !KeyTreeGetNameOfItem (hParent, g_Key2)) {
            return FALSE;
        }

        StringCatA (g_Key2, "\\");
        StringCatA (g_Key2, Name);

        if (!MemDbMoveTreeA (g_Key1, g_Key2)) {
            MessageBox (NULL, "Could not rename item", "Error", MB_OK|MB_ICONEXCLAMATION);
            return FALSE;
        }
    }

    Item.hItem = hItem;
    Item.mask = TVIF_TEXT;
    Item.pszText = Name;
    TreeView_SetItem (g_hTreeKey, &Item);

    return TRUE;
*/
}


BOOL
KeyTreeDeleteKey (
    HTREEITEM hItem
    )
/*++

  only returns TRUE if the memdb database is altered

--*/
{
    CHAR Key[MEMDB_MAX];
    HTREEITEM hParent;

    if (!hItem || !KeyTreeGetNameOfItem (hItem, Key)) {
        return FALSE;
    }

    do {
        //
        // move up tree, deleting parents if they have no other children
        // and they are not an endpoint (memdbgetvalue returns false)
        //
        hParent = TreeView_GetParent (g_hTreeKey, hItem);
        TreeView_DeleteItem (g_hTreeKey, hItem);

        hItem = hParent;
    } while (hItem && !TreeView_GetChild (g_hTreeKey, hItem) &&
        !(KeyTreeGetNameOfItem (hItem, g_Key1) && MemDbGetValueA (g_Key1, NULL)));

    MemDbDeleteTreeA (Key);

    return TRUE;
}


BOOL
KeyTreeDeleteItem (
    HTREEITEM hItem
    )
{
    return TreeView_DeleteItem (g_hTreeKey, hItem);
}



VOID
KeyTreeExpandItem (
    HTREEITEM hItem,
    BOOL Expand,
    BOOL Recurse
    )
{
    HTREEITEM hChildItem;
    if (!hItem) {
        if (!(hItem = TreeView_GetRoot (g_hTreeKey))) {
            return;
        }
    }

    if (!Recurse) {
        TreeView_Expand (g_hTreeKey, hItem, Expand ? TVE_EXPAND : TVE_COLLAPSE);
    } else {

        do {
            hChildItem = TreeView_GetChild (g_hTreeKey, hItem);

            if (hChildItem) {
                TreeView_Expand (g_hTreeKey, hItem, Expand ? TVE_EXPAND : TVE_COLLAPSE);
                KeyTreeExpandItem (hChildItem, Expand, TRUE);
            }
        } while (hItem = TreeView_GetNextSibling (g_hTreeKey, hItem));
    }
}




BOOL
KeyTreeRightClick (
    HWND hdlg,
    HTREEITEM hItem
    )
{
    RECT TVrect, rect;
    HMENU hMenu;

    if (!hItem || !GetWindowRect (g_hTreeKey, &TVrect)) {
        return FALSE;
    }

    TreeView_EnsureVisible (g_hTreeKey, hItem);

    if (!TreeView_GetItemRect (g_hTreeKey, hItem, &rect, TRUE)) {
        DEBUGMSG ((DBG_ERROR, "Error getting item rectangle!"));
    }

    if (!(hMenu = LoadMenu (g_hInst, MAKEINTRESOURCE(IDR_MENU_POPUP))) ||
        (!(hMenu = GetSubMenu (hMenu, MENUINDEX_POPUP_KEY)))) {
        return FALSE;
    }

    if (!TrackPopupMenu (
        hMenu,
        TPM_LEFTALIGN,
        TVrect.left + rect.right + 4,
        TVrect.top + rect.top,
        0,
        hdlg,
        NULL
        )) {
        return FALSE;
    }

    return TRUE;
}





BOOL
KeyTreeForceEditLabel (
    HTREEITEM hItem
    )
{
    if (!hItem) {
        return FALSE;
    }
    if (!TreeView_EditLabel (g_hTreeKey, hItem)) {
        TreeView_DeleteItem (g_hTreeKey, hItem);
        return FALSE;
    }
    return TRUE;
}







HTREEITEM
KeyTreeFindChildItem (
    HTREEITEM hItem,
    PSTR Str
    )
{
    TVITEM Item;
    static CHAR PieceBuf[MEMDB_MAX];

    Item.mask = TVIF_TEXT;
    Item.pszText = PieceBuf;
    Item.cchTextMax = MEMDB_MAX;
    if (hItem == NULL) {
        Item.hItem = TreeView_GetRoot (g_hTreeKey);
    } else {
        Item.hItem = TreeView_GetChild (g_hTreeKey, hItem);
    }

    while (Item.hItem) {
        TreeView_GetItem (g_hTreeKey, &Item);

        if (StringIMatchA (PieceBuf, Str)) {
            return Item.hItem;
        }

        Item.hItem = TreeView_GetNextSibling (g_hTreeKey, Item.hItem);
    }

    return NULL;

}


BOOL
KeyTreeFindNext (
    VOID
    )
{
    BOOL b;
    TurnOnWaitCursor ();

    while (g_hFindItem = pKeyTreeEnumNextItem (g_hFindItem))
    {
        if (!KeyTreeGetNameOfItem (g_hFindItem, g_Key1)) {
            TurnOffWaitCursor ();
            return FALSE;
        }

        if (MemDbGetValueA (g_Key1, NULL)) {
            //
            // if we are looking at an endpoint, see if it matches
            //
            if (g_FindParsedPattern) {
                b = TestParsedPatternA (g_FindParsedPattern, g_Key1);
            } else {
                b = (_mbsistr (g_Key1, g_FindString) != NULL);
            }

            if (b) {
                KeyTreeSelectItem (g_hFindItem);
                TurnOffWaitCursor ();
                return TRUE;
            }
        }
    }
    TurnOffWaitCursor ();

    MessageBox (NULL, "No more keys found", "MemDb Editor", MB_OK|MB_ICONINFORMATION);
    return FALSE;
}



BOOL
KeyTreeFind (
    HWND hwnd
    )
{
    BOOL UsePattern;

    if (!KeyFindDialog (hwnd, g_FindString, &UsePattern)) {
        return FALSE;
    }

    if (g_FindParsedPattern) {
        //
        // if we have an old pattern, destroy it.
        //
        DestroyParsedPatternA (g_FindParsedPattern);
        g_FindParsedPattern = NULL;
    }

    if (UsePattern) {
        g_FindParsedPattern = CreateParsedPatternA (g_FindString);
    }
    g_hFindItem = NULL;

    return KeyTreeFindNext ();
}




BOOL
KeyTreeCreateEmptyKey (
    HTREEITEM hItem
    )
{
    TVITEM Item;
    UINT Index;
    HTREEITEM hParent;

    if (hParent = TreeView_GetParent (g_hTreeKey, hItem)) {
        if (!KeyTreeGetNameOfItem (hParent, g_Key1)) {
            return FALSE;
        }
        StringCatA (g_Key1, "\\");
    } else {
        g_Key1[0] = '\0';
    }

    Item.hItem = hItem;
    Item.mask = TVIF_TEXT;
    Item.pszText = GetEndOfStringA (g_Key1);

    if (!TreeView_GetItem (g_hTreeKey, &Item)) {
        return FALSE;
    }

    Index = MemDbAddKeyA (g_Key1);

    if (!Index) {
        return FALSE;
    }

    Item.mask = TVIF_PARAM;
    Item.lParam = Index;
    return TreeView_SetItem (g_hTreeKey, &Item);
}



BOOL
KeyTreeAddShortData (
    HWND hwnd,
    HTREEITEM hItem,
    BYTE DataFlag
    )
{
    DWORD dataValue;
    BOOL addData;
    BYTE instance;

    if (!hItem || (DataFlag != DATAFLAG_VALUE) && (DataFlag != DATAFLAG_FLAGS)) {
        return FALSE;
    }

    if (!KeyTreeGetNameOfItem (hItem, g_Key1)) {
        DEBUGMSG ((DBG_ERROR, "Could not get item name!"));
        return FALSE;
    }

    if (!ShortDataDialog (hwnd, DataFlag, &dataValue, &addData, &instance)) {
        return FALSE;
    }

    if (addData) {
        if (!MemDbAddUnorderedBlobA (g_Key1, instance, (PBYTE) &dataValue, sizeof (dataValue))) {
            DEBUGMSG ((DBG_ERROR, "Could not add data to item!"));
            return FALSE;
        }
    } else if (DataFlag == DATAFLAG_VALUE) {

        if (!MemDbSetValue (g_Key1, dataValue)) {
            DEBUGMSG ((DBG_ERROR, "Could not set value of item!"));
            return FALSE;
        }
    } else if (DataFlag == DATAFLAG_FLAGS) {

        if (!MemDbSetFlags (g_Key1, dataValue, (UINT) -1)) {
            DEBUGMSG ((DBG_ERROR, "Could not set flag of item!"));
            return FALSE;
        }
    }

    pKeyTreeDisplayItemData (hItem);

    return TRUE;
}


BOOL
KeyTreeClearData (
    HTREEITEM hItem
    )
{
    if (!hItem || !KeyTreeGetNameOfItem (hItem, g_Key1)) {
        return FALSE;
    }

    if (MemDbTestKey (g_Key1)) {
        MemDbDeleteKey (g_Key1);
        if (!MemDbAddKey (g_Key1)) {
            return FALSE;
        }
    }

    pKeyTreeDisplayItemData (hItem);
    return TRUE;
}


VOID
KeyTreeSetFilterPattern (
    PSTR Pattern
    )
{
    KeyAddSetFilterPattern (Pattern);
}


BOOL
KeyTreeCreateLinkage (
    HWND hdlg,
    HTREEITEM hItem,
    BOOL SingleLinkage,
    BYTE Instance
    )
{
    BOOL b = TRUE;

    if (hItem) {
        KeyTreeGetNameOfItem (hItem, g_Key1);
    } else {
        g_Key1[0] = '\0';
    }
    g_Key2[0] = '\0';

    if (!LinkageDialog (hdlg, g_Key1, g_Key2)) {
        return FALSE;
    }

    if (SingleLinkage) {
        if (!MemDbAddSingleLinkage (g_Key1, g_Key2, Instance)) {
            DEBUGMSG ((DBG_ERROR, "Could not create linkage between %s and %s!", g_Key1, g_Key2));
            return FALSE;
        }
    } else {
        if (!MemDbAddDoubleLinkage (g_Key1, g_Key2, Instance)) {
            DEBUGMSG ((DBG_ERROR, "Could not create double linkage between %s and %s!", g_Key1, g_Key2));
            return FALSE;
        }
    }

    pKeyTreeDisplayItemData (hItem);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\filler\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implements a small utility that fills the disk for purposes of free space
    testing.

Author:

    Jim Schmidt (jimschm) 18-Aug-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    UtInitialize (NULL);

    return TRUE;
}


VOID
Terminate (
    VOID
    )
{
    UtTerminate ();
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        "  filler <free_space> [/D:<drive>] [/C:<cmdline> [/M]]\n"
        "  filler /Q [/D:<drive>]\n"

        "\nDescription:\n\n"

        "  filler creates a file (bigfile.dat) on the current or specified\n"
        "  drive, leaving only the specified amount of free space on the drive.\n"

        "\nArguments:\n\n"

        "  free_space   Specifies the amount of free space to leave on\n"
        "               disk.\n"
        "  /D           Specifies the drive letter to fill (i.e. /D:C)\n"
        "  /Q           Queries the free space on the disk\n"
        "  /C           Executes command line specified in <cmdline>\n"
        "  /M           Issue message box if command line alters disk space\n"

        );

    exit (1);
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    TCHAR drive;
    TCHAR curDir[MAX_PATH];
    LONGLONG freeSpace = -1;
    PCTSTR p;
    BOOL qSpecified = FALSE;
    PCTSTR cmdLine = NULL;
    BOOL mSpecified = FALSE;

    GetCurrentDirectory (ARRAYSIZE(curDir), curDir);
    drive = 0;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('d'):
                if (drive) {
                    HelpAndExit();
                }

                if (argv[i][2] == TEXT(':')) {
                    if (!argv[i][3] || argv[i][4]) {
                        HelpAndExit();
                    }

                    drive = argv[i][3];

                } else if (i + 1 < argc) {
                    i++;
                    if (!argv[i][0] || argv[i][1]) {
                        HelpAndExit();
                    }

                    drive = argv[i][0];
                } else {
                    HelpAndExit();
                }

                if (!_istalpha (drive)) {
                    HelpAndExit();
                }

                break;

            case TEXT('c'):
                if (cmdLine) {
                    HelpAndExit();
                }

                if (argv[i][2] == TEXT(':')) {
                    if (!argv[i][3]) {
                        HelpAndExit();
                    }

                    cmdLine = &argv[i][3];
                } else if (i + 1 < argc) {
                    i++;
                    if (!argv[i][0]) {
                        HelpAndExit();
                    }

                    cmdLine = argv[i];
                } else {
                    HelpAndExit();
                }

                break;

            case TEXT('m'):
                if (mSpecified) {
                    HelpAndExit();
                }

                mSpecified = TRUE;
                break;

            case TEXT('q'):
                if (qSpecified || freeSpace != -1) {
                    HelpAndExit();
                }

                qSpecified = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (qSpecified || freeSpace != -1) {
                HelpAndExit();
            }

            freeSpace = StringToInt64 (argv[i], &p);

            if (*p != 0 || freeSpace < 0) {
                HelpAndExit();
            }
        }
    }

    if (cmdLine && qSpecified) {
        HelpAndExit();
    }

    if (mSpecified && !cmdLine) {
        HelpAndExit();
    }

    if (!drive) {
        drive = curDir[0];
    }

    if (!qSpecified) {

        if (freeSpace == -1) {
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    printf ("---------------------------------------------------------\n");

    //
    // Do work here
    //
    {
        HANDLE file;
        TCHAR path[] = TEXT("?:\\bigfile.dat");
        TCHAR rootDir[] = TEXT("?:\\");
        ULARGE_INTEGER freeBytes;
        ULARGE_INTEGER totalBytes;
        ULARGE_INTEGER totalFreeBytes;
        ULARGE_INTEGER freeBytesAfter;
        ULARGE_INTEGER totalBytesAfter;
        ULARGE_INTEGER totalFreeBytesAfter;
        BOOL b;
        HANDLE h;

        path[0] = drive;
        rootDir[0] = drive;

        if (qSpecified) {
            b = GetDiskFreeSpaceEx (rootDir, &freeBytes, &totalBytes, &totalFreeBytes);

            if (b) {
                _ftprintf (stderr, TEXT("Drive %c has %I64u bytes free\n"), drive, freeBytes.QuadPart);
            } else {
                _ftprintf (stderr, TEXT("Can't get free space from drive %c\n"), drive);
            }
        } else {

            _tprintf (TEXT("FILLER: Deleting %s..."), path);

            SetFileAttributes (path, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (path);

            printf ("\n");

            b = GetDiskFreeSpaceEx (rootDir, &freeBytes, &totalBytes, &totalFreeBytes);

            if (b) {

                if (freeBytes.QuadPart <= (ULONGLONG) freeSpace) {
                    _ftprintf (stderr, TEXT("ERROR: Drive %c only has %I64u bytes available\n"), drive, freeBytes.QuadPart);
                    b = FALSE;
                }
            }

            if (b) {

                file = BfCreateFile (path);
                if (!file) {
                    _ftprintf (stderr, TEXT("ERROR: Can't create file %s\n"), path);
                } else {
                    printf ("FILLER: Allocating disk space...");

                    GetDiskFreeSpaceEx (rootDir, &freeBytes, &totalBytes, &totalFreeBytes);

                    freeBytes.QuadPart -= (ULONGLONG) freeSpace;
                    if (!BfSetFilePointer (file, freeBytes.QuadPart)) {
                        DEBUGMSG ((DBG_ERROR, "BfSetFilePointer failed"));
                    }

                    if (!SetEndOfFile (file)) {
                        DEBUGMSG ((DBG_ERROR, "SetEndOfFile failed"));
                    }
                    CloseHandle (file);

                    printf ("done\n");

                    b = GetDiskFreeSpaceEx (rootDir, &freeBytes, &totalBytes, &totalFreeBytes);

                    if (b) {
                        _ftprintf (stderr, TEXT("FILLER: Drive %c now has %I64u bytes available\n"), drive, freeBytes.QuadPart);
                    } else {
                        fprintf (stderr, "ERROR: Can't get free space again.\n");
                    }

                    if (cmdLine) {

                        h = StartProcess (cmdLine);

                        if (!h) {
                            _ftprintf (stderr, TEXT("\nERROR: Can't start process %s\n"), cmdLine);
                        } else {

                            _tprintf (TEXT("FILLER: Running\n\n  %s\n\n"), cmdLine);

                            WaitForSingleObject (h, INFINITE);
                            CloseHandle (h);

                            printf ("\n\nFILLER: Process done.\n");

                            b = GetDiskFreeSpaceEx (rootDir, &freeBytesAfter, &totalBytesAfter, &totalFreeBytesAfter);

                            if (b) {
                                _ftprintf (stderr, TEXT("FILLER: Drive %c has %I64u bytes available after cmdline\n"), drive, freeBytesAfter.QuadPart);

                                if (freeBytesAfter.QuadPart != freeBytes.QuadPart) {
                                    if (!mSpecified) {
                                        fprintf (stderr, "\nWARNING: Command line altered disk space\n\n");
                                    } else {
                                        TCHAR msg[1024];

                                        _stprintf (msg, "Command line altered disk space:\n\n%s\n\nSize: %I64i", cmdLine, freeSpace);
                                        MessageBox (NULL, msg, TEXT("filler.exe"), MB_OK);
                                    }
                                }
                            } else {
                                fprintf (stderr, "ERROR: Can't get free space again.\n");
                            }
                        }
                    }
                }
            } else {
                _ftprintf (stderr, TEXT("ERROR: Can't get free space for drive %c\n"), drive);
            }
        }
    }

    printf ("---------------------------------------------------------\n\n");

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\ssstub\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\homenet\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    homenet.exe is a proof-of-concept tool for the protocol-independent
    home networking transport.

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include <initguid.h>
#include <winsock2.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include <nb30.h>

#define TCPIP_BROADCAST_PORT        2048
#define IPX_BROADCAST_PORT          1150
#define NETBIOS_BROADCAST_PORT      0x50

#define TCPIP_CONNECT_PORT          2049
#define IPX_CONNECT_PORT            1151
#define NETBIOS_CONNECT_PORT        0x51

#define MAX_SOCKADDR                (max(sizeof(SOCKADDR_IN),max(sizeof(SOCKADDR_IPX),sizeof(SOCKADDR_NB))))
#define DBG_HOMENET                 "HomeNet"

VOID
pDoSource (
    VOID
    );

VOID
pDoDestination (
    VOID
    );

// 36E4BE8D-0766-46E9-8679-8546529A90EE
DEFINE_GUID(g_MyGuid, 0x36E4BE8D, 0x0766, 0x46e9, 0x86, 0x79, 0X85, 0x46, 0x52, 0X9A, 0x90, 0XEE);

HANDLE g_StopHandle;
HANDLE g_ConnectionDone;
TCHAR g_StoragePath[MAX_PATH];

#pragma pack(push,1)

typedef struct {
    WORD PacketNumber;
    WORD DataLength;
} DATAGRAM_PACKET, *PDATAGRAM_PACKET;

#pragma pack(pop)

typedef struct TAG_DATAGRAM_POOL_ITEM {
    struct TAG_DATAGRAM_POOL_ITEM *Next, *Prev;
    DATAGRAM_PACKET Header;
    PCBYTE PacketData;
    // PacketData follows
} DATAGRAM_POOL_ITEM, *PDATAGRAM_POOL_ITEM;

typedef struct {
    PMHANDLE Pool;
    SOCKET Socket;
    PDATAGRAM_POOL_ITEM FirstItem;
    WORD SendSequenceNumber;
    WORD RecvSequenceNumber;
} DATAGRAM_POOL, *PDATAGRAM_POOL;


BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // Describe command line syntax(es), indent 2 spaces
        //

        "  homenet /S|/D\n"

        "\nDescription:\n\n"

        //
        // Describe tool, indent 2 spaces
        //

        "  HomeNet.exe is a proof-of-concept tool for the home networking transport.\n"

        "\nArguments:\n\n"

        //
        // Describe args, indent 2 spaces, say optional if necessary
        //

        "  /S  Executes the tool in source mode\n"
        "  /D  Executes the tool in destination mode\n"

        );

    exit (1);
}


BOOL
pCtrlCRoutine (
    IN      DWORD CtrlType
    )
{
    SetEvent (g_StopHandle);
    WaitForSingleObject (g_ConnectionDone, INFINITE);

    return FALSE;
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    BOOL destination = FALSE;
    BOOL source = FALSE;
    WSADATA startupData;
    INT result;

    g_StopHandle = CreateEvent (NULL, TRUE, FALSE, NULL);
    g_ConnectionDone = CreateEvent (NULL, TRUE, FALSE, NULL);
    SetConsoleCtrlHandler (pCtrlCRoutine, TRUE);

    //
    // Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('s'):
                if (source || destination) {
                    HelpAndExit();
                }

                source = TRUE;
                break;

            case TEXT('d'):
                if (source || destination) {
                    HelpAndExit();
                }

                destination = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // Start sockets
    //

    result = WSAStartup (2, &startupData);

    if (result) {
        printf ("Can't start sockets.  Code=%u\n", result);
        exit (1);
    }

    //
    // Do work
    //

    if (source) {
        pDoSource();
    } else {
        pDoDestination();
    }

    //
    // Shut down sockets
    //

    WSACleanup();

    //
    // End of processing
    //

    Terminate();

    return 0;
}


typedef struct {
    SOCKET Socket;
    BYTE BroadcastAddress[MAX_SOCKADDR];
    INT AddressLen;
    INT Family;
    INT Protocol;
} BROADCASTSOCKET, *PBROADCASTSOCKET;

typedef struct {
    SOCKET Socket;
    INT Family;
    INT Protocol;
    BOOL Datagram;
} LISTENSOCKET, *PLISTENSOCKET;

typedef struct {
    SOCKET Socket;
    BYTE LocalAddress[MAX_SOCKADDR];
    INT LocalAddressLen;
    BYTE RemoteAddress[MAX_SOCKADDR];
    INT RemoteAddressLen;
    INT Family;
    INT Protocol;
    BOOL Datagram;
    DATAGRAM_POOL DatagramPool;
} CONNECTIONSOCKET, *PCONNECTIONSOCKET;

typedef struct {
    BYTE LocalAddress[MAX_SOCKADDR];
    INT LocalAddressLen;
    BYTE RemoteAddress[MAX_SOCKADDR];
    INT RemoteAddressLen;
    INT Family;
    INT Protocol;
    BOOL Datagram;
    TCHAR DestinationName[MAX_COMPUTER_NAME];
} CONNECTADDRESS, *PCONNECTADDRESS;

typedef struct {
    PBROADCASTSOCKET BroadcastSockets;
    INT BroadcastCount;
    PLISTENSOCKET ListenSockets;
    INT ListenCount;
    CONNECTIONSOCKET ConnectionSocket;
    PGROWBUFFER AddressArray;
} BROADCASTARGS, *PBROADCASTARGS;

typedef struct {
    UINT StructSize;
    UINT FileCount;
    LONGLONG TotalSize;
} TRANSFERMETRICS, *PTRANSFERMETRICS;




PBROADCASTSOCKET
pOpenOneBroadcastSocket (
    IN OUT  PGROWBUFFER BroadcastSockets,
    IN      SOCKADDR *SockAddr,
    IN      INT SockAddrLen,
    IN      INT Family,
    IN      INT Protocol,
    IN      PCTSTR DebugText
    )
{
    PBROADCASTSOCKET broadcastSocket;
    BOOL b;

    broadcastSocket = (PBROADCASTSOCKET) GbGrow (BroadcastSockets, sizeof (BROADCASTSOCKET));
    broadcastSocket->Socket = socket (Family, SOCK_DGRAM, Protocol);

    if (broadcastSocket->Socket != INVALID_SOCKET) {

        b = TRUE;
        setsockopt (broadcastSocket->Socket, SOL_SOCKET, SO_BROADCAST, (PBYTE) &b, sizeof (b));
        setsockopt (broadcastSocket->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        if (bind (broadcastSocket->Socket, SockAddr, SockAddrLen)) {
            DEBUGMSG ((DBG_ERROR, "Can't bind to %s socket", DebugText));
            closesocket (broadcastSocket->Socket);
            broadcastSocket->Socket = INVALID_SOCKET;
        }
    }

    if (broadcastSocket->Socket == INVALID_SOCKET) {
        BroadcastSockets->End -= sizeof (BROADCASTSOCKET);
        broadcastSocket = NULL;
    } else {
        DEBUGMSG ((
            DBG_HOMENET,
            "%s is available for broadcast on socket %u",
            DebugText,
            (BroadcastSockets->End / sizeof (BROADCASTSOCKET)) - 1
            ));

        broadcastSocket->AddressLen = SockAddrLen;
        MYASSERT (SockAddrLen <= MAX_SOCKADDR);
        CopyMemory (broadcastSocket->BroadcastAddress, (PBYTE) SockAddr, SockAddrLen);
        broadcastSocket->Family = Family;
        broadcastSocket->Protocol = Protocol;
    }

    return broadcastSocket;
}


INT
pOpenBroadcastSockets (
    OUT     PGROWBUFFER BroadcastSockets
    )
{
    SOCKADDR_IPX ipxAddr;
    SOCKADDR_IN tcpipAddr;
    SOCKADDR_NB netbiosAddr;
    NCB ncbEnum;
    LANA_ENUM leBuf;
    INT rc;
    INT i;
    PBROADCASTSOCKET broadcastSocket;
    BOOL b;
    TCHAR netbiosDebugText[32];

    MYASSERT (!BroadcastSockets->Buf && !BroadcastSockets->End);

    //
    // Open sockets for broadcasts
    //

    // IPX
    ZeroMemory (&ipxAddr, sizeof (ipxAddr));
    ipxAddr.sa_family = AF_IPX;
    memset (ipxAddr.sa_nodenum, 0xFF, 6);
    ipxAddr.sa_socket = IPX_BROADCAST_PORT;

    pOpenOneBroadcastSocket (
        BroadcastSockets,
        (SOCKADDR *) &ipxAddr,
        sizeof (ipxAddr),
        AF_IPX,
        NSPROTO_IPX,
        TEXT("IPX")
        );

    // TCP/IP
    ZeroMemory (&tcpipAddr, sizeof (tcpipAddr));
    tcpipAddr.sin_family = AF_INET;
    tcpipAddr.sin_addr.s_addr = htonl (INADDR_ANY);
    tcpipAddr.sin_port = TCPIP_BROADCAST_PORT;

    broadcastSocket = pOpenOneBroadcastSocket (
                            BroadcastSockets,
                            (SOCKADDR *) &tcpipAddr,
                            sizeof (tcpipAddr),
                            AF_INET,
                            IPPROTO_UDP,
                            TEXT("UDP")
                            );

    if (broadcastSocket) {
        tcpipAddr.sin_addr.s_addr = htonl (INADDR_BROADCAST);
        CopyMemory (broadcastSocket->BroadcastAddress, &tcpipAddr, sizeof (tcpipAddr));
    }

    // NetBIOS
    ZeroMemory (&ncbEnum, sizeof (NCB));
    ncbEnum.ncb_command = NCBENUM;
    ncbEnum.ncb_buffer = (PBYTE) &leBuf;
    ncbEnum.ncb_length = sizeof (LANA_ENUM);

    rc = Netbios (&ncbEnum);

    if (rc == NRC_GOODRET) {

        for (i = 0 ; i < leBuf.length  ; i++) {
            SET_NETBIOS_SOCKADDR (&netbiosAddr, NETBIOS_GROUP_NAME, "usmt", NETBIOS_BROADCAST_PORT);

            wsprintf (netbiosDebugText, TEXT("NETBIOS cli lana %u"), leBuf.lana[i]);
            pOpenOneBroadcastSocket (
                BroadcastSockets,
                (SOCKADDR *) &netbiosAddr,
                sizeof (netbiosAddr),
                AF_NETBIOS,
                -leBuf.lana[i],
                netbiosDebugText
                );
        }

    }

    return BroadcastSockets->End / sizeof (BROADCASTSOCKET);
}


PLISTENSOCKET
pOpenOneListenSocket (
    IN OUT  PGROWBUFFER ListenSockets,
    IN      SOCKADDR *SockAddr,
    IN      INT SockAddrLen,
    IN      INT Family,
    IN      BOOL Multicast,
    IN      INT Protocol,
    IN      PCTSTR DebugText
    )
{
    PLISTENSOCKET listenSocket;
    BOOL b;

    listenSocket = (PLISTENSOCKET) GbGrow (ListenSockets, sizeof (LISTENSOCKET));
    listenSocket->Socket = socket (Family, Multicast ? SOCK_DGRAM : SOCK_STREAM, Protocol);
    listenSocket->Datagram = Multicast;
    listenSocket->Family = Family;
    listenSocket->Protocol = Protocol;

    if (listenSocket->Socket != INVALID_SOCKET) {

        b = TRUE;
        setsockopt (listenSocket->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        if (Multicast) {
            setsockopt (listenSocket->Socket, SOL_SOCKET, SO_BROADCAST, (PBYTE) &b, sizeof (b));
        }

        if (bind (listenSocket->Socket, SockAddr, SockAddrLen) ||
            (!Multicast && listen (listenSocket->Socket, 1))
            ) {
            DEBUGMSG ((DBG_ERROR, "Can't bind/listen to %s socket", DebugText));
            closesocket (listenSocket->Socket);
            listenSocket->Socket = INVALID_SOCKET;
        }
    }

    if (listenSocket->Socket == INVALID_SOCKET) {
        ListenSockets->End -= sizeof (LISTENSOCKET);
        listenSocket = NULL;
    } else {
        DEBUGMSG ((
            DBG_HOMENET,
            "%s is availble for connection on socket %u",
            DebugText,
            (ListenSockets->End / sizeof (LISTENSOCKET)) - 1
            ));
    }

    return listenSocket;
}


INT
pOpenListenSockets (
    OUT     PGROWBUFFER ListenSockets
    )
{
    SOCKADDR_IPX ipxAddr;
    SOCKADDR_IN tcpipAddr;
    SOCKADDR_NB netbiosAddr;
    NCB ncbEnum;
    LANA_ENUM leBuf;
    INT rc;
    INT i;
    TCHAR netbiosDebugText[32];

    MYASSERT (!ListenSockets->Buf && !ListenSockets->End);

    //
    // Open sockets to accept inbound connections
    //

    // SPX
    ZeroMemory (&ipxAddr, sizeof (ipxAddr));
    ipxAddr.sa_family = AF_IPX;
    ipxAddr.sa_socket = IPX_CONNECT_PORT;

    pOpenOneListenSocket (
        ListenSockets,
        (SOCKADDR *) &ipxAddr,
        sizeof (ipxAddr),
        AF_IPX,
        FALSE,
        NSPROTO_SPX,
        TEXT("SPX")
        );

    // TCP/IP
    ZeroMemory (&tcpipAddr, sizeof (tcpipAddr));
    tcpipAddr.sin_family = AF_INET;
    tcpipAddr.sin_port = TCPIP_CONNECT_PORT;

    pOpenOneListenSocket (
        ListenSockets,
        (SOCKADDR *) &tcpipAddr,
        sizeof (tcpipAddr),
        AF_INET,
        FALSE,
        IPPROTO_TCP,
        TEXT("TCP")
        );

    // NetBIOS
    ZeroMemory (&ncbEnum, sizeof (NCB));
    ncbEnum.ncb_command = NCBENUM;
    ncbEnum.ncb_buffer = (PBYTE) &leBuf;
    ncbEnum.ncb_length = sizeof (LANA_ENUM);

    rc = Netbios (&ncbEnum);

    if (rc == NRC_GOODRET) {

        for (i = 0 ; i < leBuf.length  ; i++) {
            SET_NETBIOS_SOCKADDR (&netbiosAddr, NETBIOS_GROUP_NAME, "usmt", NETBIOS_CONNECT_PORT);
            wsprintf (netbiosDebugText, TEXT("NETBIOS srv lana %u"), leBuf.lana[i]);

            pOpenOneListenSocket (
                ListenSockets,
                (SOCKADDR *) &netbiosAddr,
                sizeof (netbiosAddr),
                AF_NETBIOS,
                TRUE,
                -leBuf.lana[i],
                netbiosDebugText
                );
        }
    }

    return ListenSockets->End / sizeof (LISTENSOCKET);
}

PCTSTR
pGetNameFromMessage (
    IN      PCTSTR Message
    )
{
    PCTSTR p;
    PCTSTR name = NULL;
    INT len;
    CHARTYPE ch;

    if (_tcsprefixcmp (Message, TEXT("usmt-v2,"))) {

        p = Message + 8;
        len = 0;

        while (*p) {

            ch = _tcsnextc (p);
            p = _tcsinc (p);

            if (ch == TEXT(',')) {
                break;
            }

            if (ch < TEXT('0') || ch > TEXT('9')) {
                break;
            }

            len = len * 10 + (ch - TEXT('0'));
        }

        if (ch == TEXT(',') && len < MAX_COMPUTER_NAME) {

            name = p;

            while (*p && len) {
                if (*p < 32) {
                    break;
                }

                p++;
                len--;
            }

            if (len || *p) {
                name = NULL;
            }
        }
    }

    return name;
}


VOID
pTranslateBroadcastAddrToConnectAddr (
    IN      INT Family,
    IN OUT  PINT Protocol,
    IN OUT  PBOOL Datagram,
    IN OUT  SOCKADDR *SockAddr
    )
{
    SOCKADDR_IPX *ipxAddr;
    SOCKADDR_IN *tcpipAddr;
    SOCKADDR_NB *netbiosAddr;

    switch (Family) {

    case AF_INET:
        *Protocol = IPPROTO_TCP;
        tcpipAddr = (SOCKADDR_IN *) SockAddr;
        tcpipAddr->sin_port = TCPIP_CONNECT_PORT;
        break;

    case AF_IPX:
        *Protocol = NSPROTO_SPX;
        ipxAddr = (SOCKADDR_IPX *) SockAddr;
        ipxAddr->sa_socket = IPX_CONNECT_PORT;
        break;

    case AF_NETBIOS:
        netbiosAddr = (SOCKADDR_NB *) SockAddr;
        netbiosAddr->snb_name[NETBIOS_NAME_LENGTH - 1] = NETBIOS_CONNECT_PORT;
        *Datagram = TRUE;
        break;
    }
}


VOID
pResetPort (
    IN      INT Family,
    IN OUT  SOCKADDR *SockAddr
    )
{
    SOCKADDR_IN *tcpipAddr;

    switch (Family) {

    case AF_INET:
        tcpipAddr = (SOCKADDR_IN *) SockAddr;
        tcpipAddr->sin_port = 0;
        break;
    }
}


INT
pSourceBroadcast (
    PBROADCASTARGS Args
    )
{
    INT i;
    INT bytesIn;
    DWORD rc;
    TCHAR message[256];
    UINT size;
    FD_SET set;
    TIMEVAL zero = {0,0};
    INT waitCycle = -1;
    BOOL result = FALSE;
    PCTSTR name;
    PCONNECTADDRESS address;
    PCONNECTADDRESS end;
    PBROADCASTSOCKET broadcastSocket;
    BYTE remoteAddr[MAX_SOCKADDR];
    INT remoteAddrLen;

    for (;;) {
        //
        // Check cancel
        //

        rc = WaitForSingleObject (g_StopHandle, 250);

        if (rc == WAIT_OBJECT_0) {
            result = FALSE;
            break;
        }

        //
        // Check time to live
        //

        if (waitCycle > -1) {
            waitCycle--;

            if (!waitCycle) {
                break;
            }
        }

        //
        // Check for a message
        //

        FD_ZERO (&set);
        for (i = 0 ; i < Args->BroadcastCount ; i++) {
            FD_SET (Args->BroadcastSockets[i].Socket, &set);
        }

        i = select (0, &set, NULL, NULL, &zero);

        if (i > 0) {

            // once we receive something, wait 15 additional seconds for other inbound datagrams
            if (waitCycle == -1) {
                waitCycle = 60;
            }

            for (i = 0 ; i < Args->BroadcastCount ; i++) {

                broadcastSocket = &Args->BroadcastSockets[i];

                if (FD_ISSET (broadcastSocket->Socket, &set)) {

                    remoteAddrLen = MAX_SOCKADDR;

                    bytesIn = recvfrom (
                                    broadcastSocket->Socket,
                                    message,
                                    254,
                                    0,
                                    (SOCKADDR *) remoteAddr,
                                    &remoteAddrLen
                                    );

                    if (bytesIn > (10 * sizeof (TCHAR))) {
                        message[bytesIn] = 0;
                        message[bytesIn + 1] = 0;

                        //
                        // Parse the inbound text.  It must be in the format of
                        //
                        //      usmt-v2,<tchars>,<name>
                        //

                        name = pGetNameFromMessage (message);

                        if (name) {

                            result = TRUE;

                            //
                            // Scan the address list for the name
                            //

                            address = (PCONNECTADDRESS) Args->AddressArray->Buf;
                            end = (PCONNECTADDRESS) (Args->AddressArray->Buf + Args->AddressArray->End);

                            while (address < end) {
                                if (StringIMatch (address->DestinationName, name)) {
                                    if (address->Family == broadcastSocket->Family) {
                                        break;
                                    }
                                }

                                address++;
                            }

                            if (address >= end) {
                                //
                                // New computer name; add to the address list
                                //

                                address = (PCONNECTADDRESS) GbGrow (Args->AddressArray, sizeof (CONNECTADDRESS));

                                address->RemoteAddressLen = remoteAddrLen;
                                CopyMemory (address->RemoteAddress, remoteAddr, remoteAddrLen);

                                address->LocalAddressLen = MAX_SOCKADDR;
                                if (getsockname (
                                        broadcastSocket->Socket,
                                        (SOCKADDR *) address->LocalAddress,
                                        &address->LocalAddressLen
                                        )) {
                                    address->LocalAddressLen = broadcastSocket->AddressLen;
                                    ZeroMemory (address->LocalAddress, broadcastSocket->AddressLen);
                                    DEBUGMSG ((DBG_HOMENET, "Failed to get local socket name; using nul name instead"));
                                }

                                address->Family = broadcastSocket->Family;
                                address->Protocol = broadcastSocket->Protocol;
                                address->Datagram = FALSE;

                                pTranslateBroadcastAddrToConnectAddr (
                                    address->Family,
                                    &address->Protocol,
                                    &address->Datagram,
                                    (SOCKADDR *) &address->RemoteAddress
                                    );

                                StringCopy (address->DestinationName, name);

                                DEBUGMSG ((DBG_HOMENET, "Destination found: %s (protocol %i)", name, address->Family));
                            }
                        }
                        ELSE_DEBUGMSG ((DBG_HOMENET, "garbage found: %s", message));
                    }
                }
            }
        }
    }

    return result ? Args->AddressArray->End / sizeof (CONNECTADDRESS) : 0;
}


BOOL
pDestinationBroadcast (
    PBROADCASTARGS Args
    )
{
    INT i;
    DWORD rc;
    INT socketNum = 0;
    TCHAR message[256];
    TCHAR name[128];
    UINT size;
    FD_SET set;
    TIMEVAL zero = {0,0};
    PBROADCASTSOCKET broadcastSocket;
    BOOL result = FALSE;
    BYTE sockAddr[MAX_SOCKADDR];
    INT sockAddrLen;

    size = MAX_COMPUTER_NAME;
    GetComputerName (name, &size);

    size = wsprintf (message, TEXT("USMT-v2,%u,%s"), TcharCount (name), name);
    size = (size + 1) * sizeof (TCHAR);

    for (;;) {
        //
        // Check cancel
        //

        rc = WaitForSingleObject (g_StopHandle, 250);

        if (rc == WAIT_OBJECT_0) {
            break;
        }

        //
        // Send out the message
        //

        broadcastSocket = &Args->BroadcastSockets[socketNum];

        i = sendto (
                broadcastSocket->Socket,
                message,
                size,
                0,
                (SOCKADDR *) broadcastSocket->BroadcastAddress,
                broadcastSocket->AddressLen
                );

        if (i == SOCKET_ERROR) {
            DEBUGMSG ((DBG_VERBOSE, "Error sending on socket %u: %u", socketNum, WSAGetLastError()));
        } else {
            DEBUGMSG ((DBG_HOMENET, "Sent data on socket %u", socketNum));
        }

        socketNum++;
        if (socketNum >= Args->BroadcastCount) {
            socketNum = 0;
        }

        //
        // Check for an inbound connection
        //

        FD_ZERO (&set);
        for (i = 0 ; i < Args->ListenCount ; i++) {
            FD_SET (Args->ListenSockets[i].Socket, &set);
        }

        i = select (0, &set, NULL, NULL, &zero);

        if (i > 0) {
            DEBUGMSG ((DBG_HOMENET, "Connection request count = %i", i));
            for (i = 0 ; i < Args->ListenCount ; i++) {
                if (FD_ISSET (Args->ListenSockets[i].Socket, &set)) {

                    Args->ConnectionSocket.RemoteAddressLen = MAX_SOCKADDR;
                    Args->ConnectionSocket.Socket = accept (
                                                        Args->ListenSockets[i].Socket,
                                                        (SOCKADDR *) Args->ConnectionSocket.RemoteAddress,
                                                        &Args->ConnectionSocket.RemoteAddressLen
                                                        );


                    if (Args->ConnectionSocket.Socket != INVALID_SOCKET) {
                        Args->ConnectionSocket.Family = Args->ListenSockets[i].Family;
                        Args->ConnectionSocket.Protocol = Args->ListenSockets[i].Protocol;
                        Args->ConnectionSocket.Datagram = Args->ListenSockets[i].Datagram;

                        ZeroMemory (&Args->ConnectionSocket.DatagramPool, sizeof (DATAGRAM_POOL));
                        if (Args->ConnectionSocket.Datagram) {
                            Args->ConnectionSocket.DatagramPool.Pool = PmCreatePool();
                        }

                        Args->ConnectionSocket.LocalAddressLen = MAX_SOCKADDR;
                        if (getsockname (
                                Args->ConnectionSocket.Socket,
                                (SOCKADDR *) Args->ConnectionSocket.LocalAddress,
                                &Args->ConnectionSocket.LocalAddressLen
                                )) {
                            Args->ConnectionSocket.LocalAddressLen = broadcastSocket->AddressLen;
                            ZeroMemory (Args->ConnectionSocket.LocalAddress, broadcastSocket->AddressLen);
                            DEBUGMSG ((DBG_HOMENET, "Failed to get local socket name; using nul name instead"));
                        }

                        result = TRUE;
                        break;
                    } else {
                        DEBUGMSG ((DBG_ERROR, "select indicated connection, but accept failed"));
                    }
                }
            }

            if (result) {
                break;
            }
        }
    }

    return result;
}


INT
pNameResolver (
    OUT     PGROWBUFFER AddressBuffer,
    IN      BOOL DestinationMode,
    OUT     PCONNECTIONSOCKET ConnectionSocket
    )
{
    INT size;
    BROADCASTARGS args;
    INT i;
    INT result = 0;
    BOOL b;
    BOOL connected = FALSE;
    GROWBUFFER broadcastSockets = INIT_GROWBUFFER;
    GROWBUFFER listenSockets = INIT_GROWBUFFER;
    INT broadcastSocketCount;
    INT listenSocketCount = 0;
    PLISTENSOCKET connection;

    __try {

        //
        // In source mode, we collect datagrams sent by destinations on the network.  After
        // the first datagram is received, collection continues for 15 seconds.  At
        // that point, we have a list of socket addresses, protocol, and destination names.
        //
        // In destination mode, we send out periodic broadcasts, and we wait until a source
        // connects or the cancel event is signaled.
        //

        broadcastSocketCount = pOpenBroadcastSockets (&broadcastSockets);

        if (!broadcastSocketCount) {
            __leave;
        }

        if (DestinationMode) {
            listenSocketCount = pOpenListenSockets (&listenSockets);

            if (!listenSocketCount) {
                DEBUGMSG ((DBG_ERROR, "Able to set up broadcast sockets but not connection sockets"));
                __leave;
            }
        }

        // call mode-specific routine
        ZeroMemory (&args, sizeof (args));

        args.AddressArray = AddressBuffer;
        args.BroadcastSockets = (PBROADCASTSOCKET) broadcastSockets.Buf;
        args.BroadcastCount = broadcastSocketCount;
        args.ListenSockets = (PLISTENSOCKET) listenSockets.Buf;
        args.ListenCount = listenSocketCount;

        b = DestinationMode ? pDestinationBroadcast (&args) : pSourceBroadcast (&args);

        //
        // Clean up all sockets
        //

        for (i = 0 ; i < args.BroadcastCount ; i++) {
            closesocket (args.BroadcastSockets[i].Socket);
        }

        if (DestinationMode) {
            for (i = 0 ; i < args.ListenCount ; i++) {
                closesocket (args.ListenSockets[i].Socket);
            }
        }

        if (b) {
            if (DestinationMode) {
                CopyMemory (ConnectionSocket, &args.ConnectionSocket, sizeof (CONNECTIONSOCKET));
                result = 1;
            } else {
                result = AddressBuffer->End / sizeof (CONNECTADDRESS);
            }
        }
    }
    __finally {
        GbFree (&broadcastSockets);
        GbFree (&listenSockets);
        SetEvent (g_ConnectionDone);
    }

    return result;
}


BOOL
pSendExactData (
    IN      SOCKET Socket,
    IN      PBYTE Data,
    IN      UINT DataLen
    )
{
    INT result;

    result = send (Socket, Data, DataLen, 0);

    return result == (INT) DataLen;
}


BOOL
pSendDatagramData (
    IN      PDATAGRAM_POOL DatagramPool,
    IN      PCBYTE Data,
    IN      UINT DataLen
    )
{
    PDATAGRAM_PACKET header;
    BYTE buffer[512];
    PBYTE dataPtr;
    UINT bytesSent = 0;
    UINT bytesToSend;
    INT result;

    header = (PDATAGRAM_PACKET) buffer;
    dataPtr = (PBYTE) (&header[1]);

    do {

        bytesToSend = DataLen - bytesSent;
        bytesToSend = min (bytesToSend, 256);

        header->PacketNumber = DatagramPool->SendSequenceNumber;
        DatagramPool->SendSequenceNumber++;
        header->DataLength = (WORD) bytesToSend;

        CopyMemory (dataPtr, Data, bytesToSend);

        result = send (
                    DatagramPool->Socket,
                    (PBYTE) header,
                    header->DataLength + sizeof (DATAGRAM_PACKET),
                    0
                    );

        if (result == SOCKET_ERROR) {
            break;
        }

        bytesToSend = (UINT) result - sizeof (DATAGRAM_PACKET);
        Data += bytesToSend;
        bytesSent += bytesToSend;

    } while (bytesSent < DataLen);

    return bytesSent == DataLen;
}


PBYTE
pReceiveExactData (
    IN      SOCKET Socket,
    IN OUT  PGROWBUFFER Buffer,
    IN      UINT BytesToReceive
    )
{
    PBYTE recvBuf;
    PBYTE bufPos;
    UINT bytesSoFar = 0;
    INT result;
    UINT readSize;

    Buffer->End = 0;
    recvBuf = GbGrow (Buffer, BytesToReceive);
    bufPos = recvBuf;

    do {

        readSize = BytesToReceive - bytesSoFar;
        result = recv (Socket, bufPos, (INT) readSize, 0);

        if (result == SOCKET_ERROR) {
            DEBUGMSG ((DBG_ERROR, "Error reading from socket"));
            break;
        }

        bufPos += result;
        bytesSoFar += result;

    } while (bytesSoFar < BytesToReceive);

    MYASSERT (bytesSoFar <= BytesToReceive);

    return bytesSoFar == BytesToReceive ? recvBuf : NULL;
}


BOOL
pReceiveDatagramData (
    IN      PDATAGRAM_POOL DatagramPool,
    IN OUT  PGROWBUFFER Buffer,         OPTIONAL
    OUT     PBYTE AlternateBuffer,      OPTIONAL
    IN      UINT BytesToReceive
    )
{
    PDATAGRAM_POOL_ITEM itemHeader;
    PDATAGRAM_POOL_ITEM prevItem, nextItem;
    BYTE buffer[512];
    PBYTE dataPtr;
    PBYTE recvBuf;
    PBYTE bufPos;
    UINT bytesSoFar = 0;
    UINT bytesLeft;
    INT result;
    UINT readSize;
    PDATAGRAM_POOL_ITEM item;
    UINT newPacketNum;
    UINT currentPacketNum;

    if (Buffer) {
        Buffer->End = 0;
        recvBuf = GbGrow (Buffer, BytesToReceive);
    } else {
        recvBuf = AlternateBuffer;
    }

    bufPos = recvBuf;

    itemHeader = (PDATAGRAM_POOL_ITEM) buffer;
    dataPtr = (PBYTE) (&itemHeader[1]);

    for (;;) {
        //
        // Take all available data out of the pool
        //

        item = DatagramPool->FirstItem;
        bytesLeft = BytesToReceive - bytesSoFar;

        while (item) {

            if (item->Header.PacketNumber == DatagramPool->RecvSequenceNumber) {
                //
                // Two cases:
                //
                // 1. Want entire packet
                // 2. Want partial packet
                //

                if (bytesLeft >= item->Header.DataLength) {
                    // entire packet
                    CopyMemory (bufPos, item->PacketData, item->Header.DataLength);

                    MYASSERT (!item->Prev);
                    if (item->Next) {
                        item->Next->Prev = NULL;
                    }
                    DatagramPool->FirstItem = item->Next;

                    bytesSoFar += item->Header.DataLength;
                    PmReleaseMemory (DatagramPool->Pool, item);

                    DatagramPool->RecvSequenceNumber++;

                } else {
                    // partial packet
                    CopyMemory (bufPos, item->PacketData, bytesLeft);

                    item->PacketData += bytesLeft;
                    item->Header.DataLength -= (WORD) bytesLeft;

                    bytesSoFar += bytesLeft;
                }

                if (BytesToReceive == bytesSoFar) {
                    return TRUE;
                }
            }
        }

        //
        // Data is not available in the pool. Receive one packet and then try again.
        //

        // header
        if (!pReceiveExactData (
                DatagramPool->Socket,
                NULL,
                (PBYTE) &itemHeader->Header,
                sizeof (DATAGRAM_PACKET)
                )) {
            break;
        }

        if (itemHeader->Header.DataLength > 256) {
            break;
        }

        // data
        if (!pReceiveExactData (
                DatagramPool->Socket,
                NULL,
                (PBYTE) dataPtr,
                itemHeader->Header.DataLength
                )) {
            break;
        }

        //
        // Put the packet in the item linked list, sorted by packet number
        //

        item = (PDATAGRAM_POOL_ITEM) PmDuplicateMemory (
                                        DatagramPool->Pool,
                                        (PCBYTE) itemHeader,
                                        itemHeader->Header.DataLength + sizeof (DATAGRAM_PACKET)
                                        );

        item->PacketData = (PBYTE) (&item[1]);

        prevItem = NULL;
        nextItem = DatagramPool->FirstItem;

        while (nextItem) {

            //
            // Account for wrapping; assume a packet number difference no more
            // than 16383 out-of-sequence packets in the queue (about 4M of
            // data)
            //

            if (nextItem->Header.PacketNumber >= 49152 && item->Header.PacketNumber < 16384) {
                newPacketNum = (UINT) item->Header.PacketNumber + 65536;
                currentPacketNum = (UINT) nextItem->Header.PacketNumber;
            } else if (nextItem->Header.PacketNumber < 16384 && item->Header.PacketNumber >= 49152) {
                newPacketNum = (UINT) item->Header.PacketNumber;
                currentPacketNum = (UINT) nextItem->Header.PacketNumber + 65536;
            } else {
                newPacketNum = (UINT) item->Header.PacketNumber;
                currentPacketNum = (UINT) nextItem->Header.PacketNumber;
            }

            if (newPacketNum < currentPacketNum) {
                break;
            }

            prevItem = nextItem;
            nextItem = nextItem->Next;
        }

        item->Next = nextItem;
        item->Prev = prevItem;

        if (!prevItem) {
            DatagramPool->FirstItem = item;
        }
    }

    return bytesSoFar == BytesToReceive;
}


BOOL
pSendFile (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,    OPTIONAL
    IN      PCTSTR LocalFileName,           OPTIONAL
    IN      PCTSTR DestFileName             OPTIONAL
    )
{
    INT len;
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;
    HANDLE file = NULL;
    LONGLONG fileSize;

    __try {
        //
        // If no file was specified, send length of zero
        //

        if (!LocalFileName || !DestFileName) {
            len = 0;
            if (!pSendExactData (Socket, (PBYTE) &len, 4)) {
                __leave;
            }

            result = TRUE;
            __leave;
        }

        //
        // Try to open the file
        //

        fileSize = BfGetFileSize (LocalFileName);

        file = BfOpenFile (LocalFileName);
        if (!file) {
            __leave;
        }

        //
        // Send the file name and file size
        //

        len = ByteCount (DestFileName);
        if (!pSendExactData (Socket, (PBYTE) &len, 4)) {
            __leave;
        }

        if (!pSendExactData (Socket, (PBYTE) DestFileName, len)) {
            __leave;
        }

        if (!pSendExactData (Socket, (PBYTE) &fileSize, 8)) {
            __leave;
        }

        //
        // Send the data 64K at a time
        //

        GbGrow (&data, 0x10000);

        while (fileSize) {
            if (fileSize >= 0x10000) {
                if (!BfReadFile (file, data.Buf, 0x10000)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from file"));
                    __leave;
                }

                if (!pSendExactData (Socket, data.Buf, 0x10000)) {
                    __leave;
                }

                fileSize -= 0x10000;
            } else {
                if (!BfReadFile (file, data.Buf, (UINT) fileSize)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from file"));
                    __leave;
                }

                if (!pSendExactData (Socket, data.Buf, (UINT) fileSize)) {
                    __leave;
                }

                fileSize = 0;
            }
        }

        //
        // Done!
        //

        result = TRUE;

    }
    __finally {
        GbFree (&data);
        if (file) {
            CloseHandle (file);
        }
    }

    return result;
}


BOOL
pReceiveStreamFile (
    IN      SOCKET Socket
    )
{
    TCHAR fileName[MAX_PATH * 2];
    INT len;
    INT bytesIn;
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;
    PTSTR p;
    HANDLE file = NULL;
    LONGLONG fileSize;

    __try {
        //
        // Wait for file name
        //

        if (!pReceiveExactData (Socket, &data, 4)) {
            __leave;
        }

        len = *((PDWORD) data.Buf);

        if (!len) {
            result = TRUE;
            __leave;
        }

        if (len >= (MAX_PATH * sizeof (TCHAR))) {
            __leave;
        }

        if (!pReceiveExactData (Socket, &data, len)) {
            __leave;
        }

        StringCopy (fileName, g_StoragePath);

        GbGrow (&data, sizeof (TCHAR) * 2);
        p = (PTSTR) data.Buf;
        p[len] = 0;
        p[len + 1] = 0;

        StringCopy (AppendWack (fileName), p);

        //
        // Get the file size
        //

        if (!pReceiveExactData (Socket, &data, 8)) {
            __leave;
        }

        fileSize = *((PLONGLONG) data.Buf);

        DEBUGMSG ((DBG_HOMENET, "Receiving %s", fileName));

        //
        // Create the file
        //

        file = BfCreateFile (fileName);
        if (!file) {
            __leave;
        }

        //
        // Fetch the data 64K at a time
        //

        while (fileSize) {
            if (fileSize >= 0x10000) {
                if (!pReceiveExactData (Socket, &data, 0x10000)) {
                    __leave;
                }

                if (!BfWriteFile (file, data.Buf, data.End)) {
                    DEBUGMSG ((DBG_ERROR, "Can't write to file"));
                    __leave;
                }

                fileSize -= 0x10000;
            } else {
                if (!pReceiveExactData (Socket, &data, (UINT) fileSize)) {
                    __leave;
                }

                if (!BfWriteFile (file, data.Buf, data.End)) {
                    DEBUGMSG ((DBG_ERROR, "Can't write to file"));
                    __leave;
                }

                fileSize = 0;
            }
        }

        //
        // Done!
        //

        result = TRUE;

    }
    __finally {
        GbFree (&data);
        if (file) {
            CloseHandle (file);
            if (!result) {
                DeleteFile (fileName);
            }
        }
    }

    return result;
}


BOOL
pReceiveFile (
    IN      SOCKET Socket,
    IN      BOOL Datagram
    )
{
    if (Datagram) {
        return FALSE;
    }

    return pReceiveStreamFile (Socket);
}


BOOL
pSendMetrics (
    IN      SOCKET Socket,
    IN      BOOL Datagram,
    IN      PTRANSFERMETRICS Metrics
    )
{
    if (Datagram) {
        return FALSE;
    }

    Metrics->StructSize = sizeof (TRANSFERMETRICS);

    if (!pSendExactData (Socket, (PBYTE) Metrics, sizeof (TRANSFERMETRICS))) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pReceiveMetrics (
    IN      SOCKET Socket,
    OUT     PTRANSFERMETRICS Metrics
    )
{
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;

    __try {
        if (!pReceiveExactData (Socket, &data, sizeof (TRANSFERMETRICS))) {
            __leave;
        }

        CopyMemory (Metrics, data.Buf, data.End);

        if (Metrics->StructSize != sizeof (TRANSFERMETRICS)) {
            DEBUGMSG ((DBG_ERROR, "Invalid transfer metrics received"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        GbFree (&data);
    }

    return result;
}


VOID
pDoDestination (
    VOID
    )
{
    GROWBUFFER sourceAddress = INIT_GROWBUFFER;
    CONNECTIONSOCKET connection;
    TRANSFERMETRICS metrics;
    UINT u;

    ZeroMemory (&connection, sizeof (CONNECTIONSOCKET));
    connection.Socket = INVALID_SOCKET;

    __try {

        GetTempPath (MAX_PATH, g_StoragePath);

        if (!pNameResolver (&sourceAddress, TRUE, &connection)) {
            __leave;
        }

        printf ("Connected!\n");

        if (!pReceiveMetrics (connection.Socket, &metrics)) {
            __leave;
        }

        for (u = 0 ; u < metrics.FileCount ; u++) {
            if (!pReceiveFile (connection.Socket, connection.Datagram)) {
                __leave;
            }
        }
    }
    __finally {
        GbFree (&sourceAddress);

        if (connection.Socket != INVALID_SOCKET) {
            closesocket (connection.Socket);
        }
    }
}


BOOL
pConnectToDestination (
    IN      PCONNECTADDRESS Address,
    OUT     PCONNECTIONSOCKET Connection
    )
{
    BOOL result = FALSE;
    BOOL b;

    CopyMemory (Connection->LocalAddress, Address->LocalAddress, Address->LocalAddressLen);
    Connection->LocalAddressLen = Address->LocalAddressLen;

    CopyMemory (Connection->RemoteAddress, Address->RemoteAddress, Address->RemoteAddressLen);
    Connection->RemoteAddressLen = Address->RemoteAddressLen;

    Connection->Socket = socket (
                            Address->Family,
                            Address->Datagram ? SOCK_DGRAM : SOCK_STREAM,
                            Address->Protocol
                            );

    if (Connection->Socket == INVALID_SOCKET) {
        DEBUGMSG ((DBG_ERROR, "Can't create socket for connection"));
        return FALSE;
    }

    __try {

        b = TRUE;
        setsockopt (Connection->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        pResetPort (Address->Family, (SOCKADDR *) Address->LocalAddress);

        if (bind (Connection->Socket, (SOCKADDR *) Address->LocalAddress, Address->LocalAddressLen)) {
            DEBUGMSG ((DBG_ERROR, "Failed to bind to connection socket"));
            __leave;
        }

        if (connect (Connection->Socket, (SOCKADDR *) Address->RemoteAddress, Address->RemoteAddressLen)) {
            DEBUGMSG ((DBG_ERROR, "Failed to connect to socket"));
            __leave;
        }

        Connection->Family = Address->Family;
        Connection->Protocol = Address->Protocol;
        Connection->Datagram = Address->Datagram;

        result = TRUE;
    }
    __finally {
        if (!result && Connection->Socket != INVALID_SOCKET) {
            closesocket (Connection->Socket);
            Connection->Socket = INVALID_SOCKET;
        }
    }

    return result;
}


VOID
pDoSource (
    VOID
    )
{
    GROWBUFFER destinationAddresses = INIT_GROWBUFFER;
    INT destinationCount;
    PCTSTR firstName;
    PCONNECTADDRESS addressArray;
    PCONNECTADDRESS address;
    CONNECTIONSOCKET connection;
    INT i;
    TRANSFERMETRICS metrics;
    PCTSTR localFileName = TEXT("c:\\debug.inf");
    PCTSTR destFileName = TEXT("foo.inf");

    ZeroMemory (&connection, sizeof (CONNECTIONSOCKET));
    connection.Socket = INVALID_SOCKET;

    __try {

        destinationCount = pNameResolver (&destinationAddresses, FALSE, NULL);

        if (!destinationCount) {
            __leave;
        }

        addressArray = (PCONNECTADDRESS) destinationAddresses.Buf;

        //
        // Determine which address to use.  Rules are:
        //
        // 1. Must have only one destination to choose from
        // 2. Pick TCP/IP, then IPX, then NetBIOS
        //

        if (destinationCount > 1) {
            firstName = addressArray[0].DestinationName;

            for (i = 1 ; i < destinationCount ; i++) {
                if (!StringIMatch (firstName, addressArray[i].DestinationName)) {
                    break;
                }
            }

            if (i < destinationCount) {
                DEBUGMSG ((DBG_ERROR, "Multiple destinations found on the subnet; can't continue"));
                __leave;
            }
        }

        for (i = 0 ; i < destinationCount ; i++) {
            if (addressArray[i].Family == AF_INET) {
                break;
            }
        }

        if (i == destinationCount) {
            for (i = 0 ; i < destinationCount ; i++) {
                if (addressArray[i].Family == AF_IPX) {
                    break;
                }
            }

            if (i == destinationCount) {
                for (i = 0 ; i < destinationCount ; i++) {
                    if (addressArray[i].Family == AF_NETBIOS) {
                        break;
                    }
                }

                if (i == destinationCount) {
                    DEBUGMSG ((DBG_WHOOPS, "Connection is from unsupported protocol"));
                    __leave;
                }
            }
        }

        //
        // Now connect to destination (at index i)
        //

        DEBUGMSG ((
            DBG_HOMENET,
            "Attempting connection to %s (protocol %i)",
            addressArray[i].DestinationName,
            addressArray[i].Protocol
            ));

        if (!pConnectToDestination (&addressArray[i], &connection)) {
            __leave;
        }

        printf ("Connected!\n");

        ZeroMemory (&metrics, sizeof (metrics));

        metrics.FileCount = 1;
        metrics.TotalSize = 0;

        if (!pSendMetrics (connection.Socket, connection.Datagram, &metrics)) {
            __leave;
        }

        if (!pSendFile (
                connection.Socket,
                connection.Datagram ? &connection.DatagramPool : NULL,
                localFileName,
                destFileName
                )) {
            __leave;
        }
    }
    __finally {
        GbFree (&destinationAddresses);

        if (connection.Socket != INVALID_SOCKET) {
            closesocket (connection.Socket);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\template\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\osver\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg;

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    {
        OSVERSIONINFO versionInfo;

        ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
        versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        if (GetVersionEx (&versionInfo)) {
            printf ("OS version information:\n");
            printf ("OS major version no    :%d\n", versionInfo.dwMajorVersion);
            printf ("OS minor version no    :%d\n", versionInfo.dwMinorVersion);
            printf ("OS build no            :%d\n", versionInfo.dwBuildNumber);
            printf ("OS platform ID         :%d\n", versionInfo.dwPlatformId);
            printf ("OS string              :%s\n", versionInfo.szCSDVersion);
        } else {
            printf ("Version information could not be retrieved: %d\n", GetLastError ());
        }
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\icontool\icontool.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    icontool.c

Abstract:

    Tool to extract icons from ICO, PE and NE files and to write them
    to an ICO or PE file

Author:

    Calin Negreanu (calinn) 16 June 2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        FileEnumInitialize ();
        LogReInit (NULL, NULL, NULL, NULL);
        break;
    case DLL_PROCESS_DETACH:
        FileEnumTerminate ();
        UtTerminate ();
        break;
    }
    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
pHelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // Describe command line syntax(es), indent 2 spaces
        //

        "  icontool [/D:<destination file>] <node pattern> <leaf pattern>\n"

        "\nDescription:\n\n"

        //
        // Describe tool, indent 2 spaces
        //

        "  Extracts icon groups from ICO, PE and NE files specified <node pattern> and\n"
        "  <leaf pattern>. Optionally writes the extracted icons to either a PE file or\n"
        "  a sequence of ICO files.\n"

        "\nArguments:\n\n"

        //
        // Describe args, indent 2 spaces, say optional if necessary
        //

        "  /D:<destination file> - Specifies the destination file where all extracted icons\n"
        "                          are going to be written. It's either a PE file specification\n"
        "                          or a sequence of ICO files with %%d in name (like icon%%04d.ico)\n"
        "  <node pattern>  Specifies the directory pattern (like c:\\foo*\\bar?\\*)\n"
        "  <leaf pattern>  Specifies the file pattern (like abc*.exe)\n"
        );

    exit (1);
}

BOOL
pGetFilePath (
    IN      PCSTR UserSpecifiedFile,
    OUT     PTSTR Buffer,
    IN      UINT BufferTchars
    )
{
    PSTR tempBuffer = NULL;
    CHAR modulePath[MAX_MBCHAR_PATH];
    CHAR currentDir[MAX_MBCHAR_PATH];
    PSTR p;
    PCSTR userFile = NULL;
    PSTR dontCare;

    __try {
        //
        // Locate the file using the full path specified by the user, or
        // if only a file spec was given, use the following priorities:
        //
        // 1. Current directory
        // 2. Directory where the tool is
        //
        // In all cases, return the full path to the file.
        //

        tempBuffer = AllocTextA (BufferTchars);
        *tempBuffer = 0;

        if (!_mbsrchr (UserSpecifiedFile, '\\')) {

            if (!GetModuleFileNameA (NULL, modulePath, ARRAYSIZE(modulePath))) {
                MYASSERT (FALSE);
                return FALSE;
            }

            p = _mbsrchr (modulePath, '\\');
            if (p) {
                *p = 0;
            } else {
                MYASSERT (FALSE);
                return FALSE;
            }

            if (!GetCurrentDirectoryA (ARRAYSIZE(currentDir), currentDir)) {
                MYASSERT (FALSE);
                return FALSE;
            }

            //
            // Let's see if it's in the current dir
            //

            userFile = JoinPathsA (currentDir, UserSpecifiedFile);

            if (DoesFileExistA (userFile)) {
                GetFullPathNameA (
                    userFile,
                    BufferTchars,
                    tempBuffer,
                    &dontCare
                    );
            } else {

                //
                // Let's try the module dir
                //

                FreePathStringA (userFile);
                userFile = JoinPathsA (modulePath, UserSpecifiedFile);

                if (DoesFileExistA (userFile)) {
                    GetFullPathNameA (
                        userFile,
                        BufferTchars,
                        tempBuffer,
                        &dontCare
                        );
                }
            }

        } else {
            //
            // Use the full path that the user specified
            //

            GetFullPathNameA (
                UserSpecifiedFile,
                BufferTchars,
                tempBuffer,
                &dontCare
                );
        }

        //
        // Transfer output into caller's buffer.  Note the TCHAR conversion.
        //

#ifdef UNICODE
        KnownSizeAtoW (Buffer, tempBuffer);
#else
        StringCopy (Buffer, tempBuffer);
#endif

    }
    __finally {
        if (userFile) {
            FreePathStringA (userFile);
        }

        FreeTextA (tempBuffer);
    }

    return *Buffer != 0;
}

PCTSTR
pGetIconFileType (
    IN      DWORD FileType
    )
{
    switch (FileType) {
    case ICON_ICOFILE:
        return TEXT("ICO File");
    case ICON_PEFILE:
        return TEXT("PE  File");
    case ICON_NEFILE:
        return TEXT("NE  File");
    }
    return TEXT("UNKNOWN ");
}

INT
__cdecl
_tmain (
    INT Argc,
    PCTSTR Argv[]
    )
{
    INT i;
    PCTSTR nodePattern = NULL;
    PCTSTR leafPattern = NULL;
    PTSTR encodedPattern = NULL;
    PCSTR destFile = NULL;
    PSTR p;
    TCHAR destPath[MAX_PATH_PLUS_NUL];
    TCHAR destIcoPath[MAX_PATH_PLUS_NUL];
    FILETREE_ENUM e;
    ICON_ENUM iconEnum;
    PCSTR resourceId;
    DWORD totalIcons = 0;
    DWORD fileIcons = 0;
    DWORD fileType = 0;

    if (!Init()) {
        return 0;
    }

    for (i = 1 ; i < Argc ; i++) {
        if (Argv[i][0] == TEXT('/') || Argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&Argv[i][1]))) {

            case TEXT('d'):

                if (Argv[i][2] == TEXT(':')) {
                    destFile = &Argv[i][3];
                } else if (i + 1 < Argc) {
                    i++;
                    destFile = Argv[i];
                } else {
                    pHelpAndExit();
                }

                if (!pGetFilePath (destFile, destPath, ARRAYSIZE(destPath))) {
                    destPath [0] = 0;
                    break;
                }
                break;

            default:
                pHelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (nodePattern || leafPattern) {
                pHelpAndExit();
            }
            nodePattern = Argv[i];
            if (*nodePattern == TEXT('\"')) {
                nodePattern++;
                p = _tcsdec2 (nodePattern, GetEndOfString (nodePattern));
                if (p && *p == TEXT('\"')) {
                    *p = 0;
                }
            }
            leafPattern = Argv[i+1];
            i++;
        }
    }

    if (!nodePattern) {
        pHelpAndExit ();
    }

    if (!leafPattern) {
        pHelpAndExit ();
    }

    //
    // Begin processing
    //

    encodedPattern = ObsBuildEncodedObjectStringEx (nodePattern, leafPattern, FALSE);

    if (EnumFirstFileInTree (&e, encodedPattern)) {
        // at this point, if we don't have a valid updateHandle and moduleHandle
        // we will assume that the destination specification is a sequence of ICO files.
        do {
            fileIcons = 0;
            if (IcoEnumFirstIconGroupInFile (e.NativeFullName, &iconEnum)) {
                fileType = iconEnum.FileType;
                do {
                    if (destPath [0]) {
                        if (fileIcons == 0x0b) {
                        } else {
                        if (!IcoWriteIconGroupToPeFile (destPath, iconEnum.IconGroup, &resourceId, NULL)) {
                            wsprintf (destIcoPath, destPath, totalIcons);
                            if (!IcoWriteIconGroupToIcoFile (destIcoPath, iconEnum.IconGroup, TRUE)) {
                                printf ("Error writing icon group to destination file %s\n", destPath);
                            }
                        }
                        }
                    }
                    totalIcons ++;
                    fileIcons ++;
                } while (IcoEnumNextIconGroupInFile (&iconEnum));
                IcoAbortEnumIconGroup (&iconEnum);
            }
            if (fileIcons) {
                printf ("[%6u],[%6u] [%8s] %s\n", totalIcons, fileIcons, pGetIconFileType (fileType), e.NativeFullName);
            }
        } while (EnumNextFileInTree (&e));
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\regenum\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include <conio.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    //
    // Initialize the common libs
    //

    if (Reason == DLL_PROCESS_ATTACH) {
        UtInitialize (NULL);
        if (!RegInitialize ()) {
            return FALSE;
        }

    } else {
        RegTerminate();
        UtTerminate ();
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        "  regenum [/N] [/S] [/W] [/F] [/L:MaxSubLevel] [/X] <Node Pattern> <Leaf Pattern>\n"

        "\nDescription:\n\n"

        //
        // TODO: Describe tool, indent 2 spaces
        //

        "  Enumerates the part of registry that matches <Pattern>.\n"
        "  Uses C:\\exclude.inf if present and /X not specified to determine what keys/values\n"
        "  are excluded.\n"

        "\nArguments:\n\n"

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        "  /N  Specifies exclusion of key names from enumeration; optional\n"
        "  /S  Specifies sub-keys to be enumerated before values for any key; optional\n"
        "  /W  Specifies enumeration should be width-first; optional\n"
        "  /F  Specifies output should use \"key <value>\" format; optional\n"
        "  /L:MaxSubLevel  Specifies the maximum sub-level starting from the root of enum;\n"
        "                  -1 = all levels (default), 0 = only the root level etc.; optional\n"
        "  /X  Specifies to use exclusions in C:\\exclude.inf; optional\n"
        "  <Pattern>  Specifies the file/dir pattern; must have the form \"DirPattern <FilePattern>\"\n"
        "             the <FilePattern> part is optional; quotes required if both parts are specified\n"

        );

    exit (1);
}


BOOL
BuildExclusionList (
    IN      PCTSTR FileName
    )
{
    HINF h;
    INFCONTEXT ic;
    TCHAR buf[256];

    h = SetupOpenInfFile (FileName, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    if (SetupFindFirstLine (h, TEXT("RegKeys"), NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, buf, DWSIZEOF (buf) / DWSIZEOF (TCHAR), NULL)) {
                //ElAdd (ELT_REGKEY, buf);
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    if (SetupFindFirstLine (h, TEXT("RegValues"), NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, buf, DWSIZEOF (buf) / DWSIZEOF (TCHAR), NULL)) {
                //ElAdd (ELT_REGVALUE, buf);
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    SetupCloseInfFile (h);
    return TRUE;
}

BOOL
RegEnumCallback (
    IN      PREGNODE RegNode        OPTIONAL
    )
{
    BOOL b;

    if (!RegNode) {
        _ftprintf (stderr, TEXT("\nOut of memory\n"));
        return FALSE;
    }
    _ftprintf (stderr, TEXT("Error creating key node: %s; continue anyway ? (yn):"), RegNode->KeyName);
    b = _totupper(_getche ()) == TEXT('Y');
    _ftprintf (stderr, TEXT("\n"));
    return b;
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR patternNode = NULL;
    PCTSTR patternLeaf = NULL;
    PTSTR p;
    PCTSTR level;
    BOOL enumKeyNames = TRUE;
    BOOL valuesFirst = TRUE;
    BOOL depthFirst = TRUE;
    BOOL nativeFormat = TRUE;
    UINT maxSubLevel = -1;
    BOOL exclusions = FALSE;
    INT pos;
    REGTREE_ENUM e;
    PCTSTR pattern;

    //
    // TODO: Parse command line here
    //
    if (argc < 2) {
        HelpAndExit ();
    }

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('x'):
                exclusions = TRUE;
                break;
            case TEXT('n'):
                enumKeyNames = FALSE;
                break;
            case TEXT('s'):
                valuesFirst = FALSE;
                break;
            case TEXT('w'):
                depthFirst = FALSE;
                break;
            case TEXT('f'):
                nativeFormat = FALSE;
                break;
            case TEXT('l'):
                if (argv[i][2] == TEXT(':')) {
                    level = &argv[i][3];
                } else if (i + 1 < argc) {
                    level = argv[++i];
                } else {
                    HelpAndExit();
                }
                if (!_stscanf (level, TEXT("%ld%n"), &maxSubLevel, &pos) || level[pos]) {
                    HelpAndExit();
                }
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (!patternNode) {
                patternNode = argv[i];
            } else if (!patternLeaf) {
                patternLeaf = argv[i];
            } else {
                HelpAndExit();
            }
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 2;
    }

    if (!patternLeaf) {
        HelpAndExit ();
    }

    pattern = ObsBuildEncodedObjectStringEx (patternNode, patternLeaf, FALSE);

    //
    // TODO: Do work here
    //

    if (exclusions) {
        BuildExclusionList (TEXT("C:\\exclude.inf"));
    }

    if (EnumFirstRegObjectInTreeEx (
            &e,
            pattern,
            enumKeyNames,
            TRUE,
            valuesFirst,
            depthFirst,
            maxSubLevel,
            exclusions,
            FALSE,
            RegEnumDefaultCallback
            )) {
        do {
            _tprintf (
                TEXT("%s - %s\n"),
                nativeFormat ? e.NativeFullName : e.EncodedFullName,
                (e.Attributes & REG_ATTRIBUTE_KEY) ? TEXT("Key") : TEXT("Value")
                );
        } while (EnumNextRegObjectInTree (&e));
    }

    //
    // End of processing
    //

    if (exclusions) {
        ElRemoveAll ();
    }

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\ssstub\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implements a small utility that fills the disk for purposes of free space
    testing.

Author:

    Jim Schmidt (jimschm) 18-Aug-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    UtInitialize (NULL);

    return TRUE;
}


VOID
Terminate (
    VOID
    )
{
    UtTerminate ();
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        "  filler <free_space> [/D:<drive>] [/C:<cmdline> [/M]]\n"
        "  filler /Q [/D:<drive>]\n"

        "\nDescription:\n\n"

        "  filler creates a file (bigfile.dat) on the current or specified\n"
        "  drive, leaving only the specified amount of free space on the drive.\n"

        "\nArguments:\n\n"

        "  free_space   Specifies the amount of free space to leave on\n"
        "               disk.\n"
        "  /D           Specifies the drive letter to fill (i.e. /D:C)\n"
        "  /Q           Queries the free space on the disk\n"
        "  /C           Executes command line specified in <cmdline>\n"
        "  /M           Issue message box if command line alters disk space\n"

        );

    exit (1);
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    TCHAR curDir[MAX_PATH];
    TCHAR curFileS[MAX_PATH];
    TCHAR curFileD[MAX_PATH];
    PCTSTR cmdLine = NULL;
    PCTSTR cmdPtr = NULL;
    TCHAR newCmdLine[MAX_PATH];

    GetCurrentDirectory (ARRAYSIZE(curDir), curDir);
    cmdLine = GetCommandLine ();
    if (!cmdLine) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    cmdPtr = _tcsstr (cmdLine, TEXT("scanstate"));
    if (!cmdPtr) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    StringCopyAB (newCmdLine, cmdLine, cmdPtr);
    StringCat (newCmdLine, TEXT("scanstate_a.exe"));
    cmdPtr = _tcschr (cmdPtr, TEXT(' '));
    if (!cmdPtr) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    StringCat (newCmdLine, cmdPtr);

    //
    // Begin processing
    //

    if (!Init()) {
        exit (-1);
    }

    //
    // Do work here
    //
    {
        BOOL result = FALSE;
        STARTUPINFO startupInfo;
        PROCESS_INFORMATION processInformation;
        DWORD exitCode = -1;

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("guitrn_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("guitrn.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("unctrn_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("unctrn.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("script_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("script.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("sysmod_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("sysmod.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("migism_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("migism.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
        startupInfo.cb = sizeof (STARTUPINFO);
        ZeroMemory (&processInformation, sizeof (PROCESS_INFORMATION));

        result = CreateProcess (
                    NULL,
                    newCmdLine,
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &startupInfo,
                    &processInformation
                    );

        if (result && processInformation.hProcess && (processInformation.hProcess != INVALID_HANDLE_VALUE)) {
            WaitForSingleObject (processInformation.hProcess, INFINITE);
            if (!GetExitCodeProcess (processInformation.hProcess, &exitCode)) {
                exitCode = -1;
            }
            exit (exitCode);
        }
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\lsstub\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implements a small utility that fills the disk for purposes of free space
    testing.

Author:

    Jim Schmidt (jimschm) 18-Aug-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    UtInitialize (NULL);

    return TRUE;
}


VOID
Terminate (
    VOID
    )
{
    UtTerminate ();
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        "  filler <free_space> [/D:<drive>] [/C:<cmdline> [/M]]\n"
        "  filler /Q [/D:<drive>]\n"

        "\nDescription:\n\n"

        "  filler creates a file (bigfile.dat) on the current or specified\n"
        "  drive, leaving only the specified amount of free space on the drive.\n"

        "\nArguments:\n\n"

        "  free_space   Specifies the amount of free space to leave on\n"
        "               disk.\n"
        "  /D           Specifies the drive letter to fill (i.e. /D:C)\n"
        "  /Q           Queries the free space on the disk\n"
        "  /C           Executes command line specified in <cmdline>\n"
        "  /M           Issue message box if command line alters disk space\n"

        );

    exit (1);
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    TCHAR curDir[MAX_PATH];
    TCHAR curFileS[MAX_PATH];
    TCHAR curFileD[MAX_PATH];
    PCTSTR cmdLine = NULL;
    PCTSTR cmdPtr = NULL;
    TCHAR newCmdLine[MAX_PATH];

    GetCurrentDirectory (ARRAYSIZE(curDir), curDir);
    cmdLine = GetCommandLine ();
    if (!cmdLine) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    cmdPtr = _tcsstr (cmdLine, TEXT("loadstate"));
    if (!cmdPtr) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    StringCopyAB (newCmdLine, cmdLine, cmdPtr);
    StringCat (newCmdLine, TEXT("loadstate_u.exe"));
    cmdPtr = _tcschr (cmdPtr, TEXT(' '));
    if (!cmdPtr) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    StringCat (newCmdLine, cmdPtr);

    //
    // Begin processing
    //

    if (!Init()) {
        exit (-1);
    }

    //
    // Do work here
    //
    {
        BOOL result = FALSE;
        STARTUPINFO startupInfo;
        PROCESS_INFORMATION processInformation;
        DWORD exitCode = -1;

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("guitrn_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("guitrn.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("unctrn_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("unctrn.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("script_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("script.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("sysmod_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("sysmod.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("migism_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("migism.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
        startupInfo.cb = sizeof (STARTUPINFO);
        ZeroMemory (&processInformation, sizeof (PROCESS_INFORMATION));

        result = CreateProcess (
                    NULL,
                    newCmdLine,
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &startupInfo,
                    &processInformation
                    );

        if (result && processInformation.hProcess && (processInformation.hProcess != INVALID_HANDLE_VALUE)) {
            WaitForSingleObject (processInformation.hProcess, INFINITE);
            if (!GetExitCodeProcess (processInformation.hProcess, &exitCode)) {
                exitCode = -1;
            }
            exit (exitCode);
        }
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\tools\utiltool\template\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);
BOOL g_Source = FALSE;

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        "  utiltool [/F:file]\n"

        "\nDescription:\n\n"

        //
        // TODO: Describe tool, indent 2 spaces
        //

        "  <Not Specified>\n"

        "\nArguments:\n\n"

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        "  /F  Specifies optional file name\n"

        );

    exit (1);
}

HANDLE
pOpenAndSetPort (
    IN      PCTSTR ComPort
    )
{
    HANDLE result = INVALID_HANDLE_VALUE;
    COMMTIMEOUTS commTimeouts;
    DCB dcb;

    // let's open the port. If we can't we just exit with error;
    result = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (result == INVALID_HANDLE_VALUE) {
        return result;
    }

    // we want 10 sec timeout for both read and write
    commTimeouts.ReadIntervalTimeout = 0;
    commTimeouts.ReadTotalTimeoutMultiplier = 0;
    commTimeouts.ReadTotalTimeoutConstant = 10000;
    commTimeouts.WriteTotalTimeoutMultiplier = 0;
    commTimeouts.WriteTotalTimeoutConstant = 10000;
    SetCommTimeouts (result, &commTimeouts);

    // let's set some comm state data
    if (GetCommState (result, &dcb)) {
        dcb.fBinary = 1;
        dcb.fParity = 1;
        dcb.ByteSize = 8;
        if (g_Source) {
            dcb.BaudRate = CBR_115200;
        } else {
            dcb.BaudRate = CBR_57600;
        }
        if (!SetCommState (result, &dcb)) {
            CloseHandle (result);
            result = INVALID_HANDLE_VALUE;
            return result;
        }
    } else {
        CloseHandle (result);
        result = INVALID_HANDLE_VALUE;
        return result;
    }

    return result;
}

#define ACK     0x16
#define NAK     0x15
#define SOH     0x01
#define EOT     0x04

BOOL
pSendFileToHandle (
    IN      HANDLE DeviceHandle,
    IN      PCTSTR FileName
    )
{
    HANDLE fileHandle = NULL;
    BOOL result = TRUE;
    BYTE buffer [132];
    BYTE signal;
    BYTE currBlock = 0;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = FALSE;
    UINT index;

    fileHandle = BfOpenReadFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    // finally let's start the protocol

    // We are going to listen for the NAK(15h) signal.
    // As soon as we get it we are going to send a 132 bytes block having:
    // 1 byte - SOH (01H)
    // 1 byte - block number
    // 1 byte - FF - block number
    // 128 bytes of data
    // 1 byte - checksum - sum of all 128 bytes of data
    // After the block is sent, we are going to wait for ACK(16h). If we don't get
    // it after timeout or if we get something else we are going to send the block again.

    // wait for NAK
    while (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
           (numRead != 1) ||
           (signal != NAK)
           );

    repeat = FALSE;
    while (TRUE) {
        if (!repeat) {
            // prepare the next block
            currBlock ++;
            if (currBlock == 0) {
                result = TRUE;
            }
            buffer [0] = SOH;
            buffer [1] = currBlock;
            buffer [2] = 0xFF - currBlock;
            if (!ReadFile (fileHandle, buffer + 3, 128, &numRead, NULL) ||
                (numRead == 0)
                ) {
                // we are done with data, send the EOT signal
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
                break;
            }

            // compute the checksum
            buffer [sizeof (buffer) - 1] = 0;
            signal = 0;
            for (index = 0; index < sizeof (buffer) - 1; index ++) {
                signal += buffer [index];
            }
            buffer [sizeof (buffer) - 1] = signal;
        }

        // now send the block to the other side
        if (!WriteFile (DeviceHandle, buffer, sizeof (buffer), &numWritten, NULL) ||
            (numWritten != sizeof (buffer))
            ) {
            repeat = TRUE;
        } else {
            repeat = FALSE;
        }

        if (repeat) {
            // we could not send the data last time
            // let's just wait for a NAK for 10 sec and then send it again
            ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL);
        } else {
            // we sent it OK. We need to wait for an ACK to come. If we timeout
            // or we get something else, we will repeat the block.
            if (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
                (numRead != sizeof (signal)) ||
                (signal != ACK)
                ) {
                repeat = TRUE;
            }
        }
    }

    // we are done here. However, let's listen one more timeout for a
    // potential NAK. If we get it, we'll repeat the EOT signal
    while (ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) &&
        (numRead == 1)
        ) {
        if (signal == NAK) {
            signal = EOT;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }
    }

    CloseHandle (fileHandle);

    return result;
}

BOOL
pSendFile (
    IN      PCTSTR ComPort,
    IN      PCTSTR FileName
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    deviceHandle = pOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pSendFileToHandle (deviceHandle, FileName);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pReceiveFileFromHandle (
    IN      HANDLE DeviceHandle,
    IN      PCTSTR FileName
    )
{
    HANDLE fileHandle = NULL;
    BOOL result = TRUE;
    BYTE buffer [132];
    BYTE signal;
    BYTE currBlock = 1;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = TRUE;
    UINT index;

    fileHandle = BfCreateFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    // finally let's start the protocol

    // We are going to send an NAK(15h) signal.
    // After that we are going to listen for a block.
    // If we don't get the block in time, or the block is wrong size
    // or it has a wrong checksum we are going to send a NAK signal,
    // otherwise we are going to send an ACK signal
    // One exception. If the block size is 1 and the block is actually the
    // EOT signal it means we are done.

    while (TRUE) {
        if (repeat) {
            // send the NAK
            signal = NAK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        } else {
            // send the ACK
            signal = ACK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }
        repeat = TRUE;
        // let's read the data block
        if (ReadFile (DeviceHandle, buffer, sizeof (buffer), &numRead, NULL)) {
            if ((numRead == 1) &&
                (buffer [0] == EOT)
                ) {
                break;
            }
            if (numRead == sizeof (buffer)) {
                // compute the checksum
                signal = 0;
                for (index = 0; index < sizeof (buffer) - 1; index ++) {
                    signal += buffer [index];
                }
                if (buffer [sizeof (buffer) - 1] == signal) {
                    repeat = FALSE;
                    // checksum is correct, let's see if this is the right block
                    if (currBlock < buffer [1]) {
                        // this is a major error, the sender is ahead of us,
                        // we have to fail
                        result = FALSE;
                        break;
                    }
                    if (currBlock == buffer [1]) {
                        WriteFile (fileHandle, buffer + 3, 128, &numWritten, NULL);
                        currBlock ++;
                    }
                }
            }
        }
    }

    CloseHandle (fileHandle);

    return result;
}

BOOL
pReceiveFile (
    IN      PCTSTR ComPort,
    IN      PCTSTR FileName
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    deviceHandle = pOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pReceiveFileFromHandle (deviceHandle, FileName);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pPrintStuff (
    PCTSTR ComPort
    )
{
    HANDLE comPortHandle = INVALID_HANDLE_VALUE;
    COMMTIMEOUTS commTimeouts;
    DCB dcb;
    COMMPROP commProp;

    printf ("Processing %s...\n\n", ComPort);

    comPortHandle = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (comPortHandle == INVALID_HANDLE_VALUE) {
        printf ("Cannot open comport. Error: %d\n", GetLastError ());
        return FALSE;
    }

    if (GetCommTimeouts (comPortHandle, &commTimeouts)) {
        printf ("Timeouts:\n");
        printf ("ReadIntervalTimeout            %d\n", commTimeouts.ReadIntervalTimeout);
        printf ("ReadTotalTimeoutMultiplier     %d\n", commTimeouts.ReadTotalTimeoutMultiplier);
        printf ("ReadTotalTimeoutConstant       %d\n", commTimeouts.ReadTotalTimeoutConstant);
        printf ("WriteTotalTimeoutMultiplier    %d\n", commTimeouts.WriteTotalTimeoutMultiplier);
        printf ("WriteTotalTimeoutConstant      %d\n", commTimeouts.WriteTotalTimeoutConstant);
        printf ("\n");
    } else {
        printf ("Cannot get CommTimeouts. Error: %d\n\n", GetLastError ());
    }

    if (GetCommState (comPortHandle, &dcb)) {
        printf ("CommState:\n");
        printf ("DCBlength              %d\n", dcb.DCBlength);
        printf ("BaudRate               %d\n", dcb.BaudRate);
        printf ("fBinary                %d\n", dcb.fBinary);
        printf ("fParity                %d\n", dcb.fParity);
        printf ("fOutxCtsFlow           %d\n", dcb.fOutxCtsFlow);
        printf ("fOutxDsrFlow           %d\n", dcb.fOutxDsrFlow);
        printf ("fDtrControl            %d\n", dcb.fDtrControl);
        printf ("fDsrSensitivity        %d\n", dcb.fDsrSensitivity);
        printf ("fTXContinueOnXoff      %d\n", dcb.fTXContinueOnXoff);
        printf ("fOutX                  %d\n", dcb.fOutX);
        printf ("fInX                   %d\n", dcb.fInX);
        printf ("fErrorChar             %d\n", dcb.fErrorChar);
        printf ("fNull                  %d\n", dcb.fNull);
        printf ("fRtsControl            %d\n", dcb.fRtsControl);
        printf ("fAbortOnError          %d\n", dcb.fAbortOnError);
        printf ("fDummy2                %d\n", dcb.fDummy2);
        printf ("wReserved              %d\n", dcb.wReserved);
        printf ("XonLim                 %d\n", dcb.XonLim);
        printf ("XoffLim                %d\n", dcb.XoffLim);
        printf ("ByteSize               %d\n", dcb.ByteSize);
        printf ("Parity                 %d\n", dcb.Parity);
        printf ("StopBits               %d\n", dcb.StopBits);
        printf ("XonChar                %d\n", dcb.XonChar);
        printf ("XoffChar               %d\n", dcb.XoffChar);
        printf ("ErrorChar              %d\n", dcb.ErrorChar);
        printf ("EofChar                %d\n", dcb.EofChar);
        printf ("EvtChar                %d\n", dcb.EvtChar);
        printf ("wReserved1             %d\n", dcb.wReserved1);
        printf ("\n");
    } else {
        printf ("Cannot get CommState. Error: %d\n\n", GetLastError ());
    }

    if (GetCommProperties (comPortHandle, &commProp)) {
        printf ("CommProperties:\n");
        printf ("wPacketLength          %d\n", commProp.wPacketLength);
        printf ("wPacketVersion         %d\n", commProp.wPacketVersion);
        printf ("dwServiceMask          %d\n", commProp.dwServiceMask);
        printf ("dwReserved1            %d\n", commProp.dwReserved1);
        printf ("dwMaxTxQueue           %d\n", commProp.dwMaxTxQueue);
        printf ("dwMaxRxQueue           %d\n", commProp.dwMaxRxQueue);
        printf ("dwMaxBaud              %d\n", commProp.dwMaxBaud);
        printf ("dwProvSubType          %d\n", commProp.dwProvSubType);
        printf ("dwProvCapabilities     %d\n", commProp.dwProvCapabilities);
        printf ("dwSettableParams       %d\n", commProp.dwSettableParams);
        printf ("dwSettableBaud         %d\n", commProp.dwSettableBaud);
        printf ("wSettableData          %d\n", commProp.wSettableData);
        printf ("wSettableStopParity    %d\n", commProp.wSettableStopParity);
        printf ("dwCurrentTxQueue       %d\n", commProp.dwCurrentTxQueue);
        printf ("dwCurrentRxQueue       %d\n", commProp.dwCurrentRxQueue);
        printf ("dwProvSpec1            %d\n", commProp.dwProvSpec1);
        printf ("dwProvSpec2            %d\n", commProp.dwProvSpec2);
        printf ("wcProvChar             %S\n", commProp.wcProvChar);
        printf ("\n");
    } else {
        printf ("Cannot get CommProperties. Error: %d\n\n", GetLastError ());
    }
    return TRUE;
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg = NULL;
    PCTSTR comPort = NULL;
    BOOL sender = FALSE;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('f'):
                //
                // Sample option - /f:file
                //

                if (argv[i][2] == TEXT(':')) {
                    FileArg = &argv[i][3];
                } else if (i + 1 < argc) {
                    FileArg = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            case TEXT('s'):
                sender = TRUE;
                g_Source = TRUE;
                break;

            case TEXT('c'):
                //
                // Sample option - /f:file
                //

                if (argv[i][2] == TEXT(':')) {
                    comPort = &argv[i][3];
                } else if (i + 1 < argc) {
                    comPort = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // TODO: Do work here
    //
    {

        pPrintStuff (comPort);

        /*
        if (sender) {
            pSendFile (comPort, FileArg);
        } else {
            pReceiveFile (comPort, FileArg);
        }
        */
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\compress\mrcicode.c ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.C
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */
#include "pch.h"
#include "mrcicode.h"                   /* prototype verification */

#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

static unsigned abits;                  /* Array of bits */
static unsigned cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed;  /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static unsigned ahash[CHASH];           /* Hash table */
static unsigned alink[MAXDISPBIG];      /* Links */


/* compression internal functions */

static void inithash(void);
static void charbuf(unsigned c);
static void putbits(unsigned bits,unsigned cbits);
static void outlength(unsigned cb);

static void mrci1outsingle(unsigned ch);
static void mrci1outstring(unsigned disp,unsigned cb);

static void mrci2outsingle(unsigned ch);
static void mrci2outstring(unsigned disp,unsigned cb);


/* decompression internal functions */

static unsigned getbit(void);
static unsigned getbits(unsigned cbits);
static void expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void inithash(void)
{
    unsigned FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static unsigned getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static unsigned getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char FAR *source;
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\compress\mrcicode.h ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.H
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

extern unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\compress\compress.c ===
#include "pch.h"
#include "compress.h"
#include "mrcicode.h"

#define COMPRESS_SIG            0x434F4D50  //COMP
#define COMPRESS_CONT_SIG       0x434F4D43  //COMC
#define COMPRESS_NEWFILE        0x434F4D46  //COMF
#define COMPRESS_BUFFER_SIZE    0x8000      //32K
#define COMPRESS_DEFAULT_SIZE   0x7FFFFFFF  //2GB

BOOL g_ErrorMode = FALSE;

unsigned
CompressData(
    IN  CompressionType Type,
    IN  PBYTE           Data,
    IN  unsigned        DataSize,
    OUT PBYTE           CompressedData,
    IN  unsigned        BufferSize
    )
{
    unsigned u;

    switch(Type) {

    case CompressNone:
    default:
        //
        // Force caller to do something intelligent, such as
        // writing directly out of the uncompressed buffer.
        // This avoids an extra memory move.
        //
        u = (unsigned)(-1);
        break;

    case CompressMrci1:
        u = Mrci1MaxCompress(Data,DataSize,CompressedData,BufferSize);
        break;

    case CompressMrci2:
        u = Mrci2MaxCompress(Data,DataSize,CompressedData,BufferSize);
        break;
    }

    return(u);
}


unsigned
DecompressData(
    IN  CompressionType Type,
    IN  PBYTE           CompressedData,
    IN  unsigned        CompressedDataSize,
    OUT PBYTE           DecompressedData,
    IN  unsigned        BufferSize
    )
{
    unsigned u;

    switch(Type) {

    case CompressNone:
        if(BufferSize >= CompressedDataSize) {
            memmove(DecompressedData,CompressedData,CompressedDataSize);
            u = CompressedDataSize;
        } else {
            u = (unsigned)(-1);
        }
        break;

    case CompressMrci1:
        u = Mrci1Decompress(CompressedData,CompressedDataSize,DecompressedData,BufferSize);
        break;

    case CompressMrci2:
        u = Mrci2Decompress(CompressedData,CompressedDataSize,DecompressedData,BufferSize);
        break;

    default:
        u = (unsigned)(-1);
        break;
    }

    return(u);
}

VOID
CompressCleanupHandleA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    )
{
    if (CompressedHandle) {
        if (CompressedHandle->ReadBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->ReadBuffer);
        }
        if (CompressedHandle->ExtraBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->ExtraBuffer);
        }
        if (CompressedHandle->CompBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->CompBuffer);
        }
        if (CompressedHandle->StorePath) {
            FreePathStringA (CompressedHandle->StorePath);
        }
        if (CompressedHandle->MainFilePattern) {
            FreePathStringA (CompressedHandle->MainFilePattern);
        }
        if ((CompressedHandle->CurrFileHandle) &&
            (CompressedHandle->CurrFileHandle != INVALID_HANDLE_VALUE)
            ) {
            CloseHandle (CompressedHandle->CurrFileHandle);
        }
        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEA));
    }
}

VOID
CompressCleanupHandleW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    )
{
    if (CompressedHandle) {
        if (CompressedHandle->ReadBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->ReadBuffer);
        }
        if (CompressedHandle->ExtraBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->ExtraBuffer);
        }
        if (CompressedHandle->CompBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->CompBuffer);
        }
        if (CompressedHandle->StorePath) {
            FreePathStringW (CompressedHandle->StorePath);
        }
        if (CompressedHandle->MainFilePattern) {
            FreePathStringW (CompressedHandle->MainFilePattern);
        }
        if ((CompressedHandle->CurrFileHandle) &&
            (CompressedHandle->CurrFileHandle != INVALID_HANDLE_VALUE)
            ) {
            CloseHandle (CompressedHandle->CurrFileHandle);
        }
        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEW));
    }
}

BOOL
CompressCreateHandleA (
    IN      PCSTR StorePath,
    IN      PCSTR MainFilePattern,
    IN      UINT StartIndex,
    IN      LONGLONG MaxFileSize,
    OUT     PCOMPRESS_HANDLEA CompressedHandle
    )
{
    CHAR currFile [1024];
    PCSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    BOOL result = FALSE;

    __try {

        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEA));
        if (StartIndex == 0) {
            CompressedHandle->CurrFileIndex = 1;
        } else {
            CompressedHandle->CurrFileIndex = StartIndex;
        }
        CompressedHandle->FirstFileIndex = CompressedHandle->CurrFileIndex;
        if (MaxFileSize == 0) {
            CompressedHandle->MaxFileSize = COMPRESS_DEFAULT_SIZE;
        } else {
            CompressedHandle->MaxFileSize = MaxFileSize;
        }
        CompressedHandle->StorePath = DuplicatePathStringA (StorePath, 0);
        if (!CompressedHandle->StorePath) {
            __leave;
        }
        CompressedHandle->MainFilePattern = DuplicatePathStringA (MainFilePattern, 0);
        if (!CompressedHandle->MainFilePattern) {
            __leave;
        }
        wsprintfA (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
        CompressedHandle->CurrFileHandle = BfCreateFileA (currFullPath);
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringA (currFullPath);
        currFullPath = NULL;

        // write the signature
        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        // reserve room for writing how many files we stored
        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        CompressedHandle->ReadBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ReadBuffer) {
            __leave;
        }

        CompressedHandle->CompBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->CompBuffer) {
            __leave;
        }

        CompressedHandle->ExtraBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ExtraBuffer) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        if (!result) {
            CompressCleanupHandleA (CompressedHandle);
        }
        PopError ();
    }

    return result;
}

BOOL
CompressCreateHandleW (
    IN      PCWSTR StorePath,
    IN      PCWSTR MainFilePattern,
    IN      UINT StartIndex,
    IN      LONGLONG MaxFileSize,
    OUT     PCOMPRESS_HANDLEW CompressedHandle
    )
{
    WCHAR currFile [1024];
    PCWSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    BOOL result = FALSE;

    __try {

        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEW));
        if (StartIndex == 0) {
            CompressedHandle->CurrFileIndex = 1;
        } else {
            CompressedHandle->CurrFileIndex = StartIndex;
        }
        CompressedHandle->FirstFileIndex = CompressedHandle->CurrFileIndex;
        if (MaxFileSize == 0) {
            CompressedHandle->MaxFileSize = COMPRESS_DEFAULT_SIZE;
        } else {
            CompressedHandle->MaxFileSize = MaxFileSize;
        }
        CompressedHandle->StorePath = DuplicatePathStringW (StorePath, 0);
        if (!CompressedHandle->StorePath) {
            __leave;
        }
        CompressedHandle->MainFilePattern = DuplicatePathStringW (MainFilePattern, 0);
        if (!CompressedHandle->MainFilePattern) {
            __leave;
        }
        wsprintfW (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
        CompressedHandle->CurrFileHandle = BfCreateFileW (currFullPath);
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringW (currFullPath);
        currFullPath = NULL;

        // write the signature
        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        // reserve room for writing how many files we stored
        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        CompressedHandle->ReadBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ReadBuffer) {
            __leave;
        }

        CompressedHandle->CompBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->CompBuffer) {
            __leave;
        }

        CompressedHandle->ExtraBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ExtraBuffer) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        if (!result) {
            CompressCleanupHandleW (CompressedHandle);
        }
        PopError ();
    }

    return result;
}

BOOL
pPrepareNextFileA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle,
    IN      BOOL ReadOnly
    )
{
    CHAR currFile [1024];
    PCSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    LONGLONG contSig = COMPRESS_CONT_SIG;
    BOOL result = FALSE;

    __try {

        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }

        if (!CloseHandle (CompressedHandle->CurrFileHandle)) {
            __leave;
        }

        CompressedHandle->CurrFileSize = 0;

        CompressedHandle->CurrFileIndex ++;

        wsprintfA (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
        if (ReadOnly) {
            CompressedHandle->CurrFileHandle = BfOpenReadFileA (currFullPath);
        } else {
            CompressedHandle->CurrFileHandle = BfCreateFileA (currFullPath);
        }
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringA (currFullPath);
        currFullPath = NULL;

        if (ReadOnly) {
            // read the signature
            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            if (signature != COMPRESS_SIG) {
                SetLastError (ERROR_INVALID_DATA);
                __leave;
            }

            // read special continuation signature
            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&contSig), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);

            if (CompressedHandle->CurrFileIndex > 1) {
                if (contSig != COMPRESS_CONT_SIG) {
                    SetLastError (ERROR_INVALID_DATA);
                    __leave;
                }
            }
        } else {
            // write the signature
            if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            // write special continuation signature
            if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&contSig), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        PopError ();
    }

    return result;
}

BOOL
pPrepareNextFileW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle,
    IN      BOOL ReadOnly
    )
{
    WCHAR currFile [1024];
    PCWSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    LONGLONG contSig = COMPRESS_CONT_SIG;
    BOOL result = FALSE;

    __try {

        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }

        if (!CloseHandle (CompressedHandle->CurrFileHandle)) {
            __leave;
        }

        CompressedHandle->CurrFileSize = 0;

        CompressedHandle->CurrFileIndex ++;

        wsprintfW (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
        if (ReadOnly) {
            CompressedHandle->CurrFileHandle = BfOpenReadFileW (currFullPath);
        } else {
            CompressedHandle->CurrFileHandle = BfCreateFileW (currFullPath);
        }
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringW (currFullPath);
        currFullPath = NULL;

        if (ReadOnly) {
            // read the signature
            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            if (signature != COMPRESS_SIG) {
                SetLastError (ERROR_INVALID_DATA);
                __leave;
            }

            // read special continuation signature
            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&contSig), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);

            if (CompressedHandle->CurrFileIndex > 1) {
                if (contSig != COMPRESS_CONT_SIG) {
                    SetLastError (ERROR_INVALID_DATA);
                    __leave;
                }
            }
        } else {
            // write the signature
            if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            // write special continuation signature
            if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&contSig), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        PopError ();
    }

    return result;
}

BOOL
pDeleteNextFilesA (
    IN      PCOMPRESS_HANDLEA CompressedHandle,
    IN      UINT SavedIndex
    )
{
    CHAR currFile [1024];
    PCSTR currFullPath = NULL;

    while (TRUE) {
        wsprintfA (currFile, CompressedHandle->MainFilePattern, SavedIndex);
        currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
        if (currFullPath) {
            if (DoesFileExistA (currFullPath)) {
                DeleteFileA (currFullPath);
            } else {
                break;
            }
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        SavedIndex ++;
    }
    if (currFullPath) {
        FreePathStringA (currFullPath);
        currFullPath = NULL;
    }
    return TRUE;
}

BOOL
pDeleteNextFilesW (
    IN      PCOMPRESS_HANDLEW CompressedHandle,
    IN      UINT SavedIndex
    )
{
    WCHAR currFile [1024];
    PCWSTR currFullPath = NULL;

    while (TRUE) {
        wsprintfW (currFile, CompressedHandle->MainFilePattern, SavedIndex);
        currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
        if (currFullPath) {
            if (DoesFileExistW (currFullPath)) {
                DeleteFileW (currFullPath);
            } else {
                break;
            }
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        SavedIndex ++;
    }
    if (currFullPath) {
        FreePathStringW (currFullPath);
        currFullPath = NULL;
    }
    return TRUE;
}

BOOL
CompressAddFileToHandleA (
    IN      PCSTR FileName,
    IN      PCSTR StoredName,
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    LONGLONG fileSize;
    DWORD bytesRead;
    DWORD bytesWritten;
    DWORD bytesComp;
    DWORD bytesUncomp;
    DWORD signature = COMPRESS_NEWFILE;
    DWORD fileNameSize;
    DWORD headerSize;
    USHORT compType = 0;
    USHORT compSize = 0;
    PCWSTR unicodeName = NULL;
    UINT savedIndex = 0;
    LARGE_INTEGER savedSize;
    BOOL result = FALSE;

    __try {

        // save the state of the compress handle
        savedIndex = CompressedHandle->CurrFileIndex;
        savedSize.QuadPart = CompressedHandle->CurrFileSize;

        fileSize = BfGetFileSizeA (FileName);
        fileHandle = BfOpenReadFileA (FileName);
        if ((fileHandle == NULL) ||
            (fileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }

        // handle UNICODE files
        unicodeName = ConvertAtoW (StoredName);
        if (!unicodeName) {
            __leave;
        }
        fileNameSize = SizeOfStringW (unicodeName);
        headerSize = sizeof (DWORD) + sizeof (LONGLONG) + sizeof (DWORD) + fileNameSize;

        if (CompressedHandle->CurrFileSize + headerSize > CompressedHandle->MaxFileSize) {
            if (!pPrepareNextFileA (CompressedHandle, FALSE)) {
                __leave;
            }
        }

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileSize), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileNameSize), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(unicodeName), fileNameSize)) {
            __leave;
        }
        CompressedHandle->CurrFileSize += fileNameSize;
        FreeConvertedStr (unicodeName);
        unicodeName = NULL;

        while (fileSize) {

            ZeroMemory (CompressedHandle->ReadBuffer, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
            ZeroMemory (CompressedHandle->CompBuffer, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));

            if (!ReadFile (fileHandle, CompressedHandle->ReadBuffer + 2 * sizeof (USHORT), COMPRESS_BUFFER_SIZE, &bytesRead, NULL)) {
                __leave;
            }
            if (bytesRead == 0)
            {
                // Somehow the file points is beyond the end of the file. Probably file in use.
                SetLastError(ERROR_SHARING_VIOLATION);
                __leave;
            }

            bytesComp = CompressData (
                            CompressMrci1,
                            CompressedHandle->ReadBuffer + 2 * sizeof (USHORT),
                            bytesRead,
                            CompressedHandle->CompBuffer + 2 * sizeof (USHORT),
                            COMPRESS_BUFFER_SIZE
                            );

            if (bytesComp < bytesRead) {
                bytesUncomp = DecompressData (
                                CompressMrci1,
                                CompressedHandle->CompBuffer + 2 * sizeof (USHORT),
                                bytesComp,
                                CompressedHandle->ExtraBuffer,
                                COMPRESS_BUFFER_SIZE
                                );
                if (bytesUncomp != bytesRead) {
                    bytesComp = COMPRESS_BUFFER_SIZE;
                } else {
                    if (!TestBuffer (CompressedHandle->ReadBuffer + 2 * sizeof (USHORT), CompressedHandle->ExtraBuffer, bytesRead)) {
                        bytesComp = COMPRESS_BUFFER_SIZE;
                    }
                }
            }

            if (bytesComp >= bytesRead) {
                compType = CompressNone;
                compSize = (USHORT)bytesRead;
                CopyMemory (CompressedHandle->ReadBuffer, &compType, sizeof (USHORT));
                CopyMemory (CompressedHandle->ReadBuffer + sizeof (USHORT), &compSize, sizeof (USHORT));

                compSize += (2 * sizeof (USHORT));

                if (CompressedHandle->CurrFileSize + compSize > CompressedHandle->MaxFileSize) {
                    if (!pPrepareNextFileA (CompressedHandle, FALSE)) {
                        __leave;
                    }
                }

                if (!BfWriteFile (CompressedHandle->CurrFileHandle, CompressedHandle->ReadBuffer, compSize)) {
                    __leave;
                }
                CompressedHandle->CurrFileSize += compSize;
            } else {
                compType = CompressMrci1;
                compSize = (USHORT)bytesComp;
                CopyMemory (CompressedHandle->CompBuffer, &compType, sizeof (USHORT));
                CopyMemory (CompressedHandle->CompBuffer + sizeof (USHORT), &compSize, sizeof (USHORT));

                compSize += (2 * sizeof (USHORT));

                if (CompressedHandle->CurrFileSize + compSize > CompressedHandle->MaxFileSize) {
                    if (!pPrepareNextFileA (CompressedHandle, FALSE)) {
                        __leave;
                    }
                }

                if (!BfWriteFile (CompressedHandle->CurrFileHandle, CompressedHandle->CompBuffer, compSize)) {
                    __leave;
                }
                CompressedHandle->CurrFileSize += compSize;
            }
            fileSize -= bytesRead;
        }
        CompressedHandle->FilesStored ++;

        result = TRUE;
    }
    __finally {
        PushError ();
        if (unicodeName) {
            FreeConvertedStr (unicodeName);
            unicodeName = NULL;
        }
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (!result) {
            // let's restore the state of the compress handle
            if (savedIndex == CompressedHandle->CurrFileIndex) {
                if (savedSize.QuadPart != CompressedHandle->CurrFileSize) {
                    SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                    SetEndOfFile (CompressedHandle->CurrFileHandle);
                    CompressedHandle->CurrFileSize = savedSize.QuadPart;
                }
            } else {
                CompressedHandle->CurrFileIndex = savedIndex - 1;
                pPrepareNextFileA (CompressedHandle, TRUE);
                SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                SetEndOfFile (CompressedHandle->CurrFileHandle);
                CompressedHandle->CurrFileSize = savedSize.QuadPart;
                pDeleteNextFilesA (CompressedHandle, savedIndex);
            }
        }
        PopError ();
    }

    return result;
}

BOOL
CompressAddFileToHandleW (
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName,
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    LONGLONG fileSize;
    DWORD bytesRead;
    DWORD bytesWritten;
    DWORD bytesComp;
    DWORD bytesUncomp;
    DWORD signature = COMPRESS_NEWFILE;
    DWORD fileNameSize;
    DWORD headerSize;
    USHORT compType = 0;
    USHORT compSize = 0;
    UINT savedIndex = 0;
    LARGE_INTEGER savedSize;
    BOOL result = FALSE;

    __try {

        // save the state of the compress handle
        savedIndex = CompressedHandle->CurrFileIndex;
        savedSize.QuadPart = CompressedHandle->CurrFileSize;

        fileSize = BfGetFileSizeW (FileName);
        fileHandle = BfOpenReadFileW (FileName);
        if ((fileHandle == NULL) ||
            (fileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }

        fileNameSize = SizeOfStringW (StoredName);
        headerSize = sizeof (DWORD) + sizeof (LONGLONG) + sizeof (DWORD) + fileNameSize;

        if (CompressedHandle->CurrFileSize + headerSize > CompressedHandle->MaxFileSize) {
            if (!pPrepareNextFileW (CompressedHandle, FALSE)) {
                __leave;
            }
        }

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileSize), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileNameSize), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(StoredName), fileNameSize)) {
            __leave;
        }
        CompressedHandle->CurrFileSize += fileNameSize;

        while (fileSize) {

            ZeroMemory (CompressedHandle->ReadBuffer, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
            ZeroMemory (CompressedHandle->CompBuffer, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));

            if (!ReadFile (fileHandle, CompressedHandle->ReadBuffer + 2 * sizeof (USHORT), COMPRESS_BUFFER_SIZE, &bytesRead, NULL)) {
                __leave;
            }
            if (bytesRead == 0)
            {
                // Somehow the file points is beyond the end of the file. Probably file in use.
                SetLastError(ERROR_SHARING_VIOLATION);
                __leave;
            }

            bytesComp = CompressData (
                            CompressMrci1,
                            CompressedHandle->ReadBuffer + 2 * sizeof (USHORT),
                            bytesRead,
                            CompressedHandle->CompBuffer + 2 * sizeof (USHORT),
                            COMPRESS_BUFFER_SIZE
                            );

            if (bytesComp < bytesRead) {
                bytesUncomp = DecompressData (
                                CompressMrci1,
                                CompressedHandle->CompBuffer + 2 * sizeof (USHORT),
                                bytesComp,
                                CompressedHandle->ExtraBuffer,
                                COMPRESS_BUFFER_SIZE
                                );
                if (bytesUncomp != bytesRead) {
                    bytesComp = COMPRESS_BUFFER_SIZE;
                } else {
                    if (!TestBuffer (CompressedHandle->ReadBuffer + 2 * sizeof (USHORT), CompressedHandle->ExtraBuffer, bytesRead)) {
                        bytesComp = COMPRESS_BUFFER_SIZE;
                    }
                }
            }

            if (bytesComp >= bytesRead) {
                compType = CompressNone;
                compSize = (USHORT)bytesRead;
                CopyMemory (CompressedHandle->ReadBuffer, &compType, sizeof (USHORT));
                CopyMemory (CompressedHandle->ReadBuffer + sizeof (USHORT), &compSize, sizeof (USHORT));

                compSize += (2 * sizeof (USHORT));

                if (CompressedHandle->CurrFileSize + compSize > CompressedHandle->MaxFileSize) {
                    if (!pPrepareNextFileW (CompressedHandle, FALSE)) {
                        __leave;
                    }
                }

                if (!BfWriteFile (CompressedHandle->CurrFileHandle, CompressedHandle->ReadBuffer, compSize)) {
                    __leave;
                }
                CompressedHandle->CurrFileSize += compSize;
            } else {
                compType = CompressMrci1;
                compSize = (USHORT)bytesComp;
                CopyMemory (CompressedHandle->CompBuffer, &compType, sizeof (USHORT));
                CopyMemory (CompressedHandle->CompBuffer + sizeof (USHORT), &compSize, sizeof (USHORT));

                compSize += (2 * sizeof (USHORT));

                if (CompressedHandle->CurrFileSize + compSize > CompressedHandle->MaxFileSize) {
                    if (!pPrepareNextFileW (CompressedHandle, FALSE)) {
                        __leave;
                    }
                }

                if (!BfWriteFile (CompressedHandle->CurrFileHandle, CompressedHandle->CompBuffer, compSize)) {
                    __leave;
                }
                CompressedHandle->CurrFileSize += compSize;
            }
            fileSize -= bytesRead;
        }
        CompressedHandle->FilesStored ++;

        result = TRUE;
    }
    __finally {
        PushError ();
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (!result) {
            // let's restore the state of the compress handle
            if (savedIndex == CompressedHandle->CurrFileIndex) {
                if (savedSize.QuadPart != CompressedHandle->CurrFileSize) {
                    SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                    SetEndOfFile (CompressedHandle->CurrFileHandle);
                    CompressedHandle->CurrFileSize = savedSize.QuadPart;
                }
            } else {
                CompressedHandle->CurrFileIndex = savedIndex - 1;
                pPrepareNextFileW (CompressedHandle, TRUE);
                SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                SetEndOfFile (CompressedHandle->CurrFileHandle);
                CompressedHandle->CurrFileSize = savedSize.QuadPart;
                pDeleteNextFilesW (CompressedHandle, savedIndex);
            }
        }
        PopError ();
    }

    return result;
}

BOOL
CompressFlushAndCloseHandleA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    )
{
    CHAR currFile [1024];
    PCSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    BOOL result = FALSE;

    __try {

        if ((CompressedHandle) &&
            (CompressedHandle->CurrFileHandle) &&
            (CompressedHandle->CurrFileHandle != INVALID_HANDLE_VALUE)
            ) {
            result = CloseHandle (CompressedHandle->CurrFileHandle);
            CompressedHandle->CurrFileHandle = NULL;
            if (result) {
                // write the total number of files compressed into the first file
                result = FALSE;
                wsprintfA (currFile, CompressedHandle->MainFilePattern, CompressedHandle->FirstFileIndex);
                currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
                CompressedHandle->CurrFileHandle = BfOpenFileA (currFullPath);
                if ((CompressedHandle->CurrFileHandle == NULL) ||
                    (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
                    ) {
                    __leave;
                }
                FreePathStringA (currFullPath);
                currFullPath = NULL;

                // write again the signature
                if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    __leave;
                }

                // write number of files compressed
                if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
                    __leave;
                }

                result = CloseHandle (CompressedHandle->CurrFileHandle);
                CompressedHandle->CurrFileHandle = NULL;
            }
        }
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        CompressCleanupHandleA (CompressedHandle);
        PopError ();
    }

    return result;
}

BOOL
CompressFlushAndCloseHandleW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    )
{
    WCHAR currFile [1024];
    PCWSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    BOOL result = FALSE;

    __try {

        if ((CompressedHandle) &&
            (CompressedHandle->CurrFileHandle) &&
            (CompressedHandle->CurrFileHandle != INVALID_HANDLE_VALUE)
            ) {
            result = CloseHandle (CompressedHandle->CurrFileHandle);
            CompressedHandle->CurrFileHandle = NULL;
            if (result) {
                // write the total number of files compressed into the first file
                result = FALSE;
                wsprintfW (currFile, CompressedHandle->MainFilePattern, CompressedHandle->FirstFileIndex);
                currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
                CompressedHandle->CurrFileHandle = BfOpenFileW (currFullPath);
                if ((CompressedHandle->CurrFileHandle == NULL) ||
                    (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
                    ) {
                    __leave;
                }
                FreePathStringW (currFullPath);
                currFullPath = NULL;

                // write again the signature
                if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    __leave;
                }

                // write number of files compressed
                if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
                    __leave;
                }

                result = CloseHandle (CompressedHandle->CurrFileHandle);
                CompressedHandle->CurrFileHandle = NULL;
            }
        }
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        CompressCleanupHandleW (CompressedHandle);
        PopError ();
    }

    return result;
}

BOOL
CompressOpenHandleA (
    IN      PCSTR StorePath,
    IN      PCSTR MainFilePattern,
    IN      UINT StartIndex,
    OUT     PCOMPRESS_HANDLEA CompressedHandle
    )
{
    CHAR currFile [1024];
    PCSTR currFullPath = NULL;
    DWORD signature = 0;
    BOOL result = FALSE;

    __try {
        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEA));
        if (StartIndex == 0) {
            CompressedHandle->CurrFileIndex = 1;
        } else {
            CompressedHandle->CurrFileIndex = StartIndex;
        }
        CompressedHandle->FirstFileIndex = CompressedHandle->CurrFileIndex;
        CompressedHandle->StorePath = DuplicatePathStringA (StorePath, 0);
        if (!CompressedHandle->StorePath) {
            __leave;
        }
        CompressedHandle->MainFilePattern = DuplicatePathStringA (MainFilePattern, 0);
        if (!CompressedHandle->MainFilePattern) {
            __leave;
        }
        wsprintfA (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
        CompressedHandle->CurrFileHandle = BfOpenReadFileA (currFullPath);
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringA (currFullPath);
        currFullPath = NULL;

        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (signature != COMPRESS_SIG) {
            SetLastError (ERROR_INVALID_DATA);
            __leave;
        }

        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        CompressedHandle->ReadBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ReadBuffer) {
            __leave;
        }

        CompressedHandle->CompBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->CompBuffer) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        if (!result) {
            CompressCleanupHandleA (CompressedHandle);
        }
        PopError ();
    }
    return result;
}

BOOL
CompressOpenHandleW (
    IN      PCWSTR StorePath,
    IN      PCWSTR MainFilePattern,
    IN      UINT StartIndex,
    OUT     PCOMPRESS_HANDLEW CompressedHandle
    )
{
    WCHAR currFile [1024];
    PCWSTR currFullPath = NULL;
    DWORD signature = 0;
    BOOL result = FALSE;

    __try {
        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEW));
        if (StartIndex == 0) {
            CompressedHandle->CurrFileIndex = 1;
        } else {
            CompressedHandle->CurrFileIndex = StartIndex;
        }
        CompressedHandle->FirstFileIndex = CompressedHandle->CurrFileIndex;
        CompressedHandle->StorePath = DuplicatePathStringW (StorePath, 0);
        if (!CompressedHandle->StorePath) {
            __leave;
        }
        CompressedHandle->MainFilePattern = DuplicatePathStringW (MainFilePattern, 0);
        if (!CompressedHandle->MainFilePattern) {
            __leave;
        }
        wsprintfW (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
        CompressedHandle->CurrFileHandle = BfOpenReadFileW (currFullPath);
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringW (currFullPath);
        currFullPath = NULL;

        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (signature != COMPRESS_SIG) {
            SetLastError (ERROR_INVALID_DATA);
            __leave;
        }

        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        CompressedHandle->ReadBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ReadBuffer) {
            __leave;
        }

        CompressedHandle->CompBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->CompBuffer) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        if (!result) {
            CompressCleanupHandleW (CompressedHandle);
        }
        PopError ();
    }
    return result;
}

BOOL
CompressExtractAllFilesA (
    IN      PCSTR ExtractPath,
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle,
    IN      PCOMPRESSNOTIFICATIONA CompressNotification OPTIONAL
    )
{
    DWORD signature;
    LONGLONG fileSize;
    LONGLONG fileSizeRead;
    DWORD fileNameSize;
    PCWSTR storedName = NULL;
    PCSTR storedNameA = NULL;
    PCSTR extractPath = NULL;
    PCSTR newFileName = NULL;
    BOOL extractFile = TRUE;
    HANDLE extractHandle = NULL;
    USHORT compType = 0;
    USHORT compSize = 0;
    DWORD bytesComp;
    LARGE_INTEGER savedSize;
    BOOL result = FALSE;

    __try {

        for (;;) {

            // read the header for this file

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                // It is possible that we continue onto the next file, let's try that.
                if (!pPrepareNextFileA (CompressedHandle, TRUE)) {
                    result = TRUE;
                    __leave;
                }
                if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    __leave;
                }
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);
            if (signature != COMPRESS_NEWFILE) {
                SetLastError (ERROR_INVALID_DATA);
                __leave;
            }

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileSize), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);
            fileSizeRead = 0;

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileNameSize), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            storedName = MemAlloc (g_hHeap, 0, fileNameSize);

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(storedName), fileNameSize)) {
                __leave;
            }
            CompressedHandle->CurrFileSize += fileNameSize;

            storedNameA = ConvertWtoA (storedName);
            if (!storedNameA) {
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            extractPath = JoinPathsA (ExtractPath, storedNameA);
            if (!extractPath) {
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            extractFile = TRUE;
            newFileName = NULL;
            if (CompressNotification) {
                if (!CompressNotification (extractPath, fileSize, &extractFile, &newFileName)) {
                    __leave;
                }
            }

            if (extractFile) {
                if (newFileName) {
                    // let's make sure that the directory exists
                    BfCreateDirectoryExA (newFileName, FALSE);
                }
                extractHandle = BfCreateFileA (newFileName?newFileName:extractPath);
                if ((extractHandle == NULL) ||
                    (extractHandle == INVALID_HANDLE_VALUE)
                    ) {
                    __leave;
                }
            } else {
                extractHandle = NULL;
            }

            if (newFileName) {
                FreePathStringA (newFileName);
                newFileName = NULL;
            }

            FreePathStringA (extractPath);
            extractPath = NULL;

            MemFree (g_hHeap, 0, storedName);
            storedName = NULL;

            FreeConvertedStr (storedNameA);
            storedNameA = NULL;

            if (fileSize > 0) {
                if (!extractFile && g_ErrorMode) {
                    for (;;) {
                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                            // It is possible that we continue onto the next file, let's try that.
                            if (!pPrepareNextFileA (CompressedHandle, TRUE)) {
                                // we might be at the end of the compressed file, there are no other files here
                                result = TRUE;
                                __leave;
                            }
                            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                                __leave;
                            }
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compSize), sizeof (USHORT))) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        // let's try to see if we just read a new file signature
                        *((PUSHORT)(&signature) + 0) = compType;
                        *((PUSHORT)(&signature) + 1) = compSize;
                        if (signature == COMPRESS_NEWFILE) {
                            // this is a new file
                            CompressedHandle->CurrFileSize -= sizeof (USHORT);
                            CompressedHandle->CurrFileSize -= sizeof (USHORT);
                            // rewind the file current pointer;
                            savedSize.QuadPart = CompressedHandle->CurrFileSize;
                            SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                            // we are done with the current file
                            break;
                        } else {
                            // Let's advance the file pointer
                            if (SetFilePointer (CompressedHandle->CurrFileHandle, compSize, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER) {
                                __leave;
                            }
                            CompressedHandle->CurrFileSize += compSize;
                        }
                    }
                } else {
                    for (;;) {
                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                            // It is possible that we continue onto the next file, let's try that.
                            if (!pPrepareNextFileA (CompressedHandle, TRUE)) {
                                __leave;
                            }
                            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                                __leave;
                            }
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compSize), sizeof (USHORT))) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, CompressedHandle->CompBuffer, compSize)) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += compSize;

                        if (compType == CompressNone) {
                            if (extractFile) {
                                if (!BfWriteFile (extractHandle, CompressedHandle->CompBuffer, compSize)) {
                                    __leave;
                                }
                            }
                            fileSizeRead += compSize;
                        } else {
                            bytesComp = DecompressData (
                                            compType,
                                            CompressedHandle->CompBuffer,
                                            compSize,
                                            CompressedHandle->ReadBuffer,
                                            COMPRESS_BUFFER_SIZE
                                            );
                            if (bytesComp > COMPRESS_BUFFER_SIZE) {
                                SetLastError (ERROR_INVALID_DATA);
                                __leave;
                            }
                            if (extractFile) {
                                if (!BfWriteFile (extractHandle, CompressedHandle->ReadBuffer, bytesComp)) {
                                    __leave;
                                }
                            }
                            fileSizeRead += bytesComp;
                        }

                        if (fileSizeRead == fileSize) {
                            // this file is done, let's go to the next one
                            break;
                        }
                    }
                }
            }

            if (extractHandle) {
                CloseHandle (extractHandle);
                extractHandle = NULL;
            }
        }
    }
    __finally {
        if (storedName != NULL) {
            MemFree (g_hHeap, 0, storedName);
            storedName = NULL;
        }
        if (storedNameA != NULL) {
            FreeConvertedStr (storedNameA);
            storedNameA = NULL;
        }
        if (newFileName != NULL) {
            FreePathStringA (newFileName);
            newFileName = NULL;
        }
        if (extractPath != NULL) {
            FreePathStringA (extractPath);
            extractPath = NULL;
        }
        if ((extractHandle != NULL) &&
            (extractHandle != INVALID_HANDLE_VALUE)
            ) {
            CloseHandle (extractHandle);
            extractHandle = NULL;
        }
    }

    return result;
}

BOOL
CompressExtractAllFilesW (
    IN      PCWSTR ExtractPath,
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle,
    IN      PCOMPRESSNOTIFICATIONW CompressNotification OPTIONAL
    )
{
    DWORD signature;
    LONGLONG fileSize;
    LONGLONG fileSizeRead;
    DWORD fileNameSize;
    PCWSTR storedName = NULL;
    PCWSTR extractPath = NULL;
    PCWSTR newFileName = NULL;
    BOOL extractFile = TRUE;
    HANDLE extractHandle = NULL;
    USHORT compType = 0;
    USHORT compSize = 0;
    DWORD bytesComp;
    LARGE_INTEGER savedSize;
    BOOL result = FALSE;

    __try {

        for (;;) {

            // read the header for this file

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                // It is possible that we continue onto the next file, let's try that.
                if (!pPrepareNextFileW (CompressedHandle, TRUE)) {
                    result = TRUE;
                    __leave;
                }
                if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    __leave;
                }
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);
            if (signature != COMPRESS_NEWFILE) {
                SetLastError (ERROR_INVALID_DATA);
                __leave;
            }

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileSize), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);
            fileSizeRead = 0;

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileNameSize), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            storedName = MemAlloc (g_hHeap, 0, fileNameSize);

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(storedName), fileNameSize)) {
                __leave;
            }
            CompressedHandle->CurrFileSize += fileNameSize;

            extractPath = JoinPathsW (ExtractPath, storedName);
            if (!extractPath) {
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            extractFile = TRUE;
            newFileName = NULL;
            if (CompressNotification) {
                if (!CompressNotification (extractPath, fileSize, &extractFile, &newFileName)) {
                    __leave;
                }
            }

            if (extractFile) {
                if (newFileName) {
                    // let's make sure that the directory exists
                    BfCreateDirectoryExW (newFileName, FALSE);
                }
                extractHandle = BfCreateFileW (newFileName?newFileName:extractPath);
                if ((extractHandle == NULL) ||
                    (extractHandle == INVALID_HANDLE_VALUE)
                    ) {
                    __leave;
                }
            } else {
                extractHandle = NULL;
            }

            if (newFileName) {
                FreePathStringW (newFileName);
                newFileName = NULL;
            }

            FreePathStringW (extractPath);
            extractPath = NULL;

            MemFree (g_hHeap, 0, storedName);
            storedName = NULL;

            if (fileSize) {
                if (!extractFile && g_ErrorMode) {
                    for (;;) {
                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                            // It is possible that we continue onto the next file, let's try that.
                            if (!pPrepareNextFileW (CompressedHandle, TRUE)) {
                                // we might be at the end of the compressed file, there are no other files here
                                result = TRUE;
                                __leave;
                            }
                            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                                __leave;
                            }
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compSize), sizeof (USHORT))) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        // let's try to see if we just read a new file signature
                        *((PUSHORT)(&signature + 0)) = compType;
                        *((PUSHORT)(&signature + 1)) = compSize;
                        if (signature == COMPRESS_NEWFILE) {
                            // this is a new file
                            CompressedHandle->CurrFileSize -= sizeof (USHORT);
                            CompressedHandle->CurrFileSize -= sizeof (USHORT);
                            // rewind the file current pointer;
                            savedSize.QuadPart = CompressedHandle->CurrFileSize;
                            SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                            // we are done with the current file
                            break;
                        } else {
                            // Let's advance the file pointer
                            if (SetFilePointer (CompressedHandle->CurrFileHandle, compSize, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER) {
                                __leave;
                            }
                            CompressedHandle->CurrFileSize += compSize;
                        }
                    }
                } else {
                    for (;;) {
                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                            // It is possible that we continue onto the next file, let's try that.
                            if (!pPrepareNextFileW (CompressedHandle, TRUE)) {
                                __leave;
                            }
                            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                                __leave;
                            }
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compSize), sizeof (USHORT))) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, CompressedHandle->CompBuffer, compSize)) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += compSize;

                        if (compType == CompressNone) {
                            if (extractFile) {
                                if (!BfWriteFile (extractHandle, CompressedHandle->CompBuffer, compSize)) {
                                    __leave;
                                }
                            }
                            fileSizeRead += compSize;
                        } else {
                            bytesComp = DecompressData (
                                            compType,
                                            CompressedHandle->CompBuffer,
                                            compSize,
                                            CompressedHandle->ReadBuffer,
                                            COMPRESS_BUFFER_SIZE
                                            );
                            if (bytesComp > COMPRESS_BUFFER_SIZE) {
                                SetLastError (ERROR_INVALID_DATA);
                                __leave;
                            }
                            if (extractFile) {
                                if (!BfWriteFile (extractHandle, CompressedHandle->ReadBuffer, bytesComp)) {
                                    __leave;
                                }
                            }
                            fileSizeRead += bytesComp;
                        }

                        if (fileSizeRead == fileSize) {
                            // this file is done, let's go to the next one
                            break;
                        }
                    }
                }
            }

            if (extractHandle) {
                CloseHandle (extractHandle);
                extractHandle = NULL;
            }
        }
    }
    __finally {
        if (storedName != NULL) {
            MemFree (g_hHeap, 0, storedName);
            storedName = NULL;
        }
        if (newFileName != NULL) {
            FreePathStringW (newFileName);
            newFileName = NULL;
        }
        if (extractPath != NULL) {
            FreePathStringW (extractPath);
            extractPath = NULL;
        }
        if ((extractHandle != NULL) &&
            (extractHandle != INVALID_HANDLE_VALUE)
            ) {
            CloseHandle (extractHandle);
            extractHandle = NULL;
        }
    }

    return result;
}

BOOL
CompressSetErrorMode (
    IN      BOOL ErrorMode
    )
{
    BOOL oldErrorMode = g_ErrorMode;

    g_ErrorMode = ErrorMode;
    return oldErrorMode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\cablib\cablib.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cablib.c

Abstract:

    Implements wrappers for cabinet APIs

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include <cablib.h>
#include <fci.h>
#include <fdi.h>
#include <fcntl.h>
#include <crt\sys\stat.h>

//
// Includes
//

// None

#define DBG_CABLIB  "CabLib"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCSTR CabPath;
    PCSTR CabFileFormat;
    PCSTR CabDiskFormat;
    PCABGETCABINETNAMESA CabGetCabinetNames;
    PCABGETTEMPFILEA CabGetTempFile;
    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;
} FCI_CAB_HANDLEA, *PFCI_CAB_HANDLEA;

typedef struct {
    PCWSTR CabPath;
    PCWSTR CabFileFormat;
    PCWSTR CabDiskFormat;
    PCABGETCABINETNAMESW CabGetCabinetNames;
    PCABGETTEMPFILEW CabGetTempFile;
    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;
} FCI_CAB_HANDLEW, *PFCI_CAB_HANDLEW;

typedef struct {
    PCSTR CabPath;
    PCSTR CabFile;
    HFDI FdiHandle;
    ERF FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
} FDI_CAB_HANDLEA, *PFDI_CAB_HANDLEA;

typedef struct {
    PCWSTR CabPath;
    PCWSTR CabFile;
    HFDI FdiHandle;
    ERF FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
} FDI_CAB_HANDLEW, *PFDI_CAB_HANDLEW;

typedef struct {
    PCSTR ExtractPath;
    PCABNOTIFICATIONA CabNotification;
} CAB_DATAA, *PCAB_DATAA;

typedef struct {
    PCWSTR ExtractPath;
    PCABNOTIFICATIONW CabNotification;
} CAB_DATAW, *PCAB_DATAW;

//
// Globals
//

HASHTABLE g_UnicodeTable = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

INT
DIAMONDAPI
pCabFilePlacedA (
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) Context;
    if (!cabHandle) {
        return 0;
    }

    cabHandle->FileCount++;
    cabHandle->FileSize += FileSize;

    return 0;
}


INT
DIAMONDAPI
pCabFilePlacedW (
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;

    cabHandle = (PFCI_CAB_HANDLEW) Context;
    if (!cabHandle) {
        return 0;
    }

    cabHandle->FileCount++;
    cabHandle->FileSize += FileSize;

    return 0;
}


PVOID
DIAMONDAPI
pCabAlloc (
    IN      ULONG Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}

VOID
DIAMONDAPI
pCabFree (
    IN      PVOID Memory
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    if (Memory) {
        MemFree (g_hHeap, 0, Memory);
    }
}

INT_PTR
DIAMONDAPI
pCabOpenA (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    HANDLE fileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT ((oFlag == (_O_CREAT | _O_TRUNC | _O_BINARY | _O_RDWR)) || (oFlag == (_O_CREAT | _O_EXCL | _O_BINARY | _O_RDWR)));
    MYASSERT (pMode == (_S_IREAD | _S_IWRITE));

    fileHandle = CreateFileA (
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return (INT_PTR)fileHandle;
}

INT_PTR
DIAMONDAPI
pCabOpen1A (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    HANDLE fileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT (oFlag == _O_BINARY);

    fileHandle = CreateFileA (
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return -1;
    }
    return (INT_PTR)fileHandle;
}

INT_PTR
DIAMONDAPI
pCabOpen1W (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCSTR fileName = NULL;
    PSTR fileNamePtr = NULL;
    PCWSTR fileNameW = NULL;
    PCWSTR fullFileName = NULL;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT (oFlag == _O_BINARY);

    if (g_UnicodeTable) {
        fileName = DuplicatePathStringA (FileName, 0);
        if (fileName) {
            fileNamePtr = (PSTR)GetFileNameFromPathA (fileName);
            if (fileNamePtr) {
                *fileNamePtr = 0;
                if ((HtFindStringAndDataA (g_UnicodeTable, fileName, &cabHandle) != NULL) &&
                    (cabHandle != NULL)
                    ) {
                    fileNamePtr = (PSTR)GetFileNameFromPathA (FileName);
                    if (fileNamePtr) {
                        fileNameW = ConvertAtoW (fileNamePtr);
                        if (fileNameW) {
                            fullFileName = JoinPathsW (cabHandle->CabPath, fileNameW);
                            if (fullFileName) {
                                fileHandle = CreateFileW (
                                                fullFileName,
                                                GENERIC_READ,
                                                FILE_SHARE_READ,
                                                NULL,
                                                OPEN_EXISTING,
                                                FILE_ATTRIBUTE_ARCHIVE,
                                                NULL
                                                );
                                FreePathStringW (fullFileName);
                                fullFileName = NULL;
                            }
                            FreeConvertedStr (fileNameW);
                            fileNameW = NULL;
                        }
                    }
                }
            }
            FreePathStringA (fileName);
            fileName = NULL;
        }
    }

    if (fileHandle == INVALID_HANDLE_VALUE) {
        fileHandle = CreateFileA (
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_ARCHIVE,
                        NULL
                        );
    }

    if (fileHandle == INVALID_HANDLE_VALUE) {
        return -1;
    }

    return (INT_PTR)fileHandle;
}

UINT
DIAMONDAPI
pCabRead (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    UINT bytesRead;

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        *Error = GetLastError ();
        return ((UINT)(-1));
    }
    *Error = 0;
    return bytesRead;
}

UINT
DIAMONDAPI
pCabRead1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    UINT bytesRead;

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return bytesRead;
}

UINT
DIAMONDAPI
pCabWrite (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;

    result = BfWriteFile ((HANDLE)FileHandle, Buffer, Size);
    if (!result) {
        *Error = GetLastError ();
        return ((UINT)(-1));
    }
    *Error = 0;
    return Size;
}

UINT
DIAMONDAPI
pCabWrite1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;

    result = BfWriteFile ((HANDLE)FileHandle, Buffer, Size);
    if (!result) {
        return ((UINT)(-1));
    }
    return Size;
}

INT
DIAMONDAPI
pCabClose (
    IN      INT_PTR FileHandle,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    CloseHandle ((HANDLE)FileHandle);
    *Error = 0;
    return 0;
}

INT
DIAMONDAPI
pCabClose1 (
    IN      INT_PTR FileHandle
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    CloseHandle ((HANDLE)FileHandle);
    return 0;
}

LONG
DIAMONDAPI
pCabSeek (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return ((LONG)(result));
}

LONG
DIAMONDAPI
pCabSeek1 (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        return -1;
    }
    return ((LONG)(result));
}

INT
DIAMONDAPI
pCabDeleteA (
    IN      PSTR FileName,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    if (!DeleteFileA (FileName)) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return 0;
}

BOOL
DIAMONDAPI
pCabGetTempFileA (
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) Context;

    if (cabHandle && cabHandle->CabGetTempFile) {
        return cabHandle->CabGetTempFile (FileName, FileNameLen);
    }

    return BfGetTempFileNameA (FileName, FileNameLen);
}

BOOL
DIAMONDAPI
pCabGetTempFileW (
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR tempFileNameW [MAX_PATH];
    PCSTR tempFileNameA = NULL;

    cabHandle = (PFCI_CAB_HANDLEW) Context;

    if (cabHandle && cabHandle->CabGetTempFile) {
        if (cabHandle->CabGetTempFile (tempFileNameW, MAX_PATH)) {
            tempFileNameA = ConvertWtoA (tempFileNameW);
            if (tempFileNameA) {
                StringCopyTcharCountA (FileName, tempFileNameA, FileNameLen);
                FreeConvertedStr (tempFileNameA);
                return TRUE;
            }
        }
        return FALSE;
    }

    return BfGetTempFileNameA (FileName, FileNameLen);
}

BOOL
DIAMONDAPI
pCabGetNextCabinetA (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    CHAR cabFile [1024];
    CHAR cabDisk [1024];

    cabHandle = (PFCI_CAB_HANDLEA) Context;
    if (!cabHandle) {
        return FALSE;
    }
    if (cabHandle->CabGetCabinetNames) {
        return cabHandle->CabGetCabinetNames (
                            FciCabParams->szCabPath,
                            CB_MAX_CAB_PATH,
                            FciCabParams->szCab,
                            CB_MAX_CABINET_NAME,
                            FciCabParams->szDisk,
                            CB_MAX_DISK_NAME,
                            FciCabParams->iCab,
                            &FciCabParams->iDisk
                            );
    } else {
        FciCabParams->iDisk = FciCabParams->iCab;
        if (cabHandle->CabFileFormat) {
            wsprintfA (cabFile, cabHandle->CabFileFormat, FciCabParams->iCab);
            StringCopyByteCountA (FciCabParams->szCab, cabFile, CB_MAX_CABINET_NAME * sizeof (CHAR));
        }
        if (cabHandle->CabDiskFormat) {
            wsprintfA (cabDisk, cabHandle->CabDiskFormat, FciCabParams->iDisk);
            StringCopyByteCountA (FciCabParams->szDisk, cabDisk, CB_MAX_DISK_NAME * sizeof (CHAR));
        }
    }
    return TRUE;
}

BOOL
DIAMONDAPI
pCabGetNextCabinetW (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabPath [1024];
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];
    BOOL result;

    cabHandle = (PFCI_CAB_HANDLEW) Context;
    if (!cabHandle) {
        return FALSE;
    }
    if (cabHandle->CabGetCabinetNames) {
        result = cabHandle->CabGetCabinetNames (
                            cabPath,
                            CB_MAX_CAB_PATH,
                            cabFile,
                            CB_MAX_CABINET_NAME,
                            cabDisk,
                            CB_MAX_DISK_NAME,
                            FciCabParams->iCab,
                            &FciCabParams->iDisk
                            );
        if (result) {
            KnownSizeUnicodeToDbcsN (FciCabParams->szCabPath, cabPath, min (CB_MAX_CAB_PATH, CharCountW (cabPath)));
            KnownSizeUnicodeToDbcsN (FciCabParams->szCab, cabFile, min (CB_MAX_CABINET_NAME, CharCountW (cabFile)));
            KnownSizeUnicodeToDbcsN (FciCabParams->szDisk, cabDisk, min (CB_MAX_DISK_NAME, CharCountW (cabDisk)));
            return TRUE;
        }
        return FALSE;
    } else {
        FciCabParams->iDisk = FciCabParams->iCab;
        if (cabHandle->CabFileFormat) {
            wsprintfW (cabFile, cabHandle->CabFileFormat, FciCabParams->iCab);
            KnownSizeUnicodeToDbcsN (FciCabParams->szCab, cabFile, min (CB_MAX_CABINET_NAME, CharCountW (cabFile)));
        }
        if (cabHandle->CabDiskFormat) {
            wsprintfW (cabDisk, cabHandle->CabDiskFormat, FciCabParams->iDisk);
            KnownSizeUnicodeToDbcsN (FciCabParams->szDisk, cabDisk, min (CB_MAX_DISK_NAME, CharCountW (cabDisk)));
        }
    }
    return TRUE;
}

LONG
DIAMONDAPI
pCabStatusA (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    if (StatusType == statusCabinet) {

        cabHandle = (PFCI_CAB_HANDLEA) Context;
        if (!cabHandle) {
            return 0;
        }

        cabHandle->CabCount++;
        cabHandle->CompressedSize += (LONGLONG) Size2;
    }

    return 0;
}

LONG
DIAMONDAPI
pCabStatusW (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;

    if (StatusType == statusCabinet) {

        cabHandle = (PFCI_CAB_HANDLEW) Context;
        if (!cabHandle) {
            return 0;
        }

        cabHandle->CabCount++;
        cabHandle->CompressedSize += (LONGLONG) Size2;
    }

    return 0;
}

INT_PTR
DIAMONDAPI
pCabGetOpenInfoA (
    IN      PSTR FileName,
    OUT     USHORT *Date,
    OUT     USHORT *Time,
    OUT     USHORT *Attributes,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    WIN32_FIND_DATAA findData;
    FILETIME fileTime;
    HANDLE fileHandle;

    if (DoesFileExistExA (FileName, &findData)) {

        FileTimeToLocalFileTime (&findData.ftLastWriteTime, &fileTime);
        FileTimeToDosDateTime (&fileTime, Date, Time);

        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *Attributes = (USHORT) (findData.dwFileAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));

        fileHandle = CreateFileA (
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (fileHandle == INVALID_HANDLE_VALUE) {
            *Error = GetLastError ();
            return -1;
        }
        *Error = 0;
        return (INT_PTR)fileHandle;
    } else {
        *Error = GetLastError ();
        return -1;
    }
}

INT_PTR
DIAMONDAPI
pCabNotificationA (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PCSTR destFile = NULL;
    HANDLE destHandle = NULL;
    DWORD attributes;
    FILETIME localFileTime;
    FILETIME fileTime;
    PCAB_DATAA cabData;

    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        return 0;
    case fdintCOPY_FILE:        // File to be copied
        cabData = (PCAB_DATAA)FdiNotification->pv;
        destFile = JoinPathsA (cabData->ExtractPath, FdiNotification->psz1);
        if (cabData->CabNotification) {
            if (cabData->CabNotification (destFile)) {
                destHandle = BfCreateFileA (destFile);
            }
        } else {
            destHandle = BfCreateFileA (destFile);
        }
        FreePathStringA (destFile);
        return (INT_PTR)destHandle;
    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        cabData = (PCAB_DATAA)FdiNotification->pv;
        if (DosDateTimeToFileTime (FdiNotification->date, FdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)FdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }
        destFile = JoinPathsA (cabData->ExtractPath, FdiNotification->psz1);
        CloseHandle ((HANDLE)FdiNotification->hf);
        attributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
        SetFileAttributesA (destFile, attributes);
        FreePathStringA (destFile);
        return TRUE;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        return 0;
    case fdintENUMERATE:        // Enumeration status
        return 0;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        // sometimes, in a corrupted cabinet file, the cabinet APIs can ask
        // for the next cabinet but nothing more exists. If we don't fail here
        // in this case, we are going to infinite loop, so do some checking
        if (!FdiNotification) {
            return -1;
        }
        if (FdiNotification->psz1[0] == 0) {
            return -1;
        }
        return 0;
    }
    return 0;
}

INT_PTR
DIAMONDAPI
pCabNotificationW (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PCWSTR destFile = NULL;
    PCWSTR destFileW = NULL;
    HANDLE destHandle = NULL;
    DWORD attributes;
    FILETIME localFileTime;
    FILETIME fileTime;
    PCAB_DATAW cabData;

    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        return 0;
    case fdintCOPY_FILE:        // File to be copied
        cabData = (PCAB_DATAW)FdiNotification->pv;
        destFileW = ConvertAtoW (FdiNotification->psz1);
        if (destFileW) {
            destFile = JoinPathsW (cabData->ExtractPath, destFileW);
            if (destFile) {
                if (cabData->CabNotification) {
                    if (cabData->CabNotification (destFile)) {
                        destHandle = BfCreateFileW (destFile);
                    }
                } else {
                    destHandle = BfCreateFileW (destFile);
                }
                FreePathStringW (destFile);
            }
            FreeConvertedStr (destFileW);
        }
        return (INT_PTR)destHandle;
    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        cabData = (PCAB_DATAW)FdiNotification->pv;
        if (DosDateTimeToFileTime (FdiNotification->date, FdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)FdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }
        destFileW = ConvertAtoW (FdiNotification->psz1);
        if (destFileW) {
            destFile = JoinPathsW (cabData->ExtractPath, destFileW);
            if (destFile) {
                CloseHandle ((HANDLE)FdiNotification->hf);
                attributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
                SetFileAttributesW (destFile, attributes);
                FreePathStringW (destFile);
            }
            FreeConvertedStr (destFileW);
        }
        return TRUE;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        return 0;
    case fdintENUMERATE:        // Enumeration status
        return 0;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        // sometimes, in a corrupted cabinet file, the cabinet APIs can ask
        // for the next cabinet but nothing more exists. If we don't fail here
        // in this case, we are going to infinite loop, so do some checking
        if (!FdiNotification) {
            return -1;
        }
        if (FdiNotification->psz1[0] == 0) {
            return -1;
        }
        return 0;
    }
    return 0;
}

CCABHANDLE
CabCreateCabinetByIndexA (
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      PCABGETTEMPFILEA CabGetTempFile, // OPTIONAL
    IN      LONG MaxFileSize,
    IN      INT InitialIndex
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPath - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    CHAR cabFile [1024];
    CHAR cabDisk [1024];

    if (!CabFileFormat) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    cabHandle = (PFCI_CAB_HANDLEA) MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEA));
    if (CabPath) {
        cabHandle->CabPath = DuplicatePathStringA (CabPath, 0);
    }
    cabHandle->CabFileFormat = DuplicatePathStringA (CabFileFormat, 0);
    if (CabDiskFormat) {
        cabHandle->CabDiskFormat = DuplicatePathStringA (CabDiskFormat, 0);
    }
    cabHandle->CabGetTempFile = CabGetTempFile;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = InitialIndex;
    cabHandle->FciCabParams.iDisk = InitialIndex;
    cabHandle->FciCabParams.setID = 0;
    if (CabPath) {
        StringCopyByteCountA (cabHandle->FciCabParams.szCabPath, CabPath, CB_MAX_CAB_PATH - 1);
        AppendWackA (cabHandle->FciCabParams.szCabPath);
    }
    if (CabDiskFormat) {
        wsprintfA (cabDisk, CabDiskFormat, cabHandle->FciCabParams.iDisk);
        StringCopyByteCountA (cabHandle->FciCabParams.szDisk, cabDisk, CB_MAX_DISK_NAME * sizeof (CHAR));
    }
    wsprintfA (cabFile, CabFileFormat, cabHandle->FciCabParams.iCab);
    StringCopyByteCountA (cabHandle->FciCabParams.szCab, cabFile, CB_MAX_CABINET_NAME * sizeof (CHAR));

    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetByIndexW (
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      PCABGETTEMPFILEW CabGetTempFile, // OPTIONAL
    IN      LONG MaxFileSize,
    IN      INT InitialIndex
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPath - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];

    if (!CabFileFormat) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    cabHandle = (PFCI_CAB_HANDLEW) MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEW));
    if (CabPath) {
        cabHandle->CabPath = DuplicatePathStringW (CabPath, 0);
    }
    cabHandle->CabFileFormat = DuplicatePathStringW (CabFileFormat, 0);
    if (CabDiskFormat) {
        cabHandle->CabDiskFormat = DuplicatePathStringW (CabDiskFormat, 0);
    }
    cabHandle->CabGetTempFile = CabGetTempFile;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = InitialIndex;
    cabHandle->FciCabParams.iDisk = InitialIndex;
    cabHandle->FciCabParams.setID = 0;
    if (CabPath) {
        KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szCabPath, CabPath, min (CB_MAX_CAB_PATH - 1, CharCountW (CabPath)));
        AppendWackA (cabHandle->FciCabParams.szCabPath);
    }
    if (CabDiskFormat) {
        wsprintfW (cabDisk, CabDiskFormat, cabHandle->FciCabParams.iDisk);
        KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szDisk, cabDisk, min (CB_MAX_DISK_NAME, CharCountW (cabDisk)));
    }
    wsprintfW (cabFile, CabFileFormat, cabHandle->FciCabParams.iCab);
    KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szCab, cabFile, min (CB_MAX_CABINET_NAME, CharCountW (cabFile)));

    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedW,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileW,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetExA (
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    if (!CabGetCabinetNames) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    cabHandle = MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEA));
    cabHandle->CabGetCabinetNames = CabGetCabinetNames;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (!CabGetCabinetNames (
            cabHandle->FciCabParams.szCabPath,
            CB_MAX_CAB_PATH,
            cabHandle->FciCabParams.szCab,
            CB_MAX_CABINET_NAME,
            cabHandle->FciCabParams.szDisk,
            CB_MAX_DISK_NAME,
            cabHandle->FciCabParams.iCab,
            &cabHandle->FciCabParams.iDisk
            )) {
        return NULL;
    }
    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetExW (
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabPath [1024];
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];

    if (!CabGetCabinetNames) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    cabHandle = MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEW));
    cabHandle->CabGetCabinetNames = CabGetCabinetNames;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (!CabGetCabinetNames (
            cabPath,
            CB_MAX_CAB_PATH,
            cabFile,
            CB_MAX_CABINET_NAME,
            cabDisk,
            CB_MAX_DISK_NAME,
            cabHandle->FciCabParams.iCab,
            &cabHandle->FciCabParams.iDisk
            )) {
        return NULL;
    }
    KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szCabPath, cabPath, min (CB_MAX_CAB_PATH, CharCountW (cabPath)));
    KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szCab, cabFile, min (CB_MAX_CABINET_NAME, CharCountW (cabFile)));
    KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szDisk, cabDisk, min (CB_MAX_DISK_NAME, CharCountW (cabDisk)));
    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedW,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileW,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

BOOL
CabAddFileToCabinetA (
    IN      CCABHANDLE CabHandle,
    IN      PCSTR FileName,
    IN      PCSTR StoredName
    )

/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileName - Specifies the file to be added.

  StoredName - Specifies the name to be stored in the cabinet file.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }

    return FCIAddFile (
                cabHandle->FciHandle,
                (PSTR)FileName,
                (PSTR)StoredName,
                FALSE,
                pCabGetNextCabinetA,
                pCabStatusA,
                pCabGetOpenInfoA,
                tcompTYPE_MSZIP
                );
}

BOOL
CabAddFileToCabinetW (
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    )

/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileName - Specifies the file to be added.

  StoredName - Specifies the name to be stored in the cabinet file.

  FileCount - Specifies a count of files, receives the updated count
              when cabinet files are created

  FileSize - Specifies the number of bytes used by the file, receives
             the updated size

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    CHAR ansiFileName [1024];
    CHAR ansiStoredName [1024];

    cabHandle = (PFCI_CAB_HANDLEW) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    KnownSizeUnicodeToDbcsN (ansiFileName, FileName, min (CB_MAX_CABINET_NAME, CharCountW (FileName)));
    KnownSizeUnicodeToDbcsN (ansiStoredName, StoredName, min (CB_MAX_CABINET_NAME, CharCountW (StoredName)));

    return FCIAddFile (
                cabHandle->FciHandle,
                ansiFileName,
                ansiStoredName,
                FALSE,
                pCabGetNextCabinetW,
                pCabStatusW,
                pCabGetOpenInfoA,
                tcompTYPE_MSZIP
                );
}

BOOL
CabFlushAndCloseCabinetExA (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )

/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    BOOL result = FALSE;

    cabHandle = (PFCI_CAB_HANDLEA) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    if (FCIFlushCabinet (
            cabHandle->FciHandle,
            FALSE,
            pCabGetNextCabinetA,
            pCabStatusA
            )) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        result = FCIDestroy (cabHandle->FciHandle);

        if (FileCount) {
            *FileCount = cabHandle->FileCount;
        }

        if (FileSize) {
            *FileSize = cabHandle->FileSize;
        }

        if (CabFileCount) {
            *CabFileCount = cabHandle->CabCount;
        }

        if (CabFileSize) {
            *CabFileSize = cabHandle->CompressedSize;
        }

        MemFree (g_hHeap, 0, cabHandle);
    }

    return result;
}

BOOL
CabFlushAndCloseCabinetExW (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )

/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    BOOL result = FALSE;

    cabHandle = (PFCI_CAB_HANDLEW) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    if (FCIFlushCabinet (
            cabHandle->FciHandle,
            FALSE,
            pCabGetNextCabinetW,
            pCabStatusW
            )) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        result = FCIDestroy (cabHandle->FciHandle);

        if (FileCount) {
            *FileCount = cabHandle->FileCount;
        }

        if (FileSize) {
            *FileSize = cabHandle->FileSize;
        }

        if (CabFileCount) {
            *CabFileCount = cabHandle->CabCount;
        }

        if (CabFileSize) {
            *CabFileSize = cabHandle->CompressedSize;
        }

        MemFree (g_hHeap, 0, cabHandle);
    }
    return result;
}

OCABHANDLE
CabOpenCabinetA (
    IN      PCSTR FileName
    )

/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;
    PSTR filePtr;
    HANDLE fileHandle;
    PCSTR fileName;

    cabHandle = (PFDI_CAB_HANDLEA) MemAlloc (g_hHeap, 0, sizeof (FDI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FDI_CAB_HANDLEA));
    cabHandle->FdiHandle = FDICreate (
                                pCabAlloc,
                                pCabFree,
                                pCabOpen1A,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN,
                                &cabHandle->FdiErrorStruct
                                );
    if (!cabHandle->FdiHandle) {
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    fileName = DuplicatePathStringA (FileName, 0);
    fileHandle = BfOpenReadFileA (fileName);
    if (!fileHandle) {
        FreePathStringA (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    if (!FDIIsCabinet (cabHandle->FdiHandle, (INT_PTR)fileHandle, &cabHandle->FdiCabinetInfo)) {
        FreePathStringA (fileName);
        CloseHandle (fileHandle);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    CloseHandle (fileHandle);
    filePtr = (PSTR)GetFileNameFromPathA (fileName);
    if (!filePtr) {
        FreePathStringA (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    cabHandle->CabFile = DuplicatePathStringA (filePtr, 0);
    *filePtr = 0;
    cabHandle->CabPath = DuplicatePathStringA (fileName, 0);
    FreePathStringA (fileName);
    return ((CCABHANDLE)(cabHandle));
}

OCABHANDLE
CabOpenCabinetW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    PWSTR filePtr;
    HANDLE fileHandle;
    PCWSTR fileName;
    PCSTR filePathA = NULL;

    cabHandle = (PFDI_CAB_HANDLEW) MemAlloc (g_hHeap, 0, sizeof (FDI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FDI_CAB_HANDLEW));
    cabHandle->FdiHandle = FDICreate (
                                pCabAlloc,
                                pCabFree,
                                pCabOpen1W,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN,
                                &cabHandle->FdiErrorStruct
                                );
    if (!cabHandle->FdiHandle) {
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    fileName = DuplicatePathStringW (FileName, 0);
    fileHandle = BfOpenReadFileW (fileName);
    if (!fileHandle) {
        FreePathStringW (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    if (!FDIIsCabinet (cabHandle->FdiHandle, (INT_PTR)fileHandle, &cabHandle->FdiCabinetInfo)) {
        FreePathStringW (fileName);
        CloseHandle (fileHandle);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    CloseHandle (fileHandle);
    filePtr = (PWSTR)GetFileNameFromPathW (fileName);
    if (!filePtr) {
        FreePathStringW (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    cabHandle->CabFile = DuplicatePathStringW (filePtr, 0);
    *filePtr = 0;
    cabHandle->CabPath = DuplicatePathStringW (fileName, 0);
    FreePathStringW (fileName);
    if (!g_UnicodeTable) {
        g_UnicodeTable = HtAllocWithDataA (sizeof (PFDI_CAB_HANDLEW));
    }
    if (g_UnicodeTable) {
        filePathA = ConvertWtoA (cabHandle->CabPath);
        if (filePathA) {
            HtAddStringAndDataA (g_UnicodeTable, filePathA, &cabHandle);
            FreeConvertedStr (filePathA);
            filePathA = NULL;
        }
    }
    return ((CCABHANDLE)(cabHandle));
}

BOOL
CabExtractAllFilesExA (
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,
    IN      PCABNOTIFICATIONA CabNotification   OPTIONAL
    )

/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;
    CAB_DATAA cabData;

    cabHandle = (PFDI_CAB_HANDLEA)CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    cabData.ExtractPath = ExtractPath;
    cabData.CabNotification = CabNotification;
    return FDICopy (
                cabHandle->FdiHandle,
                (PSTR)cabHandle->CabFile,
                (PSTR)cabHandle->CabPath,
                0,
                pCabNotificationA,
                NULL,
                (PVOID)(&cabData)
                );
}


BOOL
CabExtractAllFilesExW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,
    IN      PCABNOTIFICATIONW CabNotification   OPTIONAL
    )

/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    CAB_DATAW cabData;
    PCSTR cabFileA = NULL;
    PCSTR cabPathA = NULL;
    BOOL result = FALSE;

    cabHandle = (PFDI_CAB_HANDLEW)CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    cabData.ExtractPath = ExtractPath;
    cabData.CabNotification = CabNotification;
    cabFileA = ConvertWtoA (cabHandle->CabFile);
    cabPathA = ConvertWtoA (cabHandle->CabPath);
    if (cabFileA && cabPathA) {
        result = FDICopy (
                    cabHandle->FdiHandle,
                    (PSTR)cabFileA,
                    (PSTR)cabPathA,
                    0,
                    pCabNotificationW,
                    NULL,
                    (PVOID)(&cabData)
                    );
    }
    if (cabPathA) {
        FreeConvertedStr (cabPathA);
        cabPathA = NULL;
    }
    if (cabFileA) {
        FreeConvertedStr (cabFileA);
        cabFileA = NULL;
    }
    return result;
}

BOOL
CabCloseCabinetA (
    IN      OCABHANDLE CabHandle
    )

/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;

    cabHandle = (PFDI_CAB_HANDLEA) CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    if (FDIDestroy (cabHandle->FdiHandle)) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFile) {
            FreePathStringA (cabHandle->CabFile);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return TRUE;
    }
    return FALSE;
}

BOOL
CabCloseCabinetW (
    IN      OCABHANDLE CabHandle
    )

/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    PCSTR filePathA = NULL;

    cabHandle = (PFDI_CAB_HANDLEW) CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    if (FDIDestroy (cabHandle->FdiHandle)) {
        if (cabHandle->CabPath) {
            if (g_UnicodeTable) {
                filePathA = ConvertWtoA (cabHandle->CabPath);
                if (filePathA) {
                    HtRemoveStringA (g_UnicodeTable, filePathA);
                    FreeConvertedStr (filePathA);
                    filePathA = NULL;
                }
            }
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFile) {
            FreePathStringW (cabHandle->CabFile);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\file\fileenum.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileenum.c

Abstract:

    Implements a set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FILEENUM    "FileEnum"

//
// Strings
//

#define S_FILEENUM      "FILEENUM"

//
// Constants
//

// None

//
// Macros
//

#define pFileAllocateMemory(Size)   PmGetMemory (g_FileEnumPool,Size)
#define pFileFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_FileEnumPool, (PVOID)Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_FileEnumPool;
static INT g_FileEnumRefs;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
FileEnumInitialize (
    VOID
    )

/*++

Routine Description:

    FileEnumInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_FileEnumRefs++;

    if (g_FileEnumRefs == 1) {
        g_FileEnumPool = PmCreateNamedPool (S_FILEENUM);
    }

    return g_FileEnumPool != NULL;
}


VOID
FileEnumTerminate (
    VOID
    )

/*++

Routine Description:

    FileEnumTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    MYASSERT (g_FileEnumRefs > 0);
    g_FileEnumRefs--;

    if (!g_FileEnumRefs) {
        if (g_FileEnumPool) {
            PmDestroyPool (g_FileEnumPool);
            g_FileEnumPool = NULL;
        }
    }
}


/*++

Routine Description:

    EnumFirstDrive enumerates the first fixed drive root

Arguments:

    DriveEnum - Receives info about the first fixed drive root

Return Value:

    TRUE if a drive root was found; FALSE if not

--*/

BOOL
EnumFirstDriveA (
    OUT     PDRIVE_ENUMA DriveEnum,
    IN      UINT WantedDriveTypes
    )
{
    DWORD len;

    len = GetLogicalDriveStringsA (0, NULL);
    if (len) {
        DriveEnum->AllLogicalDrives = pFileAllocateMemory ((len + 1) * sizeof (CHAR));
        if (DriveEnum->AllLogicalDrives) {
            GetLogicalDriveStringsA (len, DriveEnum->AllLogicalDrives);
            DriveEnum->DriveName = NULL;
            DriveEnum->WantedDriveTypes = WantedDriveTypes;
            return EnumNextDriveA (DriveEnum);
        }
    }
    return FALSE;
}

BOOL
EnumFirstDriveW (
    OUT     PDRIVE_ENUMW DriveEnum,
    IN      UINT WantedDriveTypes
    )
{
    DWORD len;

    len = GetLogicalDriveStringsW (0, NULL);
    if (len) {
        DriveEnum->AllLogicalDrives = pFileAllocateMemory ((len + 1) * sizeof (WCHAR));
        if (DriveEnum->AllLogicalDrives) {
            GetLogicalDriveStringsW (len, DriveEnum->AllLogicalDrives);
            DriveEnum->DriveName = NULL;
            DriveEnum->WantedDriveTypes = WantedDriveTypes;
            return EnumNextDriveW (DriveEnum);
        }
    }
    return FALSE;
}


/*++

Routine Description:

    EnumNextDrive enumerates the next fixed drive

Arguments:

    DriveEnum - Specifies info about the previous fixed drive root; receives updated info

Return Value:

    TRUE if a new drive root was found; FALSE if not

--*/

BOOL
EnumNextDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    )
{
    do {
        if (!DriveEnum->DriveName) {
            DriveEnum->DriveName = DriveEnum->AllLogicalDrives;
        } else {
            // Since DriveEnum->DriveName is not NULL, GetEndOfStringA will
            // not return NULL so...
            DriveEnum->DriveName = GetEndOfStringA (DriveEnum->DriveName) + 1;  //lint !e613
        }
        if (*DriveEnum->DriveName == 0) {
            AbortEnumDriveA (DriveEnum);
            return FALSE;
        }

        DriveEnum->DriveType = GetDriveTypeA (DriveEnum->DriveName);

        switch (DriveEnum->DriveType) {
        case DRIVE_UNKNOWN:
            DriveEnum->DriveType = DRIVEENUM_UNKNOWN;
            break;
        case DRIVE_NO_ROOT_DIR:
            DriveEnum->DriveType = DRIVEENUM_NOROOTDIR;
            break;
        case DRIVE_REMOVABLE:
            DriveEnum->DriveType = DRIVEENUM_REMOVABLE;
            break;
        case DRIVE_FIXED:
            DriveEnum->DriveType = DRIVEENUM_FIXED;
            break;
        case DRIVE_REMOTE:
            DriveEnum->DriveType = DRIVEENUM_REMOTE;
            break;
        case DRIVE_CDROM:
            DriveEnum->DriveType = DRIVEENUM_CDROM;
            break;
        case DRIVE_RAMDISK:
            DriveEnum->DriveType = DRIVEENUM_RAMDISK;
            break;
        default:
            DriveEnum->DriveType = DRIVEENUM_UNKNOWN;
        }

    } while (!(DriveEnum->DriveType & DriveEnum->WantedDriveTypes));

    return TRUE;
}

BOOL
EnumNextDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    )
{
    do {
        if (!DriveEnum->DriveName) {
            DriveEnum->DriveName = DriveEnum->AllLogicalDrives;
        } else {
            DriveEnum->DriveName = GetEndOfStringW (DriveEnum->DriveName) + 1;
        }
        if (*DriveEnum->DriveName == 0) {
            AbortEnumDriveW (DriveEnum);
            return FALSE;
        }

        DriveEnum->DriveType = GetDriveTypeW (DriveEnum->DriveName);

        switch (DriveEnum->DriveType) {
        case DRIVE_UNKNOWN:
            DriveEnum->DriveType = DRIVEENUM_UNKNOWN;
            break;
        case DRIVE_NO_ROOT_DIR:
            DriveEnum->DriveType = DRIVEENUM_NOROOTDIR;
            break;
        case DRIVE_REMOVABLE:
            DriveEnum->DriveType = DRIVEENUM_REMOVABLE;
            break;
        case DRIVE_FIXED:
            DriveEnum->DriveType = DRIVEENUM_FIXED;
            break;
        case DRIVE_REMOTE:
            DriveEnum->DriveType = DRIVEENUM_REMOTE;
            break;
        case DRIVE_CDROM:
            DriveEnum->DriveType = DRIVEENUM_CDROM;
            break;
        case DRIVE_RAMDISK:
            DriveEnum->DriveType = DRIVEENUM_RAMDISK;
            break;
        default:
            DriveEnum->DriveType = DRIVEENUM_UNKNOWN;
        }

    } while (!(DriveEnum->DriveType & DriveEnum->WantedDriveTypes));

    return TRUE;
}


/*++

Routine Description:

    AbortEnumDrive aborts enumeration of fixed drives

Arguments:

    DriveEnum - Specifies info about the previous fixed drive;
                receives a "clean" context

Return Value:

    none

--*/

VOID
AbortEnumDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    )
{
    if (DriveEnum->AllLogicalDrives) {
        pFileFreeMemory (DriveEnum->AllLogicalDrives);
        DriveEnum->AllLogicalDrives = NULL;
    }
}

VOID
AbortEnumDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    )
{
    if (DriveEnum->AllLogicalDrives) {
        pFileFreeMemory (DriveEnum->AllLogicalDrives);
        DriveEnum->AllLogicalDrives = NULL;
    }
}


/*++

Routine Description:

    pGetFileEnumInfo is a private function that validates and translates the enumeration info
    in an internal form that's more accessible to the enum routines

Arguments:

    FileEnumInfo - Receives the enum info
    EncodedPathPattern - Specifies the encoded dir pattern (encoded as defined by the
                         ParsedPattern functions)
    EnumDirs - Specifies TRUE if directories should be returned during the enumeration
               (if they match the pattern); a directory is returned before any of its
               subdirs or files
    ContainersFirst - Specifies TRUE if directories should be returned before any of its
                      files or subdirs; used only if EnumDirs is TRUE
    FilesFirst - Specifies TRUE if a dir's files should be returned before dir's subdirs;
                 this parameter decides the enum order between files and subdirs
                 for each directory
    DepthFirst - Specifies TRUE if the current subdir of any dir should be fully enumerated
                 before going to the next subdir; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a dir that is to be enumerated, relative to
                  the root; if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    paths/files are excluded from enumeration; this slows down the speed

Return Value:

    TRUE if all params are valid; in this case, FileEnumInfo is filled with the corresponding
         info.
    FALSE otherwise.

--*/

BOOL
pGetFileEnumInfoA (
    OUT     PFILEENUMINFOA FileEnumInfo,
    IN      PCSTR EncodedPathPattern,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions
    )
{
    FileEnumInfo->PathPattern = ObsCreateParsedPatternA (EncodedPathPattern);
    if (!FileEnumInfo->PathPattern) {
        DEBUGMSGA ((DBG_ERROR, "pGetFileEnumInfoA: bad EncodedPathPattern: %s", EncodedPathPattern));
        return FALSE;
    }

    //
    // check for empty filename; no filename will match in this case
    //
    if (FileEnumInfo->PathPattern->Leaf && *FileEnumInfo->PathPattern->Leaf == 0) {
        DEBUGMSGA ((
            DBG_ERROR,
            "pGetFileEnumInfoA: empty filename pattern specified in EncodedPathPattern: %s",
            EncodedPathPattern
            ));
        ObsDestroyParsedPatternA (FileEnumInfo->PathPattern);
        FileEnumInfo->PathPattern = NULL;
        return FALSE;
    }

    if (FileEnumInfo->PathPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsA (
                FileEnumInfo->PathPattern->ExactRoot,
                NULL,
                &FileEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        FileEnumInfo->RootLevel = 1;
    }

    if (!FileEnumInfo->PathPattern->LeafPattern) {
        //
        // no file pattern specified; assume only directory names will be returned
        // overwrite caller's setting
        //
        DEBUGMSGA ((
            DBG_FILEENUM,
            "pGetFileEnumInfoA: no filename pattern specified; forcing EnumDirs to TRUE"
            ));
        EnumDirs = TRUE;
    }

    if (EnumDirs) {
        FileEnumInfo->Flags |= FEIF_RETURN_DIRS;
    }
    if (ContainersFirst) {
        FileEnumInfo->Flags |= FEIF_CONTAINERS_FIRST;
    }
    if (FilesFirst) {
        FileEnumInfo->Flags |= FEIF_FILES_FIRST;
    }
    if (DepthFirst) {
        FileEnumInfo->Flags |= FEIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        FileEnumInfo->Flags |= FEIF_USE_EXCLUSIONS;
    }

    FileEnumInfo->MaxSubLevel = min (MaxSubLevel, FileEnumInfo->PathPattern->MaxSubLevel);

    return TRUE;
}

BOOL
pGetFileEnumInfoW (
    OUT     PFILEENUMINFOW FileEnumInfo,
    IN      PCWSTR EncodedPathPattern,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions
    )
{
    FileEnumInfo->PathPattern = ObsCreateParsedPatternW (EncodedPathPattern);
    if (!FileEnumInfo->PathPattern) {
        DEBUGMSGW ((DBG_ERROR, "pGetFileEnumInfoW: bad EncodedPathPattern: %s", EncodedPathPattern));
        return FALSE;
    }

    //
    // check for empty filename; no filename will match in this case
    //
    if (FileEnumInfo->PathPattern->Leaf && *FileEnumInfo->PathPattern->Leaf == 0) {
        DEBUGMSGW ((
            DBG_ERROR,
            "pGetFileEnumInfoW: empty filename pattern specified in EncodedPathPattern: %s",
            EncodedPathPattern
            ));
        ObsDestroyParsedPatternW (FileEnumInfo->PathPattern);
        FileEnumInfo->PathPattern = NULL;
        return FALSE;
    }

    if (FileEnumInfo->PathPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsW (
                FileEnumInfo->PathPattern->ExactRoot,
                NULL,
                &FileEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        FileEnumInfo->RootLevel = 1;
    }

    if (!FileEnumInfo->PathPattern->LeafPattern) {
        //
        // no file pattern specified; assume only directory names will be returned
        // overwrite caller's setting
        //
        DEBUGMSGW ((
            DBG_FILEENUM,
            "pGetFileEnumInfoW: no filename pattern specified; forcing EnumDirs to TRUE"
            ));
        EnumDirs = TRUE;
    }

    if (EnumDirs) {
        FileEnumInfo->Flags |= FEIF_RETURN_DIRS;
    }
    if (ContainersFirst) {
        FileEnumInfo->Flags |= FEIF_CONTAINERS_FIRST;
    }
    if (FilesFirst) {
        FileEnumInfo->Flags |= FEIF_FILES_FIRST;
    }
    if (DepthFirst) {
        FileEnumInfo->Flags |= FEIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        FileEnumInfo->Flags |= FEIF_USE_EXCLUSIONS;
    }

    FileEnumInfo->MaxSubLevel = min (MaxSubLevel, FileEnumInfo->PathPattern->MaxSubLevel);

    return TRUE;
}


/*++

Routine Description:

    pGetCurrentDirNode returns the current dir node to be enumerated, based on DepthFirst flag

Arguments:

    FileEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be retrieved, regardless of
                  DepthFirst flag

Return Value:

    The current node if any or NULL if none remaining.

--*/

PDIRNODEA
pGetCurrentDirNodeA (
    IN      PFILETREE_ENUMA FileEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &FileEnum->FileNodes;

    if (!gb->Buf || gb->End - gb->UserIndex < DWSIZEOF (DIRNODEA)) {
        return NULL;
    }

    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        return (PDIRNODEA)(gb->Buf + gb->End) - 1;
    } else {
        return (PDIRNODEA)(gb->Buf + gb->UserIndex);
    }
}

PDIRNODEW
pGetCurrentDirNodeW (
    IN      PFILETREE_ENUMW FileEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &FileEnum->FileNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (DIRNODEW)) {
        return NULL;
    }

    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        return (PDIRNODEW)(gb->Buf + gb->End) - 1;
    } else {
        return (PDIRNODEW)(gb->Buf + gb->UserIndex);
    }
}


/*++

Routine Description:

    pDeleteDirNode frees the resources associated with the current dir node and destroys it

Arguments:

    FileEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be deleted, regardless of
                  DepthFirst flag

Return Value:

    TRUE if there was a node to delete, FALSE if no more nodes

--*/

BOOL
pDeleteDirNodeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    IN      BOOL LastCreated
    )
{
    PDIRNODEA dirNode;
    PGROWBUFFER gb = &FileEnum->FileNodes;

    dirNode = pGetCurrentDirNodeA (FileEnum, LastCreated);
    if (!dirNode) {
        return FALSE;
    }

    if (dirNode->DirName) {
        FreeTextExA (g_FileEnumPool, dirNode->DirName);
    }

    if (dirNode->FindHandle) {
        FindClose (dirNode->FindHandle);
        dirNode->FindHandle = NULL;
    }

    if (FileEnum->LastNode == dirNode) {
        FileEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (DIRNODEA);
    } else {
        gb->UserIndex += DWSIZEOF (DIRNODEA);
        //
        // shift list
        //
        if (gb->Size - gb->End < DWSIZEOF (DIRNODEA)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }

    }

    return TRUE;
}

BOOL
pDeleteDirNodeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    IN      BOOL LastCreated
    )
{
    PDIRNODEW dirNode;
    PGROWBUFFER gb = &FileEnum->FileNodes;

    dirNode = pGetCurrentDirNodeW (FileEnum, LastCreated);
    if (!dirNode) {
        return FALSE;
    }

    if (dirNode->DirName) {
        FreeTextExW (g_FileEnumPool, dirNode->DirName);
    }

    if (dirNode->FindHandle) {
        FindClose (dirNode->FindHandle);
        dirNode->FindHandle = NULL;
    }

    if (FileEnum->LastNode == dirNode) {
        FileEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (DIRNODEW);
    } else {
        gb->UserIndex += DWSIZEOF (DIRNODEW);
        //
        // shift list
        //
        if (gb->Size - gb->End < DWSIZEOF (DIRNODEW)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }

    }

    return TRUE;
}


/*++

Routine Description:

    pCreateDirNode creates a new node given a context, a dir name or a parent node

Arguments:

    FileEnum - Specifies the context
    DirName - Specifies the dir name of the new node; may be NULL only if ParentNode is not NULL
    ParentNode - Specifies a pointer to the parent node of the new node; a pointer to the node
                 is required because the parent node location in memory may change as a result
                 of the growbuffer changing buffer location when it grows;
                 may be NULL only if DirName is not;
    Ignore - Receives a meaningful value only if NULL is returned (no node created);
             if TRUE upon return, the failure of node creation should be ignored

Return Value:

    A pointer to the new node or NULL if no node was created

--*/

PDIRNODEA
pCreateDirNodeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    IN      PCSTR DirName,              OPTIONAL
    IN      PDIRNODEA* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PDIRNODEA newNode;
    PSTR newDirName;
    PSEGMENTA FirstSegment;
    LONG offset = 0;

    if (DirName) {
        newDirName = DuplicateTextExA (g_FileEnumPool, DirName, 0, NULL);
        RemoveWackAtEndA (newDirName);
    } else {
        MYASSERT (ParentNode);
        newDirName = JoinPathsInPoolExA ((
                        g_FileEnumPool,
                        (*ParentNode)->DirName,
                        (*ParentNode)->FindData.cFileName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        if (FileEnum->FileEnumInfo.PathPattern->NodePattern) {
            FirstSegment = FileEnum->FileEnumInfo.PathPattern->NodePattern->Pattern->Segment;
        } else {
            FreeTextExA (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
        if ((FirstSegment->Type == SEGMENTTYPE_EXACTMATCH) &&
            (!StringIMatchByteCountA (
                    FirstSegment->Exact.LowerCasePhrase,
                    newDirName,
                    FirstSegment->Exact.PhraseBytes
                    ))
            ) {
            DEBUGMSGA ((
                DBG_FILEENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newDirName
                ));

            FreeTextExA (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
        //
        // look if this dir and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2A (ELT_FILE, newDirName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {

            DEBUGMSGA ((
                DBG_FILEENUM,
                "Skipping tree %s\\%s because it's excluded",
                newDirName,
                FileEnum->FileEnumInfo.PathPattern->Leaf
                ));

            FreeTextExA (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PDIRNODEA) GbGrow (&FileEnum->FileNodes, DWSIZEOF (DIRNODEA));
    if (!newNode) {
        FreeTextExA (g_FileEnumPool, newDirName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PDIRNODEA)(FileEnum->FileNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (DIRNODEA));

    newNode->DirName = newDirName;

    if (DirName) {
        newNode->DirAttributes = GetFileAttributesA (DirName);
        //
        // roots are not returned from enumeration because DNF_RETURN_DIRNAME is not set here
        //
        if ((FileEnum->FileEnumInfo.PathPattern->Leaf == NULL) &&
            (FileEnum->FileEnumInfo.PathPattern->ExactRoot) &&
            (!WildCharsPatternA (FileEnum->FileEnumInfo.PathPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    } else {
        MYASSERT (ParentNode);
        //ParentNode is not NULL (see the assert above) so...
        newNode->DirAttributes = (*ParentNode)->FindData.dwFileAttributes;  //lint !e613
        newNode->Flags |= DNF_RETURN_DIRNAME;
    }

    newNode->EnumState = DNS_ENUM_INIT;

    if ((FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternA (FileEnum->FileEnumInfo.PathPattern->NodePattern, newDirName)
        ) {
        newNode->Flags |= DNF_DIRNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (FileEnum->FileEnumInfo.CallbackOnError) {
            *Ignore = (*FileEnum->FileEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    return NULL;
}

PDIRNODEW
pCreateDirNodeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    IN      PCWSTR DirName,             OPTIONAL
    IN      PDIRNODEW* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PDIRNODEW newNode;
    PWSTR newDirName;
    PSEGMENTW FirstSegment;
    LONG offset = 0;

    if (DirName) {
        newDirName = DuplicateTextExW (g_FileEnumPool, DirName, 0, NULL);
        RemoveWackAtEndW (newDirName);
    } else {
        MYASSERT (ParentNode);
        newDirName = JoinPathsInPoolExW ((
                        g_FileEnumPool,
                        (*ParentNode)->DirName,
                        (*ParentNode)->FindData.cFileName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        if (FileEnum->FileEnumInfo.PathPattern->NodePattern) {
            FirstSegment = FileEnum->FileEnumInfo.PathPattern->NodePattern->Pattern->Segment;
        } else {
            FreeTextExW (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
        if ((FirstSegment->Type == SEGMENTTYPE_EXACTMATCH) &&
            (!StringIMatchByteCountW (
                    FirstSegment->Exact.LowerCasePhrase,
                    newDirName,
                    FirstSegment->Exact.PhraseBytes
                    ))
            ) {    //lint !e64
            DEBUGMSGW ((
                DBG_FILEENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newDirName
                ));

            FreeTextExW (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
        //
        // look if this dir and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2W (ELT_FILE, newDirName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {

            DEBUGMSGW ((
                DBG_FILEENUM,
                "Skipping tree %s\\%s because it's excluded",
                newDirName,
                FileEnum->FileEnumInfo.PathPattern->Leaf
                ));

            FreeTextExW (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PDIRNODEW) GbGrow (&FileEnum->FileNodes, DWSIZEOF (DIRNODEW));
    if (!newNode) {
        FreeTextExW (g_FileEnumPool, newDirName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PDIRNODEW)(FileEnum->FileNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (DIRNODEW));

    newNode->DirName = newDirName;

    if (DirName) {
        newNode->DirAttributes = GetFileAttributesW (DirName);
        //
        // roots are not returned from enumeration because DNF_RETURN_DIRNAME is not set here
        //
        if ((FileEnum->FileEnumInfo.PathPattern->Leaf == NULL) &&
            (FileEnum->FileEnumInfo.PathPattern->ExactRoot) &&
            (!WildCharsPatternW (FileEnum->FileEnumInfo.PathPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    } else {
        MYASSERT (ParentNode);
        //ParentNode is not NULL (see the assert above) so...
        newNode->DirAttributes = (*ParentNode)->FindData.dwFileAttributes;  //lint !e613
        newNode->Flags |= DNF_RETURN_DIRNAME;
    }

    newNode->EnumState = DNS_ENUM_INIT;

    if ((FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternW (FileEnum->FileEnumInfo.PathPattern->NodePattern, newDirName)
        ) {
        newNode->Flags |= DNF_DIRNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (FileEnum->FileEnumInfo.CallbackOnError) {
            *Ignore = (*FileEnum->FileEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    return NULL;
}


/*++

Routine Description:

    pEnumNextFile enumerates the next file that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new file was found; FALSE if not

--*/

BOOL
pEnumNextFileA (
    IN OUT  PDIRNODEA DirNode
    )
{
    do {
        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumNextFileW (
    IN OUT  PDIRNODEW DirNode
    )
{
    do {
        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstFile enumerates the first file that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first file was found; FALSE if not

--*/

BOOL
pEnumFirstFileA (
    OUT     PDIRNODEA DirNode,
    IN      PFILETREE_ENUMA FileEnum
    )
{
    PCSTR pattern;
    PSEGMENTA FirstSegment;
    PCSTR p;

    if (FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_EXACTLEAF) {
        FirstSegment = FileEnum->FileEnumInfo.PathPattern->LeafPattern->Pattern->Segment;
        p = FirstSegment->Exact.LowerCasePhrase;
        MYASSERT (p && *p);
    } else {
        p = "*";
    }
    pattern = JoinPathsA (DirNode->DirName, p);
    DirNode->FindHandle = FindFirstFileA (pattern, &DirNode->FindData);
    FreePathStringA (pattern);

    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    do {
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }

        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumFirstFileW (
    OUT     PDIRNODEW DirNode,
    IN      PFILETREE_ENUMW FileEnum
    )
{
    PCWSTR pattern;
    PSEGMENTW FirstSegment;
    PCWSTR p;

    if (FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_EXACTLEAF) {
        FirstSegment = FileEnum->FileEnumInfo.PathPattern->LeafPattern->Pattern->Segment;
        p = FirstSegment->Exact.LowerCasePhrase;
        MYASSERT (p && *p);
    } else {
        p = L"*";
    }

    pattern = JoinPathsW (DirNode->DirName, p);
    DirNode->FindHandle = FindFirstFileW (pattern, &DirNode->FindData);
    FreePathStringW (pattern);

    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    do {
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }

        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pIsSpecialDirName checks if the specified dir name is a special name (used by the OS)

Arguments:

    DirName - Specifies the name

Return Value:

    TRUE if it's a special dir name

--*/

BOOL
pIsSpecialDirNameA (
    IN      PCSTR DirName
    )
{
    return DirName[0] == '.' && (DirName[1] == 0 || (DirName[1] == '.' && DirName[2] == 0));
}

BOOL
pIsSpecialDirNameW (
    IN      PCWSTR DirName
    )
{
    return DirName[0] == L'.' && (DirName[1] == 0 || (DirName[1] == L'.' && DirName[2] == 0));
}


/*++

Routine Description:

    pEnumNextSubDir enumerates the next subdir that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new subdir was found; FALSE if not

--*/

BOOL
pEnumNextSubDirA (
    IN OUT  PDIRNODEA DirNode
    )
{
    do {
        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore special dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            continue;
        }
        if (!pIsSpecialDirNameA (DirNode->FindData.cFileName)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumNextSubDirW (
    IN OUT  PDIRNODEW DirNode
    )
{
    do {
        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore special dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            continue;
        }
        if (!pIsSpecialDirNameW (DirNode->FindData.cFileName)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstSubDir enumerates the first subdir that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first subdir was found; FALSE if not

--*/

BOOL
pEnumFirstSubDirA (
    OUT     PDIRNODEA DirNode
    )
{
    PCSTR pattern;

    pattern = JoinPathsA (DirNode->DirName, "*");
    //
    // NTRAID#NTBUG9-153302-2000/08/01-jimschm this should be enhanced for NT (it supports FindFirstFileExA)
    //
    DirNode->FindHandle = FindFirstFileA (pattern, &DirNode->FindData);
    FreePathStringA (pattern);

    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    do {
        //
        // ignore special dirs
        //
        if ((DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            !pIsSpecialDirNameA (DirNode->FindData.cFileName)
            ) {
            break;
        }

        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumFirstSubDirW (
    OUT     PDIRNODEW DirNode
    )
{
    PCWSTR pattern;

    pattern = JoinPathsW (DirNode->DirName, L"*");
    //
    // NTRAID#NTBUG9-153302-2000/08/01-jimschm this should be enhanced for NT (it supports FindFirstFileExW)
    //
    DirNode->FindHandle = FindFirstFileW (pattern, &DirNode->FindData);
    FreePathStringW (pattern);

    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    do {
        //
        // ignore special dirs
        //
        if ((DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            !pIsSpecialDirNameW (DirNode->FindData.cFileName)
            ) {
            break;
        }

        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumNextFileInTree is a private function that enumerates the next node matching
    the specified criteria; it's implemented as a state machine that travels the dirs/files
    as specified the the caller; it doesn't check if they actually match the patterns

Arguments:

    FileEnum - Specifies the current enum context; receives updated info
    CurrentDirNode - Receives the dir node that is currently processed, if success is returned

Return Value:

    TRUE if a next match was found; FALSE if no more dirs/files match

--*/

BOOL
pEnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    OUT     PDIRNODEA* CurrentDirNode
    )
{
    PDIRNODEA currentNode;
    PDIRNODEA newNode;
    BOOL ignore;

    while ((currentNode = pGetCurrentDirNodeA (FileEnum, FALSE)) != NULL) {

        *CurrentDirNode = currentNode;

        switch (currentNode->EnumState) {

        case DNS_FILE_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumFirstFileA (currentNode, FileEnum)) {
                currentNode->EnumState = DNS_FILE_NEXT;
                return TRUE;
            }
            currentNode->EnumState = DNS_FILE_DONE;
            break;

        case DNS_FILE_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumNextFileA (currentNode)) {
                return TRUE;
            }
            //
            // no more files for this one, go to the next
            //
            currentNode->EnumState = DNS_FILE_DONE;
            //
            // fall through
            //
        case DNS_FILE_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // done with this node
                //
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }
            //
            // now enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            //
            // fall through
            //
        case DNS_SUBDIR_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            //
            // check current dir's level; if max level reached, don't recurse into subdirs
            //
            if (currentNode->SubLevel >= FileEnum->FileEnumInfo.MaxSubLevel) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (!pEnumFirstSubDirA (currentNode)) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            currentNode->EnumState = DNS_SUBDIR_NEXT;
            newNode = pCreateDirNodeA (FileEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // look at the new node first
                //
                if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                    if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~DNF_RETURN_DIRNAME;
                        *CurrentDirNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating file system; aborting enumeration"
                    ));
                FileEnum->RootState = FES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case DNS_SUBDIR_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (pEnumNextSubDirA (currentNode)) {
                newNode = pCreateDirNodeA (FileEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                        if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~DNF_RETURN_DIRNAME;
                            *CurrentDirNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                //
                // did it fail because of a soft block?
                //
                if (!ignore) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating file system; aborting enumeration"
                        ));
                    FileEnum->RootState = FES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subdir
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = DNS_SUBDIR_DONE;
            //
            // fall through
            //
        case DNS_SUBDIR_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // now enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = DNS_ENUM_DONE;
            //
            // fall through
            //
        case DNS_ENUM_DONE:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (!(FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        //
                        // before returning, set some data
                        //
                        currentNode->FindData.cFileName[0] = 0;
                        return TRUE;
                    }
                }
            }
            pDeleteDirNodeA (FileEnum, FALSE);
            break;

        case DNS_ENUM_INIT:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        return TRUE;
                    }
                }
            }

            if (FileEnum->ControlFlags & FECF_SKIPDIR) {
                FileEnum->ControlFlags &= ~FECF_SKIPDIR;
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }

            if (FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST) {
                //
                // enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}

BOOL
pEnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    OUT     PDIRNODEW* CurrentDirNode
    )
{
    PDIRNODEW currentNode;
    PDIRNODEW newNode;
    BOOL ignore;

    while ((currentNode = pGetCurrentDirNodeW (FileEnum, FALSE)) != NULL) {

        *CurrentDirNode = currentNode;

        switch (currentNode->EnumState) {

        case DNS_FILE_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumFirstFileW (currentNode, FileEnum)) {
                currentNode->EnumState = DNS_FILE_NEXT;
                return TRUE;
            }
            currentNode->EnumState = DNS_FILE_DONE;
            break;

        case DNS_FILE_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumNextFileW (currentNode)) {
                return TRUE;
            }
            //
            // no more files for this one, go to the next
            //
            currentNode->EnumState = DNS_FILE_DONE;
            //
            // fall through
            //
        case DNS_FILE_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // done with this node
                //
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }
            //
            // now enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            //
            // fall through
            //
        case DNS_SUBDIR_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            //
            // check current dir's level; if max level reached, don't recurse into subdirs
            //
            if (currentNode->SubLevel >= FileEnum->FileEnumInfo.MaxSubLevel) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (!pEnumFirstSubDirW (currentNode)) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            currentNode->EnumState = DNS_SUBDIR_NEXT;
            newNode = pCreateDirNodeW (FileEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // look at the new node first
                //
                if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                    if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~DNF_RETURN_DIRNAME;
                        *CurrentDirNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            //
            // did it fail because of a soft block?
            //
            if (!ignore) {
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating file system; aborting enumeration"
                    ));
                FileEnum->RootState = FES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case DNS_SUBDIR_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (pEnumNextSubDirW (currentNode)) {
                newNode = pCreateDirNodeW (FileEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                        if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~DNF_RETURN_DIRNAME;
                            *CurrentDirNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                //
                // did it fail because of a soft block?
                //
                if (!ignore) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating file system; aborting enumeration"
                        ));
                    FileEnum->RootState = FES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subdir
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = DNS_SUBDIR_DONE;
            //
            // fall through
            //
        case DNS_SUBDIR_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // now enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = DNS_ENUM_DONE;
            //
            // fall through
            //
        case DNS_ENUM_DONE:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (!(FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        //
                        // before returning, set some data
                        //
                        currentNode->FindData.cFileName[0] = 0;
                        return TRUE;
                    }
                }
            }
            pDeleteDirNodeW (FileEnum, FALSE);
            break;

        case DNS_ENUM_INIT:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        return TRUE;
                    }
                }
            }

            if (FileEnum->ControlFlags & FECF_SKIPDIR) {
                FileEnum->ControlFlags &= ~FECF_SKIPDIR;
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }

            if (FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST) {
                //
                // enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}


/*++

Routine Description:

    pEnumFirstFileRoot enumerates the first root that matches caller's conditions

Arguments:

    FileEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumFirstFileRootA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    PSTR root = NULL;
    BOOL ignore;

    if (FileEnum->FileEnumInfo.PathPattern->ExactRoot) {
        root = pFileAllocateMemory (SizeOfStringA (FileEnum->FileEnumInfo.PathPattern->ExactRoot));
        ObsDecodeStringA (root, FileEnum->FileEnumInfo.PathPattern->ExactRoot);
    }

    if (root) {

        if (!BfPathIsDirectoryA (root)) {
            DEBUGMSGA ((DBG_FILEENUM, "pEnumFirstFileRootA: Invalid root spec: %s", root));
            pFileFreeMemory (root);
            return FALSE;
        }

        if (pCreateDirNodeA (FileEnum, root, NULL, NULL)) {
            FileEnum->RootState = FES_ROOT_DONE;
            pFileFreeMemory (root);
            return TRUE;
        }
    } else {
        FileEnum->DriveEnum = pFileAllocateMemory (DWSIZEOF (DRIVE_ENUMA));

        if (!EnumFirstDriveA (FileEnum->DriveEnum, FileEnum->DriveEnumTypes)) {
            return FALSE;
        }

        do {
            if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2A (ELT_FILE, FileEnum->DriveEnum->DriveName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {
                    DEBUGMSGA ((DBG_FILEENUM, "pEnumFirstFileRootA: Root is excluded: %s", FileEnum->DriveEnum->DriveName));
                    continue;
                }
            }
            if (!pCreateDirNodeA (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            FileEnum->RootState = FES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextDriveA (FileEnum->DriveEnum));

        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }

    return FALSE;
}

BOOL
pEnumFirstFileRootW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    PWSTR root = NULL;
    BOOL ignore;

    if (FileEnum->FileEnumInfo.PathPattern->ExactRoot) {
        root = pFileAllocateMemory (SizeOfStringW (FileEnum->FileEnumInfo.PathPattern->ExactRoot));
        ObsDecodeStringW (root, FileEnum->FileEnumInfo.PathPattern->ExactRoot);
    }

    if (root) {

        if (!BfPathIsDirectoryW (root)) {
            DEBUGMSGW ((DBG_FILEENUM, "pEnumFirstFileRootW: Invalid root spec: %s", root));
            pFileFreeMemory (root);
            return FALSE;
        }

        if (pCreateDirNodeW (FileEnum, root, NULL, NULL)) {
            FileEnum->RootState = FES_ROOT_DONE;
            pFileFreeMemory (root);
            return TRUE;
        }
    } else {
        FileEnum->DriveEnum = pFileAllocateMemory (DWSIZEOF (DRIVE_ENUMA));

        if (!EnumFirstDriveW (FileEnum->DriveEnum, FileEnum->DriveEnumTypes)) {
            return FALSE;
        }

        do {
            if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2W (ELT_FILE, FileEnum->DriveEnum->DriveName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {
                    DEBUGMSGW ((DBG_FILEENUM, "pEnumFirstFileRootW: Root is excluded: %s", FileEnum->DriveEnum->DriveName));
                    continue;
                }
            }
            if (!pCreateDirNodeW (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            FileEnum->RootState = FES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextDriveW (FileEnum->DriveEnum));

        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }

    return FALSE;
}


BOOL
pEnumNextFileRootA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    BOOL ignore;

    while (EnumNextDriveA (FileEnum->DriveEnum)) {
        if (pCreateDirNodeA (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    FileEnum->RootState = FES_ROOT_DONE;

    return FALSE;
}

BOOL
pEnumNextFileRootW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    BOOL ignore;

    while (EnumNextDriveW (FileEnum->DriveEnum)) {
        if (pCreateDirNodeW (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    FileEnum->RootState = FES_ROOT_DONE;

    return FALSE;
}


/*++

Routine Description:

    EnumFirstFileInTreeEx enumerates file system dirs, and optionally files, that match the
    specified criteria

Arguments:

    FileEnum - Receives the enum context info; this will be used in subsequent calls to
               EnumNextFileInTree
    EncodedPathPattern - Specifies the encoded dir pattern (encoded as defined by the
                        ParsedPattern functions)
    EncodedFilePattern - Specifies the encoded file pattern (encoded as defined by the
                          ParsedPattern functions); optional; NULL means no files
                          should be returned (only look for dirs)
    EnumDirs - Specifies TRUE if directories should be returned during the enumeration
               (if they match the pattern)
    ContainersFirst - Specifies TRUE if directories should be returned before any of its
                      files or subdirs
    FilesFirst - Specifies TRUE if a dir's files should be returned before dir's subdirs;
                  this parameter decides the enum order between files and subdirs
                  for each dir
    DepthFirst - Specifies TRUE if the current subdir of any dir should be fully enumerated
                 before going to the next subdir; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a subdir that is to be enumerated,
                  relative to the root; if 0, only the root is enumerated;
                  if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    paths/files are excluded from enumeration; this slows down the speed
    CallbackOnError - Specifies a pointer to a callback function that will be called during
                      enumeration if an error occurs; if the callback is defined and it
                      returns FALSE, the enumeration is aborted, otherwise it will continue
                      ignoring the error

Return Value:

    TRUE if a first match is found.
    FALSE otherwise.

--*/

BOOL
EnumFirstFileInTreeExA (
    OUT     PFILETREE_ENUMA FileEnum,
    IN      PCSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKA CallbackOnError    OPTIONAL
    )
{
    MYASSERT (FileEnum && EncodedPathPattern && *EncodedPathPattern);
    MYASSERT (g_FileEnumPool);

    ZeroMemory (FileEnum, DWSIZEOF (*FileEnum));    //lint !e613 !e668

    FileEnum->DriveEnumTypes = DriveEnumTypes;

    //
    // first try to get dir enum info in internal format
    //
    if (!pGetFileEnumInfoA (
            /*lint -e(613)*/&FileEnum->FileEnumInfo,
            EncodedPathPattern,
            EnumDirs,
            ContainersFirst,
            FilesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions
            )) {
        AbortEnumFileInTreeA (FileEnum);
        return FALSE;
    }
    if (UseExclusions) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedA (ELT_FILE, /*lint -e(613)*/FileEnum->FileEnumInfo.PathPattern)) {
            DEBUGMSGA ((
                DBG_FILEENUM,
                "EnumFirstFileInTreeExA: Root is excluded: %s",
                EncodedPathPattern
                ));
            AbortEnumFileInTreeA (FileEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstFileRootA (FileEnum)) {
        AbortEnumFileInTreeA (FileEnum);
        return FALSE;
    }

    /*lint -e(613)*/FileEnum->FileEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextFileInTreeA (FileEnum);
}

BOOL
EnumFirstFileInTreeExW (
    OUT     PFILETREE_ENUMW FileEnum,
    IN      PCWSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKW CallbackOnError    OPTIONAL
    )
{
    MYASSERT (FileEnum && EncodedPathPattern && *EncodedPathPattern);
    MYASSERT (g_FileEnumPool);

    ZeroMemory (FileEnum, DWSIZEOF (*FileEnum));    //lint !e613 !e668

    FileEnum->DriveEnumTypes = DriveEnumTypes;

    //
    // first try to get dir enum info in internal format
    //
    if (!pGetFileEnumInfoW (
            /*lint -e(613)*/&FileEnum->FileEnumInfo,
            EncodedPathPattern,
            EnumDirs,
            ContainersFirst,
            FilesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions
            )) {
        AbortEnumFileInTreeW (FileEnum);
        return FALSE;
    }
    if (UseExclusions) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedW (ELT_FILE, /*lint -e(613)*/FileEnum->FileEnumInfo.PathPattern)) {
            DEBUGMSGW ((
                DBG_FILEENUM,
                "EnumFirstFileInTreeExW: Root is excluded: %s",
                EncodedPathPattern
                ));
            AbortEnumFileInTreeW (FileEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstFileRootW (FileEnum)) {
        AbortEnumFileInTreeW (FileEnum);
        return FALSE;
    }

    /*lint -e(613)*/FileEnum->FileEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextFileInTreeW (FileEnum);
}


BOOL
pTestLeafPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR LeafToTest
    )
{
    PSTR newLeaf;
    BOOL result = TRUE;

    if (!TestParsedPatternA (ParsedPattern, LeafToTest)) {
        newLeaf = JoinTextA (LeafToTest, ".");
        result = TestParsedPatternA (ParsedPattern, newLeaf);
        FreeTextA (newLeaf);
    }
    return result;
}

BOOL
pTestLeafPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR LeafToTest
    )
{
    PWSTR newLeaf;
    BOOL result = TRUE;

    if (!TestParsedPatternW (ParsedPattern, LeafToTest)) {
        newLeaf = JoinTextW (LeafToTest, L".");
        result = TestParsedPatternW (ParsedPattern, newLeaf);
        FreeTextW (newLeaf);
    }
    return result;
}


/*++

Routine Description:

    EnumNextFileInTree enumerates the next node matching the criteria specified in
    FileEnum; this is filled on the call to EnumFirstFileInTreeEx;

Arguments:

    FileEnum - Specifies the current enum context; receives updated info

Return Value:

    TRUE if a next match was found; FALSE if no more dirs/files match

--*/

BOOL
EnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    PDIRNODEA currentNode;
    BOOL success;

    MYASSERT (FileEnum);

    do {
        if (FileEnum->EncodedFullName) {
            ObsFreeA (FileEnum->EncodedFullName);
            FileEnum->EncodedFullName = NULL;
        }

        while (TRUE) {  //lint !e506

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = '\\';
                FileEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextFileInTreeA (FileEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->DirName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & DNF_DIRNAME_MATCHES)) {   //lint !e613
                continue;
            }

            if (/*lint -e(613)*/currentNode->FindData.cFileName[0] == 0) {
                MYASSERT (/*lint -e(613)*/currentNode->DirAttributes & FILE_ATTRIBUTE_DIRECTORY);

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->LastWackPtr = _mbsrchr (FileEnum->Location, '\\');
                if (!FileEnum->LastWackPtr) {
                    FileEnum->Name = FileEnum->Location;
                } else {
                    FileEnum->Name = _mbsinc (FileEnum->LastWackPtr);
                    if (!FileEnum->Name) {
                        FileEnum->Name = FileEnum->Location;
                    }
                }

                //
                // prepare full path buffer
                //
                if (SizeOfStringA (FileEnum->Location) / DWSIZEOF(CHAR)> DWSIZEOF (FileEnum->NativeFullName) / DWSIZEOF(CHAR)) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Directory %s was found, but its path is too long",
                        FileEnum->Location
                        ));
                    continue;
                }
                StringCopyA (FileEnum->NativeFullName, FileEnum->Location);
                FileEnum->LastNode = currentNode;
                FileEnum->FileNameAppendPos = NULL;

                FileEnum->Attributes = /*lint -e(613)*/currentNode->DirAttributes;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2A (ELT_FILE, FileEnum->Location, NULL)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                FileEnum->Location,
                                                NULL,
                                                TRUE
                                                );
            } else {

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->Name = /*lint -e(613)*/currentNode->FindData.cFileName;

                //
                // test if the filename matches
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !pTestLeafPatternA (
                            FileEnum->FileEnumInfo.PathPattern->LeafPattern,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            )
                   ) {
                    continue;
                }

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2A (ELT_FILE, NULL, /*lint -e(613)*/currentNode->FindData.cFileName)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "File %s\\%s was found, but it's excluded by filename",
                            FileEnum->Location,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            ));
                        continue;
                    }
                }

                if (FileEnum->LastNode != currentNode) {
                    FileEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    FileEnum->NativeFullName[0] = 0;
                    FileEnum->FileNameAppendPos = StringCatA (FileEnum->NativeFullName, FileEnum->Location);
                    if (FileEnum->FileNameAppendPos) {
                        *FileEnum->FileNameAppendPos++ = '\\';
                    }
                } else if (!FileEnum->FileNameAppendPos) {
                    FileEnum->FileNameAppendPos = GetEndOfStringA (FileEnum->NativeFullName);
                    if (FileEnum->FileNameAppendPos) {
                        *FileEnum->FileNameAppendPos++ = '\\';
                    }
                }

                if (FileEnum->FileNameAppendPos + SizeOfStringA (FileEnum->Name) / DWSIZEOF(CHAR)>
                    FileEnum->NativeFullName + DWSIZEOF (FileEnum->NativeFullName) / DWSIZEOF(CHAR)) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "File %s\\%s was found, but its path is too long",
                        FileEnum->Location,
                        FileEnum->Name
                        ));
                    continue;
                }

                StringCopyA (FileEnum->FileNameAppendPos, FileEnum->Name);
                FileEnum->Attributes = /*lint -e(613)*/currentNode->FindData.dwFileAttributes;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2A (ELT_FILE, FileEnum->Location, FileEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                FileEnum->Location,
                                                FileEnum->Name,
                                                TRUE
                                                );
            }

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = 0;
            }

            FileEnum->CurrentLevel = FileEnum->FileEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            return TRUE;
        }

        //
        // try the next root
        //
        if (FileEnum->RootState == FES_ROOT_DONE) {
            break;
        }

        MYASSERT (FileEnum->RootState == FES_ROOT_NEXT);
        MYASSERT (FileEnum->DriveEnum);
        success = pEnumNextFileRootA (FileEnum);

    } while (success);

    AbortEnumFileInTreeA (FileEnum);

    return FALSE;
}

BOOL
EnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    PDIRNODEW currentNode;
    BOOL success;

    MYASSERT (FileEnum);

    do {
        if (FileEnum->EncodedFullName) {
            ObsFreeW (FileEnum->EncodedFullName);
            FileEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = L'\\';
                FileEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextFileInTreeW (FileEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->DirName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & DNF_DIRNAME_MATCHES)) {   //lint !e613
                continue;
            }

            if (/*lint -e(613)*/currentNode->FindData.cFileName[0] == 0) {
                MYASSERT (/*lint -e(613)*/currentNode->DirAttributes & FILE_ATTRIBUTE_DIRECTORY);

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->LastWackPtr = wcsrchr (FileEnum->Location, L'\\');
                if (!FileEnum->LastWackPtr) {
                    FileEnum->Name = FileEnum->Location;
                } else {
                    FileEnum->Name = FileEnum->LastWackPtr + 1;
                    if (!FileEnum->Name) {
                        FileEnum->Name = FileEnum->Location;
                    }
                }

                //
                // prepare full path buffer
                //
                if (SizeOfStringW (FileEnum->Location) / DWSIZEOF(WCHAR)> DWSIZEOF (FileEnum->NativeFullName) / DWSIZEOF(WCHAR)) {
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "Directory %s was found, but its path is too long",
                        FileEnum->Location
                        ));
                    continue;
                }
                StringCopyW (FileEnum->NativeFullName, FileEnum->Location);
                FileEnum->LastNode = currentNode;
                FileEnum->FileNameAppendPos = NULL;

                FileEnum->Attributes = /*lint -e(613)*/currentNode->DirAttributes;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2W (ELT_FILE, FileEnum->Location, NULL)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                FileEnum->Location,
                                                NULL,
                                                TRUE
                                                );
            } else {

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->Name = /*lint -e(613)*/currentNode->FindData.cFileName;

                //
                // test if the filename matches
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !pTestLeafPatternW (
                            FileEnum->FileEnumInfo.PathPattern->LeafPattern,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            )
                   ) {
                    continue;
                }

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2W (ELT_FILE, NULL, /*lint -e(613)*/currentNode->FindData.cFileName)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "File %s\\%s was found, but it's excluded by filename",
                            FileEnum->Location,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            ));
                        continue;
                    }
                }

                if (FileEnum->LastNode != currentNode) {
                    FileEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    FileEnum->NativeFullName[0] = 0;
                    FileEnum->FileNameAppendPos = StringCatW (FileEnum->NativeFullName, FileEnum->Location);
                    if (FileEnum->FileNameAppendPos) {
                        *FileEnum->FileNameAppendPos++ = L'\\';
                    }
                } else if (!FileEnum->FileNameAppendPos) {
                    FileEnum->FileNameAppendPos = GetEndOfStringW (FileEnum->NativeFullName);
                    if (FileEnum->FileNameAppendPos) {
                        *FileEnum->FileNameAppendPos++ = L'\\';
                    }
                }
                MYASSERT (FileEnum->Name && *FileEnum->Name);

                if (FileEnum->FileNameAppendPos + SizeOfStringW (FileEnum->Name) / DWSIZEOF(WCHAR)>
                    FileEnum->NativeFullName + DWSIZEOF (FileEnum->NativeFullName) / DWSIZEOF(WCHAR)) {
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "File %s\\%s was found, but its path is too long",
                        FileEnum->Location,
                        FileEnum->Name
                        ));
                    continue;
                }

                StringCopyW (FileEnum->FileNameAppendPos, FileEnum->Name);
                FileEnum->Attributes = /*lint -e(613)*/currentNode->FindData.dwFileAttributes;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2W (ELT_FILE, FileEnum->Location, FileEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                FileEnum->Location,
                                                FileEnum->Name,
                                                TRUE
                                                );
            }

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = 0;
            }

            FileEnum->CurrentLevel = FileEnum->FileEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            return TRUE;
        }

        //
        // try the next root
        //
        if (FileEnum->RootState == FES_ROOT_DONE) {
            break;
        }

        MYASSERT (FileEnum->RootState == FES_ROOT_NEXT);
        MYASSERT (FileEnum->DriveEnum);
        success = pEnumNextFileRootW (FileEnum);

    } while (success);

    AbortEnumFileInTreeW (FileEnum);

    return FALSE;
}


/*++

Routine Description:

    AbortEnumFileInTree aborts the enumeration, freeing all resources allocated

Arguments:

    FileEnum - Specifies the current enum context; receives a "clean" context

Return Value:

    none

--*/

VOID
AbortEnumFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    while (pDeleteDirNodeA (FileEnum, TRUE)) {
    }
    GbFree (&FileEnum->FileNodes);

    if (FileEnum->EncodedFullName) {
        ObsFreeA (FileEnum->EncodedFullName);
        FileEnum->EncodedFullName = NULL;
    }

    if (FileEnum->FileEnumInfo.PathPattern) {
        ObsDestroyParsedPatternA (FileEnum->FileEnumInfo.PathPattern);
        FileEnum->FileEnumInfo.PathPattern = NULL;
    }

    if (FileEnum->DriveEnum) {
        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }
}

VOID
AbortEnumFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    while (pDeleteDirNodeW (FileEnum, TRUE)) {
    }
    GbFree (&FileEnum->FileNodes);

    if (FileEnum->EncodedFullName) {
        ObsFreeW (FileEnum->EncodedFullName);
        FileEnum->EncodedFullName = NULL;
    }

    if (FileEnum->FileEnumInfo.PathPattern) {
        ObsDestroyParsedPatternW (FileEnum->FileEnumInfo.PathPattern);
        FileEnum->FileEnumInfo.PathPattern = NULL;
    }

    if (FileEnum->DriveEnum) {
        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\file\fileutil.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileutil.c

Abstract:

    Implements utility routines for files, file paths, etc.

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FILEUTIL    "FileUtil"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pDefaultFindFileA (
    IN      PCSTR FileName
    )
{
    return (GetFileAttributesA (FileName) != INVALID_ATTRIBUTES);
}

BOOL
pDefaultFindFileW (
    IN      PCWSTR FileName
    )
{
    return (GetFileAttributesW (FileName) != INVALID_ATTRIBUTES);
}

BOOL
pDefaultSearchPathA (
    IN      PCSTR FileName,
    IN      DWORD BufferLength,
    OUT     PSTR Buffer
    )
{
    PSTR dontCare;
    return SearchPathA (NULL, FileName, NULL, BufferLength, Buffer, &dontCare);
}

BOOL
pDefaultSearchPathW (
    IN      PCWSTR FileName,
    IN      DWORD BufferLength,
    OUT     PWSTR Buffer
    )
{
    PWSTR dontCare;
    return SearchPathW (NULL, FileName, NULL, BufferLength, Buffer, &dontCare);
}

PCMDLINEA
ParseCmdLineExA (
    IN      PCSTR CmdLine,
    IN      PCSTR Separators,                   OPTIONAL
    IN      PFINDFILEA FindFileCallback,        OPTIONAL
    IN      PSEARCHPATHA SearchPathCallback,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer
    )
{
    PFINDFILEA findFileCallback = FindFileCallback;
    PSEARCHPATHA searchPathCallback = SearchPathCallback;
    GROWBUFFER SpacePtrs = INIT_GROWBUFFER;
    PCSTR p;
    PSTR q;
    INT Count;
    INT i;
    INT j;
    PSTR *Array;
    PCSTR Start;
    CHAR OldChar = 0;
    GROWBUFFER StringBuf = INIT_GROWBUFFER;
    PBYTE CopyBuf;
    PCMDLINEA CmdLineTable;
    PCMDLINEARGA CmdLineArg;
    ULONG_PTR Base;
    PSTR Path = NULL;
    PSTR UnquotedPath = NULL;
    PSTR FixedFileName = NULL;
    PSTR FirstArgPath = NULL;
    DWORD pathSize = 0;
    PCSTR FullPath = NULL;
    BOOL fileExists = FALSE;
    PSTR CmdLineCopy;
    BOOL Quoted;
    UINT OriginalArgOffset = 0;
    UINT CleanedUpArgOffset = 0;
    BOOL GoodFileFound = FALSE;
    PSTR EndOfFirstArg;
    BOOL QuoteMode = FALSE;
    PSTR End;

    if (!Separators) {
        Separators = " =,;";
    }

    if (!findFileCallback) {
        findFileCallback = pDefaultFindFileA;
    }

    if (!searchPathCallback) {
        searchPathCallback = pDefaultSearchPathA;
    }

    pathSize = SizeOfStringA (CmdLine) * 2;
    if (pathSize < MAX_MBCHAR_PATH) {
        pathSize = MAX_MBCHAR_PATH;
    }

    Path = AllocTextA (pathSize);
    UnquotedPath = AllocTextA (pathSize);
    FixedFileName = AllocTextA (pathSize);
    FirstArgPath = AllocTextA (pathSize);
    CmdLineCopy = DuplicateTextA (CmdLine);

    if (!Path ||
        !UnquotedPath ||
        !FixedFileName ||
        !FirstArgPath ||
        !CmdLineCopy
        ) {
        return NULL;
    }

    //
    // Build an array of places to break the string
    //

    for (p = CmdLineCopy ; *p ; p = _mbsinc (p)) {

        if (_mbsnextc (p) == '\"') {

            QuoteMode = !QuoteMode;

        } else if (!QuoteMode &&
                   _mbschr (Separators, _mbsnextc (p))
                   ) {

            //
            // Remove excess spaces
            //

            q = (PSTR) p + 1;
            while (_mbsnextc (q) == ' ') {
                q++;
            }

            if (q > p + 1) {
                MoveMemory ((PBYTE) p + sizeof (CHAR), q, SizeOfStringA (q));
            }

            GbAppendPvoid (&SpacePtrs, p);
        }
    }

    //
    // Prepare the CMDLINE struct
    //

    CmdLineTable = (PCMDLINEA) GbGrow (Buffer, sizeof (CMDLINEA));
    MYASSERT (CmdLineTable);

    //
    // NOTE: We store string offsets, then at the end resolve them
    //       to pointers later.
    //

    CmdLineTable->CmdLine = (PCSTR) (ULONG_PTR) StringBuf.End;
    GbMultiSzAppendA (&StringBuf, CmdLine);

    CmdLineTable->ArgCount = 0;

    //
    // Now test every combination, emulating CreateProcess
    //

    Count = SpacePtrs.End / sizeof (PVOID);
    Array = (PSTR *) SpacePtrs.Buf;

    i = -1;
    EndOfFirstArg = NULL;

    while (i < Count) {

        GoodFileFound = FALSE;
        Quoted = FALSE;

        if (i >= 0) {
            Start = Array[i] + 1;
        } else {
            Start = CmdLineCopy;
        }

        //
        // Check for a full path at Start
        //

        if (_mbsnextc (Start) != '/') {

            for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                FullPath = Start;

                //
                // Remove quotes; continue in the loop if it has no terminating quotes
                //

                Quoted = FALSE;
                if (_mbsnextc (Start) == '\"') {

                    StringCopyByteCountA (UnquotedPath, Start + 1, pathSize);
                    q = _mbschr (UnquotedPath, '\"');

                    if (q) {
                        *q = 0;
                        FullPath = UnquotedPath;
                        Quoted = TRUE;
                    } else {
                        FullPath = NULL;
                    }
                }

                if (FullPath && *FullPath) {
                    //
                    // Look in file system for the path
                    //

                    fileExists = findFileCallback (FullPath);

                    if (!fileExists && EndOfFirstArg) {
                        //
                        // Try prefixing the path with the first arg's path.
                        //

                        StringCopyByteCountA (
                            EndOfFirstArg,
                            FullPath,
                            pathSize - (HALF_PTR) ((PBYTE) EndOfFirstArg - (PBYTE) FirstArgPath)
                            );

                        FullPath = FirstArgPath;
                        fileExists = findFileCallback (FullPath);
                    }

                    if (!fileExists && i < 0) {
                        //
                        // Try appending .exe, then testing again.  This
                        // emulates what CreateProcess does.
                        //

                        StringCopyByteCountA (
                            FixedFileName,
                            FullPath,
                            pathSize - sizeof (".exe")
                            );

                        q = GetEndOfStringA (FixedFileName);
                        q = _mbsdec (FixedFileName, q);
                        MYASSERT (q);

                        if (_mbsnextc (q) != '.') {
                            q = _mbsinc (q);
                        }

                        StringCopyA (q, ".exe");

                        FullPath = FixedFileName;
                        fileExists = findFileCallback (FullPath);
                    }

                    if (fileExists) {
                        //
                        // Full file path found.  Test its file status, then
                        // move on if there are no important operations on it.
                        //

                        OriginalArgOffset = StringBuf.End;
                        GbMultiSzAppendA (&StringBuf, Start);

                        if (!StringMatchA (Start, FullPath)) {
                            CleanedUpArgOffset = StringBuf.End;
                            GbMultiSzAppendA (&StringBuf, FullPath);
                        } else {
                            CleanedUpArgOffset = OriginalArgOffset;
                        }

                        i = j;
                        GoodFileFound = TRUE;
                    }
                }

                if (j < Count) {
                    *Array[j] = OldChar;
                }
            }

            if (!GoodFileFound) {
                //
                // If a wack is in the path, then we could have a relative path, an arg, or
                // a full path to a non-existent file.
                //

                if (_mbschr (Start, '\\')) {
#ifdef DEBUG
                    j = i + 1;

                    if (j < Count) {
                        OldChar = *Array[j];
                        *Array[j] = 0;
                    }

                    DEBUGMSGA ((
                        DBG_VERBOSE,
                        "%s is a non-existent path spec, a relative path, or an arg",
                        Start
                        ));

                    if (j < Count) {
                        *Array[j] = OldChar;
                    }
#endif

                } else {
                    //
                    // The string at Start did not contain a full path; try using
                    // searchPathCallback.
                    //

                    for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                        if (j < Count) {
                            OldChar = *Array[j];
                            *Array[j] = 0;
                        }

                        FullPath = Start;

                        //
                        // Remove quotes; continue in the loop if it has no terminating quotes
                        //

                        Quoted = FALSE;
                        if (_mbsnextc (Start) == '\"') {

                            StringCopyByteCountA (UnquotedPath, Start + 1, pathSize);
                            q = _mbschr (UnquotedPath, '\"');

                            if (q) {
                                *q = 0;
                                FullPath = UnquotedPath;
                                Quoted = TRUE;
                            } else {
                                FullPath = NULL;
                            }
                        }

                        if (FullPath && *FullPath) {
                            if (searchPathCallback (
                                    FullPath,
                                    pathSize / sizeof (Path[0]),
                                    Path
                                    )) {

                                FullPath = Path;

                            } else if (i < 0) {
                                //
                                // Try appending .exe and searching the path again
                                //

                                StringCopyByteCountA (
                                    FixedFileName,
                                    FullPath,
                                    pathSize - sizeof (".exe")
                                    );

                                q = GetEndOfStringA (FixedFileName);
                                q = _mbsdec (FixedFileName, q);
                                MYASSERT (q);

                                if (_mbsnextc (q) != '.') {
                                    q = _mbsinc (q);
                                }

                                StringCopyA (q, ".exe");

                                if (searchPathCallback (
                                        FixedFileName,
                                        pathSize / sizeof (Path[0]),
                                        Path
                                        )) {

                                    FullPath = Path;

                                } else {

                                    FullPath = NULL;

                                }

                            } else {

                                FullPath = NULL;

                            }
                        }

                        if (FullPath && *FullPath) {
                            fileExists = findFileCallback (FullPath);
                            MYASSERT (fileExists);

                            OriginalArgOffset = StringBuf.End;
                            GbMultiSzAppendA (&StringBuf, Start);

                            if (!StringMatchA (Start, FullPath)) {
                                CleanedUpArgOffset = StringBuf.End;
                                GbMultiSzAppendA (&StringBuf, FullPath);
                            } else {
                                CleanedUpArgOffset = OriginalArgOffset;
                            }

                            i = j;
                            GoodFileFound = TRUE;
                        }

                        if (j < Count) {
                            *Array[j] = OldChar;
                        }
                    }
                }
            }
        }

        CmdLineTable->ArgCount += 1;
        CmdLineArg = (PCMDLINEARGA) GbGrow (Buffer, sizeof (CMDLINEARGA));
        MYASSERT (CmdLineArg);

        if (GoodFileFound) {
            //
            // We have a good full file spec in FullPath, its existance
            // is in fileExists, and i has been moved to the space beyond
            // the path.  We now add a table entry.
            //

            CmdLineArg->OriginalArg = (PCSTR) (ULONG_PTR) OriginalArgOffset;
            CmdLineArg->CleanedUpArg = (PCSTR) (ULONG_PTR) CleanedUpArgOffset;
            CmdLineArg->Quoted = Quoted;

            if (!EndOfFirstArg) {
                StringCopyByteCountA (
                    FirstArgPath,
                    (PCSTR) (StringBuf.Buf + (ULONG_PTR) CmdLineArg->CleanedUpArg),
                    pathSize
                    );
                q = (PSTR) GetFileNameFromPathA (FirstArgPath);
                if (q) {
                    q = _mbsdec (FirstArgPath, q);
                    if (q) {
                        *q = 0;
                    }
                }

                EndOfFirstArg = AppendWackA (FirstArgPath);
            }

        } else {
            //
            // We do not have a good file spec; we must have a non-file
            // argument.  Put it in the table, and advance to the next
            // arg.
            //

            j = i + 1;
            if (j <= Count) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                CmdLineArg->OriginalArg = (PCSTR) (ULONG_PTR) StringBuf.End;
                GbMultiSzAppendA (&StringBuf, Start);

                Quoted = FALSE;

                if (_mbschr (Start, '\"')) {

                    p = Start;
                    q = UnquotedPath;
                    End = (PSTR) ((PBYTE) UnquotedPath + pathSize - sizeof (CHAR));

                    while (*p && q < End) {
                        if (IsLeadByte (p)) {
                            *q++ = *p++;
                            *q++ = *p++;
                        } else {
                            if (*p == '\"') {
                                p++;
                            } else {
                                *q++ = *p++;
                            }
                        }
                    }

                    *q = 0;

                    CmdLineArg->CleanedUpArg = (PCSTR) (ULONG_PTR) StringBuf.End;
                    GbMultiSzAppendA (&StringBuf, UnquotedPath);
                    Quoted = TRUE;

                } else {
                    CmdLineArg->CleanedUpArg = CmdLineArg->OriginalArg;
                }

                CmdLineArg->Quoted = Quoted;

                if (j < Count) {
                    *Array[j] = OldChar;
                }

                i = j;
            }
        }
    }

    //
    // We now have a command line table; transfer StringBuf to Buffer, then
    // convert all offsets into pointers.
    //

    MYASSERT (StringBuf.End);

    CopyBuf = GbGrow (Buffer, StringBuf.End);
    MYASSERT (CopyBuf);

    Base = (ULONG_PTR) CopyBuf;
    CopyMemory (CopyBuf, StringBuf.Buf, StringBuf.End);

    // Earlier GbGrow may have moved the buffer in memory.  We need to repoint CmdLineTable
    CmdLineTable = (PCMDLINEA)Buffer->Buf;
    CmdLineTable->CmdLine = (PCSTR) ((PBYTE) CmdLineTable->CmdLine + Base);

    CmdLineArg = &CmdLineTable->Args[0];

    for (i = 0 ; i < (INT) CmdLineTable->ArgCount ; i++) {
        CmdLineArg->OriginalArg = (PCSTR) ((PBYTE) CmdLineArg->OriginalArg + Base);
        CmdLineArg->CleanedUpArg = (PCSTR) ((PBYTE) CmdLineArg->CleanedUpArg + Base);

        CmdLineArg++;
    }

    GbFree (&StringBuf);
    GbFree (&SpacePtrs);

    FreeTextA (CmdLineCopy);
    FreeTextA (FirstArgPath);
    FreeTextA (FixedFileName);
    FreeTextA (UnquotedPath);
    FreeTextA (Path);

    return (PCMDLINEA) Buffer->Buf;
}


PCMDLINEW
ParseCmdLineExW (
    IN      PCWSTR CmdLine,
    IN      PCWSTR Separators,                  OPTIONAL
    IN      PFINDFILEW FindFileCallback,        OPTIONAL
    IN      PSEARCHPATHW SearchPathCallback,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer
    )
{
    PFINDFILEW findFileCallback = FindFileCallback;
    PSEARCHPATHW searchPathCallback = SearchPathCallback;
    GROWBUFFER SpacePtrs = INIT_GROWBUFFER;
    PCWSTR p;
    PWSTR q;
    INT Count;
    INT i;
    INT j;
    PWSTR *Array;
    PCWSTR Start;
    WCHAR OldChar = 0;
    GROWBUFFER StringBuf = INIT_GROWBUFFER;
    PBYTE CopyBuf;
    PCMDLINEW CmdLineTable;
    PCMDLINEARGW CmdLineArg;
    ULONG_PTR Base;
    PWSTR Path = NULL;
    PWSTR UnquotedPath = NULL;
    PWSTR FixedFileName = NULL;
    PWSTR FirstArgPath = NULL;
    DWORD pathSize = 0;
    PCWSTR FullPath = NULL;
    BOOL fileExists = FALSE;
    PWSTR CmdLineCopy;
    BOOL Quoted;
    UINT OriginalArgOffset = 0;
    UINT CleanedUpArgOffset = 0;
    BOOL GoodFileFound = FALSE;
    PWSTR EndOfFirstArg;
    BOOL QuoteMode = FALSE;
    PWSTR End;

    if (!Separators) {
        Separators = L" =,;";
    }

    if (!findFileCallback) {
        findFileCallback = pDefaultFindFileW;
    }

    if (!searchPathCallback) {
        searchPathCallback = pDefaultSearchPathW;
    }

    pathSize = SizeOfStringW (CmdLine);
    if (pathSize < MAX_WCHAR_PATH) {
        pathSize = MAX_WCHAR_PATH;
    }

    Path = AllocTextW (pathSize);
    UnquotedPath = AllocTextW (pathSize);
    FixedFileName = AllocTextW (pathSize);
    FirstArgPath = AllocTextW (pathSize);
    CmdLineCopy = DuplicateTextW (CmdLine);

    if (!Path ||
        !UnquotedPath ||
        !FixedFileName ||
        !FirstArgPath ||
        !CmdLineCopy
        ) {
        return NULL;
    }

    //
    // Build an array of places to break the string
    //

    for (p = CmdLineCopy ; *p ; p++) {
        if (*p == L'\"') {

            QuoteMode = !QuoteMode;

        } else if (!QuoteMode &&
                   wcschr (Separators, *p)
                   ) {

            //
            // Remove excess spaces
            //

            q = (PWSTR) p + 1;
            while (*q == L' ') {
                q++;
            }

            if (q > p + 1) {
                MoveMemory ((PBYTE) p + sizeof (WCHAR), q, SizeOfStringW (q));
            }

            GbAppendPvoid (&SpacePtrs, p);
        }
    }

    //
    // Prepare the CMDLINE struct
    //

    CmdLineTable = (PCMDLINEW) GbGrow (Buffer, sizeof (CMDLINEW));
    MYASSERT (CmdLineTable);

    //
    // NOTE: We store string offsets, then at the end resolve them
    //       to pointers later.
    //

    CmdLineTable->CmdLine = (PCWSTR) (ULONG_PTR) StringBuf.End;
    GbMultiSzAppendW (&StringBuf, CmdLine);

    CmdLineTable->ArgCount = 0;

    //
    // Now test every combination, emulating CreateProcess
    //

    Count = SpacePtrs.End / sizeof (PVOID);
    Array = (PWSTR *) SpacePtrs.Buf;

    i = -1;
    EndOfFirstArg = NULL;

    while (i < Count) {

        GoodFileFound = FALSE;
        Quoted = FALSE;

        if (i >= 0) {
            Start = Array[i] + 1;
        } else {
            Start = CmdLineCopy;
        }

        //
        // Check for a full path at Start
        //

        if (*Start != L'/') {
            for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                FullPath = Start;

                //
                // Remove quotes; continue in the loop if it has no terminating quotes
                //

                Quoted = FALSE;
                if (*Start == L'\"') {

                    StringCopyByteCountW (UnquotedPath, Start + 1, pathSize);
                    q = wcschr (UnquotedPath, L'\"');

                    if (q) {
                        *q = 0;
                        FullPath = UnquotedPath;
                        Quoted = TRUE;
                    } else {
                        FullPath = NULL;
                    }
                }

                if (FullPath && *FullPath) {
                    //
                    // Look in file system for the path
                    //

                    fileExists = findFileCallback (FullPath);

                    if (!fileExists && EndOfFirstArg) {
                        //
                        // Try prefixing the path with the first arg's path.
                        //

                        StringCopyByteCountW (
                            EndOfFirstArg,
                            FullPath,
                            pathSize - (HALF_PTR) ((PBYTE) EndOfFirstArg - (PBYTE) FirstArgPath)
                            );

                        FullPath = FirstArgPath;
                        fileExists = findFileCallback (FullPath);
                    }

                    if (!fileExists && i < 0) {
                        //
                        // Try appending .exe, then testing again.  This
                        // emulates what CreateProcess does.
                        //

                        StringCopyByteCountW (
                            FixedFileName,
                            FullPath,
                            pathSize - sizeof (L".exe")
                            );

                        q = GetEndOfStringW (FixedFileName);
                        q--;
                        MYASSERT (q >= FixedFileName);

                        if (*q != L'.') {
                            q++;
                        }

                        StringCopyW (q, L".exe");

                        FullPath = FixedFileName;
                        fileExists = findFileCallback (FullPath);
                    }

                    if (fileExists) {
                        //
                        // Full file path found.  Test its file status, then
                        // move on if there are no important operations on it.
                        //

                        OriginalArgOffset = StringBuf.End;
                        GbMultiSzAppendW (&StringBuf, Start);

                        if (!StringMatchW (Start, FullPath)) {
                            CleanedUpArgOffset = StringBuf.End;
                            GbMultiSzAppendW (&StringBuf, FullPath);
                        } else {
                            CleanedUpArgOffset = OriginalArgOffset;
                        }

                        i = j;
                        GoodFileFound = TRUE;
                    }
                }

                if (j < Count) {
                    *Array[j] = OldChar;
                }
            }

            if (!GoodFileFound) {
                //
                // If a wack is in the path, then we could have a relative path, an arg, or
                // a full path to a non-existent file.
                //

                if (wcschr (Start, L'\\')) {

#ifdef DEBUG
                    j = i + 1;

                    if (j < Count) {
                        OldChar = *Array[j];
                        *Array[j] = 0;
                    }

                    DEBUGMSGW ((
                        DBG_VERBOSE,
                        "%s is a non-existent path spec, a relative path, or an arg",
                        Start
                        ));

                    if (j < Count) {
                        *Array[j] = OldChar;
                    }
#endif

                } else {
                    //
                    // The string at Start did not contain a full path; try using
                    // searchPathCallback.
                    //

                    for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                        if (j < Count) {
                            OldChar = *Array[j];
                            *Array[j] = 0;
                        }

                        FullPath = Start;

                        //
                        // Remove quotes; continue in the loop if it has no terminating quotes
                        //

                        Quoted = FALSE;
                        if (*Start == L'\"') {

                            StringCopyByteCountW (UnquotedPath, Start + 1, pathSize);
                            q = wcschr (UnquotedPath, L'\"');

                            if (q) {
                                *q = 0;
                                FullPath = UnquotedPath;
                                Quoted = TRUE;
                            } else {
                                FullPath = NULL;
                            }
                        }

                        if (FullPath && *FullPath) {
                            if (searchPathCallback (
                                    FullPath,
                                    pathSize / sizeof (Path[0]),
                                    Path
                                    )) {

                                FullPath = Path;

                            } else if (i < 0) {
                                //
                                // Try appending .exe and searching the path again
                                //

                                StringCopyByteCountW (
                                    FixedFileName,
                                    FullPath,
                                    pathSize - sizeof (L".exe")
                                    );

                                q = GetEndOfStringW (FixedFileName);
                                q--;
                                MYASSERT (q >= FixedFileName);

                                if (*q != L'.') {
                                    q++;
                                }

                                StringCopyW (q, L".exe");

                                if (searchPathCallback (
                                        FixedFileName,
                                        pathSize / sizeof (Path[0]),
                                        Path
                                        )) {

                                    FullPath = Path;

                                } else {

                                    FullPath = NULL;

                                }
                            } else {

                                FullPath = NULL;

                            }
                        }

                        if (FullPath && *FullPath) {
                            fileExists = findFileCallback (FullPath);
                            MYASSERT (fileExists);

                            OriginalArgOffset = StringBuf.End;
                            GbMultiSzAppendW (&StringBuf, Start);

                            if (!StringMatchW (Start, FullPath)) {
                                CleanedUpArgOffset = StringBuf.End;
                                GbMultiSzAppendW (&StringBuf, FullPath);
                            } else {
                                CleanedUpArgOffset = OriginalArgOffset;
                            }

                            i = j;
                            GoodFileFound = TRUE;
                        }

                        if (j < Count) {
                            *Array[j] = OldChar;
                        }
                    }
                }
            }
        }

        CmdLineTable->ArgCount += 1;
        CmdLineArg = (PCMDLINEARGW) GbGrow (Buffer, sizeof (CMDLINEARGW));
        MYASSERT (CmdLineArg);

        if (GoodFileFound) {
            //
            // We have a good full file spec in FullPath, its existance
            // is in fileExists, and i has been moved to the space beyond
            // the path.  We now add a table entry.
            //

            CmdLineArg->OriginalArg = (PCWSTR) (ULONG_PTR) OriginalArgOffset;
            CmdLineArg->CleanedUpArg = (PCWSTR) (ULONG_PTR) CleanedUpArgOffset;
            CmdLineArg->Quoted = Quoted;

            if (!EndOfFirstArg) {
                StringCopyByteCountW (
                    FirstArgPath,
                    (PCWSTR) (StringBuf.Buf + (ULONG_PTR) CmdLineArg->CleanedUpArg),
                    pathSize
                    );

                q = (PWSTR) GetFileNameFromPathW (FirstArgPath);
                if (q) {
                    q--;
                    if (q >= FirstArgPath) {
                        *q = 0;
                    }
                }

                EndOfFirstArg = AppendWackW (FirstArgPath);
            }

        } else {
            //
            // We do not have a good file spec; we must have a non-file
            // argument.  Put it in the table, and advance to the next
            // arg.
            //

            j = i + 1;
            if (j <= Count) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                CmdLineArg->OriginalArg = (PCWSTR) (ULONG_PTR) StringBuf.End;
                GbMultiSzAppendW (&StringBuf, Start);

                Quoted = FALSE;
                if (wcschr (Start, '\"')) {

                    p = Start;
                    q = UnquotedPath;
                    End = (PWSTR) ((PBYTE) UnquotedPath + pathSize - sizeof (WCHAR));

                    while (*p && q < End) {
                        if (*p == L'\"') {
                            p++;
                        } else {
                            *q++ = *p++;
                        }
                    }

                    *q = 0;

                    CmdLineArg->CleanedUpArg = (PCWSTR) (ULONG_PTR) StringBuf.End;
                    GbMultiSzAppendW (&StringBuf, UnquotedPath);
                    Quoted = TRUE;

                } else {
                    CmdLineArg->CleanedUpArg = CmdLineArg->OriginalArg;
                }

                CmdLineArg->Quoted = Quoted;

                if (j < Count) {
                    *Array[j] = OldChar;
                }

                i = j;
            }
        }
    }

    //
    // We now have a command line table; transfer StringBuf to Buffer, then
    // convert all offsets into pointers.
    //

    MYASSERT (StringBuf.End);

    CopyBuf = GbGrow (Buffer, StringBuf.End);
    MYASSERT (CopyBuf);

    Base = (ULONG_PTR) CopyBuf;
    CopyMemory (CopyBuf, StringBuf.Buf, StringBuf.End);

    // Earlier GbGrow may have moved the buffer in memory.  We need to repoint CmdLineTable
    CmdLineTable = (PCMDLINEW)Buffer->Buf;
    CmdLineTable->CmdLine = (PCWSTR) ((PBYTE) CmdLineTable->CmdLine + Base);

    CmdLineArg = &CmdLineTable->Args[0];

    for (i = 0 ; i < (INT) CmdLineTable->ArgCount ; i++) {
        CmdLineArg->OriginalArg = (PCWSTR) ((PBYTE) CmdLineArg->OriginalArg + Base);
        CmdLineArg->CleanedUpArg = (PCWSTR) ((PBYTE) CmdLineArg->CleanedUpArg + Base);

        CmdLineArg++;
    }

    GbFree (&StringBuf);
    GbFree (&SpacePtrs);

    FreeTextW (CmdLineCopy);
    FreeTextW (FirstArgPath);
    FreeTextW (FixedFileName);
    FreeTextW (UnquotedPath);
    FreeTextW (Path);

    return (PCMDLINEW) Buffer->Buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\file\tree.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Implements routines that do operations on entire trees

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_TREE        "Tree"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
FiRemoveAllFilesInDirA (
    IN      PCSTR Dir
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;

    pattern = ObsBuildEncodedObjectStringExA (Dir, "*", FALSE);

    if (EnumFirstFileInTreeExA (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            SetFileAttributesA (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);

            if (!DeleteFileA (e.NativeFullName)) {
                AbortEnumFileInTreeA (&e);
                result = FALSE;
                break;
            }

        } while (EnumNextFileInTreeA (&e));
    }

    ObsFreeA (pattern);

    return result;
}


BOOL
FiRemoveAllFilesInDirW (
    IN      PCWSTR Dir
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;

    pattern = ObsBuildEncodedObjectStringExW (Dir, L"*", FALSE);

    if (EnumFirstFileInTreeExW (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            SetFileAttributesW (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);

            if (!DeleteFileW (e.NativeFullName)) {
                AbortEnumFileInTreeW (&e);
                result = FALSE;
                break;
            }

        } while (EnumNextFileInTreeW (&e));
    }

    ObsFreeW (pattern);

    return result;
}


BOOL
FiRemoveAllFilesInTreeExA (
    IN      PCSTR Dir,
    IN      BOOL RemoveRoot
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PSTR encodedStr;
    PCSTR dirPattern;

    encodedStr = DuplicatePathStringA (Dir, TcharCountA (Dir));
    ObsEncodeStringExA (encodedStr, Dir, "^");
    dirPattern = JoinPathsA (encodedStr, "*");
    FreePathStringA (encodedStr);
    pattern = ObsBuildEncodedObjectStringExA (dirPattern, "*", FALSE);

    if (EnumFirstFileInTreeExA (&e, pattern, 0, TRUE, FALSE, FALSE, TRUE, FILEENUM_ALL_SUBLEVELS, FALSE, NULL)) {
        do {
            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                result = RemoveDirectoryA (e.NativeFullName);
            } else {
                SetFileAttributesA (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);
                result = DeleteFileA (e.NativeFullName);
            }
            if (!result) {
                AbortEnumFileInTreeA (&e);
                break;
            }
        } while (EnumNextFileInTreeA (&e));
    }

    if (result) {
        if (RemoveRoot) {
            result = RemoveDirectoryA (Dir);
        }
    }

    ObsFreeA (pattern);
    FreePathStringA (dirPattern);

    return result;
}


BOOL
FiRemoveAllFilesInTreeExW (
    IN      PCWSTR Dir,
    IN      BOOL RemoveRoot
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PWSTR encodedStr;
    PCWSTR dirPattern;

    encodedStr = DuplicatePathStringW (Dir, TcharCountW (Dir));
    ObsEncodeStringExW (encodedStr, Dir, L"^");
    dirPattern = JoinPathsW (encodedStr, L"*");
    FreePathStringW (encodedStr);
    pattern = ObsBuildEncodedObjectStringExW (dirPattern, L"*", FALSE);

    if (EnumFirstFileInTreeExW (&e, pattern, 0, TRUE, FALSE, FALSE, TRUE, FILEENUM_ALL_SUBLEVELS, FALSE, NULL)) {
        do {
            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                result = RemoveDirectoryW (e.NativeFullName);
            } else {
                SetFileAttributesW (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);
                result = DeleteFileW (e.NativeFullName);
            }
            if (!result) {
                AbortEnumFileInTreeW (&e);
                break;
            }
        } while (EnumNextFileInTreeW (&e));
    }

    if (result) {
        if (RemoveRoot) {
            result = RemoveDirectoryW (Dir);
        }
    }

    ObsFreeW (pattern);
    FreePathStringW (dirPattern);

    return result;
}


BOOL
FiCopyAllFilesInDirExA (
    IN      PCSTR Source,
    IN      PCSTR Dest,
    IN      BOOL SkipExisting
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PCSTR subPath;
    PCSTR destPath;
    BOOL fileResult;

    pattern = ObsBuildEncodedObjectStringExA (Source, "*", FALSE);

    if (EnumFirstFileInTreeExA (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            subPath = e.NativeFullName;
            subPath = (PCSTR) ((PBYTE) subPath + e.FileEnumInfo.PathPattern->ExactRootBytes);

            destPath = JoinPathsA (Dest, subPath);

            SetFileAttributesA (destPath, FILE_ATTRIBUTE_NORMAL);
            fileResult = CopyFileA (e.NativeFullName, destPath, SkipExisting);
            if (fileResult) {
                fileResult = SetFileAttributesA (destPath, e.Attributes);
            }

            FreePathStringA (destPath);

            if (!fileResult) {
                if ((!SkipExisting) ||
                    (GetLastError() != ERROR_FILE_EXISTS)) {
                    result = FALSE;
                    DEBUGMSGA ((DBG_WARNING, "Unable to copy %s", e.NativeFullName));
                }
            }

        } while (EnumNextFileInTreeA (&e));
    }

    ObsFreeA (pattern);

    return result;
}


BOOL
FiCopyAllFilesInDirExW (
    IN      PCWSTR Source,
    IN      PCWSTR Dest,
    IN      BOOL SkipExisting
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PCWSTR subPath;
    PCWSTR destPath;
    BOOL fileResult;

    pattern = ObsBuildEncodedObjectStringExW (Source, L"*", FALSE);

    if (EnumFirstFileInTreeExW (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            subPath = e.NativeFullName;
            subPath = (PCWSTR) ((PBYTE) subPath + e.FileEnumInfo.PathPattern->ExactRootBytes);

            destPath = JoinPathsW (Dest, subPath);

            SetFileAttributesW (destPath, FILE_ATTRIBUTE_NORMAL);
            fileResult = CopyFileW (e.NativeFullName, destPath, SkipExisting);
            if (fileResult) {
                fileResult = SetFileAttributesW (destPath, e.Attributes);
            }

            FreePathStringW (destPath);

            if (!fileResult) {
                if ((!SkipExisting) ||
                    (GetLastError() != ERROR_FILE_EXISTS)) {
                    result = FALSE;
                    DEBUGMSGW ((DBG_WARNING, "Unable to copy %s", e.NativeFullName));
                }
            }

        } while (EnumNextFileInTreeW (&e));
    }

    ObsFreeW (pattern);

    return result;
}


BOOL
FiCopyAllFilesInTreeExA (
    IN      PCSTR Source,
    IN      PCSTR Dest,
    IN      BOOL SkipExisting
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PCSTR dirPattern;
    PCSTR subPath;
    PCSTR destPath;
    BOOL fileResult;

    dirPattern = JoinPathsA (Source, "*");
    pattern = ObsBuildEncodedObjectStringExA (dirPattern, "*", FALSE);

    if (EnumFirstFileInTreeExA (
            &e,
            pattern,
            0,                          // drive enum types
            TRUE,                       // enum containers
            TRUE,                       // containers first
            FALSE,                      // files first
            FALSE,                      // depth first
            FILEENUM_ALL_SUBLEVELS,     // max sublevel
            FALSE,                      // use exclusions
            NULL                        // callback on error
            )) {

        do {

            subPath = e.NativeFullName;
            subPath = (PCSTR) ((PBYTE) subPath + e.FileEnumInfo.PathPattern->ExactRootBytes);

            destPath = JoinPathsA (Dest, subPath);

            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                fileResult = BfCreateDirectoryA (destPath);
                if (fileResult) {
                    fileResult = SetFileAttributesA (destPath, e.Attributes);
                }
            } else {
                SetFileAttributesA (destPath, FILE_ATTRIBUTE_NORMAL);
                fileResult = CopyFileA (e.NativeFullName, destPath, SkipExisting);
                if (fileResult) {
                    fileResult = SetFileAttributesA (destPath, e.Attributes);
                }
            }

            FreePathStringA (destPath);

            if (!fileResult) {
                if ((!SkipExisting) ||
                    (GetLastError() != ERROR_FILE_EXISTS)) {
                    result = FALSE;
                    DEBUGMSGA ((DBG_WARNING, "Unable to copy %s", e.NativeFullName));
                }
            }

        } while (EnumNextFileInTreeA (&e));
    }

    ObsFreeA (pattern);
    FreePathStringA (dirPattern);

    return result;
}


BOOL
FiCopyAllFilesInTreeExW (
    IN      PCWSTR Source,
    IN      PCWSTR Dest,
    IN      BOOL SkipExisting
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PCWSTR dirPattern;
    PCWSTR subPath;
    PCWSTR destPath;
    BOOL fileResult;

    dirPattern = JoinPathsW (Source, L"*");
    pattern = ObsBuildEncodedObjectStringExW (dirPattern, L"*", FALSE);

    if (EnumFirstFileInTreeExW (
            &e,
            pattern,
            0,                          // drive enum types
            TRUE,                       // enum containers
            TRUE,                       // containers first
            FALSE,                      // files first
            FALSE,                      // depth first
            FILEENUM_ALL_SUBLEVELS,     // max sublevel
            FALSE,                      // use exclusions
            NULL                        // callback on error
            )) {

        do {

            subPath = e.NativeFullName;
            subPath = (PCWSTR) ((PBYTE) subPath + e.FileEnumInfo.PathPattern->ExactRootBytes);

            destPath = JoinPathsW (Dest, subPath);

            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                fileResult = BfCreateDirectoryW (destPath);
                if (fileResult) {
                    fileResult = SetFileAttributesW (destPath, e.Attributes);
                }
            } else {
                SetFileAttributesW (destPath, FILE_ATTRIBUTE_NORMAL);
                fileResult = CopyFileW (e.NativeFullName, destPath, SkipExisting);
                if (fileResult) {
                    fileResult = SetFileAttributesW (destPath, e.Attributes);
                }
            }

            FreePathStringW (destPath);

            if (!fileResult) {
                if ((!SkipExisting) ||
                    (GetLastError() != ERROR_FILE_EXISTS)) {
                    result = FALSE;
                    DEBUGMSGW ((DBG_WARNING, "Unable to copy %s", e.NativeFullName));
                }
            }

        } while (EnumNextFileInTreeW (&e));
    }

    ObsFreeW (pattern);
    FreePathStringW (dirPattern);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\icons\icons.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    icons.c

Abstract:

    Implements a set of routines for handling icons in ICO, PE and NE files

Author:

    Calin Negreanu (calinn) 16-Jum-2000

Revision History:

--*/

//
// Includes
//

#include "pch.h"

//
// Debug constants
//

#define DBG_ICONS   "Icons"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
IcoReleaseResourceIdA (
    PCSTR ResourceId
    )
/*++

Routine Description:

  IcoReleaseResourceId will either do nothing if the resource ID has the high WORD 0 or will
  release the string from the paths pool.

Arguments:

  ResourceId - Specifies the resource ID to be released.

Return value:

  None

--*/
{
    if ((ULONG_PTR) ResourceId > 0xffff) {
        FreePathStringA (ResourceId);
    }
}

VOID
IcoReleaseResourceIdW (
    PCWSTR ResourceId
    )
/*++

Routine Description:

  IcoReleaseResourceId will either do nothing if the resource ID has the high WORD 0 or will
  release the string from the paths pool.

Arguments:

  ResourceId - Specifies the resource ID to be released.

Return value:

  None

--*/
{
    if ((ULONG_PTR) ResourceId > 0xffff) {
        FreePathStringW (ResourceId);
    }
}

VOID
IcoReleaseIconGroup (
    IN      PICON_GROUP IconGroup
    )
/*++

Routine Description:

  IcoReleaseIconGroup releases a previously allocated icon group.

Arguments:

  IconGroup - Specifies the icon group to be released.

Return value:

  None

--*/
{
    if (IconGroup && IconGroup->Pool) {
        PmEmptyPool (IconGroup->Pool);
        PmDestroyPool (IconGroup->Pool);
    }
}

VOID
IcoReleaseIconSGroup (
    IN OUT  PICON_SGROUP IconSGroup
    )
/*++

Routine Description:

  IcoReleaseIconSGroup releases a previously allocated serialized icon group.

Arguments:

  IconSGroup - Specifies the serialized icon group to be released.

Return value:

  None

--*/
{
    if (IconSGroup->DataSize && IconSGroup->Data) {
        MemFree (g_hHeap, 0, IconSGroup->Data);
    }
    ZeroMemory (IconSGroup, sizeof (ICON_SGROUP));
}

BOOL
IcoSerializeIconGroup (
    IN      PICON_GROUP IconGroup,
    OUT     PICON_SGROUP IconSGroup
    )
/*++

Routine Description:

  IcoSerializeIconGroup transforms a ICON_GROUP structure into a ICON_SGROUP structure.

Arguments:

  IconGroup - Specifies the icon group to be serialized.

Return value:

  None

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    DWORD iconsCount;
    DWORD index;
    DWORD size;
    PICON_IMAGE iconImage;

    if (IconGroup == NULL) {
        return FALSE;
    }
    if (IconSGroup == NULL) {
        return FALSE;
    }
    iconsCount = IconGroup->IconsCount;
    GbAppendDword (&buffer, iconsCount);
    size = sizeof (ICON_IMAGE) - sizeof (PBYTE);
    index = 0;
    while (index < iconsCount) {
        iconImage = IconGroup->Icons[index];
        CopyMemory (GbGrow (&buffer, size), iconImage, size);
        CopyMemory (GbGrow (&buffer, iconImage->Size), iconImage->Image, iconImage->Size);
        index ++;
    }
    MYASSERT (buffer.End);
    IconSGroup->DataSize = buffer.End;
    IconSGroup->Data = MemAlloc (g_hHeap, 0, buffer.End);
    CopyMemory (IconSGroup->Data, buffer.Buf, buffer.End);
    GbFree (&buffer);
    return TRUE;
}

PICON_GROUP
IcoDeSerializeIconGroup (
    IN      PICON_SGROUP IconSGroup
    )
/*++

Routine Description:

  IcoDeSerializeIconGroup transforms a ICON_SGROUP structure into a ICON_GROUP structure.

Arguments:

  IconSGroup - Specifies the icon sgroup to be transformed.

Return value:

  None

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PICON_IMAGE iconSImage = NULL;
    PDWORD iconsCount;
    PBYTE currPtr = NULL;
    DWORD i;

    if (IconSGroup == NULL) {
        return NULL;
    }
    currPtr = IconSGroup->Data;
    iconsCount = (PDWORD) currPtr;
    currPtr += sizeof (DWORD);
    iconPool = PmCreateNamedPool ("Icon");
    if (!iconPool) {
        return NULL;
    }
    iconGroupSize = sizeof (ICON_GROUP) + *iconsCount * sizeof (PICON_IMAGE);
    iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
    ZeroMemory (iconGroup, iconGroupSize);
    iconGroup->Pool = iconPool;
    iconGroup->IconsCount = (WORD) (*iconsCount);
    for (i = 0; i < *iconsCount; i ++) {
        iconSImage = (PICON_IMAGE) currPtr;
        currPtr += (sizeof (ICON_IMAGE) - sizeof (PBYTE));
        iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
        ZeroMemory (iconImage, sizeof (ICON_IMAGE));
        iconImage->Width = iconSImage->Width;
        iconImage->Height = iconSImage->Height;
        iconImage->ColorCount = iconSImage->ColorCount;
        iconImage->Planes = iconSImage->Planes;
        iconImage->BitCount = iconSImage->BitCount;
        iconImage->Size = iconSImage->Size;
        iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
        CopyMemory (iconImage->Image, currPtr, iconImage->Size);
        currPtr += iconImage->Size;
        iconGroup->Icons [i] = iconImage;
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromIcoFileEx (
    IN      HANDLE IcoFileHandle
    )
/*++

Routine Description:

  IcoExtractIconGroupFromIcoFileEx extracts the icon group from an ICO file.

Arguments:

  IcoFile - Specifies the name of the ICO file to be processed.
  IcoFileHandle - Specifies the handle to the ICO file to be processed.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    LONGLONG fileSize;
    DWORD fileOffset;
    ICONDIRBASE iconDirBase;
    PICONDIR iconDir = NULL;
    DWORD iconDirSize = 0;
    PICONDIRENTRY iconDirEntry;
    DWORD i;
    BOOL result = FALSE;

    __try {
        fileSize = GetFileSize (IcoFileHandle, NULL);
        if (!BfSetFilePointer (IcoFileHandle, 0)) {
            __leave;
        }
        if (!BfReadFile (IcoFileHandle, (PBYTE)(&iconDirBase), sizeof (ICONDIRBASE))) {
            __leave;
        }
        if (!BfSetFilePointer (IcoFileHandle, 0)) {
            __leave;
        }
        iconDirSize = sizeof (ICONDIRBASE) + iconDirBase.Count * sizeof (ICONDIRENTRY);
        // validation
        if (iconDirBase.Count == 0) {
            __leave;
        }
        if (iconDirSize > fileSize) {
            __leave;
        }
        iconDir = (PICONDIR) MemAlloc (g_hHeap, 0, iconDirSize);
        if (!BfReadFile (IcoFileHandle, (PBYTE)iconDir, iconDirSize)) {
            __leave;
        }
        // validation
        for (i = 0; i < iconDirBase.Count; i ++) {
            iconDirEntry = &iconDir->Entries[i];
            fileOffset = iconDirEntry->ImageOffset & 0x0fffffff;
            if (fileOffset > fileSize) {
                __leave;
            }
            if (iconDirEntry->Width == 0) {
                __leave;
            }
            if (iconDirEntry->Height == 0) {
                __leave;
            }
            if (iconDirEntry->BytesInRes == 0) {
                __leave;
            }
        }
        if (iconDirEntry->BytesInRes + fileOffset != fileSize) {
            __leave;
        }
        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }
        iconGroupSize = sizeof (ICON_GROUP) + iconDirBase.Count * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = iconDirBase.Count;
        for (i = 0; i < iconDirBase.Count; i ++) {
            iconDirEntry = &iconDir->Entries[i];
            fileOffset = iconDirEntry->ImageOffset & 0x0fffffff;
            if (!BfSetFilePointer (IcoFileHandle, fileOffset)) {
                __leave;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            if (!BfReadFile (IcoFileHandle, iconImage->Image, iconImage->Size)) {
                __leave;
            }
            iconGroup->Icons [i] = iconImage;
        }
        result = TRUE;
    }
    __finally {
        if (iconDir) {
            MemFree (g_hHeap, 0, iconDir);
            iconDir = NULL;
        }
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
        BfSetFilePointer (IcoFileHandle, 0);
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromIcoFileA (
    IN      PCSTR IcoFile
    )
/*++

Routine Description:

  IcoExtractIconGroupFromIcoFile extracts the icon group from an ICO file.

Arguments:

  IcoFile - Specifies the name of the ICO file to be processed.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE icoFileHandle;
    PICON_GROUP result = NULL;

    icoFileHandle = BfOpenReadFileA (IcoFile);
    if (!icoFileHandle) {
        return NULL;
    }
    result = IcoExtractIconGroupFromIcoFileEx (icoFileHandle);
    CloseHandle (icoFileHandle);
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromIcoFileW (
    IN      PCWSTR IcoFile
    )
/*++

Routine Description:

  IcoExtractIconGroupFromIcoFile extracts the icon group from an ICO file.

Arguments:

  IcoFile - Specifies the name of the ICO file to be processed.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE icoFileHandle;
    PICON_GROUP result = NULL;

    icoFileHandle = BfOpenReadFileW (IcoFile);
    if (!icoFileHandle) {
        return NULL;
    }
    result = IcoExtractIconGroupFromIcoFileEx (icoFileHandle);
    CloseHandle (icoFileHandle);
    return result;
}

BOOL
IcoWriteIconGroupToIcoFileEx (
    IN      HANDLE IcoFileHandle,
    IN      PICON_GROUP IconGroup
    )
/*++

Routine Description:

  IcoWriteIconGroupToIcoFileEx writes an icon group to an ICO file. The file has to exist and it's
  content will be overwritten.

Arguments:

  IcoFileHandle - Specifies the handle of the ICO file to be processed.
  IconGroup - Specifies the icon group to be written.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    PICONDIR iconDir = NULL;
    DWORD iconDirSize = 0;
    DWORD elapsedSize = 0;
    WORD i;
    BOOL result = FALSE;

    __try {
        if (!BfSetFilePointer (IcoFileHandle, 0)) {
            __leave;
        }
        iconDirSize = sizeof (ICONDIRBASE) + IconGroup->IconsCount * sizeof (ICONDIRENTRY);
        iconDir = (PICONDIR) MemAlloc (g_hHeap, 0, iconDirSize);
        ZeroMemory (iconDir, iconDirSize);
        iconDir->Type = 1;
        iconDir->Count = IconGroup->IconsCount;
        elapsedSize = iconDirSize;
        for (i = 0; i < IconGroup->IconsCount; i ++) {
            iconDir->Entries[i].Width = (IconGroup->Icons [i])->Width;
            iconDir->Entries[i].Height = (IconGroup->Icons [i])->Height;
            iconDir->Entries[i].ColorCount = (IconGroup->Icons [i])->ColorCount;
            iconDir->Entries[i].Planes = (IconGroup->Icons [i])->Planes;
            iconDir->Entries[i].BitCount = (IconGroup->Icons [i])->BitCount;
            iconDir->Entries[i].BytesInRes = (IconGroup->Icons [i])->Size;
            iconDir->Entries[i].ImageOffset = elapsedSize;
            elapsedSize += (IconGroup->Icons [i])->Size;
        }
        if (!BfWriteFile (IcoFileHandle, (PBYTE)iconDir, iconDirSize)) {
            __leave;
        }
        for (i = 0; i < IconGroup->IconsCount; i ++) {
            if (!BfWriteFile (IcoFileHandle, (IconGroup->Icons [i])->Image, (IconGroup->Icons [i])->Size)) {
                __leave;
            }
        }
        result = TRUE;
    }
    __finally {
    }

    return result;
}

BOOL
IcoWriteIconGroupToIcoFileA (
    IN      PCSTR IcoFile,
    IN      PICON_GROUP IconGroup,
    IN      BOOL OverwriteExisting
    )
/*++

Routine Description:

  IcoWriteIconGroupToIcoFile writes an icon group to an ICO file. The file is either created if
  does not exist or it is overwritten if OverwriteExisting is TRUE.

Arguments:

  IcoFile - Specifies the ICO file to be processed.
  IconGroup - Specifies the icon group to be written.
  OverwriteExisting - if TRUE and the IcoFile exists, it will be overwritten

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    HANDLE icoFileHandle;
    BOOL result = FALSE;

    if (DoesFileExistA (IcoFile)) {
        if (!OverwriteExisting) {
            return FALSE;
        }
    }
    icoFileHandle = BfCreateFileA (IcoFile);
    if (!icoFileHandle) {
        return FALSE;
    }
    result = IcoWriteIconGroupToIcoFileEx (icoFileHandle, IconGroup);
    CloseHandle (icoFileHandle);
    if (!result) {
        DeleteFileA (IcoFile);
    }
    return result;
}

BOOL
IcoWriteIconGroupToIcoFileW (
    IN      PCWSTR IcoFile,
    IN      PICON_GROUP IconGroup,
    IN      BOOL OverwriteExisting
    )
/*++

Routine Description:

  IcoWriteIconGroupToIcoFile writes an icon group to an ICO file. The file is either created if
  does not exist or it is overwritten if OverwriteExisting is TRUE.

Arguments:

  IcoFile - Specifies the ICO file to be processed.
  IconGroup - Specifies the icon group to be written.
  OverwriteExisting - if TRUE and the IcoFile exists, it will be overwritten

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    HANDLE icoFileHandle;
    BOOL result = FALSE;

    if (DoesFileExistW (IcoFile)) {
        if (!OverwriteExisting) {
            return FALSE;
        }
    }
    icoFileHandle = BfCreateFileW (IcoFile);
    if (!icoFileHandle) {
        return FALSE;
    }
    result = IcoWriteIconGroupToIcoFileEx (icoFileHandle, IconGroup);
    CloseHandle (icoFileHandle);
    if (!result) {
        DeleteFileW (IcoFile);
    }
    return result;
}

BOOL
CALLBACK
pPeEnumIconGroupA (
    HANDLE ModuleHandle,
    PCSTR Type,
    PSTR Name,
    LONG_PTR lParam
    )
{
    PGROWBUFFER Buf;
    PCSTR Num;
    CHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((ULONG_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfA (NumBuf, "#%u", Name);
    }

    GbMultiSzAppendA (Buf, Num);
    return TRUE;
}

BOOL
CALLBACK
pPeEnumIconGroupW (
    HANDLE ModuleHandle,
    PCWSTR Type,
    PWSTR Name,
    LONG_PTR lParam
    )
{
    PGROWBUFFER Buf;
    PCWSTR Num;
    WCHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((ULONG_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfW (NumBuf, L"#%u", Name);
    }

    GbMultiSzAppendW (Buf, Num);
    return TRUE;
}

INT
IcoGetIndexFromPeResourceIdExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromPeResourceIdEx returns the index of an icon group resource given the
  resource ID. It knows how to process only PE files.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    MULTISZ_ENUMA multiSzEnum;
    CHAR NumBuf[32];
    INT index = 0;
    BOOL result = FALSE;

    if ((ULONG_PTR) GroupIconId < 0x10000) {
        wsprintfA (NumBuf, "#%u", GroupIconId);
        GroupIconId = NumBuf;
    }
    if (EnumResourceNamesA (ModuleHandle, (PCSTR) RT_GROUP_ICON, pPeEnumIconGroupA, (LONG_PTR) (&buffer))) {
        GbMultiSzAppendA (&buffer, "");
        if (EnumFirstMultiSzA (&multiSzEnum, (PCSTR)(buffer.Buf))) {
            do {
                if (StringIMatchA (multiSzEnum.CurrentString, GroupIconId)) {
                    result = TRUE;
                    break;
                }
                index ++;
            } while (EnumNextMultiSzA (&multiSzEnum));
        }
    }
    if (!result) {
        index = -1;
    }
    return index;
}

INT
IcoGetIndexFromPeResourceIdExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromPeResourceIdEx returns the index of an icon group resource given the
  resource ID. It knows how to process only PE files.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    MULTISZ_ENUMW multiSzEnum;
    WCHAR NumBuf[32];
    INT index = 0;
    BOOL result = FALSE;

    if ((ULONG_PTR) GroupIconId < 0x10000) {
        wsprintfW (NumBuf, L"#%u", GroupIconId);
        GroupIconId = NumBuf;
    }
    if (EnumResourceNamesW (
            ModuleHandle,
            (PCWSTR) RT_GROUP_ICON,
            pPeEnumIconGroupW,
            (LONG_PTR) (&buffer)
            )) {
        GbMultiSzAppendW (&buffer, L"");
        if (EnumFirstMultiSzW (&multiSzEnum, (PCWSTR)(buffer.Buf))) {
            do {
                if (StringIMatchW (multiSzEnum.CurrentString, GroupIconId)) {
                    result = TRUE;
                    break;
                }
                index ++;
            } while (EnumNextMultiSzW (&multiSzEnum));
        }
    }
    if (!result) {
        index = -1;
    }
    return index;
}

INT
IcoGetIndexFromPeResourceIdA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromPeResourceId returns the index of an icon group resource given the
  resource ID. It knows how to process only PE files.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    HANDLE moduleHandle;
    INT result = -1;

    moduleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoGetIndexFromPeResourceIdExA (moduleHandle, GroupIconId);
        FreeLibrary (moduleHandle);
    }
    return result;
}

INT
IcoGetIndexFromPeResourceIdW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromPeResourceId returns the index of an icon group resource given the
  resource ID. It knows how to process only PE files.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    HANDLE moduleHandle;
    INT result = -1;

    moduleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoGetIndexFromPeResourceIdExW (moduleHandle, GroupIconId);
        FreeLibrary (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId,
    OUT     PINT Index              OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFileEx extracts an icon group from a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PGRPICONDIRENTRY iconDirEntry;
    HRSRC resourceHandle;
    HGLOBAL resourceBlock;
    PBYTE resourceData;
    DWORD resourceSize;
    PGRPICONDIR groupIconDir;
    WORD groupIconDirCount;
    WORD gap;
    WORD i;
    BOOL result = FALSE;

    __try {
        resourceHandle = FindResourceA (ModuleHandle, GroupIconId, (PCSTR) RT_GROUP_ICON);
        if (!resourceHandle) {
            __leave;
        }

        resourceBlock = LoadResource (ModuleHandle, resourceHandle);
        if (!resourceBlock) {
            __leave;
        }

        groupIconDir = (PGRPICONDIR) LockResource (resourceBlock);
        if (!groupIconDir) {
            __leave;
        }

        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }

        // First let's do some validation of all the icons from this icon group
        groupIconDirCount = groupIconDir->Count;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceHandle = FindResourceA (ModuleHandle, (PCSTR) (groupIconDir->Entries[i].ID), (PCSTR) RT_ICON);
            if (!resourceHandle) {
                groupIconDirCount --;
                continue;
            }
            resourceBlock = LoadResource (ModuleHandle, resourceHandle);
            if (!resourceBlock) {
                groupIconDirCount --;
                continue;
            }
            resourceData = (PBYTE) LockResource (resourceBlock);
            if (!resourceData) {
                FreeResource (resourceBlock);
                groupIconDirCount --;
                continue;
            }
            resourceSize = SizeofResource (ModuleHandle, resourceHandle);
            if (!resourceSize) {
                FreeResource (resourceBlock);
                groupIconDirCount --;
                continue;
            }
        }

        iconGroupSize = sizeof (ICON_GROUP) + groupIconDirCount * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = groupIconDirCount;
        gap = 0;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceHandle = FindResourceA (ModuleHandle, (PCSTR) (groupIconDir->Entries[i].ID), (PCSTR) RT_ICON);
            if (!resourceHandle) {
                gap ++;
                continue;
            }
            resourceBlock = LoadResource (ModuleHandle, resourceHandle);
            if (!resourceBlock) {
                gap ++;
                continue;
            }
            resourceData = (PBYTE) LockResource (resourceBlock);
            if (!resourceData) {
                FreeResource (resourceBlock);
                gap ++;
                continue;
            }
            resourceSize = SizeofResource (ModuleHandle, resourceHandle);
            if (!resourceSize) {
                FreeResource (resourceBlock);
                gap ++;
                continue;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconDirEntry = &groupIconDir->Entries[i];
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            if (iconImage->Size > resourceSize) {
                iconImage->Size = resourceSize;
            }
            iconImage->Id = iconDirEntry->ID;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            CopyMemory (iconImage->Image, resourceData, iconImage->Size);
            iconGroup->Icons [i - gap] = iconImage;
        }
        if (Index) {
            *Index = IcoGetIndexFromPeResourceIdExA (ModuleHandle, GroupIconId);
        }
        result = TRUE;
    }
    __finally {
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index              OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFileEx extracts an icon group from a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PGRPICONDIRENTRY iconDirEntry;
    HRSRC resourceHandle;
    HGLOBAL resourceBlock;
    PBYTE resourceData;
    DWORD resourceSize;
    PGRPICONDIR groupIconDir;
    WORD i;
    BOOL result = FALSE;

    __try {
        resourceHandle = FindResourceW (ModuleHandle, GroupIconId, (PCWSTR) RT_GROUP_ICON);
        if (!resourceHandle) {
            __leave;
        }

        resourceBlock = LoadResource (ModuleHandle, resourceHandle);
        if (!resourceBlock) {
            __leave;
        }

        groupIconDir = (PGRPICONDIR) LockResource (resourceBlock);
        if (!groupIconDir) {
            __leave;
        }

        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }

        iconGroupSize = sizeof (ICON_GROUP) + groupIconDir->Count * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = groupIconDir->Count;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceHandle = FindResourceW (ModuleHandle, (PCWSTR) (groupIconDir->Entries[i].ID), (PCWSTR) RT_ICON);
            if (!resourceHandle) {
                __leave;
            }
            resourceBlock = LoadResource (ModuleHandle, resourceHandle);
            if (!resourceBlock) {
                __leave;
            }
            resourceData = (PBYTE) LockResource (resourceBlock);
            if (!resourceData) {
                __leave;
            }
            resourceSize = SizeofResource (ModuleHandle, resourceHandle);
            if (!resourceSize) {
                __leave;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconDirEntry = &groupIconDir->Entries[i];
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            if (iconImage->Size > resourceSize) {
                iconImage->Size = resourceSize;
            }
            iconImage->Id = iconDirEntry->ID;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            CopyMemory (iconImage->Image, resourceData, iconImage->Size);
            iconGroup->Icons [i] = iconImage;
        }
        if (Index) {
            *Index = IcoGetIndexFromPeResourceIdExW (ModuleHandle, GroupIconId);
        }
        result = TRUE;
    }
    __finally {
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromPeFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFile extracts an icon group from a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoExtractIconGroupFromPeFileExA (moduleHandle, GroupIconId, Index);
        FreeLibrary (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromPeFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFile extracts an icon group from a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoExtractIconGroupFromPeFileExW (moduleHandle, GroupIconId, Index);
        FreeLibrary (moduleHandle);
    }
    return result;
}

VOID
IcoAbortPeEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoAbortPeEnumIconGroup terminates the icon group enumeration from a PE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        FreeLibrary (IconEnum->ModuleHandle);
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
}

VOID
IcoAbortPeEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoAbortPeEnumIconGroup terminates the icon group enumeration from a PE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        FreeLibrary (IconEnum->ModuleHandle);
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
}

BOOL
pEnumFirstIconGroupInPeFileExA (
    IN OUT  PICON_ENUMA IconEnum
    )
{
    BOOL result = FALSE;

    if (EnumResourceNamesA (
            IconEnum->ModuleHandle,
            (PCSTR) RT_GROUP_ICON,
            pPeEnumIconGroupA,
            (LONG_PTR) (&IconEnum->Buffer)
            )) {
        GbMultiSzAppendA (&IconEnum->Buffer, "");
        if (EnumFirstMultiSzA (&IconEnum->MultiSzEnum, (PCSTR)(IconEnum->Buffer.Buf))) {
            IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExA (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
            result = (IconEnum->IconGroup != NULL);
            if (result) {
                IconEnum->ResourceId = DuplicatePathStringA (IconEnum->MultiSzEnum.CurrentString, 0);
            }
        }
    }
    if (!result) {
        IcoAbortPeEnumIconGroupA (IconEnum);
    }
    return result;
}

BOOL
pEnumFirstIconGroupInPeFileExW (
    IN OUT  PICON_ENUMW IconEnum
    )
{
    BOOL result = FALSE;

    if (EnumResourceNamesW (
            IconEnum->ModuleHandle,
            (PCWSTR) RT_GROUP_ICON,
            pPeEnumIconGroupW,
            (LONG_PTR) (&IconEnum->Buffer)
            )) {
        GbMultiSzAppendW (&IconEnum->Buffer, L"");
        if (EnumFirstMultiSzW (&IconEnum->MultiSzEnum, (PCWSTR)(IconEnum->Buffer.Buf))) {
            IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExW (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
            result = (IconEnum->IconGroup != NULL);
            if (result) {
                IconEnum->ResourceId = DuplicatePathStringW (IconEnum->MultiSzEnum.CurrentString, 0);
            }
        }
    }
    if (!result) {
        IcoAbortPeEnumIconGroupW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInPeFileExA (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInPeFileEx starts the icon group enumeration from a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    IconEnum->FreeHandle = FALSE;
    IconEnum->ModuleHandle = ModuleHandle;
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInPeFileExA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInPeFileExW (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInPeFileEx starts the icon group enumeration from a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    IconEnum->FreeHandle = FALSE;
    IconEnum->ModuleHandle = ModuleHandle;
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInPeFileExW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInPeFileA (
    IN      PCSTR ModuleName,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInPeFile starts the icon group enumeration from a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    IconEnum->FreeHandle = TRUE;
    IconEnum->ModuleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInPeFileExA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInPeFileW (
    IN      PCWSTR ModuleName,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInPeFile starts the icon group enumeration from a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    IconEnum->FreeHandle = TRUE;
    IconEnum->ModuleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInPeFileExW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumNextIconGroupInPeFileA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInPeFile continues the icon group enumeration from a PE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
        IconEnum->IconGroup = NULL;
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    if (EnumNextMultiSzA (&IconEnum->MultiSzEnum)) {
        IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExA (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
        result = (IconEnum->IconGroup != NULL);
        if (result) {
            IconEnum->ResourceId = DuplicatePathStringA (IconEnum->MultiSzEnum.CurrentString, 0);
            IconEnum->Index ++;
        }
    }
    if (!result) {
        IcoAbortPeEnumIconGroupA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumNextIconGroupInPeFileW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInPeFile continues the icon group enumeration from a PE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
        IconEnum->IconGroup = NULL;
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    if (EnumNextMultiSzW (&IconEnum->MultiSzEnum)) {
        IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExW (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
        result = (IconEnum->IconGroup != NULL);
        if (result) {
            IconEnum->ResourceId = DuplicatePathStringW (IconEnum->MultiSzEnum.CurrentString, 0);
            IconEnum->Index ++;
        }
    }
    if (!result) {
        IcoAbortPeEnumIconGroupW (IconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromPeFileEx extracts an icon group from a PE file
  using the Index.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    ICON_ENUMA iconEnum;
    PICON_GROUP result = NULL;

    if (IcoEnumFirstIconGroupInPeFileExA (ModuleHandle, &iconEnum)) {
        do {
            if (iconEnum.Index == Index) {
                result = iconEnum.IconGroup;
                iconEnum.IconGroup = NULL;
                if (GroupIconId) {
                    *GroupIconId = iconEnum.ResourceId;
                    iconEnum.ResourceId = NULL;
                }
                break;
            }
        } while (IcoEnumNextIconGroupInPeFileA (&iconEnum));
        IcoAbortPeEnumIconGroupA (&iconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromPeFileEx extracts an icon group from a PE file
  using the Index.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    ICON_ENUMW iconEnum;
    PICON_GROUP result = NULL;

    if (IcoEnumFirstIconGroupInPeFileExW (ModuleHandle, &iconEnum)) {
        do {
            if (iconEnum.Index == Index) {
                result = iconEnum.IconGroup;
                iconEnum.IconGroup = NULL;
                if (GroupIconId) {
                    *GroupIconId = iconEnum.ResourceId;
                    iconEnum.ResourceId = NULL;
                }
                break;
            }
        } while (IcoEnumNextIconGroupInPeFileW (&iconEnum));
        IcoAbortPeEnumIconGroupW (&iconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFile extracts an icon group from a PE file
  using the Index

Arguments:

  ModuleName - Specifies the PE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoExtractIconGroupByIndexFromPeFileExA (moduleHandle, Index, GroupIconId);
        FreeLibrary (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFile extracts an icon group from a PE file
  using the Index

Arguments:

  ModuleName - Specifies the PE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoExtractIconGroupByIndexFromPeFileExW (moduleHandle, Index, GroupIconId);
        FreeLibrary (moduleHandle);
    }
    return result;
}

WORD
pGetAvailableResourceA (
    IN      HANDLE ModuleHandle,
    IN      WORD StartIndex,
    IN      PCSTR ResourceType
    )
{
    WORD lastIndex = StartIndex;
    HRSRC resourceHandle;
    BOOL result = FALSE;

    if (lastIndex == 0) {
        lastIndex ++;
    }

    do {
        resourceHandle = FindResourceA (ModuleHandle, MAKEINTRESOURCEA (lastIndex), ResourceType);
        if (!resourceHandle) {
            break;
        }
        lastIndex ++;
        if (lastIndex == 0) {
            break;
        }
    } while (TRUE);

    return lastIndex;
}

WORD
pGetAvailableResourceW (
    IN      HANDLE ModuleHandle,
    IN      WORD StartIndex,
    IN      PCWSTR ResourceType
    )
{
    WORD lastIndex = StartIndex;
    HRSRC resourceHandle;
    BOOL result = FALSE;

    if (lastIndex == 0) {
        lastIndex ++;
    }

    do {
        resourceHandle = FindResourceW (ModuleHandle, MAKEINTRESOURCEW (lastIndex), ResourceType);
        if (!resourceHandle) {
            break;
        }
        lastIndex ++;
        if (lastIndex == 0) {
            break;
        }
    } while (TRUE);

    return lastIndex;
}

BOOL
IcoWriteIconGroupToPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      HANDLE UpdateHandle,
    IN      PICON_GROUP IconGroup,
    OUT     PCSTR *ResourceId       OPTIONAL
    )
/*++

Routine Description:

  IcoWriteIconGroupToPeFileEx writes an icon group resource to a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  UpdateHandle - Specifies the resource update handle (returned by BeginUpdateResource).
  IconGroup - Specifies the icon group to be inserted.
  ResourceId - Receives the resource ID allocated for the newly inserted icon group.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    WORD lastIndex = 0;
    WORD lastIconIndex = 0;
    PGRPICONDIR groupIconDir = NULL;
    DWORD groupIconDirSize;
    WORD i;
    BOOL result = FALSE;

    __try {
        lastIndex = pGetAvailableResourceA (ModuleHandle, lastIndex, (PCSTR) RT_GROUP_ICON);
        if (lastIndex == 0) {
            // no more room for resources
            __leave;
        }
        groupIconDirSize = sizeof (GRPICONDIRBASE) + IconGroup->IconsCount * sizeof (GRPICONDIRENTRY);
        groupIconDir = MemAlloc (g_hHeap, 0, groupIconDirSize);
        ZeroMemory (groupIconDir, groupIconDirSize);
        groupIconDir->Type = 1;
        groupIconDir->Count = IconGroup->IconsCount;
        for (i = 0; i < groupIconDir->Count; i ++) {
            groupIconDir->Entries[i].Width = IconGroup->Icons[i]->Width;
            groupIconDir->Entries[i].Height = IconGroup->Icons[i]->Height;
            groupIconDir->Entries[i].ColorCount = IconGroup->Icons[i]->ColorCount;
            groupIconDir->Entries[i].Planes = IconGroup->Icons[i]->Planes;
            groupIconDir->Entries[i].BitCount = IconGroup->Icons[i]->BitCount;
            groupIconDir->Entries[i].BytesInRes = IconGroup->Icons[i]->Size;
            lastIconIndex = pGetAvailableResourceA (ModuleHandle, lastIconIndex, (PCSTR) RT_ICON);
            groupIconDir->Entries[i].ID = lastIconIndex;
            lastIconIndex ++;
        }
        for (i = 0; i < groupIconDir->Count; i ++) {
            if (!UpdateResourceA (
                    UpdateHandle,
                    (PCSTR) RT_ICON,
                    MAKEINTRESOURCEA (groupIconDir->Entries[i].ID),
                    MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                    IconGroup->Icons[i]->Image,
                    IconGroup->Icons[i]->Size
                    )) {
                __leave;
            }
        }
        if (!UpdateResourceA (
                UpdateHandle,
                (PCSTR) RT_GROUP_ICON,
                MAKEINTRESOURCEA (lastIndex),
                MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                groupIconDir,
                groupIconDirSize
                )) {
            __leave;
        }
        if (ResourceId) {
            *ResourceId = MAKEINTRESOURCEA (lastIndex);
        }
        result = TRUE;
    }
    __finally {
        if (groupIconDir) {
            MemFree (g_hHeap, 0, groupIconDir);
        }
    }
    return result;
}


BOOL
IcoWriteIconGroupToPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      HANDLE UpdateHandle,
    IN      PICON_GROUP IconGroup,
    OUT     PCWSTR *ResourceId      OPTIONAL
    )
/*++

Routine Description:

  IcoWriteIconGroupToPeFileEx writes an icon group resource to a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  UpdateHandle - Specifies the resource update handle (returned by BeginUpdateResource).
  IconGroup - Specifies the icon group to be inserted.
  ResourceId - Receives the resource ID allocated for the newly inserted icon group.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    WORD lastIndex = 0;
    WORD lastIconIndex = 0;
    PGRPICONDIR groupIconDir = NULL;
    DWORD groupIconDirSize;
    WORD i;
    BOOL result = FALSE;

    __try {
        lastIndex = pGetAvailableResourceW (ModuleHandle, lastIndex, (PCWSTR) RT_GROUP_ICON);
        if (lastIndex == 0) {
            // no more room for resources
            __leave;
        }
        groupIconDirSize = sizeof (GRPICONDIRBASE) + IconGroup->IconsCount * sizeof (GRPICONDIRENTRY);
        groupIconDir = MemAlloc (g_hHeap, 0, groupIconDirSize);
        ZeroMemory (groupIconDir, groupIconDirSize);
        groupIconDir->Type = 1;
        groupIconDir->Count = IconGroup->IconsCount;
        for (i = 0; i < groupIconDir->Count; i ++) {
            groupIconDir->Entries[i].Width = IconGroup->Icons[i]->Width;
            groupIconDir->Entries[i].Height = IconGroup->Icons[i]->Height;
            groupIconDir->Entries[i].ColorCount = IconGroup->Icons[i]->ColorCount;
            groupIconDir->Entries[i].Planes = IconGroup->Icons[i]->Planes;
            groupIconDir->Entries[i].BitCount = IconGroup->Icons[i]->BitCount;
            groupIconDir->Entries[i].BytesInRes = IconGroup->Icons[i]->Size;
            lastIconIndex = pGetAvailableResourceW (ModuleHandle, lastIconIndex, (PCWSTR) RT_ICON);
            groupIconDir->Entries[i].ID = lastIconIndex;
            lastIconIndex ++;
        }
        for (i = 0; i < groupIconDir->Count; i ++) {
            if (!UpdateResourceW (
                    UpdateHandle,
                    (PCWSTR) RT_ICON,
                    MAKEINTRESOURCEW (groupIconDir->Entries[i].ID),
                    MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                    IconGroup->Icons[i]->Image,
                    IconGroup->Icons[i]->Size
                    )) {
                __leave;
            }
        }
        if (!UpdateResourceW (
                UpdateHandle,
                (PCWSTR) RT_GROUP_ICON,
                MAKEINTRESOURCEW (lastIndex),
                MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                groupIconDir,
                groupIconDirSize
                )) {
            __leave;
        }
        if (ResourceId) {
            *ResourceId = MAKEINTRESOURCEW (lastIndex);
        }
        result = TRUE;
    }
    __finally {
        if (groupIconDir) {
            MemFree (g_hHeap, 0, groupIconDir);
        }
    }
    return result;
}

BOOL
IcoWriteIconGroupToPeFileA (
    IN      PCSTR ModuleName,
    IN      PICON_GROUP IconGroup,
    OUT     PCSTR *ResourceId,      OPTIONAL
    OUT     PINT Index              OPTIONAL
    )
/*++

Routine Description:

  IcoWriteIconGroupToPeFile writes an icon group resource to a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  IconGroup - Specifies the icon group to be inserted.
  ResourceId - Receives the resource ID allocated for the newly inserted icon group.
  Index - Receives the index of the newly inserted icon group.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    HANDLE moduleHandle = NULL;
    HANDLE updateHandle = NULL;
    PCSTR resourceId;
    BOOL result = FALSE;

    updateHandle = BeginUpdateResourceA (ModuleName, FALSE);
    if (updateHandle) {
        //printf ("BeginUpdateResource\n");
        moduleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (moduleHandle) {
            //printf ("IcoWriteIconGroupToPeFileExA\n");
            result = IcoWriteIconGroupToPeFileExA (moduleHandle, updateHandle, IconGroup, &resourceId);
            FreeLibrary (moduleHandle);
        }
        if (result) {
            //printf ("EndUpdateResource\n");
            result = EndUpdateResource (updateHandle, FALSE);
            if (result) {
                if (ResourceId) {
                    *ResourceId = resourceId;
                } else {
                    IcoReleaseResourceIdA (resourceId);
                }
                if (Index) {
                    *Index = IcoGetIndexFromPeResourceIdA (ModuleName, resourceId);
                }
            }
        } else {
            EndUpdateResource (updateHandle, TRUE);
        }
    }
    //printf ("return\n");
    return result;
}

BOOL
IcoWriteIconGroupToPeFileW (
    IN      PCWSTR ModuleName,
    IN      PICON_GROUP IconGroup,
    OUT     PCWSTR *ResourceId,     OPTIONAL
    OUT     PINT Index              OPTIONAL
    )
/*++

Routine Description:

  IcoWriteIconGroupToPeFile writes an icon group resource to a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  IconGroup - Specifies the icon group to be inserted.
  ResourceId - Receives the resource ID allocated for the newly inserted icon group.
  Index - Receives the index of the newly inserted icon group.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    HANDLE moduleHandle = NULL;
    HANDLE updateHandle = NULL;
    PCWSTR resourceId;
    BOOL result = FALSE;

    updateHandle = BeginUpdateResourceW (ModuleName, FALSE);
    if (updateHandle) {
        moduleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (moduleHandle) {
            result = IcoWriteIconGroupToPeFileExW (moduleHandle, updateHandle, IconGroup, &resourceId);
            FreeLibrary (moduleHandle);
        }
        if (result) {
            result = EndUpdateResource (updateHandle, FALSE);
            if (result) {
                if (ResourceId) {
                    *ResourceId = resourceId;
                } else {
                    IcoReleaseResourceIdW (resourceId);
                }
                if (Index) {
                    *Index = IcoGetIndexFromPeResourceIdW (ModuleName, resourceId);
                }
            }
        } else {
            EndUpdateResource (updateHandle, TRUE);
        }
    }
    return result;
}

BOOL
pNeEnumIconGroupA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name,
    IN      LPARAM lParam
    )
{
    PGROWBUFFER Buf;
    PCSTR Num;
    CHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((ULONG_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfA (NumBuf, "#%u", Name);
    }

    GbMultiSzAppendA (Buf, Num);
    return TRUE;
}

BOOL
pNeEnumIconGroupW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name,
    IN      LPARAM lParam
    )
{
    PGROWBUFFER Buf;
    PCWSTR Num;
    WCHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((ULONG_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfW (NumBuf, L"#%u", Name);
    }

    GbMultiSzAppendW (Buf, Num);
    return TRUE;
}

INT
IcoGetIndexFromNeResourceIdExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromNeResourceIdEx returns the index of an icon group resource given the
  resource ID. It knows how to process only NE files.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    MULTISZ_ENUMA multiSzEnum;
    CHAR NumBuf[32];
    INT index = 0;
    BOOL result = FALSE;

    if ((ULONG_PTR) GroupIconId < 0x10000) {
        wsprintfA (NumBuf, "#%u", GroupIconId);
        GroupIconId = NumBuf;
    }

    if (NeEnumResourceNamesA (
            ModuleHandle,
            (PCSTR) RT_GROUP_ICON,
            pNeEnumIconGroupA,
            (LONG_PTR) (&buffer)
            )) {

        GbMultiSzAppendA (&buffer, "");
        if (EnumFirstMultiSzA (&multiSzEnum, (PCSTR)(buffer.Buf))) {
            do {
                if (StringIMatchA (multiSzEnum.CurrentString, GroupIconId)) {
                    result = TRUE;
                    break;
                }
                index ++;
            } while (EnumNextMultiSzA (&multiSzEnum));
        }
    }
    if (!result) {
        index = -1;
    }
    return index;
}

INT
IcoGetIndexFromNeResourceIdExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromNeResourceIdEx returns the index of an icon group resource given the
  resource ID. It knows how to process only NE files.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    MULTISZ_ENUMW multiSzEnum;
    WCHAR NumBuf[32];
    INT index = 0;
    BOOL result = FALSE;

    if ((ULONG_PTR) GroupIconId < 0x10000) {
        wsprintfW (NumBuf, L"#%u", GroupIconId);
        GroupIconId = NumBuf;
    }

    if (NeEnumResourceNamesW (
            ModuleHandle,
            (PCWSTR) RT_GROUP_ICON,
            pNeEnumIconGroupW,
            (LONG_PTR) (&buffer)
            )) {

        GbMultiSzAppendW (&buffer, L"");
        if (EnumFirstMultiSzW (&multiSzEnum, (PCWSTR)(buffer.Buf))) {
            do {
                if (StringIMatchW (multiSzEnum.CurrentString, GroupIconId)) {
                    result = TRUE;
                    break;
                }
                index ++;
            } while (EnumNextMultiSzW (&multiSzEnum));
        }
    }
    if (!result) {
        index = -1;
    }
    return index;
}

INT
IcoGetIndexFromNeResourceIdA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromNeResourceId returns the index of an icon group resource given the
  resource ID. It knows how to process only NE files.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    HANDLE moduleHandle;
    INT result = -1;

    moduleHandle = NeOpenFileA (ModuleName);
    if (moduleHandle) {
        result = IcoGetIndexFromNeResourceIdExA (moduleHandle, GroupIconId);
        NeCloseFile (moduleHandle);
    }
    return result;
}

INT
IcoGetIndexFromNeResourceIdW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromNeResourceId returns the index of an icon group resource given the
  resource ID. It knows how to process only NE files.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    HANDLE moduleHandle;
    INT result = -1;

    moduleHandle = NeOpenFileW (ModuleName);
    if (moduleHandle) {
        result = IcoGetIndexFromNeResourceIdExW (moduleHandle, GroupIconId);
        NeCloseFile (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromNeFileExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFileEx extracts an icon group from a NE file.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PGRPICONDIRENTRY iconDirEntry;
    PBYTE resourceData;
    DWORD resourceSize;
    PGRPICONDIR groupIconDir;
    WORD i;
    BOOL result = FALSE;

    __try {
        groupIconDir = (PGRPICONDIR) NeFindResourceExA (ModuleHandle, (PCSTR) RT_GROUP_ICON, GroupIconId);
        if (!groupIconDir) {
            __leave;
        }
        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }

        iconGroupSize = sizeof (ICON_GROUP) + groupIconDir->Count * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = groupIconDir->Count;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceData = NeFindResourceExA (
                                ModuleHandle,
                                (PCSTR) RT_ICON,
                                (PCSTR) groupIconDir->Entries[i].ID
                                );

            if (!resourceData) {
                __leave;
            }

            resourceSize = NeSizeofResourceA (
                                ModuleHandle,
                                (PCSTR) RT_ICON,
                                (PCSTR) groupIconDir->Entries[i].ID
                                );
            if (!resourceSize) {
                __leave;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconDirEntry = &groupIconDir->Entries[i];
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            if (iconImage->Size > resourceSize) {
                iconImage->Size = resourceSize;
            }
            iconImage->Id = iconDirEntry->ID;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            CopyMemory (iconImage->Image, resourceData, iconImage->Size);
            iconGroup->Icons [i] = iconImage;
        }
        if (Index) {
            *Index = IcoGetIndexFromNeResourceIdExA (ModuleHandle, GroupIconId);
        }
        result = TRUE;
    }
    __finally {
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromNeFileExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFileEx extracts an icon group from a NE file.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PGRPICONDIRENTRY iconDirEntry;
    PBYTE resourceData;
    DWORD resourceSize;
    PGRPICONDIR groupIconDir;
    WORD i;
    BOOL result = FALSE;

    __try {
        groupIconDir = (PGRPICONDIR) NeFindResourceExW (ModuleHandle, (PCWSTR) RT_GROUP_ICON, GroupIconId);
        if (!groupIconDir) {
            __leave;
        }
        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }

        iconGroupSize = sizeof (ICON_GROUP) + groupIconDir->Count * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = groupIconDir->Count;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceData = NeFindResourceExW (
                                ModuleHandle,
                                (PCWSTR) RT_ICON,
                                (PCWSTR) groupIconDir->Entries[i].ID
                                );

            if (!resourceData) {
                __leave;
            }

            resourceSize = NeSizeofResourceW (
                                ModuleHandle,
                                (PCWSTR) RT_ICON,
                                (PCWSTR) groupIconDir->Entries[i].ID
                                );
            if (!resourceSize) {
                __leave;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconDirEntry = &groupIconDir->Entries[i];
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            if (iconImage->Size > resourceSize) {
                iconImage->Size = resourceSize;
            }
            iconImage->Id = iconDirEntry->ID;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            CopyMemory (iconImage->Image, resourceData, iconImage->Size);
            iconGroup->Icons [i] = iconImage;
        }
        if (Index) {
            *Index = IcoGetIndexFromNeResourceIdExW (ModuleHandle, GroupIconId);
        }
        result = TRUE;
    }
    __finally {
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromNeFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFile extracts an icon group from a NE file.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = NeOpenFileA (ModuleName);
    if (moduleHandle) {
        result = IcoExtractIconGroupFromNeFileExA (moduleHandle, GroupIconId, Index);
        NeCloseFile (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromNeFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFile extracts an icon group from a NE file.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = NeOpenFileW (ModuleName);
    if (moduleHandle) {
        result = IcoExtractIconGroupFromNeFileExW (moduleHandle, GroupIconId, Index);
        NeCloseFile (moduleHandle);
    }
    return result;
}

VOID
IcoAbortNeEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoAbortNeEnumIconGroup terminates the icon group enumeration from a NE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        NeCloseFile (IconEnum->ModuleHandle);
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
}

VOID
IcoAbortNeEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoAbortNeEnumIconGroup terminates the icon group enumeration from a NE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        NeCloseFile (IconEnum->ModuleHandle);
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
}

BOOL
pEnumFirstIconGroupInNeFileExA (
    IN OUT  PICON_ENUMA IconEnum
    )
{
    BOOL result = FALSE;

    if (NeEnumResourceNamesA (
            IconEnum->ModuleHandle,
            (PCSTR) RT_GROUP_ICON,
            pNeEnumIconGroupA,
            (LONG_PTR) (&IconEnum->Buffer)
            )) {
        GbMultiSzAppendA (&IconEnum->Buffer, "");
        if (EnumFirstMultiSzA (&IconEnum->MultiSzEnum, (PCSTR)(IconEnum->Buffer.Buf))) {
            IconEnum->IconGroup = IcoExtractIconGroupFromNeFileExA (
                                        IconEnum->ModuleHandle,
                                        IconEnum->MultiSzEnum.CurrentString,
                                        NULL
                                        );
            result = (IconEnum->IconGroup != NULL);
            if (result) {
                IconEnum->ResourceId = DuplicatePathStringA (IconEnum->MultiSzEnum.CurrentString, 0);
            }
        }
    }
    if (!result) {
        IcoAbortNeEnumIconGroupA (IconEnum);
    }
    return result;
}

BOOL
pEnumFirstIconGroupInNeFileExW (
    IN OUT  PICON_ENUMW IconEnum
    )
{
    BOOL result = FALSE;

    if (NeEnumResourceNamesW (
            IconEnum->ModuleHandle,
            (PCWSTR) RT_GROUP_ICON,
            pNeEnumIconGroupW,
            (LONG_PTR) (&IconEnum->Buffer)
            )) {

        GbMultiSzAppendW (&IconEnum->Buffer, L"");
        if (EnumFirstMultiSzW (&IconEnum->MultiSzEnum, (PCWSTR)(IconEnum->Buffer.Buf))) {
            IconEnum->IconGroup = IcoExtractIconGroupFromNeFileExW (
                                        IconEnum->ModuleHandle,
                                        IconEnum->MultiSzEnum.CurrentString,
                                        NULL
                                        );

            result = (IconEnum->IconGroup != NULL);
            if (result) {
                IconEnum->ResourceId = DuplicatePathStringW (IconEnum->MultiSzEnum.CurrentString, 0);
            }
        }
    }
    if (!result) {
        IcoAbortNeEnumIconGroupW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInNeFileExA (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInNeFileEx starts the icon group enumeration from a NE file.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    IconEnum->FreeHandle = FALSE;
    IconEnum->ModuleHandle = ModuleHandle;
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInNeFileExA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInNeFileExW (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInNeFileEx starts the icon group enumeration from a NE file.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    IconEnum->FreeHandle = FALSE;
    IconEnum->ModuleHandle = ModuleHandle;
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInNeFileExW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInNeFileA (
    IN      PCSTR ModuleName,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInNeFile starts the icon group enumeration from a NE file.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    IconEnum->FreeHandle = TRUE;
    IconEnum->ModuleHandle = NeOpenFileA (ModuleName);
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInNeFileExA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInNeFileW (
    IN      PCWSTR ModuleName,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInNeFile starts the icon group enumeration from a NE file.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    IconEnum->FreeHandle = TRUE;
    IconEnum->ModuleHandle = NeOpenFileW (ModuleName);
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInNeFileExW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumNextIconGroupInNeFileA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInNeFile continues the icon group enumeration from a NE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
        IconEnum->IconGroup = NULL;
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    if (EnumNextMultiSzA (&IconEnum->MultiSzEnum)) {
        IconEnum->IconGroup = IcoExtractIconGroupFromNeFileExA (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
        result = (IconEnum->IconGroup != NULL);
        if (result) {
            IconEnum->ResourceId = DuplicatePathStringA (IconEnum->MultiSzEnum.CurrentString, 0);
            IconEnum->Index ++;
        }
    }
    if (!result) {
        IcoAbortNeEnumIconGroupA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumNextIconGroupInNeFileW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInNeFile continues the icon group enumeration from a NE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
        IconEnum->IconGroup = NULL;
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    if (EnumNextMultiSzW (&IconEnum->MultiSzEnum)) {
        IconEnum->IconGroup = IcoExtractIconGroupFromNeFileExW (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
        result = (IconEnum->IconGroup != NULL);
        if (result) {
            IconEnum->ResourceId = DuplicatePathStringW (IconEnum->MultiSzEnum.CurrentString, 0);
            IconEnum->Index ++;
        }
    }
    if (!result) {
        IcoAbortNeEnumIconGroupW (IconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileExA (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromNeFileEx extracts an icon group from a NE file
  using the Index.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    ICON_ENUMA iconEnum;
    PICON_GROUP result = NULL;

    if (IcoEnumFirstIconGroupInNeFileExA (ModuleHandle, &iconEnum)) {
        do {
            if (iconEnum.Index == Index) {
                result = iconEnum.IconGroup;
                iconEnum.IconGroup = NULL;
                if (GroupIconId) {
                    *GroupIconId = iconEnum.ResourceId;
                    iconEnum.ResourceId = NULL;
                }
                break;
            }
        } while (IcoEnumNextIconGroupInNeFileA (&iconEnum));
        IcoAbortNeEnumIconGroupA (&iconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileExW (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromNeFileEx extracts an icon group from a NE file
  using the Index.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    ICON_ENUMW iconEnum;
    PICON_GROUP result = NULL;

    if (IcoEnumFirstIconGroupInNeFileExW (ModuleHandle, &iconEnum)) {
        do {
            if (iconEnum.Index == Index) {
                result = iconEnum.IconGroup;
                iconEnum.IconGroup = NULL;
                if (GroupIconId) {
                    *GroupIconId = iconEnum.ResourceId;
                    iconEnum.ResourceId = NULL;
                }
                break;
            }
        } while (IcoEnumNextIconGroupInNeFileW (&iconEnum));
        IcoAbortNeEnumIconGroupW (&iconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFile extracts an icon group from a NE file
  using the Index.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = NeOpenFileA (ModuleName);
    if (moduleHandle) {
        result = IcoExtractIconGroupByIndexFromNeFileExA (moduleHandle, Index, GroupIconId);
        NeCloseFile (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFile extracts an icon group from a NE file
  using the Index.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = NeOpenFileW (ModuleName);
    if (moduleHandle) {
        result = IcoExtractIconGroupByIndexFromNeFileExW (moduleHandle, Index, GroupIconId);
        NeCloseFile (moduleHandle);
    }
    return result;
}

VOID
IcoAbortEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoAbortEnumIconGroup terminates the icon group enumeration from a ICO, PE or NE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        if (IconEnum->FileType == ICON_PEFILE) {
            FreeLibrary (IconEnum->ModuleHandle);
        }
        if (IconEnum->FileType == ICON_NEFILE) {
            NeCloseFile (IconEnum->ModuleHandle);
        }
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
}

VOID
IcoAbortEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoAbortEnumIconGroup terminates the icon group enumeration from a ICO, PE or NE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        if (IconEnum->FileType == ICON_PEFILE) {
            FreeLibrary (IconEnum->ModuleHandle);
        }
        if (IconEnum->FileType == ICON_NEFILE) {
            NeCloseFile (IconEnum->ModuleHandle);
        }
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
}

BOOL
IcoEnumFirstIconGroupInFileA (
    IN      PCSTR FileName,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInFile starts the icon group enumeration from a ICO, PE or NE file.

Arguments:

  ModuleName - Specifies the ICO, PE or NE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    if (IcoEnumFirstIconGroupInPeFileA (FileName, IconEnum)) {
        IconEnum->FileType = ICON_PEFILE;
        return TRUE;
    }
    if (IcoEnumFirstIconGroupInNeFileA (FileName, IconEnum)) {
        IconEnum->FileType = ICON_NEFILE;
        return TRUE;
    }
    IconEnum->IconGroup = IcoExtractIconGroupFromIcoFileA (FileName);
    if (IconEnum->IconGroup) {
        IconEnum->FileType = ICON_ICOFILE;
        return TRUE;
    }
    return FALSE;
}

BOOL
IcoEnumFirstIconGroupInFileW (
    IN      PCWSTR FileName,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInFile starts the icon group enumeration from a ICO, PE or NE file.

Arguments:

  ModuleName - Specifies the ICO, PE or NE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    if (IcoEnumFirstIconGroupInPeFileW (FileName, IconEnum)) {
        IconEnum->FileType = ICON_PEFILE;
        return TRUE;
    }
    if (IcoEnumFirstIconGroupInNeFileW (FileName, IconEnum)) {
        IconEnum->FileType = ICON_NEFILE;
        return TRUE;
    }
    IconEnum->IconGroup = IcoExtractIconGroupFromIcoFileW (FileName);
    if (IconEnum->IconGroup) {
        IconEnum->FileType = ICON_ICOFILE;
        return TRUE;
    }
    return FALSE;
}

BOOL
IcoEnumNextIconGroupInFileA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInFile continues the icon group enumeration from a ICO, PE or NE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    if (IconEnum->FileType == ICON_ICOFILE) {
        IcoAbortEnumIconGroupA (IconEnum);
        return FALSE;
    }
    if (IconEnum->FileType == ICON_PEFILE) {
        return IcoEnumNextIconGroupInPeFileA (IconEnum);
    }
    if (IconEnum->FileType == ICON_NEFILE) {
        return IcoEnumNextIconGroupInNeFileA (IconEnum);
    }
    return FALSE;
}

BOOL
IcoEnumNextIconGroupInFileW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInFile continues the icon group enumeration from a ICO, PE or NE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    if (IconEnum->FileType == ICON_ICOFILE) {
        IcoAbortEnumIconGroupW (IconEnum);
        return FALSE;
    }
    if (IconEnum->FileType == ICON_PEFILE) {
        return IcoEnumNextIconGroupInPeFileW (IconEnum);
    }
    if (IconEnum->FileType == ICON_NEFILE) {
        return IcoEnumNextIconGroupInNeFileW (IconEnum);
    }
    return FALSE;
}

PICON_GROUP
IcoExtractIconGroupFromFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromFile extracts an icon group from a ICO, PE or NE file.

Arguments:

  ModuleName - Specifies the file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PICON_GROUP result = NULL;

    // assume that this is a PE file
    result = IcoExtractIconGroupFromPeFileA (ModuleName, GroupIconId, Index);
    if (result) {
        return result;
    }
    // assume that this is a NE file
    result = IcoExtractIconGroupFromNeFileA (ModuleName, GroupIconId, Index);
    if (result) {
        return result;
    }
    // finally, assume that this is a ICO file, verify that
    // the GroupIconId is zero
    if (GroupIconId == NULL) {
        result = IcoExtractIconGroupFromIcoFileA (ModuleName);
        if (result && Index) {
            *Index = 0;
        }
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromFile extracts an icon group from a ICO, PE or NE file.

Arguments:

  ModuleName - Specifies the file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PICON_GROUP result = NULL;

    // assume that this is a PE file
    result = IcoExtractIconGroupFromPeFileW (ModuleName, GroupIconId, Index);
    if (result) {
        return result;
    }
    // assume that this is a NE file
    result = IcoExtractIconGroupFromNeFileW (ModuleName, GroupIconId, Index);
    if (result) {
        return result;
    }
    // finally, assume that this is a ICO file, verify that
    // the GroupIconId is zero
    if (GroupIconId == NULL) {
        result = IcoExtractIconGroupFromIcoFileW (ModuleName);
        if (result && Index) {
            *Index = 0;
        }
        return result;
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromFile extracts an icon group from a ICO, PE or NE file
  using the Index.

Arguments:

  ModuleName - Specifies the file to be processed.
  Index - Specifies the index of the icon groupto be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PICON_GROUP result = NULL;

    // assume that this is a PE file
    result = IcoExtractIconGroupByIndexFromPeFileA (ModuleName, Index, GroupIconId);
    if (result) {
        return result;
    }
    // assume that this is a NE file
    result = IcoExtractIconGroupByIndexFromNeFileA (ModuleName, Index, GroupIconId);
    if (result) {
        return result;
    }
    // finally, assume that this is a ICO file, verify that
    // the Index is zero
    if (Index == 0) {
        result = IcoExtractIconGroupFromIcoFileA (ModuleName);
        if (result && GroupIconId) {
            *GroupIconId = NULL;
        }
        return result;
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromFile extracts an icon group from a ICO, PE or NE file
  using the Index.

Arguments:

  ModuleName - Specifies the file to be processed.
  Index - Specifies the index of the icon groupto be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PICON_GROUP result = NULL;

    // assume that this is a PE file
    result = IcoExtractIconGroupByIndexFromPeFileW (ModuleName, Index, GroupIconId);
    if (result) {
        return result;
    }
    // assume that this is a NE file
    result = IcoExtractIconGroupByIndexFromNeFileW (ModuleName, Index, GroupIconId);
    if (result) {
        return result;
    }
    // finally, assume that this is a ICO file, verify that
    // the Index is zero
    if (Index == 0) {
        result = IcoExtractIconGroupFromIcoFileW (ModuleName);
        if (result && GroupIconId) {
            *GroupIconId = NULL;
        }
        return result;
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\basemem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    basemem.h

Abstract:

    Implements macros and declares functions for basic allocation functions.
    Consolidated into this file from debug.h and allutils.h

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:


--*/

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

#define INVALID_PTR             ((PVOID)-1)


//
// Fail-proof memory allocators
//

PVOID SafeHeapAlloc (HANDLE g_hHeap, DWORD Flags, SIZE_T Size);
PVOID SafeHeapReAlloc (HANDLE g_hHeap, DWORD Flags, PVOID OldBlock, SIZE_T Size);

//
// Reusable memory alloc, kind of like a GROWBUFFER but more simple
//

PVOID ReuseAlloc (HANDLE Heap, PVOID OldPtr, DWORD SizeNeeded);
VOID ReuseFree (HANDLE Heap,PVOID Ptr);





#ifdef DEBUG

#define MemAlloc(heap,flags,size) DebugHeapAlloc(__FILE__,__LINE__,heap,flags,size)
#define MemReAlloc(heap,flags,ptr,size) DebugHeapReAlloc(__FILE__,__LINE__,heap,flags,ptr,size)
#define MemFree(heap,flags,ptr) DebugHeapFree(__FILE__,__LINE__,heap,flags,ptr)
#define MemCheck(x) DebugHeapCheck(__FILE__,__LINE__,heap)
#define FreeAlloc(ptr) DebugHeapFree(__FILE__,__LINE__,g_hHeap,0,ptr)
#define MemAllocUninit(size) DebugHeapAlloc(__FILE__,__LINE__,g_hHeap,0,size)
#define MemAllocZeroed(size) DebugHeapAlloc(__FILE__,__LINE__,g_hHeap,HEAP_ZERO_MEMORY,size)


LPVOID DebugHeapAlloc (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, SIZE_T dwSize);
LPVOID DebugHeapReAlloc (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, LPCVOID pMem, SIZE_T dwSize);
BOOL DebugHeapFree (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, LPCVOID pMem);
void DebugHeapCheck (LPCSTR File, DWORD Line, HANDLE hHeap);

VOID DumpHeapStats (VOID);
VOID DumpHeapLeaks (VOID);

SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );

#define MemCheckPtr(heap,ptr)       (DebugHeapValidatePtr(heap,ptr,__FILE__,__LINE__) != INVALID_PTR)


#else

#define MemAlloc SafeHeapAlloc
#define MemReAlloc SafeHeapReAlloc
#define MemFree(x,y,z) HeapFree(x,y,(PVOID)(z))
#define MemCheck(x)
#define FreeAlloc(ptr) HeapFree(g_hHeap,0,(PVOID)(ptr))
#define MemAllocUninit(size) SafeHeapAlloc(g_hHeap,0,size)
#define MemAllocZeroed(size) SafeHeapAlloc(g_hHeap,HEAP_ZERO_MEMORY,size)

#define DebugHeapCheck(x,y,z)
#define DumpHeapStats()
#define DumpHeapLeaks()

#define MemCheckPtr(heap,ptr)       (1)

#endif


#ifdef _cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\blobs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    blobs.h

Abstract:

    Declares the interface functions to manage BLOBS and arrays of BLOBS.

Author:

    Ovidiu Temereanca (ovidiut)   24-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef enum {
    BDT_NONE        = 0,
    BDT_SZW,
    BDT_SZA,
    BDT_MULTISZW,
    BDT_MULTISZA,
    BDT_DWORD,
    BDT_QWORD,
    BDT_BINARY,
    BDT_LAST
} BLOB_DATA_TYPE;

typedef enum {
    BF_RECORDDATATYPE   = 0x0001,
    BF_RECORDDATASIZE   = 0x0002,
    BF_UNICODESTRINGS   = 0x0004,
} BLOB_FLAGS;

typedef struct {
    PBYTE       Data;
    DWORD       End;
    DWORD       AllocSize;
    DWORD       GrowSize;
    DWORD       Index;
    DWORD       Flags;
    DWORD       UserIndex;
} OURBLOB, *POURBLOB;

typedef struct {
    DWORD       Signature;
    POURBLOB*   Blobs;
    DWORD       BlobsCount;
    DWORD       BlobsAllocated;
    DWORD       BlobsGrowCount;
} BLOBS, *PBLOBS;


typedef struct {
    POURBLOB    CurrentBlob;
    PBLOBS      Array;
    DWORD       Index;
} BLOB_ENUM, *PBLOB_ENUM;


//
// Macros
//

#define OURBLOB_INIT    { NULL, 0, 0, 0, 0, 0, 0 }
#define BLOBS_INIT      { 0, NULL, 0, 0, 0 }


//
// Blob APIs
//

__inline
BOOL
BlobRecordsDataType (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_RECORDDATATYPE;
}

__inline
BOOL
BlobRecordsDataSize (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_RECORDDATASIZE;
}

__inline
BOOL
BlobRecordsUnicodeStrings (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_UNICODESTRINGS;
}

__inline
BOOL
BlobIsEOF (
    IN      POURBLOB Blob
    )
{
    return !Blob->Data || Blob->Index == Blob->End;
}

__inline
PBYTE
BlobGetPointer (
    IN      POURBLOB Blob
    )
{
    return Blob->Data ? Blob->Data + Blob->Index : NULL;
}

__inline
PBYTE
BlobGetEOF (
    IN      POURBLOB Blob
    )
{
    return Blob->Data ? Blob->Data + Blob->End : NULL;
}

__inline
DWORD
BlobGetIndex (
    IN      POURBLOB Blob
    )
{
    return Blob->Index;
}


__inline
DWORD
BlobGetDataSize (
    IN      POURBLOB Blob
    )
{
    return Blob->End;
}

POURBLOB
BlobCreate (
    VOID
    );

POURBLOB
BlobDuplicate (
    IN      POURBLOB SourceBlob
    );

VOID
BlobClear (
    IN OUT  POURBLOB Blob
    );

VOID
BlobDestroy (
    IN OUT  POURBLOB Blob
    );

BOOL
BlobSetIndex (
    IN OUT  POURBLOB Blob,
    IN      DWORD Index
    );

DWORD
BlobGetRecordedDataType (
    IN      POURBLOB Blob
    );

BOOL
BlobWriteEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD DataType,         OPTIONAL
    IN      BOOL RecordDataSize,
    IN      DWORD DataSize,
    IN      PCVOID Data
    );

PBYTE
BlobReadEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD ExpectedDataType,     OPTIONAL
    IN      DWORD ExpectedDataSize,     OPTIONAL
    IN      BOOL RecordedDataSize,
    OUT     PDWORD ActualDataSize,      OPTIONAL
    OUT     PVOID Data,                 OPTIONAL
    IN      PMHANDLE Pool               OPTIONAL
    );

BOOL
BlobWriteDword (
    IN OUT  POURBLOB Blob,
    IN      DWORD Data
    );

BOOL
BlobReadDword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORD Data
    );

BOOL
BlobWriteQword (
    IN OUT  POURBLOB Blob,
    IN      DWORDLONG Data
    );

BOOL
BlobReadQword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORDLONG Data
    );

BOOL
BlobWriteStringA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    );

BOOL
BlobWriteStringW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    );

BOOL
BlobReadStringA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobReadStringW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobWriteMultiSzA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    );

BOOL
BlobWriteMultiSzW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    );

BOOL
BlobReadMultiSzA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobReadMultiSzW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobWriteBinary (
    IN OUT  POURBLOB Blob,
    IN      PBYTE Data,
    IN      DWORD Size
    );

BOOL
BlobReadBinary (
    IN OUT  POURBLOB Blob,
    OUT     PBYTE* Data,
    OUT     PDWORD Size,
    IN      PMHANDLE Pool
    );

BOOL
BlobWriteToFile (
    IN      POURBLOB Blob,
    IN      HANDLE File
    );

BOOL
BlobReadFromFile (
    OUT     POURBLOB Blob,
    IN      HANDLE File
    );

//
// Blob Array APIs
//

__inline
DWORD
BlobsGetCount (
    IN      PBLOBS BlobsArray
    )
{
    return BlobsArray->BlobsCount;
}


BOOL
BlobsAdd (
    IN OUT  PBLOBS BlobsArray,
    IN      POURBLOB Blob
    );


VOID
BlobsFree (
    IN OUT  PBLOBS BlobsArray,
    IN      BOOL DestroyBlobs
    );

BOOL
EnumFirstBlob (
    OUT     PBLOB_ENUM BlobEnum,
    IN      PBLOBS BlobsArray
    );

BOOL
EnumNextBlob (
    IN OUT  PBLOB_ENUM BlobEnum
    );

BOOL
BlobsWriteToFile (
    IN      PBLOBS BlobsArray,
    IN      HANDLE File
    );

BOOL
BlobsReadFromFile (
    OUT     PBLOBS BlobsArray,
    IN      HANDLE File
    );

//
// Macros
//

#ifdef UNICODE

#define BlobWriteString         BlobWriteStringW
#define BlobReadString          BlobReadStringW
#define BlobWriteMultiSz        BlobWriteMultiSzW
#define BlobReadMultiSz         BlobReadMultiSzW

#else

#define BlobWriteString         BlobWriteStringA
#define BlobReadString          BlobReadStringA
#define BlobWriteMultiSz        BlobWriteMultiSzA
#define BlobReadMultiSz         BlobReadMultiSzA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\compress.h ===
//
// Compression stuff
//
typedef enum {
    CompressNone,
    CompressMrci1,
    CompressMrci2,
    CompressMax
} CompressionType;

typedef BOOL(WINAPI COMPRESSNOTIFICATIONA)(
                        IN      PCSTR FileName,
                        IN      LONGLONG FileSize,
                        OUT     PBOOL ExtractFile,
                        IN OUT  PCSTR *NewFileName
                        );
typedef COMPRESSNOTIFICATIONA *PCOMPRESSNOTIFICATIONA;

typedef BOOL(WINAPI COMPRESSNOTIFICATIONW)(
                        IN      PCWSTR FileName,
                        IN      LONGLONG FileSize,
                        OUT     PBOOL ExtractFile,
                        IN OUT  PCWSTR *NewFileName
                        );
typedef COMPRESSNOTIFICATIONW *PCOMPRESSNOTIFICATIONW;

typedef struct {
    HANDLE CurrFileHandle;
    UINT FirstFileIndex;
    UINT CurrFileIndex;
    LONGLONG MaxFileSize;
    LONGLONG CurrFileSize;
    LONGLONG FilesStored;
    PCSTR StorePath;
    PCSTR MainFilePattern;
    PBYTE ReadBuffer;
    PBYTE CompBuffer;
    PBYTE ExtraBuffer;
} COMPRESS_HANDLEA, *PCOMPRESS_HANDLEA;

typedef struct {
    HANDLE CurrFileHandle;
    UINT FirstFileIndex;
    UINT CurrFileIndex;
    LONGLONG MaxFileSize;
    LONGLONG CurrFileSize;
    LONGLONG FilesStored;
    PCWSTR StorePath;
    PCWSTR MainFilePattern;
    PBYTE ReadBuffer;
    PBYTE CompBuffer;
    PBYTE ExtraBuffer;
} COMPRESS_HANDLEW, *PCOMPRESS_HANDLEW;

BOOL
CompressCreateHandleA (
    IN      PCSTR StorePath,
    IN      PCSTR MainFilePattern,
    IN      UINT StartIndex,
    IN      LONGLONG MaxFileSize,
    OUT     PCOMPRESS_HANDLEA CompressedHandle
    );

BOOL
CompressCreateHandleW (
    IN      PCWSTR StorePath,
    IN      PCWSTR MainFilePattern,
    IN      UINT StartIndex,
    IN      LONGLONG MaxFileSize,
    OUT     PCOMPRESS_HANDLEW CompressedHandle
    );

BOOL
CompressOpenHandleA (
    IN      PCSTR StorePath,
    IN      PCSTR MainFilePattern,
    IN      UINT StartIndex,
    OUT     PCOMPRESS_HANDLEA CompressedHandle
    );

BOOL
CompressOpenHandleW (
    IN      PCWSTR StorePath,
    IN      PCWSTR MainFilePattern,
    IN      UINT StartIndex,
    OUT     PCOMPRESS_HANDLEW CompressedHandle
    );

BOOL
CompressFlushAndCloseHandleA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    );

BOOL
CompressFlushAndCloseHandleW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    );

VOID
CompressCleanupHandleA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    );

VOID
CompressCleanupHandleW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    );

BOOL
CompressAddFileToHandleA (
    IN      PCSTR FileName,
    IN      PCSTR StoredName,
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    );

BOOL
CompressAddFileToHandleW (
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName,
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    );

BOOL
CompressExtractAllFilesA (
    IN      PCSTR ExtractPath,
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle,
    IN      PCOMPRESSNOTIFICATIONA CompressNotification OPTIONAL
    );

BOOL
CompressExtractAllFilesW (
    IN      PCWSTR ExtractPath,
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle,
    IN      PCOMPRESSNOTIFICATIONW CompressNotification OPTIONAL
    );

BOOL
CompressSetErrorMode (
    IN      BOOL ErrorMode
    );

#ifndef UNICODE

#define COMPRESS_HANDLE             COMPRESS_HANDLEA
#define PCOMPRESS_HANDLE            PCOMPRESS_HANDLEA
#define COMPRESSNOTIFICATION        COMPRESSNOTIFICATIONA
#define PCOMPRESSNOTIFICATION       PCOMPRESSNOTIFICATIONA
#define CompressCreateHandle        CompressCreateHandleA
#define CompressOpenHandle          CompressOpenHandleA
#define CompressFlushAndCloseHandle CompressFlushAndCloseHandleA
#define CompressCleanupHandle       CompressCleanupHandleA
#define CompressAddFileToHandle     CompressAddFileToHandleA
#define CompressExtractAllFiles     CompressExtractAllFilesA

#else

#define COMPRESS_HANDLE             COMPRESS_HANDLEW
#define PCOMPRESS_HANDLE            PCOMPRESS_HANDLEW
#define COMPRESSNOTIFICATION        COMPRESSNOTIFICATIONW
#define PCOMPRESSNOTIFICATION       PCOMPRESSNOTIFICATIONW
#define CompressCreateHandle        CompressCreateHandleW
#define CompressOpenHandle          CompressOpenHandleW
#define CompressFlushAndCloseHandle CompressFlushAndCloseHandleW
#define CompressCleanupHandle       CompressCleanupHandleW
#define CompressAddFileToHandle     CompressAddFileToHandleW
#define CompressExtractAllFiles     CompressExtractAllFilesW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\exclist.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    exclist.h

Abstract:

    Set of APIs to manage exclusion lists of objects of various well-known types.

Author:

    Ovidiu Temereanca (ovidiut)   23-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Macro expansion list
//

#define EXCLUSIONLIST_TYPES                                     \
            DEFMAC(ELT_UNUSED,          "Unused")               \
            DEFMAC(ELT_REGISTRY,        "Registry")             \
            DEFMAC(ELT_FILE,            "File")                 \
            DEFMAC(ELT_EXTRA1,          "Extra1")               \
            DEFMAC(ELT_EXTRA2,          "Extra2")               \
            DEFMAC(ELT_EXTRA3,          "Extra3")               \
            DEFMAC(ELT_EXTRA4,          "Extra4")               \
            DEFMAC(ELT_EXTRA5,          "Extra5")               \
            DEFMAC(ELT_EXTRA6,          "Extra6")               \
            DEFMAC(ELT_EXTRA7,          "Extra7")               \
            DEFMAC(ELT_EXTRA8,          "Extra8")               \

            // this needs work in order to work with extensible types

//
// Types
//

#define DEFMAC(TypeId,TypeName)     TypeId,

//
// these should map 1:1 with MIG_*_TYPE in ism.h for ease of use
//
typedef enum {
    EXCLUSIONLIST_TYPES     /* , */
    ELT_LAST
};

#undef DEFMAC


//
// API
//

BOOL
ElInitialize (
    VOID
    );

VOID
ElTerminateA (
    VOID
    );

VOID
ElTerminateW (
    VOID
    );

DWORD
ElGetTypeId (
    IN      PCSTR TypeName
    );

PCSTR
ElGetTypeName (
    IN      DWORD TypeId
    );

BOOL
ElAddA (
    IN      DWORD ObjectType,
    IN      PCSTR ObjectName
    );

BOOL
ElAddW (
    IN      DWORD ObjectType,
    IN      PCWSTR ObjectName
    );

VOID
ElRemoveAllA (
    VOID
    );

VOID
ElRemoveAllW (
    VOID
    );

BOOL
ElIsExcludedA (
    IN      DWORD ObjectType,
    IN      PCSTR Object
    );

BOOL
ElIsExcludedW (
    IN      DWORD ObjectType,
    IN      PCWSTR Object
    );

BOOL
ElIsExcluded2A (
    IN      DWORD ObjectType,
    IN      PCSTR Node,             OPTIONAL
    IN      PCSTR Leaf              OPTIONAL
    );

BOOL
ElIsExcluded2W (
    IN      DWORD ObjectType,
    IN      PCWSTR Node,            OPTIONAL
    IN      PCWSTR Leaf             OPTIONAL
    );

BOOL
ElIsTreeExcludedA (
    IN      DWORD ObjectType,
    IN      PCSTR TreePattern
    );

BOOL
ElIsTreeExcludedW (
    IN      DWORD ObjectType,
    IN      PCWSTR TreePattern
    );

BOOL
ElIsTreeExcluded2A (
    IN      DWORD ObjectType,
    IN      PCSTR Root,
    IN      PCSTR LeafPattern           OPTIONAL
    );

BOOL
ElIsTreeExcluded2W (
    IN      DWORD ObjectType,
    IN      PCWSTR Root,
    IN      PCWSTR Leaf             OPTIONAL
    );

BOOL
ElIsObsPatternExcludedA (
    IN      DWORD ObjectType,
    IN      POBSPARSEDPATTERNA Pattern
    );

BOOL
ElIsObsPatternExcludedW (
    IN      DWORD ObjectType,
    IN      POBSPARSEDPATTERNW Pattern
    );

//
// Macros
//

#ifdef UNICODE

#define ElAdd                   ElAddW
#define ElTerminate             ElTerminateW
#define ElRemoveAll             ElRemoveAllW
#define ElIsExcluded            ElIsExcludedW
#define ElIsExcluded2           ElIsExcluded2W
#define ElIsTreeExcluded        ElIsTreeExcludedW
#define ElIsTreeExcluded2       ElIsTreeExcluded2W
#define ElIsObsPatternExcluded  ElIsObsPatternExcludedW

#else

#define ElAdd                   ElAddA
#define ElTerminate             ElTerminateA
#define ElRemoveAll             ElRemoveAllA
#define ElIsExcluded            ElIsExcludedA
#define ElIsExcluded2           ElIsExcluded2A
#define ElIsTreeExcluded        ElIsTreeExcludedA
#define ElIsTreeExcluded2       ElIsTreeExcluded2A
#define ElIsObsPatternExcluded  ElIsObsPatternExcludedA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\basefile.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    basefile.c

Abstract:

    Contains simple wrappers for commonly used file i/o functions.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#define INVALID_ATTRIBUTES      0xFFFFFFFF

BOOL
DoesFileExistExA (
    IN      PCSTR Path,
    OUT     PWIN32_FIND_DATAA FindData  OPTIONAL
    );

#define DoesFileExistA(x) DoesFileExistExA (x, NULL)

BOOL
DoesFileExistExW (
    IN      PCWSTR Path,
    OUT     PWIN32_FIND_DATAW FindData  OPTIONAL
    );

#define DoesFileExistW(x) DoesFileExistExW (x, NULL)

BOOL
BfPathIsDirectoryA (
    IN      PCSTR PathSpec
    );

BOOL
BfPathIsDirectoryW (
    IN      PCWSTR PathSpec
    );

BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    );

BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    );

PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

#define MapFileIntoMemoryA(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExA(FileName,FileHandle,MapHandle,FALSE)
#define MapFileIntoMemoryW(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExW(FileName,FileHandle,MapHandle,FALSE)

BOOL
UnmapFile (
    IN PCVOID FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    );

BOOL
BfGetTempFileNameExA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCSTR Prefix
    );

#define BfGetTempFileNameA(b,c) BfGetTempFileNameExA(b,c,"temp")

BOOL
BfGetTempFileNameExW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCWSTR Prefix
    );

#define BfGetTempFileNameW(b,c) BfGetTempFileNameExW(b,c,L"temp")

BOOL
BfGetTempDirectoryExA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCSTR Prefix
    );

#define BfGetTempDirectoryA(b,c) BfGetTempDirectoryExA(b,c,"dir")

BOOL
BfGetTempDirectoryExW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCWSTR Prefix
    );

#define BfGetTempDirectoryW(b,c) BfGetTempDirectoryExW(b,c,L"dir")

HANDLE
BfGetTempFile (
    VOID
    );

BOOL
BfSetFilePointer (
    IN      HANDLE File,
    IN      LONGLONG Offset
    );

HANDLE
BfOpenReadFileA (
    IN      PCSTR FileName
    );

HANDLE
BfOpenReadFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfOpenFileA (
    IN      PCSTR FileName
    );

HANDLE
BfOpenFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfCreateFileA (
    IN      PCSTR FileName
    );

HANDLE
BfCreateFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfCreateSharedFileA (
    IN      PCSTR FileName
    );

HANDLE
BfCreateSharedFileW (
    IN      PCWSTR FileName
    );

BOOL
BfSetSizeOfFile (
    HANDLE File,
    LONGLONG Size
    );

BOOL
BfGoToEndOfFile (
    IN      HANDLE File,
    OUT     PLONGLONG FileSize      OPTIONAL
    );

BOOL
BfGetFilePointer (
    IN      HANDLE File,
    OUT     PLONGLONG FilePointer       OPTIONAL
    );

BOOL
BfReadFile (
    IN      HANDLE File,
    OUT     PBYTE Buffer,
    IN      UINT BytesToRead
    );

BOOL
BfWriteFile (
    IN      HANDLE File,
    OUT     PCBYTE Buffer,
    IN      UINT BytesToWrite
    );


BOOL
BfCreateDirectoryExA (
    IN      PCSTR FullPath,
    IN      BOOL CreateLastSegment
    );
#define BfCreateDirectoryA(d) BfCreateDirectoryExA(d,TRUE)

BOOL
BfCreateDirectoryExW (
    IN      PCWSTR FullPath,
    IN      BOOL CreateLastSegment
    );
#define BfCreateDirectoryW(d) BfCreateDirectoryExW(d,TRUE)

LONGLONG
BfGetFileSizeA (
    IN      PCSTR FileName
    );

LONGLONG
BfGetFileSizeW (
    IN      PCWSTR FileName
    );

PCSTR
BfGetLongFileNameA (
    IN      PCSTR SrcFileName
    );

BOOL
BfGetLongFileNameExA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    );

PCWSTR
BfGetLongFileNameW (
    IN      PCWSTR SrcFileName
    );

BOOL
BfGetLongFileNameExW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    );

BOOL
BfCopyAndFlushFileA (
    IN      PCSTR SrcFileName,
    IN      PCSTR DestFileName,
    IN      BOOL FailIfExists
    );

BOOL
BfCopyAndFlushFileW (
    IN      PCWSTR SrcFileName,
    IN      PCWSTR DestFileName,
    IN      BOOL FailIfExists
    );

#ifdef UNICODE

#define DoesFileExist                   DoesFileExistW
#define DoesFileExistEx                 DoesFileExistExW
#define BfPathIsDirectory               BfPathIsDirectoryW
#define WriteFileString                 WriteFileStringW
#define MapFileIntoMemory               MapFileIntoMemoryW
#define MapFileIntoMemoryEx             MapFileIntoMemoryExW
#define BfGetTempFileName               BfGetTempFileNameW
#define BfGetTempFileNameEx             BfGetTempFileNameExW
#define BfGetTempDirectory              BfGetTempDirectoryW
#define BfGetTempDirectoryEx            BfGetTempDirectoryExW
#define BfOpenReadFile                  BfOpenReadFileW
#define BfOpenFile                      BfOpenFileW
#define BfCreateFile                    BfCreateFileW
#define BfCreateSharedFile              BfCreateSharedFileW
#define BfCreateDirectoryEx             BfCreateDirectoryExW
#define BfCreateDirectory               BfCreateDirectoryW
#define BfGetFileSize                   BfGetFileSizeW
#define BfGetLongFileName               BfGetLongFileNameW
#define BfGetLongFileNameEx             BfGetLongFileNameExW
#define BfCopyAndFlushFile              BfCopyAndFlushFileW

#else

#define DoesFileExist                   DoesFileExistA
#define DoesFileExistEx                 DoesFileExistExA
#define BfPathIsDirectory               BfPathIsDirectoryA
#define WriteFileString                 WriteFileStringA
#define MapFileIntoMemory               MapFileIntoMemoryA
#define MapFileIntoMemoryEx             MapFileIntoMemoryExA
#define BfGetTempFileName               BfGetTempFileNameA
#define BfGetTempFileNameEx             BfGetTempFileNameExA
#define BfGetTempDirectory              BfGetTempDirectoryA
#define BfGetTempDirectoryEx            BfGetTempDirectoryExA
#define BfOpenReadFile                  BfOpenReadFileA
#define BfOpenFile                      BfOpenFileA
#define BfCreateFile                    BfCreateFileA
#define BfCreateSharedFile              BfCreateSharedFileA
#define BfCreateDirectoryEx             BfCreateDirectoryExA
#define BfCreateDirectory               BfCreateDirectoryA
#define BfGetFileSize                   BfGetFileSizeA
#define BfGetLongFileName               BfGetLongFileNameA
#define BfGetLongFileNameEx             BfGetLongFileNameExA
#define BfCopyAndFlushFile              BfCopyAndFlushFileA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\dbgtrack.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dbgtrack.h

Abstract:

    Implements macros and declares functions for resource tracking apis.
    Split from old debug.h

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:



--*/

#ifndef RC_INVOKED

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG

#ifndef DEBUG
#define DEBUG
#endif

#endif

#ifdef DEBUG

#ifndef DBG
#define DBG
#endif

#endif



//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

//
// Debug-only constants
//

#ifdef DEBUG

// This option makes fat, slow binaries
#define MEMORY_TRACKING

#define ALLOCATION_TRACKING_DEF , PCSTR File, UINT Line
#define ALLOCATION_TRACKING_CALL ,__FILE__,__LINE__
#define ALLOCATION_TRACKING_INLINE_CALL ,File,Line


#endif



//
// Macros
//

#ifdef DEBUG

#define DISABLETRACKCOMMENT()               DisableTrackComment()
#define ENABLETRACKCOMMENT()                EnableTrackComment()

#define TRACK_BEGIN(type,name)              Track##type(TrackPush(#name,__FILE__,__LINE__) ? (type) 0 : (
#define TRACK_END()                         ))

#define INVALID_POINTER(x)                  x=NULL

#else

#define DISABLETRACKCOMMENT()
#define ENABLETRACKCOMMENT()

#define TRACK_BEGIN(type,name)
#define TRACK_END()

#define INVALID_POINTER(x)

#define ALLOCATION_TRACKING_DEF
#define ALLOCATION_TRACKING_CALL
#define ALLOCATION_TRACKING_INLINE_CALL

#define InitAllocationTracking()
#define FreeAllocationTracking()
#define DebugRegisterAllocationEx(t,p,f,l,a)
#define DebugRegisterAllocation(t,p,f,l)
#define DebugUnregisterAllocation(t,p)

#endif

//
// Types
//

typedef enum {
    MERGE_OBJECT,
    POOLMEM_POINTER,
    POOLMEM_POOL,
    INF_HANDLE
} ALLOCTYPE;



//
// Globals
//

extern PCSTR g_TrackComment;
extern INT g_UseCount;
extern PCSTR g_TrackFile;
extern UINT g_TrackLine;
extern BOOL g_TrackAlloc;

//
// Macro expansion list
//

#define TRACK_WRAPPERS              \
        DEFMAC(PBYTE)               \
        DEFMAC(DWORD)               \
        DEFMAC(BOOL)                \
        DEFMAC(UINT)                \
        DEFMAC(PCSTR)               \
        DEFMAC(PCWSTR)              \
        DEFMAC(PVOID)               \
        DEFMAC(PSTR)                \
        DEFMAC(PWSTR)               \
        DEFMAC(HINF)                \
        DEFMAC(PMHANDLE)            \
        DEFMAC(PGROWBUFFER)         \
        DEFMAC(PPARSEDPATTERNA)     \
        DEFMAC(PPARSEDPATTERNW)     \
        DEFMAC(POBSPARSEDPATTERNA)  \
        DEFMAC(POBSPARSEDPATTERNW)  \
        DEFMAC(HASHTABLE)           \

//
// Public function prototypes
//

#ifdef DEBUG

VOID InitAllocationTracking (VOID);
VOID FreeAllocationTracking (VOID);
VOID DebugRegisterAllocationEx (ALLOCTYPE Type, PVOID Ptr, PCSTR File, UINT Line, BOOL Alloc);
VOID DebugRegisterAllocation (ALLOCTYPE Type, PVOID Ptr, PCSTR File, UINT Line);
VOID DebugUnregisterAllocation (ALLOCTYPE Type, PVOID Ptr);
VOID DisableTrackComment (VOID);
VOID EnableTrackComment (VOID);

INT TrackPush (PCSTR Name, PCSTR File, UINT Line);
INT TrackPushEx (PCSTR Name, PCSTR File, UINT Line, BOOL Alloc);
INT TrackPop (VOID);

VOID
TrackDump (
    VOID
    );

#define TRACKPUSH(n,f,l)        TrackPush(n,f,l)
#define TRACKPUSHEX(n,f,l,a)    TrackPushEx(n,f,l,a)
#define TRACKPOP()              TrackPop()
#define TRACKDUMP()             TrackDump()

//
// Macro expansion definition
//

#define DEFMAC(type)    __inline type Track##type (type Arg) {TrackPop(); return Arg;}

TRACK_WRAPPERS

#undef DEFMAC


#else       // i.e., if !DEBUG

#define TRACKPUSH(n,f,l)
#define TRACKPUSHEX(n,f,l,a)
#define TRACKPOP()
#define TRACKDUMP()

#endif

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\fileenum.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileenum.h

Abstract:

    Set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

//
// Drive enumeration structures
//

#define DRIVEENUM_NONE      0x000000
#define DRIVEENUM_UNKNOWN   0x000001
#define DRIVEENUM_NOROOTDIR 0x000002
#define DRIVEENUM_REMOVABLE 0x000004
#define DRIVEENUM_FIXED     0x000008
#define DRIVEENUM_REMOTE    0x000010
#define DRIVEENUM_CDROM     0x000020
#define DRIVEENUM_RAMDISK   0x000040
#define DRIVEENUM_ALL       (DRIVEENUM_UNKNOWN|DRIVEENUM_NOROOTDIR|DRIVEENUM_REMOVABLE|DRIVEENUM_FIXED|DRIVEENUM_REMOTE|DRIVEENUM_CDROM|DRIVEENUM_RAMDISK)
#define DRIVEENUM_ALLVALID  (DRIVEENUM_REMOVABLE|DRIVEENUM_FIXED|DRIVEENUM_REMOTE|DRIVEENUM_CDROM|DRIVEENUM_RAMDISK)

typedef struct {
    PCSTR           DriveName;
    UINT            DriveType;

    //
    // private members, maintained by enumeration
    //
    PSTR            AllLogicalDrives;
    UINT            WantedDriveTypes;
} DRIVE_ENUMA, *PDRIVE_ENUMA;

typedef struct {
    PCWSTR          DriveName;
    UINT            DriveType;

    //
    // private members, maintained by enumeration
    //
    PWSTR           AllLogicalDrives;
    UINT            WantedDriveTypes;
} DRIVE_ENUMW, *PDRIVE_ENUMW;

//
// file enumeration structures
//

#define FILEENUM_ALL_SUBLEVELS  0xFFFFFFFF

typedef enum {
    FECF_SKIPDIR                = 0x0001,
    FECF_SKIPSUBDIRS            = 0x0002,
    FECF_SKIPFILES              = 0x0004,
} FILEENUM_CONTROLFLAGS;

typedef enum {
    FEIF_RETURN_DIRS            = 0x0001,
    FEIF_FILES_FIRST            = 0x0002,
    FEIF_DEPTH_FIRST            = 0x0004,
    FEIF_USE_EXCLUSIONS         = 0x0008,
    FEIF_CONTAINERS_FIRST       = 0x0010,
} FILEENUM_INFOFLAGS;

typedef enum {
    DNS_ENUM_INIT,
    DNS_FILE_FIRST,
    DNS_FILE_NEXT,
    DNS_FILE_DONE,
    DNS_SUBDIR_FIRST,
    DNS_SUBDIR_NEXT,
    DNS_SUBDIR_DONE,
    DNS_ENUM_DONE
} DNS_ENUM_STATE;

typedef enum {
    FES_ROOT_FIRST,
    FES_ROOT_NEXT,
    FES_ROOT_DONE
} FES_ROOT_STATE;

typedef enum {
    DNF_RETURN_DIRNAME      = 0x0001,
    DNF_DIRNAME_MATCHES     = 0x0002,
} DIRNODE_FLAGS;

typedef struct {
    PCSTR               DirName;
    DWORD               DirAttributes;
    PSTR                FileName;
    HANDLE              FindHandle;
    WIN32_FIND_DATAA    FindData;
    DWORD               EnumState;
    DWORD               Flags;
    DWORD               SubLevel;
} DIRNODEA, *PDIRNODEA;

typedef struct {
    PCWSTR              DirName;
    DWORD               DirAttributes;
    PWSTR               FileName;
    HANDLE              FindHandle;
    WIN32_FIND_DATAW    FindData;
    DWORD               EnumState;
    DWORD               Flags;
    DWORD               SubLevel;
} DIRNODEW, *PDIRNODEW;

typedef BOOL (*FPE_ERROR_CALLBACKA)(PDIRNODEA);

typedef struct {
    POBSPARSEDPATTERNA      PathPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    FPE_ERROR_CALLBACKA     CallbackOnError;
} FILEENUMINFOA, *PFILEENUMINFOA;

typedef BOOL (*FPE_ERROR_CALLBACKW)(PDIRNODEW);

typedef struct {
    POBSPARSEDPATTERNW      PathPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    FPE_ERROR_CALLBACKW     CallbackOnError;
} FILEENUMINFOW, *PFILEENUMINFOW;

typedef struct {
    PCSTR           EncodedFullName;
    PCSTR           Name;
    PCSTR           Location;
    CHAR            NativeFullName[MAX_MBCHAR_PATH];
    DWORD           Attributes;
    DWORD           CurrentLevel;

    //
    // Private members
    //
    DWORD           ControlFlags;
    FILEENUMINFOA   FileEnumInfo;
    GROWBUFFER      FileNodes;
    DWORD           RootState;
    PDRIVE_ENUMA    DriveEnum;
    UINT            DriveEnumTypes;
    PDIRNODEA       LastNode;
    PSTR            FileNameAppendPos;
    PSTR            LastWackPtr;
} FILETREE_ENUMA, *PFILETREE_ENUMA;

typedef struct {
    PCWSTR          EncodedFullName;
    PCWSTR          Name;
    PCWSTR          Location;
    WCHAR           NativeFullName[MAX_WCHAR_PATH];
    DWORD           Attributes;
    DWORD           CurrentLevel;

    //
    // Private members
    //
    DWORD           ControlFlags;
    FILEENUMINFOW   FileEnumInfo;
    GROWBUFFER      FileNodes;
    DWORD           RootState;
    PDRIVE_ENUMW    DriveEnum;
    UINT            DriveEnumTypes;
    PDIRNODEW       LastNode;
    PWSTR           FileNameAppendPos;
    PWSTR           LastWackPtr;
} FILETREE_ENUMW, *PFILETREE_ENUMW;

typedef struct {
    PCSTR OriginalArg;
    PCSTR CleanedUpArg;
    BOOL Quoted;
} CMDLINEARGA, *PCMDLINEARGA;

typedef struct {
    PCSTR CmdLine;
    UINT ArgCount;
    CMDLINEARGA Args[];
} CMDLINEA, *PCMDLINEA;

typedef struct {
    PCWSTR OriginalArg;
    PCWSTR CleanedUpArg;
    BOOL Quoted;
} CMDLINEARGW, *PCMDLINEARGW;

typedef struct {
    PCWSTR CmdLine;
    UINT ArgCount;
    CMDLINEARGW Args[];
} CMDLINEW, *PCMDLINEW;

typedef BOOL(WINAPI FINDFILEA)(
                        IN      PCSTR FileName
                        );
typedef FINDFILEA *PFINDFILEA;

typedef BOOL(WINAPI FINDFILEW)(
                        IN      PCWSTR FileName
                        );
typedef FINDFILEW *PFINDFILEW;

typedef BOOL(WINAPI SEARCHPATHA)(
                        IN      PCSTR FileName,
                        IN      DWORD BufferLength,
                        OUT     PSTR Buffer
                        );
typedef SEARCHPATHA *PSEARCHPATHA;

typedef BOOL(WINAPI SEARCHPATHW)(
                        IN      PCWSTR FileName,
                        IN      DWORD BufferLength,
                        OUT     PWSTR Buffer
                        );
typedef SEARCHPATHW *PSEARCHPATHW;


//
// API
//

BOOL
FileEnumInitialize (
    VOID
    );

VOID
FileEnumTerminate (
    VOID
    );

//
// File enumeration APIs
//

BOOL
EnumFirstFileInTreeExA (
    OUT     PFILETREE_ENUMA FileEnum,
    IN      PCSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumContainers,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevels,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKA CallbackOnError OPTIONAL
    );

#define EnumFirstFileInTreeA(e,p)  EnumFirstFileInTreeExA(e,p,DRIVEENUM_ALLVALID,TRUE,TRUE,TRUE,TRUE,FILEENUM_ALL_SUBLEVELS,FALSE,NULL)

BOOL
EnumFirstFileInTreeExW (
    OUT     PFILETREE_ENUMW FileEnum,
    IN      PCWSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumContainers,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevels,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKW CallbackOnError OPTIONAL
    );

#define EnumFirstFileInTreeW(e,p)  EnumFirstFileInTreeExW(e,p,DRIVEENUM_ALLVALID,TRUE,TRUE,TRUE,TRUE,FILEENUM_ALL_SUBLEVELS,FALSE,NULL)

BOOL
EnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    );

BOOL
EnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    );

VOID
AbortEnumFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    );

VOID
AbortEnumFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    );

//
// Drive enumeration APIs
//

BOOL
EnumFirstDriveA (
    OUT     PDRIVE_ENUMA DriveEnum,
    IN      UINT WantedDriveTypes
    );

BOOL
EnumFirstDriveW (
    OUT     PDRIVE_ENUMW DriveEnum,
    IN      UINT WantedDriveTypes
    );

BOOL
EnumNextDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    );

BOOL
EnumNextDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    );

VOID
AbortEnumDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    );

VOID
AbortEnumDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    );


//
// Routines built on enum
//

BOOL
FiRemoveAllFilesInDirA (
    IN      PCSTR Dir
    );

BOOL
FiRemoveAllFilesInDirW (
    IN      PCWSTR Dir
    );

BOOL
FiRemoveAllFilesInTreeExA (
    IN      PCSTR Dir,
    IN      BOOL RemoveRoot
    );

#define FiRemoveAllFilesInTreeA(dir) FiRemoveAllFilesInTreeExA(dir,TRUE)

BOOL
FiRemoveAllFilesInTreeExW (
    IN      PCWSTR Dir,
    IN      BOOL RemoveRoot
    );

#define FiRemoveAllFilesInTreeW(dir) FiRemoveAllFilesInTreeExW(dir,TRUE)

BOOL
FiCopyAllFilesInDirA (
    IN      PCSTR Source,
    IN      PCSTR Dest,
    IN      BOOL SkipExisting
    );

#define FiCopyAllFilesInDirA(source,dest) FiCopyAllFilesInDirExA(source,dest,FALSE)

BOOL
FiCopyAllFilesInDirW (
    IN      PCWSTR Source,
    IN      PCWSTR Dest,
    IN      BOOL SkipExisting
    );

#define FiCopyAllFilesInDirW(source,dest) FiCopyAllFilesInDirExW(source,dest,FALSE)

BOOL
FiCopyAllFilesInTreeExA (
    IN      PCSTR Source,
    IN      PCSTR Dest,
    IN      BOOL SkipExisting
    );

#define FiCopyAllFilesInTreeA(source,dest) FiCopyAllFilesInTreeExA(source,dest,FALSE)

BOOL
FiCopyAllFilesInTreeExW (
    IN      PCWSTR Source,
    IN      PCWSTR Dest,
    IN      BOOL SkipExisting
    );

#define FiCopyAllFilesInTreeW(source,dest) FiCopyAllFilesInTreeExW(source,dest,FALSE)

PCMDLINEA
ParseCmdLineExA (
    IN      PCSTR CmdLine,
    IN      PCSTR Separators,                   OPTIONAL
    IN      PFINDFILEA FindFileCallback,        OPTIONAL
    IN      PSEARCHPATHA SearchPathCallback,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer
    );
#define ParseCmdLineA(c,b) ParseCmdLineExA(c,NULL,NULL,NULL,b)

PCMDLINEW
ParseCmdLineExW (
    IN      PCWSTR CmdLine,
    IN      PCWSTR Separators,                  OPTIONAL
    IN      PFINDFILEW FindFileCallback,        OPTIONAL
    IN      PSEARCHPATHW SearchPathCallback,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer
    );
#define ParseCmdLineW(c,b) ParseCmdLineExW(c,NULL,NULL,NULL,b)

//
// Macros
//

#ifdef UNICODE

#define DIRNODE                     DIRNODEW
#define PDIRNODE                    PDIRNODEW
#define FILENODE                    FILENODEW
#define PFILENODE                   PFILENODEW
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKW
#define FILEENUMINFO                FILEENUMINFOW
#define PFILEENUMINFO               PFILEENUMINFOW
#define FILETREE_ENUM               FILETREE_ENUMW
#define PFILETREE_ENUM              PFILETREE_ENUMW
#define EnumFirstFileInTree         EnumFirstFileInTreeW
#define EnumFirstFileInTreeEx       EnumFirstFileInTreeExW
#define EnumNextFileInTree          EnumNextFileInTreeW
#define AbortEnumFileInTree         AbortEnumFileInTreeW

#define DRIVE_ENUM                  DRIVE_ENUMW
#define EnumFirstDrive              EnumFirstDriveW
#define EnumNextDrive               EnumNextDriveW
#define AbortEnumDrive              AbortEnumDriveW
#define FiRemoveAllFilesInDir       FiRemoveAllFilesInDirW
#define FiRemoveAllFilesInTreeEx    FiRemoveAllFilesInTreeExW
#define FiRemoveAllFilesInTree      FiRemoveAllFilesInTreeW
#define FiCopyAllFilesInDir         FiCopyAllFilesInDirW
#define FiCopyAllFilesInDirEx       FiCopyAllFilesInDirExW
#define FiCopyAllFilesInTree        FiCopyAllFilesInTreeW
#define FiCopyAllFilesInTreeEx      FiCopyAllFilesInTreeExW

#define CMDLINE                     CMDLINEW
#define PCMDLINE                    PCMDLINEW
#define ParseCmdLineEx              ParseCmdLineExW
#define ParseCmdLine                ParseCmdLineW

#else

#define DIRNODE                     DIRNODEA
#define PDIRNODE                    PDIRNODEA
#define FILENODE                    FILENODEA
#define PFILENODE                   PFILENODEA
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKA
#define FILEENUMINFO                FILEENUMINFOA
#define PFILEENUMINFO               PFILEENUMINFOA
#define FILETREE_ENUM               FILETREE_ENUMA
#define PFILETREE_ENUM              PFILETREE_ENUMA
#define EnumFirstFileInTree         EnumFirstFileInTreeA
#define EnumFirstFileInTreeEx       EnumFirstFileInTreeExA
#define EnumNextFileInTree          EnumNextFileInTreeA
#define AbortEnumFileInTree         AbortEnumFileInTreeA

#define DRIVE_ENUM                  DRIVE_ENUMA
#define EnumFirstDrive              EnumFirstDriveA
#define EnumNextDrive               EnumNextDriveA
#define AbortEnumDrive              AbortEnumDriveA
#define FiRemoveAllFilesInDir       FiRemoveAllFilesInDirA
#define FiRemoveAllFilesInTreeEx    FiRemoveAllFilesInTreeExA
#define FiRemoveAllFilesInTree      FiRemoveAllFilesInTreeA
#define FiCopyAllFilesInDirEx       FiCopyAllFilesInDirExA
#define FiCopyAllFilesInDir         FiCopyAllFilesInDirA
#define FiCopyAllFilesInTreeEx      FiCopyAllFilesInTreeExA
#define FiCopyAllFilesInTree        FiCopyAllFilesInTreeA

#define CMDLINE                     CMDLINEA
#define PCMDLINE                    PCMDLINEA
#define ParseCmdLineEx              ParseCmdLineExA
#define ParseCmdLine                ParseCmdLineA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\cablib.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cablib.h

Abstract:

    Set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef BOOL(WINAPI CABGETCABINETNAMESA)(
                        IN      PCSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESA *PCABGETCABINETNAMESA;

typedef BOOL(WINAPI CABGETCABINETNAMESW)(
                        IN      PCWSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCWSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCWSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESW *PCABGETCABINETNAMESW;

typedef BOOL(WINAPI CABGETTEMPFILEA)(
                        OUT     PSTR Buffer,
                        IN      UINT BufferTchars
                        );
typedef CABGETTEMPFILEA *PCABGETTEMPFILEA;

typedef BOOL(WINAPI CABGETTEMPFILEW)(
                        OUT     PWSTR Buffer,
                        IN      UINT BufferTchars
                        );
typedef CABGETTEMPFILEW *PCABGETTEMPFILEW;

typedef BOOL(WINAPI CABNOTIFICATIONA)(
                        IN      PCSTR FileName
                        );
typedef CABNOTIFICATIONA *PCABNOTIFICATIONA;

typedef BOOL(WINAPI CABNOTIFICATIONW)(
                        IN      PCWSTR FileName
                        );
typedef CABNOTIFICATIONW *PCABNOTIFICATIONW;

typedef PVOID CCABHANDLE;

typedef PVOID OCABHANDLE;

//
// API
//

CCABHANDLE
CabCreateCabinetByIndexA (
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      PCABGETTEMPFILEA CabGetTempFile, // OPTIONAL
    IN      LONG MaxFileSize,
    IN      INT InitialIndex
    );
#define CabCreateCabinetA(p,f,d,t,s) CabCreateCabinetByIndexA(p,f,d,t,s,1)

CCABHANDLE
CabCreateCabinetByIndexW (
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      PCABGETTEMPFILEW CabGetTempFile, // OPTIONAL
    IN      LONG MaxFileSize,
    IN      INT InitialIndex
    );
#define CabCreateCabinetW(p,f,d,t,s) CabCreateCabinetByIndexW(p,f,d,t,s,1)

CCABHANDLE
CabCreateCabinetExA (
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

CCABHANDLE
CabCreateCabinetExW (
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

BOOL
CabAddFileToCabinetA (
    IN      CCABHANDLE CabHandle,
    IN      PCSTR FileName,
    IN      PCSTR StoredName
    );

BOOL
CabAddFileToCabinetW (
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    );

BOOL
CabFlushAndCloseCabinetExA (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

#define CabFlushAndCloseCabinetA(h)         CabFlushAndCloseCabinetExA(h,NULL,NULL,NULL,NULL)

BOOL
CabFlushAndCloseCabinetExW (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

#define CabFlushAndCloseCabinetW(h)         CabFlushAndCloseCabinetExW(h,NULL,NULL,NULL,NULL)

OCABHANDLE
CabOpenCabinetA (
    IN      PCSTR FileName
    );

OCABHANDLE
CabOpenCabinetW (
    IN      PCWSTR FileName
    );

BOOL
CabExtractAllFilesExA (
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,
    IN      PCABNOTIFICATIONA CabNotification   OPTIONAL
    );

#define CabExtractAllFilesA(h,p) CabExtractAllFilesExA(h,p,NULL)

BOOL
CabExtractAllFilesExW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,
    IN      PCABNOTIFICATIONW CabNotification   OPTIONAL
    );

#define CabExtractAllFilesW(h,p) CabExtractAllFilesExW(h,p,NULL)

BOOL
CabCloseCabinetA (
    IN      OCABHANDLE CabHandle
    );

BOOL
CabCloseCabinetW (
    IN      OCABHANDLE CabHandle
    );

//
// Macros
//

#ifdef UNICODE

#define CABGETCABINETNAMES          CABGETCABINETNAMESW
#define PCABGETCABINETNAMES         PCABGETCABINETNAMESW
#define CABNOTIFICATION             CABNOTIFICATIONW
#define PCABNOTIFICATION            PCABNOTIFICATIONW
#define CABGETTEMPFILE              CABGETTEMPFILEW
#define PCABGETTEMPFILE             PCABGETTEMPFILEW
#define CabCreateCabinet            CabCreateCabinetW
#define CabCreateCabinetByIndex     CabCreateCabinetByIndexW
#define CabCreateCabinetEx          CabCreateCabinetExW
#define CabAddFileToCabinet         CabAddFileToCabinetW
#define CabFlushAndCloseCabinet     CabFlushAndCloseCabinetW
#define CabFlushAndCloseCabinetEx   CabFlushAndCloseCabinetExW
#define CabOpenCabinet              CabOpenCabinetW
#define CabExtractAllFilesEx        CabExtractAllFilesExW
#define CabExtractAllFiles          CabExtractAllFilesW
#define CabCloseCabinet             CabCloseCabinetW

#else

#define CABGETCABINETNAMES          CABGETCABINETNAMESA
#define PCABGETCABINETNAMES         PCABGETCABINETNAMESA
#define CABNOTIFICATION             CABNOTIFICATIONA
#define PCABNOTIFICATION            PCABNOTIFICATIONA
#define CABGETTEMPFILE              CABGETTEMPFILEA
#define PCABGETTEMPFILE             PCABGETTEMPFILEA
#define CabCreateCabinet            CabCreateCabinetA
#define CabCreateCabinetByIndex     CabCreateCabinetByIndexA
#define CabCreateCabinetEx          CabCreateCabinetExA
#define CabAddFileToCabinet         CabAddFileToCabinetA
#define CabFlushAndCloseCabinet     CabFlushAndCloseCabinetA
#define CabFlushAndCloseCabinetEx   CabFlushAndCloseCabinetExA
#define CabOpenCabinet              CabOpenCabinetA
#define CabExtractAllFilesEx        CabExtractAllFilesExA
#define CabExtractAllFiles          CabExtractAllFilesA
#define CabCloseCabinet             CabCloseCabinetA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\growbuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growbuf.h

Abstract:

    Implements the GROWBUFFER data type, a dynamically allocated buffer
    that grows (and potentially changes addresses).  GROWBUFFERs are
    typically used to maintain dynamic sized arrays, or multi-sz lists.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/



typedef struct TAG_GROWBUFFER {
    PBYTE Buf;
    DWORD Size;
    DWORD End;
    DWORD GrowSize;
    DWORD UserIndex;        // Unused by Growbuf. For caller use.
#ifdef DEBUG
    DWORD StatEnd;
#endif
} GROWBUFFER;

#ifdef DEBUG
#define INIT_GROWBUFFER {NULL,0,0,0,0,0}
#else
#define INIT_GROWBUFFER {NULL,0,0,0,0}
#endif

PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD SpaceNeeded
    );

#define GbGrow(buf,size)    TRACK_BEGIN(PBYTE, GbGrow)\
                            RealGbGrow(buf,size)\
                            TRACK_END()

VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    );


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbMultiSzAppendA(buf,str)   TRACK_BEGIN(BOOL, GbMultiSzAppendA)\
                                    RealGbMultiSzAppendA(buf,str)\
                                    TRACK_END()

BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbMultiSzAppendW(buf,str)   TRACK_BEGIN(BOOL, GbMultiSzAppendW)\
                                    RealGbMultiSzAppendW(buf,str)\
                                    TRACK_END()

BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    );

#define GbAppendDword(buf,d)        TRACK_BEGIN(BOOL, GbAppendDword)\
                                    RealGbAppendDword(buf,d)\
                                    TRACK_END()

BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID p
    );

#define GbAppendPvoid(buf,p)        TRACK_BEGIN(BOOL, GbAppendPvoid)\
                                    RealGbAppendPvoid(buf,p)\
                                    TRACK_END()


BOOL
RealGbAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbAppendStringA(buf,str)    TRACK_BEGIN(BOOL, GbAppendStringA)\
                                    RealGbAppendStringA(buf,str)\
                                    TRACK_END()

BOOL
RealGbAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbAppendStringW(buf,str)    TRACK_BEGIN(BOOL, GbAppendStringW)\
                                    RealGbAppendStringW(buf,str)\
                                    TRACK_END()


BOOL
RealGbAppendStringABA (
    PGROWBUFFER GrowBuf,
    PCSTR Start,
    PCSTR EndPlusOne
    );

#define GbAppendStringABA(buf,a,b)      TRACK_BEGIN(BOOL, GbAppendStringABA)\
                                        RealGbAppendStringABA(buf,a,b)\
                                        TRACK_END()

BOOL
RealGbAppendStringABW (
    PGROWBUFFER GrowBuf,
    PCWSTR Start,
    PCWSTR EndPlusOne
    );

#define GbAppendStringABW(buf,a,b)      TRACK_BEGIN(BOOL, GbAppendStringABW)\
                                        RealGbAppendStringABW(buf,a,b)\
                                        TRACK_END()



BOOL
RealGbCopyStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbCopyStringA(buf,str)      TRACK_BEGIN(BOOL, GbCopyStringA)\
                                    RealGbCopyStringA(buf,str)\
                                    TRACK_END()

BOOL
RealGbCopyStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbCopyStringW(buf,str)      TRACK_BEGIN(BOOL, GbCopyStringW)\
                                    RealGbCopyStringW(buf,str)\
                                    TRACK_END()

BOOL
RealGbCopyQuotedStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbCopyQuotedStringA(buf,str) TRACK_BEGIN(BOOL, GbCopyQuotedStringA)\
                                     RealGbCopyQuotedStringA(buf,str)\
                                     TRACK_END()

BOOL
RealGbCopyQuotedStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbCopyQuotedStringW(buf,str) TRACK_BEGIN(BOOL, GbCopyQuotedStringW)\
                                     RealGbCopyQuotedStringW(buf,str)\
                                     TRACK_END()

#ifdef DEBUG
VOID
GbDumpStatistics (
    VOID
    );
#else
#define GbDumpStatistics()
#endif

#ifdef UNICODE

#define GbMultiSzAppend             GbMultiSzAppendW
#define GbAppendString              GbAppendStringW
#define GbAppendStringAB            GbAppendStringABW
#define GbCopyString                GbCopyStringW
#define GbCopyQuotedString          GbCopyQuotedStringW

#else

#define GbMultiSzAppend             GbMultiSzAppendA
#define GbAppendString              GbAppendStringA
#define GbAppendStringAB            GbAppendStringABA
#define GbCopyString                GbCopyStringA
#define GbCopyQuotedString          GbCopyQuotedStringA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\growlist.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growlist.h

Abstract:

    Implements a dynamic array-indexed list of binary objects.  Typically,
    the binary objects are strings.  The list uses a GROWBUF for the array,
    and a pool for the binary data of each list item.

Author:

    Jim Schmidt (jimschm) 08-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    GROWBUFFER ListArray;
    PMHANDLE ListData;
} GROWLIST, *PGROWLIST;

#ifdef DEBUG
#define INIT_GROWLIST {NULL,0,0,0,0,0, NULL}
#else
#define INIT_GROWLIST {NULL,0,0,0,0, NULL}
#endif

#define GlGetPtrArray(listptr)           ((PVOID *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayA(listptr)    ((PCSTR *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayW(listptr)    ((PCWSTR *) ((listptr)->ListArray.Buf))

PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppend(list,data,size)    TRACK_BEGIN(PBYTE, GlAppend)\
                                    RealGlAppend (list,data,size)   \
                                    TRACK_END()

PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppendAddNul(list,data,size)    TRACK_BEGIN(PBYTE, GlAppendAddNul)         \
                                          RealGlAppendAddNul (list,data,size)       \
                                          TRACK_END()

VOID
GlFree (
    IN  PGROWLIST GrowList
    );

VOID
GlReset (
    IN OUT  PGROWLIST GrowList
    );

PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    );

UINT
GlGetSize (
    IN      PGROWLIST GrowList
    );

PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsert(list,index,data,size)      TRACK_BEGIN(PBYTE,GlInsert)   \
                                            RealGlInsert (list,index,data,size)             \
                                            TRACK_END()


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsertAddNul(list,index,data,size)    TRACK_BEGIN(PBYTE, GlInsertAddNul)           \
                                                RealGlInsertAddNul (list,index,data,size)   \
                                                TRACK_END()


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToSet,           OPTIONAL
    IN      UINT SizeOfData
    );

#define GlSetItem(list,index,data,size)     TRACK_BEGIN(PBYTE, GlSetItem)        \
                                            RealGlSetItem(list,index,data,size) \
                                            TRACK_END()

__inline
PCSTR
RealGlAppendStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABA"));

    return (PCSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCWSTR
RealGlAppendStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABW"));

    return (PCWSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCSTR
RealGlInsertStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABA"));

    return (PCSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCWSTR
RealGlInsertStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABW"));

    return (PCWSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

#define GlAppendStringABA(list,a,b)         TRACK_BEGIN(PCSTR, GrowListAppendStringABA)          \
                                            RealGlAppendStringABA(list,a,b)\
                                            TRACK_END()

#define GlAppendStringABW(list,a,b)         TRACK_BEGIN(PCWSTR, GrowListAppendStringABW)         \
                                            RealGlAppendStringABW(list,a,b)\
                                            TRACK_END()

#define GlInsertStringABA(list,index,a,b)   TRACK_BEGIN(PCSTR, GrowListInsertStringABA)            \
                                            RealGlInsertStringABA(list,index,a,b)\
                                            TRACK_END()

#define GlInsertStringABW(list,index,a,b)   TRACK_BEGIN(PCWSTR, GrowListInsertStringABW)           \
                                            RealGlInsertStringABW(list,index,a,b)\
                                            TRACK_END()



#define GlAppendStringA(list,str) GlAppendStringABA(list,str,GetEndOfStringA(str))
#define GlAppendStringW(list,str) GlAppendStringABW(list,str,GetEndOfStringW(str))

#define GlInsertStringA(list,index,str) GlInsertStringABA(list,index,str,GetEndOfStringA(str))
#define GlInsertStringW(list,index,str) GlInsertStringABW(list,index,str,GetEndOfStringW(str))

#define GlAppendStringNA(list,str,len) GlAppendStringABA(list,str,CharCountToPointerA(str,len))
#define GlAppendStringNW(list,str,len) GlAppendStringABW(list,str,CharCountToPointerW(str,len))

#define GlInsertStringNA(list,index,str,len) GlInsertStringABA(list,index,str,CharCountToPointerA(str,len))
#define GlInsertStringNW(list,index,str,len) GlInsertStringABW(list,index,str,CharCountToPointerW(str,len))

#define GlGetStringA(list,index) (PCSTR)(GlGetItem(list,index))
#define GlGetStringW(list,index) (PCWSTR)(GlGetItem(list,index))

#define GlAppendEmptyItem(list)           GlAppend (list,NULL,0)
#define GlInsertEmptyItem(list,index)     GlInsert (list,index,NULL,0)

#ifdef UNICODE

#define GlAppendString GlAppendStringW
#define GlInsertString GlInsertStringW
#define GlAppendStringAB GlAppendStringABW
#define GlInsertStringAB GlInsertStringABW
#define GlAppendStringN GlAppendStringNW
#define GlInsertStringN GlInsertStringNW
#define GlGetString GlGetStringW
#define GlGetStringPtrArray GlGetStringPtrArrayW

#else

#define GlAppendString GlAppendStringA
#define GlInsertString GlInsertStringA
#define GlAppendStringAB GlAppendStringABA
#define GlInsertStringAB GlInsertStringABA
#define GlAppendStringN GlAppendStringNA
#define GlInsertStringN GlInsertStringNA
#define GlGetString GlGetStringA
#define GlGetStringPtrArray GlGetStringPtrArrayA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\icons.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    icons.h

Abstract:

    Implements a set of routines for handling icons in ICO, PE and NE files

Author:

    Calin Negreanu (calinn) 16-Jum-2000

Revision History:

--*/

#pragma once

//
// Includes
//

// None

//
// Debug constants
//

// None

//
// Strings
//

// None

//
// Constants
//

#define ICON_ICOFILE    0x00000001
#define ICON_PEFILE     0x00000002
#define ICON_NEFILE     0x00000003

//
// Macros
//

// None

//
// Types
//

#pragma pack(push)
#pragma pack(2)

typedef struct {
    BYTE        Width;          // Width, in pixels, of the image
    BYTE        Height;         // Height, in pixels, of the image
    BYTE        ColorCount;     // Number of colors in image (0 if >=8bpp)
    BYTE        Reserved;       // Reserved ( must be 0)
    WORD        Planes;         // Color Planes
    WORD        BitCount;       // Bits per pixel
    DWORD       BytesInRes;     // How many bytes in this resource?
    DWORD       ImageOffset;    // Where in the file is this image?
} ICONDIRENTRY, *PICONDIRENTRY;

typedef struct {
    WORD           Reserved;   // Reserved (must be 0)
    WORD           Type;       // Resource Type (1 for icons)
    WORD           Count;      // How many images?
    ICONDIRENTRY   Entries[];  // An entry for each image (idCount of 'em)
} ICONDIR, *PICONDIR;

typedef struct {
    WORD           Reserved;   // Reserved (must be 0)
    WORD           Type;       // Resource Type (1 for icons)
    WORD           Count;      // How many images?
} ICONDIRBASE, *PICONDIRBASE;

typedef struct {
    BYTE   Width;               // Width, in pixels, of the image
    BYTE   Height;              // Height, in pixels, of the image
    BYTE   ColorCount;          // Number of colors in image (0 if >=8bpp)
    BYTE   Reserved;            // Reserved
    WORD   Planes;              // Color Planes
    WORD   BitCount;            // Bits per pixel
    DWORD  BytesInRes;          // how many bytes in this resource?
    WORD   ID;                  // the ID
} GRPICONDIRENTRY, *PGRPICONDIRENTRY;

typedef struct {
    WORD             Reserved;   // Reserved (must be 0)
    WORD             Type;       // Resource type (1 for icons)
    WORD             Count;      // How many images?
    GRPICONDIRENTRY  Entries[];  // The entries for each image
} GRPICONDIR, *PGRPICONDIR;

typedef struct {
    WORD             Reserved;   // Reserved (must be 0)
    WORD             Type;       // Resource type (1 for icons)
    WORD             Count;      // How many images?
} GRPICONDIRBASE, *PGRPICONDIRBASE;

#pragma pack( pop )

typedef struct {
    BYTE Width;
    BYTE Height;
    BYTE ColorCount;
    WORD Planes;
    WORD BitCount;
    DWORD Size;
    WORD Id;
    PBYTE Image;
} ICON_IMAGE, *PICON_IMAGE;

typedef struct {
    PMHANDLE Pool;
    WORD IconsCount;
    PICON_IMAGE Icons[];
} ICON_GROUP, *PICON_GROUP;

typedef struct {
    DWORD DataSize;
    PBYTE Data;
} ICON_SGROUP, *PICON_SGROUP;

typedef struct {
    PICON_GROUP IconGroup;
    PCSTR ResourceId;
    WORD Index;

    // private members, do not touch
    DWORD FileType;
    BOOL FreeHandle;
    HANDLE ModuleHandle;
    GROWBUFFER Buffer;
    MULTISZ_ENUMA MultiSzEnum;
} ICON_ENUMA, *PICON_ENUMA;

typedef struct {
    PICON_GROUP IconGroup;
    PCWSTR ResourceId;
    WORD Index;

    // private members, do not touch
    DWORD FileType;
    BOOL FreeHandle;
    HANDLE ModuleHandle;
    GROWBUFFER Buffer;
    MULTISZ_ENUMW MultiSzEnum;
} ICON_ENUMW, *PICON_ENUMW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes
//

VOID
IcoReleaseResourceIdA (
    PCSTR ResourceId
    );

VOID
IcoReleaseResourceIdW (
    PCWSTR ResourceId
    );

VOID
IcoReleaseIconGroup (
    IN      PICON_GROUP IconGroup
    );

VOID
IcoReleaseIconSGroup (
    IN OUT  PICON_SGROUP IconSGroup
    );

BOOL
IcoSerializeIconGroup (
    IN      PICON_GROUP IconGroup,
    OUT     PICON_SGROUP IconSGroup
    );

PICON_GROUP
IcoDeSerializeIconGroup (
    IN      PICON_SGROUP IconSGroup
    );

PICON_GROUP
IcoExtractIconGroupFromIcoFileEx (
    IN      HANDLE IcoFileHandle
    );

PICON_GROUP
IcoExtractIconGroupFromIcoFileA (
    IN      PCSTR IcoFile
    );

PICON_GROUP
IcoExtractIconGroupFromIcoFileW (
    IN      PCWSTR IcoFile
    );

BOOL
IcoWriteIconGroupToIcoFileEx (
    IN      HANDLE IcoFileHandle,
    IN      PICON_GROUP IconGroup
    );

BOOL
IcoWriteIconGroupToIcoFileA (
    IN      PCSTR IcoFile,
    IN      PICON_GROUP IconGroup,
    IN      BOOL OverwriteExisting
    );

BOOL
IcoWriteIconGroupToIcoFileW (
    IN      PCWSTR IcoFile,
    IN      PICON_GROUP IconGroup,
    IN      BOOL OverwriteExisting
    );

INT
IcoGetIndexFromPeResourceIdExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId
    );

INT
IcoGetIndexFromPeResourceIdExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId
    );

INT
IcoGetIndexFromPeResourceIdA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId
    );

INT
IcoGetIndexFromPeResourceIdW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId
    );

PICON_GROUP
IcoExtractIconGroupFromPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId,
    OUT     PINT Index              OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index              OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromPeFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromPeFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

VOID
IcoAbortPeEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    );

VOID
IcoAbortPeEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInPeFileExA (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInPeFileExW (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInPeFileA (
    IN      PCSTR ModuleName,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInPeFileW (
    IN      PCWSTR ModuleName,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumNextIconGroupInPeFileA (
    IN OUT  PICON_ENUMA IconEnum
    );

BOOL
IcoEnumNextIconGroupInPeFileW (
    IN OUT  PICON_ENUMW IconEnum
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    );

BOOL
IcoWriteIconGroupToPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      HANDLE UpdateHandle,
    IN      PICON_GROUP IconGroup,
    OUT     PCSTR *ResourceId       OPTIONAL
    );

BOOL
IcoWriteIconGroupToPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      HANDLE UpdateHandle,
    IN      PICON_GROUP IconGroup,
    OUT     PCWSTR *ResourceId      OPTIONAL
    );

BOOL
IcoWriteIconGroupToPeFileA (
    IN      PCSTR ModuleName,
    IN      PICON_GROUP IconGroup,
    OUT     PCSTR *ResourceId,      OPTIONAL
    OUT     PINT Index              OPTIONAL
    );

BOOL
IcoWriteIconGroupToPeFileW (
    IN      PCWSTR ModuleName,
    IN      PICON_GROUP IconGroup,
    OUT     PCWSTR *ResourceId,     OPTIONAL
    OUT     PINT Index              OPTIONAL
    );

INT
IcoGetIndexFromNeResourceIdExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId
    );

INT
IcoGetIndexFromNeResourceIdExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId
    );

INT
IcoGetIndexFromNeResourceIdA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId
    );

INT
IcoGetIndexFromNeResourceIdW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId
    );

PICON_GROUP
IcoExtractIconGroupFromNeFileExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromNeFileExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromNeFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromNeFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

VOID
IcoAbortNeEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    );

VOID
IcoAbortNeEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInNeFileExA (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInNeFileExW (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInNeFileA (
    IN      PCSTR ModuleName,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInNeFileW (
    IN      PCWSTR ModuleName,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumNextIconGroupInNeFileA (
    IN OUT  PICON_ENUMA IconEnum
    );

BOOL
IcoEnumNextIconGroupInNeFileW (
    IN OUT  PICON_ENUMW IconEnum
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileExA (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileExW (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    );

VOID
IcoAbortEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    );

VOID
IcoAbortEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInFileA (
    IN      PCSTR FileName,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInFileW (
    IN      PCWSTR FileName,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumNextIconGroupInFileA (
    IN OUT  PICON_ENUMA IconEnum
    );

BOOL
IcoEnumNextIconGroupInFileW (
    IN OUT  PICON_ENUMW IconEnum
    );

PICON_GROUP
IcoExtractIconGroupFromFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId
    );

//
// Macro expansion definition
//

// None

//
// TCHAR mappings
//

#ifndef UNICODE

#define ICON_ENUM                               ICON_ENUMA
#define IcoReleaseResourceId                    IcoReleaseResourceIdA
#define IcoExtractIconGroupFromIcoFile          IcoExtractIconGroupFromIcoFileA
#define IcoWriteIconGroupToIcoFile              IcoWriteIconGroupToIcoFileA
#define IcoGetIndexFromPeResourceIdEx           IcoGetIndexFromPeResourceIdExA
#define IcoGetIndexFromPeResourceId             IcoGetIndexFromPeResourceIdA
#define IcoExtractIconGroupFromPeFileEx         IcoExtractIconGroupFromPeFileExA
#define IcoExtractIconGroupFromPeFile           IcoExtractIconGroupFromPeFileA
#define IcoAbortPeEnumIconGroup                 IcoAbortPeEnumIconGroupA
#define IcoEnumFirstIconGroupInPeFileEx         IcoEnumFirstIconGroupInPeFileExA
#define IcoEnumFirstIconGroupInPeFile           IcoEnumFirstIconGroupInPeFileA
#define IcoEnumNextIconGroupInPeFile            IcoEnumNextIconGroupInPeFileA
#define IcoExtractIconGroupByIndexFromPeFileEx  IcoExtractIconGroupByIndexFromPeFileExA
#define IcoExtractIconGroupByIndexFromPeFile    IcoExtractIconGroupByIndexFromPeFileA
#define IcoWriteIconGroupToPeFileEx             IcoWriteIconGroupToPeFileExA
#define IcoWriteIconGroupToPeFile               IcoWriteIconGroupToPeFileA
#define IcoGetIndexFromNeResourceIdEx           IcoGetIndexFromNeResourceIdExA
#define IcoGetIndexFromNeResourceId             IcoGetIndexFromNeResourceIdA
#define IcoExtractIconGroupFromNeFileEx         IcoExtractIconGroupFromNeFileExA
#define IcoExtractIconGroupFromNeFile           IcoExtractIconGroupFromNeFileA
#define IcoAbortNeEnumIconGroup                 IcoAbortNeEnumIconGroupA
#define IcoEnumFirstIconGroupInNeFileEx         IcoEnumFirstIconGroupInNeFileExA
#define IcoEnumFirstIconGroupInNeFile           IcoEnumFirstIconGroupInNeFileA
#define IcoEnumNextIconGroupInNeFile            IcoEnumNextIconGroupInNeFileA
#define IcoExtractIconGroupByIndexFromNeFileEx  IcoExtractIconGroupByIndexFromNeFileExA
#define IcoExtractIconGroupByIndexFromNeFile    IcoExtractIconGroupByIndexFromNeFileA
#define IcoAbortEnumIconGroup                   IcoAbortEnumIconGroupA
#define IcoEnumFirstIconGroupInFile             IcoEnumFirstIconGroupInFileA
#define IcoEnumNextIconGroupInFile              IcoEnumNextIconGroupInFileA
#define IcoExtractIconGroupFromFile             IcoExtractIconGroupFromFileA
#define IcoExtractIconGroupByIndexFromFile      IcoExtractIconGroupByIndexFromFileA

#else

#define ICON_ENUM                               ICON_ENUMW
#define IcoReleaseResourceId                    IcoReleaseResourceIdW
#define IcoExtractIconGroupFromIcoFile          IcoExtractIconGroupFromIcoFileW
#define IcoWriteIconGroupToIcoFile              IcoWriteIconGroupToIcoFileW
#define IcoGetIndexFromPeResourceIdEx           IcoGetIndexFromPeResourceIdExW
#define IcoGetIndexFromPeResourceId             IcoGetIndexFromPeResourceIdW
#define IcoExtractIconGroupFromPeFileEx         IcoExtractIconGroupFromPeFileExW
#define IcoExtractIconGroupFromPeFile           IcoExtractIconGroupFromPeFileW
#define IcoAbortPeEnumIconGroup                 IcoAbortPeEnumIconGroupW
#define IcoEnumFirstIconGroupInPeFileEx         IcoEnumFirstIconGroupInPeFileExW
#define IcoEnumFirstIconGroupInPeFile           IcoEnumFirstIconGroupInPeFileW
#define IcoEnumNextIconGroupInPeFile            IcoEnumNextIconGroupInPeFileW
#define IcoExtractIconGroupByIndexFromPeFileEx  IcoExtractIconGroupByIndexFromPeFileExW
#define IcoExtractIconGroupByIndexFromPeFile    IcoExtractIconGroupByIndexFromPeFileW
#define IcoWriteIconGroupToPeFileEx             IcoWriteIconGroupToPeFileExW
#define IcoWriteIconGroupToPeFile               IcoWriteIconGroupToPeFileW
#define IcoGetIndexFromNeResourceIdEx           IcoGetIndexFromNeResourceIdExW
#define IcoGetIndexFromNeResourceId             IcoGetIndexFromNeResourceIdW
#define IcoExtractIconGroupFromNeFileEx         IcoExtractIconGroupFromNeFileExW
#define IcoExtractIconGroupFromNeFile           IcoExtractIconGroupFromNeFileW
#define IcoAbortNeEnumIconGroup                 IcoAbortNeEnumIconGroupW
#define IcoEnumFirstIconGroupInNeFileEx         IcoEnumFirstIconGroupInNeFileExW
#define IcoEnumFirstIconGroupInNeFile           IcoEnumFirstIconGroupInNeFileW
#define IcoEnumNextIconGroupInNeFile            IcoEnumNextIconGroupInNeFileW
#define IcoExtractIconGroupByIndexFromNeFileEx  IcoExtractIconGroupByIndexFromNeFileExW
#define IcoExtractIconGroupByIndexFromNeFile    IcoExtractIconGroupByIndexFromNeFileW
#define IcoAbortEnumIconGroup                   IcoAbortEnumIconGroupW
#define IcoEnumFirstIconGroupInFile             IcoEnumFirstIconGroupInFileW
#define IcoEnumNextIconGroupInFile              IcoEnumNextIconGroupInFileW
#define IcoExtractIconGroupFromFile             IcoExtractIconGroupFromFileW
#define IcoExtractIconGroupByIndexFromFile      IcoExtractIconGroupByIndexFromFileW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\inf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    inf.h

Abstract:

    Declares interface for INF wrapper routines.  These routines simplify
    access of INFs by wrapping the setup APIs with routines that use
    pools or grow buffers.

    The INF wrapper routines also implement append and replace capabilities,
    so any INF used by the Win9x upgrade can be appended in the future, or
    completely replaced.

Author:

    Marc R. Whitten (marcw) 20-Oct-1997

Revision History:

    jimschm     05-Jan-1999     INF parser moved to migutil
    marcw       28-Oct-1998     Append/Replace capability
    marcw       08-Aug-1997     Pool/Growbuf routines

--*/


typedef enum {
    INF_USE_PMHANDLE,
    INF_USE_GROWBUFFER,
    INF_USE_PRIVATE_GROWBUFFER,
    INF_USE_PRIVATE_PMHANDLE
} ALLOCATORTYPES;

typedef struct {
    INFCONTEXT      Context;
    GROWBUFFER      GrowBuffer;
    PMHANDLE        PoolHandle;
    ALLOCATORTYPES  Allocator;
} INFSTRUCT, *PINFSTRUCT;

#define INFCONTEXT_INIT {NULL,NULL,0,0}
#define INITINFSTRUCT_GROWBUFFER {INFCONTEXT_INIT,INIT_GROWBUFFER,NULL,INF_USE_PRIVATE_GROWBUFFER}
#define INITINFSTRUCT_PMHANDLE {INFCONTEXT_INIT,INIT_GROWBUFFER,NULL,INF_USE_PRIVATE_PMHANDLE}
#define InfOpenAppendInfFile    SetupOpenAppendInfFile



VOID
InfGlobalInit (
    IN  BOOL Terminate
    );

VOID
InfCleanUpInfStruct (
    PINFSTRUCT Context
    );

VOID
InitInfStruct (
    OUT PINFSTRUCT Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  PMHANDLE PoolHandle  OPTIONAL
    );



#define InfOpenInfFileA(f)              TRACK_BEGIN(HINF, InfOpenInfFile)\
                                        RealInfOpenInfFileA((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        TRACK_END()

#define InfOpenInfFileW(f)              TRACK_BEGIN(HINF, InfOpenInfFile)\
                                        RealInfOpenInfFileW((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        TRACK_END()



HINF
RealInfOpenInfFileA (
    IN PCSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

HINF
RealInfOpenInfFileW (
    IN PCWSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

VOID
InfCloseInfFile (HINF Inf);

//
// See the macros below before calling InfOpenInfInAllSourcesA or W.
//
HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    );

HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    );

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCT
    );


PWSTR
InfGetLineTextW (
    IN OUT  PINFSTRUCT
    );

PSTR
InfGetStringFieldA (
    IN OUT PINFSTRUCT    Context,
    IN     UINT         FieldIndex
    );

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCT    Context,
    IN     UINT         FieldIndex
    );

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    ) ;

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    ) ;


BOOL
InfGetIntField (
    IN PINFSTRUCT       Context,
    IN UINT            FieldIndex,
    IN PINT             Value
    );

PBYTE
InfGetBinaryField (
    IN  PINFSTRUCT      Context,
    IN  UINT           FieldIndex
    );

BOOL
InfGetLineByIndexA(
    IN HINF InfHandle,
    IN PCSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
);

BOOL
InfGetLineByIndexW(
    IN HINF InfHandle,
    IN PCWSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
);

BOOL
InfFindFirstLineA (
    IN HINF             InfHandle,
    IN PCSTR            Section,
    IN PCSTR            Key,
    OUT PINFSTRUCT      Context
    );

BOOL
InfFindFirstLineW (
    IN HINF             InfHandle,
    IN PCWSTR           Section,
    IN PCWSTR           Key,
    OUT PINFSTRUCT      Context
    );

BOOL
InfFindNextLine (
    IN OUT PINFSTRUCT   Context
    );

UINT
InfGetFieldCount (
    IN PINFSTRUCT       Context
    );


PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCT Context,
    IN      UINT Field
    );

BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PSTR ReturnBuffer,
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize
    );

VOID
InfResetInfStruct (
    IN OUT PINFSTRUCT Context
    );

VOID
InfLogContext (
    IN      PCSTR LogType,
    IN      HINF InfHandle,
    IN      PINFSTRUCT InfStruct
    );

VOID
InfNameHandle (
    IN      HINF Inf,
    IN      PCSTR NewName,
    IN      BOOL OverwriteExistingName
    );

//
// INF parser
//

typedef struct _tagINFLINE {
    PCWSTR Key;             OPTIONAL
    PCWSTR Data;
    DWORD LineFlags;
    struct _tagINFLINE *Next, *Prev;
    struct _tagINFSECTION *Section;
} INFLINE, *PINFLINE;

#define LINEFLAG_KEY_QUOTED         0x0001
#define LINEFLAG_ALL_COMMENTS       0x0002
#define LINEFLAG_TRAILING_COMMENTS  0x0004


typedef struct _tagINFSECTION {
    PCWSTR Name;
    PINFLINE FirstLine;
    PINFLINE LastLine;
    UINT LineCount;
    struct _tagINFSECTION *Next, *Prev;
} INFSECTION, *PINFSECTION;

PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    );

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    );


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    );

PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    );

PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    );

PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    );

PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    );

PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    );

UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    );

BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    );

BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    );

HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileA(Path) OpenInfFileExA (Path, NULL, TRUE)

HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileW(Path) OpenInfFileExW (Path, NULL, TRUE)

VOID
CloseInfFile (
    HINF InfFile
    );

BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    );

BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    );


//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#   define InfFindFirstLine                 InfFindFirstLineW
#   define InfGetLineByIndex                InfGetLineByIndexW
#   define InfGetStringField                InfGetStringFieldW
#   define InfGetMultiSzField               InfGetMultiSzFieldW
#   define InfGetLineText                   InfGetLineTextW
#   define InfOpenInfFile                   InfOpenInfFileW
#   define InfGetOemStringField             InfGetStringFieldW
#   define SetupGetOemStringField           SetupGetStringFieldW
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesW((x),1,&g_SourceDirectory);
#   define AddInfSectionToTable             AddInfSectionToTableW
#   define FindInfSectionInTable            FindInfSectionInTableW
#   define AddInfLineToTable                AddInfLineToTableW
#   define FindLineInInfSection             FindLineInInfSectionW
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrW
#   define OpenInfFileEx                    OpenInfFileExW
#   define OpenInfFile                      OpenInfFileW
#   define SaveInfFile                      SaveInfFileW


#else

#   define InfFindFirstLine                 InfFindFirstLineA
#   define InfGetLineByIndex                InfGetLineByIndexA
#   define InfGetStringField                InfGetStringFieldA
#   define InfGetMultiSzField               InfGetMultiSzFieldA
#   define InfGetLineText                   InfGetLineTextA
#   define InfOpenInfFile                   InfOpenInfFileA
#   define InfGetOemStringField             InfGetOemStringFieldA
#   define SetupGetOemStringField           SetupGetOemStringFieldA
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesA((x),g_SourceDirectoryCount,g_SourceDirectories);
#   define AddInfSectionToTable             AddInfSectionToTableA
#   define FindInfSectionInTable            FindInfSectionInTableA
#   define AddInfLineToTable                AddInfLineToTableA
#   define FindLineInInfSection             FindLineInInfSectionA
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrA
#   define OpenInfFileEx                    OpenInfFileExA
#   define OpenInfFile                      OpenInfFileA
#   define SaveInfFile                      SaveInfFileA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\linkpif.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    linkpif.h

Abstract:

    Implements routines to manage .LNK and .PIF files.  This
    is a complete redesign from the work that MikeCo did.

Author:

    Calin Negreanu (calinn)     23-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Types
//

typedef struct _LNK_EXTRA_DATAA {
    BOOL    FullScreen;
    DWORD   xSize;
    DWORD   ySize;
    BOOL    QuickEdit;
    CHAR    FontName [LF_FACESIZE];
    DWORD   xFontSize;
    DWORD   yFontSize;
    DWORD   FontWeight;
    DWORD   FontFamily;
    WORD    CurrentCodePage;
} LNK_EXTRA_DATAA, *PLNK_EXTRA_DATAA;

typedef struct _LNK_EXTRA_DATAW {
    BOOL    FullScreen;
    DWORD   xSize;
    DWORD   ySize;
    BOOL    QuickEdit;
    WCHAR   FontName [LF_FACESIZE];
    DWORD   xFontSize;
    DWORD   yFontSize;
    DWORD   FontWeight;
    DWORD   FontFamily;
    WORD    CurrentCodePage;
} LNK_EXTRA_DATAW, *PLNK_EXTRA_DATAW;

//
// APIs
//

BOOL
InitCOMLinkA (
    OUT     IShellLinkA **ShellLink,
    OUT     IPersistFile **PersistFile
    );

BOOL
InitCOMLinkW (
    OUT     IShellLinkW **ShellLink,
    OUT     IPersistFile **PersistFile
    );

BOOL
FreeCOMLinkA (
    IN OUT  IShellLinkA **ShellLink,
    IN OUT  IPersistFile **PersistFile
    );

BOOL
FreeCOMLinkW (
    IN OUT  IShellLinkW **ShellLink,
    IN OUT  IPersistFile **PersistFile
    );

BOOL
ExtractPifInfoA(
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData       OPTIONAL
    );

BOOL
ExtractPifInfoW(
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData       OPTIONAL
    );

BOOL
ExtractUrlInfoA(
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber
    );

BOOL
ExtractUrlInfoW(
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber
    );

BOOL
ExtractShellLinkInfoA (
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShellLinkInfoW (
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShortcutInfoA (
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData, OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShortcutInfoW (
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData, OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ModifyShellLinkFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,               OPTIONAL
    IN      PCSTR Params,               OPTIONAL
    IN      PCSTR WorkDir,              OPTIONAL
    IN      PCSTR IconPath,             OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAA ExtraData, OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ModifyShellLinkFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,               OPTIONAL
    IN      PCWSTR Params,               OPTIONAL
    IN      PCWSTR WorkDir,              OPTIONAL
    IN      PCWSTR IconPath,             OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAW ExtraData, OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ModifyPifFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,       OPTIONAL
    IN      PCSTR Params,       OPTIONAL
    IN      PCSTR WorkDir,      OPTIONAL
    IN      PCSTR IconPath,     OPTIONAL
    IN      INT  IconNumber
    );

BOOL
ModifyPifFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,          OPTIONAL
    IN      PCWSTR Params,          OPTIONAL
    IN      PCWSTR WorkDir,         OPTIONAL
    IN      PCWSTR IconPath,        OPTIONAL
    IN      INT  IconNumber
    );

BOOL
ModifyUrlFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,       OPTIONAL
    IN      PCSTR IconPath,     OPTIONAL
    IN      INT  IconNumber
    );

BOOL
ModifyUrlFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,          OPTIONAL
    IN      PCWSTR IconPath,        OPTIONAL
    IN      INT  IconNumber
    );

BOOL
ModifyShortcutFileExA (
    IN      PCSTR FileName,
    IN      PCSTR ForcedExtension,        OPTIONAL
    IN      PCSTR Target,                 OPTIONAL
    IN      PCSTR Params,                 OPTIONAL
    IN      PCSTR WorkDir,                OPTIONAL
    IN      PCSTR IconPath,               OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAA ExtraData,   OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );
#define ModifyShortcutFileA(n,t,p,w,i,in,hk,ed,sl,pf) ModifyShortcutFileExA(n,NULL,t,p,w,i,in,hk,ed,sl,pf)

BOOL
ModifyShortcutFileExW (
    IN      PCWSTR FileName,
    IN      PCWSTR ForcedExtension,       OPTIONAL
    IN      PCWSTR Target,                OPTIONAL
    IN      PCWSTR Params,                OPTIONAL
    IN      PCWSTR WorkDir,               OPTIONAL
    IN      PCWSTR IconPath,              OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAW ExtraData,   OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );
#define ModifyShortcutFileW(n,t,p,w,i,in,hk,ed,sl,pf) ModifyShortcutFileExW(n,NULL,t,p,w,i,in,hk,ed,sl,pf)

//
// Macros
//

#ifdef UNICODE

#define InitCOMLink             InitCOMLinkW
#define FreeCOMLink             FreeCOMLinkW
#define ExtractPifInfo          ExtractPifInfoW
#define ExtractUrlInfo          ExtractUrlInfoW
#define ExtractShellLinkInfo    ExtractShellLinkInfoW
#define ExtractShortcutInfo     ExtractShortcutInfoW
#define LNK_EXTRA_DATA          LNK_EXTRA_DATAW
#define PLNK_EXTRA_DATA         PLNK_EXTRA_DATAW
#define ModifyShellLinkFile     ModifyShellLinkFileW
#define ModifyPifFile           ModifyPifFileW
#define ModifyUrlFile           ModifyUrlFileW
#define ModifyShortcutFileEx    ModifyShortcutFileExW
#define ModifyShortcutFile      ModifyShortcutFileW

#else

#define InitCOMLink             InitCOMLinkA
#define FreeCOMLink             FreeCOMLinkA
#define ExtractPifInfo          ExtractPifInfoA
#define ExtractUrlInfo          ExtractUrlInfoA
#define ExtractShellLinkInfo    ExtractShellLinkInfoA
#define ExtractShortcutInfo     ExtractShortcutInfoA
#define LNK_EXTRA_DATA          LNK_EXTRA_DATAA
#define PLNK_EXTRA_DATA         PLNK_EXTRA_DATAA
#define ModifyShellLinkFile     ModifyShellLinkFileA
#define ModifyPifFile           ModifyPifFileA
#define ModifyUrlFile           ModifyUrlFileA
#define ModifyShortcutFileEx    ModifyShortcutFileExA
#define ModifyShortcutFile      ModifyShortcutFileA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\log.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    log.h

Abstract:

    Implements routines that simplify the writing to setupact.log
    and setuperr.log.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    mikeco      23-May-1997     Ran code through train_wreck.exe
    Ovidiu Temereanca (ovidiut) 23-Oct-1998
        Added new logging capabilities

*/


//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef DEBUG
#ifndef DBG
#define DBG
#endif
#endif

//
// Redefine MYASSERT
//

#ifdef DEBUG

#ifdef MYASSERT
#undef MYASSERT
#endif

#define DBG_ASSERT          "Assert"

#define MYASSERT(expr)          LogBegin(g_hInst);                      \
                                LogIfA(                                 \
                                !(expr),                                \
                                DBG_ASSERT,                             \
                                "Assert Failure\n\n%s\n\n%s line %u",   \
                                #expr,                                  \
                                __FILE__,                               \
                                __LINE__                                \
                                );                                      \
                                LogEnd()

#else

#ifndef MYASSERT
#define MYASSERT(x)
#endif

#endif

#define LOG_FATAL_ERROR  "Fatal Error"
#define LOG_MODULE_ERROR "Module Error"
#define LOG_ERROR        "Error"
#define LOG_WARNING      "Warning"
#define LOG_INFORMATION  "Info"
#define LOG_STATUS       "Status"
#define LOG_UPDATE       "Update"

typedef enum {
    LOGSEV_DEBUG = 0,
    LOGSEV_INFORMATION = 1,
    LOGSEV_WARNING = 2,
    LOGSEV_ERROR = 3,
    LOGSEV_FATAL_ERROR = 4
} LOGSEVERITY;

typedef struct {
    BOOL Debug;
    HMODULE ModuleInstance;
    LOGSEVERITY Severity;       // non-debug only
    PCSTR Type;
    PCSTR Message;              // debug only
    PCSTR FormattedMessage;
} LOGARGA, *PLOGARGA;

typedef struct {
    BOOL Debug;
    HMODULE ModuleInstance;
    LOGSEVERITY Severity;       // non-debug only
    PCSTR Type;                 // note ansi type
    PCWSTR Message;             // debug only
    PCWSTR FormattedMessage;
} LOGARGW, *PLOGARGW;

typedef enum {
    OD_UNDEFINED = 0x00,            // undefined output dest
    OD_DEBUGLOG = 0x01,             // debuglog used
    OD_SUPPRESS = 0x02,             // don't log to any device
    OD_ERROR = 0x04,                // automatically append GetLastError() to the message
    OD_LOGFILE = 0x08,              // messages go to logfile
    OD_DEBUGGER = 0x10,             // messages go to debugger
    OD_CONSOLE = 0x20,              // messages go to console
    OD_POPUP = 0x40,                // display a popup dialog
    OD_POPUP_CANCEL = 0x80,         // do not display a popup dialog (cancelled by user)
    OD_FORCE_POPUP = 0x100,         // force the popup to be displayed always
    OD_MUST_BE_LOCALIZED = 0x200,   // used for LOG() that will generate a popup
    OD_UNATTEND_POPUP = 0x400,      // force the popup to be displayed in unattend mode
    OD_ASSERT = 0x800,              // give DebugBreak option in popup
} OUTPUT_DESTINATION;

typedef enum {
    LL_FATAL_ERROR = 0x01,
    LL_MODULE_ERROR = 0x02,
    LL_ERROR = 0x04,
    LL_WARNING = 0x08,
    LL_INFORMATION = 0x10,
    LL_STATUS = 0x20,
    LL_UPDATE = 0x40,
} LOG_LEVEL;

typedef BOOL (WINAPI LOGCALLBACKA)(PLOGARGA Args);
typedef LOGCALLBACKA * PLOGCALLBACKA;

typedef BOOL (WINAPI LOGCALLBACKW)(PLOGARGW Args);
typedef LOGCALLBACKW * PLOGCALLBACKW;

VOID
LogBegin (
    IN      HMODULE ModuleInstance
    );

VOID
LogEnd (
    VOID
    );

BOOL
LogReInitA (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCSTR LogFile,              OPTIONAL
    IN      PLOGCALLBACKA LogCallback   OPTIONAL
    );

BOOL
LogReInitW (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCWSTR LogFile,             OPTIONAL
    IN      PLOGCALLBACKW LogCallback   OPTIONAL
    );

VOID
LogSetVerboseLevel (
    IN      OUTPUT_DESTINATION Level
    );

VOID
LogSetVerboseBitmap (
    IN      LOG_LEVEL Bitmap,
    IN      LOG_LEVEL BitsToAdjustMask,
    IN      BOOL EnableDebugger
    );

#ifdef UNICODE

#define LOGARG          LOGARGW
#define LOGCALLBACK     LOGCALLBACKW
#define PLOGARG         PLOGARGW
#define PLOGCALLBACK    PLOGCALLBACKW

#define LogReInit       LogReInitW

#else

#define LOGARG          LOGARGA
#define LOGCALLBACK     LOGCALLBACKA
#define PLOGARG         PLOGARGA
#define PLOGCALLBACK    PLOGCALLBACKA

#define LogReInit       LogReInitA

#endif

VOID
LogDeleteOnNextInit(
    VOID
    );

#define SET_RESETLOG()   LogDeleteOnNextInit()

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title
    );

VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title
    );

VOID
LogLineA (
    IN      PCSTR Line
    );

VOID
LogLineW (
    IN      PCWSTR Line
    );

VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    );

VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    );

VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    );

BOOL
LogSetErrorDest (
    IN      PCSTR Type,
    IN      OUTPUT_DESTINATION OutDest
    );

// Define W symbols

extern HMODULE g_hInst;

#define LOGW(x) LogBegin(g_hInst);LogW x;LogEnd()
#define LOGW_IF(x) LogBegin(g_hInst);LogIfW x;LogEnd()
#define ELSE_LOGW(x) else {LogBegin(g_hInst);LogW x;LogEnd();}
#define ELSE_LOGW_IF(x) else {LogBegin(g_hInst);LogIfW x;LogEnd();}
#define LOGTITLEW(type,title) LogBegin(g_hInst);LogTitleW (type,title);LogEnd()
#define LOGLINEW(title) LogBegin(g_hInst);LogLineW (title);LogEnd()
#define LOGDIRECTW(type,text) LogBegin(g_hInst);LogDirectW (type,text);LogEnd()

// Define A symbols

#define LOGA(x) LogBegin(g_hInst);LogA x;LogEnd()
#define LOGA_IF(x) LogBegin(g_hInst);LogIfA x;LogEnd()
#define ELSE_LOGA(x) else {LogBegin(g_hInst);LogA x;LogEnd();}
#define ELSE_LOGA_IF(x) else {LogBegin(g_hInst);LogIfA x;LogEnd();}
#define LOGTITLEA(type,title) LogBegin(g_hInst);LogTitleA (type,title);LogEnd()
#define LOGLINEA(line) LogBegin(g_hInst);LogLineA (line);LogEnd()
#define LOGDIRECTA(type,text) LogBegin(g_hInst);LogDirectA (type,text);LogEnd()

// Define generic symbols

#ifdef UNICODE

#define LOG(x) LOGW(x)
#define LOG_IF(x) LOGW_IF(x)
#define ELSE_LOG(x) ELSE_LOGW(x)
#define ELSE_LOG_IF(x) ELSE_LOGW_IF(x)
#define LOGTITLE(type,title) LOGTITLEW(type,title)
#define LOGLINE(title) LOGLINEW(title)
#define LOGDIRECT(type,text) LOGDIRECTW(type,text)

#else

#define LOG(x) LOGA(x)
#define LOG_IF(x) LOGA_IF(x)
#define ELSE_LOG(x) ELSE_LOGA(x)
#define ELSE_LOG_IF(x) ELSE_LOGA_IF(x)
#define LOGTITLE(type,title) LOGTITLEA(type,title)
#define LOGLINE(title) LOGLINEA(title)
#define LOGDIRECT(type,text) LOGDIRECTA(type,text)

#endif // UNICODE


#ifdef DEBUG

#define DBG_NAUSEA      "Nausea"
#define DBG_VERBOSE     "Verbose"
#define DBG_STATS       "Stats"
#define DBG_WARNING     "Warning"
#define DBG_ERROR       "Error"
#define DBG_WHOOPS      "Whoops"
#define DBG_TRACK       "Track"
#define DBG_TIME        "Time"


VOID
_cdecl
DbgLogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DbgLogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DbgLogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DbgLogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
DbgDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    );

VOID
DbgDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    );


VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    );

VOID
LogCopyDebugInfPathA(
    OUT     PSTR MaxPathBuffer
    );

VOID
LogCopyDebugInfPathW(
    OUT     PWSTR MaxPathBuffer
    );


// Define W symbols

#define DEBUGMSGW(x) LogBegin(g_hInst);DbgLogW x;LogEnd()
#define DEBUGMSGW_IF(x) LogBegin(g_hInst);DbgLogIfW x;LogEnd()
#define ELSE_DEBUGMSGW(x) else {LogBegin(g_hInst);DbgLogW x;LogEnd();}
#define ELSE_DEBUGMSGW_IF(x) else {LogBegin(g_hInst);DbgLogW x;LogEnd();}
#define DEBUGLOGTIMEW(x) LogBegin(g_hInst);DebugLogTimeW x;LogEnd()
#define DEBUGDIRECTW(type,text) LogBegin(g_hInst);DbgDirectW (type,text);LogEnd()


// Define A symbols

#define DEBUGMSGA(x) LogBegin(g_hInst);DbgLogA x;LogEnd()
#define DEBUGMSGA_IF(x) LogBegin(g_hInst);DbgLogIfA x;LogEnd()
#define ELSE_DEBUGMSGA(x) else {LogBegin(g_hInst);DbgLogA x;LogEnd();}
#define ELSE_DEBUGMSGA_IF(x) else {LogBegin(g_hInst);DbgLogIfA x;LogEnd();}
#define DEBUGLOGTIMEA(x) LogBegin(g_hInst);DebugLogTimeA x;LogEnd()
#define DEBUGDIRECTA(type,text) LogBegin(g_hInst);DbgDirectA (type,text);LogEnd()

// Define generic symbols

#ifdef UNICODE

#define DEBUGMSG(x) DEBUGMSGW(x)
#define DEBUGMSG_IF(x) DEBUGMSGW_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGW(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGW_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEW(x)
#define DEBUGDIRECT(type,text) DEBUGDIRECTW(type,text)
#define LogCopyDebugInfPath LogCopyDebugInfPathW

#else

#define DEBUGMSG(x) DEBUGMSGA(x)
#define DEBUGMSG_IF(x) DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGA_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEA(x)
#define DEBUGDIRECT(type,text) DEBUGDIRECTA(type,text)
#define LogCopyDebugInfPath LogCopyDebugInfPathA

#endif // UNICODE

#else // !defined(DEBUG)

//
// No-debug constants
//

#define DEBUGMSG(x)
#define DEBUGMSGA(x)
#define DEBUGMSGW(x)

#define DEBUGMSG_IF(x)
#define DEBUGMSGA_IF(x)
#define DEBUGMSGW_IF(x)

#define ELSE_DEBUGMSG(x)
#define ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSGW(x)

#define ELSE_DEBUGMSG_IF(x)
#define ELSE_DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSGW_IF(x)

#define DEBUGLOGTIME(x)

#define DEBUGDIRECTA(type,text)
#define DEBUGDIRECTW(type,text)
#define DEBUGDIRECT(type,text)

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\ini.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ini.h

Abstract:

    Declares interface for INI wrapper routines. These routines simplify
    access of INIs by wrapping the Win32 APIs with routines that use pools.

Author:

    04-Nov-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef struct {
    PCSTR   IniFilePath;
    DWORD   OriginalAttributes;
} INIFILEA, *PINIFILEA;

typedef struct {
    PCWSTR  IniFilePath;
    DWORD   OriginalAttributes;
} INIFILEW, *PINIFILEW;


typedef struct {
    PCSTR   CurrentSection;
    PCSTR   Sections;
} INISECT_ENUMA, *PINISECT_ENUMA;

typedef struct {
    PCWSTR  CurrentSection;
    PCWSTR  Sections;
} INISECT_ENUMW, *PINISECT_ENUMW;


typedef struct {
    PCSTR   CurrentKeyValuePair;
    PCSTR   KeyValuePairs;
    PCSTR   CurrentKey;
    PCSTR   CurrentValue;
    PSTR    Private;
} INIKEYVALUE_ENUMA, *PINIKEYVALUE_ENUMA;

typedef struct {
    PCWSTR  CurrentKeyValuePair;
    PCWSTR  KeyValuePairs;
    PCWSTR  CurrentKey;
    PCWSTR  CurrentValue;
    PWSTR   Private;
} INIKEYVALUE_ENUMW, *PINIKEYVALUE_ENUMW;

//
// Public function prototypes
//

BOOL
Ini_Init (
    VOID
    );

VOID
Ini_Exit (
    VOID
    );


BOOL
RealIniFileOpenA (
    OUT     PINIFILEA IniFile,
    IN      PCSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    );

#define IniFileOpenA(i,path,b)  TRACK_BEGIN(BOOL, IniFileOpenA)\
                                RealIniFileOpenA((i),(path),(b)/*,*/ ALLOCATION_TRACKING_CALL)\
                                TRACK_END()

BOOL
RealIniFileOpenW (
    OUT     PINIFILEW IniFile,
    IN      PCWSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    );

#define IniFileOpenW(i,path,b)  TRACK_BEGIN(BOOL, IniFileOpenW)\
                                RealIniFileOpenW((i),(path),(b)/*,*/ ALLOCATION_TRACKING_CALL)\
                                TRACK_END()


VOID
IniFileCloseA (
    IN      PINIFILEA IniFile
    );

VOID
IniFileCloseW (
    IN      PINIFILEW IniFile
    );

BOOL
EnumFirstIniSectionA (
    OUT     PINISECT_ENUMA IniSectEnum,
    IN      PINIFILEA IniFile
    );

BOOL
EnumFirstIniSectionW (
    OUT     PINISECT_ENUMW IniSectEnum,
    IN      PINIFILEW IniFile
    );

BOOL
EnumNextIniSectionA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    );

BOOL
EnumNextIniSectionW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    );

VOID
AbortIniSectionEnumA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    );

VOID
AbortIniSectionEnumW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    );

BOOL
EnumFirstIniKeyValueA (
    OUT     PINIKEYVALUE_ENUMA IniKeyValueEnum,
    IN      PINIFILEA IniFile,
    IN      PCSTR Section
    );

BOOL
EnumFirstIniKeyValueW (
    OUT     PINIKEYVALUE_ENUMW IniKeyValueEnum,
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section
    );

BOOL
EnumNextIniKeyValueA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    );

BOOL
EnumNextIniKeyValueW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    );

VOID
AbortIniKeyValueEnumA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    );

VOID
AbortIniKeyValueEnumW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    );

BOOL
IniReadValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    OUT     PSTR* Value,            OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    );

BOOL
IniReadValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR* Value,           OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    );

VOID
IniFreeReadValueA (
    IN      PCSTR Value
    );

VOID
IniFreeReadValueW (
    IN      PCWSTR Value
    );

BOOL
IniWriteValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    IN      PCSTR Value
    );

BOOL
IniWriteValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    IN      PCWSTR Value
    );


//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#define INIFILE                         INIFILEW
#define INISECT_ENUM                    INISECT_ENUMW
#define INIKEYVALUE_ENUM                INIKEYVALUE_ENUMW

#define IniFileOpen                     IniFileOpenW
#define IniFileClose                    IniFileCloseW
#define EnumFirstIniSection             EnumFirstIniSectionW
#define EnumNextIniSection              EnumNextIniSectionW
#define AbortIniSectionEnum             AbortIniSectionEnumW
#define EnumFirstIniKeyValue            EnumFirstIniKeyValueW
#define EnumNextIniKeyValue             EnumNextIniKeyValueW
#define AbortIniKeyValueEnum            AbortIniKeyValueEnumW
#define IniReadValue                    IniReadValueW
#define IniFreeReadValue                IniFreeReadValueW
#define IniWriteValue                   IniWriteValueW

#else

#define INIFILE                         INIFILEA
#define INISECT_ENUM                    INISECT_ENUMA
#define INIKEYVALUE_ENUM                INIKEYVALUE_ENUMA

#define IniFileOpen                     IniFileOpenA
#define IniFileClose                    IniFileCloseA
#define EnumFirstIniSection             EnumFirstIniSectionA
#define EnumNextIniSection              EnumNextIniSectionA
#define AbortIniSectionEnum             AbortIniSectionEnumA
#define EnumFirstIniKeyValue            EnumFirstIniKeyValueA
#define EnumNextIniKeyValue             EnumNextIniKeyValueA
#define AbortIniKeyValueEnum            AbortIniKeyValueEnumA
#define IniReadValue                    IniReadValueA
#define IniFreeReadValue                IniFreeReadValueA
#define IniWriteValue                   IniWriteValueA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\main.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    main.h

Abstract:

    Declares the interface to utils\main

Author:

    Jim Schmidt (jimschm) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/


//
// MAX constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_SERVER_NAMEA + (20 * 2))
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_TRANSLATION             32
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_SERVER_NAMEW + 20)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

//
// Prototypes
//

VOID
UtInitialize (
    IN      HANDLE Heap             OPTIONAL
    );

VOID
UtTerminate (
    VOID
    );

HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    );

HANDLE
StartProcessA (
    IN      PCSTR CmdLine
    );

HANDLE
StartProcessW (
    IN      PCWSTR CmdLine
    );

#ifdef UNICODE

#define StartProcess            StartProcessW

#else

#define StartProcess            StartProcessA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\memdb.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdb.h

Abstract:

    Declares interfaces for memdb, the memory database.  MemDb is
    used throughout the Win9x upgrade project to record OS state
    and to track operations on files and the registry.

    See common\memdb for implementation details.

Author:

    Jim Schmidt (jimschm) 15-Nov-1996

Revision History:

    mvander     13-Aug-1999     many changes
    jimschm     05-Apr-1999     MemDbGetStoredEndPatternValue
    jimschm     18-Jan-1999     Version APIs
    jimschm     23-Sep-1998     Proxy node capability
    jimschm     24-Jun-1998     MemDbMove capability
    jimschm     30-Oct-1997     Temporary hive capability
    jimschm     31-Jul-1997     Hashing for faster access
    jimschm     19-Mar-1997     Binary node capability
    jimschm     28-Feb-1997     Offset access capabilities
    jimschm     20-Dec-1996     Ex routines

--*/

#pragma once

#define MEMDB_MAX 2048

//
// My net share flag, used to distinguish user-level security and
// password-level security.  When it is specified, user-level
// security is enabled, and NetShares\<share>\ACL\<list> exists.
//

#define SHI50F_ACLS         0x1000


//
// Dataflags for enuming key data
//

#define DATAFLAG_INSTANCEMASK   0x03
#define DATAFLAG_UNORDERED      0x04
#define DATAFLAG_SINGLELINK     0x08
#define DATAFLAG_DOUBLELINK     0x10
#define DATAFLAG_BINARYMASK     0x1C
#define DATAFLAG_VALUE          0x20
#define DATAFLAG_FLAGS          0x40
#define DATAFLAG_ALL            (DATAFLAG_INSTANCEMASK|DATAFLAG_UNORDERED|DATAFLAG_SINGLELINK|DATAFLAG_DOUBLELINK|DATAFLAG_VALUE|DATAFLAG_FLAGS)

//
// Constant for MemDbKeyFromHandle
//

#define MEMDB_LAST_LEVEL        0xFFFFFFFF

//
// Types
//


typedef UINT KEYHANDLE;
typedef UINT DATAHANDLE;

typedef struct {
    BOOL Valid;
    BOOL Debug;
    UINT Version;
    BOOL CurrentVersion;
} MEMDB_VERSION, *PMEMDB_VERSION;

//
// Flags for enumeration routines
//
#define ENUMFLAG_INSTANCEMASK       0x0003
#define ENUMFLAG_UNORDERED          0x0004
#define ENUMFLAG_SINGLELINK         0x0008
#define ENUMFLAG_DOUBLELINK         0x0010
#define ENUMFLAG_BINARYMASK         0x001C
#define ENUMFLAG_VALUE              0x0020
#define ENUMFLAG_FLAGS              0x0040
#define ENUMFLAG_EMPTY              0x0080
#define ENUMFLAG_ENDPOINTS          0x0100
#define ENUMFLAG_NONENDPOINTS       0x0200

#define ENUMFLAG_ALLDATA        (ENUMFLAG_BINARYMASK|ENUMFLAG_VALUE|ENUMFLAG_FLAGS|ENUMFLAG_EMPTY)
#define ENUMFLAG_ALLSEGMENTS    (ENUMFLAG_ENDPOINTS|ENUMFLAG_NONENDPOINTS)

#define ENUMFLAG_ALL            (ENUMFLAG_ALLDATA|ENUMFLAG_ALLSEGMENTS)

#define ENUMFLAG_NORMAL         (ENUMFLAG_ALLDATA|ENUMFLAG_ENDPOINTS)

#define ENUMLEVEL_LASTLEVEL         0xFFFFFFFF
#define ENUMLEVEL_ALLLEVELS         0xFFFFFFFF

typedef BOOL(MEMDB_PATTERNFINDW)(PCWSTR);
typedef MEMDB_PATTERNFINDW * PMEMDB_PATTERNFINDW;

typedef BOOL(MEMDB_PATTERNMATCHW)(PCVOID, PCWSTR);
typedef MEMDB_PATTERNMATCHW * PMEMDB_PATTERNMATCHW;

typedef struct {
    PMEMDB_PATTERNFINDW PatternFind;
    PMEMDB_PATTERNMATCHW PatternMatch;
    PCVOID Data;
} MEMDB_PATTERNSTRUCTW, *PMEMDB_PATTERNSTRUCTW;

typedef struct {
    WCHAR FullKeyName[MEMDB_MAX];
    WCHAR KeyName[MEMDB_MAX];
    UINT Value;
    UINT Flags;
    KEYHANDLE KeyHandle;
    BOOL EndPoint;

    // internally maintained members
    BYTE CurrentDatabaseIndex;
    BOOL EnumerationMode;
    UINT EnumFlags;
    PWSTR KeyNameCopy;
    PWSTR PatternCopy;
    PWSTR PatternPtr;
    PWSTR PatternEndPtr;
    UINT CurrentIndex;
    UINT BeginLevel;                   // 0-based first level of keys
    UINT EndLevel;                     // 0-based last level of keys
    UINT CurrentLevel;                 // 1-based level of keys
    GROWBUFFER TreeEnumBuffer;
    UINT TreeEnumLevel;
    MEMDB_PATTERNSTRUCTW PatternStruct;
} MEMDB_ENUMW, *PMEMDB_ENUMW;

typedef struct {
    CHAR FullKeyName[MEMDB_MAX];
    CHAR KeyName[MEMDB_MAX];
    UINT Value;
    UINT Flags;
    KEYHANDLE KeyHandle;
    BOOL EndPoint;

    // internally maintained members
    MEMDB_ENUMW UnicodeEnum;
} MEMDB_ENUMA, *PMEMDB_ENUMA;


//
// Function prototypes
//

BOOL
MemDbInitializeExA (
    IN      PCSTR DatabasePath  OPTIONAL
    );
#define MemDbInitializeA() MemDbInitializeExA(NULL)

BOOL
MemDbInitializeExW (
    IN      PCWSTR DatabasePath  OPTIONAL
    );
#define MemDbInitializeW() MemDbInitializeExW(NULL)

VOID
MemDbTerminateEx (
    IN      BOOL EraseDatabasePath
    );
#define MemDbTerminate() MemDbTerminateEx(FALSE)

PVOID
MemDbGetMemory (
    IN      UINT Size
    );

VOID
MemDbReleaseMemory (
    IN      PCVOID Memory
    );

KEYHANDLE
MemDbAddKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbAddKeyW (
    IN      PCWSTR KeyName
    );

KEYHANDLE
MemDbSetKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbSetKeyW (
    IN      PCWSTR KeyName
    );

BOOL
MemDbDeleteKeyA (
    IN      PCSTR KeyName
    );

BOOL
MemDbDeleteKeyW (
    IN      PCWSTR KeyName
    );

BOOL
MemDbDeleteKeyByHandle (
    IN      KEYHANDLE KeyHandle
    );

BOOL
MemDbDeleteTreeA (
    IN      PCSTR KeyName
    );

BOOL
MemDbDeleteTreeW (
    IN      PCWSTR KeyName
    );

PCSTR
MemDbGetKeyFromHandleA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    );

PCWSTR
MemDbGetKeyFromHandleW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    );

BOOL
MemDbGetKeyFromHandleExA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer          OPTIONAL
    );

BOOL
MemDbGetKeyFromHandleExW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer          OPTIONAL
    );

KEYHANDLE
MemDbGetHandleFromKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbGetHandleFromKeyW (
    IN      PCWSTR KeyName
    );

KEYHANDLE
MemDbSetValueAndFlagsExA (
    IN      PCSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

KEYHANDLE
MemDbSetValueAndFlagsExW (
    IN      PCWSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

BOOL
MemDbSetValueAndFlagsByHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

BOOL
MemDbGetValueAndFlagsA (
    IN      PCSTR KeyName,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

BOOL
MemDbGetValueAndFlagsW (
    IN      PCWSTR KeyName,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

BOOL
MemDbGetValueAndFlagsByHandle (
    IN      KEYHANDLE KeyHandle,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

#define MemDbSetValueAndFlagsA(k,v,s,c) MemDbSetValueAndFlagsExA(k,TRUE,v,FALSE,s,c)
#define MemDbSetValueAndFlagsW(k,v,s,c) MemDbSetValueAndFlagsExW(k,TRUE,v,FALSE,s,c)
#define MemDbSetValueAndFlagsByHandle(h,v,s,c) MemDbSetValueAndFlagsByHandleEx(h,TRUE,v,FALSE,s,c)

#define MemDbSetValueA(k,v) MemDbSetValueAndFlagsExA(k,TRUE,v,FALSE,0,0)
#define MemDbSetValueW(k,v) MemDbSetValueAndFlagsExW(k,TRUE,v,FALSE,0,0)
#define MemDbSetValueByHandle(h,v) MemDbSetValueAndFlagsByHandleEx(h,TRUE,v,FALSE,0,0)
#define MemDbGetValueA(k,v) MemDbGetValueAndFlagsA(k,v,NULL)
#define MemDbGetValueW(k,v) MemDbGetValueAndFlagsW(k,v,NULL)
#define MemDbGetValueByHandle(h,v) MemDbGetValueAndFlagsByHandle(h,v,NULL)

#define MemDbTestKeyA(k)  MemDbGetValueAndFlagsA(k,NULL,NULL)
#define MemDbTestKeyW(k)  MemDbGetValueAndFlagsW(k,NULL,NULL)
#define MemDbTestKeyByHandle(h) MemDbGetValueAndFlagsByHandle(h,NULL,NULL)

#define MemDbSetFlagsA(k,s,c) MemDbSetValueAndFlagsExA(k,FALSE,0,FALSE,s,c)
#define MemDbSetFlagsW(k,s,c) MemDbSetValueAndFlagsExW(k,FALSE,0,FALSE,s,c)
#define MemDbSetFlagsByHandle(h,s,c) MemDbSetValueAndFlagsByHandleEx(h,FALSE,0,FALSE,s,c)
#define MemDbReplaceFlagsA(k,f) MemDbSetValueAndFlagsExA(k,FALSE,0,TRUE,f,0)
#define MemDbReplaceFlagsW(k,f) MemDbSetValueAndFlagsExW(k,FALSE,0,TRUE,f,0)
#define MemDbReplaceFlagsByHandle(h,f) MemDbSetValueAndFlagsByHandleEx(h,FALSE,0,TRUE,f,0)
#define MemDbGetFlagsA(k,f) MemDbGetValueAndFlagsA(k,NULL,f)
#define MemDbGetFlagsW(k,f) MemDbGetValueAndFlagsW(k,NULL,f)
#define MemDbGetFlagsByHandle(h,f) MemDbGetValueAndFlagsByHandle(h,NULL,f)

DATAHANDLE
MemDbAddDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbAddDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbAddDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGetDataHandleA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

DATAHANDLE
MemDbGetDataHandleW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

PBYTE
MemDbGetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataExA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,     OPTIONAL
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataExW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,     OPTIONAL
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataByDataHandleEx (
    IN      DATAHANDLE DataHandle,
    IN OUT  PGROWBUFFER Buffer,     OPTIONAL
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataByKeyHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,     OPTIONAL
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbDeleteDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteDataByDataHandle (
    IN      DATAHANDLE DataHandle
    );

BOOL
MemDbDeleteDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance
    );

//
// High-level BLOB functions
//
#define MemDbAddUnorderedBlobA(k,i,d,s)  MemDbAddDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbAddUnorderedBlobW(k,i,d,s)  MemDbAddDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbAddUnorderedBlobByKeyHandle(h,i,d,s) MemDbAddDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobA(k,i,d,s)  MemDbSetDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobW(k,i,d,s)  MemDbSetDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobByDataHandle(h,d,s) MemDbSetDataByDataHandle(h,d,s)
#define MemDbSetUnorderedBlobByKeyHandle(h,i,d,s) MemDbSetDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobA(k,i,d,s)  MemDbGrowDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobW(k,i,d,s)  MemDbGrowDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobByDataHandle(h,d,s) MemDbGrowDataByDataHandle(h,d,s)
#define MemDbGrowUnorderedBlobByKeyHandle(h,i,d,s) MemDbGrowDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGetUnorderedBlobHandleA(k,i) MemDbGetDataHandleA(k,DATAFLAG_UNORDERED,i)
#define MemDbGetUnorderedBlobHandleW(k,i) MemDbGetDataHandleW(k,DATAFLAG_UNORDERED,i)
#define MemDbGetUnorderedBlobA(k,i,s) MemDbGetDataA(k,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobW(k,i,s) MemDbGetDataW(k,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobExA(k,i,b,s) MemDbGetDataExA(k,DATAFLAG_UNORDERED,i,b,s)
#define MemDbGetUnorderedBlobExW(k,i,b,s) MemDbGetDataExW(k,DATAFLAG_UNORDERED,i,b,s)
#define MemDbGetUnorderedBlobByDataHandle(h,s) MemDbGetDataByDataHandle(h,s)
#define MemDbGetUnorderedBlobByDataHandleEx(h,b,s) MemDbGetDataByDataHandle(h,b,s)
#define MemDbGetUnorderedBlobByKeyHandle(h,i,s) MemDbGetDataByKeyHandle(h,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobByKeyHandleEx(h,i,b,s) MemDbGetDataByKeyHandleEx(h,DATAFLAG_UNORDERED,i,b,s)
#define MemDbDeleteUnorderedBlobA(k,i) MemDbDeleteDataA(k,DATAFLAG_UNORDERED,i);
#define MemDbDeleteUnorderedBlobW(k,i) MemDbDeleteDataW(k,DATAFLAG_UNORDERED,i);
#define MemDbDeleteUnorderedBlobByDataHandle(h) MemDbDeleteDataByDataHandle(h)
#define MemDbDeleteUnorderedBlobByKeyHandle(h,i) MemDbDeleteDataByKeyHandle(h,DATAFLAG_UNORDERED,i)

//
// low-level linkage functions
//
DATAHANDLE
MemDbAddLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

BOOL
MemDbDeleteLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

#define MemDbSetLinkageArrayA(k,t,i,d,s) MemDbSetDataA(k,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayW(k,t,i,d,s) MemDbSetDataW(k,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayByKeyHandle(h,t,i,d,s) MemDbSetDataByKeyHandle(h,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayByDataHandle(h,d,s) MemDbSetDataByDataHandle(h,(PCBYTE)d,s)
#define MemDbGetLinkageArrayA(k,t,i,s) (PUINT)MemDbGetDataA(k,t,i,s)
#define MemDbGetLinkageArrayW(k,t,i,s) (PUINT)MemDbGetDataW(k,t,i,s)
#define MemDbGetLinkageArrayByKeyHandle(h,t,i,s) (PUINT)MemDbGetDataByKeyHandle(h,t,i,s)
#define MemDbGetLinkageArrayByKeyHandleEx(h,t,i,b,s) (PUINT)MemDbGetDataByKeyHandleEx(h,t,i,b,s)
#define MemDbGetLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetDataByDataHandle(h,s)
#define MemDbGetLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetDataByDataHandleEx(h,b,s)

BOOL
MemDbTestLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbAddLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbAddLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbAddLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

KEYHANDLE
MemDbGetLinkageA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

KEYHANDLE
MemDbGetLinkageW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

KEYHANDLE
MemDbGetLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

BOOL
MemDbTestLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbTestLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbTestLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

// high-level linkage functions
#define MemDbAddSingleLinkageValueA(k,i,l,a) MemDbAddLinkageValueA(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueW(k,i,l,a) MemDbAddLinkageValueW(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueByKeyHandle(k,i,l,a) MemDbAddLinkageValueByKeyHandle(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueByDataHandle(h,l,a) MemDbAddLinkagaValueByDataHandle(h,l,a)
#define MemDbDeleteSingleLinkageValueA(k,i,l,f) MemDbDeleteLinkageValueA(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueW(k,i,l,f) MemDbDeleteLinkageValueW(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueByKeyHandle(k,i,l,f) MemDbDeleteLinkageValueByKeyHandle(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueByDataHandle(h,l,f) MemDbDeleteLinkagaValueByDataHandle(h,l,f)
#define MemDbSetSingleLinkageArrayA(k,i,d,s) MemDbSetLinkageArrayA(k,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayW(k,i,d,s) MemDbSetLinkageArrayW(k,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayByKeyHandle(h,i,d,s) MemDbSetLinkageArrayByKeyHandle(h,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayByDataHandle(h,d,s) MemDbSetLinkageArrayByDataHandle(h,d,s)
#define MemDbGetSingleLinkageArrayA(k,i,s) (PUINT)MemDbGetLinkageArrayA(k,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayW(k,i,s) (PUINT)MemDbGetLinkageArrayW(k,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayByKeyHandle(h,i,s) (PUINT)MemDbGetLinkageArrayByKeyHandle(h,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayByKeyHandleEx(h,i,b,s) (PUINT)MemDbGetLinkageArrayByKeyHandleEx(h,DATAFLAG_SINGLELINK,i,b,s)
#define MemDbGetSingleLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetLinkageArrayByDataHandle(h,s)
#define MemDbGetSingleLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetLinkageArrayByDataHandleEx(h,b,s)
#define MemDbTestSingleLinkageValueA(k,i,l) MemDbTestLinkageValueA(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueW(k,i,l) MemDbTestLinkageValueW(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueByKeyHandle(h,i,l) MemDbTestLinkageValueByKeyHandle(h,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueByDataHandle(h,l) MemDbTestLinkageValueByDataHandle(h,l)

#define MemDbAddDoubleLinkageValueA (k,i,l,a) MemDbAddLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueW (k,i,l,a) MemDbAddLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueByKeyHandle(k,i,l,a) MemDbAddLinkageValueByKeyHandle(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueByDataHandle(h,l,a) MemDbAddLinkagaValueByDataHandle(h,l,a)
#define MemDbDeleteDoubleLinkageValueA(k,i,l,f) MemDbDeleteLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueW(k,i,l,f) MemDbDeleteLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueByKeyHandle(k,i,l,f) MemDbDeleteLinkageValueByKeyHandle(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueByDataHandle(h,l,f) MemDbDeleteLinkagaValueByDataHandle(h,l,f)
#define MemDbSetDoubleLinkageArrayA(k,i,d,s) MemDbSetLinkageArrayA(k,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayW(k,i,d,s) MemDbSetLinkageArrayW(k,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayByKeyHandle(h,i,d,s) MemDbSetLinkageArrayByKeyHandle(h,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayByDataHandle(h,d,s) MemDbSetLinkageArrayByDataHandle(h,d,s)
#define MemDbGetDoubleLinkageArrayA(k,i,s) (PUINT)MemDbGetLinkageArrayA(k,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayW(k,i,s) (PUINT)MemDbGetLinkageArrayW(k,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayByKeyHandle(h,i,s) (PUINT)MemDbGetLinkageArrayByKeyHandle(h,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayByKeyHandleEx(h,i,b,s) (PUINT)MemDbGetLinkageArrayByKeyHandleEx(h,DATAFLAG_DOUBLELINK,i,b,s)
#define MemDbGetDoubleLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetLinkageArrayByDataHandle(h,s)
#define MemDbGetDoubleLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetLinkageArrayByDataHandleEx(h,b,s)
#define MemDbTestDoubleLinkageValueA(k,i,l) MemDbTestLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueW(k,i,l) MemDbTestLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueByKeyHandle(h,i,l) MemDbTestLinkageValueByKeyHandle(h,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueByDataHandle(h,l) MemDbTestLinkageValueByDataHandle(h,l)

#define MemDbAddSingleLinkageA(k1,k2,i) MemDbAddLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbAddSingleLinkageW(k1,k2,i) MemDbAddLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbAddSingleLinkageByKeyHandle(h1,h2,i) MemDbAddLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageA(k1,k2,i) MemDbDeleteLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageW(k1,k2,i) MemDbDeleteLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageByKeyHandle(h1,h2,i) MemDbDeleteLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)
#define MemDbGetSingleLinkageA(k,i,l) MemDbGetLinkageA(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbGetSingleLinkageW(k,i,l) MemDbGetLinkageW(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbGetSingleLinkageByKeyHandle(h,i,l) MemDbGetLinkageByKeyHandle(h,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageA(k1,k2,i) MemDbTestLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbTestSingleLinkageW(k1,k2,i) MemDbTestLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbTestSingleLinkageByKeyHandle(h1,h2,i) MemDbTestLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)

#define MemDbAddDoubleLinkageA(k1,k2,i) MemDbAddLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbAddDoubleLinkageW(k1,k2,i) MemDbAddLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbAddDoubleLinkageByKeyHandle(h1,h2,i) MemDbAddLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageA(k1,k2,i) MemDbDeleteLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageW(k1,k2,i) MemDbDeleteLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageByKeyHandle(h1,h2,i) MemDbDeleteLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)
#define MemDbGetDoubleLinkageA(k,i,l) MemDbGetLinkageA(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbGetDoubleLinkageW(k,i,l) MemDbGetLinkageW(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbGetDoubleLinkageByKeyHandle(h,i,l) MemDbGetLinkageByKeyHandle(h,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageA(k1,k2,i) MemDbTestLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbTestDoubleLinkageW(k1,k2,i) MemDbTestLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbTestDoubleLinkageByKeyHandle(h1,h2,i) MemDbTestLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)

// enumeration functions
BOOL
RealMemDbEnumFirstExA (
    IN OUT  PMEMDB_ENUMA MemDbEnum,
    IN      PCSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel,
    IN      PMEMDB_PATTERNSTRUCTW PatternStruct OPTIONAL
    );

#define MemDbEnumFirstExA(m,p,f,b,e,s)  TRACK_BEGIN(BOOL, MemDbEnumFirstExA)\
                                        RealMemDbEnumFirstExA(m,p,f,b,e,s)\
                                        TRACK_END()

#define MemDbEnumFirstA(e,p,f,l1,l2)    MemDbEnumFirstExA(e,p,f,l1,l2,NULL)

BOOL
RealMemDbEnumFirstExW (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel,
    IN      PMEMDB_PATTERNSTRUCTW PatternStruct OPTIONAL
    );

#define MemDbEnumFirstExW(m,p,f,b,e,s)  TRACK_BEGIN(BOOL, MemDbEnumFirstExW)\
                                        RealMemDbEnumFirstExW(m,p,f,b,e,s)\
                                        TRACK_END()

#define MemDbEnumFirstW(e,p,f,l1,l2)    MemDbEnumFirstExW(e,p,f,l1,l2,NULL)

BOOL
RealMemDbEnumNextA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    );

#define MemDbEnumNextA(m)  TRACK_BEGIN(BOOL, MemDbEnumNextA)\
                           RealMemDbEnumNextA(m)\
                           TRACK_END()

BOOL
RealMemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    );

#define MemDbEnumNextW(m)  TRACK_BEGIN(BOOL, MemDbEnumNextW)\
                           RealMemDbEnumNextW(m)\
                           TRACK_END()

BOOL
MemDbAbortEnumA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    );

BOOL
MemDbAbortEnumW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    );

BOOL
MemDbSetInsertionOrderedA (
    IN      PCSTR Key
    );

BOOL
MemDbSetInsertionOrderedW (
    IN      PCWSTR Key
    );

BOOL
MemDbSetInsertionOrderedByKeyHandle (
    IN      KEYHANDLE KeyHandle
    );

BOOL
MemDbMoveKeyHandleToEnd (
    IN      KEYHANDLE KeyHandle
    );

BOOL
MemDbSaveA (
    IN      PCSTR szFile
    );

BOOL
MemDbSaveW (
    IN      PCWSTR szFile
    );

BOOL
MemDbLoadA (
    IN      PCSTR szFile
    );

BOOL
MemDbLoadW (
    IN      PCWSTR szFile
    );

BOOL
MemDbValidateDatabase (
    VOID
    );

BOOL
MemDbQueryVersionA (
    IN      PCSTR FileName,
    OUT     PMEMDB_VERSION Version
    );

BOOL
MemDbQueryVersionW (
    IN      PCWSTR FileName,
    OUT     PMEMDB_VERSION Version
    );

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbImportA (
    IN      PCSTR FileName
    );

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    );

PCBYTE
MemDbGetDatabaseAddress (
    VOID
    );

UINT
MemDbGetDatabaseSize (
    VOID
    );

#define MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1            0x0001
#define MEMDB_CONVERT_WILD_STAR_TO_ASCII_2              0x0002
#define MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3             0x0002
// other conversion to be implemented when needed

VOID MemDbMakeNonPrintableKeyA (PSTR KeyName, UINT Flags);
VOID MemDbMakeNonPrintableKeyW (PWSTR KeyName, UINT Flags);

VOID MemDbMakePrintableKeyA (PSTR KeyName, UINT Flags);
VOID MemDbMakePrintableKeyW (PWSTR KeyName, UINT Flags);

VOID GetFixedUserNameA (PSTR UserName);
VOID GetFixedUserNameW (PWSTR UserName);


#ifdef DEBUG
extern UINT g_DatabaseCheckLevel;
#define MEMDB_CHECKLEVEL1      0x000001
#define MEMDB_CHECKLEVEL2      0x000002
#define MEMDB_CHECKLEVEL3      0x000003

BOOL MemDbCheckDatabase(UINT Level);
#else
#define MemDbCheckDatabase()
#endif

//
// A & W
//

#ifdef UNICODE

#define MemDbInitialize MemDbInitializeW
#define MemDbInitializeEx MemDbInitializeExW
#define MemDbAddKey MemDbAddKeyW
#define MemDbSetKey MemDbSetKeyW
#define MemDbTestKey MemDbTestKeyW
#define MemDbDeleteKey MemDbDeleteKeyW
#define MemDbDeleteTree MemDbDeleteTreeW
#define MemDbGetKeyFromHandle MemDbGetKeyFromHandleW
#define MemDbGetKeyFromHandleEx MemDbGetKeyFromHandleExW
#define MemDbGetHandleFromKey MemDbGetHandleFromKeyW
#define MemDbSetValueAndFlagsEx MemDbSetValueAndFlagsExW
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsW
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsW
#define MemDbSetValue MemDbSetValueW
#define MemDbGetValue MemDbGetValueW
#define MemDbSetFlags MemDbSetFlagsW
#define MemDbReplaceFlags MemDbReplaceFlagsW
#define MemDbGetFlags MemDbGetFlagsW
#define MemDbAddData MemDbAddDataW
#define MemDbSetData MemDbSetDataW
#define MemDbGrowData MemDbGrowDataW
#define MemDbGetDataHandle MemDbGetDataHandleW
#define MemDbGetData MemDbGetDataW
#define MemDbGetDataEx MemDbGetDataExW
#define MemDbDeleteData MemDbDeleteDataW
#define MemDbAddUnorderedBlob MemDbAddUnorderedBlobW
#define MemDbSetUnorderedBlob MemDbSetUnorderedBlobW
#define MemDbGrowUnorderedBlob MemDbGrowUnorderedBlobW
#define MemDbGetUnorderedBlob MemDbGetUnorderedBlobW
#define MemDbGetUnorderedBlobEx MemDbGetUnorderedBlobExW
#define MemDbDeleteUnorderedBlob MemDbDeleteUnorderedBlobW
#define MemDbAddLinkageValue MemDbAddLinkageValueW
#define MemDbDeleteLinkageValue MemDbDeleteLinkageValueW
#define MemDbSetLinkageArray MemDbSetLinkageArrayW
#define MemDbGetLinkageArray MemDbGetLinkageArrayW
#define MemDbAddSingleLinkageValue MemDbAddSingleLinkageValueW
#define MemDbDeleteSingleLinkageValue MemDbDeleteSingleLinkageValueW
#define MemDbSetSingleLinkageArray MemDbSetSingleLinkageArrayW
#define MemDbGetSingleLinkageArray MemDbGetSingleLinkageArrayW
#define MemDbAddDoubleLinkageValue MemDbAddDoubleLinkageValueW
#define MemDbDeleteDoubleLinkageValue MemDbDeleteDoubleLinkageValueW
#define MemDbSetDoubleLinkageArray MemDbSetDoubleLinkageArrayW
#define MemDbGetDoubleLinkageArray MemDbGetDoubleLinkageArrayW
#define MemDbTestLinkageValue MemDbTestLinkageValueW
#define MemDbTestSingleLinkageValue MemDbTestSingleLinkageValueW
#define MemDbTestDoubleLinkageValue MemDbTestDoubleLinkageValueW
#define MemDbAddLinkage MemDbAddLinkageW
#define MemDbGetLinkage MemDbGetLinkageW
#define MemDbTestLinkage MemDbTestLinkageW
#define MemDbAddSingleLinkage MemDbAddSingleLinkageW
#define MemDbDeleteSingleLinkage MemDbDeleteSingleLinkageW
#define MemDbGetSingleLinkage MemDbGetSingleLinkageW
#define MemDbTestSingleLinkage MemDbTestSingleLinkageW
#define MemDbAddDoubleLinkage MemDbAddDoubleLinkageW
#define MemDbDeleteDoubleLinkage MemDbDeleteDoubleLinkageW
#define MemDbGetDoubleLinkage MemDbGetDoubleLinkageW
#define MemDbTestDoubleLinkage MemDbTestDoubleLinkageW
#define MemDbEnumFirst MemDbEnumFirstW
#define MemDbEnumFirstEx MemDbEnumFirstExW
#define MemDbEnumNext MemDbEnumNextW
#define MemDbAbortEnum MemDbAbortEnumW
#define MEMDB_ENUM MEMDB_ENUMW
#define PMEMDB_ENUM PMEMDB_ENUMW

#define MemDbSave MemDbSaveW
#define MemDbLoad MemDbLoadW
#define MemDbQueryVersion MemDbQueryVersionW
#define MemDbExport MemDbExportW
#define MemDbImport MemDbImportW
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyW
#define MemDbMakePrintableKey MemDbMakePrintableKeyW
#define GetFixedUserName GetFixedUserNameW

#define MemDbSetInsertionOrdered MemDbSetInsertionOrderedW


#else

#define MemDbInitialize MemDbInitializeA
#define MemDbInitializeEx MemDbInitializeExA
#define MemDbAddKey MemDbAddKeyA
#define MemDbSetKey MemDbSetKeyA
#define MemDbTestKey MemDbTestKeyA
#define MemDbDeleteKey MemDbDeleteKeyA
#define MemDbDeleteTree MemDbDeleteTreeA
#define MemDbGetKeyFromHandle MemDbGetKeyFromHandleA
#define MemDbGetKeyFromHandleEx MemDbGetKeyFromHandleExA
#define MemDbGetHandleFromKey MemDbGetHandleFromKeyA
#define MemDbSetValueAndFlagsEx MemDbSetValueAndFlagsExA
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsA
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsA
#define MemDbSetValue MemDbSetValueA
#define MemDbGetValue MemDbGetValueA
#define MemDbSetFlags MemDbSetFlagsA
#define MemDbReplaceFlags MemDbReplaceFlagsA
#define MemDbGetFlags MemDbGetFlagsA
#define MemDbAddData MemDbAddDataA
#define MemDbSetData MemDbSetDataA
#define MemDbGrowData MemDbGrowDataA
#define MemDbGetDataHandle MemDbGetDataHandleA
#define MemDbGetData MemDbGetDataA
#define MemDbGetDataEx MemDbGetDataExA
#define MemDbDeleteData MemDbDeleteDataA
#define MemDbAddUnorderedBlob MemDbAddUnorderedBlobA
#define MemDbSetUnorderedBlob MemDbSetUnorderedBlobA
#define MemDbGrowUnorderedBlob MemDbGrowUnorderedBlobA
#define MemDbGetUnorderedBlob MemDbGetUnorderedBlobA
#define MemDbGetUnorderedBlobEx MemDbGetUnorderedBlobExA
#define MemDbDeleteUnorderedBlob MemDbDeleteUnorderedBlobA
#define MemDbAddLinkageValue MemDbAddLinkageValueA
#define MemDbDeleteLinkageValue MemDbDeleteLinkageValueA
#define MemDbSetLinkageArray MemDbSetLinkageArrayA
#define MemDbGetLinkageArray MemDbGetLinkageArrayA
#define MemDbAddSingleLinkageValue MemDbAddSingleLinkageValueA
#define MemDbDeleteSingleLinkageValue MemDbDeleteSingleLinkageValueA
#define MemDbSetSingleLinkageArray MemDbSetSingleLinkageArrayA
#define MemDbGetSingleLinkageArray MemDbGetSingleLinkageArrayA
#define MemDbAddDoubleLinkageValue MemDbAddDoubleLinkageValueA
#define MemDbDeleteDoubleLinkageValue MemDbDeleteDoubleLinkageValueA
#define MemDbSetDoubleLinkageArray MemDbSetDoubleLinkageArrayA
#define MemDbGetDoubleLinkageArray MemDbGetDoubleLinkageArrayA
#define MemDbTestLinkageValue MemDbTestLinkageValueA
#define MemDbTestSingleLinkageValue MemDbTestSingleLinkageValueA
#define MemDbTestDoubleLinkageValue MemDbTestDoubleLinkageValueA
#define MemDbAddLinkage MemDbAddLinkageA
#define MemDbGetLinkage MemDbGetLinkageA
#define MemDbTestLinkage MemDbTestLinkageA
#define MemDbAddSingleLinkage MemDbAddSingleLinkageA
#define MemDbDeleteSingleLinkage MemDbDeleteSingleLinkageA
#define MemDbGetSingleLinkage MemDbGetSingleLinkageA
#define MemDbTestSingleLinkage MemDbTestSingleLinkageA
#define MemDbAddDoubleLinkage MemDbAddDoubleLinkageA
#define MemDbDeleteDoubleLinkage MemDbDeleteDoubleLinkageA
#define MemDbGetDoubleLinkage MemDbGetDoubleLinkageA
#define MemDbTestDoubleLinkage MemDbTestDoubleLinkageA
#define MemDbEnumFirst MemDbEnumFirstA
#define MemDbEnumFirstEx MemDbEnumFirstExA
#define MemDbEnumNext MemDbEnumNextA
#define MemDbAbortEnum MemDbAbortEnumA
#define MEMDB_ENUM MEMDB_ENUMA
#define PMEMDB_ENUM PMEMDB_ENUMA

#define MemDbSave MemDbSaveA
#define MemDbLoad MemDbLoadA
#define MemDbQueryVersion MemDbQueryVersionA
#define MemDbExport MemDbExportA
#define MemDbImport MemDbImportA
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyA
#define MemDbMakePrintableKey MemDbMakePrintableKeyA
#define GetFixedUserName GetFixedUserNameA

#define MemDbSetInsertionOrdered MemDbSetInsertionOrderedA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\hash.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    ovidiut     11-Oct-1999 Updated for new coding conventions and Win64 compliance

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define CASE_SENSITIVE      TRUE
#define CASE_INSENSITIVE    FALSE

#define UNKNOWN_LETTER_CASE FALSE
#define ALREADY_LOWERCASE   TRUE

#define DEFAULT_BUCKET_SIZE 0

//
// Types
//

typedef const void *HASHTABLE;

typedef const void *HASHITEM;

typedef struct {

    PCSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMA, *PHASHTABLE_ENUMA;

typedef struct {
    PCWSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMW, *PHASHTABLE_ENUMW;

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEA)(
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEW)(
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCWSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    );

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes and wrapper macros
//

HASHTABLE
RealHtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT BucketCount            OPTIONAL
    );

#define HtAllocExAW(cs,u,s,d,b)     TRACK_BEGIN(HASHTABLE, HtAllocExAW)\
                                    RealHtAllocExAW(cs,u,s,d,b)\
                                    TRACK_END()

#define HtAllocA()                                  HtAllocExAW(FALSE,FALSE,FALSE,0,0)
#define HtAllocW()                                  HtAllocExAW(FALSE,TRUE,FALSE,0,0)

#define HtAllocWithDataA(size)                      HtAllocExAW(FALSE,FALSE,FALSE,size,0)
#define HtAllocWithDataW(size)                      HtAllocExAW(FALSE,TRUE,FALSE,size,0)

#define HtAllocExA(cs,datasize,bucketcount)         HtAllocExAW(cs,FALSE,FALSE,datasize,bucketcount)
#define HtAllocExW(cs,datasize,bucketcount)         HtAllocExAW(cs,TRUE,FALSE,datasize,bucketcount)

#define HtAllocExternStrA()                         HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrW()                         HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrWithDataA(size)             HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrWithDataW(size)             HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrExA(cs,size,bucketcount)    HtAllocExAW(cs,FALSE,TRUE,size,bucketcount)
#define HtAllocExternStrExW(cs,size,bucketcount)    HtAllocExAW(cs,TRUE,TRUE,size,bucketcount)

VOID
HtFree (
    IN      HASHTABLE HashTable
    );

HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringA(table,string)              HtAddStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataA(table,string,data)  HtAddStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringW(table,string)              HtAddStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataW(table,string,data)  HtAddStringExW(table,string,data,UNKNOWN_LETTER_CASE)

BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    );

BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    );

BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    );


HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringA(table,string)             HtFindStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataA(table,string,data) HtFindStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringW(table,string)             HtFindStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataW(table,string,data) HtFindStringExW(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR StringStart,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixA(table,str,end)    HtFindPrefixExA(table,str,end,NULL,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR StringStart,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixW(table,str,end)     HtFindPrefixExW(table,str,end,NULL,UNKNOWN_LETTER_CASE)

BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    );

BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    );

BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    );

PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Index
    );

PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Index
    );

BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    );

BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    );


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    );

BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    );

BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    );

BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    );

//
// Macro expansion definition
//

// None

//
// A & W macros
//

#ifdef UNICODE

#define HASHTABLE_ENUM              HASHTABLE_ENUMW
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMW
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEW
#define HtAlloc                     HtAllocW
#define HtAllocWithData             HtAllocWithDataW
#define HtAllocEx                   HtAllocExW
#define HtAllocExternStr            HtAllocExternStrW
#define HtAllocExternStrWithData    HtAllocExternStrWithDataW
#define HtAllocExternStrEx          HtAllocExternStrExW
#define HtAddString                 HtAddStringW
#define HtAddStringAndData          HtAddStringAndDataW
#define HtAddStringEx               HtAddStringExW
#define HtRemoveString              HtRemoveStringW
#define HtFindString                HtFindStringW
#define HtFindStringAndData         HtFindStringAndDataW
#define HtFindStringEx              HtFindStringExW
#define HtFindPrefix                HtFindPrefixW
#define HtFindPrefixEx              HtFindPrefixExW
#define HtGetStringFromItem         HtGetStringFromItemW
#define EnumFirstHashTableString    EnumFirstHashTableStringW
#define EnumNextHashTableString     EnumNextHashTableStringW
#define EnumHashTableWithCallback   EnumHashTableWithCallbackW

#else

#define HASHTABLE_ENUM              HASHTABLE_ENUMA
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMA
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEA
#define HtAlloc                     HtAllocA
#define HtAllocWithData             HtAllocWithDataA
#define HtAllocEx                   HtAllocExA
#define HtAllocExternStr            HtAllocExternStrA
#define HtAllocExternStrWithData    HtAllocExternStrWithDataA
#define HtAllocExternStrEx          HtAllocExternStrExA
#define HtAddString                 HtAddStringA
#define HtAddStringAndData          HtAddStringAndDataA
#define HtAddStringEx               HtAddStringExA
#define HtRemoveString              HtRemoveStringA
#define HtFindString                HtFindStringA
#define HtFindStringAndData         HtFindStringAndDataA
#define HtFindStringEx              HtFindStringExA
#define HtFindPrefix                HtFindPrefixA
#define HtFindPrefixEx              HtFindPrefixExA
#define HtGetStringFromItem         HtGetStringFromItemA
#define EnumFirstHashTableString    EnumFirstHashTableStringA
#define EnumNextHashTableString     EnumNextHashTableStringA
#define EnumHashTableWithCallback   EnumHashTableWithCallbackA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\objstr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    objstr.h

Abstract:

    Implements a set of APIs to handle the string representation of nodes/leafs of a tree

Author:

    03-Jan-2000 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

/*
                                   +-------+
                                   | root1 |                            Level 1
                                   +-------+
                                      / \
                                    /     \
                          +---------+     (-------)
                          |  node1  |    (  leaf1  )                    Level 2
                          +---------+     (-------)
                          /  |   \  \__________
                        /    |     \           \
               +-------+ +-------+  (-------)   (-------)
               | node2 | | node3 | (  leaf2  ) (  leaf3  )              Level 3
               +-------+ +-------+  (-------)   (-------)
                  / \
                /     \
          +-------+  (-------)
          | node4 | (  leaf4  )                                         Level 4
          +-------+  (-------)
             / \
           /     \
    (-------)   (-------)
   (  leaf5  ) (  leaf6  )                                              Level 5
    (-------)   (-------)


    The string representation of some tree elements above:

    root1
    root1 <leaf1>
    root1\node1
    root1\node1 <leaf2>
    root1\node1 <leaf3>

*/


//
// Types
//

typedef PCTSTR  ENCODEDSTRHANDLE;

typedef enum {
    OBSPF_EXACTNODE             = 0x0001,
    OBSPF_NODEISROOTPLUSSTAR    = 0x0002,
    OBSPF_OPTIONALNODE          = 0x0004,
    OBSPF_NOLEAF                = 0x0008,
    OBSPF_EXACTLEAF             = 0x0010,
    OBSPF_OPTIONALLEAF          = 0x0020,
} OBSP_FLAGS;

typedef struct TAG_OBSPARSEDPATTERNA {
    PPARSEDPATTERNA     NodePattern;
    PPARSEDPATTERNA     LeafPattern;
    PSTR                ExactRoot;
    DWORD               ExactRootBytes;
    PCSTR               Leaf;
    DWORD               MinNodeLevel;
    DWORD               MaxNodeLevel;
    DWORD               MaxSubLevel;
    DWORD               Flags;
    PMHANDLE            Pool;
} OBSPARSEDPATTERNA, *POBSPARSEDPATTERNA;

typedef struct TAG_OBSPARSEDPATTERNW {
    PPARSEDPATTERNW     NodePattern;
    PPARSEDPATTERNW     LeafPattern;
    PWSTR               ExactRoot;
    DWORD               ExactRootBytes;
    PCWSTR              Leaf;
    DWORD               MinNodeLevel;
    DWORD               MaxNodeLevel;
    DWORD               MaxSubLevel;
    DWORD               Flags;
    PMHANDLE            Pool;
} OBSPARSEDPATTERNW, *POBSPARSEDPATTERNW;

//
// APIs
//

BOOL
ObsInitialize (
    VOID
    );

VOID
ObsTerminate (
    VOID
    );

VOID
ObsFreeA (
    IN      PCSTR EncodedObject
    );

VOID
ObsFreeW (
    IN      PCWSTR EncodedObject
    );

BOOL
ObsEncodeStringExA (
    PSTR Destination,
    PCSTR Source,
    PCSTR CharsToEncode
    );

#define ObsEncodeStringA(d,s) ObsEncodeStringExA(d,s,NULL)

BOOL
ObsEncodeStringExW (
    PWSTR Destination,
    PCWSTR Source,
    PCWSTR CharsToEncode
    );

#define ObsEncodeStringW(d,s) ObsEncodeStringExW(d,s,NULL)

BOOL
ObsDecodeStringA (
    PSTR Destination,
    PCSTR Source
    );

BOOL
ObsDecodeStringW (
    PWSTR Destination,
    PCWSTR Source
    );

BOOL
RealObsSplitObjectStringExA (
    IN      PCSTR EncodedObject,
    OUT     PCSTR* DecodedNode,         OPTIONAL
    OUT     PCSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    );

#define ObsSplitObjectStringExA(o,n,l,p,s)  TRACK_BEGIN(BOOL, ObsSplitObjectStringExA)\
                                            RealObsSplitObjectStringExA(o,n,l,p,s)\
                                            TRACK_END()

#define ObsSplitObjectStringA(o,n,l)    ObsSplitObjectStringExA(o,n,l,NULL,TRUE)

BOOL
RealObsSplitObjectStringExW (
    IN      PCWSTR EncodedObject,
    OUT     PCWSTR* DecodedNode,        OPTIONAL
    OUT     PCWSTR* DecodedLeaf,        OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    );

#define ObsSplitObjectStringExW(o,n,l,p,s)  TRACK_BEGIN(BOOL, ObsSplitObjectStringExW)\
                                            RealObsSplitObjectStringExW(o,n,l,p,s)\
                                            TRACK_END()

#define ObsSplitObjectStringW(o,n,l)    ObsSplitObjectStringExW(o,n,l,NULL,TRUE)

BOOL
ObsHasNodeA (
    IN      PCSTR EncodedObject
    );

BOOL
ObsHasNodeW (
    IN      PCWSTR EncodedObject
    );

PCSTR
ObsGetLeafPortionOfEncodedStringA (
    IN      PCSTR EncodedObject
    );

PCWSTR
ObsGetLeafPortionOfEncodedStringW (
    IN      PCWSTR EncodedObject
    );

PCSTR
ObsGetNodeLeafDividerA (
    IN      PCSTR EncodedObject
    );

PCWSTR
ObsGetNodeLeafDividerW (
    IN      PCWSTR EncodedObject
    );

PCSTR
ObsFindNonEncodedCharInEncodedStringA (
    IN      PCSTR String,
    IN      MBCHAR Char
    );

PCWSTR
ObsFindNonEncodedCharInEncodedStringW (
    IN      PCWSTR String,
    IN      WCHAR Char
    );

PSTR
ObsBuildEncodedObjectStringFromPatternA (
    IN      POBSPARSEDPATTERNA Pattern
    );

PWSTR
ObsBuildEncodedObjectStringFromPatternW (
    IN      POBSPARSEDPATTERNW Pattern
    );

PSTR
RealObsBuildEncodedObjectStringExA (
    IN      PCSTR DecodedNode,
    IN      PCSTR DecodedLeaf,          OPTIONAL
    IN      BOOL EncodeString
    );

#define ObsBuildEncodedObjectStringExA(n,l,e)   TRACK_BEGIN(PSTR, ObsBuildEncodedObjectStringExA)\
                                                RealObsBuildEncodedObjectStringExA(n,l,e)\
                                                TRACK_END()

#define ObsBuildEncodedObjectStringA(node,leaf) ObsBuildEncodedObjectStringExA(node,leaf,FALSE)

PSTR
ObsBuildPartialEncodedObjectStringExA (
    IN      PCSTR DecodedNode,
    IN      PCSTR DecodedLeaf,          OPTIONAL
    IN      BOOL EncodeString
    );

PWSTR
RealObsBuildEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,         OPTIONAL
    IN      BOOL EncodeString
    );

#define ObsBuildEncodedObjectStringExW(n,l,e)   TRACK_BEGIN(PWSTR, ObsBuildEncodedObjectStringExW)\
                                                RealObsBuildEncodedObjectStringExW(n,l,e)\
                                                TRACK_END()

#define ObsBuildEncodedObjectStringW(node,leaf) ObsBuildEncodedObjectStringExW(node,leaf,FALSE)

PWSTR
ObsBuildPartialEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,         OPTIONAL
    IN      BOOL EncodeString
    );

POBSPARSEDPATTERNA
RealObsCreateParsedPatternExA (
    IN      PMHANDLE Pool,              OPTIONAL
    IN      PCSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    );

#define ObsCreateParsedPatternExA(p,o,m) TRACK_BEGIN(POBSPARSEDPATTERNA, ObsCreateParsedPatternExA)\
                                         RealObsCreateParsedPatternExA(p,o,m)\
                                         TRACK_END()

#define ObsCreateParsedPatternA(obj)     ObsCreateParsedPatternExA (NULL,obj,FALSE)

POBSPARSEDPATTERNW
RealObsCreateParsedPatternExW (
    IN      PMHANDLE Pool,              OPTIONAL
    IN      PCWSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    );

#define ObsCreateParsedPatternExW(p,o,m) TRACK_BEGIN(POBSPARSEDPATTERNW, ObsCreateParsedPatternExW)\
                                         RealObsCreateParsedPatternExW(p,o,m)\
                                         TRACK_END()

#define ObsCreateParsedPatternW(obj)     ObsCreateParsedPatternExW (NULL,obj,FALSE)

VOID
ObsDestroyParsedPatternA (
    IN      POBSPARSEDPATTERNA ParsedPattern
    );

VOID
ObsDestroyParsedPatternW (
    IN      POBSPARSEDPATTERNW ParsedPattern
    );

BOOL
ObsParsedPatternMatchA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR EncodedObject
    );

BOOL
ObsParsedPatternMatchW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR EncodedObject
    );

BOOL
ObsParsedPatternMatchExA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR Node,
    IN      PCSTR Leaf                          OPTIONAL
    );

BOOL
ObsParsedPatternMatchExW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR Node,
    IN      PCWSTR Leaf                         OPTIONAL
    );

BOOL
ObsPatternMatchA (
    IN      PCSTR ObjectPattern,
    IN      PCSTR ObjectStr
    );

BOOL
ObsPatternMatchW (
    IN      PCWSTR ObjectPattern,
    IN      PCWSTR ObjectStr
    );

BOOL
ObsIsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    );

BOOL
ObsIsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    );

BOOL
ObsGetPatternLevelsA (
    IN      PCSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    );

BOOL
ObsGetPatternLevelsW (
    IN      PCWSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    );

BOOL
ObsPatternIncludesPatternA (
    IN      POBSPARSEDPATTERNA IncludingPattern,
    IN      POBSPARSEDPATTERNA IncludedPattern
    );

BOOL
ObsPatternIncludesPatternW (
    IN      POBSPARSEDPATTERNW IncludingPattern,
    IN      POBSPARSEDPATTERNW IncludedPattern
    );

//
// Macros
//

#ifdef UNICODE

#define OBSPARSEDPATTERN                        OBSPARSEDPATTERNW
#define POBSPARSEDPATTERN                       POBSPARSEDPATTERNW

#define ObsFree                                 ObsFreeW
#define ObsEncodeStringEx                       ObsEncodeStringExW
#define ObsEncodeString                         ObsEncodeStringW
#define ObsDecodeString                         ObsDecodeStringW
#define ObsSplitObjectString                    ObsSplitObjectStringW
#define ObsSplitObjectStringEx                  ObsSplitObjectStringExW
#define ObsHasNode                              ObsHasNodeW
#define ObsGetLeafPortionOfEncodedString        ObsGetLeafPortionOfEncodedStringW
#define ObsGetNodeLeafDivider                   ObsGetNodeLeafDividerW
#define ObsFindNonEncodedCharInEncodedString    ObsFindNonEncodedCharInEncodedStringW
#define ObsBuildEncodedObjectStringFromPattern  ObsBuildEncodedObjectStringFromPatternW
#define ObsBuildEncodedObjectStringEx           ObsBuildEncodedObjectStringExW
#define ObsBuildPartialEncodedObjectStringEx    ObsBuildPartialEncodedObjectStringExW
#define ObsBuildEncodedObjectString             ObsBuildEncodedObjectStringW
#define ObsCreateParsedPattern                  ObsCreateParsedPatternW
#define ObsCreateParsedPatternEx                ObsCreateParsedPatternExW
#define ObsDestroyParsedPattern                 ObsDestroyParsedPatternW
#define ObsParsedPatternMatch                   ObsParsedPatternMatchW
#define ObsParsedPatternMatchEx                 ObsParsedPatternMatchExW
#define ObsPatternMatch                         ObsPatternMatchW
#define ObsIsPatternContained                   ObsIsPatternContainedW
#define ObsGetPatternLevels                     ObsGetPatternLevelsW
#define ObsPatternIncludesPattern               ObsPatternIncludesPatternW

#else

#define OBSPARSEDPATTERN                        OBSPARSEDPATTERNA
#define POBSPARSEDPATTERN                       POBSPARSEDPATTERNA

#define ObsFree                                 ObsFreeA
#define ObsEncodeStringEx                       ObsEncodeStringExA
#define ObsEncodeString                         ObsEncodeStringA
#define ObsDecodeString                         ObsDecodeStringA
#define ObsSplitObjectString                    ObsSplitObjectStringA
#define ObsSplitObjectStringEx                  ObsSplitObjectStringExA
#define ObsHasNode                              ObsHasNodeA
#define ObsGetLeafPortionOfEncodedString        ObsGetLeafPortionOfEncodedStringA
#define ObsGetNodeLeafDivider                   ObsGetNodeLeafDividerA
#define ObsFindNonEncodedCharInEncodedString    ObsFindNonEncodedCharInEncodedStringA
#define ObsBuildEncodedObjectStringFromPattern  ObsBuildEncodedObjectStringFromPatternA
#define ObsBuildEncodedObjectStringEx           ObsBuildEncodedObjectStringExA
#define ObsBuildPartialEncodedObjectStringEx    ObsBuildPartialEncodedObjectStringExA
#define ObsBuildEncodedObjectString             ObsBuildEncodedObjectStringA
#define ObsCreateParsedPattern                  ObsCreateParsedPatternA
#define ObsCreateParsedPatternEx                ObsCreateParsedPatternExA
#define ObsDestroyParsedPattern                 ObsDestroyParsedPatternA
#define ObsParsedPatternMatch                   ObsParsedPatternMatchA
#define ObsParsedPatternMatchEx                 ObsParsedPatternMatchExA
#define ObsPatternMatch                         ObsPatternMatchA
#define ObsIsPatternContained                   ObsIsPatternContainedA
#define ObsGetPatternLevels                     ObsGetPatternLevelsA
#define ObsPatternIncludesPattern               ObsPatternIncludesPatternA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\poolmem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    poolmem.h

Abstract:

    Declares the pool memory interface.  A pool of memory is a set of
    blocks (typically 8K each) that are used for several allocations,
    and then freed at the end of processing.  See below for routines.

Author:

    Marc R. Whitten (marcw)     02-Feb-1997

Revision History:

    jimschm     04-Feb-1998     Named pools for tracking

--*/

#pragma once

/*++

  Create and destroy routines:

    PMHANDLE
    PmCreatePoolEx (
        IN      DWORD BlockSize     OPTIONAL
        );

    PMHANDLE
    PmCreateNamedPoolEx (
        IN      PCSTR Name,
        IN      DWORD BlockSize     OPTIONAL
        );

    VOID
    PmDestroyPool (
        IN      PMHANDLE Handle
        );

  Primitive routines:

    PVOID
    PmGetMemory (
        IN      PMHANDLE Handle,
        IN      DWORD Size
        );

    PVOID
    PmGetAlignedMemory (
        IN      PMHANDLE Handle,
        IN      DWORD Size
        );

    VOID
    PmReleaseMemory (
        IN      PMHANDLE Handle,
        IN      PCVOID Memory
        );

  Performance and debugging control:

    VOID
    PmSetMinimumGrowthSize (
        IN      PMHANDLE Handle,
        IN      DWORD GrowthSize
        );

    VOID
    PmEmptyPool (
        IN      PMHANDLE Handle
        );

    VOID
    PmDisableTracking (
        IN      PMHANDLE Handle
        );

    VOID
    PmDumpStatistics (
        VOID
        );

  Allocation and duplication of data types:

    PCTSTR
    PmCreateString (
        IN      PMHANDLE Handle,
        IN      UINT TcharCount
        );

    PCTSTR
    PmCreateDword (
        IN      PMHANDLE Handle
        );

    PBYTE
    PmDuplicateMemory (
        IN      PMHANDLE Handle,
        IN      PBYTE Data,
        IN      UINT DataSize
        );

    PDWORD
    PmDuplciateDword (
        IN      PMHANDLE Handle,
        IN      DWORD Data
        );

    PTSTR
    PmDuplicateString (
        IN      PMHANDLE Handle,
        IN      PCTSTR String
        );

    PTSTR
    PmDuplicateMultiSz (
        IN      PMHANDLE Handle,
        IN      PCTSTR MultiSz
        );


--*/


//
// Default size of memory pool blocks. This can be changed on a per-pool basis
// by calling PmSetMinimumGrowthSize().
//

#define POOLMEMORYBLOCKSIZE 8192

//
// if DEBUG is defined, poolmem keeps a tally of common statistics on all
// pools. These include number of alloc and free requests, number of
// actual allocations and frees, and various size measures.
//
// PoolMem also checks each PmReleaseMemory() call to ensure that the
// address passed is a valid poolmem address that has not yet been freed.
//

PMHANDLE
RealPmCreatePoolEx (
    IN      DWORD BlockSize         OPTIONAL
    );

#define PmCreatePoolEx(b)           TRACK_BEGIN(PMHANDLE, PmCreatePoolEx)\
                                    RealPmCreatePoolEx(b)\
                                    TRACK_END()

#define PmCreatePool()              PmCreatePoolEx(0)

#ifdef DEBUG

PMHANDLE
RealPmCreateNamedPoolEx (
    IN      PCSTR Name,
    IN      DWORD BlockSize         OPTIONAL
    );

#define PmCreateNamedPoolEx(n,b)    TRACK_BEGIN(PMHANDLE, PmCreateNamedPoolEx)\
                                    RealPmCreateNamedPoolEx(n,b)\
                                    TRACK_END()

#define PmCreateNamedPool(n)        PmCreateNamedPoolEx(n,0)

#else

#define PmCreateNamedPoolEx(n,b)    PmCreatePoolEx(b)

#define PmCreateNamedPool(n)        PmCreatePoolEx(0)

#endif

VOID
PmDestroyPool (
    IN PMHANDLE Handle
    );


//
// Callers should use PmGetMemory or PmGetAlignedMemory. These each decay into
// RealPmGetMemory.
//

PVOID
RealPmGetMemory (
    IN      PMHANDLE Handle,
    IN      SIZE_T Size,
    IN      DWORD AlignSize
    );

#define PmGetMemory(h,s)           TRACK_BEGIN(PVOID, PmGetMemory)\
                                   RealPmGetMemory((h),(s),0)\
                                   TRACK_END()

#define PmGetAlignedMemory(h,s)    TRACK_BEGIN(PVOID, PmGetAlignedMemory)\
                                   RealPmGetMemory((h),(s),sizeof(DWORD))\
                                   TRACK_END()

VOID PmReleaseMemory (IN PMHANDLE Handle, IN PCVOID Memory);
VOID PmSetMinimumGrowthSize(IN PMHANDLE Handle, IN SIZE_T Size);


VOID
PmEmptyPool (
    IN      PMHANDLE Handle
    );


//
// PoolMem created strings are always aligned on DWORD boundaries.
//
#define PmCreateString(h,x) ((LPTSTR) PmGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PmCreateDword(h)    ((PDWORD) PmGetMemory((h),sizeof(DWORD)))


__inline
PBYTE
PmDuplicateMemory (
    IN PMHANDLE Handle,
    IN PCBYTE DataToCopy,
    IN UINT SizeOfData
    )
{
    PBYTE Data;

    Data = (PBYTE) PmGetAlignedMemory (Handle, SizeOfData);
    if (Data) {
        CopyMemory (Data, DataToCopy, SizeOfData);
    }

    return Data;
}


__inline
PDWORD
PmDuplicateDword (
    IN PMHANDLE Handle,
    IN DWORD ValueToCopy
    )
{
    PDWORD rWord;

    rWord = (PDWORD) PmGetMemory (Handle, sizeof (ValueToCopy));
    if (rWord) {
        *rWord = ValueToCopy;
    }

    return rWord;
}


__inline
PSTR
RealPmDuplicateStringA (
    IN PMHANDLE Handle,
    IN PCSTR StringToCopy
    )

{
    PSTR rString = RealPmGetMemory (
                        Handle,
                        SizeOfStringA (StringToCopy),
                        sizeof(WCHAR)
                        );

    if (rString) {

        StringCopyA (rString, StringToCopy);
    }

    return rString;
}

#define PmDuplicateStringA(h,s)    TRACK_BEGIN(PSTR, PmDuplicateStringA)\
                                   RealPmDuplicateStringA(h,s)\
                                   TRACK_END()


__inline
PWSTR
RealPmDuplicateStringW (
    IN PMHANDLE Handle,
    IN PCWSTR StringToCopy
    )

{
    PWSTR rString = RealPmGetMemory (
                        Handle,
                        SizeOfStringW (StringToCopy),
                        sizeof(WCHAR)
                        );

    if (rString) {

        StringCopyW (rString, StringToCopy);
    }

    return rString;
}

#define PmDuplicateStringW(h,s)    TRACK_BEGIN(PWSTR, PmDuplicateStringA)\
                                   RealPmDuplicateStringW(h,s)\
                                   TRACK_END()


__inline
PSTR
RealPmDuplicateStringABA (
    IN PMHANDLE Handle,
    IN PCSTR StringStart,
    IN PCSTR End
    )

{
    PSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = RealPmGetMemory (
                    Handle,
                    // cast is OK, we don't expenct pointers to be far away from each other
                    (DWORD)((UBINT) End - (UBINT) StringStart) + sizeof (CHAR),
                    sizeof(WCHAR)
                    );

    if (rString) {

        StringCopyABA (rString, StringStart, End);
    }

    return rString;
}

#define PmDuplicateStringABA(h,s,e)     TRACK_BEGIN(PSTR, PmDuplicateStringABA)\
                                        RealPmDuplicateStringABA(h,s,e)\
                                        TRACK_END()



__inline
PWSTR
RealPmDuplicateStringABW (
    IN PMHANDLE Handle,
    IN PCWSTR StringStart,
    IN PCWSTR End
    )

{
    PWSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = RealPmGetMemory (
                    Handle,
                    (DWORD)((UBINT) End - (UBINT) StringStart) + sizeof (WCHAR),
                    sizeof(WCHAR)
                    );

    if (rString) {

        StringCopyABW (rString,StringStart,End);
    }

    return rString;
}

#define PmDuplicateStringABW(h,s,e)     TRACK_BEGIN(PSTR, PmDuplicateStringABW)\
                                        RealPmDuplicateStringABW(h,s,e)\
                                        TRACK_END()


PSTR
PmDuplicateMultiSzA (
    IN PMHANDLE Handle,
    IN PCSTR MultiSzToCopy
    );

PWSTR
PmDuplicateMultiSzW (
    IN PMHANDLE Handle,
    IN PCWSTR MultiSzToCopy
    );

#ifdef UNICODE
#define PmDuplicateString  PmDuplicateStringW
#define PmDuplicateMultiSz PmDuplicateMultiSzW
#else
#define PmDuplicateString  PmDuplicateStringA
#define PmDuplicateMultiSz PmDuplicateMultiSzA
#endif

#ifdef DEBUG

VOID
PmDisableTracking (
    IN PMHANDLE Handle
    );

VOID
PmDumpStatistics (
    VOID
    );

#else

#define PmDisableTracking(x)
#define PmDumpStatistics()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\modimage.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    modimage.h

Abstract:

    Implements a set of routines for examining EXE modules

Author:

    Calin Negreanu (calinn) 27-Nov-1997

Revision History:

    calinn      08-Mar-2000 Moved over from Win9xUpg project.

--*/

#pragma once

//
// Includes
//

// None

//
// Debug constants
//

// None

//
// Strings
//

// None

//
// Constants
//

#define MODULETYPE_UNKNOWN      0x00000000
#define MODULETYPE_DOS          0x00000001
#define MODULETYPE_WIN16        0x00000002
#define MODULETYPE_WIN32        0x00000003

//
// Macros
//

// None

//
// Types
//

typedef struct _MD_IMPORT_ENUM16 {
    CHAR  ImportModule[MAX_MBCHAR_PATH];
    CHAR  ImportFunction[MAX_MBCHAR_PATH];
    ULONG ImportFunctionOrd;
    PVOID Handle;
} MD_IMPORT_ENUM16A, *PMD_IMPORT_ENUM16A;

typedef struct _MD_IMPORT_ENUM32 {
    PCSTR ImportModule;
    PCSTR ImportFunction;
    ULONG ImportFunctionOrd;
    PVOID Handle;
} MD_IMPORT_ENUM32A, *PMD_IMPORT_ENUM32A;

typedef struct _MD_MODULE_IMAGE {
    UINT ModuleType;
    union {
        struct {
            LOADED_IMAGE Image;
        } W32Data;
        struct {
            PBYTE Image;
            HANDLE FileHandle;
            HANDLE MapHandle;
        } W16Data;
    } ModuleData;
} MD_MODULE_IMAGE, *PMD_MODULE_IMAGE;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes
//

BOOL
MdLoadModuleDataA (
    IN      PCSTR ModuleName,
    OUT     PMD_MODULE_IMAGE ModuleImage
    );

BOOL
MdLoadModuleDataW (
    IN      PCWSTR ModuleName,
    OUT     PMD_MODULE_IMAGE ModuleImage
    );

BOOL
MdUnloadModuleDataA (
    IN OUT  PMD_MODULE_IMAGE ModuleImage
    );

BOOL
MdUnloadModuleDataW (
    IN OUT  PMD_MODULE_IMAGE ModuleImage
    );

BOOL
MdEnumFirstImport16A (
    IN      PBYTE ModuleImage,
    IN OUT  PMD_IMPORT_ENUM16A ImportsEnum
    );

BOOL
MdEnumNextImport16A (
    IN OUT  PMD_IMPORT_ENUM16A ImportsEnum
    );

BOOL
MdAbortImport16EnumA (
    IN      PMD_IMPORT_ENUM16A ImportsEnum
    );

BOOL
MdEnumFirstImportModule32A (
    IN      PLOADED_IMAGE ModuleImage,
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    );

BOOL
MdEnumNextImportModule32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    );

BOOL
MdEnumFirstImportFunction32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    );

BOOL
MdEnumNextImportFunction32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    );

BOOL
MdAbortImport32EnumA (
    IN      PMD_IMPORT_ENUM32A ImportsEnum
    );

DWORD
MdGetModuleTypeA (
    IN      PCSTR ModuleName
    );

DWORD
MdGetModuleTypeW (
    IN      PCWSTR ModuleName
    );

PCSTR
MdGet16ModuleDescriptionA (
    IN      PCSTR ModuleName
    );

PCWSTR
MdGet16ModuleDescriptionW (
    IN      PCWSTR ModuleName
    );

ULONG
MdGetPECheckSumA (
    IN      PCSTR ModuleName
    );

DWORD
MdGetCheckSumA (
    IN      PCSTR ModuleName
    );

DWORD
MdGetCheckSumW (
    IN      PCWSTR ModuleName
    );

//
// New Executable resource access
//

HANDLE
NeOpenFileA (
    PCSTR FileName
    );

HANDLE
NeOpenFileW (
    PCWSTR FileName
    );

VOID
NeCloseFile (
    HANDLE Handle
    );

//
// Once upon a time ENUMRESTYPEPROC was defined as a TCHAR prototype,
// which was broken.  If ENUMRESTYPEPROCA isn't defined, we'll define
// it.  (NOTE: The current winbase.h has these typedefs.)
//

#ifndef ENUMRESTYPEPROCA

typedef BOOL (CALLBACK* ENUMRESTYPEPROCA)(HMODULE hModule, PSTR lpType, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCW)(HMODULE hModule, PWSTR lpType, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCA)(HMODULE hModule, PCSTR lpType, PSTR lpName, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCW)(HMODULE hModule, PCWSTR lpType, PWSTR lpName, LONG_PTR lParam);

#endif

BOOL
NeEnumResourceTypesA (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCA EnumFunc,
    IN      LONG_PTR lParam
    );

BOOL
NeEnumResourceTypesW (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCW EnumFunc,
    IN      LONG_PTR lParam
    );

BOOL
NeEnumResourceNamesA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCA EnumFunc,
    IN      LONG_PTR lParam
    );

BOOL
NeEnumResourceNamesW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      ENUMRESNAMEPROCW EnumFunc,
    IN      LONG_PTR lParam
    );

DWORD
NeSizeofResourceA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    );

DWORD
NeSizeofResourceW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    );

PBYTE
NeFindResourceExA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    );

PBYTE
NeFindResourceExW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    );

#define NeFindResourceA(h,n,t) NeFindResourceExA(h,t,n)
#define NeFindResourceW(h,n,t) NeFindResourceExW(h,t,n)

//
// Macro expansion definition
//

// None

//
// TCHAR mappings
//

#ifndef UNICODE

#define MD_IMPORT_ENUM16                    MD_IMPORT_ENUM16A
#define MD_IMPORT_ENUM32                    MD_IMPORT_ENUM32A
#define MdLoadModuleData                    MdLoadModuleDataA
#define MdUnloadModuleData                  MdUnloadModuleDataA
#define MdEnumFirstImport16                 MdEnumFirstImport16A
#define MdEnumNextImport16                  MdEnumNextImport16A
#define MdAbortImport16Enum                 MdAbortImport16EnumA
#define MdEnumFirstImportModule32           MdEnumFirstImportModule32A
#define MdEnumNextImportModule32            MdEnumNextImportModule32A
#define MdEnumFirstImportFunction32         MdEnumFirstImportFunction32A
#define MdEnumNextImportFunction32          MdEnumNextImportFunction32A
#define MdAbortImport32Enum                 MdAbortImport32EnumA
#define MdGetModuleType                     MdGetModuleTypeA
#define MdGet16ModuleDescription            MdGet16ModuleDescriptionA
#define MdGetPECheckSum                     MdGetPECheckSumA
#define MdGetCheckSum                       MdGetCheckSumA

#define NeOpenFile                          NeOpenFileA
#define NeEnumResourceTypes                 NeEnumResourceTypesA
#define NeEnumResourceNames                 NeEnumResourceNamesA
#define NeSizeofResource                    NeSizeofResourceA
#define NeFindResource                      NeFindResourceA
#define NeFindResourceEx                    NeFindResourceExA

#else

#define MD_IMPORT_ENUM16                    MD_IMPORT_ENUM16W
#define MD_IMPORT_ENUM32                    MD_IMPORT_ENUM32W
#define MdLoadModuleData                    MdLoadModuleDataW
#define MdUnloadModuleData                  MdUnloadModuleDataW
#define MdEnumFirstImport16                 MdEnumFirstImport16W
#define MdEnumNextImport16                  MdEnumNextImport16W
#define MdAbortImport16Enum                 MdAbortImport16EnumW
#define MdEnumFirstImportModule32           MdEnumFirstImportModule32W
#define MdEnumNextImportModule32            MdEnumNextImportModule32W
#define MdEnumFirstImportFunction32         MdEnumFirstImportFunction32W
#define MdEnumNextImportFunction32          MdEnumNextImportFunction32W
#define MdAbortImport32Enum                 MdAbortImport32EnumW
#define MdGetModuleType                     MdGetModuleTypeW
#define MdGet16ModuleDescription            MdGet16ModuleDescriptionW
#define MdGetPECheckSum                     MdGetPECheckSumW
#define MdGetCheckSum                       MdGetCheckSumW

#define NeOpenFile                          NeOpenFileW
#define NeEnumResourceTypes                 NeEnumResourceTypesW
#define NeEnumResourceNames                 NeEnumResourceNamesW
#define NeSizeofResource                    NeSizeofResourceW
#define NeFindResource                      NeFindResourceW
#define NeFindResourceEx                    NeFindResourceExW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\progbar.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    progbar.h

Abstract:

    Declares the functions, variables and macros for the progress bar
    utilities.  The progress bar utilities manage a single progress bar by
    dividing it into slices.  Each slice has an initial static size.  The
    count for each slice is scaled independently, so code can dynamically
    change the slice count as an aid to help tick the progress bar more
    smoothly.

Author:

    Marc R. Whitten (marcw)     14-Apr-1997

Revision History:

    jimschm 01-Jul-1998     Rewrite

--*/

#pragma once

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// exposed for the macros
extern HWND    g_Component;
extern HWND    g_SubComponent;
extern HANDLE  g_ComponentCancelEvent;
extern HANDLE  g_SubComponentCancelEvent;

//
// Macro expansion list
//

// None

//
// Public function prototypes
//
// initialization and termination
//

VOID
PbInitialize (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    );

VOID
PbTerminate (
    VOID
    );

//
// registration, estimate revision and ticking
//

UINT
PbRegisterSlice (
    IN      UINT InitialEstimate
    );

VOID
PbReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    );

VOID
PbBeginSliceProcessing (
    IN      UINT SliceId
    );

VOID
PbGetSliceInfo (
    IN      UINT SliceId,
    OUT     PBOOL SliceStarted,     OPTIONAL
    OUT     PBOOL SliceFinished,    OPTIONAL
    OUT     PUINT TicksCompleted,   OPTIONAL
    OUT     PUINT TotalTicks        OPTIONAL
    );

BOOL
PbTickDelta (
    IN      UINT Ticks
    );

BOOL
PbTick (
    VOID
    );

VOID
PbEndSliceProcessing (
    VOID
    );


//
// delayed titles
//

BOOL
PbSetWindowStringA (
    IN      HWND Window,
    IN      HANDLE CancelEvent,
    IN      PCSTR Message,              OPTIONAL
    IN      DWORD MessageId             OPTIONAL
    );

BOOL
PbSetDelayedMessageA (
    IN      HWND Window,
    IN      HANDLE CancelEvent,
    IN      PCSTR Message,
    IN      DWORD MessageId,
    IN      DWORD Delay
    );

VOID
PbCancelDelayedMessage (
    IN      HANDLE CancelEvent
    );

#if 0

BOOL
PbCreateTickThread (
    IN      HANDLE CancelEvent,
    IN      DWORD TickCount
    );

BOOL
PbCancelTickThread (
    IN      HANDLE CancelEvent
    );

#endif



//
// Macro expansion definition
//

// None

//
// Macros, including ANSI/UNICODE macros
//

#define PbCancelDelayedComponent()                  PbCancelDelayedMessage(g_ComponentCancelEvent);
#define PbCancelDelayedSubComponent()               PbCancelDelayedMessage(g_SubComponentCancelEvent);

#ifndef UNICODE

#define PbSetComponent(s)                           PbSetWindowStringA(g_Component,g_ComponentCancelEvent,(s),0)

#if !defined PRERELEASE || !defined DEBUG

#define PbSetSubComponent(s)                        PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0)
#define PbSetFnName(s)
#define PbClearFnName()

#else

#define PbSetSubComponent(s)                        ((s) == NULL ? 1 : PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0))
#define PbSetFnName(s)                              PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0)
#define PbClearFnName()                             PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,NULL,0)

#endif

#define PbSetComponentById(n)                       PbSetWindowStringA(g_Component,g_ComponentCancelEvent,NULL,(n))
#define PbSetSubComponentById(n)                    PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,NULL,(n))
#define PbSetDelayedComponent(s,d)                  PbSetDelayedMessageA(g_Component,g_ComponentCancelEvent,(s),0,(d))
#define PbSetDelayedSubComponent(s,d)               PbSetDelayedMessageA(g_SubComponent,g_SubComponentCancelEvent,(s),0,(d))
#define PbSetDelayedComponentById(n,d)              PbSetDelayedMessageA(g_Component,g_ComponentCancelEvent,NULL,(n),(d))
#define PbSetDelayedSubComponentById(n,d)           PbSetDelayedMessageA(g_SubComponent,g_SubComponentCancelEvent,NULL,(n),(d))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\reg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg.h

Abstract:

    Implements macros to simplify the registry APIs and to track
    the resource allocations.

Author:

    Jim Schmidt (jimschm) 24-Mar-1997

Revision History:

    jimschm 09-Apr-1997     Expanded Get functionality

--*/

#pragma once

#define HKEY_ROOT   ((HKEY) 0X7FFFFFFF)

BOOL
RegInitialize (
    VOID
    );

VOID
RegTerminate (
    VOID
    );


VOID
RegInitializeCache (
    IN      UINT InitialCacheSize
    );

VOID
RegTerminateCache (
    VOID
    );

//
// APIs to set access mode
//

REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    );

//
// Tracking of registry calls.  These functions are completely
// turned off for non-debug builds and are mapped to the standard
// Win32 APIs via macro definitions.
//

//
// The Track* API take the same params as the Reg* equivalents.
// The Our* API also take the same params as the Reg* equivalents, but
// the debug versions have two extra parameters, File and Line.
//

//
// Use the Track* API set instead of the Reg* API set.
//

#ifndef DEBUG

#define DumpOpenKeys()

#define TrackedRegOpenKey             RegOpenKey
#define TrackedRegCreateKey           RegCreateKey
#define TrackedRegOpenKeyEx           RegOpenKeyEx
#define TrackedRegCreateKeyEx         RegCreateKeyEx

#define TrackedRegOpenKeyA            RegOpenKeyA
#define TrackedRegCreateKeyA          RegCreateKeyA
#define TrackedRegOpenKeyExA          RegOpenKeyExA
#define TrackedRegCreateKeyExA        RegCreateKeyExA

#define TrackedRegOpenKeyW            RegOpenKeyW
#define TrackedRegCreateKeyW          RegCreateKeyW
#define TrackedRegOpenKeyExW          RegOpenKeyExW
#define TrackedRegCreateKeyExW        RegCreateKeyExW

#define OurRegOpenKeyExA            RegOpenKeyExA
#define OurRegCreateKeyExA          RegCreateKeyExA

#define OurRegOpenRootKeyA(a,b)
#define OurRegOpenRootKeyW(a,b)

#define OurRegOpenKeyExW            RegOpenKeyExW
#define OurRegCreateKeyExW          RegCreateKeyExW

#define CloseRegKey                 RealCloseRegKey

#define DEBUG_TRACKING_PARAMS
#define DEBUG_TRACKING_ARGS

#else

extern DWORD g_DontCare;

#define DEBUG_TRACKING_PARAMS       ,PCSTR File,DWORD Line
#define DEBUG_TRACKING_ARGS         , File, Line

VOID
DumpOpenKeys (
    VOID
    );

LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );


VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#ifdef UNICODE
#define OurRegOpenRootKey OurRegOpenRootKeyW
#else
#define OurRegOpenRootKey OurRegOpenRootKeyA
#endif


LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    );

#define CloseRegKey(k) OurCloseRegKey(k,__FILE__,__LINE__)


#define TrackedRegOpenKeyEx(key,subkey,u,sam,res) OurRegOpenKeyEx(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKey(k,sk,rp) OurRegOpenKeyEx(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKey(k,sk,rp) OurRegCreateKeyEx(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExA(key,subkey,u,sam,res) OurRegOpenKeyExA(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyA(k,sk,rp) OurRegOpenKeyExA(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyA(k,sk,rp) OurRegCreateKeyExA(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExW(key,subkey,u,sam,res) OurRegOpenKeyExW(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyW(k,sk,rp) OurRegOpenKeyExW(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyW(K,sk,rp) OurRegCreateKeyExW(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

//
// Undefine the real registry APIs -- using them will throw off the tracking
//

#undef RegOpenKey
#undef RegCreateKey
#undef RegOpenKeyEx
#undef RegCreateKeyEx

#define RegCloseKey USE_CloseRegKey
#define RegOpenKeyA USE_TrackedRegOpenKeyA
#define RegCreateKeyA USE_TrackedRegCreateKeyA
#define RegOpenKeyExA USE_TrackedRegOpenKeyExA
#define RegCreateKeyExA USE_TrackedRegCreateKeyExA
#define RegOpenKeyW USE_TrackedRegOpenKeyw
#define RegCreateKeyW USE_TrackedRegCreateKeyW
#define RegOpenKeyExW USE_TrackedRegOpenKeyExW
#define RegCreateKeyExW USE_TrackedRegCreateKeyExW

#endif


#ifdef UNICODE
#define OurRegOpenKeyEx         OurRegOpenKeyExW
#define OurRegCreateKeyEx       OurRegCreateKeyExW
#else
#define OurRegOpenKeyEx         OurRegOpenKeyExA
#define OurRegCreateKeyEx       OurRegCreateKeyExA
#endif

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    );

PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    );

#define CreateEncodedRegistryStringA(k,v) CreateEncodedRegistryStringExA(k,v,TRUE)
#define CreateEncodedRegistryStringW(k,v) CreateEncodedRegistryStringExW(k,v,TRUE)

VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    );

VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    );


BOOL
DecodeRegistryStringA (
    IN      PCSTR RegString,
    OUT     PSTR KeyBuf,            OPTIONAL
    OUT     PSTR ValueBuf,          OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );

BOOL
DecodeRegistryStringW (
    IN      PCWSTR RegString,
    OUT     PWSTR KeyBuf,           OPTIONAL
    OUT     PWSTR ValueBuf,         OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );


//
// Versions that allow caller to specify allocator, and macro that uses
// MemAllocWrapper
//

typedef PVOID (ALLOCATOR_PROTOTYPE)(DWORD Size);
typedef ALLOCATOR_PROTOTYPE * ALLOCATOR;

ALLOCATOR_PROTOTYPE MemAllocWrapper;

typedef VOID (DEALLOCATOR_PROTOTYPE)(PCVOID Mem);
typedef DEALLOCATOR_PROTOTYPE * DEALLOCATOR;

DEALLOCATOR_PROTOTYPE MemFreeWrapper;

BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataA(key,valuename) TRACK_BEGIN(PBYTE, GetRegValueDataA)\
                                        GetRegValueData2A((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        TRACK_END()


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataW(key,valuename) TRACK_BEGIN(PBYTE,GetRegValueDataW)\
                                        GetRegValueData2W((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        TRACK_END()

PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeA(key,valuename,type)  TRACK_BEGIN(PBYTE, GetRegValueDataOfTypeA)\
                                                    GetRegValueDataOfType2A((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    TRACK_END()

PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeW(key,valuename,type)  TRACK_BEGIN(PBYTE, GetRegValueDataOfTypeW)\
                                                    GetRegValueDataOfType2W((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    TRACK_END()

PBYTE
GetRegKeyData2A (
    IN      HKEY hKey,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataA(key,subkey)  TRACK_BEGIN(PBYTE, GetRegKeyDataA)\
                                    GetRegKeyData2A((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

PBYTE
GetRegKeyData2W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataW(key,subkey)  TRACK_BEGIN(PBYTE, GetRegKeyDataW)\
                                    GetRegKeyData2W((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataA(keystr,value) TRACK_BEGIN(PBYTE, GetRegDataA)\
                                  GetRegData2A((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                  TRACK_END()

PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataW(keystr,value)   TRACK_BEGIN(PBYTE, GetRegDataW)\
                                    GetRegData2W((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    );


//
// Reg key create & open
//

HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
RealCloseRegKey (
    IN      HKEY Key
    );

BOOL
DeleteRegKeyA (
    IN      HKEY Key,
    IN      PCSTR SubKey
    );

BOOL
DeleteRegKeyW (
    IN      HKEY Key,
    IN      PCWSTR SubKey
    );

BOOL
DeleteRegKeyStrA (
    IN      PCSTR RegKey
    );

BOOL
DeleteRegKeyStrW (
    IN      PCWSTR RegKey
    );

BOOL
DeleteEmptyRegKeyStrA (
    IN      PCSTR RegKey
    );

BOOL
DeleteEmptyRegKeyStrW (
    IN      PCWSTR RegKey
    );

#ifdef DEBUG

#define CreateRegKeyA(a,b) RealCreateRegKeyA(a,b,__FILE__,__LINE__)
#define CreateRegKeyW(a,b) RealCreateRegKeyW(a,b,__FILE__,__LINE__)
#define CreateRegKeyStrA(a) RealCreateRegKeyStrA(a,__FILE__,__LINE__)
#define CreateRegKeyStrW(a) RealCreateRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyStrA(a) RealOpenRegKeyStrA(a,__FILE__,__LINE__)
#define OpenRegKeyStrW(a) RealOpenRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyA(a,b) RealOpenRegKeyA(a,b,__FILE__,__LINE__)
#define OpenRegKeyW(a,b) RealOpenRegKeyW(a,b,__FILE__,__LINE__)

#else

#define CreateRegKeyA RealCreateRegKeyA
#define CreateRegKeyW RealCreateRegKeyW
#define CreateRegKeyStrA RealCreateRegKeyStrA
#define CreateRegKeyStrW RealCreateRegKeyStrW
#define OpenRegKeyStrA RealOpenRegKeyStrA
#define OpenRegKeyStrW RealOpenRegKeyStrW
#define OpenRegKeyA RealOpenRegKeyA
#define OpenRegKeyW RealOpenRegKeyW

#endif


//
// Registry root functions
//

VOID
SetRegRoot (
    IN      HKEY Root
    );

HKEY
GetRegRoot (
    VOID
    );


// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootStringA (PCSTR RootString, PDWORD LengthPtr OPTIONAL);
INT GetOffsetOfRootStringW (PCWSTR RootString, PDWORD LengthPtr OPTIONAL);

// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootKey (HKEY RootKey);

// Given non-zero array offset to root, returns string or NULL if element
// is out of bounds
PCSTR GetRootStringFromOffsetA (INT i);
PCWSTR GetRootStringFromOffsetW (INT i);

// Given non-zero array offset to root, returns registry handle or NULL if
// element is out of bounds
HKEY GetRootKeyFromOffset (INT i);

// Converts the root at the head of RegPath to an HKEY and gives the number
// of characters occupied by the root string (including optional wack)
HKEY ConvertRootStringToKeyA (PCSTR RegPath, PDWORD LengthPtr OPTIONAL);
HKEY ConvertRootStringToKeyW (PCWSTR RegPath, PDWORD LengthPtr OPTIONAL);

// Returns a pointer to a static string for the matching root, or NULL if
// RegRoot does not point to a valid root
PCSTR ConvertKeyToRootStringA (HKEY RegRoot);
PCWSTR ConvertKeyToRootStringW (HKEY RegRoot);



//
// Macros
//

#define GetRegValueStringA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_SZ)
#define GetRegValueBinaryA(key,valuename) (PBYTE) GetRegValueDataOfTypeA((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordA(key,valuename) (PDWORD) GetRegValueDataOfTypeA((key),(valuename),REG_DWORD)

#define GetRegValueStringW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_SZ)
#define GetRegValueBinaryW(key,valuename) (PBYTE) GetRegValueDataOfTypeW((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordW(key,valuename) (PDWORD) GetRegValueDataOfTypeW((key),(valuename),REG_DWORD)

#define GetRegValueString2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_DWORD,alloc,free)

#define GetRegValueString2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeW
#define GetRegValueData                 GetRegValueDataW
#define GetRegValueDataOfType           GetRegValueDataOfTypeW
#define GetRegKeyData                   GetRegKeyDataW
#define GetRegValueData2                GetRegValueData2W
#define GetRegValueDataOfType2          GetRegValueDataOfType2W
#define GetRegKeyData2                  GetRegKeyData2W
#define GetRegValueString               GetRegValueStringW
#define GetRegValueBinary               GetRegValueBinaryW
#define GetRegValueMultiSz              GetRegValueMultiSzW
#define GetRegValueDword                GetRegValueDwordW
#define GetRegValueString2              GetRegValueString2W
#define GetRegValueBinary2              GetRegValueBinary2W
#define GetRegValueMultiSz2             GetRegValueMultiSz2W
#define GetRegValueDword2               GetRegValueDword2W
#define GetRegData2                     GetRegData2W
#define GetRegData                      GetRegDataW

#define CreateRegKey                    CreateRegKeyW
#define CreateRegKeyStr                 CreateRegKeyStrW
#define OpenRegKey                      OpenRegKeyW
#define OpenRegKeyStr                   OpenRegKeyStrW
#define DeleteRegKey                    DeleteRegKeyW
#define DeleteRegKeyStr                 DeleteRegKeyStrW
#define DeleteEmptyRegKeyStr            DeleteEmptyRegKeyStrW
#define GetOffsetOfRootString           GetOffsetOfRootStringW
#define GetRootStringFromOffset         GetRootStringFromOffsetW
#define ConvertRootStringToKey          ConvertRootStringToKeyW
#define ConvertKeyToRootString          ConvertKeyToRootStringW
#define CreateEncodedRegistryString     CreateEncodedRegistryStringW
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExW
#define FreeEncodedRegistryString       FreeEncodedRegistryStringW
#define DecodeRegistryString            DecodeRegistryStringW


#else

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeA
#define GetRegValueData                 GetRegValueDataA
#define GetRegValueDataOfType           GetRegValueDataOfTypeA
#define GetRegKeyData                   GetRegKeyDataA
#define GetRegValueData2                GetRegValueData2A
#define GetRegValueDataOfType2          GetRegValueDataOfType2A
#define GetRegKeyData2                  GetRegKeyData2A
#define GetRegValueString               GetRegValueStringA
#define GetRegValueBinary               GetRegValueBinaryA
#define GetRegValueMultiSz              GetRegValueMultiSzA
#define GetRegValueDword                GetRegValueDwordA
#define GetRegValueString2              GetRegValueString2A
#define GetRegValueBinary2              GetRegValueBinary2A
#define GetRegValueMultiSz2             GetRegValueMultiSz2A
#define GetRegValueDword2               GetRegValueDword2A
#define GetRegData2                     GetRegData2A
#define GetRegData                      GetRegDataA

#define CreateRegKey                    CreateRegKeyA
#define CreateRegKeyStr                 CreateRegKeyStrA
#define OpenRegKey                      OpenRegKeyA
#define OpenRegKeyStr                   OpenRegKeyStrA
#define DeleteRegKey                    DeleteRegKeyA
#define DeleteRegKeyStr                 DeleteRegKeyStrA
#define DeleteEmptyRegKeyStr            DeleteEmptyRegKeyStrA
#define GetOffsetOfRootString           GetOffsetOfRootStringA
#define GetRootStringFromOffset         GetRootStringFromOffsetA
#define ConvertRootStringToKey          ConvertRootStringToKeyA
#define ConvertKeyToRootString          ConvertKeyToRootStringA
#define CreateEncodedRegistryString     CreateEncodedRegistryStringA
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExA
#define FreeEncodedRegistryString       FreeEncodedRegistryStringA
#define DecodeRegistryString            DecodeRegistryStringA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\regenum.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regenum.h

Abstract:

    Set of APIs to enumerate the local registry using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

#define REGENUM_ALL_SUBLEVELS   0xFFFFFFFF

#define REG_ATTRIBUTE_KEY       0x00000001
#define REG_ATTRIBUTE_VALUE     0x00000002

//
// Root enumeration structures
//

typedef struct {
    PCSTR   RegRootName;
    HKEY    RegRootHandle;
    UINT    Index;
} REGROOT_ENUMA, *PREGROOT_ENUMA;

typedef struct {
    PCWSTR  RegRootName;
    HKEY    RegRootHandle;
    UINT    Index;
} REGROOT_ENUMW, *PREGROOT_ENUMW;

//
// Key/Values enumeration structures
//

typedef enum {
    RECF_SKIPKEY                = 0x0001,
    RECF_SKIPSUBKEYS            = 0x0002,
    RECF_SKIPVALUES             = 0x0004,
} REGENUM_CONTROLFLAGS;

typedef enum {
    REIF_RETURN_KEYS            = 0x0001,
    REIF_VALUES_FIRST           = 0x0002,
    REIF_DEPTH_FIRST            = 0x0004,
    REIF_USE_EXCLUSIONS         = 0x0008,
    REIF_CONTAINERS_FIRST       = 0x0010,
    REIF_READ_VALUE_DATA        = 0x0020,
} REGENUMINFOFLAGS;

typedef enum {
    RNS_ENUM_INIT,
    RNS_VALUE_FIRST,
    RNS_VALUE_NEXT,
    RNS_VALUE_DONE,
    RNS_SUBKEY_FIRST,
    RNS_SUBKEY_NEXT,
    RNS_SUBKEY_DONE,
    RNS_ENUM_DONE
} RNS_ENUM_STATE;

typedef enum {
    RES_ROOT_FIRST,
    RES_ROOT_NEXT,
    RES_ROOT_DONE
} RES_ROOT_STATE;


typedef enum {
    RNF_RETURN_KEYS         = 0x0001,
    RNF_KEYNAME_MATCHES     = 0x0002,
    RNF_VALUENAME_INVALID   = 0x0004,
    RNF_VALUEDATA_INVALID   = 0x0008,
} REGNODE_FLAGS;

typedef struct {
    PCSTR   KeyName;
    HKEY    KeyHandle;
    DWORD   ValueCount;
    PSTR    ValueName;
    DWORD   ValueLengthMax;
    DWORD   ValueType;
    PBYTE   ValueData;
    DWORD   ValueDataSize;
    DWORD   ValueDataSizeMax;
    DWORD   SubKeyCount;
    PSTR    SubKeyName;
    DWORD   SubKeyLengthMax;
    DWORD   SubKeyIndex;
    DWORD   ValueIndex;
    DWORD   EnumState;
    DWORD   Flags;
    DWORD   SubLevel;
} REGNODEA, *PREGNODEA;

typedef struct {
    PCWSTR  KeyName;
    HKEY    KeyHandle;
    DWORD   ValueCount;
    PWSTR   ValueName;
    DWORD   ValueLengthMax;
    DWORD   ValueType;
    PBYTE   ValueData;
    DWORD   ValueDataSize;
    DWORD   ValueDataSizeMax;
    DWORD   SubKeyCount;
    PWSTR   SubKeyName;
    DWORD   SubKeyLengthMax;
    DWORD   SubKeyIndex;
    DWORD   ValueIndex;
    DWORD   EnumState;
    DWORD   Flags;
    DWORD   SubLevel;
} REGNODEW, *PREGNODEW;

typedef BOOL (*RPE_ERROR_CALLBACKA)(PREGNODEA);

typedef struct {
    POBSPARSEDPATTERNA      RegPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    RPE_ERROR_CALLBACKA     CallbackOnError;
} REGENUMINFOA, *PREGENUMINFOA;

typedef BOOL (*RPE_ERROR_CALLBACKW)(PREGNODEW);

typedef struct {
    POBSPARSEDPATTERNW      RegPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    RPE_ERROR_CALLBACKW     CallbackOnError;
} REGENUMINFOW, *PREGENUMINFOW;

typedef struct {
    PCSTR           EncodedFullName;
    PCSTR           Name;
    PCSTR           Location;
    CHAR            NativeFullName[2 * MAX_MBCHAR_PATH];
    PBYTE           CurrentValueData;
    UINT            CurrentValueDataSize;
    DWORD           CurrentValueType;
    HKEY            CurrentKeyHandle;
    DWORD           CurrentLevel;
    DWORD           Attributes;

    //
    // Private members
    //
    DWORD           ControlFlags;
    REGENUMINFOA    RegEnumInfo;
    GROWBUFFER      RegNodes;
    DWORD           RootState;
    PREGROOT_ENUMA  RootEnum;
    PREGNODEA       LastNode;
    PSTR            RegNameAppendPos;
    PSTR            LastWackPtr;
} REGTREE_ENUMA, *PREGTREE_ENUMA;

typedef struct {
    PCWSTR          EncodedFullName;
    PCWSTR          Name;
    PCWSTR          Location;
    WCHAR           NativeFullName[2 * MAX_WCHAR_PATH];
    PBYTE           CurrentValueData;
    UINT            CurrentValueDataSize;
    DWORD           CurrentValueType;
    HKEY            CurrentKeyHandle;
    DWORD           CurrentLevel;
    DWORD           Attributes;

    //
    // Private members
    //
    DWORD           ControlFlags;
    REGENUMINFOW    RegEnumInfo;
    GROWBUFFER      RegNodes;
    DWORD           RootState;
    PREGROOT_ENUMW  RootEnum;
    PREGNODEW       LastNode;
    PWSTR           RegNameAppendPos;
    PWSTR           LastWackPtr;
} REGTREE_ENUMW, *PREGTREE_ENUMW;


//
// API
//

BOOL
RegEnumDefaultCallbackA (
    IN      PREGNODEA RegNode       OPTIONAL
    );

BOOL
RegEnumDefaultCallbackW (
    IN      PREGNODEW RegNode       OPTIONAL
    );

BOOL
EnumFirstRegRootA (
    OUT     PREGROOT_ENUMA EnumPtr
    );

BOOL
EnumFirstRegRootW (
    OUT     PREGROOT_ENUMW EnumPtr
    );

BOOL
EnumNextRegRootA (
    IN OUT  PREGROOT_ENUMA EnumPtr
    );

BOOL
EnumNextRegRootW (
    IN OUT  PREGROOT_ENUMW EnumPtr
    );

BOOL
EnumFirstRegObjectInTreeExA (
    OUT     PREGTREE_ENUMA RegEnum,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData,
    IN      RPE_ERROR_CALLBACKA CallbackOnError     OPTIONAL
    );

#define EnumFirstRegObjectInTreeA(e,p)  EnumFirstRegObjectInTreeExA(e,p,TRUE,TRUE,TRUE,TRUE,REGENUM_ALL_SUBLEVELS,FALSE,FALSE,RegEnumDefaultCallbackA)

BOOL
EnumFirstRegObjectInTreeExW (
    OUT     PREGTREE_ENUMW RegEnum,
    IN      PCWSTR EncodedKeyPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData,
    IN      RPE_ERROR_CALLBACKW CallbackOnError     OPTIONAL
    );

#define EnumFirstRegObjectInTreeW(e,p)  EnumFirstRegObjectInTreeExW(e,p,TRUE,TRUE,TRUE,TRUE,REGENUM_ALL_SUBLEVELS,FALSE,FALSE,RegEnumDefaultCallbackW)

BOOL
EnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    );

BOOL
EnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    );

VOID
AbortRegObjectInTreeEnumA (
    IN OUT  PREGTREE_ENUMA RegEnum
    );

VOID
AbortRegObjectInTreeEnumW (
    IN OUT  PREGTREE_ENUMW RegEnum
    );

BOOL
RgRemoveAllValuesInKeyA (
    IN      PCSTR KeyToRemove
    );

BOOL
RgRemoveAllValuesInKeyW (
    IN      PCWSTR KeyToRemove
    );

BOOL
RgRemoveKeyA (
    IN      PCSTR KeyToRemove
    );

BOOL
RgRemoveKeyW (
    IN      PCWSTR KeyToRemove
    );

//
// Macros
//

#ifdef UNICODE

#define RegEnumDefaultCallback      RegEnumDefaultCallbackW
#define REGROOT_ENUM                REGROOT_ENUMW
#define EnumFirstRegRoot            EnumFirstRegRootW
#define EnumNextRegRoot             EnumNextRegRootW
#define REGNODE                     REGNODEW
#define PREGNODE                    PREGNODEW
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKW
#define REGENUMINFO                 REGENUMINFOW
#define PREGENUMINFO                PREGENUMINFOW
#define REGTREE_ENUM                REGTREE_ENUMW
#define PREGTREE_ENUM               PREGTREE_ENUMW
#define EnumFirstRegObjectInTree    EnumFirstRegObjectInTreeW
#define EnumFirstRegObjectInTreeEx  EnumFirstRegObjectInTreeExW
#define EnumNextRegObjectInTree     EnumNextRegObjectInTreeW
#define AbortRegObjectInTreeEnum    AbortRegObjectInTreeEnumW
#define RgRemoveAllValuesInKey      RgRemoveAllValuesInKeyW
#define RgRemoveKey                 RgRemoveKeyW

#else

#define RegEnumDefaultCallback      RegEnumDefaultCallbackA
#define REGROOT_ENUM                REGROOT_ENUMA
#define EnumFirstRegRoot            EnumFirstRegRootA
#define EnumNextRegRoot             EnumNextRegRootA
#define REGNODE                     REGNODEA
#define PREGNODE                    PREGNODEA
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKA
#define REGENUMINFO                 REGENUMINFOA
#define PREGENUMINFO                PREGENUMINFOA
#define REGTREE_ENUM                REGTREE_ENUMA
#define PREGTREE_ENUM               PREGTREE_ENUMA
#define EnumFirstRegObjectInTree    EnumFirstRegObjectInTreeA
#define EnumFirstRegObjectInTreeEx  EnumFirstRegObjectInTreeExA
#define EnumNextRegObjectInTree     EnumNextRegObjectInTreeA
#define AbortRegObjectInTreeEnum    AbortRegObjectInTreeEnumA
#define RgRemoveAllValuesInKey      RgRemoveAllValuesInKeyA
#define RgRemoveKey                 RgRemoveKeyA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\strmap.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    strmap.h

Abstract:

    Strmap (formally pathmap) is a fast hueristic-based program that
    searches strings and attempts to replace substrings when there
    are matching substrings in the mapping database.

Author:

    Marc R. Whitten (marcw) 20-Mar-1997

Revision History:

    Jim Schmidt (jimschm) 08-May-2000       Rewrote mapping, added Flags & ex nodes
    Calin Negreanu (calinn) 02-Mar-2000     Ported from win9xupg project

--*/

//
// Constants
//

#define STRMAP_COMPLETE_MATCH_ONLY                  0x0001
#define STRMAP_FIRST_CHAR_MUST_MATCH                0x0002
#define STRMAP_RETURN_AFTER_FIRST_REPLACE           0x0004
#define STRMAP_REQUIRE_WACK_OR_NUL                  0x0008

//
// Types
//

typedef struct {
    BOOL UnicodeData;

    //
    // The filter can replace NewSubString.  (The filter must also
    // set NewSubStringSizeInBytes when replacing NewSubString.)
    //

    union {
        struct {
            PCWSTR OriginalString;
            PCWSTR BeginningOfMatch;
            PCWSTR CurrentString;
            PCWSTR OldSubString;
            PCWSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Unicode;

        struct {
            PCSTR OriginalString;
            PCSTR BeginningOfMatch;
            PCSTR CurrentString;
            PCSTR OldSubString;
            PCSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Ansi;
    };
} REG_REPLACE_DATA, *PREG_REPLACE_DATA;

typedef BOOL(REG_REPLACE_FILTER_PROTOTYPE)(PREG_REPLACE_DATA Data);
typedef REG_REPLACE_FILTER_PROTOTYPE * REG_REPLACE_FILTER;

typedef struct TAG_CHARNODE {
    WORD Char;
    WORD Flags;
    PVOID OriginalStr;
    PVOID ReplacementStr;
    INT ReplacementBytes;

    struct TAG_CHARNODE *NextLevel;
    struct TAG_CHARNODE *NextPeer;

} CHARNODE, *PCHARNODE;

typedef struct {
    CHARNODE Node;
    REG_REPLACE_FILTER Filter;
    ULONG_PTR ExtraData;
} CHARNODEEX, *PCHARNODEEX;



typedef struct {
    PMHANDLE Pool;
    PCHARNODE FirstLevelRoot;
    BOOL UsesExNode;
    BOOL UsesFilter;
    BOOL UsesExtraData;
} MAPSTRUCT, *PMAPSTRUCT;

//
// Macros
//

// None

//
// APIs
//

PMAPSTRUCT
CreateStringMappingEx (
    IN      BOOL UsesFilter,
    IN      BOOL UsesExtraData
    );

#define CreateStringMapping()   CreateStringMappingEx(FALSE,FALSE)

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    );

VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define AddStringMappingPairA(Map,Old,New) AddStringMappingPairExA(Map,Old,New,NULL,0,0)

VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define AddStringMappingPairW(Map,Old,New) AddStringMappingPairExW(Map,Old,New,NULL,0,0)

BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define MappingSearchAndReplaceA(map,buffer,maxbytes)   MappingSearchAndReplaceExA(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define MappingSearchAndReplaceW(map,buffer,maxbytes)   MappingSearchAndReplaceExW(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingMultiTableSearchAndReplaceExA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define MappingMultiTableSearchAndReplaceA(array,count,buffer,maxbytes)   \
        MappingMultiTableSearchAndReplaceExA(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingMultiTableSearchAndReplaceExW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define MappingMultiTableSearchAndReplaceW(array,count,buffer,maxbytes)   \
        MappingMultiTableSearchAndReplaceExW(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

//
// Macros
//

#ifdef UNICODE

#define AddStringMappingPairEx                  AddStringMappingPairExW
#define AddStringMappingPair                    AddStringMappingPairW
#define MappingSearchAndReplaceEx               MappingSearchAndReplaceExW
#define MappingSearchAndReplace                 MappingSearchAndReplaceW
#define MappingMultiTableSearchAndReplaceEx     MappingMultiTableSearchAndReplaceExW
#define MappingMultiTableSearchAndReplace       MappingMultiTableSearchAndReplaceW

#else

#define AddStringMappingPairEx                  AddStringMappingPairExA
#define AddStringMappingPair                    AddStringMappingPairA
#define MappingSearchAndReplaceEx               MappingSearchAndReplaceExA
#define MappingSearchAndReplace                 MappingSearchAndReplaceA
#define MappingMultiTableSearchAndReplaceEx     MappingMultiTableSearchAndReplaceExA
#define MappingMultiTableSearchAndReplace       MappingMultiTableSearchAndReplaceA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\utiltypes.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    utiltypes.h

Abstract:

    Defines types used by utilities

Author:

    Jim Schmidt (jimschm) 25-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef PVOID PMHANDLE;
typedef struct TAG_GROWBUFFER *PGROWBUFFER;
typedef struct TAG_PARSEDPATTERNA *PPARSEDPATTERNA;
typedef struct TAG_PARSEDPATTERNW *PPARSEDPATTERNW;
typedef struct TAG_OBSPARSEDPATTERNA *POBSPARSEDPATTERNA;
typedef struct TAG_OBSPARSEDPATTERNW *POBSPARSEDPATTERNW;
typedef const void *HASHTABLE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\strings.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Declares the string utilities implemented in common\migutil.

Author:

    Several

Revision History:

    See SLM log

--*/

#include <tchar.h>
#include <mbstring.h>
#include <wchar.h>

typedef PVOID PMHANDLE;

#pragma once

#define MAX_ENCODED_RULE    (256*6)
#define NODE_LEVEL_MAX      ((DWORD)-1)

#define SHIFTRIGHT8(l)  (/*lint --e(506)*/sizeof(l)<=1?0:l>>8)
#define SHIFTRIGHT16(l) (/*lint --e(506)*/sizeof(l)<=2?0:l>>16)
#define SHIFTRIGHT32(l) (/*lint --e(506)*/sizeof(l)<=4?0:l>>32)

extern CHAR EscapedCharsA[];
extern WCHAR EscapedCharsW[];

//
// String sizing routines and unit conversion
//

#define CharCountA(x)   ((DWORD)_mbslen(x))
#define CharCountW(x)   ((DWORD)wcslen(x))

#define SIZEOF(x)       ((DWORD)sizeof(x))


extern BOOL g_LeadByteArray[256];

__inline
BOOL
IsLeadByte (
    IN      PCSTR BytePtr
    )
{
    return (BytePtr[0] && g_LeadByteArray[BytePtr[0]]) ? (BytePtr[1] != 0) : FALSE;
}

__inline
BOOL
IsCharLeadByte (
    BYTE ByteToTest
    )
{
    return g_LeadByteArray[ByteToTest];
}

__inline
PSTR
CharCountToPointerA (
    PCSTR String,
    UINT Char
    )
{
    while (Char > 0) {
        MYASSERT (*String != 0);
        Char--;
        String = _mbsinc (String);
    }

    return (PSTR) String;
}

__inline
PWSTR
CharCountToPointerW (
    PCWSTR String,
    UINT Char
    )
{
#ifdef DEBUG
    UINT u;
    for (u = 0 ; u < Char ; u++) {
        MYASSERT (String[u] != 0);
    }
#endif

    return (PWSTR) (&String[Char]);
}


__inline
UINT
CharCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
    register UINT Count;

    Count = 0;
    while (Start < EndPlusOne) {
        MYASSERT (*Start != 0);
        Count++;
        Start = _mbsinc (Start);
    }

    return Count;
}

__inline
UINT
CharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}


__inline
UINT
CharCountInByteRangeA (
    IN      PCSTR Start,
    IN      UINT Bytes
    )
{
    register UINT Count;
    PCSTR EndPlusOne = (PCSTR) ((UBINT) Start + Bytes);

    Count = 0;
    while (Start < EndPlusOne) {
        Count++;
        Start = _mbsinc (Start);
    }

    return Count;
}

__inline
UINT
CharCountInByteRangeW (
    IN      PCWSTR Start,
    IN      UINT Bytes
    )
{
    PCWSTR EndPlusOne = (PCWSTR) ((UBINT) Start + Bytes);

    if (Start < EndPlusOne) {
        //cast is OK, we don't expect pointers to be that far
        return (UINT)(EndPlusOne - Start);
    }

    MYASSERT (FALSE);
    return 0;
}

__inline
UINT
CharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT CharCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = CharCountToPointerA (Start, CharCount);
    //cast is OK, we don't expect pointers to be that far
    return (UINT)(EndPlusOne - Start);
}

__inline
UINT
CharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount * SIZEOF (WCHAR);
}

#define CharCountToTcharsA   CharCountToBytesA

__inline
UINT
CharCountToTcharsW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount;
}


#define ByteCountA(x)       ((DWORD)strlen(x))
#define ByteCountW(x)       ((DWORD)wcslen(x)*SIZEOF(WCHAR))

#define SizeOfStringA(str)  ((DWORD)ByteCountA(str) + SIZEOF (CHAR))
#define SizeOfStringW(str)  ((DWORD)ByteCountW(str) + SIZEOF (WCHAR))

__inline
PSTR
ByteCountToPointerA (
    PCSTR String,
    UINT BytePos
    )
{
    return (PSTR)((UBINT) String + BytePos);
}

__inline
PWSTR
ByteCountToPointerW (
    PCWSTR String,
    UINT BytePos
    )
{
    return (PWSTR)((UBINT) String + BytePos);
}


__inline
UINT
ByteCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCSTR p;
    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

__inline
UINT
ByteCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) * SIZEOF (WCHAR) : 0;
}

__inline
UINT
ByteCountToCharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = Start + ByteCount;
    return CharCountABA (Start, EndPlusOne);
}

__inline
UINT
ByteCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = (PCWSTR) ((UBINT) Start + ByteCount);

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount / SIZEOF (WCHAR);
}

__inline
UINT
ByteCountToTcharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + ByteCount;

    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount;
}

#define ByteCountToTcharsW  ByteCountToCharsW


#define TcharCountA     strlen
#define TcharCountW     wcslen

__inline
PSTR
TcharCountToPointerA (
    PCSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return (PSTR) (String + Tchars);
}

__inline
PWSTR
TcharCountToPointerW (
    PCWSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return (PWSTR) (String + Tchars);
}


#define TcharCountABA       ByteCountABA

__inline
UINT
TcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

#define TcharCountToCharsA      ByteCountToCharsA

__inline
UINT
TcharCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars * SIZEOF (WCHAR);
}

VOID
UBINTtoHexA (
    IN      UBINT Number,
    OUT     PSTR String
    );

VOID
UBINTtoHexW (
    IN      UBINT Number,
    OUT     PWSTR String
    );

VOID
UBINTtoDecA (
    IN      UBINT Number,
    OUT     PSTR String
    );

VOID
UBINTtoDecW (
    IN      UBINT Number,
    OUT     PWSTR String
    );

VOID
BINTtoDecA (
    IN      BINT Number,
    OUT     PSTR String
    );

VOID
BINTtoDecW (
    IN      BINT Number,
    OUT     PWSTR String
    );

#define StackStringCopyA(stackbuf,src)                  StringCopyByteCountA(stackbuf,src,SIZEOF(stackbuf))
#define StackStringCopyW(stackbuf,src)                  StringCopyByteCountW(stackbuf,src,SIZEOF(stackbuf))


//
// String comparison routines
//

#define StringCompareA                                  _mbscmp
#define StringCompareW                                  wcscmp

BOOL
StringMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    );

#define StringMatchW(str1,str2)                         (wcscmp(str1,str2)==0)

#define StringICompareA                                 _mbsicmp
#define StringICompareW                                 _wcsicmp

#define StringIMatchA(str1,str2)                        (_mbsicmp(str1,str2)==0)
#define StringIMatchW(str1,str2)                        (_wcsicmp(str1,str2)==0)

#define StringCompareByteCountA(str1,str2,bytes)        _mbsncmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringCompareByteCountW(str1,str2,bytes)        wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringMatchByteCountA(str1,str2,bytes)          StringMatchABA(str1,str2,(PCSTR)((PBYTE)(str2) + bytes))
#define StringMatchByteCountW(str1,str2,bytes)          (wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringICompareByteCountA(str1,str2,bytes)       _mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringICompareByteCountW(str1,str2,bytes)       _wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringIMatchByteCountA(str1,str2,bytes)         (_mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))==0)
#define StringIMatchByteCountW(str1,str2,bytes)         (_wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringCompareCharCountA(str1,str2,chars)        _mbsncmp(str1,str2,chars)
#define StringCompareCharCountW(str1,str2,chars)        wcsncmp(str1,str2,chars)

#define StringMatchCharCountA(str1,str2,chars)          (_mbsncmp(str1,str2,chars)==0)
#define StringMatchCharCountW(str1,str2,chars)          (wcsncmp(str1,str2,chars)==0)

#define StringICompareCharCountA(str1,str2,chars)       _mbsnicmp(str1,str2,chars)
#define StringICompareCharCountW(str1,str2,chars)       _wcsnicmp(str1,str2,chars)

#define StringIMatchCharCountA(str1,str2,chars)         (_mbsnicmp(str1,str2,chars)==0)
#define StringIMatchCharCountW(str1,str2,chars)         (_wcsnicmp(str1,str2,chars)==0)

#define StringCompareTcharCountA(str1,str2,tchars)      StringCompareByteCountA(str1,str2,(tchars)/sizeof(CHAR))
#define StringCompareTcharCountW(str1,str2,tchars)      wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringMatchTcharCountA(str1,str2,tchars)        (_mbsncmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringMatchTcharCountW(str1,str2,tchars)        (wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)

#define StringICompareTcharCountA(str1,str2,tchars)     _mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))
#define StringICompareTcharCountW(str1,str2,tchars)     _wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringIMatchTcharCountA(str1,str2,tchars)       (_mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringIMatchTcharCountW(str1,str2,tchars)       (_wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)

#define StringPrefixA(string,prefix)                    StringMatchCharCountA(string,prefix,CharCountA(prefix))
#define StringPrefixW(string,prefix)                    StringMatchCharCountW(string,prefix,CharCountW(prefix))

#define StringIPrefixA(string,prefix)                   StringIMatchCharCountA(string,prefix,CharCountA(prefix))
#define StringIPrefixW(string,prefix)                   StringIMatchCharCountW(string,prefix,CharCountW(prefix))


INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

BOOL
StringMatchABA (
    IN      PCSTR String1,
    IN      PCSTR Start,
    IN      PCSTR End
    );

#define StringMatchABW(String,Start,End)                (StringCompareABW(String,Start,End)==0)


// stricmp that takes an end pointer instead of a length
INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

#define StringIMatchABA(String,Start,End)               (StringICompareABA(String,Start,End)==0)
#define StringIMatchABW(String,Start,End)               (StringICompareABW(String,Start,End)==0)



//
// String copy routines -- they return the END of the string
//

PSTR
StringCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

PWSTR
StringCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );

PSTR
StringCopyByteCountA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

PWSTR
StringCopyByteCountW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

PSTR
StringCopyByteCountABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

PWSTR
StringCopyByteCountABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

#define StringCopyCharCountA(str1,str2,chars)           StringCopyByteCountA(str1,str2,CharCountToBytesA(str2,chars))
#define StringCopyCharCountW(str1,str2,chars)           StringCopyByteCountW(str1,str2,CharCountToBytesW(str2,chars))

#define StringCopyTcharCountA(str1,str2,tchars)         StringCopyByteCountA(str1,str2,(tchars) * sizeof (CHAR))
#define StringCopyTcharCountW(str1,str2,tchars)         StringCopyByteCountW(str1,str2,(tchars) * sizeof (WCHAR))

#define StringCopyABA(dest,stra,strb)                   StringCopyByteCountA((dest),(stra),((UINT)((UBINT)(strb)-(UBINT)(stra))+(UINT)SIZEOF(CHAR)))
#define StringCopyABW(dest,stra,strb)                   StringCopyByteCountW((dest),(stra),((UINT)((UBINT)(strb)-(UBINT)(stra))+(UINT)SIZEOF(WCHAR)))

//
// String cat routines
//

PSTR
StringCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

PWSTR
StringCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );


//
// Character search routines
//

#define GetEndOfStringA(s)      strchr(s,0)
#define GetEndOfStringW(s)      wcschr(s,0)

__inline
UINT
SizeOfMultiSzA (
    PCSTR MultiSz
    )
{
    PCSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringA (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((UBINT) MultiSz - (UBINT) Base);
}


__inline
UINT
SizeOfMultiSzW (
    PCWSTR MultiSz
    )
{
    PCWSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringW (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((UBINT) MultiSz - (UBINT) Base);
}


__inline
UINT
MultiSzSizeInCharsA (
    PCSTR MultiSz
    )
{
    UINT Chars = 0;

    while (*MultiSz) {

        do {
            Chars++;
            MultiSz = _mbsinc (MultiSz);
        } while (*MultiSz);

        Chars++;
        MultiSz++;
    }

    Chars++;

    return Chars;
}


#define MultiSzSizeInCharsW(msz)  (SizeOfMultiSzW(msz)/SIZEOF(WCHAR))

PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    );

PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    );

//
// Pool allocation routines
//

PSTR
RealAllocTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      UINT ByteSize
    );

PWSTR
RealAllocTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      UINT WcharSize
    );

#define AllocTextExA(p,s)   TRACK_BEGIN(PSTR, AllocTextExA)\
                            RealAllocTextExA(p,(UINT)(s))\
                            TRACK_END()

#define AllocTextExW(p,s)   TRACK_BEGIN(PWSTR, AllocTextExW)\
                            RealAllocTextExW(p,(UINT)(s))\
                            TRACK_END()

#define AllocTextA(s)       AllocTextExA(NULL,(UINT)(s))
#define AllocTextW(s)       AllocTextExW(NULL,(UINT)(s))



VOID
FreeTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Text          OPTIONAL
    );

VOID
FreeTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    );

#define FreeTextA(t)    FreeTextExA(NULL,t)
#define FreeTextW(t)    FreeTextExW(NULL,t)

PSTR
RealDuplicateTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    );

PWSTR
RealDuplicateTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    );

#define DuplicateTextExA(p,t,c,n)   TRACK_BEGIN(PSTR, DuplicateTextExA)\
                                    RealDuplicateTextExA(p,t,c,n)\
                                    TRACK_END()

#define DuplicateTextExW(p,t,c,n)   TRACK_BEGIN(PWSTR, DuplicateTextExW)\
                                    RealDuplicateTextExW(p,t,c,n)\
                                    TRACK_END()

#define DuplicateTextA(text) DuplicateTextExA(NULL,text,0,NULL)
#define DuplicateTextW(text) DuplicateTextExW(NULL,text,0,NULL)

PSTR
RealJoinTextExA (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR DelimeterString,  OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    );

PWSTR
RealJoinTextExW (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    );

#define JoinTextExA(p,s1,s2,cs,ec,nc)   TRACK_BEGIN(PSTR, JoinTextExA)\
                                        RealJoinTextExA(p,s1,s2,cs,ec,nc)\
                                        TRACK_END()

#define JoinTextExW(p,s1,s2,cs,ec,nc)   TRACK_BEGIN(PWSTR, JoinTextExW)\
                                        RealJoinTextExW(p,s1,s2,cs,ec,nc)\
                                        TRACK_END()

#define JoinTextA(str1,str2) JoinTextExA(NULL,str1,str2,NULL,0,NULL)
#define JoinTextW(str1,str2) JoinTextExW(NULL,str1,str2,NULL,0,NULL)


PSTR
RealExpandEnvironmentTextExA (
    IN PCSTR   InString,
    IN PCSTR * ExtraEnvironmentVariables OPTIONAL
    );

PWSTR
RealExpandEnvironmentTextExW (
    IN PCWSTR   InString,
    IN PCWSTR * ExtraEnvironmentVariables OPTIONAL
    );

#define ExpandEnvironmentTextExA(str,ev)    TRACK_BEGIN(PSTR, ExpandEnvironmentTextExA)\
                                            RealExpandEnvironmentTextExA(str,ev)\
                                            TRACK_END()

#define ExpandEnvironmentTextExW(str,ev)    TRACK_BEGIN(PWSTR, ExpandEnvironmentTextExW)\
                                            RealExpandEnvironmentTextExW(str,ev)\
                                            TRACK_END()

#define ExpandEnvironmentTextA(string) ExpandEnvironmentTextExA(string,NULL)
#define ExpandEnvironmentTextW(string) ExpandEnvironmentTextExW(string,NULL)

//
// Command line routines
//

// Converts ANSI command line to array of args
PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     PUINT NumArgs
    );


//
// Need both MBCS and UNICODE versions
//

// an atoi that supports decimal or hex
DWORD   _mbsnum (IN PCSTR szNum);
DWORD   _wcsnum (IN PCWSTR szNum);

// determines if an entire string is printable chars
int     _mbsisprint (PCSTR szStr);
int     _wcsisprint (PCWSTR szStr);

// case-insensitive strstr
PCSTR  _mbsistr (PCSTR szStr, PCSTR szSubStr);
PCWSTR _wcsistr (PCWSTR szStr, PCWSTR szSubStr);

// copies the first character of str2 to str
void    _copymbchar (PSTR str1, PCSTR str2);
#define _copywchar(dest,src)    (*(dest)=*(src))

// replaces a character in a multi-byte char string and maintains
// the string integrity (may grow string by one byte)
void    _setmbchar  (PSTR str, MBCHAR c);
#define _setwchar(str,c)        (*(str)=(c))

// removes specified character from the end of a string, if it exists
BOOL    _mbsctrim (PSTR str, MBCHAR c);
BOOL    _wcsctrim (PWSTR str, WCHAR c);

// Always adds a backslash, returns ptr to nul terminator
PSTR    AppendWackA (IN PSTR str);
PWSTR   AppendWackW (IN PWSTR str);

// Adds a backslash to the end of a DOS path (unless str is empty
// or is only a drive letter)
PSTR    AppendDosWackA (IN PSTR str);
PWSTR   AppendDosWackW (IN PWSTR str);

// Adds a backslash unless str is empty
PSTR    AppendUncWackA (IN PSTR str);
PWSTR   AppendUncWackW (IN PWSTR str);

// Adds a backslash and identifies the correct naming convention (DOS,
// or UNC)
PSTR    AppendPathWackA (IN PSTR str);
PWSTR   AppendPathWackW (IN PWSTR str);

//
// Joins any number of paths together, allocates string in g_PathsPool if not otherwise specified
// this version checks for wacks at the begin/end of each segment so they are properly joined
//
PSTR
_cdecl
RealJoinPathsInPoolExA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

PWSTR
_cdecl
RealJoinPathsInPoolExW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

#define JoinPathsInPoolExA(x)   TRACK_BEGIN(PSTR, JoinPathsInPoolExA)\
                                RealJoinPathsInPoolExA x\
                                TRACK_END()

#define JoinPathsInPoolExW(x)   TRACK_BEGIN(PWSTR, JoinPathsInPoolExW)\
                                RealJoinPathsInPoolExW x\
                                TRACK_END()

//
// for backwards compatibility, JoinPaths expands to JoinPathsInPoolEx
// and NOT to JoinPathsEx which uses a growbuffer instead
//
#define JoinPathsA(p1,p2)               JoinPathsInPoolExA((NULL,p1,p2,NULL))
#define JoinPathsW(p1,p2)               JoinPathsInPoolExW((NULL,p1,p2,NULL))


BOOL
_cdecl
JoinPathsExA (
    IN OUT      PGROWBUFFER Gb,
    ...
    );

BOOL
_cdecl
JoinPathsExW (
    IN OUT      PGROWBUFFER Gb,
    ...
    );

//
// Joins any number of paths together, allocates string in g_PathsPool if not otherwise specified
// this version does NOT check for wacks at the begin/end of each segment
//
PSTR
_cdecl
RealBuildPathInPoolA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

PWSTR
_cdecl
RealBuildPathInPoolW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

#define BuildPathInPoolA(x)   TRACK_BEGIN(PSTR, BuildPathInPoolA)\
                              RealBuildPathInPoolA x\
                              TRACK_END()

#define BuildPathInPoolW(x)   TRACK_BEGIN(PWSTR, BuildPathInPoolW)\
                              RealBuildPathInPoolW x\
                              TRACK_END()


DWORD
_cdecl
BuildPathA (
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    );

DWORD
_cdecl
BuildPathW (
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    );

BOOL
_cdecl
BuildPathExA (
    IN OUT  PGROWBUFFER Gb,
    ...
    );

BOOL
_cdecl
BuildPathExW (
    IN OUT  PGROWBUFFER Gb,
    ...
    );


// Routine to allocate a 1K buffer for path manipulation, allocated in g_PathsPool
PSTR    RealAllocPathStringA (IN DWORD Tchars);
PWSTR   RealAllocPathStringW (IN DWORD Tchars);
#define DEFSIZE 0

#define AllocPathStringA(chars)     TRACK_BEGIN(PSTR, AllocPathStringA)\
                                    RealAllocPathStringA(chars)\
                                    TRACK_END()

#define AllocPathStringW(chars)     TRACK_BEGIN(PWSTR, AllocPathStringW)\
                                    RealAllocPathStringW(chars)\
                                    TRACK_END()

// Routine to divide path into separate strings, each allocated in g_PathsPool
VOID    RealSplitPathA (IN PCSTR Path, OUT PSTR *Drive, OUT PSTR *Dir, OUT PSTR *File, OUT PSTR *Ext);
VOID    RealSplitPathW (IN PCWSTR Path, OUT PWSTR *Drive, OUT PWSTR *Dir, OUT PWSTR *File, OUT PWSTR *Ext);

#define SplitPathA(path,dv,dir,f,e) TRACK_BEGIN_VOID (VOID, SplitPathA)\
                                    RealSplitPathA(path,dv,dir,f,e)\
                                    TRACK_END()

#define SplitPathW(path,dv,dir,f,e) TRACK_BEGIN_VOID (VOID, SplitPathW)\
                                    RealSplitPathW(path,dv,dir,f,e)\
                                    TRACK_END()

// Routine to extract the file from a path
PCSTR  GetFileNameFromPathA (IN PCSTR Path);
PCWSTR GetFileNameFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path
PCSTR  GetFileExtensionFromPathA (IN PCSTR Path);
PCWSTR GetFileExtensionFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path, including the dot, or the
// end of the string if no extension exists
PCSTR  GetDotExtensionFromPathA (IN PCSTR Path);
PCWSTR GetDotExtensionFromPathW (IN PCWSTR Path);

// Routine to duplicate a path and allocate space for cat processing
PSTR    RealDuplicatePathStringA (IN PCSTR Path, IN DWORD ExtraBytes);
PWSTR   RealDuplicatePathStringW (IN PCWSTR Path, IN DWORD ExtraBytes);

#define DuplicatePathStringA(path,eb)   TRACK_BEGIN(PSTR, DuplicatePathStringA)\
                                        RealDuplicatePathStringA(path,eb)\
                                        TRACK_END()

#define DuplicatePathStringW(path,eb)   TRACK_BEGIN(PWSTR, DuplicatePathStringW)\
                                        RealDuplicatePathStringW(path,eb)\
                                        TRACK_END()

// Routines to enumerate the PATH variable
typedef struct _PATH_ENUMA {
    PSTR  BufferPtr;
    PSTR  PtrNextPath;
    PSTR  PtrCurrPath;
} PATH_ENUMA, *PPATH_ENUMA;

BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    );

#define EnumFirstPathA(e,a,w,s) EnumFirstPathExA(e,a,w,s,TRUE)

BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    );

BOOL
AbortPathEnumA (
    IN OUT  PPATH_ENUMA PathEnum
    );


typedef struct _PATH_ENUMW {
    PWSTR  BufferPtr;
    PWSTR  PtrNextPath;
    PWSTR  PtrCurrPath;
} PATH_ENUMW, *PPATH_ENUMW;

BOOL
EnumFirstPathExW (
    OUT     PPATH_ENUMW PathEnum,
    IN      PCWSTR AdditionalPath,
    IN      PCWSTR WinDir,
    IN      PCWSTR SysDir,
    IN      BOOL IncludeEnvPath
    );

#define EnumFirstPathW(e,a,w,s) EnumFirstPathExW(e,a,w,s,TRUE)

BOOL
EnumNextPathW (
    IN OUT  PPATH_ENUMW PathEnum
    );

BOOL
AbortPathEnumW (
    IN OUT  PPATH_ENUMW PathEnum
    );



// Frees a string allocated in g_PathsPool
VOID
FreePathStringExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Path          OPTIONAL
    );

VOID
FreePathStringExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    );

#define FreePathStringA(p) FreePathStringExA(NULL,p)
#define FreePathStringW(p) FreePathStringExW(NULL,p)

// Removes a trailing backslash, if it exists
#define RemoveWackAtEndA(str)  _mbsctrim(str,'\\')
#define RemoveWackAtEndW(str)  _wcsctrim(str,L'\\')

PCSTR
FindLastWackA (
    IN      PCSTR Str
    );

PCWSTR
FindLastWackW (
    IN      PCWSTR Str
    );

BOOL
GetNodePatternMinMaxLevelsA (
    IN          PCSTR NodePattern,
    OUT         PSTR FormattedNode,     OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    );

BOOL
GetNodePatternMinMaxLevelsW (
    IN          PCWSTR NodePattern,
    OUT         PWSTR FormattedNode,    OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    );


// Rule encoding functions used to encode a number of syntax-related
// characters (backslash, brackets, asterisk, etc)
PSTR
EncodeRuleCharsExA (
    PSTR szEncRule,
    PCSTR szRule,
    PCSTR szEncChars    OPTIONAL
    );
#define EncodeRuleCharsA(e,r) EncodeRuleCharsExA(e,r,NULL)

PWSTR
EncodeRuleCharsExW (
    PWSTR szEncRule,
    PCWSTR szRule,
    PCWSTR szEncChars    OPTIONAL
    );
#define EncodeRuleCharsW(e,r) EncodeRuleCharsExW(e,r,NULL)

// Rule decoding functions used to restore an encoded string
MBCHAR  GetNextRuleCharA (PCSTR *p_szRule, BOOL *p_bFromHex);
WCHAR   GetNextRuleCharW (PCWSTR *p_szRule, BOOL *p_bFromHex);
PSTR   DecodeRuleCharsA (PSTR szRule, PCSTR szEncRule);
PWSTR  DecodeRuleCharsW (PWSTR szRule, PCWSTR szEncRule);
PSTR   DecodeRuleCharsABA (PSTR szRule, PCSTR szEncRuleStart, PCSTR End);
PWSTR  DecodeRuleCharsABW (PWSTR szRule, PCWSTR szEncRuleStart, PCWSTR End);

// Returns a pointer to the next non-space character (uses isspace)
PCSTR  SkipSpaceA (PCSTR szStr);
PCWSTR SkipSpaceW (PCWSTR szStr);

// Returns a pointer to the first space character at the end of a string,
// or a pointer to the terminating nul if no space exists at the end of the
// string.  (Used for trimming space.)
PCSTR  SkipSpaceRA (PCSTR szBaseStr, PCSTR szStr);
PCWSTR SkipSpaceRW (PCWSTR szBaseStr, PCWSTR szStr);

// Truncates a string after the last non-whitepace character
VOID TruncateTrailingSpaceA (IN OUT  PSTR Str);
VOID TruncateTrailingSpaceW (IN OUT  PWSTR Str);


// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchA (PCSTR wstrPattern, PCSTR wstrStr);
BOOL IsPatternMatchW (PCWSTR wstrPattern, PCWSTR wstrStr);

// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchABA (PCSTR Pattern, PCSTR Start, PCSTR End);
BOOL IsPatternMatchABW (PCWSTR Pattern, PCWSTR Start, PCWSTR End);

BOOL IsPatternContainedA (PCSTR Container, PCSTR Contained);
BOOL IsPatternContainedW (PCWSTR Container, PCWSTR Contained);


//
// More powerful pattern matching
//

#define SEGMENTTYPE_UNKNOWN         0
#define SEGMENTTYPE_EXACTMATCH      1
#define SEGMENTTYPE_OPTIONAL        2
#define SEGMENTTYPE_REQUIRED        3

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // optional
        struct {
            UINT MaxLen;                // zero if any length
            PCSTR IncludeSet;           OPTIONAL
            PCSTR ExcludeSet;           OPTIONAL
        } Wildcard;
    };
} SEGMENTA, *PSEGMENTA;

typedef struct {
    UINT SegmentCount;
    PSEGMENTA Segment;
} PATTERNPROPSA, *PPATTERNPROPSA;

typedef struct TAG_PARSEDPATTERNA {
    UINT PatternCount;
    PMHANDLE Pool;
    BOOL ExternalPool;
    PPATTERNPROPSA Pattern;
} PARSEDPATTERNA, *PPARSEDPATTERNA;

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCWSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // wildcard
        struct {
            UINT MaxLen;                // zero if any length
            PCWSTR IncludeSet;          OPTIONAL
            PCWSTR ExcludeSet;          OPTIONAL
        } Wildcard;
    };
} SEGMENTW, *PSEGMENTW;

typedef struct {
    UINT SegmentCount;
    PSEGMENTW Segment;
} PATTERNPROPSW, *PPATTERNPROPSW;

typedef struct TAG_PARSEDPATTERNW {
    UINT PatternCount;
    PMHANDLE Pool;
    BOOL ExternalPool;
    PPATTERNPROPSW Pattern;
} PARSEDPATTERNW, *PPARSEDPATTERNW;


BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR String
    );

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR String
    );

BOOL
IsPatternMatchExABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    );

BOOL
IsPatternMatchExABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

PPARSEDPATTERNA
ExplodeParsedPatternExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PPARSEDPATTERNA Pattern
    );

#define ExplodeParsedPatternA(p) ExplodeParsedPatternExA(NULL,p)

PPARSEDPATTERNW
ExplodeParsedPatternExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PPARSEDPATTERNW Pattern
    );

#define ExplodeParsedPatternW(p) ExplodeParsedPatternExW(NULL,p)

BOOL
IsPatternContainedExA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    );

BOOL
IsPatternContainedExW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    );

BOOL
IsParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    );

BOOL
IsParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    );

BOOL
IsExplodedParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained,
    IN      BOOL SkipDotWithStar
    );

BOOL
IsExplodedParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained,
    IN      BOOL SkipDotWithStar
    );

BOOL
DoExplodedParsedPatternsIntersectExA (
    IN      PPARSEDPATTERNA Pat1,
    IN      PPARSEDPATTERNA Pat2,
    IN      BOOL IgnoreWackAtEnd
    );
#define DoExplodedParsedPatternsIntersectA(P1,P2) DoExplodedParsedPatternsIntersectExA(P1,P2,FALSE)

BOOL
DoExplodedParsedPatternsIntersectExW (
    IN      PPARSEDPATTERNW Pat1,
    IN      PPARSEDPATTERNW Pat2,
    IN      BOOL IgnoreWackAtEnd
    );
#define DoExplodedParsedPatternsIntersectW(P1,P2) DoExplodedParsedPatternsIntersectExW(P1,P2,FALSE)

PCSTR
GetPatternBaseExA (
    IN      PCSTR Pattern,
    IN      BOOL NodePattern
    );
#define GetPatternBaseA(p) GetPatternBaseExA(p,TRUE)

PCWSTR
GetPatternBaseExW (
    IN      PCWSTR Pattern,
    IN      BOOL NodePattern
    );
#define GetPatternBaseW(p) GetPatternBaseExW(p,TRUE)

PPARSEDPATTERNA
RealCreateParsedPatternExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Pattern
    );

#define CreateParsedPatternExA(o,p) TRACK_BEGIN(PPARSEDPATTERNA, CreateParsedPatternExA)\
                                    RealCreateParsedPatternExA(o,p)\
                                    TRACK_END()

#define CreateParsedPatternA(p)     CreateParsedPatternExA(NULL,p)

PPARSEDPATTERNW
RealCreateParsedPatternExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Pattern
    );

#define CreateParsedPatternExW(o,p) TRACK_BEGIN(PPARSEDPATTERNW, CreateParsedPatternExW)\
                                    RealCreateParsedPatternExW(o,p)\
                                    TRACK_END()

#define CreateParsedPatternW(p)     CreateParsedPatternExW(NULL,p)

BOOL
WildCharsPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

BOOL
WildCharsPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    );

BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    );

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    );

BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    );

VOID
PrintPattern (
    PCSTR Pattern,
    PPARSEDPATTERNA Struct
    );

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

VOID
DecodeParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DecodeParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

BOOL
PatternIncludesPatternA (
    IN      PPARSEDPATTERNA IncludingPattern,
    IN      PPARSEDPATTERNA IncludedPattern
    );

BOOL
PatternIncludesPatternW (
    IN      PPARSEDPATTERNW IncludingPattern,
    IN      PPARSEDPATTERNW IncludedPattern
    );

VOID
GetParsedPatternMinMaxSizeA (
    IN      PPARSEDPATTERNA ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    );

VOID
GetParsedPatternMinMaxSizeW (
    IN      PPARSEDPATTERNW ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    );

__inline
BOOL
ParsedPatternIsExactMatchA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternIsExactMatchW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternSegmentIsPureOptionalA (
    IN      PSEGMENTA ParsedPatternSegment
    )
{
    return ParsedPatternSegment->Type == SEGMENTTYPE_OPTIONAL &&
           ParsedPatternSegment->Wildcard.MaxLen == 0 &&
           ParsedPatternSegment->Wildcard.IncludeSet == NULL &&
           ParsedPatternSegment->Wildcard.ExcludeSet == NULL;
}

__inline
BOOL
ParsedPatternSegmentIsPureOptionalW (
    IN      PSEGMENTW ParsedPatternSegment
    )
{
    return ParsedPatternSegment->Type == SEGMENTTYPE_OPTIONAL &&
           ParsedPatternSegment->Wildcard.MaxLen == 0 &&
           ParsedPatternSegment->Wildcard.IncludeSet == NULL &&
           ParsedPatternSegment->Wildcard.ExcludeSet == NULL;
}

__inline
BOOL
ParsedPatternIsOptionalA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPatternSegmentIsPureOptionalA (ParsedPattern->Pattern->Segment);
}

__inline
BOOL
ParsedPatternIsOptionalW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPatternSegmentIsPureOptionalW (ParsedPattern->Pattern->Segment);
}

__inline
BOOL
ParsedPatternIsRootPlusStarA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 2 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH &&
           ParsedPatternSegmentIsPureOptionalA (ParsedPattern->Pattern->Segment + 1);
}

__inline
BOOL
ParsedPatternIsRootPlusStarW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 2 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH &&
           ParsedPatternSegmentIsPureOptionalW (ParsedPattern->Pattern->Segment + 1);
}

__inline
BOOL
ParsedPatternHasRootA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount > 0 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternHasRootW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount > 0 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
PCSTR
ParsedPatternGetRootA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (!ParsedPatternHasRootA (ParsedPattern)) {
        return NULL;
    }
    return ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase;
}

__inline
PCWSTR
ParsedPatternGetRootW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (!ParsedPatternHasRootW (ParsedPattern)) {
        return NULL;
    }
    return ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase;
}

__inline
BOOL
ParsedPatternEndsWithStarA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPatternSegmentIsPureOptionalA (
                ParsedPattern->Pattern->Segment + ParsedPattern->Pattern->SegmentCount - 1
                );
}

__inline
BOOL
ParsedPatternEndsWithStarW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPatternSegmentIsPureOptionalW (
                ParsedPattern->Pattern->Segment + ParsedPattern->Pattern->SegmentCount - 1
                );
}

BOOL
ParsedPatternTrimLastCharA (
    IN OUT  PPARSEDPATTERNA ParsedPattern
    );

BOOL
ParsedPatternTrimLastCharW (
    IN OUT  PPARSEDPATTERNW ParsedPattern
    );


// Character counters
UINT CountInstancesOfCharA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharW (PCWSTR String, WCHAR Char);

UINT CountInstancesOfCharIA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharIW (PCWSTR String, WCHAR Char);


//
// Message Functions
//
// An AllocTable is an array of HLOCAL pointers that the message routines
// return.  This table is maintained to allow a single function to clean up
// all strings at once.
//
// All "Ex" functions (ParseMessageEx, GetStringResourceEx, and so on)
// require a valid AllocTable pointer.  A caller obtains this pointer by
// calling CreateAllocTable before processing any message.  The caller
// cleans up the entire table by calling DestroyAllocTable.
//
// A set of macros can be used for short-term strings.  ParseMessage and
// GetStringResource work the same as their Ex counterparts, but operate
// on the process-wide g_ShortTermAllocTable.  Short-term strings are
// freed with FreeStringResource.
//
// A routine that calls ParseMessage and/or GetStringResource several times
// in the same function wrap the calls between BeginMessageProcessing and
// EndMessageProcessing.  Only one thread in the process can do this at a
// time, and when EndMessageProcessing is called, all strings allocated
// by ParseMessage or GetResourceString in the processing section are
// automatically freed.
//

// AllocTable creation/deletion
PGROWBUFFER RealCreateAllocTable (VOID);

#define CreateAllocTable()      TRACK_BEGIN(PGROWBUFFER, CreateAllocTable)\
                                RealCreateAllocTable()\
                                TRACK_END()


VOID DestroyAllocTable (PGROWBUFFER AllocTable);

// The "Ex" functions
// ParseMessageEx retrieves the string resource via FormatMessage
PCSTR ParseMessageExA (PGROWBUFFER AllocTable, PCSTR Template, PCSTR ArgArray[]);
PCWSTR ParseMessageExW (PGROWBUFFER AllocTable, PCWSTR Template, PCWSTR ArgArray[]);

// GetStringResourceEx retrives an argument-less string resource
PCSTR GetStringResourceExA (PGROWBUFFER AllocTable, UINT ID);
PCWSTR GetStringResourceExW (PGROWBUFFER AllocTable, UINT ID);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros
VOID FreeStringResourceExA (PGROWBUFFER AllocTable, PCSTR String);
VOID FreeStringResourceExW (PGROWBUFFER AllocTable, PCWSTR String);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros.
// Tests String first; nulls when freed.
VOID FreeStringResourcePtrExA (PGROWBUFFER AllocTable, PCSTR * String);
VOID FreeStringResourcePtrExW (PGROWBUFFER AllocTable, PCWSTR * String);

// Macros
extern PGROWBUFFER g_ShortTermAllocTable;
#define ParseMessageA(strid,args) ParseMessageExA(g_ShortTermAllocTable, strid, args)
#define ParseMessageW(strid,args) ParseMessageExW(g_ShortTermAllocTable, strid, args)
#define ParseMessageIDA(id,args) ParseMessageExA(g_ShortTermAllocTable, (PCSTR) (id), args)
#define ParseMessageIDW(id,args) ParseMessageExW(g_ShortTermAllocTable, (PCWSTR) (id), args)
#define ParseMessageIDExA(table,id,args) ParseMessageExA(table, (PCSTR) (id), args)
#define ParseMessageIDExW(table,id,args) ParseMessageExW(table, (PCWSTR) (id), args)
#define GetStringResourceA(id) GetStringResourceExA(g_ShortTermAllocTable, id)
#define GetStringResourceW(id) GetStringResourceExW(g_ShortTermAllocTable, id)
#define FreeStringResourceA(str) FreeStringResourceExA(g_ShortTermAllocTable, str)
#define FreeStringResourceW(str) FreeStringResourceExW(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrA(str) FreeStringResourcePtrExA(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrW(str) FreeStringResourcePtrExW(g_ShortTermAllocTable, str)

// Functions for single-threaded message-intensive processing loops
BOOL BeginMessageProcessing (VOID);
VOID EndMessageProcessing (VOID);


//
// The following message functions do not return strings, so they do not
// need cleanup.
//

// An odd variant--obtains message ID from a window's text and replaces
// it with the actual message.  Useful in dialog box initialization.
VOID ParseMessageInWndA (HWND hwnd, PCSTR ArgArray[]);
VOID ParseMessageInWndW (HWND hwnd, PCWSTR ArgArray[]);

// Displays a message box using a message string
INT ResourceMessageBoxA (HWND hwndOwner, UINT ID, UINT Flags, PCSTR ArgArray[]);
INT ResourceMessageBoxW (HWND hwndOwner, UINT ID, UINT Flags, PCWSTR ArgArray[]);


//
// Functions that don't care about UNICODE or MBCS
// and realy shouldn't be in strings.h/.c
//

// Pushes dwError on a global error stack
void    PushNewError (DWORD dwError);

// Pushes the return of GetLastError() on a global error stack
void    PushError (void);

// Pops the last error from the global error stack, calls SetLastError
// and returns the popped error code.
DWORD   PopError (void);

// Returns an int value for chars 0-9, a-f, A-F, and -1 for all others
int     GetHexDigit (IN  int c);


//
// Inline functions
//

// Returns the character at str[pos]
__inline MBCHAR _mbsgetc(PCSTR str, DWORD pos) {
    return (MBCHAR) _mbsnextc(CharCountToPointerA ((PSTR) str, pos));
}

__inline WCHAR _wcsgetc(PCWSTR str, DWORD pos) {
    return *CharCountToPointerW ((PWSTR) str, pos);
}

// Sets the character at str[pos]
// Multibyte version may grow string by one byte.
__inline void _mbssetc(PSTR str, DWORD pos, MBCHAR c) {
    _setmbchar (CharCountToPointerA (str, pos), c);
}

__inline void _wcssetc(PWSTR str, DWORD pos, WCHAR c) {
    *CharCountToPointerW (str, pos) = c;
}

// Bug fix for C Runtime _tcsdec
__inline PWSTR _wcsdec2(PCWSTR base, PCWSTR p) {
    if (base >= p) {
        return NULL;
    }
    return (PWSTR) (p-1);
}

// Bug fix for C Runtime _tcsdec
__inline PSTR _mbsdec2(PCSTR base, PCSTR p) {
    if (base >= p) {
        return NULL;
    }
    return _mbsdec(base,p);
}


//
// Sub String Replacement functions.
//
BOOL StringReplaceW (PWSTR Buffer,DWORD MaxSize,PWSTR ReplaceStartPos,PWSTR ReplaceEndPos,PCWSTR NewString);
BOOL StringReplaceA (PSTR Buffer,DWORD MaxSize,PSTR ReplaceStartPos,PSTR ReplaceEndPos,PCSTR NewString);

//
// String table population from INF section
//

typedef enum {
    CALLBACK_CONTINUE,
    CALLBACK_SKIP,
    CALLBACK_STOP
} CALLBACK_RESULT;

typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEA)(PCSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEW)(PCWSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef ADDINFSECTION_PROTOTYPEA * ADDINFSECTION_PROCA;
typedef ADDINFSECTION_PROTOTYPEW * ADDINFSECTION_PROCW;

BOOL AddInfSectionToHashTableA (PVOID, HINF, PCSTR, DWORD, ADDINFSECTION_PROCA, PVOID);
BOOL AddInfSectionToHashTableW (PVOID, HINF, PCWSTR, DWORD, ADDINFSECTION_PROCW, PVOID);


UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    );

UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    );

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    );

PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    );

typedef struct _MULTISZ_ENUMA {
    PCSTR   Buffer;
    PCSTR   CurrentString;
} MULTISZ_ENUMA, *PMULTISZ_ENUMA;

typedef struct _MULTISZ_ENUMW {
    PCWSTR  Buffer;
    PCWSTR  CurrentString;
} MULTISZ_ENUMW, *PMULTISZ_ENUMW;

BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    );

BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    );

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    );

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    );

BOOL
IsStrInMultiSzA (
    IN      PCSTR String,
    IN      PCSTR MultiSz
    );

BOOL
IsStrInMultiSzW (
    IN      PCWSTR String,
    IN      PCWSTR MultiSz
    );

VOID
ToggleWacksW (
    IN OUT PWSTR String,
    IN BOOL Operation
    );

VOID
ToggleWacksA (
    IN OUT PSTR String,
    IN BOOL Operation
    );

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    );

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    );

PCSTR
ConvertSBtoDB (
    PCSTR RootPath,
    PCSTR FullPath,
    PCSTR Limit
    );

ULONGLONG
StringToUint64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

#define AToU64(str)     StringToUint64A(str,NULL)

ULONGLONG
StringToUint64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

#define WToU64(str)     StringToUint64W(str,NULL)

LONGLONG
StringToInt64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

#define AToI64(str)     StringToInt64A(str,NULL)

LONGLONG
StringToInt64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

#define WToI64(str)     StringToInt64W(str,NULL)

BOOL
TestBuffer (
    IN      PCBYTE SrcBuff,
    IN      PCBYTE DestBuff,
    IN      UINT Size
    );

PCSTR
IsValidUncPathA (
    IN      PCSTR Path
    );

BOOL
IsValidFileSpecA (
    IN      PCSTR FileSpec
    );

PCWSTR
IsValidUncPathW (
    IN      PCWSTR Path
    );

BOOL
IsValidFileSpecW (
    IN      PCWSTR FileSpec
    );

BOOL
IsEmptyStrA (
    IN      PCSTR String
    );

BOOL
IsEmptyStrW (
    IN      PCWSTR String
    );

//
// TCHAR mappings
//

#ifdef UNICODE

#define EscapedChars                EscapedCharsW
#define CharCount                   CharCountW
#define CharCountToPointer          CharCountToPointerW
#define CharCountAB                 CharCountABW
#define CharCountInByteRange        CharCountInByteRangeW
#define CharCountToBytes            CharCountToBytesW
#define CharCountToTchars           CharCountToTcharsW
#define ByteCount                   ByteCountW
#define SizeOfString                SizeOfStringW
#define SizeOfMultiSz               SizeOfMultiSzW
#define MultiSzSizeInChars          MultiSzSizeInCharsW
#define ByteCountToPointer          ByteCountToPointerW
#define ByteCountAB                 ByteCountABW
#define ByteCountToChars            ByteCountToCharsW
#define ByteCountToTchars           ByteCountToTcharsW
#define TcharCount                  TcharCountW
#define TcharCountToPointer         TcharCountToPointerW
#define TcharCountAB                TcharCountABW
#define TcharCountToChars           TcharCountToCharsW
#define TcharCountToBytes           TcharCountToBytesW
#define StackStringCopy             StackStringCopyW
#define StringCompare               StringCompareW
#define StringMatch                 StringMatchW
#define StringICompare              StringICompareW
#define StringIMatch                StringIMatchW
#define StringCompareByteCount      StringCompareByteCountW
#define StringMatchByteCount        StringMatchByteCountW
#define StringICompareByteCount     StringICompareByteCountW
#define StringIMatchByteCount       StringIMatchByteCountW
#define StringCompareCharCount      StringCompareCharCountW
#define StringMatchCharCount        StringMatchCharCountW
#define StringICompareCharCount     StringICompareCharCountW
#define StringIMatchCharCount       StringIMatchCharCountW
#define StringCompareTcharCount     StringCompareTcharCountW
#define StringMatchTcharCount       StringMatchTcharCountW
#define StringICompareTcharCount    StringICompareTcharCountW
#define StringIMatchTcharCount      StringIMatchTcharCountW
#define StringCompareAB             StringCompareABW
#define StringMatchAB               StringMatchABW
#define StringICompareAB            StringICompareABW
#define StringIMatchAB              StringIMatchABW
#define StringPrefix                StringPrefixW
#define StringIPrefix               StringIPrefixW
#define StringCopy                  StringCopyW
#define StringCopyByteCount         StringCopyByteCountW
#define StringCopyCharCount         StringCopyCharCountW
#define StringCopyTcharCount        StringCopyTcharCountW
#define StringCopyAB                StringCopyABW
#define StringCat                   StringCatW
#define GetEndOfString              GetEndOfStringW
#define GetPrevChar                 GetPrevCharW

#define AllocTextEx                 AllocTextExW
#define AllocText                   AllocTextW
#define FreeTextEx                  FreeTextExW
#define FreeText                    FreeTextW
#define DuplicateText               DuplicateTextW
#define DuplicateTextEx             DuplicateTextExW
#define JoinTextEx                  JoinTextExW
#define JoinText                    JoinTextW
#define ExpandEnvironmentText       ExpandEnvironmentTextW
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExW
#define CommandLineToArgv           CommandLineToArgvW

#define _tcsdec2                    _wcsdec2
#define _copytchar                  _copywchar
#define _settchar                   _setwchar
#define _tcsgetc                    _wcsgetc
#define _tcssetc                    _wcssetc
#define _tcsnum                     _wcsnum
#define _tcsappend                  _wcsappend
#define _tcsistr                    _wcsistr
#define _tcsisprint                 _wcsisprint
#define _tcsnzcpy                   _wcsnzcpy
#define _tcssafecpy                 _wcssafecpy
#define _tcsnzcpyab                 _wcsnzcpyab
#define _tcssafecpyab               _wcssafecpyab
#define _tcsctrim                   _wcsctrim

#define AppendWack                  AppendWackW
#define AppendDosWack               AppendDosWackW
#define AppendUncWack               AppendUncWackW
#define AppendPathWack              AppendPathWackW
#define RemoveWackAtEnd             RemoveWackAtEndW
#define JoinPaths                   JoinPathsW
#define JoinPathsInPoolEx           JoinPathsInPoolExW
#define JoinPathsEx                 JoinPathsExW
#define BuildPathInPool             BuildPathInPoolW
#define BuildPath                   BuildPathW
#define BuildPathEx                 BuildPathExW
#define AllocPathString             AllocPathStringW
#define SplitPath                   SplitPathW
#define GetFileNameFromPath         GetFileNameFromPathW
#define GetFileExtensionFromPath    GetFileExtensionFromPathW
#define GetDotExtensionFromPath     GetDotExtensionFromPathW
#define DuplicatePathString         DuplicatePathStringW

#define PATH_ENUM                   PATH_ENUMW
#define PPATH_ENUM                  PPATH_ENUMW
#define EnumFirstPathEx             EnumFirstPathExW
#define EnumFirstPath               EnumFirstPathW
#define EnumNextPath                EnumNextPathW
#define AbortPathEnum               AbortPathEnumW
#define FreePathStringEx            FreePathStringExW
#define FreePathString              FreePathStringW
#define FindLastWack                FindLastWackW
#define GetNodePatternMinMaxLevels  GetNodePatternMinMaxLevelsW

#define GetNextRuleChar             GetNextRuleCharW
#define DecodeRuleChars             DecodeRuleCharsW
#define DecodeRuleCharsAB           DecodeRuleCharsABW
#define EncodeRuleCharsEx           EncodeRuleCharsExW
#define EncodeRuleChars             EncodeRuleCharsW

#define SkipSpace                   SkipSpaceW
#define SkipSpaceR                  SkipSpaceRW
#define TruncateTrailingSpace       TruncateTrailingSpaceW
#define IsPatternMatch              IsPatternMatchW
#define IsPatternMatchAB            IsPatternMatchABW
#define IsPatternContained          IsPatternContainedW

#define PPARSEDPATTERN              PPARSEDPATTERNW
#define PARSEDPATTERN               PARSEDPATTERNW
#define GetPatternBaseEx            GetPatternBaseExW
#define GetPatternBase              GetPatternBaseW
#define CreateParsedPatternEx       CreateParsedPatternExW
#define CreateParsedPattern         CreateParsedPatternW
#define WildCharsPattern            WildCharsPatternW
#define IsPatternMatchEx            IsPatternMatchExW
#define IsPatternMatchExAB          IsPatternMatchExABW
#define ExplodeParsedPattern        ExplodeParsedPatternW
#define ExplodeParsedPatternEx      ExplodeParsedPatternExW
#define IsPatternContainedEx        IsPatternContainedExW
#define IsParsedPatternContainedEx  IsParsedPatternContainedExW
#define IsExplodedParsedPatternContainedEx  IsExplodedParsedPatternContainedExW
#define DoExplodedParsedPatternsIntersectEx DoExplodedParsedPatternsIntersectExW
#define DoExplodedParsedPatternsIntersect   DoExplodedParsedPatternsIntersectW
#define TestParsedPattern           TestParsedPatternW
#define TestParsedPatternAB         TestParsedPatternABW
#define DestroyParsedPattern        DestroyParsedPatternW
#define DestroyParsedPattern        DestroyParsedPatternW
#define DecodeParsedPattern         DecodeParsedPatternW
#define PatternIncludesPattern      PatternIncludesPatternW
#define GetParsedPatternMinMaxSize  GetParsedPatternMinMaxSizeW
#define ParsedPatternIsExactMatch   ParsedPatternIsExactMatchW
#define ParsedPatternIsOptional     ParsedPatternIsOptionalW
#define ParsedPatternIsRootPlusStar ParsedPatternIsRootPlusStarW
#define ParsedPatternHasRoot        ParsedPatternHasRootW
#define ParsedPatternGetRoot        ParsedPatternGetRootW
#define ParsedPatternSegmentIsPureOptional ParsedPatternSegmentIsPureOptionalW
#define ParsedPatternEndsWithStar   ParsedPatternEndsWithStarW
#define ParsedPatternTrimLastChar   ParsedPatternTrimLastCharW

#define CountInstancesOfChar        CountInstancesOfCharW
#define CountInstancesOfCharI       CountInstancesOfCharIW
#define StringReplace               StringReplaceW
#define CountInstancesOfSubString   CountInstancesOfSubStringW
#define StringSearchAndReplace      StringSearchAndReplaceW
#define MULTISZ_ENUM                MULTISZ_ENUMW
#define EnumFirstMultiSz            EnumFirstMultiSzW
#define EnumNextMultiSz             EnumNextMultiSzW
#define IsStrInMultiSz              IsStrInMultiSzW

#define ParseMessage                ParseMessageW
#define ParseMessageEx              ParseMessageExW
#define ParseMessageID              ParseMessageIDW
#define ParseMessageIDEx            ParseMessageIDExW
#define GetStringResource           GetStringResourceW
#define GetStringResourceEx         GetStringResourceExW
#define FreeStringResource          FreeStringResourceW
#define ParseMessageInWnd           ParseMessageInWndW
#define ResourceMessageBox          ResourceMessageBoxW

#define AddInfSectionToHashTable    AddInfSectionToHashTableW
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCW

#define ReplaceWacks(f)             ToggleWacksW(f,FALSE)
#define RestoreWacks(f)             ToggleWacksW(f,TRUE)

#define SanitizePath                SanitizePathW

#define StringToUint64              StringToUint64W
#define TToU64                      WToU64
#define StringToInt64               StringToInt64W
#define TToI64                      WToI64

#define IsValidUncPath              IsValidUncPathW
#define IsValidFileSpec             IsValidFileSpecW

#define IsEmptyStr                  IsEmptyStrW

#else

#define EscapedChars                EscapedCharsA
#define CharCount                   CharCountA
#define CharCountToPointer          CharCountToPointerA
#define CharCountAB                 CharCountABA
#define CharCountInByteRange        CharCountInByteRangeA
#define CharCountToBytes            CharCountToBytesA
#define CharCountToTchars           CharCountToTcharsA
#define ByteCount                   ByteCountA
#define SizeOfString                SizeOfStringA
#define SizeOfMultiSz               SizeOfMultiSzA
#define MultiSzSizeInChars          MultiSzSizeInCharsA
#define ByteCountToPointer          ByteCountToPointerA
#define ByteCountAB                 ByteCountABA
#define ByteCountToChars            ByteCountToCharsA
#define ByteCountToTchars           ByteCountToTcharsA
#define TcharCount                  TcharCountA
#define TcharCountToPointer         TcharCountToPointerA
#define TcharCountAB                TcharCountABA
#define TcharCountToChars           TcharCountToCharsA
#define TcharCountToBytes           TcharCountToBytesA
#define StackStringCopy             StackStringCopyA
#define StringCompare               StringCompareA
#define StringMatch                 StringMatchA
#define StringICompare              StringICompareA
#define StringIMatch                StringIMatchA
#define StringCompareByteCount      StringCompareByteCountA
#define StringMatchByteCount        StringMatchByteCountA
#define StringICompareByteCount     StringICompareByteCountA
#define StringIMatchByteCount       StringIMatchByteCountA
#define StringCompareCharCount      StringCompareCharCountA
#define StringMatchCharCount        StringMatchCharCountA
#define StringICompareCharCount     StringICompareCharCountA
#define StringIMatchCharCount       StringIMatchCharCountA
#define StringCompareTcharCount     StringCompareTcharCountA
#define StringMatchTcharCount       StringMatchTcharCountA
#define StringICompareTcharCount    StringICompareTcharCountA
#define StringIMatchTcharCount      StringIMatchTcharCountA
#define StringCompareAB             StringCompareABA
#define StringMatchAB               StringMatchABA
#define StringICompareAB            StringICompareABA
#define StringIMatchAB              StringIMatchABA
#define StringPrefix                StringPrefixA
#define StringIPrefix               StringIPrefixA

#define StringCopy                  StringCopyA
#define StringCopyByteCount         StringCopyByteCountA
#define StringCopyCharCount         StringCopyCharCountA
#define StringCopyTcharCount        StringCopyTcharCountA
#define StringCopyAB                StringCopyABA
#define StringCat                   StringCatA
#define GetEndOfString              GetEndOfStringA
#define GetPrevChar                 GetPrevCharA

#define AllocTextEx                 AllocTextExA
#define AllocText                   AllocTextA
#define FreeTextEx                  FreeTextExA
#define FreeText                    FreeTextA
#define DuplicateText               DuplicateTextA
#define DuplicateTextEx             DuplicateTextExA
#define JoinTextEx                  JoinTextExA
#define JoinText                    JoinTextA
#define ExpandEnvironmentText       ExpandEnvironmentTextA
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExA
#define CommandLineToArgv           CommandLineToArgvA

#define _tcsdec2                    _mbsdec2
#define _copytchar                  _copymbchar
#define _settchar                   _setmbchar
#define _tcsgetc                    _mbsgetc
#define _tcssetc                    _mbssetc
#define _tcsnum                     _mbsnum
#define _tcsappend                  _mbsappend
#define _tcsistr                    _mbsistr
#define _tcsisprint                 _mbsisprint
#define _tcsnzcpy                   _mbsnzcpy
#define _tcssafecpy                 _mbssafecpy
#define _tcsnzcpyab                 _mbsnzcpyab
#define _tcssafecpyab               _mbssafecpyab
#define _tcsctrim                   _mbsctrim

#define AppendWack                  AppendWackA
#define AppendDosWack               AppendDosWackA
#define AppendUncWack               AppendUncWackA
#define AppendPathWack              AppendPathWackA
#define RemoveWackAtEnd             RemoveWackAtEndA
#define JoinPaths                   JoinPathsA
#define JoinPathsInPoolEx           JoinPathsInPoolExA
#define JoinPathsEx                 JoinPathsExA
#define BuildPathInPool             BuildPathInPoolA
#define BuildPath                   BuildPathA
#define BuildPathEx                 BuildPathExA
#define AllocPathString             AllocPathStringA
#define SplitPath                   SplitPathA
#define GetFileNameFromPath         GetFileNameFromPathA
#define GetFileExtensionFromPath    GetFileExtensionFromPathA
#define GetDotExtensionFromPath     GetDotExtensionFromPathA
#define DuplicatePathString         DuplicatePathStringA
#define FindLastWack                FindLastWackA
#define GetNodePatternMinMaxLevels  GetNodePatternMinMaxLevelsA

#define PATH_ENUM                   PATH_ENUMA
#define PPATH_ENUM                  PPATH_ENUMA
#define EnumFirstPathEx             EnumFirstPathExA
#define EnumFirstPath               EnumFirstPathA
#define EnumNextPath                EnumNextPathA
#define AbortPathEnum               AbortPathEnumA
#define FreePathStringEx            FreePathStringExA
#define FreePathString              FreePathStringA

#define GetNextRuleChar             GetNextRuleCharA
#define DecodeRuleChars             DecodeRuleCharsA
#define DecodeRuleCharsAB           DecodeRuleCharsABA
#define EncodeRuleCharsEx           EncodeRuleCharsExA
#define EncodeRuleChars             EncodeRuleCharsA

#define SkipSpace                   SkipSpaceA
#define SkipSpaceR                  SkipSpaceRA
#define TruncateTrailingSpace       TruncateTrailingSpaceA
#define IsPatternMatch              IsPatternMatchA
#define IsPatternMatchAB            IsPatternMatchABA
#define IsPatternContained          IsPatternContainedA

#define PPARSEDPATTERN              PPARSEDPATTERNA
#define PARSEDPATTERN               PARSEDPATTERNA
#define GetPatternBaseEx            GetPatternBaseExA
#define GetPatternBase              GetPatternBaseA
#define CreateParsedPatternEx       CreateParsedPatternExA
#define CreateParsedPattern         CreateParsedPatternA
#define WildCharsPattern            WildCharsPatternA
#define IsPatternMatchEx            IsPatternMatchExA
#define IsPatternMatchExAB          IsPatternMatchExABA
#define ExplodeParsedPattern        ExplodeParsedPatternA
#define ExplodeParsedPatternEx      ExplodeParsedPatternExA
#define IsPatternContainedEx        IsPatternContainedExA
#define IsParsedPatternContainedEx  IsParsedPatternContainedExA
#define IsExplodedParsedPatternContainedEx  IsExplodedParsedPatternContainedExA
#define DoExplodedParsedPatternsIntersectEx DoExplodedParsedPatternsIntersectExA
#define DoExplodedParsedPatternsIntersect   DoExplodedParsedPatternsIntersectA
#define TestParsedPattern           TestParsedPatternA
#define TestParsedPatternAB         TestParsedPatternABA
#define DestroyParsedPattern        DestroyParsedPatternA
#define DecodeParsedPattern         DecodeParsedPatternA
#define PatternIncludesPattern      PatternIncludesPatternA
#define GetParsedPatternMinMaxSize  GetParsedPatternMinMaxSizeA
#define ParsedPatternIsExactMatch   ParsedPatternIsExactMatchA
#define ParsedPatternIsOptional     ParsedPatternIsOptionalA
#define ParsedPatternIsRootPlusStar ParsedPatternIsRootPlusStarA
#define ParsedPatternHasRoot        ParsedPatternHasRootA
#define ParsedPatternGetRoot        ParsedPatternGetRootA
#define ParsedPatternSegmentIsPureOptional ParsedPatternSegmentIsPureOptionalA
#define ParsedPatternEndsWithStar   ParsedPatternEndsWithStarA
#define ParsedPatternTrimLastChar   ParsedPatternTrimLastCharA

#define CountInstancesOfChar        CountInstancesOfCharA
#define CountInstancesOfCharI       CountInstancesOfCharIA
#define StringReplace               StringReplaceA
#define CountInstancesOfSubString   CountInstancesOfSubStringA
#define StringSearchAndReplace      StringSearchAndReplaceA
#define MULTISZ_ENUM                MULTISZ_ENUMA
#define EnumFirstMultiSz            EnumFirstMultiSzA
#define EnumNextMultiSz             EnumNextMultiSzA
#define IsStrInMultiSz              IsStrInMultiSzA

#define ParseMessage                ParseMessageA
#define ParseMessageEx              ParseMessageExA
#define ParseMessageID              ParseMessageIDA
#define ParseMessageIDEx            ParseMessageIDExA
#define GetStringResource           GetStringResourceA
#define GetStringResourceEx         GetStringResourceExA
#define FreeStringResource          FreeStringResourceA
#define ParseMessageInWnd           ParseMessageInWndA
#define ResourceMessageBox          ResourceMessageBoxA

#define AddInfSectionToHashTable    AddInfSectionToHashTableA
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCA

#define ReplaceWacks(f)             ToggleWacksA(f,FALSE)
#define RestoreWacks(f)             ToggleWacksA(f,TRUE)

#define SanitizePath                SanitizePathA

#define StringToUint64              StringToUint64A
#define TToU64                      AToU64
#define StringToInt64               StringToInt64A
#define TToI64                      AToI64

#define IsValidUncPath              IsValidUncPathA
#define IsValidFileSpec             IsValidFileSpecA

#define IsEmptyStr                  IsEmptyStrA

#endif

//
// MessageBox macros
//

#define YesNoBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNO|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define YesNoCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNOCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define OkBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OK|MB_ICONINFORMATION|MB_SETFOREGROUND,NULL)
#define OkCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OKCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define RetryCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_RETRYCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\version.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    version.h

Abstract:

    This file implements a set of enumeration routines to access
    version info in a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    calinn      03-Sep-1999 Moved over from Win9xUpg project.

--*/

#pragma once

//
// Includes
//

// None

//
// Debug constants
//

// None

//
// Strings
//

// None

//
// Constants
//

#define MAX_TRANSLATION             32

//
// Macros
//

// None

//
// Types
//

typedef struct {
    WORD CodePage;
    WORD Language;
} TRANSLATION, *PTRANSLATION;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    CHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCSTR FileSpec;
    PCSTR VersionField;
} VRVALUE_ENUMA, *PVRVALUE_ENUMA;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    WCHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCWSTR FileSpec;
    PCWSTR VersionField;
} VRVALUE_ENUMW, *PVRVALUE_ENUMW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes
//

BOOL
VrCreateEnumStructA (
    OUT     PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR FileSpec
    );

BOOL
VrCreateEnumStructW (
    OUT     PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR FileSpec
    );

VOID
VrDestroyEnumStructA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

VOID
VrDestroyEnumStructW (
    IN      PVRVALUE_ENUMW VrValueEnum
    );

PCSTR
VrEnumFirstValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionField
    );

PCWSTR
VrEnumFirstValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionField
    );

PCSTR
VrEnumNextValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
VrEnumNextValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

BOOL
VrCheckVersionValueA (
    IN      PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionName,
    IN      PCSTR VersionValue
    );

BOOL
VrCheckFileVersionA (
    IN      PCSTR FileName,
    IN      PCSTR NameToCheck,
    IN      PCSTR ValueToCheck
    );

BOOL
VrCheckFileVersionW (
    IN      PCWSTR FileName,
    IN      PCWSTR NameToCheck,
    IN      PCWSTR ValueToCheck
    );

BOOL
VrCheckVersionValueW (
    IN      PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionName,
    IN      PCWSTR VersionValue
    );

ULONGLONG
VrGetBinaryFileVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileVersionW(VrValueEnum)    VrGetBinaryFileVersionA((PVRVALUE_ENUMA)VrValueEnum)

ULONGLONG
VrGetBinaryProductVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryProductVersionW(VrValueEnum) VrGetBinaryProductVersionA((PVRVALUE_ENUMA)VrValueEnum)

DWORD
VrGetBinaryFileDateLoA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileDateLoW(VrValueEnum)     VrGetBinaryFileDateLoA((PVRVALUE_ENUMA)VrValueEnum)

DWORD
VrGetBinaryFileDateHiA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileDateHiW(VrValueEnum)     VrGetBinaryFileDateHiA((PVRVALUE_ENUMA)VrValueEnum)

DWORD
VrGetBinaryOsVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryOsVersionW(VrValueEnum)      VrGetBinaryOsVersionA((PVRVALUE_ENUMA)VrValueEnum)

DWORD
VrGetBinaryFileTypeA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileTypeW(VrValueEnum)       VrGetBinaryFileTypeA((PVRVALUE_ENUMA)VrValueEnum)

//
// Macro expansion definition
//

// None

//
// TCHAR mappings
//

#ifndef UNICODE

#define VRVALUE_ENUM                    VRVALUE_ENUMA
#define PVRVALUE_ENUM                   PVRVALUE_ENUMA
#define VrCreateEnumStruct              VrCreateEnumStructA
#define VrDestroyEnumStruct             VrDestroyEnumStructA
#define VrEnumFirstValue                VrEnumFirstValueA
#define VrEnumNextValue                 VrEnumNextValueA
#define VrCheckFileVersion              VrCheckFileVersionA
#define VrCheckVersionValue             VrCheckVersionValueA
#define VrGetBinaryFileVersion          VrGetBinaryFileVersionA
#define VrGetBinaryProductVersion       VrGetBinaryProductVersionA
#define VrGetBinaryFileDateLo           VrGetBinaryFileDateLoA
#define VrGetBinaryFileDateHi           VrGetBinaryFileDateHiA
#define VrGetBinaryOsVersion            VrGetBinaryOsVersionA
#define VrGetBinaryFileType             VrGetBinaryFileTypeA

#else

#define VRVALUE_ENUM                    VRVALUE_ENUMW
#define PVRVALUE_ENUM                   PVRVALUE_ENUMW
#define VrCreateEnumStruct              VrCreateEnumStructW
#define VrDestroyEnumStruct             VrDestroyEnumStructW
#define VrEnumFirstValue                VrEnumFirstValueW
#define VrEnumNextValue                 VrEnumNextValueW
#define VrCheckFileVersion              VrCheckFileVersionW
#define VrCheckVersionValue             VrCheckVersionValueW
#define VrGetBinaryFileVersion          VrGetBinaryFileVersionW
#define VrGetBinaryProductVersion       VrGetBinaryProductVersionW
#define VrGetBinaryFileDateLo           VrGetBinaryFileDateLoW
#define VrGetBinaryFileDateHi           VrGetBinaryFileDateHiW
#define VrGetBinaryOsVersion            VrGetBinaryOsVersionW
#define VrGetBinaryFileType             VrGetBinaryFileTypeW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\unicode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unicode.h

Abstract:

    Declares the interfaces for unicode/ansi conversion.

    See macros at the end of this file for details! (Search for ***)

Author:

    Jim Schmidt (jimschm)   02-Sep-1997

Revision History:

    jimschm 16-Mar-2000     PTSTR<->PCSTR/PCWSTR routines
    jimschm 15-Feb-1999     Eliminated AnsiFromUnicode and UnicodeFromAnsi
    calinn  07-Jul-1998     SetGlobalPage/GetGlobalPage
    mikeco  03-Nov-1997     AnsiFromUnicode/UnicodeFromAnsi

--*/

#pragma once

extern WORD g_GlobalCodePage;

#define OurGetACP() (g_GlobalCodePage)

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    );

VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    );

WORD
SetConversionCodePage (
    IN      WORD CodePage
    );

#define INVALID_CHAR_COUNT      0xffffffff

//
// Explicit conversions, pool-based, unlimited size
//

PCSTR
RealUnicodeToDbcsN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    );

PCWSTR
RealDbcsToUnicodeN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    );

#define UnicodeToDbcsN(p,s,c)       TRACK_BEGIN(PCSTR, UnicodeToDbcsN)\
                                    RealUnicodeToDbcsN(p,s,c)\
                                    TRACK_END()

#define DbcsToUnicodeN(p,s,c)       TRACK_BEGIN(PCWSTR, DbcsToUnicodeN)\
                                    RealDbcsToUnicodeN(p,s,c)\
                                    TRACK_END()

#define UnicodeToDbcs(pool,str) UnicodeToDbcsN(pool,str,(DWORD)wcslen(str))
#define DbcsToUnicode(pool,str) DbcsToUnicodeN(pool,str,CharCountA(str))

#define ConvertWtoA(unicode_str) UnicodeToDbcsN(NULL,unicode_str,(DWORD)wcslen(unicode_str))
#define ConvertAtoW(dbcs_str) DbcsToUnicodeN(NULL,dbcs_str,CharCountA(dbcs_str))

VOID
FreeConvertedPoolStr (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    );

#define FreeConvertedStr(str) FreeConvertedPoolStr(NULL,(PVOID)(str))

//
// In-place explicit conversions, caller handles buffer sizing
//

PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD CharCount
    );

PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD CharCount
    );

#define KnownSizeUnicodeToDbcs(out,in)      KnownSizeUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define KnownSizeDbcsToUnicode(out,in)      KnownSizeDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define KnownSizeWtoA                       KnownSizeUnicodeToDbcs
#define KnownSizeAtoW                       KnownSizeDbcsToUnicode

#define MaxSizeUnicodeToDbcs(out,in,c)      KnownSizeUnicodeToDbcsN(out,in,min(c,CharCountW(in)))
#define MaxSizeDbcsToUnicode(out,in,c)      KnownSizeDbcsToUnicodeN(out,in,min(c,CharCountA(in)))

PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    );

PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    );

#define DirectUnicodeToDbcs(out,in)         DirectUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define DirectDbcsToUnicode(out,in)         DirectDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define DirectWtoA                          DirectUnicodeToDbcs
#define DirectAtoW                          DirectDbcsToUnicode




//
// TCHAR conversions -- do not call A & W versions directly
//

#define CreateDbcsW(unicode_str)            ConvertWtoA(unicode_str)
#define DestroyDbcsW(unicode_str)           FreeConvertedStr(unicode_str)
#define CreateUnicodeW(unicode_str)         (unicode_str)
#define DestroyUnicodeW(unicode_str)
#define CreateDbcsA(dbcs_str)               (dbcs_str)
#define DestroyDbcsA(dbcs_str)
#define CreateUnicodeA(dbcs_str)            ConvertAtoW(dbcs_str)
#define DestroyUnicodeA(dbcs_str)           FreeConvertedStr(dbcs_str)

#define DuplicateDbcsW(unicode_str)         ((PSTR) ConvertWtoA(unicode_str))
#define FreeDuplicatedDbcsW(unicode_str)    FreeConvertedStr(unicode_str)
#define DuplicateUnicodeW(unicode_str)      ((PWSTR) DuplicateTextW(unicode_str))
#define FreeDuplicatedUnicodeW(unicode_str) FreeTextW(unicode_str)
#define DuplicateDbcsA(dbcs_str)            ((PSTR) DuplicateTextA(dbcs_str))
#define FreeDuplicatedDbcsA(dbcs_str)       FreeTextA(dbcs_str)
#define DuplicateUnicodeA(dbcs_str)         ((PWSTR) ConvertAtoW(dbcs_str))
#define FreeDuplicatedUnicodeA(dbcs_str)    FreeConvertedStr(dbcs_str)


//
// **********************************************************************
//
// - Call ConvertWtoA or ConvertAtoW for PCSTR<->PCWSTR conversion,
//   FreeConvertedStr to clean up
//
// - Call KnownSizeAtoW or KnownSizeWtoA for PCSTR<->PCWSTR conversion
//   when you know the destination can hold the result
//
// - Call the routines below for TCHAR<->dbcs/unicode conversion
//
// **********************************************************************
//

#ifdef UNICODE

//
// If your string is a PCTSTR, use these routines:
//

#define CreateDbcs          CreateDbcsW
#define CreateUnicode       CreateUnicodeW
#define DestroyDbcs         DestroyDbcsW
#define DestroyUnicode      DestroyUnicodeW

//
// If your string is a PTSTR, use these routines:
//

#define DuplicateDbcs               DuplicateDbcsW
#define DuplicateUnicode            DuplicateUnicodeW
#define FreeDuplicatedDbcs          FreeDuplicatedDbcsW
#define FreeDuplicatedUnicode       FreeDuplicatedUnicodeW

//
// If your string is a PCSTR or PCWSTR, use these routines:
//

#define ConvertAtoT         ConvertAtoW
#define ConvertWtoT(x)      (x)
#define FreeAtoT            FreeConvertedStr
#define FreeWtoT(x)

// Known size means you know the out buffer is big enough!
#define KnownSizeAtoT           KnownSizeAtoW
#define KnownSizeWtoT(out,in)   (in)

// These are low-level routines that don't care about nuls:
#define DirectAtoT              DirectAtoW
#define DirectWtoT(out,in)      (in)

#else

//
// If your string is a PCTSTR, use these routines:
//

#define CreateDbcs          CreateDbcsA
#define CreateUnicode       CreateUnicodeA
#define DestroyDbcs         DestroyDbcsA
#define DestroyUnicode      DestroyUnicodeA

//
// If your string is a PCSTR or PCWSTR, use these routines:
//

#define ConvertAtoT(x)      (x)
#define ConvertWtoT         ConvertWtoA
#define FreeAtoT(x)
#define FreeWtoT            FreeConvertedStr

//
// If your string is a PTSTR, use these routines:
//

#define DuplicateDbcs               DuplicateDbcsA
#define DuplicateUnicode            DuplicateUnicodeA
#define FreeDuplicatedDbcs          FreeDuplicatedDbcsA
#define FreeDuplicatedUnicode       FreeDuplicatedUnicodeA

// Known size means you know the out buffer is big enough!
#define KnownSizeAtoT(out,in)   (in)
#define KnownSizeWtoT           KnownSizeWtoA

// These are low-level routines that don't care about nuls:
#define DirectAtoT(out,in)      (in)
#define DirectWtoT              DirectWtoA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inc\wnd.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wnd.h

Abstract:

    The header file for Window utility routines.

Author:

    Jim Schmidt (jimschm) 01-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

#define BACK_BUTTON         0x0001
#define NEXT_BUTTON         0x0002
#define CANCEL_BUTTON       0x0004
#define FINISH_BUTTON       0x0008

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

HWND
WndFindWindowInProcessA (
    IN      DWORD ProcessId,
    IN      PCSTR WindowTitle           OPTIONAL
    );

HWND
WndFindWindowInProcessW (
    IN      DWORD ProcessId,
    IN      PCWSTR WindowTitle          OPTIONAL
    );

VOID
WndCenterWindow (
    IN  HWND WindowToCenter,
    IN  HWND ParentToCenterIn           OPTIONAL
    );


VOID
WndTurnOnWaitCursor (
    VOID
    );

VOID
WndTurnOffWaitCursor (
    VOID
    );

VOID
WndSetWizardButtonsA (
    IN      HWND PageHandle,
    IN      DWORD EnableButtons,
    IN      DWORD DisableButtons,
    IN      PCSTR AlternateFinishText      OPTIONAL
    );

VOID
WndSetWizardButtonsW (
    IN      HWND PageHandle,
    IN      DWORD EnableButtons,
    IN      DWORD DisableButtons,
    IN      PCWSTR AlternateFinishText      OPTIONAL
    );

//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

#ifdef UNICODE

#define WndFindWindowInProcess          WndFindWindowInProcessW
#define WndSetWizardButtons             WndSetWizardButtonsW

#else

#define WndFindWindowInProcess          WndFindWindowInProcessA
#define WndSetWizardButtons             WndSetWizardButtonsA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inf\inf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    inf.c

Abstract:

    Provides wrappers for commonly used INF file handling routines. The wrappers provide, amount
    other things, easy memory allocation using a user supplied GROWBUFFER or PMHANDLE

Author:

    09-Jul-1997 Marc R. Whitten (marcw) - File creation.

Revision History:

    22-Oct-1998  marcw    Added capability to replace/append inf files.
    08-Oct-1997  jimschm  OEM version of SetupGetStringField

--*/

#include "pch.h"

GROWLIST g_FileNameList;
HASHTABLE g_NameTable;
static INT g_InfRefs;


VOID
InfGlobalInit (
    IN  BOOL Terminate
    )
{
    if (!Terminate) {
        MYASSERT (g_InfRefs >= 0);

        g_InfRefs++;
        if (g_InfRefs == 1) {
            ZeroMemory (&g_FileNameList, sizeof (GROWLIST));
            g_NameTable = HtAllocA();
        }

    } else {
        MYASSERT (g_InfRefs >= 0);

        g_InfRefs--;

        if (!g_InfRefs) {
            GlFree (&g_FileNameList);
            HtFree (g_NameTable);
            g_NameTable = NULL;
        }
    }
}


VOID
pAddFileRef (
    IN      HINF InfHandle,
    IN      PCSTR FileName
    )
{
    PBYTE data;
    UINT size;

    size = sizeof (InfHandle) + SizeOfStringA (FileName);
    data = MemAlloc (g_hHeap, 0, size);

    if (data) {
        CopyMemory (data, &InfHandle, sizeof (InfHandle));
        StringCopyA ((PSTR) (data + sizeof (InfHandle)), FileName);

        GlAppend (&g_FileNameList, data, size);
        MemFree (g_hHeap, 0, data);
    }
}


PBYTE
pFindFileRef (
    IN      HINF InfHandle,
    OUT     PUINT ListPos       OPTIONAL
    )
{
    UINT u;
    UINT count;
    HINF *p;

    count = GlGetSize (&g_FileNameList);

    for (u = 0 ; u < count ; u++) {
        p = (HINF *) GlGetItem (&g_FileNameList, u);
        if (*p == InfHandle) {
            if (ListPos) {
                *ListPos = u;
            }

            return (PBYTE) p;
        }
    }

    DEBUGMSG ((DBG_VERBOSE, "Can't find file name for INF handle 0x%08X", InfHandle));

    return NULL;
}


VOID
pDelFileRef (
    IN      HINF InfHandle
    )
{
    UINT pos;

    if (pFindFileRef (InfHandle, &pos)) {
        GlDeleteItem (&g_FileNameList, pos);
    }
}


PCSTR
pGetFileNameOfInf (
    IN      HINF Inf
    )
{
    PBYTE fileRef;

    fileRef = pFindFileRef (Inf, NULL);
    if (fileRef) {
        return (PCSTR) (fileRef + sizeof (HINF));
    }

    return NULL;
}


VOID
InfNameHandle (
    IN      HINF Inf,
    IN      PCSTR NewName,
    IN      BOOL OverwriteExistingName
    )
{
    PCSTR name;
    HASHITEM item;

    if (!NewName) {
        pDelFileRef (Inf);
        return;
    }

    name = pGetFileNameOfInf (Inf);

    if (!OverwriteExistingName && name) {
        return;
    }

    if (name) {
        pDelFileRef (Inf);
    }

    item = HtAddStringA (g_NameTable, NewName);
    name = HtGetStringFromItemA (item);

    if (name) {
        pAddFileRef (Inf, name);
    }
}


PBYTE
pAllocateSpace (
    IN PINFSTRUCT Context,
    IN UINT      Size
    )

/*++

Routine Description:

    pAllocateSpace is a private function that allocates space using the user specified allocator.

Arguments:

    Context - A valid INFSTRUCT which has been initialized either by a call to InitInfStruct or
              by using one of the static initializers (INITINFSTRUCT_GROWBUFFER or
              INITINFSTRUCT_PMHANDLE)

    Size    - The size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if no memory could be allocated.

--*/

{

    PBYTE rBytes = NULL;

    switch (Context -> Allocator) {
    case INF_USE_PMHANDLE:
        //
        // Allocate space using Poolmem.
        //
        rBytes = PmGetMemory(Context -> PoolHandle, Size);
        break;

    case INF_USE_GROWBUFFER:
    case INF_USE_PRIVATE_GROWBUFFER:
        //
        // Allocate space using Growbuf.
        //
        Context->GrowBuffer.End = 0;
        rBytes = GbGrow (&(Context -> GrowBuffer), Size);
        break;

    case INF_USE_PRIVATE_PMHANDLE:
        //
        // Allocate space using private growbuffer.
        //
        if (!Context -> PoolHandle) {
            Context -> PoolHandle = PmCreateNamedPool ("INF Pool");
        }
        if (Context -> PoolHandle) {
            rBytes = PmGetMemory(Context -> PoolHandle, Size);
        }
        break;
    }

    return rBytes;
}


VOID
InitInfStruct (
    OUT PINFSTRUCT Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  PMHANDLE PoolHandle   OPTIONAL
    )

/*++

Routine Description:

    This function initializes an INFSTRUCT with the user supplied allocator. It is used when
    user of the INF wrapper routines wishes to manage his own memory (i.e. such as when he
    already has a suitable allocator with sufficient scope created, etc.)

    There is no need to call this function if the user wishes to have the INF wrapper routines
    manage there own memory. Initialize your Init structure with one of either

    INITINFSTRUCT_POOLMEM or INITINFSTRUCT_GROWBUFFER, depending on your preference and needs
    for an allocator.



Arguments:

    Context      - Recieves the initialized INFSTRUCT.
    GrowBuffer   - An optional parameter containing a user supplied and initialized GROWBUFFER.
                   If this parameter is non-NULL, then PoolHandle should be NULL.
    PoolHandle   - An optional parameter containing a user supplied and initialized POOLHANDLE.
                   If this parameter is non-NULL, then GrowBuffer should be NULL.

    One of either GrowBuffer or PoolHandle *must* be specified.

Return Value:

    None.

--*/
{
    ZeroMemory(Context,sizeof(INFSTRUCT));

    if (!PoolHandle && !GrowBuffer) {
        Context  -> Allocator = INF_USE_PRIVATE_PMHANDLE;
    }

    if (PoolHandle) {
        Context  -> PoolHandle = PoolHandle;
        Context  -> Allocator = INF_USE_PMHANDLE;
    }
    if (GrowBuffer) {
        Context -> GrowBuffer = *GrowBuffer;
        Context -> Allocator = INF_USE_GROWBUFFER;
    }

}

VOID
InfCleanUpInfStruct (
    IN OUT PINFSTRUCT Context
    )

/*++

Routine Description:

    InfCleanupInfStruct is responsible for cleaning up the data associated
    with an INFSTRUCT.  This is a mandatory call, unless the INFSTRUCT
    was initialized with InitInfStruct, called with a non-NULL grow buffer or
    pool handle.

    This routine can be called no matter how the INFSTRUCT was initialized.
    However, it will NOT free caller-owned grow buffers or pools.

Arguments:

    Context - Receives the properly cleaned up INFSTRUCT, ready to be
              reused.


Return Value:

     none

--*/

{
    if (Context -> Allocator == INF_USE_PRIVATE_GROWBUFFER) {
        GbFree (&(Context -> GrowBuffer));
    }
    else if (Context -> Allocator == INF_USE_PRIVATE_PMHANDLE && Context -> PoolHandle) {
        PmEmptyPool (Context->PoolHandle);
        PmDestroyPool (Context -> PoolHandle);
    }

    InitInfStruct (Context, NULL, NULL);
}


VOID
InfResetInfStruct (
    IN OUT PINFSTRUCT Context
    )

/*++

Routine Description:

  InfResetInfStruct resets the pool so memory can be recycled.  The intent is
  to allow a caller to reset the INFSTRUCT in order to release the memory
  obtained from getting INF fields.  This is useful in a loop of InfFindFirstLine/
  InfFindNextLine, where two or more fields are processed for each line.

  If only one field is processed in an InfFindFirstLine/InfFindNextLine loop,
  a grow buffer should be used instead.

  This routine empties the active pool block, a block that is 8K by default.  If
  more than the block size has been allocated, other memory blocks besides the
  active block will exist.  Because only the active block is reset, the pool will
  grow.

  If the caller expects more than the block size during one iteration, it should call
  InfCleanupInfStruct to free the pool completely.

Arguments:

  Context - Specifies the struct to reset


Return Value:

  none

--*/

{
    switch (Context -> Allocator) {
    case INF_USE_PMHANDLE:
    case INF_USE_PRIVATE_PMHANDLE:
        if (Context->PoolHandle) {
            PmEmptyPool (Context->PoolHandle);
        }
        break;
    //for some reason lint thought we forgot about INF_USE_GROWBUFFER and
    //INF_USE_PRIVATE_GROWBUFFER. This is not the case so...
    //lint -e(787)
    }
}


/*++

Routine Description:

    InfOpenInfFileA and InfOpenInfFileW are wrappers for the SetupOpenInfFile function.
    They cut down the number of parameters necessary to open an INF file by supplying
    the most common options for non-user specified parameters.

    A call to one of these functions is equivelant to
    SetupOpenInfFile(<FileName>,NULL,INF_STYLE_WIN4,NULL)

Arguments:

    FileName - Contains the name of the INF file to open. See the help for SetupOpenInfFile
               for special details concerning this parameter.

Return Value:

    If the INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
RealInfOpenInfFileA (
    IN PCSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )


{
    HINF rInf;

    MYASSERT(FileSpec);

    //
    // Open the main inf.
    //
    rInf = SetupOpenInfFileA (
                FileSpec,
                NULL,
                INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                NULL
                );

    DebugRegisterAllocation (INF_HANDLE, (PVOID) rInf, File, Line);
    pAddFileRef (rInf, FileSpec);

    return rInf;
}


HINF
RealInfOpenInfFileW (
    IN PCWSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )
{
    PCSTR AnsiFileSpec;
    HINF rInf;

    AnsiFileSpec = ConvertWtoA (FileSpec);

    MYASSERT (AnsiFileSpec);

    rInf = InfOpenInfFileA (AnsiFileSpec);

    FreeConvertedStr (AnsiFileSpec);

    return rInf;
}


VOID
InfCloseInfFile (
    HINF Inf
    )
{

    DebugUnregisterAllocation (INF_HANDLE, Inf);
    pDelFileRef (Inf);

    SetupCloseInfFile (Inf);
}



/*++

Routine Description:

    InfOpenInfInAllSourcesA and InfOpenInfInAllSourcesW are special inf open routines that
    are capable of opening multiple versions of the same inf file that may be spread out across
    installation directories. The first INF file found will be opened with a call to
    SetupOpenInfFile. Additional files will be opened with SetupOpenAppendInfFile.

Arguments:

    InfSpecifier - Contains the source directory indepent portion of the path to a particular inf file.
                   For files located in the root of the source directory, this will simply be the name
                   of the file. For files located in a sub-directory of the source directory, this will
                   be a partial path.

    SourceCount  - Contains the number of source directories

    SourceDirectories - Contains an array of all the source directories.


Return Value:

    If any INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    )
{
    DWORD           index;
    HINF            rInf = INVALID_HANDLE_VALUE;
    PSTR            curPath;
    BOOL            atLeastOneInfOpened = FALSE;

    MYASSERT(InfSpecifier && SourceDirectories);

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsA(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistA (curPath)) {

            //
            // Open the INF file.
            //
            if (!atLeastOneInfOpened) {
                //
                // Since we have not (successfully) opened any INF file yet, use SetupOpenInfFile.
                //
                rInf = InfOpenInfFileA(curPath);
                atLeastOneInfOpened = rInf != INVALID_HANDLE_VALUE;
                if (rInf == INVALID_HANDLE_VALUE) {
                    LOGA ((LOG_ERROR, "Error opening INF %s.", curPath));
                }
            }
            else {
                //
                // Open and append this INF file.
                //
                if (!SetupOpenAppendInfFileA(curPath,rInf,NULL)) {
                    LOGA ((LOG_ERROR,"Error opening INF %s.",curPath));
                }
            }
        }

        //
        // Free this string.
        //
        FreePathStringA(curPath);
    }

    return rInf;
}



HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    )
{
    DWORD index;
    HINF rInf = INVALID_HANDLE_VALUE;
    PWSTR curPath;
    BOOL atLeastOneInfOpened = FALSE;
    PCSTR AnsiPath;

    MYASSERT(InfSpecifier && SourceDirectories);

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsW(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistW (curPath)) {

            //
            // Open the INF file.
            //
            if (!atLeastOneInfOpened) {
                //
                // Since we have not (successfully) opened any INF file yet, use SetupOpenInfFile.
                //
                rInf = InfOpenInfFileW(curPath);
                atLeastOneInfOpened = rInf != INVALID_HANDLE_VALUE;
                if (rInf == INVALID_HANDLE_VALUE) {
                    LOGW ((LOG_ERROR, "OpenInfInAllSources: Error opening INF %s.", curPath));
                }
            }
            else {
                //
                // Open and append this INF file.
                //
                if (!SetupOpenAppendInfFileW(curPath,rInf,NULL)) {
                    LOGW ((LOG_ERROR,"OpenInfInAllSources: Error opening INF %s.",curPath));
                }
            }
        }

        //
        // Free this string.
        //
        FreePathStringW(curPath);
    }

    return rInf;
}



/*++

Routine Description:

    InfGetLineTextA and InfGetLineTextW are wrappers for the SetupGetLineText function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCT Context
    )

{
    PSTR    rLine = NULL;
    DWORD   requiredSize;


    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextA(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextA(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetLineTextA: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}

PWSTR
InfGetLineTextW (
    IN OUT PINFSTRUCT Context
    )
{
    PWSTR rLine = NULL;
    DWORD requiredSize;


    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextW(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextW(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetLineTextW: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}


/*++

Routine Description:

    InfGetMultiSzFieldA and InfGetMultiSzFieldW are wrappers for the SetupGetMultiSzField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated fields or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    )
{

    DWORD   requiredSize;
    PSTR    rFields = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldA(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetMultiSzFieldA: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    )
{

    DWORD   requiredSize;
    PWSTR   rFields = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldW(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetMultiSzFieldW: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

/*++

Routine Description:

    InfGetStringFieldA and InfGetStringFieldW are wrappers for the SetupGetStringField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetStringFieldA (
    IN OUT  PINFSTRUCT Context,
    IN      UINT FieldIndex
    )
{

    DWORD   requiredSize;
    PSTR    rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldA(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetStringFieldA: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCT    Context,
    IN     UINT       FieldIndex
    )
{

    DWORD requiredSize;
    PWSTR rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldW(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetStringFieldW: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}


BOOL
InfGetIntField (
    IN PINFSTRUCT Context,
    IN UINT    FieldIndex,
    IN PINT     Value
    )
/*++

Routine Description:

    InfGetIntField is a wrapper for SetupGetIntField. It is virtually identical to this function
    except that it takes care of getting the INFCONTEXT out of the INFSTRUCT structure.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line from which to retrieve the field.

    Value   - Recieves the value of the requested Int field.

Return Value:

     TRUE if the field was successfully retrieved, FALSE otherwise. Use GetLastError() To receive
     extended error information.

--*/
{
    return SetupGetIntField (&(Context -> Context), FieldIndex, Value);
}

PBYTE
InfGetBinaryField (
    IN  PINFSTRUCT    Context,
    IN  UINT       FieldIndex
    )
/*++

Routine Description:

    InfGetBinaryField is a wrapper for the SetupGetBinaryField function. It reduces
    the number of parameters required to get the line text and takes care of
    allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.
    FieldIndex - the index within the line of the desired binary information.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/
{

    DWORD requiredSize;
    PBYTE rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetBinaryField(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = pAllocateSpace(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetBinaryField(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetBinaryField: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

/*++

Routine Description:

  InfGetIndexByLine is a straight wrapper for SetupGetLineByIndex. The only
  difference is the use of an PINFSTRUCT instead of a PINFCONTEXT.

Arguments:

  InfHandle - Contains a valid HINF.

  Section   - Contains the name of the section within the InfFile.

  Index     - Contains the index within the section of the line in question.

  Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

  TRUE if the function was called successfully, FALSE otherwise.

--*/


BOOL
InfGetLineByIndexA(
    IN HINF InfHandle,
    IN PCSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
)
{
    return SetupGetLineByIndexA(InfHandle,Section,Index,&(Context -> Context));
}

BOOL
InfGetLineByIndexW(
    IN HINF InfHandle,
    IN PCWSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
)
{
    return SetupGetLineByIndexW(InfHandle,Section,Index,&(Context -> Context));
}





/*++

Routine Description:

    InfFindFirstLineA and InfFindFirstLineW are wrappers for the SetupFindFirstLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS.

Arguments:


    InfHandle - Contains a valid HINF.

    Section   - Contains the name of the section within the InfFile.

    Key       - An optional parameter containing the name of the key within the section to find.
                If NULL, these routines will return the first line in the section.

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if lines exist in the section, FALSE otherwise.

--*/
BOOL
InfFindFirstLineA (
    IN  HINF         InfHandle,
    IN  PCSTR        Section,
    IN  PCSTR        Key, OPTIONAL
    OUT PINFSTRUCT    Context
    )
{

    return SetupFindFirstLineA (
        InfHandle,
        Section,
        Key,
        &(Context -> Context)
        );
}

BOOL
InfFindFirstLineW (
    IN      HINF InfHandle,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PINFSTRUCT Context
    )
{

    return SetupFindFirstLineW (
        InfHandle,
        Section,
        Key,
        &(Context -> Context)
        );
}

/*++

Routine Description:

    InfFindNextLineA and InfFindNextLineW are wrappers for the SetupFindFirstLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS and
    need only one INFSTRUCT parameter.

Arguments:

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if there is another line in the section, FALSE otherwise.

--*/
BOOL
InfFindNextLine (
    IN OUT PINFSTRUCT    Context
    )
{

    return SetupFindNextLine (&(Context -> Context),&(Context -> Context));
}

UINT
InfGetFieldCount (
    IN PINFSTRUCT Context
    )
{
    return SetupGetFieldCount(&(Context  -> Context));
}



PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCT Context,
    IN      UINT Field
    )

/*++

Routine Description:

  InfGetOemStringField returns a string field in the OEM character set.
  This routine is used when accessing txtsetup.sif.  It is implemented
  only in the A version because UNICODE does not have a concept of OEM
  characters.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Field - Specifies the field number

Return Value:

  A pointer to the OEM string, or NULL if an error occurred.

--*/

{
    PCSTR Text;
    PSTR OemText;
    UINT Size;

    Text = InfGetStringFieldA (Context, Field);
    if (!Text) {
        return NULL;
    }

    Size = SizeOfStringA (Text);

    OemText = (PSTR) pAllocateSpace (Context, Size);
    if (!OemText) {
        return NULL;
    }

    //
    // We leave Text allocated because the caller will free everything
    // when they clean up Context.  Note the assumption that the conversion
    // doesn't change string length.
    //

    OemToCharBuffA (Text, OemText, Size);

    return OemText;
}


BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PSTR ReturnBuffer,                  OPTIONAL
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize                 OPTIONAL
    )

/*++

Routine Description:

  SetupGetOemStringFieldA is a SetupGetStringField that converts the
  return text to the OEM character set.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Index - Specifies the field number

  ReturnBuffer - Specifies the buffer to fill the text into

  ReturnBufferSize - Specifies the size of ReturnBuffer in bytes

  RequiredSize - Receives the size of the buffer needed

Return Value:

  TRUE if successful, FALSE if failure.

--*/

{
    PSTR OemBuf;

    UINT Size;

    if (!SetupGetStringFieldA (
            Context,
            Index,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
            )) {
        return FALSE;
    }

    if (!ReturnBuffer) {
        return TRUE;
    }

    Size = SizeOfStringA (ReturnBuffer);

    OemBuf = (PSTR) MemAlloc (g_hHeap, 0, Size);

    OemToCharBuffA (ReturnBuffer, OemBuf, Size);
    StringCopyA (ReturnBuffer, OemBuf);
    MemFree (g_hHeap, 0, OemBuf);

    return TRUE;
}


VOID
InfLogContext (
    IN      PCSTR LogType,
    IN      HINF InfHandle,
    IN      PINFSTRUCT InfStruct
    )
{
    PCSTR fileName;
    PSTR field0 = NULL;
    PSTR field1 = NULL;
    PSTR lineData;
    UINT requiredSize;

    //
    // Log the file name, if one exists
    //

    fileName = pGetFileNameOfInf (InfHandle);

    if (fileName) {
        LOGA ((
            LogType,
            "%s",
            fileName
            ));
    }

    //
    // Get field 0
    //

    if (SetupGetStringFieldA(
            &InfStruct->Context,
            0,
            NULL,
            0,
            &requiredSize
            )) {
        field0 = (PSTR) MemAlloc (g_hHeap, 0, requiredSize);

        if (!SetupGetStringFieldA(
                &InfStruct->Context,
                0,
                field0,
                requiredSize,
                NULL
                )) {
            MemFree (g_hHeap, 0, field0);
            field0 = NULL;
        }
    }

    //
    // Get field 1
    //

    if (SetupGetStringFieldA(
            &InfStruct->Context,
            1,
            NULL,
            0,
            &requiredSize
            )) {
        field1 = (PSTR) MemAlloc (g_hHeap, 0, requiredSize);

        if (!SetupGetStringFieldA(
                &InfStruct->Context,
                1,
                field1,
                requiredSize,
                NULL
                )) {
            MemFree (g_hHeap, 0, field1);
            field1 = NULL;
        }
    }

    //
    // Compare them, and if they are the same, eliminate field 0
    //

    if (field0 && field1) {
        if (StringMatchA (field0, field1)) {
            MemFree (g_hHeap, 0, field0);
            field0 = NULL;
        }
    }

    //
    // Now print the entire line
    //

    if (SetupGetLineTextA (
            &InfStruct->Context,
            NULL,
            NULL,
            NULL,
            NULL,
            0,
            &requiredSize
            )) {
        lineData = (PSTR) MemAlloc (g_hHeap, 0, requiredSize);

        if (SetupGetLineTextA (
                &InfStruct->Context,
                NULL,
                NULL,
                NULL,
                lineData,
                requiredSize,
                NULL
                )) {

            if (field0) {
                LOGA ((LogType, "Line: %s = %s", field0, lineData));
            } else {
                LOGA ((LogType, "Line: %s", lineData));
            }

            MemFree (g_hHeap, 0, lineData);
        }
    }

    if (field0) {
        MemFree (g_hHeap, 0, field0);
    }

    if (field1) {
        MemFree (g_hHeap, 0, field1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\inf\infparse.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  infparse.c

Abstract:

  The code in this file read in an INF file, organizing it into a data
  structure that can be manipulated.

  The entry points are:

  OpenInfFile - Parses the INF associated with the STF file.

  InfParse_WriteInfToDisk - Writes the INF memory structure to disk

  AddInfSectionToTable - Adds a new section to the INF memory structure

  AddInfLineToTable - Adds a new line to a section's memory structure

  FindInfSectionInTable - Performs a sequential search for a specific
                          section name

  FindLineInInfSection - Locates a line given a specific key

  DeleteLineInInfSection - Removes a line from an INF section

  DeleteSectionInInfFile - Removes a complete section from the INF memory
                           structure

  GetInfSectionLineCount - Returns the number of lines in a section

  GetFirstLineInSectionStruct - Begins a line enumeration given an INF
                                section ptr

  GetFirstLineInSectionStr - Begins a line enumeration given an INF
                             section string

  GetNextLineInSection - Continues a line enumeration

Author:

  Jim Schmidt (jimschm) 20-Sept-1997

Revision History:

--*/

#include "pch.h"


//
// Globals to manage INF file reading
//

static PBYTE g_Buf1, g_Buf2;
static DWORD g_Buf1Start, g_Buf2Start;
static DWORD g_Buf1End, g_Buf2End;

#define INF_BUFFER_SIZE 32768

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    );

PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    );


typedef struct {
    HANDLE SourceInfFile;
    HANDLE DestInfFile;
    PMHANDLE InfPool;             // A pool for appended INF data
    PINFSECTION FirstInfSection;    // The first section of the parsed INF
    PINFSECTION LastInfSection;     // The last section of the parsed INF
    BOOL InfIsUnicode;
} INFFILE, *PINFFILE;



BOOL
pReadInfIntoTable (
    IN OUT  PINFFILE InfFile,
    IN PWSTR SectionList,
    IN BOOL KeepComments
    )

/*++

Routine Description:

  Reads the specified file into memory, parsing the lines according to basic
  INF structure.

Arguments:

  InfFile - Specifies the structure initilized with the INF file handle.
            Receives the complete INF structure.

Return Value:

  TRUE if parsing was successful, or FALSE if parsing failed.

--*/

{
    WCHAR ch;
    BOOL Error;
    GROWBUFFER LineBuf = INIT_GROWBUFFER;
    PCWSTR Text;
    DWORD Pos;
    PCWSTR Key, Data;
    PWSTR p, q;
    DWORD i;
    PINFSECTION Section = NULL;
    DWORD LineFlags;
    BOOL Result = FALSE;
    HASHTABLE ht = NULL;
    BOOL neededSection = FALSE;
    PWSTR list;


    Section = AddInfSectionToTableW (InfFile, L"");
    if (!Section) {
        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add comment section"));
        return FALSE;
    }


    //
    // If we have a list of sections to fill, add them to a ht, for faster retrieval.
    //
    if (SectionList) {
        list = PmDuplicateStringW (InfFile->InfPool, SectionList);
        ht = HtAllocW ();
        if (ht) {
            while (list) {

                p = wcschr (list, L',');

                if (p) {
                    *p = 0;
                }

                HtAddStringW (ht, SkipSpaceW(list));

                if (p) {
                    *p = L',';
                    list = p + 1;
                }
                else {
                    list = p;
                }
            }
        }
        else {

            LOG ((LOG_ERROR, "Read Inf Into Table: Could not allocate section hash table."));
            return FALSE;
        }

    }


    g_Buf1Start = 0;
    g_Buf2Start = 0;
    g_Buf1End   = 0;
    g_Buf2End   = 0;

    g_Buf1 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);
    g_Buf2 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);

    __try {

        //
        // Determine if this file is UNICODE
        //

        ch = pGetInfFileWchar (InfFile->SourceInfFile, 0, &Error);
        InfFile->InfIsUnicode = (ch == 0xfeff) && !Error;

        //
        // Parse each line.
        //

        Pos = 0;

        for (;;) {
            //
            // Get the line
            //

            Text = pGetNextInfLine (
                        InfFile->SourceInfFile,
                        &LineBuf,
                        &Pos,
                        InfFile->InfIsUnicode
                        );

            if (!Text) {
                break;
            }

            //
            // If a comment line or blank line, skip it
            //

            p = (PWSTR) SkipSpaceW (Text);
            if (!p[0] || p[0] == L';') {
                if (KeepComments && !AddInfLineToTableW (InfFile, Section, NULL, Text, LINEFLAG_ALL_COMMENTS)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line comments to table", Text));
                    __leave;
                }

                continue;
            }

            //
            // If a section line, start the new section
            //

            if (p[0] == L'[') {
                p++;
                q = wcschr (p, L']');
                if (!q) {
                    q = GetEndOfStringW (p);
                } else {
                    *q = 0;
                }

                if (!ht || HtFindStringW (ht, p)) {

                    Section = AddInfSectionToTableW (InfFile, p);
                    neededSection = TRUE;
                    if (!Section) {
                        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add section %s", p));
                        __leave;
                    }
                }
                else {

                    //
                    // We must not care about this section. Make sure we don't add any lines.
                    //
                    neededSection = FALSE;
                }
            }

            //
            // Otherwise it must be a valid line
            //

            else {
                if (!Section) {
                    DEBUGMSG ((DBG_WARNING, "InfParse_ReadInfIntoTable: Ignoring unrecognized line %s", p));
                    continue;
                }

                if (!neededSection) {
                    continue;
                }

                //
                // Split key and line: Skip key that is surrounded by quotes, then
                // find the first
                //

                LineFlags = 0;

                q = p;
                Key = NULL;
                Data = Text;

                while (q[0] == L'\"') {
                    q = wcschr (q + 1, L'\"');
                    if (!q) {
                        q = p;
                        break;
                    } else {
                        q++;
                    }
                }

                i = (DWORD)wcscspn (q, L"\"=");

                if (q[i] == L'=') {
                    q += i;

                    Data = SkipSpaceW (q + 1);
                    *q = 0;
                    q = (PWSTR) SkipSpaceRW (Text, q);
                    if (q && *q) {
                        q++;
                        *q = 0;
                    }

                    Key = p;

                    if (Key[0] == L'\"') {

                        LineFlags |= LINEFLAG_KEY_QUOTED;
                        Key++;

                        p = GetEndOfStringW (Key);
                        p = (PWSTR) SkipSpaceRW (Key, p);

                        if (p && *p) {
                            if (p[0] != L'\"') {
                                p++;
                            }

                            *p = 0;
                        }
                    }
                }

                if (!AddInfLineToTableW (InfFile, Section, Key, Data, LineFlags)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line %s to table", Text));
                    __leave;
                }
            }
        }

        if (Pos != GetFileSize (InfFile->SourceInfFile, NULL)) {
            LOG ((LOG_ERROR, "Read Inf Into Table: Could not read entire INF"));
            __leave;
        }

        Result = TRUE;
    }
    __finally {
        MemFree (g_hHeap, 0, g_Buf1);
        MemFree (g_hHeap, 0, g_Buf2);
        GbFree (&LineBuf);
        if (ht) {
            HtFree (ht);
        }
    }

    return Result;
}


VOID
CloseInfFile (
    HINF InfFile
    )
{
    PINFFILE inf = (PINFFILE) InfFile;

    PmEmptyPool (inf->InfPool);
    PmDestroyPool (inf->InfPool);
    MemFree (g_hHeap, 0, inf);

}


HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;
    PWSTR wSectionList = NULL;


    if (SectionList) {
        wSectionList = (PWSTR) ConvertAtoW (SectionList);
    }



    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileA (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PmCreateNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, wSectionList, KeepComments);
    }

    if (wSectionList) {
        FreeConvertedStr (wSectionList);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PmDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle (InfFile->SourceInfFile);
    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;

    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileW (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PmCreateNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, SectionList, KeepComments);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PmDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle (InfFile->SourceInfFile);
    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


BOOL
pSaveInfToFile (
    IN      PINFFILE InfFile
    )

/*++

Routine Description:

  InfParse_WriteInfToDisk writes the INF represented by the given memory
  image to disk.  This is done by enumerating the INF data structures in
  the INF.

Arguments:

  InfFile - Specifies the table to process

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    PINFSECTION Section;
    PINFLINE Line;
    BYTE UnicodeHeader[] = { 0xff, 0xfe };
    DWORD DontCare;
    PCSTR AnsiStr = NULL;
    BOOL b = TRUE;

    MYASSERT (InfFile->SourceInfFile == INVALID_HANDLE_VALUE);
    MYASSERT (InfFile->DestInfFile != INVALID_HANDLE_VALUE);

    //
    // Write the INF as we have it in memory
    //

    __try {
        if (InfFile->InfIsUnicode) {
            if (!WriteFile (InfFile->DestInfFile, UnicodeHeader, sizeof (UnicodeHeader), &DontCare, NULL)) {
                __leave;
            }

            if (!WriteFileStringW (InfFile->DestInfFile, L"\r\n")) {
                __leave;
            }

        } else {

            if (!WriteFileStringA (InfFile->DestInfFile, "\r\n")) {
                __leave;
            }

        }

        Section = InfFile->FirstInfSection;

        while (Section) {
            if (Section->Name[0]) {

                if (InfFile->InfIsUnicode) {

                    if (!WriteFileStringW (InfFile->DestInfFile, L"[") ||
                        !WriteFileStringW (InfFile->DestInfFile, Section->Name) ||
                        !WriteFileStringW (InfFile->DestInfFile, L"]\r\n")
                        ) {
                        __leave;
                    }
                } else {

                    AnsiStr = ConvertWtoA (Section->Name);

                    if (!WriteFileStringA (InfFile->DestInfFile, "[") ||
                        !WriteFileStringA (InfFile->DestInfFile, AnsiStr) ||
                        !WriteFileStringA (InfFile->DestInfFile, "]\r\n")
                        ) {
                        __leave;
                    }

                    FreeConvertedStr (AnsiStr);
                    AnsiStr = NULL;
                }
            }

            Line = Section->FirstLine;

            while (Line) {
                if (Line->Key) {
                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (!WriteFile (InfFile->DestInfFile, L"\"", InfFile->InfIsUnicode ? 2 : 1, &DontCare, NULL)) {
                            __leave;
                        }

                    }

                    if (InfFile->InfIsUnicode) {

                        if (!WriteFileStringW (InfFile->DestInfFile, Line->Key)) {
                            __leave;
                        }

                    } else {

                        AnsiStr = ConvertWtoA (Line->Key);

                        if (!WriteFileStringA (InfFile->DestInfFile, AnsiStr)) {
                            __leave;
                        }

                        FreeConvertedStr (AnsiStr);
                        AnsiStr = NULL;
                    }

                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (!WriteFile (InfFile->DestInfFile, L"\"", InfFile->InfIsUnicode ? 2 : 1, &DontCare, NULL)) {
                            __leave;
                        }

                    }

                    if (InfFile->InfIsUnicode) {

                        if (!WriteFileStringW (InfFile->DestInfFile, L" = ")) {
                            __leave;
                        }

                    } else {

                        if (!WriteFileStringA (InfFile->DestInfFile, " = ")) {
                            __leave;
                        }
                    }
                }

                if (InfFile->InfIsUnicode) {

                    if (!WriteFileStringW (InfFile->DestInfFile, Line->Data) ||
                        !WriteFileStringW (InfFile->DestInfFile, L"\r\n")
                        ) {

                        __leave;
                    }

                } else {

                    AnsiStr = ConvertWtoA (Line->Data);

                    if (!WriteFileStringA (InfFile->DestInfFile, AnsiStr) ||
                        !WriteFileStringA (InfFile->DestInfFile, "\r\n")
                        ) {
                        __leave;
                    }

                    FreeConvertedStr (AnsiStr);
                    AnsiStr = NULL;

                }

                Line = Line->Next;
            }

            if (InfFile->InfIsUnicode) {

                if (!WriteFileStringW (InfFile->DestInfFile, L"\r\n")) {
                    __leave;
                }
            } else {

                if (!WriteFileStringA (InfFile->DestInfFile, "\r\n")) {
                    __leave;
                }
            }

            Section = Section->Next;
        }
    }
    __finally {
        if (AnsiStr) {
            FreeConvertedStr (AnsiStr);
        }

        DEBUGMSG_IF((!b, DBG_ERROR, "Write Inf To Disk: Cannot write INF"));
    }

    return b;
}


BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileA (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileA (SaveToFileSpec);
    }

    return b;
}


BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileW (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileW (SaveToFileSpec);
    }

    return b;
}


PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION SectionPtr;
    PCWSTR UnicodeSectionName;

    UnicodeSectionName = ConvertAtoW (SectionName);

    SectionPtr = AddInfSectionToTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (SectionName);

    return SectionPtr;
}


PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Creates a new section in our linked list structure if necessary.
  The return structure can be used to add lines to the section.

Arguments:

  Inf - Specifies the INF to add the section to

  SectionName - Specifies the name of the new section

Return Value:

  A pointer to the new INF section struct, or NULL if an
  error occurred.

--*/

{
    PINFSECTION NewSection;
    PINFFILE InfFile = (PINFFILE) Inf;

    //
    // Return early if this section already exists
    //

    NewSection = FindInfSectionInTableW (InfFile, SectionName);
    if (NewSection) {
        return NewSection;
    }

    //
    // Allocate a section struct
    //

    NewSection = (PINFSECTION) PmGetAlignedMemory (
                                    InfFile->InfPool,
                                    sizeof (INFSECTION)
                                    );

    if (!NewSection) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewSection, sizeof (INFSECTION));

    NewSection->Name = PmDuplicateStringW (
                            InfFile->InfPool,
                            SectionName
                            );

    if (!NewSection->Name) {
        return NULL;
    }

    NewSection->Prev = InfFile->LastInfSection;
    if (NewSection->Prev) {
        NewSection->Prev->Next = NewSection;
    } else {
        InfFile->FirstInfSection = NewSection;
    }

    InfFile->LastInfSection = NewSection;

    return NewSection;
}


PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    )
{
    PCWSTR UnicodeKey;
    PCWSTR UnicodeData;
    PINFLINE Line;

    if (Key) {
        UnicodeKey = ConvertAtoW (Key);
    } else {
        UnicodeKey = NULL;
    }

    UnicodeData = ConvertAtoW (Data);

    Line = AddInfLineToTableW (Inf, SectionPtr, UnicodeKey, UnicodeData, LineFlags);

    if (Key) {
        FreeConvertedStr (UnicodeKey);
    }

    FreeConvertedStr (UnicodeData);

    return Line;
}


PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    )

/*++

Routine Description:

  Adds a line to the specified section.  The caller specifies the
  full formatted data, and an optional key.  The caller does NOT
  supply the equals sign between the key and data.

Arguments:

  InfFile - Specifies the table to add the INF line to

  SectionName - Specifies the name of the section to add the line to

  Key - If specified, supplies the left-hand side of the equals line

  Data - Specifies the text for the line, or the right-hand side of
         the key = value expression.

  LineFlags - Specifies the flags for the INF line (see LINEFLAG_*)

Return Value:

  TRUE if the line was added to the structure, or FALSE if not.

--*/

{
    PINFLINE NewLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    //
    // Allocate line struct
    //

    NewLine = (PINFLINE) PmGetAlignedMemory (
                              InfFile->InfPool,
                              sizeof (INFLINE)
                              );


    if (!NewLine) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewLine, sizeof (INFLINE));

    if (Key) {
        NewLine->Key = PmDuplicateStringW (
                            InfFile->InfPool,
                            Key
                            );

        if (!NewLine->Key) {
            return NULL;
        }
    }

    NewLine->Data = PmDuplicateStringW (
                        InfFile->InfPool,
                        Data
                        );

    if (!NewLine->Data) {
        return NULL;
    }

    NewLine->Next = NULL;
    NewLine->Prev = SectionPtr->LastLine;
    NewLine->Section = SectionPtr;
    NewLine->LineFlags = LineFlags;

    if (NewLine->Prev) {
        NewLine->Prev->Next = NewLine;
    } else {
        SectionPtr->FirstLine = NewLine;
    }

    SectionPtr->LastLine = NewLine;
    SectionPtr->LineCount++;

    return NewLine;
}


PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION InfSectionPtr;
    PCWSTR UnicodeSectionName;

    UnicodeSectionName = ConvertAtoW (SectionName);

    InfSectionPtr = FindInfSectionInTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (UnicodeSectionName);

    return InfSectionPtr;
}


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Scans the INF for a specific section.  This routine scans
  the INF structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  SectionName - Specifies the name of the section to find

Return Value:

  A pointer to the matching INF section struct, or NULL if
  the section was not found.

--*/

{
    PINFSECTION Section;
    PINFFILE InfFile = (PINFFILE) Inf;

    Section = InfFile->FirstInfSection;
    while (Section) {
        if (StringIMatchW (Section->Name, SectionName)) {
            return Section;
        }

        Section = Section->Next;
    }

    return NULL;
}


PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    )
{

    PINFFILE InfFile = (PINFFILE) Inf;

    if (InfFile) {
        return InfFile->FirstInfSection;
    }

    return NULL;
}

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    )
{

    if (Section) {
        return Section->Next;
    }

    return NULL;
}




PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    )

{
    PCWSTR UnicodeKey;
    PINFLINE LinePtr;

    UnicodeKey = ConvertAtoW (Key);

    LinePtr = FindLineInInfSectionW (Inf, Section, UnicodeKey);

    FreeConvertedStr (UnicodeKey);

    return LinePtr;
}


PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    )

/*++

Routine Description:

  Scans the specified INF section for a specific key.  This routine
  scans the INF line structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  Section - Specifies the section to search

  Key - Specifies the key to find

Return Value:

  A pointer to the matching INF line struct, or NULL if
  the section was not found.

--*/

{
    PINFLINE Line;

    Line = Section->FirstLine;
    while (Line) {
        if (Line->Key && StringIMatchW (Line->Key, Key)) {
            return Line;
        }

        Line = Line->Next;
    }

    return NULL;
}


PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

  This routine does not return lines consisting only of comments.

Arguments:

  Section - Specifies the section structure to enumerate lines frmo

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    if (!Section->FirstLine) {
        return NULL;
    }

    if (Section->FirstLine->LineFlags & LINEFLAG_ALL_COMMENTS) {
        return GetNextLineInSection (Section->FirstLine);
    }

    return Section->FirstLine;
}


PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    )

/*++

Routine Description:

  GetNextLineInSection returns the next INFLINE pointer for the
  section, based on the previous line, or NULL if no lines exist.

  This routine does not return lines with comments.

Arguments:

  PrevLine - Specifies previous line (returned from
             GetFirstLineInSectionStruct or GetFirstLineInSectionStr).

Return Value:

  This routine does not return lines consisting only of comments.

--*/

{
    while (PrevLine) {
        PrevLine = PrevLine->Next;
        if (!PrevLine || !(PrevLine->LineFlags & LINEFLAG_ALL_COMMENTS)) {
            break;
        }
    }

    return PrevLine;
}


PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PCWSTR UnicodeSection;
    PINFLINE LinePtr;

    UnicodeSection = ConvertAtoW (Section);

    LinePtr = GetFirstLineInSectionStrW (Inf, UnicodeSection);

    FreeConvertedStr (UnicodeSection);

    return LinePtr;
}


PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PINFSECTION SectionPtr;
    PINFFILE Table = (PINFFILE) Inf;

    SectionPtr = FindInfSectionInTableW (Table, Section);
    if (!SectionPtr) {
        return NULL;
    }

    return GetFirstLineInSectionStruct (SectionPtr);
}


INT
pGetInfFileByte (
    IN      HANDLE File,
    IN      DWORD Pos
    )

/*++

Routine Description:

  Returns the byte at the specified position, or -1 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

Return Value:

  The byte at the specified position, or -1 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)

--*/

{
    DWORD Read;
    PBYTE BufSwap;

    //
    // If we read the buffer previously, then return data in our buffer
    //

    if (Pos >= g_Buf1Start && Pos < g_Buf1End) {
        return g_Buf1[Pos - g_Buf1Start];
    }

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    //
    // Buffer not available; move buffer 2 to buffer 1, then read buffer 2
    //

    g_Buf1Start = g_Buf2Start;
    g_Buf1End = g_Buf2End;
    BufSwap = g_Buf1;
    g_Buf1 = g_Buf2;
    g_Buf2 = BufSwap;

    g_Buf2Start = Pos - (Pos % 256);

    SetFilePointer (File, (LONG)g_Buf2Start, NULL, FILE_BEGIN);
    if (!ReadFile (File, g_Buf2, INF_BUFFER_SIZE, &Read, NULL)) {
        return -1;
    }

    g_Buf2End = g_Buf2Start + Read;

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    return -1;
}

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    )

/*++

Routine Description:

  Returns the WCHAR at the specified position, or 0 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  Error - Receives TRUE if an error was encountered, or FALSE if an
          error was not encountered.

Return Value:

  The WCHAR at the specified position, or 0 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)
  If an error was encountered, the Error variable is also set to TRUE.

--*/

{
    INT c;
    WCHAR ch;

    c = pGetInfFileByte (File, Pos);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return (WORD) c;
    }

    ch = (WORD) c;

    c = pGetInfFileByte (File, Pos + 1);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return 0;
    }

    // pGetInfFileByte return a byte value or -1.
    // Since we checked for -1 the next cast is valid.
    ch += (WORD)(c * 256);
    *Error = FALSE;

    return ch;
}


PCSTR
pGetInfLineA (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a DBCS string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the DBCS string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    INT c;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;

    EndPos = StartPos;
    for (;;) {
        c = pGetInfFileByte (File, EndPos);
        if (c == -1 || c == 26) {
            break;
        }

        if (IsDBCSLeadByte ((BYTE) c)) {
            EndPos++;
            c = pGetInfFileByte (File, EndPos);
            if (c == -1 || c == 26) {
                break;
            }
            ByteLen++;
        } else {
            if (c == '\r' || c == '\n') {
                EndPos++;
                if (c == '\r') {
                    c = pGetInfFileByte (File, EndPos);
                    if (c == '\n') {
                        EndPos++;
                    }
                }

                break;
            }
        }

        EndPos++;
        ByteLen++;
    }

    //
    // NOTE: If you make a change here, make one below in W version
    //

    // Ctrl+Z ends the file
    if (c == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer, caller frees
    LineBuf->End = 0;
    Data = GbGrow (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && c != '\r' && c != '\n') {
        return NULL;
    }

    // Copy line to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    return (PCSTR) Data;
}


PCWSTR
pGetInfLineW (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a UNICODE string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the UNICODE string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;
    WCHAR ch;
    BOOL Error;

    EndPos = StartPos;
    for (;;) {

        ch = pGetInfFileWchar (File, EndPos, &Error);

        if (Error) {
            break;
        }

        if (ch == L'\r' || ch == L'\n') {
            EndPos += 2;
            if (ch == L'\r') {
                ch = pGetInfFileWchar (File, EndPos, &Error);
                if (ch == '\n') {
                    EndPos += 2;
                }
            }

            break;
        }

        EndPos += 2;
        ByteLen += 2;
    }

    //
    // NOTE: If you make a change here, make one above in A version
    //

    // Ctrl+Z ends the file
    if (ch == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer
    LineBuf->End = 0;
    Data = GbGrow (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && ch != L'\r' && ch != L'\n') {
        return NULL;
    }

    // Copy to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    return (PCWSTR) Data;
}


PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    )

/*++

Routine Description:

  Returns a string supplying the line.  This string can be any length and
  is nul-terminated.  It does not include the \r or \n characters.

Arguments:

  File - Specifies the file to read

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

  Pos - Specifies the byte offset to the start of the line.  Receives
        the byte offset to the next line.

  UnicodeMode - Specifies TRUE if the file being read is a UNICODE file,
                or FALSE if the file being read is a DBCS file.

Return Value:

  A pointer to the string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    PCSTR AnsiStr = NULL;
    PCWSTR UnicodeStr = NULL;
    PCWSTR FinalStr;
    BOOL Converted = FALSE;

    //
    // Obtain the text from the file
    //

    if (UnicodeMode) {
        UnicodeStr = pGetInfLineW (File, *Pos, Pos, LineBuf);
        if (!UnicodeStr) {
            return NULL;
        }
    } else {
        AnsiStr = pGetInfLineA (File, *Pos, Pos, LineBuf);
        if (!AnsiStr) {
            return NULL;
        }
    }

    if (AnsiStr) {
        UnicodeStr = ConvertAtoW (AnsiStr);
        if (!UnicodeStr) {
            return NULL;
        }

        Converted = TRUE;
    }

    FinalStr = UnicodeStr;

    //
    // Copy converted string into line buffer
    //

    if (Converted) {
        LineBuf->End = 0;
        Converted = GbMultiSzAppendW (LineBuf, FinalStr);
        FreeConvertedStr (FinalStr);

        if (!Converted) {
            return NULL;
        }
    }

    return (PCWSTR) LineBuf->Buf;
}


BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    )

/*++

Routine Description:

  DeleteLineInInfSection removes the specified InfLine from its section,
  cleaning up memory used by the line.

Arguments:

  Inf - Specifies the INF to modify

  InfLine - Specifies the line to delete

Return Value:

  TRUE if the line was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFFILE InfFile = (PINFFILE) Inf;

    if (InfLine->Prev) {
        InfLine->Prev->Next = InfLine->Next;
    } else {
        InfLine->Section->FirstLine = InfLine->Next;
    }

    if (InfLine->Next) {
        InfLine->Next->Prev = InfLine->Prev;
    } else {
        InfLine->Section->LastLine = InfLine->Prev;
    }

    if (InfLine->Key) {
        PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Key);
    }

    if (InfLine->Data) {
        PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Data);
    }

    InfLine->Section->LineCount--;

    PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine);
    return TRUE;
}


BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  DeleteSectionInInfFile removes the specified section from the INF
  data structure, removing all lines cleaning up
  memory used by the section.

Arguments:

  InfFile - Specifies the table owning the INF line

  Section - Specifies the section to delete

Return Value:

  TRUE if the section was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFLINE InfLine;
    PINFLINE DelInfLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    InfLine = Section->FirstLine;
    while (InfLine) {
        DelInfLine = InfLine;
        InfLine = InfLine->Next;

        if (!DeleteLineInInfSection (InfFile, DelInfLine)) {
            return FALSE;
        }
    }

    if (Section->Prev) {
        Section->Prev->Next = Section->Next;
    } else {
        InfFile->FirstInfSection = Section->Next;
    }

    if (Section->Next) {
        Section->Next->Prev = Section->Prev;
    } else {
        InfFile->LastInfSection = Section->Prev;
    }

    PmReleaseMemory (InfFile->InfPool, (PVOID) Section->Name);
    PmReleaseMemory (InfFile->InfPool, (PVOID) Section);

    return TRUE;
}


UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetInfSectionLineCount returns the number of lines in the specified
  INF section.

Arguments:

  Section - Specifies the section to query

Return Value:

  The number of lines, or zero if the section has no lines.

--*/

{
    return Section->LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\log\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by log.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\log\log.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Tools for logging problems for the user.


Author:

    Jim Schmidt (jimschm)  23-Jan-1997

Revisions:

    ovidiut     08-Oct-1999 Updated for new coding conventions and Win64 compliance
    ovidiut     23-Oct-1998 Implemented a new log mechanism and added new logging capabilities
    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    ovidiut     15-Mar-2000 Eliminate dependencies on HashTable/PoolMemory

--*/


#include "pch.h"

//
// Includes
//

// None

//
// Strings
//

#define S_COLUMNDOUBLELINEA     ":\r\n\r\n"
#define S_COLUMNDOUBLELINEW     L":\r\n\r\n"
#define S_NEWLINEA              "\r\n"
#define S_NEWLINEW              L"\r\n"
#define DEBUG_SECTION           "Debug"
#define ENTRY_ALL               "All"
#define ENTRY_DEFAULTOVERRIDE   "DefaultOverride"

//
// Constants
//

#define OUTPUT_BUFSIZE_LARGE    8192
#define OUTPUT_BUFSIZE_SMALL    1024
#define MAX_MSGTITLE_LEN        13
#define MSGBODY_INDENT          14
#define SCREEN_WIDTH            80
#define MAX_TYPE                32
#define TYPE_ARRAY_SIZE         10

//
// Macros
//

#define OUT_UNDEFINED(OutDest)      (OutDest == OD_UNDEFINED)
#define OUT_DEBUGLOG(OutDest)       ((OutDest & OD_DEBUGLOG) != 0)
#define OUT_SUPPRESSED(OutDest)     ((OutDest & OD_SUPPRESS) != 0)
#define OUT_NO_OUTPUT(OutDest)      (OUT_UNDEFINED(OutDest) || OUT_SUPPRESSED(OutDest))
#define OUT_ERROR(OutDest)          ((OutDest & OD_ERROR) != 0)
#define OUT_LOGFILE(OutDest)        ((OutDest & OD_LOGFILE) != 0)
#define OUT_DEBUGGER(OutDest)       ((OutDest & OD_DEBUGGER) != 0)
#define OUT_CONSOLE(OutDest)        ((OutDest & OD_CONSOLE) != 0)
#define OUT_POPUP(OutDest)          ((OutDest & (OD_POPUP|OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define OUT_POPUP_CANCEL(OutDest)   ((OutDest & (OD_POPUP_CANCEL|OD_FORCE_POPUP)) == OD_POPUP_CANCEL)
#define OUT_FORCED_POPUP(OutDest)   ((OutDest & (OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define MUST_BE_LOCALIZED(OutDest)  ((OutDest & OD_MUST_BE_LOCALIZED) == OD_MUST_BE_LOCALIZED)
#define OUT_ASSERT(OutDest)         ((OutDest & OD_ASSERT) != 0)

#ifdef DEBUG
    #define DEFAULT_ERROR_FLAGS  (OD_DEBUGLOG | OD_LOGFILE | OD_POPUP | OD_ERROR | OD_UNATTEND_POPUP | OD_ASSERT)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP)
#else
    #define DEFAULT_ERROR_FLAGS  (OD_LOGFILE | OD_POPUP | OD_ERROR | OD_MUST_BE_LOCALIZED)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#endif

#define END_OF_BUFFER(buf)      ((buf) + (DWSIZEOF(buf) / DWSIZEOF(buf[0])) - 1)

// This constant sets the default output
#ifndef DEBUG
    #define NORMAL_DEFAULT      OD_LOGFILE
#else
    #define NORMAL_DEFAULT      OD_DEBUGLOG
#endif

#ifdef DEBUG
    #define PRIVATE_ASSERT(expr)        pPrivateAssert(expr,#expr,__LINE__);
#else
    #define PRIVATE_ASSERT(expr)
#endif // DEBUG

#define NEWLINE_CHAR_COUNTA  (DWSIZEOF (S_NEWLINEA) / DWSIZEOF (CHAR) - 1)
#define NEWLINE_CHAR_COUNTW  (DWSIZEOF (S_NEWLINEW) / DWSIZEOF (WCHAR) - 1)

//
// Types
//

typedef DWORD   OUTPUTDEST;

typedef struct {
    PCSTR Value;               // string value entered by the user (LOG,POPUP,SUPPRESS etc.)
    OUTPUTDEST OutDest;        // any combination of OutDest flags
} STRING2BINARY, *PSTRING2BINARY;

typedef struct {
    PCSTR Type;
    DWORD Flags;
} DEFAULT_DESTINATION, *PDEFAULT_DESTINATION;

typedef struct {
    CHAR Type[MAX_TYPE];
    DWORD OutputDest;
} MAPTYPE2OUTDEST, *PMAPTYPE2OUTDEST;

//
// Globals
//

const STRING2BINARY g_String2Binary[] = {
    "SUPPRESS", OD_SUPPRESS,
    "LOG",      OD_LOGFILE,
    "POPUP",    OD_POPUP,
    "DEBUGGER", OD_DEBUGGER,
    "CONSOLE",  OD_CONSOLE,
    "ERROR",    OD_ERROR,
    "NOCANCEL", OD_FORCE_POPUP,
    "ASSERT",   OD_ASSERT
};

const PCSTR g_IgnoreKeys[] = {
    "Debug",
    "KeepTempFiles"
};

BOOL g_LogInit;
HMODULE g_LibHandle;
CHAR g_MainLogFile [MAX_PATH] = "";
HANDLE g_LogMutex;
INT g_LoggingNow;

// a window handle for popup parent
HWND g_LogPopupParentWnd = NULL;
// thread id that set this window handle
DWORD g_InitThreadId = 0;
DWORD g_LogError;

//
// type table elements
//
PMAPTYPE2OUTDEST g_FirstTypePtr = NULL;
DWORD g_TypeTableCount = 0;
DWORD g_TypeTableFreeCount = 0;

OUTPUTDEST g_OutDestAll = OD_UNDEFINED;
OUTPUTDEST g_OutDestDefault = NORMAL_DEFAULT;
BOOL g_HasTitle = FALSE;
CHAR g_LastType [MAX_TYPE];
BOOL g_SuppressAllPopups = FALSE;
BOOL g_ResetLog = FALSE;
PLOGCALLBACKA g_LogCallbackA;
PLOGCALLBACKW g_LogCallbackW;

#ifdef DEBUG

CHAR g_DebugInfPathBufA[] = "C:\\debug.inf";
CHAR g_DebugLogFile[MAX_PATH];
// If g_DoLog is TRUE, then, debug logging is enabled in the
// checked build even if there is no debug.inf.
BOOL g_DoLog = FALSE;

DWORD g_FirstTickCount = 0;
DWORD g_LastTickCount  = 0;

#endif

//
// Macro expansion list
//

#ifndef DEBUG

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_MODULE_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)          \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_STATUS, OD_SUPPRESS)                                         \

#else

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_MODULE_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)          \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(DBG_WHOOPS,  DEFAULT_ERROR_FLAGS)                                \
        DEFMAC(DBG_WARNING, OD_LOGFILE|OD_DEBUGGER)                             \
        DEFMAC(DBG_ASSERT,DEFAULT_ERROR_FLAGS|OD_UNATTEND_POPUP)                \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_STATUS, OD_SUPPRESS)                                         \

#endif


//
// Private function prototypes
//

VOID
InitializeLog (
    VOID
    );


//
// Macro expansion definition
//

/*++

Macro Expansion List Description:

  TYPE_DEFAULTS specify the default destination for the frequently used types,
  such as LOG_ERROR, LOG_FATAL_ERROR, and so on.

Line Syntax:

   DEFMAC(TypeString, Flags)

Arguments:

   TypeString - Specifies the LOG_ constant as defined in log.h

   Flags - One or more of:

           DEFAULT_ERROR_FLAGS - Specifies debug log, setup log, debugger,
                                 popup, and the value of GetLastError.

           OD_DEBUGLOG - Specifies the debug log

           OD_ERROR - Specifies type is an error (gets value of
                      GetLastError)

           OD_SUPPRESS - Suppresses all output for the type

           OD_LOGFILE - Specifies the setup log

           OD_DEBUGGER - Specifies the debugger (i.e., VC or remote debugger)

           OD_CONSOLE - Specifies the console (via printf)

           OD_POPUP - Specifies a message box

           OD_FORCE_POPUP - Specifies a message box, even if debug message
                            was turned off via a click on Cancel

           OD_MUST_BE_LOCALIZED - Indicates the type must originate from a
                                  localized message; used for LOG() calls that
                                  generate popups.  (So English messages
                                  don't sneak into the project.)

           OD_UNATTEND_POPUP - Causes popup even in unattend mode

           OD_ASSERT - Give DebugBreak option in popup

Variables Generated From List:

    g_DefaultDest

--*/

#define DEFMAC(typestr, flags)      {typestr, (flags)},

DEFAULT_DESTINATION g_DefaultDest[] = {
    TYPE_DEFAULTS /* , */
    {NULL, 0}
};

#undef DEFMAC


//
// Code
//


#ifdef DEBUG

VOID
pPrivateAssert (
    IN      BOOL Expr,
    IN      PCSTR StringExpr,
    IN      UINT Line
    )
{
    CHAR buffer[256];

    if (Expr) {
        return;
    }

    wsprintfA (buffer, "LOG FAILURE: %s (log.c line %u)", StringExpr, Line);
    MessageBoxA (NULL, buffer, NULL, MB_OK);
}

#endif


BOOL
pIgnoreKey (
    IN      PCSTR Key
    )

/*++

Routine Description:

  pIgnoreKey decides if a key from [debug] section of DEBUG.INF
  should be ignored for our purposes (we are only looking for
  <All>, <DefaultOverride> and log/debug types).
  Specifically, we ignore all keywords in <g_IgnoreKeys> table.

Arguments:

  Key - Specifies the key from [debug] section of DEBUG.INF

Return Value:

  TRUE if the key should be ignored, or FALSE if it will be taken into consideration.

--*/

{
    UINT i;

    for (i = 0; i < DWSIZEOF (g_IgnoreKeys) / DWSIZEOF (PCSTR); i++) {
        if (StringIMatchA (Key, g_IgnoreKeys[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


OUTPUTDEST
pConvertToOutputType (
    IN      PCSTR Value
    )

/*++

Routine Description:

  pConvertToOutputType converts a text value entered by the user in
  DEBUG.INF file, associated with a type (e.g. "LOG", "POPUP" etc.).

Arguments:

  Value - Specifies the text value

Return Value:

  The OUTPUT_DESTINATION value associated with the given value or
  OD_UNDEFINED if the value is not valid.

--*/

{
    UINT i;

    for (i = 0; i < DWSIZEOF (g_String2Binary) / DWSIZEOF (STRING2BINARY); i++) {
        if (StringIMatchA (Value, g_String2Binary[i].Value)) {
            return g_String2Binary[i].OutDest;
        }
    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDestFromTable (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDestFromTable returns the output destination associated
  with the specified type in the global table

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    PMAPTYPE2OUTDEST typePtr;
    PMAPTYPE2OUTDEST last;
    OUTPUTDEST outDest = OD_UNDEFINED;

    if (g_FirstTypePtr) {
        typePtr = g_FirstTypePtr;
        last = g_FirstTypePtr + g_TypeTableCount;
        while (typePtr < last) {
            if (StringIMatchA (typePtr->Type, Type)) {
                outDest = typePtr->OutputDest;
#ifdef DEBUG
                if (g_DoLog) {
                    outDest |= OD_DEBUGLOG;
                }
#endif
                break;
            }
            typePtr++;
        }
    }

    return outDest;
}


OUTPUTDEST
pGetTypeOutputDest (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDest returns the default output
  destination for the specified type.

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST outDest;

    //
    // first check for ALL
    //

    if (!OUT_UNDEFINED (g_OutDestAll)) {
        outDest = g_OutDestAll;
    } else {

        //
        // otherwise try to get it from the table
        //

        outDest = pGetTypeOutputDestFromTable (Type);
        if (OUT_UNDEFINED (outDest)) {

            //
            // just return the default
            //

            outDest = g_OutDestDefault;
        }
    }

#ifdef DEBUG
    if (g_DoLog) {
        outDest |= OD_DEBUGLOG;
    }
#endif


    return outDest;
}


BOOL
pIsPopupEnabled (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pIsPopupEnabled decides if the type should produce a popup output. The user may
  disable popup display for a type.

Arguments:

  Type - Specifies the type

Return Value:

  TRUE if the type should display a popup message.

--*/

{
    OUTPUTDEST outDest;

    //
    // first check if any specific output is available for this type,
    // and if so, check if the OUT_POPUP_CANCEL flag is not set
    //

    if (g_SuppressAllPopups) {
        return FALSE;
    }

    outDest = pGetTypeOutputDestFromTable (Type);
    if (OUT_POPUP_CANCEL (outDest)) {
        return FALSE;
    }

    // just return the popup type of ALL of DefaultOverride
    return OUT_POPUP (pGetTypeOutputDest (Type));
}


LOGSEVERITY
pGetSeverityFromType (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetSeverityFromType converts a type to a default severity
  that will be used by the debug log system.

Arguments:

  Type - Specifies the type

Return Value:

  The default log severity associated with the given type; if the specified
  type is not found, it returns LOGSEV_INFORMATION.

--*/

{
    if (OUT_ERROR (pGetTypeOutputDest (Type))) {
        return LOGSEV_ERROR;
    }

    return LOGSEV_INFORMATION;
}


BOOL
LogSetErrorDest (
    IN      PCSTR Type,
    IN      OUTPUT_DESTINATION OutDest
    )

/*++

Routine Description:

  LogSetErrorDest adds a <Type, OutDest> association
  to the table g_FirstTypePtr. If an association of Type already exists,
  it is modified to reflect the new association.

Arguments:

  Type - Specifies the log/debug type string

  OutDest - Specifies what new destination(s) are associated with the type

Return Value:

  TRUE if the association was successful and the Type is now in the table

--*/

{
    PMAPTYPE2OUTDEST typePtr;
    UINT u;

    //
    // Try to locate the existing type
    //

    for (u = 0 ; u < g_TypeTableCount ; u++) {
        typePtr = g_FirstTypePtr + u;
        if (StringIMatchA (typePtr->Type, Type)) {
            typePtr->OutputDest = OutDest;
            return TRUE;
        }
    }

    //
    // look if any free slots are available first
    //
    if (!g_TypeTableFreeCount) {

        PRIVATE_ASSERT (g_hHeap != NULL);

        if (!g_FirstTypePtr) {
            typePtr = HeapAlloc (
                            g_hHeap,
                            0,
                            DWSIZEOF (MAPTYPE2OUTDEST) * TYPE_ARRAY_SIZE
                            );
        } else {
            typePtr = HeapReAlloc (
                            g_hHeap,
                            0,
                            g_FirstTypePtr,
                            DWSIZEOF (MAPTYPE2OUTDEST) * (TYPE_ARRAY_SIZE + g_TypeTableCount)
                            );
        }

        if (!typePtr) {
            return FALSE;
        }

        g_FirstTypePtr = typePtr;
        g_TypeTableFreeCount = TYPE_ARRAY_SIZE;
    }

    typePtr = g_FirstTypePtr + g_TypeTableCount;
    StringCopyByteCountA (typePtr->Type, Type, DWSIZEOF (typePtr->Type));
    typePtr->OutputDest = OutDest;

    g_TypeTableCount++;
    g_TypeTableFreeCount--;

    return TRUE;
}


OUTPUTDEST
pGetAttributes (
    IN OUT  PINFCONTEXT InfContext
    )

/*++

Routine Description:

  pGetAttributes converts the text values associated with the key on
  the line specified by the given context. If multiple values are
  specified, the corresponding OUTPUT_DESTINATION values are ORed together
  in the return value.

Arguments:

  InfContext - Specifies the DEBUG.INF context of the key whose values
               are being converted and receives the updated context
               after this processing is done

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given key.

--*/

{
    OUTPUTDEST outDest = OD_UNDEFINED;
    CHAR value[OUTPUT_BUFSIZE_SMALL];
    UINT field;

    for (field = SetupGetFieldCount (InfContext); field > 0; field--) {
        if (SetupGetStringFieldA (
                InfContext,
                field,
                value,
                OUTPUT_BUFSIZE_SMALL,
                NULL
                )) {
            outDest |= pConvertToOutputType(value);
        }
    }

    return outDest;
}


BOOL
pGetUserPreferences (
    IN      HINF Inf
    )

/*++

Routine Description:

  pGetUserPreferences converts user's options specified in the given Inf file
  (usually DEBUG.INF) and stores them in g_FirstTypePtr table. If <All> and
  <DefaultOverride> entries are found, their values are stored in OutputTypeAll
  and OutputTypeDefault, respectivelly, if not NULL.

Arguments:

  Inf - Specifies the open inf file hanlde to process

  OutputTypeAll - Receives the Output Dest for the special <All> entry

  OutputTypeDefault - Receives the Output Dest for the special <DefaultOverride> entry

Return Value:

  TRUE if the processing of the INF file was OK.

--*/

{
    INFCONTEXT infContext;
    OUTPUTDEST outDest;
    CHAR key[OUTPUT_BUFSIZE_SMALL];

    if (SetupFindFirstLineA (Inf, DEBUG_SECTION, NULL, &infContext)) {

        do {
            // check to see if this key is not interesting
            if (!SetupGetStringFieldA (
                    &infContext,
                    0,
                    key,
                    OUTPUT_BUFSIZE_SMALL,
                    NULL
                    )) {
                continue;
            }

            if (pIgnoreKey (key)) {
                continue;
            }

            // check for special cases
            if (StringIMatchA (key, ENTRY_ALL)) {
                g_OutDestAll = pGetAttributes (&infContext);
                // no reason to continue since ALL types will take this setting...
                break;
            } else {
                if (StringIMatchA (key, ENTRY_DEFAULTOVERRIDE)) {
                    g_OutDestDefault = pGetAttributes(&infContext);
                } else {
                    outDest = pGetAttributes(&infContext);
                    // lines like <Type>=   or like <Type>=<not a keyword(s)>  are ignored
                    if (!OUT_UNDEFINED (outDest)) {
                        if (!LogSetErrorDest (key, outDest)) {
                            return FALSE;
                        }
                    }
                }
            }
        } while (SetupFindNextLine (&infContext, &infContext));
    }

    return TRUE;
}


/*++

Routine Description:

  pPadTitleA and pPadTitleW append to Title a specified number of spaces.

Arguments:

  Title - Specifies the title (it will appear on the left column).
          The buffer must be large enough to hold the additional spaces
  Indent  - Specifies the indent of the message body. If necessary,
            spaces will be appended to the Title to get to Indent column.

Return Value:

  none

--*/

VOID
pPadTitleA (
    IN OUT  PSTR Title,
    IN      UINT Indent
    )

{
    UINT i;
    PSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = ByteCountA (Title), p = GetEndOfStringA (Title); i < Indent; i++) {
        *p++ = ' '; //lint !e613 !e794
    }

    *p = 0; //lint !e613 !e794
}


VOID
pPadTitleW (
    IN OUT  PWSTR Title,
    IN      UINT  Indent
    )
{
    UINT i;
    PWSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = CharCountW (Title), p = GetEndOfStringW (Title); i < Indent; i++) {
        *p++ = L' ';    //lint !e613
    }

    *p = 0; //lint !e613
}


/*++

Routine Description:

  pFindNextLineA and pFindNextLineW return the position where
  the next line begins

Arguments:

  Line - Specifies the current line

  Indent  - Specifies the indent of the message body. The next line
            will start preferably after a newline or a white space,
            but no further than the last column, which is
            SCREEN_WIDTH - Indent.

Return Value:

  The position of the first character on the next line.

--*/

PCSTR
pFindNextLineA (
    IN      PCSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCSTR lastSpace = NULL;
    PCSTR prevLine = Line;
    UINT ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = _mbsnextc (Line)) != 0 && column < columnMax) {

        if (ch == '\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
            column++;
        } else {
            if (_ismbcspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line = _mbsinc (Line);
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space or 2-byte char was found
        lastSpace = prevLine;
    }

    if (ch != '\n') {
        *TrimLeadingSpace = TRUE;
    }

    return _mbsinc (lastSpace);
}


PCWSTR
pFindNextLineW (
    IN      PCWSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCWSTR lastSpace = NULL;
    PCWSTR prevLine = Line;
    WCHAR ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = *Line) != 0 && column < columnMax) {

        if (ch == L'\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
        } else {
            if (iswspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line++;
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space was found
        lastSpace = prevLine;
    }

    if (ch != L'\n') {
        *TrimLeadingSpace = TRUE;
    }

    return lastSpace + 1;
}


/*++

Routine Description:

  pHangingIndentA and pHangingIndentW break in lines and indent
  the text in buffer, which is no larger than Size.

Arguments:

  buffer - Specifies the buffer containing text to format. The resulting
           text will be put in the same buffer

  Size  - Specifies the size of this buffer, in bytes

  Indent  - Specifies the indent to be used by all new generated lines.

Return Value:

  none

--*/

VOID
pHangingIndentA (
    IN OUT  PSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    CHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCSTR nextLine;
    PCSTR s;
    PSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 3;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PSTR)pFindNextLineA (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case '\r':
                s++;
                if (*s == '\r') {
                    continue;
                } else if (*s != '\n') {
                    s--;
                }

                // fall through

            case '\n':
                *d++ = '\r';
                *d++ = '\n';
                s++;
                break;

            default:
                if (IsLeadByte (s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == ' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = ' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyByteCountA (buffer, indentBuffer, Size);
}


VOID
pHangingIndentW (
    IN OUT  PWSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    WCHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCWSTR nextLine;
    PCWSTR s;
    PWSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCWSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 1;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PWSTR)pFindNextLineW (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case L'\r':
                s++;
                if (*s == L'\r') {
                    continue;
                } else if (*s != L'\n') {
                    s--;
                }

                // fall through

            case L'\n':
                *d++ = L'\r';
                *d++ = L'\n';
                s++;
                break;

            default:
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == L' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = L' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyCharCountW (buffer, indentBuffer, Size);
}


/*++

Routine Description:

  pAppendLastErrorA and pAppendLastErrorW append the specified error code
  to the Message and writes the output to the MsgWithErr buffer.

Arguments:

  MsgWithErr  - Receives the formatted message. This buffer
                is supplied by caller

  BufferSize  - Specifies the size of the buffer, in bytes

  Message  - Specifies the body of the message

  LastError  - Specifies the error code that will be appended

Return Value:

  none

--*/

VOID
pAppendLastErrorA (
    OUT     PSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCSTR Message,
    IN      DWORD LastError
    )
{
    PSTR append;
    DWORD errMsgLen;

    StringCopyByteCountA (MsgWithErr, Message, BufferSize);
    append = GetEndOfStringA (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + BufferSize - append);  //lint !e613

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snprintf (append, errMsgLen, " [ERROR=%lu]", LastError);
        } else {
            _snprintf (append, errMsgLen, " [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


VOID
pAppendLastErrorW (
    OUT     PWSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCWSTR Message,
    IN      DWORD LastError
    )
{
    PWSTR append;
    DWORD errMsgLen;

    StringCopyCharCountW (MsgWithErr, Message, BufferSize / DWSIZEOF(WCHAR));
    append = GetEndOfStringW (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + (BufferSize / DWSIZEOF(WCHAR)) - append);

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu]", LastError);
        } else {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


/*++

Routine Description:

  pIndentMessageA and pIndentMessageW format the specified message
  with the type in the left column and body of the message in the right.

Arguments:

  formattedMsg  - Receives the formatted message. This buffer
                  is supplied by caller

  BufferSize  - Specifies the size of the buffer

  Type  - Specifies the type of the message

  Body  - Specifies the body of the message

  Indent  - Specifies the column to indent to

  LastError  - Specifies the last error code if different than ERROR_SUCCESS;
               in this case it will be appended to the message

Return Value:

  none

--*/

VOID
pIndentMessageA (
    OUT     PSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    CHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR myMsgBody;
    PSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorA (bodyWithErr, DWSIZEOF (bodyWithErr), Body, LastError);
    }

    StringCopyByteCountA (formattedMsg, Type, MAX_MSGTITLE_LEN);
    pPadTitleA (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    StringCopyByteCountA (currentPos, myMsgBody, remaining);
    pHangingIndentA (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = GetEndOfStringA (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTA + 1 < formattedMsg + BufferSize) { //lint !e613
        *currentPos++ = '\r';   //lint !e613
        *currentPos++ = '\n';   //lint !e613
        *currentPos = 0;        //lint !e613
    }
}


VOID
pIndentMessageW (
    OUT     PWSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCWSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];
    WCHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR myMsgBody;
    PWSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorW (bodyWithErr, DWSIZEOF (bodyWithErr), Body, LastError);
    }

    KnownSizeAtoW (typeW, Type);

    StringCopyCharCountW (formattedMsg, typeW, MAX_MSGTITLE_LEN);
    pPadTitleW (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    StringCopyCharCountW (currentPos, myMsgBody, remaining);
    pHangingIndentW (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = GetEndOfStringW (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTW + 1 < formattedMsg + BufferSize) {
        *currentPos++ = L'\r';
        *currentPos++ = L'\n';
        *currentPos = 0;
    }
}


PCSTR
pGetSeverityStr (
    IN      LOGSEVERITY Severity,
    IN      BOOL Begin
    )
{
    switch (Severity) {
    case LogSevFatalError:
        return Begin?"":"\r\n***";
    case LogSevError:
        return Begin?"":"\r\n***";
    case LogSevWarning:
        return "";
    }
    return "";
}

/*++

Routine Description:

  pWriteToMainLogA and pWriteToMainLogW log the specified message to the main
  end-user log.

Arguments:

  Severity  - Specifies the severity of the message, as defined by the Setup API

  formattedMsg  - Specifies the message

Return Value:

  none

--*/


VOID
pWriteToMainLogA (
    IN      PCSTR Type,
    IN      LOGSEVERITY Severity,
    IN      PCSTR FormattedMsg
    )
{
    HANDLE logHandle = NULL;

    logHandle = CreateFileA (
                    g_MainLogFile,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (logHandle != INVALID_HANDLE_VALUE) {
        SetFilePointer (logHandle, 0, NULL, FILE_END);
        WriteFileStringA (logHandle, pGetSeverityStr (Severity, TRUE));
        WriteFileStringA (logHandle, FormattedMsg);
        WriteFileStringA (logHandle, pGetSeverityStr (Severity, FALSE));
        CloseHandle (logHandle);
    }
}


VOID
pWriteToMainLogW (
    IN      PCSTR Type,
    IN      LOGSEVERITY Severity,
    IN      PCWSTR FormattedMsg
    )
{
    HANDLE logHandle = NULL;

    logHandle = CreateFileA (
                    g_MainLogFile,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (logHandle != INVALID_HANDLE_VALUE) {
        SetFilePointer (logHandle, 0, NULL, FILE_END);
        WriteFileStringA (logHandle, pGetSeverityStr (Severity, TRUE));
        WriteFileStringW (logHandle, FormattedMsg);
        WriteFileStringA (logHandle, pGetSeverityStr (Severity, FALSE));
        CloseHandle (logHandle);
    }
}


/*++

Routine Description:

  pDisplayPopupA and pDisplayPopupW displays the specified message to
  a popup window, if <g_LogPopupParentWnd> is not NULL (attended mode).

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

  LastError  - Specifies the last error; it will be printed if != ERROR_SUCCESS

  Forced - Specifies TRUE to force the popup, even in unattended mode

Return Value:

  none

--*/

VOID
pDisplayPopupA (
    IN      PCSTR Type,
    IN      PCSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
#ifdef DEBUG
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    CHAR buffer[OUTPUT_BUFSIZE_SMALL];
    PSTR currentPos = buffer;
#endif
    UINT mbStyle;
    LONG rc;
    OUTPUTDEST outDest;
    HWND parentWnd;
    PCSTR displayMessage = Msg;
    LOGSEVERITY severity = pGetSeverityFromType (Type);

    outDest = pGetTypeOutputDest (Type);

    if (g_LogPopupParentWnd || Forced) {

#ifdef DEBUG
        if (LastError != ERROR_SUCCESS) {
            if (LastError < 10) {
                currentPos += wsprintfA (buffer, " [ERROR=%u]", LastError);
            } else {
                currentPos += wsprintfA (buffer, " [ERROR=%u (%Xh)]", LastError, LastError);
            }
        }

        if (OUT_ASSERT (outDest)) {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\nBreak now? (Hit Yes to break, No to continue, or Cancel to disable '%s' message boxes)",
                            Type
                            );
        } else {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\n(Hit Cancel to disable '%s' message boxes)",
                            Type
                            );
        }

        if (currentPos > buffer) {

            //
            // the displayed message should be modified to include additional info
            //

            displayMessage = formattedMsg;
            StringCopyByteCountA (
                formattedMsg,
                Msg,
                ARRAYSIZE(formattedMsg) - (HALF_PTR) (currentPos - buffer)
                );
            StringCatA (formattedMsg, buffer);
        }
#endif

        switch (severity) {

        case LOGSEV_FATAL_ERROR:
            mbStyle = MB_ICONSTOP;
            break;

        case LOGSEV_ERROR:
            mbStyle = MB_ICONERROR;
            break;

        case LOGSEV_WARNING:
            mbStyle = MB_ICONEXCLAMATION;
            break;

        default:
            mbStyle = MB_ICONINFORMATION;

        }
        mbStyle |= MB_SETFOREGROUND;

#ifdef DEBUG
        if (OUT_ASSERT (outDest)) {
            mbStyle |= MB_YESNOCANCEL|MB_DEFBUTTON2;
        } else {
            mbStyle |= MB_OKCANCEL;
        }
#else
        mbStyle |= MB_OK;
#endif

        //
        // check current thread id; if different than thread that initialized
        // parent window handle, set parent to NULL
        //
        if (GetCurrentThreadId () == g_InitThreadId) {

            parentWnd = g_LogPopupParentWnd;

        } else {

            parentWnd = NULL;

        }

        rc = MessageBoxA (parentWnd, displayMessage, Type, mbStyle);

#ifdef DEBUG

        if (rc == IDCANCEL) {
            //
            // cancel this type of messages
            //

            LogSetErrorDest (Type, outDest | OD_POPUP_CANCEL);

        } else if (rc == IDYES) {

            //
            // If Yes was clicked, call DebugBreak to get assert behavoir
            //

            DebugBreak();

        }
#endif

    }
}


VOID
pDisplayPopupW (
    IN      PCSTR Type,
    IN      PWSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
    PCSTR msgA;

    //
    // call the ANSI version because wsprintfW is not properly implemented on Win9x
    //
    msgA = ConvertWtoA (Msg);
    pDisplayPopupA (Type, msgA, LastError, Forced);
    FreeConvertedStr (msgA);
}


/*++

Routine Description:

  pRawWriteLogOutputA and pRawWriteLogOutputW output specified message
  to all character devices implied by the type. The message is not
  formatted in any way

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

Return Value:

  none

--*/

VOID
pRawWriteLogOutputA (
    IN      PCSTR Type,
    IN      PCSTR Message,
    IN      PCSTR formattedMsg,
    IN      BOOL NoMainLog
    )
{
    OUTPUTDEST outDest;
    LOGARGA callbackArgA;
    LOGARGW callbackArgW;
    static BOOL inCallback = FALSE;
#ifdef DEBUG
    HANDLE handle;
#endif

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (!inCallback && (g_LogCallbackA || g_LogCallbackW)) {

        inCallback = TRUE;

        if (g_LogCallbackA) {
            ZeroMemory (&callbackArgA, sizeof (callbackArgA));
            callbackArgA.Type = Type;
            callbackArgA.ModuleInstance = g_LibHandle;
            callbackArgA.Message = Message;
            callbackArgA.FormattedMessage = formattedMsg;
            callbackArgA.Debug = NoMainLog;

            g_LogCallbackA (&callbackArgA);
        } else {
            ZeroMemory (&callbackArgW, sizeof (callbackArgW));
            callbackArgW.Type = Type;
            callbackArgW.ModuleInstance = g_LibHandle;
            callbackArgW.Message = ConvertAtoW (Message);
            callbackArgW.FormattedMessage = ConvertAtoW (formattedMsg);
            callbackArgW.Debug = NoMainLog;

            g_LogCallbackW (&callbackArgW);

            if (callbackArgW.Message) {
                FreeConvertedStr (callbackArgW.Message);
            }
            if (callbackArgW.FormattedMessage) {
                FreeConvertedStr (callbackArgW.FormattedMessage);
            }
        }

        inCallback = FALSE;
        return;
    }

    if (!NoMainLog && OUT_LOGFILE (outDest)) {
        pWriteToMainLogA (Type, LOGSEV_INFORMATION, formattedMsg);
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringA (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fprintf (stderr, "%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                            g_DebugLogFile,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringA (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif
}


VOID
pRawWriteLogOutputW (
    IN      PCSTR Type,
    IN      PCWSTR Message,
    IN      PCWSTR formattedMsg,
    IN      BOOL NoMainLog
    )
{
    OUTPUTDEST outDest;
    LOGARGA callbackArgA;
    LOGARGW callbackArgW;
    static BOOL inCallback = FALSE;
#ifdef DEBUG
    HANDLE handle;
#endif

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (!inCallback && (g_LogCallbackA || g_LogCallbackW)) {

        inCallback = TRUE;

        if (g_LogCallbackW) {
            ZeroMemory (&callbackArgW, sizeof (callbackArgW));
            callbackArgW.Type = Type;
            callbackArgW.ModuleInstance = g_LibHandle;
            callbackArgW.Message = Message;
            callbackArgW.FormattedMessage = formattedMsg;
            callbackArgW.Debug = NoMainLog;

            g_LogCallbackW (&callbackArgW);
        } else {
            ZeroMemory (&callbackArgA, sizeof (callbackArgA));
            callbackArgA.Type = Type;
            callbackArgA.ModuleInstance = g_LibHandle;
            callbackArgA.Message = ConvertWtoA (Message);
            callbackArgA.FormattedMessage = ConvertWtoA (formattedMsg);
            callbackArgA.Debug = NoMainLog;

            g_LogCallbackA (&callbackArgA);

            if (callbackArgA.Message) {
                FreeConvertedStr (callbackArgA.Message);
            }
            if (callbackArgA.FormattedMessage) {
                FreeConvertedStr (callbackArgA.FormattedMessage);
            }
        }

        inCallback = FALSE;
        return;
    }

    if (!NoMainLog && OUT_LOGFILE (outDest)) {
        pWriteToMainLogW (Type, LOGSEV_INFORMATION, formattedMsg);
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringW (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fwprintf (stderr, L"%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                        g_DebugLogFile,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringW (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif
}


/*++

Routine Description:

  pFormatAndWriteMsgA and pFormatAndWriteMsgW format the message
  specified by the Format argument and outputs it to all destinations
  specified in OutDest. If no destination for the message,
  no action is performed.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  args  - Specifies a list of arguments to be used when formatting
          the message. If a message ID is used for Format, args
          is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
pFormatAndWriteMsgA (
    IN      BOOL NoMainLog,
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    PRIVATE_ASSERT (g_LoggingNow > 0);

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((UBINT)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageA (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_LibHandle,
                (DWORD)(UBINT) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID, Instance=0x%08X", g_LibHandle));
            return;
        }
    } else {

        //
        // format given string using printf style
        //

        _vsnprintf(output, OUTPUT_BUFSIZE_LARGE, Format, args);
        output [OUTPUT_BUFSIZE_LARGE - 1] = 0;
    }

    pIndentMessageA (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputA (Type, output, formattedMsg, NoMainLog);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (
                !MUST_BE_LOCALIZED (outDest) ||
                (SHIFTRIGHT16((UBINT)Format) == 0)
                );
        }

        pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((UBINT)Format) == 0) {
            pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


VOID
pFormatAndWriteMsgW (
    IN      BOOL NoMainLog,
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    WCHAR formatW[OUTPUT_BUFSIZE_LARGE];
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    PRIVATE_ASSERT (g_LoggingNow > 0);

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((UBINT)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_LibHandle,
                (DWORD)(UBINT) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID, Instance=0x%08X", g_LibHandle));
            return;
        }
    } else {
        KnownSizeAtoW (formatW, Format);

        //
        // format given string using printf style
        //

        _vsnwprintf(output, OUTPUT_BUFSIZE_LARGE, formatW, args);
        output [OUTPUT_BUFSIZE_LARGE - 1] = 0;
    }

    pIndentMessageW (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputW (Type, output, formattedMsg, NoMainLog);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (SHIFTRIGHT16((UBINT)Format) == 0);
        }

        pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((UBINT)Format) == 0) {
            pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


BOOL
pInitLog (
    IN      BOOL FirstTimeInit,
    IN      HWND LogPopupParentWnd,     OPTIONAL
    OUT     HWND *OrgPopupParentWnd,    OPTIONAL
    IN      PCSTR LogFile,              OPTIONAL
    IN      PLOGCALLBACKA LogCallbackA, OPTIONAL
    IN      PLOGCALLBACKW LogCallbackW  OPTIONAL
    )

/*++

Routine Description:

  pInitLog actually initializes the log system.

Arguments:

  LogPopupParentWnd  - Specifies the parent window to be used by the
                       popups, or NULL if popups are to be suppressed.
                       This value is not optional on the first call
                       to this function.

  OrgPopupParentWnd  - Receives the original parent window.

  LogFile - Specifies the name of the log file. If not specified,
            logging goes to a default file (%windir%\cobra.log).

  LogCallback - Specifies a function to call instead of the internal
                logging functions.

Return Value:

  TRUE if log system successfully initialized

--*/

{
    HINF hInf = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;
    PDEFAULT_DESTINATION dest;
#ifdef DEBUG
    PSTR p;
#endif

    __try {

        g_LogInit = FALSE;

        if (FirstTimeInit) {
            PRIVATE_ASSERT (!g_FirstTypePtr);

            dest = g_DefaultDest;

            while (dest->Type) {
                LogSetErrorDest (dest->Type, dest->Flags);
                dest++;
            }

            GetWindowsDirectoryA (g_MainLogFile, ARRAYSIZE(g_MainLogFile));
            StringCatA (g_MainLogFile, "\\cobra");

#ifdef DEBUG
            StringCopyA (g_DebugLogFile, g_MainLogFile);
            StringCatA (g_DebugLogFile, ".dbg");
            g_DebugInfPathBufA[0] = g_DebugLogFile[0];
#endif

            StringCatA (g_MainLogFile, ".log");
        }

        if (LogFile) {
            StackStringCopyA (g_MainLogFile, LogFile);

#ifdef DEBUG
            StringCopyA (g_DebugLogFile, g_MainLogFile);
            p = _mbsrchr (g_DebugLogFile, '.');
            if (p) {
                if (_mbschr (p, TEXT('\\'))) {
                    p = NULL;
                }
            }

            if (p) {
                StringCopyA (p, ".dbg");
            } else {
                StringCatA (g_DebugLogFile, ".dbg");
            }


#endif
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_MainLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_MainLogFile);
        }

#ifdef DEBUG
        if (g_ResetLog) {
            SetFileAttributesA (g_DebugLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogFile);
        }
#endif

        if (LogCallbackA) {
            g_LogCallbackA = LogCallbackA;
        }

        if (LogCallbackW) {
            g_LogCallbackW = LogCallbackW;
        }

#ifdef DEBUG
        if (FirstTimeInit) {
            //
            // get user's preferences
            //

            hInf = SetupOpenInfFileA (g_DebugInfPathBufA, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
            if (INVALID_HANDLE_VALUE != hInf && pGetUserPreferences(hInf)) {
                g_DoLog = TRUE;
            }
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_DebugLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogFile);
        }
#endif

        if (OrgPopupParentWnd) {
            *OrgPopupParentWnd = g_LogPopupParentWnd;
        }

        if (LogPopupParentWnd) {
            g_LogPopupParentWnd = LogPopupParentWnd;
            g_InitThreadId = GetCurrentThreadId ();
        }

        result = TRUE;
    }
    __finally {

        if (hInf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (hInf);
        }

        if (!result) {  //lint !e774

            if (g_FirstTypePtr) {
                HeapFree (g_hHeap, 0, g_FirstTypePtr);
                g_FirstTypePtr = NULL;
                g_TypeTableCount = 0;
                g_TypeTableFreeCount = 0;
            }

            g_OutDestAll = OD_UNDEFINED;
            g_OutDestDefault = OD_UNDEFINED;

#ifdef DEBUG
            g_DoLog = FALSE;
#endif
        }

        g_LogInit = TRUE;
        g_ResetLog = FALSE;
    }

    return result;
}


VOID
LogSetVerboseLevel (
    IN      OUTPUT_DESTINATION Level
    )
{
    OUTPUT_DESTINATION Debugger = 0;

    if (Level > 3) {
        Debugger = OD_DEBUGGER|OD_ASSERT;
    }

    LogSetErrorDest (LOG_FATAL_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_MODULE_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_WARNING, Level > 1 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_INFORMATION, Level > 2 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    LogSetErrorDest ("Assert", OD_POPUP|OD_ERROR|Debugger);
    LogSetErrorDest ("Verbose", Level > 2 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
}

VOID
LogSetVerboseBitmap (
    IN      LOG_LEVEL Bitmap,
    IN      LOG_LEVEL BitsToAdjustMask,
    IN      BOOL EnableDebugger
    )
{

    OUTPUT_DESTINATION Debugger = 0;

    if (EnableDebugger) {
        Debugger = OD_DEBUGGER|OD_ASSERT;
    }

    if (BitsToAdjustMask & LL_FATAL_ERROR) {
        LogSetErrorDest (LOG_FATAL_ERROR, (Bitmap & LL_FATAL_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_MODULE_ERROR) {
        LogSetErrorDest (LOG_MODULE_ERROR, (Bitmap & LL_MODULE_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_ERROR) {
        LogSetErrorDest (LOG_ERROR, (Bitmap & LL_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_WARNING) {
        LogSetErrorDest (LOG_WARNING, (Bitmap & LL_WARNING) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_INFORMATION) {
        LogSetErrorDest (LOG_INFORMATION, (Bitmap & LL_INFORMATION) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_STATUS) {
        LogSetErrorDest (LOG_STATUS, (Bitmap & LL_STATUS) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_UPDATE) {
        LogSetErrorDest (LOG_UPDATE, (Bitmap & LL_UPDATE) ? OD_CONSOLE : OD_SUPPRESS);
    }
}


/*++

Routine Description:

  pInitialize initializes the log system calling the worker pInitLog. This function
  should be only called once

Arguments:
  None

Return Value:

  TRUE if log system successfully initialized

--*/

BOOL
pInitialize (
    VOID
    )
{
    return pInitLog (TRUE, NULL, NULL, NULL, NULL, NULL);
}

/*++

Routine Description:

  LogReInit re-initializes the log system calling the worker pInitLog.
  This function may be called any number of times, but only after pInitialize()

Arguments:

  NewParent - Specifies the new parent handle.

  OrgParent - Receives the old parent handle.

  LogFile - Specifies a new log file name

  LogCallback - Specifies a callback function that handles the log message (so
                one module can pass log messages to another)

  ResourceImage - Specifies the module path to use in FormatMessage when the
                  message is resource-based

Return Value:

  TRUE if log system was successfully re-initialized

--*/

BOOL
LogReInitA (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCSTR LogFile,              OPTIONAL
    IN      PLOGCALLBACKA LogCallback   OPTIONAL
    )
{
    return pInitLog (FALSE, NewParent, OrgParent, LogFile, LogCallback, NULL);
}


BOOL
LogReInitW (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCWSTR LogFile,             OPTIONAL
    IN      PLOGCALLBACKW LogCallback   OPTIONAL
    )
{
    CHAR ansiLogFile[MAX_MBCHAR_PATH];

    if (LogFile) {
        KnownSizeWtoA (ansiLogFile, LogFile);
        LogFile = (PWSTR) ansiLogFile;
    }

    return pInitLog (FALSE, NewParent, OrgParent, (PCSTR) LogFile, NULL, LogCallback);
}


VOID
LogBegin (
    IN      HMODULE ModuleInstance
    )
{
    DWORD threadError;
    DWORD rc;

    threadError = GetLastError ();

    if (!g_LogMutex) {
        InitializeLog();
    }

    rc = WaitForSingleObject (g_LogMutex, INFINITE);

    PRIVATE_ASSERT (rc == WAIT_OBJECT_0 || rc == WAIT_ABANDONED);

    if (rc == WAIT_ABANDONED) {
        g_LoggingNow = 0;
    }

    if (!g_LoggingNow) {
        g_LibHandle = ModuleInstance;
        SetLastError (threadError);
        g_LogError = threadError;
    }

    g_LoggingNow++;
}

VOID
LogEnd (
    VOID
    )
{
    g_LoggingNow--;

    if (!g_LoggingNow) {
        g_LibHandle = g_hInst;
        SetLastError (g_LogError);
    }

    ReleaseMutex (g_LogMutex);
}


VOID
pDisableLog (
    VOID
    )
{
    g_LogInit = FALSE;
}


VOID
pExitLog (
    VOID
    )

/*++

Routine Description:

  pExitLog cleans up any resources used by the log system

Arguments:

  none

Return Value:

  none

--*/

{
    g_LogInit = FALSE;

    WaitForSingleObject (g_LogMutex, 60000);
    CloseHandle (g_LogMutex);
    g_LogMutex = NULL;

    if (g_FirstTypePtr) {
        HeapFree (g_hHeap, 0, g_FirstTypePtr);
        g_FirstTypePtr = NULL;
        g_TypeTableCount = 0;
        g_TypeTableFreeCount = 0;
    }

    g_OutDestAll = OD_UNDEFINED;
    g_OutDestDefault = OD_UNDEFINED;
}


/*++

Routine Description:

  LogA and LogW preserve the last error code; they call the helpers
  pFormatAndWriteMsgA and pFormatAndWriteMsgW respectivelly.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


#ifdef DEBUG

VOID
_cdecl
DbgLogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}

#endif

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title         OPTIONAL
    )
{
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];

    if (!g_LogInit) {
        return;
    }

    StringCopyByteCountA (g_LastType, Type, DWSIZEOF (g_LastType));

    if (!Title) {
        Title = Type;
    }

    StringCopyByteCountA (formattedMsg, Title, DWSIZEOF (formattedMsg) - DWSIZEOF (S_COLUMNDOUBLELINEA));
    StringCatA (formattedMsg, S_COLUMNDOUBLELINEA);

    pRawWriteLogOutputA (Type, NULL, formattedMsg, FALSE);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title        OPTIONAL
    )
{
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];

    if (!g_LogInit) {
        return;
    }

    StringCopyCharCountA (g_LastType, Type, DWSIZEOF (g_LastType));

    if (!Title) {
        KnownSizeAtoW (typeW, Type);
        Title = typeW;
    }

    StringCopyCharCountW (formattedMsg, Title, DWSIZEOF (formattedMsg) - DWSIZEOF (S_COLUMNDOUBLELINEW));
    StringCatW (formattedMsg, S_COLUMNDOUBLELINEW);

    pRawWriteLogOutputW (Type, NULL, formattedMsg, FALSE);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogLineA (
    IN      PCSTR Line
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCSTR p;

    if (!g_LogInit) {
        return;
    }

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyByteCountA (output, Line, DWSIZEOF (output) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = _mbsstr (output, S_NEWLINEA); p; p = _mbsstr (p + NEWLINE_CHAR_COUNTA, S_NEWLINEA)) {
        if (p[NEWLINE_CHAR_COUNTA] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        StringCatA (output, S_NEWLINEA);
    }

    pRawWriteLogOutputA (g_LastType, NULL, output, FALSE);
}


VOID
LogLineW (
    IN      PCWSTR Line
    )
{
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCWSTR p;

    if (!g_LogInit) {
        return;
    }

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyCharCountW (output, Line, DWSIZEOF (output) / DWSIZEOF (WCHAR) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = wcsstr (output, S_NEWLINEW); p; p = wcsstr (p + NEWLINE_CHAR_COUNTW, S_NEWLINEW)) {
        if (p[NEWLINE_CHAR_COUNTW] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        StringCatW (output, S_NEWLINEW);
    }

    pRawWriteLogOutputW (g_LastType, NULL, output, FALSE);
}


VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text, FALSE);
}


VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text, FALSE);
}


#ifdef DEBUG
VOID
DbgDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text, TRUE);
}


VOID
DbgDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text, TRUE);
}
#endif


VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    )
{
    g_SuppressAllPopups = SuppressOn;
}


#ifdef DEBUG

/*++

Routine Description:

  DebugLogTimeA and DebugLogTimeW preserve the last error code;
  they append the current date and time to the formatted message,
  then call LogA and LogW to actually process the message.

Arguments:

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    )
{
    CHAR msg[OUTPUT_BUFSIZE_LARGE];
    CHAR date[OUTPUT_BUFSIZE_SMALL];
    CHAR ttime[OUTPUT_BUFSIZE_SMALL];
    PSTR appendPos, end;
    DWORD currentTickCount;
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!g_DoLog) {
        return;
    }

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            date,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (date,"** Error retrieving date. **");
    }

    if (!GetTimeFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            ttime,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (ttime,"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }


    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    appendPos = msg + _vsnprintf (msg, OUTPUT_BUFSIZE_LARGE, Format, args);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    end = msg + OUTPUT_BUFSIZE_LARGE;
    _snprintf(
        appendPos,
        ((UBINT)end - (UBINT)appendPos) / (DWSIZEOF (CHAR)),
        "\nCurrent Date and Time: %s %s\n"
        "Milliseconds since last DEBUGLOGTIME call : %u\n"
        "Milliseconds since first DEBUGLOGTIME call: %u\n",
        date,
        ttime,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogA (DBG_TIME, "%s", msg);
}


VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    )
{
    WCHAR msgW[OUTPUT_BUFSIZE_LARGE];
    WCHAR dateW[OUTPUT_BUFSIZE_SMALL];
    WCHAR timeW[OUTPUT_BUFSIZE_SMALL];
    PCWSTR formatW;
    PWSTR appendPosW, endW;
    DWORD currentTickCount;
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!g_DoLog) {
        return;
    }

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            dateW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (dateW, L"** Error retrieving date. **");
    }

    if (!GetTimeFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            timeW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (timeW, L"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    formatW = ConvertAtoW (Format);
    appendPosW = msgW + _vsnwprintf (msgW, OUTPUT_BUFSIZE_LARGE, formatW, args);
    FreeConvertedStr (formatW);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    endW = msgW + OUTPUT_BUFSIZE_LARGE;
    _snwprintf(
        appendPosW,
        ((UBINT)endW - (UBINT)appendPosW) / (DWSIZEOF (WCHAR)),
        L"\nCurrent Date and Time: %s %s\n"
        L"Milliseconds since last DEBUGLOGTIME call : %u\n"
        L"Milliseconds since first DEBUGLOGTIME call: %u\n",
        dateW,
        timeW,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogW (DBG_TIME, "%s", msgW);
}

#endif // DEBUG


VOID
InitializeLog (
    VOID
    )
{
    g_LogMutex = CreateMutex (NULL, FALSE, TEXT("cobra_log_mutex"));
    UtInitialize (NULL);
    pInitialize ();
}


EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
        g_LibHandle = hInstance;
        InitializeLog ();

        PRIVATE_ASSERT (g_LogMutex != NULL);
    }

    return TRUE;
}

VOID
LogDeleteOnNextInit(
    VOID
    )
{
    g_ResetLog = TRUE;
}

#ifdef DEBUG

VOID
LogCopyDebugInfPathA(
    OUT     PSTR MaxPathBuffer
    )
{
    StringCopyByteCountA (MaxPathBuffer, g_DebugInfPathBufA, MAX_PATH);
}


VOID
LogCopyDebugInfPathW(
    OUT     PWSTR MaxPathBuffer
    )
{
    KnownSizeAtoW (MaxPathBuffer, g_DebugInfPathBufA);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\ini\ini.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ini.c

Abstract:

    Provides wrappers for commonly used INI file handling routines.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_INILIB      "IniLib"

//
// Strings
//

// None

//
// Constants
//

#define INITIAL_BUFFER_CHAR_COUNT   256

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_IniLibPool;
INT g_IniRefs;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
Ini_Init (
    VOID
    )

/*++

Routine Description:

    Ini_Init initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    MYASSERT (g_IniRefs >= 0);

    g_IniRefs++;

    if (g_IniRefs == 1) {
        g_IniLibPool = PmCreateNamedPool ("IniLib");
    }

    return g_IniLibPool != NULL;
}


VOID
Ini_Exit (
    VOID
    )

/*++

Routine Description:

    Ini_Exit is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    MYASSERT (g_IniRefs > 0);

    g_IniRefs--;

    if (!g_IniRefs) {

        if (g_IniLibPool) {
            PmDestroyPool (g_IniLibPool);
            g_IniLibPool = NULL;
        }
    }
}


PBYTE
pAllocateSpace (
    IN      DWORD Size
    )

/*++

Routine Description:

    pAllocateSpace is a private function that allocates space from the module's private pool

Arguments:

    Size - The size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if no memory could be allocated.

--*/

{
    MYASSERT (g_IniLibPool);
    MYASSERT (Size);
    return PmGetMemory (g_IniLibPool, Size);
}


VOID
pFreeSpace (
    IN      PVOID Buffer
    )

/*++

Routine Description:

    pFreeSpace is a private function that frees space allocated from the module's private pool

Arguments:

    Buffer - Pointer to buffer to free.

Return Value:

    none

--*/

{
    MYASSERT (g_IniLibPool);
    PmReleaseMemory (g_IniLibPool, Buffer);
}


/*++

Routine Description:

    RealIniFileOpen validates the args passed in and then
    initializes IniFile struct with info used in subsequent calls to INI functions.

Arguments:

    IniFile - Receives INI file attributes if open is successful

    IniFileSpec - Specifies the file name; if not full path,
                  current drive and/or dir are prefixed

    FileMustExist - Specifies TRUE if file must exist for open to succeed

Return Value:

    TRUE if open succeeded; IniFile is valid for subsequent calls to other INI APIs;
         IniFileClose must be called when this handle is no longer needed.
    FALSE if not

--*/

BOOL
RealIniFileOpenA (
    OUT     PINIFILEA IniFile,
    IN      PCSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    )
{
    CHAR fullPath[MAX_MBCHAR_PATH];

    if (!GetFullPathNameA (IniFileSpec, MAX_MBCHAR_PATH, fullPath, NULL)) {

        DEBUGMSGA ((
            DBG_ERROR,
            "IniFileOpenA: GetFullPathNameA failed on <%s>",
            IniFileSpec
            ));
        return FALSE;
    }

    DEBUGMSGA_IF ((
        !StringIMatchA (IniFileSpec, fullPath),
        DBG_INILIB,
        "IniFileOpenA: IniFileSpec supplied: <%s>; full path defaulting to <%s>",
        IniFileSpec,
        fullPath
        ));

    if (BfPathIsDirectoryA (fullPath)) {
        DEBUGMSGA ((
            DBG_INILIB,
            "IniFileOpenA: <%s> is a directory",
            fullPath
            ));
        return FALSE;
    }
    if (FileMustExist && !DoesFileExistA (fullPath)) {
        DEBUGMSGA ((
            DBG_INILIB,
            "IniFileOpenA: file not found: <%s>",
            fullPath
            ));
        return FALSE;
    }

    IniFile->IniFilePath = DuplicateTextExA (g_IniLibPool, fullPath, 0, NULL);
    IniFile->OriginalAttributes = GetFileAttributesA (fullPath);

    if (IniFile->OriginalAttributes != (DWORD)-1) {
        //
        // set working attributes
        //
        SetFileAttributesA (fullPath, FILE_ATTRIBUTE_NORMAL);
    }

    return TRUE;
}


BOOL
RealIniFileOpenW (
    OUT     PINIFILEW IniFile,
    IN      PCWSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    )
{
    WCHAR fullPath[MAX_MBCHAR_PATH];

    if (!GetFullPathNameW (IniFileSpec, MAX_WCHAR_PATH, fullPath, NULL)) {

        DEBUGMSGW ((
            DBG_ERROR,
            "IniFileOpenW: GetFullPathNameW failed on <%s>",
            IniFileSpec
            ));
        return FALSE;
    }

    DEBUGMSGW_IF ((
        !StringIMatchW (IniFileSpec, fullPath),
        DBG_INILIB,
        "IniFileOpenW: IniFileSpec supplied: <%s>; full path defaulting to <%s>",
        IniFileSpec,
        fullPath
        ));

    if (BfPathIsDirectoryW (fullPath)) {
        DEBUGMSGW ((
            DBG_INILIB,
            "IniFileOpenW: <%s> is a directory",
            fullPath
            ));
        return FALSE;
    }
    if (FileMustExist && !DoesFileExistW (fullPath)) {
        DEBUGMSGW ((
            DBG_INILIB,
            "IniFileOpenW: file not found: <%s>",
            fullPath
            ));
        return FALSE;
    }

    IniFile->IniFilePath = DuplicateTextExW (g_IniLibPool, fullPath, 0, NULL);
    IniFile->OriginalAttributes = GetFileAttributesW (fullPath);

    if (IniFile->OriginalAttributes != (DWORD)-1) {
        //
        // set working attributes
        //
        SetFileAttributesW (fullPath, FILE_ATTRIBUTE_NORMAL);
    }

    return TRUE;
}


/*++

Routine Description:

    IniFileClose frees resources and restores INI's initial attributes

Arguments:

    IniFile - Specifies a handle to an open INI file

Return Value:

    none

--*/

VOID
IniFileCloseA (
    IN      PINIFILEA IniFile
    )
{
    if (IniFile->OriginalAttributes != (DWORD)-1) {
        SetFileAttributesA (IniFile->IniFilePath, IniFile->OriginalAttributes);
    }
    FreeTextExA (g_IniLibPool, IniFile->IniFilePath);
}


VOID
IniFileCloseW (
    IN      PINIFILEW IniFile
    )
{
    if (IniFile->OriginalAttributes != (DWORD)-1) {
        SetFileAttributesW (IniFile->IniFilePath, IniFile->OriginalAttributes);
    }
    FreeTextExW (g_IniLibPool, IniFile->IniFilePath);
}


/*++

Routine Description:

    EnumFirstIniSection returns the first section of the given INI file, if any.

Arguments:

    IniSectEnum - Receives the first section

    IniFile - Specifies a handle to an open INI file

Return Value:

    TRUE if there is a section
    FALSE if not

--*/

BOOL
EnumFirstIniSectionA (
    OUT     PINISECT_ENUMA IniSectEnum,
    IN      PINIFILEA IniFile
    )
{
    PSTR sections;
    DWORD allocatedChars;
    DWORD chars;

    sections = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (sections) {
            pFreeSpace (sections);
        }
        allocatedChars *= 2;
        sections = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!sections) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionNamesA (
                    sections,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*sections) {
        pFreeSpace (sections);
        return FALSE;
    }

    IniSectEnum->Sections = sections;
    IniSectEnum->CurrentSection = sections;
    return TRUE;
}


BOOL
EnumFirstIniSectionW (
    OUT     PINISECT_ENUMW IniSectEnum,
    IN      PINIFILEW IniFile
    )
{
    PWSTR sections;
    DWORD allocatedChars;
    DWORD chars;

    sections = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (sections) {
            pFreeSpace (sections);
        }
        allocatedChars *= 2;
        sections = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!sections) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionNamesW (
                    sections,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*sections) {
        pFreeSpace (sections);
        return FALSE;
    }

    IniSectEnum->Sections = sections;
    IniSectEnum->CurrentSection = sections;
    return TRUE;
}


/*++

Routine Description:

    EnumNextIniSection returns the next section, if any.

Arguments:

    IniSectEnum - Specifies the prev section/receives the next section

Return Value:

    TRUE if there is a next section
    FALSE if not

--*/

BOOL
EnumNextIniSectionA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    )
{
    if (IniSectEnum->CurrentSection && *IniSectEnum->CurrentSection != 0) {
        //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
        //CurrentKeyValuePtr (because GetEndOfStringA will return a valid pointer) so...
        //lint --e(613)
        IniSectEnum->CurrentSection = GetEndOfStringA (IniSectEnum->CurrentSection) + 1;
        if (*IniSectEnum->CurrentSection != 0) {
            return TRUE;
        }
    }

    AbortIniSectionEnumA (IniSectEnum);
    return FALSE;
}


BOOL
EnumNextIniSectionW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    )
{
    if (IniSectEnum->CurrentSection && *IniSectEnum->CurrentSection != 0) {
        //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
        //CurrentKeyValuePtr (because GetEndOfStringW will return a valid pointer) so...
        //lint --e(613)
        IniSectEnum->CurrentSection = GetEndOfStringW (IniSectEnum->CurrentSection) + 1;
        if (*IniSectEnum->CurrentSection != 0) {
            return TRUE;
        }
    }

    AbortIniSectionEnumW (IniSectEnum);
    return FALSE;
}


/*++

Routine Description:

    AbortIniSectionEnum aborts section enumeration

Arguments:

    IniSectEnum - Specifies the section enumeration handle/receives NULLs

Return Value:

    none

--*/

VOID
AbortIniSectionEnumA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    )
{
    pFreeSpace ((PVOID)IniSectEnum->Sections);
    IniSectEnum->Sections = NULL;
    IniSectEnum->CurrentSection = NULL;
}


VOID
AbortIniSectionEnumW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    )
{
    pFreeSpace ((PVOID)IniSectEnum->Sections);
    IniSectEnum->Sections = NULL;
    IniSectEnum->CurrentSection = NULL;
}


/*++

Routine Description:

    EnumFirstIniKeyValue returns the first key/value pair of
    the given INI file/section name, if any.

Arguments:

    IniKeyValueEnum - Receives the first section

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to enumearte

Return Value:

    TRUE if there is a key/value pair
    FALSE if not

--*/

BOOL
EnumFirstIniKeyValueA (
    OUT     PINIKEYVALUE_ENUMA IniKeyValueEnum,
    IN      PINIFILEA IniFile,
    IN      PCSTR Section
    )
{
    PSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section);
    if (!Section) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionA (
                    Section,
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*buffer) {
        pFreeSpace (buffer);
        return FALSE;
    }

    IniKeyValueEnum->KeyValuePairs = buffer;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->Private = NULL;
    return EnumNextIniKeyValueA (IniKeyValueEnum);
}


BOOL
EnumFirstIniKeyValueW (
    OUT     PINIKEYVALUE_ENUMW IniKeyValueEnum,
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section
    )
{
    PWSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section);
    if (!Section) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionW (
                    Section,
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*buffer) {
        pFreeSpace (buffer);
        return FALSE;
    }

    IniKeyValueEnum->KeyValuePairs = buffer;
    IniKeyValueEnum->Private = NULL;
    return EnumNextIniKeyValueW (IniKeyValueEnum);
}


/*++

Routine Description:

    EnumNextIniKeyValue returns the first key/value pair of
    the given INI file/section name, if any.

Arguments:

    IniKeyValueEnum - Specifies the prev key/value pair / receives the next pair

Return Value:

    TRUE if there is a next pair
    FALSE if not

--*/

BOOL
EnumNextIniKeyValueA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    )
{
    //
    // restore from saved position
    //
    IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->Private;
    //
    // skip commented lines
    //
    do {
        if (IniKeyValueEnum->CurrentKeyValuePair) {
            //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
            //CurrentKeyValuePtr (because GetEndOfStringA will return a valid pointer) so...
            //lint --e(613)
            IniKeyValueEnum->CurrentKeyValuePair = GetEndOfStringA (IniKeyValueEnum->CurrentKeyValuePair) + 1;
        } else {
            IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->KeyValuePairs;
        }

        MYASSERT (IniKeyValueEnum->CurrentKeyValuePair);
        if (!(*IniKeyValueEnum->CurrentKeyValuePair)) {
            AbortIniKeyValueEnumA (IniKeyValueEnum);
            return FALSE;
        }
        IniKeyValueEnum->CurrentKey = IniKeyValueEnum->CurrentKeyValuePair;
        IniKeyValueEnum->CurrentValue = _mbschr (IniKeyValueEnum->CurrentKey, '=');
    }  while (*IniKeyValueEnum->CurrentKeyValuePair == ';' || !IniKeyValueEnum->CurrentValue);

    MYASSERT (*IniKeyValueEnum->CurrentKeyValuePair);
    MYASSERT (*IniKeyValueEnum->CurrentValue == '=');
    //
    // remember position for next iteration
    //
    IniKeyValueEnum->Private = GetEndOfStringA (IniKeyValueEnum->CurrentValue);
    //
    // modify buffer to get KEY and VALUE
    //
    *(PSTR)IniKeyValueEnum->CurrentValue = 0;
    IniKeyValueEnum->CurrentValue++;
    TruncateTrailingSpaceA ((PSTR)IniKeyValueEnum->CurrentKey);
    return TRUE;
}


BOOL
EnumNextIniKeyValueW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    )
{
    //
    // restore from saved position
    //
    IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->Private;
    //
    // skip commented lines
    //
    do {
        if (IniKeyValueEnum->CurrentKeyValuePair) {
            //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
            //CurrentKeyValuePtr (because GetEndOfStringW will return a valid pointer) so...
            //lint --e(613)
            IniKeyValueEnum->CurrentKeyValuePair = GetEndOfStringW (IniKeyValueEnum->CurrentKeyValuePair) + 1;
        } else {
            IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->KeyValuePairs;
        }

        MYASSERT (IniKeyValueEnum->CurrentKeyValuePair);
        if (!(*IniKeyValueEnum->CurrentKeyValuePair)) {
            AbortIniKeyValueEnumW (IniKeyValueEnum);
            return FALSE;
        }
        IniKeyValueEnum->CurrentKey = IniKeyValueEnum->CurrentKeyValuePair;
        IniKeyValueEnum->CurrentValue = wcschr (IniKeyValueEnum->CurrentKey, L'=');
    }  while (*IniKeyValueEnum->CurrentKeyValuePair == L';' || !IniKeyValueEnum->CurrentValue);

    MYASSERT (*IniKeyValueEnum->CurrentKeyValuePair);
    MYASSERT (*IniKeyValueEnum->CurrentValue == L'=');
    //
    // remember position for next iteration
    //
    IniKeyValueEnum->Private = GetEndOfStringW (IniKeyValueEnum->CurrentValue);
    //
    // modify buffer to get KEY and VALUE
    //
    *(PWSTR)IniKeyValueEnum->CurrentValue = 0;
    IniKeyValueEnum->CurrentValue++;
    TruncateTrailingSpaceW ((PWSTR)IniKeyValueEnum->CurrentKey);
    return TRUE;
}


/*++

Routine Description:

    AbortIniKeyValueEnum aborts key/value pairs enumeration

Arguments:

    IniKeyValueEnum - Specifies the key/value pair enumeration handle/receives NULLs

Return Value:

    none

--*/

VOID
AbortIniKeyValueEnumA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    )
{
    pFreeSpace ((PVOID)IniKeyValueEnum->KeyValuePairs);
    IniKeyValueEnum->KeyValuePairs = NULL;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->CurrentKey = NULL;
    IniKeyValueEnum->CurrentValue = NULL;
}


VOID
AbortIniKeyValueEnumW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    )
{
    pFreeSpace ((PVOID)IniKeyValueEnum->KeyValuePairs);
    IniKeyValueEnum->KeyValuePairs = NULL;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->CurrentKey = NULL;
    IniKeyValueEnum->CurrentValue = NULL;
}


/*++

Routine Description:

    IniReadValue returns the value of a specified key in a specified section
    from the given INI file. The buffer returned must be freed using IniFreeReadValue

Arguments:

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to read from

    Key - Specifies the key

    Value - Receives a pointer to an allocated buffer containing the read value,
            if function is successful; optional

    Chars - Receives the number of chars (not bytes) the value has,
            excluding the NULL terminator; optional

Return Value:

    TRUE if there is a value for the specified section/key
    FALSE if not

--*/

BOOL
IniReadValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    OUT     PSTR* Value,            OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    )
{
    PSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section && Key);
    if (!Section || !Key) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileStringA (
                    Section,
                    Key,
                    "",
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 1);

    if (Chars) {
        *Chars = chars;
    }

    if (Value) {
        if (*buffer) {
            *Value = buffer;
        } else {
            *Value = NULL;
        }
    }

    if (!(Value && *Value)) {
        //
        // buffer no longer needed
        //
        pFreeSpace (buffer);
    }

    return chars > 0;
}

BOOL
IniReadValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR* Value,           OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    )
{
    PWSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section && Key);
    if (!Section || !Key) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileStringW (
                    Section,
                    Key,
                    L"",
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 1);

    if (Chars) {
        *Chars = chars;
    }

    if (Value) {
        if (*buffer) {
            *Value = buffer;
        } else {
            *Value = NULL;
        }
    }

    if (!(Value && *Value)) {
        //
        // buffer no longer needed
        //
        pFreeSpace (buffer);
    }

    return chars > 0;
}


/*++

Routine Description:

    IniFreeReadValue is used to free the buffer allocated by IniReadValue
    and stored in Value, if specified.

Arguments:

    Value - Specifies a pointer to the string to be freed

Return Value:

    none

--*/

VOID
IniFreeReadValueA (
    IN      PCSTR Value
    )
{
    pFreeSpace ((PVOID)Value);
}


VOID
IniFreeReadValueW (
    IN      PCWSTR Value
    )
{
    pFreeSpace ((PVOID)Value);
}


/*++

Routine Description:

    IniWriteValue writes the key/value pair in the specified section

Arguments:

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to write to

    Key - Specifies the key

    Value - Spcifies the value

Return Value:

    TRUE if write was successful, FALSE if not

--*/

BOOL
IniWriteValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    IN      PCSTR Value
    )
{
    return WritePrivateProfileStringA (
                    Section,
                    Key,
                    Value,
                    IniFile->IniFilePath
                    );
}


BOOL
IniWriteValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    IN      PCWSTR Value
    )
{
    return WritePrivateProfileStringW (
                    Section,
                    Key,
                    Value,
                    IniFile->IniFilePath
                    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\basefile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    basefile.c

Abstract:

    Contains simple wrappers for commonly used file i/o functions.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_BASEFILE     "File Utils"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  Writes a DBCS string to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the nul-terminated string to write to the file.

Return Value:

  TRUE if successful, FALSE if an error occurred.  Call GetLastError
  for error condition.

--*/

{
    DWORD DontCare;

    return WriteFile (File, String, ByteCountA (String), &DontCare, NULL);
}


BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS, then Writes it to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the UNICODE nul-terminated string to convert and
           write to the file.

Return Value:

 TRUE if successful, FALSE if an error occurred.  Call GetLastError for
 error condition.

--*/

{
    DWORD DontCare;
    PCSTR AnsiVersion;
    BOOL b;

    AnsiVersion = ConvertWtoA (String);
    if (!AnsiVersion) {
        return FALSE;
    }

    b = WriteFile (File, AnsiVersion, ByteCountA (AnsiVersion), &DontCare, NULL);

    FreeConvertedStr (AnsiVersion);

    return b;
}

BOOL
DoesFileExistExA(
    IN      PCSTR FileName,
    OUT     PWIN32_FIND_DATAA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAA ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        // Win95 GetFileAttributes does not return a failure if FileName is NULL
        if (FileName == NULL) {
            return FALSE;
        } else {
            return GetFileAttributesA (FileName) != 0xffffffff;
        }
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileA(FileName, &ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
DoesFileExistExW (
    IN      PCWSTR FileName,
    OUT     PWIN32_FIND_DATAW FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAW ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        // Win95 GetFileAttributes does not return a failure if FileName is NULL
        if (FileName == NULL) {
            return FALSE;
        } else {
            return GetFileAttributesW (FileName) != 0xffffffff;
        }
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileW(FileName,&ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


/*++

Routine Description:

    PathIsDirectory determines if a path identifies an accessible directory.

Arguments:

    PathSpec - Specifies the full path.

Return Value:

    TRUE if the path identifies a directory.
    FALSE if not. GetLastError() returns extended error info.

--*/

BOOL
BfPathIsDirectoryA (
    IN      PCSTR PathSpec
    )
{
    DWORD attribs;

    MYASSERT (PathSpec);
    if (!PathSpec) {
        return FALSE;
    }
    attribs = GetFileAttributesA (PathSpec);
    return attribs != (DWORD)-1 && (attribs & FILE_ATTRIBUTE_DIRECTORY);
}

BOOL
BfPathIsDirectoryW (
    IN      PCWSTR PathSpec
    )
{
    DWORD attribs;

    MYASSERT (PathSpec);
    if (!PathSpec) {
        return FALSE;
    }
    attribs = GetFileAttributesW (PathSpec);
    return attribs != (DWORD)-1 && (attribs & FILE_ATTRIBUTE_DIRECTORY);
}


PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileA (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        *FileHandle = NULL;
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingA (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        CloseHandle (*FileHandle);
        *FileHandle = NULL;
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileW (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        *FileHandle = NULL;
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingW (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        CloseHandle (*FileHandle);
        *FileHandle = NULL;
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


BOOL
UnmapFile (
    IN PCVOID FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    )

/*++

Routine Description:

  UnmapFile is used to release all resources allocated by MapFileIntoMemory.

Arguments:

  FileImage - image of the mapped file as returned by MapFileIntoMemory
  MapHandle - handle of the mapping object as returned by MapFileIntoMemory
  FileHandle - handle of the file as returned by MapFileIntoMemory

Return Value:

  TRUE if successfull, FALSE if not

--*/

{
    BOOL result = TRUE;

    //if FileImage is a valid pointer then try to unmap file
    if (FileImage != NULL) {
        if (UnmapViewOfFile (FileImage) == 0) {
            result = FALSE;
        }
    }

    //if mapping object is valid then try to delete it
    if (MapHandle != NULL) {
        if (CloseHandle (MapHandle) == 0) {
            result = FALSE;
        }
    }

    //if file handle is valid then try to close the file
    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (CloseHandle (FileHandle) == 0) {
            result = FALSE;
        }
    }

    return result;
}


BOOL
BfGetTempFileNameExA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCSTR Prefix
    )
{
    CHAR tempPath[MAX_MBCHAR_PATH];
    CHAR tempFile[MAX_MBCHAR_PATH];
    UINT tchars;
    PSTR p;

    if (!GetTempPathA (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    p = _mbsrchr (tempPath, '\\');
    if (p && !p[1]) {
        *p = 0;
    }

    if (!DoesFileExistA (tempPath)) {
        BfCreateDirectoryA (tempPath);
    }

    if (BufferTchars >= MAX_PATH) {
        if (!GetTempFileNameA (tempPath, Prefix, 0, Buffer)) {
            return FALSE;
        }
    } else {
        if (!GetTempFileNameA (tempPath, Prefix, 0, tempFile)) {
            DWORD err = GetLastError ();
            return FALSE;
        }

        tchars = TcharCountA (tempFile) + 1;

        if (tchars > BufferTchars) {
            DEBUGMSG ((DBG_ERROR, "Can't get temp file name -- buffer too small"));
            return FALSE;
        }

        CopyMemory (Buffer, tempFile, tchars * sizeof (CHAR));
    }

    return TRUE;
}


BOOL
BfGetTempFileNameExW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCWSTR Prefix
    )
{
    WCHAR tempPath[MAX_WCHAR_PATH];
    WCHAR tempFile[MAX_WCHAR_PATH];
    UINT tchars;
    PWSTR p;

    if (!GetTempPathW (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    p = wcsrchr (tempPath, '\\');
    if (p && !p[1]) {
        *p = 0;
    }

    if (BufferTchars >= MAX_PATH) {
        if (!GetTempFileNameW (tempPath, Prefix, 0, Buffer)) {
            return FALSE;
        }
    } else {
        if (!GetTempFileNameW (tempPath, Prefix, 0, tempFile)) {
            return FALSE;
        }

        tchars = TcharCountW (tempFile);

        if (tchars > BufferTchars) {
            DEBUGMSG ((DBG_ERROR, "Can't get temp file name -- buffer too small"));
            return FALSE;
        }

        CopyMemory (Buffer, tempFile, tchars * sizeof (WCHAR));
    }

    return TRUE;
}


BOOL
BfGetTempDirectoryExA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCSTR Prefix
    )
{
    BOOL result = FALSE;

    result = BfGetTempFileNameExA (Buffer, BufferTchars, Prefix);

    if (result) {
        if (!DeleteFileA (Buffer)) {
            return FALSE;
        }
        if (!CreateDirectoryA (Buffer, NULL)) {
            return FALSE;
        }
    }
    return result;
}


BOOL
BfGetTempDirectoryExW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCWSTR Prefix
    )
{
    BOOL result = FALSE;

    result = BfGetTempFileNameExW (Buffer, BufferTchars, Prefix);

    if (result) {
        if (!DeleteFileW (Buffer)) {
            return FALSE;
        }
        if (!CreateDirectoryW (Buffer, NULL)) {
            return FALSE;
        }
    }
    return result;
}


HANDLE
BfGetTempFile (
    VOID
    )
{
    CHAR tempFile[MAX_MBCHAR_PATH];
    HANDLE file;

    if (!BfGetTempFileNameA (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }

    file = CreateFileA (
                tempFile,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL|FILE_FLAG_DELETE_ON_CLOSE,
                NULL
                );

    if (file == INVALID_HANDLE_VALUE) {
        file = NULL;
    }

    return file;
}


BOOL
BfSetFilePointer (
    IN      HANDLE File,
    IN      LONGLONG Offset
    )
{
    LARGE_INTEGER li;

    li.QuadPart = Offset;

    li.LowPart = SetFilePointer (File, li.LowPart, &li.HighPart, FILE_BEGIN);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    }

    return li.QuadPart != -1;
}


HANDLE
BfOpenReadFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


HANDLE
BfOpenReadFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfOpenFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


HANDLE
BfOpenFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle =  CreateFileA (
                    FileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;

}

HANDLE
BfCreateFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateSharedFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateSharedFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


BOOL
BfSetSizeOfFile (
    HANDLE File,
    LONGLONG Size
    )
{
    if (!BfSetFilePointer (File, Size)) {
        return FALSE;
    }

    return SetEndOfFile (File);
}


BOOL
BfGoToEndOfFile (
    IN      HANDLE File,
    OUT     PLONGLONG FileSize      OPTIONAL
    )
{
    LARGE_INTEGER li;

    li.HighPart = 0;
    li.LowPart = SetFilePointer (File, 0, &li.HighPart, FILE_END);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    } else if (FileSize) {
        *FileSize = li.QuadPart;
    }

    return li.QuadPart != -1;
}


BOOL
BfGetFilePointer (
    IN      HANDLE File,
    OUT     PLONGLONG FilePointer       OPTIONAL
    )
{
    LARGE_INTEGER li;

    li.HighPart = 0;
    li.LowPart = SetFilePointer (File, 0, &li.HighPart, FILE_CURRENT);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    } else if (FilePointer) {
        *FilePointer = li.QuadPart;
    }

    return li.QuadPart != -1;
}


BOOL
BfReadFile (
    IN      HANDLE File,
    OUT     PBYTE Buffer,
    IN      UINT BytesToRead
    )
{
    DWORD bytesRead;

    if (!ReadFile (File, Buffer, BytesToRead, &bytesRead, NULL)) {
        return FALSE;
    }

    return bytesRead == BytesToRead;
}


BOOL
BfWriteFile (
    IN      HANDLE File,
    OUT     PCBYTE Buffer,
    IN      UINT BytesToWrite
    )
{
    DWORD bytesWritten;

    if (!WriteFile (File, Buffer, BytesToWrite, &bytesWritten, NULL)) {
        return FALSE;
    }

    return bytesWritten == BytesToWrite;
}


BOOL
BfCreateDirectoryExA (
    IN      PCSTR FullPath,
    IN      BOOL CreateLastSegment
    )
{
    PSTR pathCopy;
    PSTR p;
    BOOL b = TRUE;

    pathCopy = DuplicatePathStringA (FullPath, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == ':' && pathCopy[2] == '\\') {
        //
        // <drive>:\ case
        //

        p = _mbschr (&pathCopy[3], '\\');

    } else if (pathCopy[0] == '\\' && pathCopy[1] == '\\') {

        //
        // UNC case
        //

        p = _mbschr (pathCopy + 2, '\\');
        if (p) {
            p = _mbschr (p + 1, '\\');
            if (p) {
                p = _mbschr (p + 1, '\\');
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = _mbschr (pathCopy, '\\');
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectoryA (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            LOG ((LOG_ERROR, "Can't create %s", pathCopy));
            break;
        }

        *p = '\\';
        p = _mbschr (p + 1, '\\');
    }

    //
    // At last, make the FullPath directory
    //

    if (b && CreateLastSegment) {
        b = CreateDirectoryA (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    FreePathStringA (pathCopy);

    if ((!b) && (TcharCountA (pathCopy) >= 248)) {
        // we tried to create a directory bigger than what CreateDirectoryA
        // will accept (errors out at 248 characters).
        // Normally this will return the error 206 (ERROR_FILENAME_EXCED_RANGE).
        // However, when the string is actually very long sometimes error 3
        // (ERROR_PATH_NOT_FOUND) is returned. Let's just guard for this case:
        if (GetLastError () == ERROR_PATH_NOT_FOUND) {
            SetLastError (ERROR_FILENAME_EXCED_RANGE);
        }
    }

    return b;
}


BOOL
BfCreateDirectoryExW (
    IN      PCWSTR FullPath,
    IN      BOOL CreateLastSegment
    )
{
    PWSTR pathCopy;
    PWSTR p;
    BOOL b = TRUE;

    pathCopy = DuplicatePathStringW (FullPath, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == L':' && pathCopy[2] == L'\\') {
        //
        // <drive>:\ case
        //

        p = wcschr (&pathCopy[3], L'\\');

    } else if (pathCopy[0] == L'\\' && pathCopy[1] == L'\\') {

        //
        // UNC case
        //

        p = wcschr (pathCopy + 2, L'\\');
        if (p) {
            p = wcschr (p + 1, L'\\');
            if (p) {
                p = wcschr (p + 1, L'\\');
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = wcschr (pathCopy, L'\\');
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectoryW (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            break;
        }

        *p = L'\\';
        p = wcschr (p + 1, L'\\');
    }

    //
    // At last, make the FullPath directory
    //

    if (b && CreateLastSegment) {
        b = CreateDirectoryW (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    FreePathStringW (pathCopy);

    if ((!b) && (TcharCountW (pathCopy) >= 248)) {
        // we tried to create a directory bigger than what CreateDirectoryW
        // will accept (errors out at 248 characters).
        // Normally this will return the error 206 (ERROR_FILENAME_EXCED_RANGE).
        // However, when the string is actually very long sometimes error 3
        // (ERROR_PATH_NOT_FOUND) is returned. Let's just guard for this case:
        if (GetLastError () == ERROR_PATH_NOT_FOUND) {
            SetLastError (ERROR_FILENAME_EXCED_RANGE);
        }
    }

    return b;
}


LONGLONG
BfGetFileSizeA (
    IN      PCSTR FileName
    )
{
    WIN32_FIND_DATAA fd;
    LONGLONG l;

    if (!DoesFileExistExA (FileName, &fd)) {
        return 0;
    }

    l = ((LONGLONG) fd.nFileSizeHigh << 32) | fd.nFileSizeLow;

    return l;
}

LONGLONG
BfGetFileSizeW (
    IN      PCWSTR FileName
    )
{
    WIN32_FIND_DATAW fd;
    LONGLONG l;

    if (!DoesFileExistExW (FileName, &fd)) {
        return 0;
    }

    l = ((LONGLONG) fd.nFileSizeHigh << 32) | fd.nFileSizeLow;

    return l;
}

PSTR
pGetFirstSegA (
    IN      PCSTR SrcFileName
    )
{
    if (SrcFileName [0] == '\\') {
        SrcFileName ++;
        if (SrcFileName [0] == '\\') {
            SrcFileName ++;
        }
        return (_mbschr (SrcFileName, '\\'));
    } else {
        return (_mbschr (SrcFileName, '\\'));
    }
}

BOOL
pGetLongFileNameWorkerA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuf
    )
{
    PSTR beginSegPtr;
    PSTR endSegPtr;
    WIN32_FIND_DATAA findData;
    CHAR savedChar;

    beginSegPtr = pGetFirstSegA (SrcFileName);

    if (!beginSegPtr) {
        GbAppendStringA (GrowBuf, SrcFileName);
        return TRUE;
    }
    beginSegPtr = _mbsinc (beginSegPtr);

    GbAppendStringABA (GrowBuf, SrcFileName, beginSegPtr);

    while (beginSegPtr) {
        endSegPtr = _mbschr (beginSegPtr, '\\');
        if (!endSegPtr) {
            endSegPtr = GetEndOfStringA (beginSegPtr);
            MYASSERT (endSegPtr);
        }
        savedChar = *endSegPtr;
        *endSegPtr = 0;
        if (DoesFileExistExA (SrcFileName, &findData)) {
            if (findData.cAlternateFileName [0]) {
                GbAppendStringA (GrowBuf, findData.cFileName);
            } else {
                if (StringIMatch (beginSegPtr, findData.cFileName)) {
                    GbAppendStringA (GrowBuf, findData.cFileName);
                } else {
                    GbAppendStringA (GrowBuf, beginSegPtr);
                }
            }
        } else {
            GbAppendStringABA (GrowBuf, beginSegPtr, endSegPtr);
        }
        *endSegPtr = savedChar;
        if (savedChar) {
            beginSegPtr = _mbsinc (endSegPtr);
            GbAppendStringABA (GrowBuf, endSegPtr, beginSegPtr);
        } else {
            beginSegPtr = NULL;
        }
    }
    return TRUE;
}

PCSTR
BfGetLongFileNameA (
    IN      PCSTR SrcFileName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PSTR srcFileName;
    PCSTR result = NULL;

    srcFileName = (PSTR)SanitizePathA (SrcFileName);
    if (pGetLongFileNameWorkerA (srcFileName, &growBuf)) {
        result = DuplicatePathStringA (growBuf.Buf, 0);
        GbFree (&growBuf);
    }
    FreePathStringA (srcFileName);
    return result;
}

BOOL
BfGetLongFileNameExA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    )
{
    PSTR srcFileName;
    BOOL result;

    srcFileName = (PSTR)SanitizePathA (SrcFileName);
    result = pGetLongFileNameWorkerA (srcFileName, GrowBuff);
    FreePathStringA (srcFileName);

    return result;
}

PWSTR
pGetFirstSegW (
    IN      PCWSTR SrcFileName
    )
{
    if (SrcFileName [0] == L'\\') {
        SrcFileName ++;
        if (SrcFileName [0] == L'\\') {
            SrcFileName ++;
        }
        return (wcschr (SrcFileName, L'\\'));
    } else {
        return (wcschr (SrcFileName, L'\\'));
    }
}

BOOL
pGetLongFileNameWorkerW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuf
    )
{
    PWSTR beginSegPtr;
    PWSTR endSegPtr;
    WIN32_FIND_DATAW findData;
    WCHAR savedChar;

    beginSegPtr = pGetFirstSegW (SrcFileName);

    if (!beginSegPtr) {
        GbAppendStringW (GrowBuf, SrcFileName);
        return TRUE;
    }
    beginSegPtr ++;

    GbAppendStringABW (GrowBuf, SrcFileName, beginSegPtr);

    while (beginSegPtr) {
        endSegPtr = wcschr (beginSegPtr, L'\\');
        if (!endSegPtr) {
            endSegPtr = GetEndOfStringW (beginSegPtr);
            MYASSERT (endSegPtr);
        }
        savedChar = *endSegPtr;
        *endSegPtr = 0;
        if (DoesFileExistExW (SrcFileName, &findData)) {
            GbAppendStringW (GrowBuf, findData.cFileName);
        } else {
            GbAppendStringABW (GrowBuf, beginSegPtr, endSegPtr);
        }
        *endSegPtr = savedChar;
        if (savedChar) {
            beginSegPtr = endSegPtr + 1;
            GbAppendStringABW (GrowBuf, endSegPtr, beginSegPtr);
        } else {
            beginSegPtr = NULL;
        }
    }
    return TRUE;
}

PCWSTR
BfGetLongFileNameW (
    IN      PCWSTR SrcFileName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PWSTR srcFileName;
    PCWSTR result = NULL;

    srcFileName = (PWSTR)SanitizePathW (SrcFileName);
    if (pGetLongFileNameWorkerW (srcFileName, &growBuf)) {
        result = DuplicatePathStringW ((PCWSTR)growBuf.Buf, 0);
        GbFree (&growBuf);
    }
    FreePathStringW (srcFileName);
    return result;
}

BOOL
BfGetLongFileNameExW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    )
{
    PWSTR srcFileName;
    BOOL result;

    srcFileName = (PWSTR)SanitizePathW (SrcFileName);
    result = pGetLongFileNameWorkerW (srcFileName, GrowBuff);
    FreePathStringW (srcFileName);

    return result;
}

BOOL
BfCopyAndFlushFileA (
    IN      PCSTR SrcFileName,
    IN      PCSTR DestFileName,
    IN      BOOL FailIfExists
    )
{
    BYTE buffer[4096];
    HANDLE srcHandle;
    HANDLE destHandle;
    DWORD bytesRead = 4096;
    DWORD bytesWritten;
    BOOL error = FALSE;
    BOOL result = FALSE;

    srcHandle = BfOpenReadFileA (SrcFileName);
    if (srcHandle) {
        if (FailIfExists && DoesFileExistA (DestFileName)) {
            SetLastError (ERROR_ALREADY_EXISTS);
        } else {
            destHandle = BfCreateFileA (DestFileName);
            if (destHandle) {
                while (bytesRead == 4096) {
                    if (!ReadFile (srcHandle, buffer, 4096, &bytesRead, NULL)) {
                        error = TRUE;
                        break;
                    }
                    if (bytesRead == 0) {
                        break;
                    }
                    if (!WriteFile (destHandle, buffer, bytesRead, &bytesWritten, NULL)) {
                        error = TRUE;
                        break;
                    }
                    if (bytesRead != bytesWritten) {
                        error = TRUE;
                        break;
                    }
                }
                if (!error) {
                    result = TRUE;
                }
                if (result) {
                    FlushFileBuffers (destHandle);
                }
                CloseHandle (destHandle);
            }
        }
        CloseHandle (srcHandle);
    }

    return result;
}

BOOL
BfCopyAndFlushFileW (
    IN      PCWSTR SrcFileName,
    IN      PCWSTR DestFileName,
    IN      BOOL FailIfExists
    )
{
    BYTE buffer[4096];
    HANDLE srcHandle;
    HANDLE destHandle;
    DWORD bytesRead = 4096;
    DWORD bytesWritten;
    BOOL error = FALSE;
    BOOL result = FALSE;

    srcHandle = BfOpenReadFileW (SrcFileName);
    if (srcHandle) {
        if (FailIfExists && DoesFileExistW (DestFileName)) {
            SetLastError (ERROR_ALREADY_EXISTS);
        } else {
            destHandle = BfCreateFileW (DestFileName);
            if (destHandle) {
                while (bytesRead == 4096) {
                    if (!ReadFile (srcHandle, buffer, 4096, &bytesRead, NULL)) {
                        error = TRUE;
                        break;
                    }
                    if (bytesRead == 0) {
                        break;
                    }
                    if (!WriteFile (destHandle, buffer, bytesRead, &bytesWritten, NULL)) {
                        error = TRUE;
                        break;
                    }
                    if (bytesRead != bytesWritten) {
                        error = TRUE;
                        break;
                    }
                }
                if (!error) {
                    result = TRUE;
                }
                if (result) {
                    FlushFileBuffers (destHandle);
                }
                CloseHandle (destHandle);
            }
        }
        CloseHandle (srcHandle);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\linkpif\linkpif.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    linkpif.c

Abstract:

    Functions to query and modify LNK and PIF files.

Author:

    Calin Negreanu (calinn) 07-Sep-1998

Revision History:

--*/


//
// Includes
//

#include "pch.h"
#include <pif.h>        // private\windows\inc

//
// Debug constants
//

#define DBG_VERSION     "LnkPif"
#define MAXINISIZE      65536

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
InitCOMLinkA (
    OUT     IShellLinkA **ShellLink,
    OUT     IPersistFile **PersistFile
    )
{
    HRESULT hres;
    BOOL result;

    //
    // Initialize COM
    //
    CoInitialize (NULL);

    *ShellLink = NULL;
    *PersistFile = NULL;
    result = FALSE;

    __try {

        //
        // Get a pointer to the IShellLink interface.
        //
        hres = CoCreateInstance (&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkA, ShellLink);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        //
        // Get a pointer to the IPersistFile interface.
        //
        hres = (*ShellLink)->lpVtbl->QueryInterface ((*ShellLink), &IID_IPersistFile, PersistFile);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        result = TRUE;

    }
    __finally {

        if (!result) {

            if (*PersistFile) {
                (*PersistFile)->lpVtbl->Release (*PersistFile);
                *PersistFile = NULL;
            }

            if (*ShellLink) {
                (*ShellLink)->lpVtbl->Release (*ShellLink);
                *ShellLink = NULL;
            }
        }
    }

    if (!result) {
        //
        // Free COM
        //
        CoUninitialize ();
    }

    return result;
}

BOOL
InitCOMLinkW (
    OUT     IShellLinkW **ShellLink,
    OUT     IPersistFile **PersistFile
    )
{
    HRESULT hres;
    BOOL result;

    //
    // Initialize COM
    //
    CoInitialize (NULL);

    *ShellLink = NULL;
    *PersistFile = NULL;
    result = FALSE;

    __try {

        //
        // Get a pointer to the IShellLink interface.
        //
        hres = CoCreateInstance (&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkW, ShellLink);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        //
        // Get a pointer to the IPersistFile interface.
        //
        hres = (*ShellLink)->lpVtbl->QueryInterface ((*ShellLink), &IID_IPersistFile, PersistFile);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        result = TRUE;

    }
    __finally {

        if (!result) {

            if (*PersistFile) {
                (*PersistFile)->lpVtbl->Release (*PersistFile);
                *PersistFile = NULL;
            }

            if (*ShellLink) {
                (*ShellLink)->lpVtbl->Release (*ShellLink);
                *ShellLink = NULL;
            }
        }
    }

    if (!result) {
        //
        // Free COM
        //
        CoUninitialize ();
    }

    return result;
}

BOOL
FreeCOMLinkA (
    IN OUT  IShellLinkA **ShellLink,
    IN OUT  IPersistFile **PersistFile
    )
{
    if (*PersistFile) {
        (*PersistFile)->lpVtbl->Release (*PersistFile);
        *PersistFile = NULL;
    }

    if (*ShellLink) {
        (*ShellLink)->lpVtbl->Release (*ShellLink);
        *ShellLink = NULL;
    }

    //
    // Free COM
    //
    CoUninitialize ();

    return TRUE;
}

BOOL
FreeCOMLinkW (
    IN OUT  IShellLinkW **ShellLink,
    IN OUT  IPersistFile **PersistFile
    )
{
    if (*PersistFile) {
        (*PersistFile)->lpVtbl->Release (*PersistFile);
        *PersistFile = NULL;
    }

    if (*ShellLink) {
        (*ShellLink)->lpVtbl->Release (*ShellLink);
        *ShellLink = NULL;
    }

    //
    // Free COM
    //
    CoUninitialize ();

    return TRUE;
}

PVOID
pFindEnhPifSignature (
    IN      PVOID FileImage,
    IN      PCSTR Signature
    )

/*++

Routine Description:

  pFindEnhPifSignature finds a certain PIF structure inside a PIF file (if it exists)
  based on a signature.

Arguments:

  FileImage - image of the PIF file mapped into memory

  Signature - structure signature

Return Value:

  address of the PIF structure, or NULL if non existent

--*/

{
    PBYTE tempPtr;
    PBYTE lastPtr;
    PVOID result = NULL;
    BOOL finished = FALSE;

    PPIFEXTHDR pifExtHdr;

    lastPtr = (PBYTE) FileImage;
    tempPtr = (PBYTE) FileImage;
    tempPtr += sizeof (STDPIF);

    pifExtHdr = (PPIFEXTHDR) tempPtr;
    __try {
        do {
            if (tempPtr < lastPtr) {
                result = NULL;
                break;
            } else {
                lastPtr = tempPtr;
            }
            finished = pifExtHdr->extnxthdrfloff == LASTHDRPTR;
            if (StringMatchA (pifExtHdr->extsig, Signature)) {
                result = tempPtr + sizeof (PIFEXTHDR);
                break;
            }
            else {
                tempPtr = (PBYTE)FileImage + pifExtHdr->extnxthdrfloff;
                pifExtHdr = (PPIFEXTHDR) tempPtr;
            }

        } while (!finished);
    }
    __except (1) {
        // something went wrong trying to access PIF file. Let's exit with NULL
        return NULL;
    }
    return result;
}

BOOL
ExtractPifInfoA(
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData       OPTIONAL
    )
{
    PVOID  fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;

    CHAR   tempStr [MEMDB_MAX];
    CHAR   target1 [MEMDB_MAX];
    PSTR   strPtr;
    PSTR   dontCare;

    PSTDPIF    stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    BOOL result = TRUE;

    if (Target) {
        *Target = NULL;
    }
    if (Params) {
        *Params = NULL;
    }
    if (WorkDir) {
        *WorkDir = NULL;
    }
    if (IconPath) {
        *IconPath = NULL;
    }
    *IconNumber = 0;
    *MsDosMode = FALSE;

    if (ExtraData) {
        ZeroMemory (ExtraData, sizeof(LNK_EXTRA_DATA));
    }

    __try {
        fileImage = MapFileIntoMemoryA (FileName, &fileHandle, &mapHandle);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;


            //
            // getting working directory
            //
            _mbsncpy (tempStr, stdPif->defpath, PIFDEFPATHSIZE);

            // we might have a path terminated with a wack, we don't want that
            strPtr = _mbsdec (tempStr, GetEndOfStringA (tempStr));
            if (strPtr) {
                if (_mbsnextc (strPtr) == '\\') {
                    *strPtr = 0;
                }
            }
            // now get the long path.
            if (WorkDir) {
                *WorkDir = DuplicatePathStringA (tempStr, 0);
            }

            //
            // getting PIFs target
            //
            _mbsncpy (target1, stdPif->startfile, PIFSTARTLOCSIZE);

            // in most cases, the target is without a path. We try to build the path, either
            // by using WorkDir or by calling SearchPath to look for this file.
            if (*target1) {//non empty target
                strPtr = _mbsrchr (target1, '\\');
                if (!strPtr) {
                    if (WorkDir && (*WorkDir)[0]) {
                        StringCopyA (tempStr, *WorkDir);
                        StringCatA  (tempStr, "\\");
                        StringCatA  (tempStr, target1);
                    }
                    else {
                        if (!SearchPathA (NULL, target1, NULL, MEMDB_MAX, tempStr, &dontCare)) {
                            DEBUGMSG ((DBG_WARNING, "Could not find path for PIF target:%s", FileName));
                            StringCopyA (tempStr, target1);
                        }
                    }
                }
                else {
                    StringCopyA (tempStr, target1);
                }
                // now get the long path
                if (Target) {
                    *Target = DuplicatePathStringA (tempStr, 0);
                }
            }

            //
            // getting PIFs arguments
            //
            _mbsncpy (tempStr, stdPif->params, PIFPARAMSSIZE);
            if (Params) {
                *Params = DuplicatePathStringA (tempStr, 0);
            }

            //
            // let's try to read the WENHPIF40 structure
            //
            wenhPif40 = pFindEnhPifSignature (fileImage, WENHHDRSIG40);
            if (wenhPif40) {
                if (IconPath) {
                    *IconPath = DuplicatePathStringA (wenhPif40->achIconFileProp, 0);
                }
                *IconNumber = wenhPif40->wIconIndexProp;
                if (ExtraData) {
                    ExtraData->xSize = 80;
                    ExtraData->ySize = wenhPif40->vidProp.cScreenLines;
                    if (ExtraData->ySize < 25) {
                        ExtraData->ySize = 25;
                    }
                    ExtraData->QuickEdit = !(wenhPif40->mseProp.flMse & MSE_WINDOWENABLE);
                    ExtraData->CurrentCodePage = wenhPif40->fntProp.wCurrentCP;
                    // now let's do some crazy things trying to get the font used
                    {
                        LOGFONTA logFont;
                        HDC dc;
                        HFONT font;
                        HGDIOBJ oldObject;
                        TEXTMETRIC tm;

                        ZeroMemory (&logFont, sizeof (LOGFONTA));
                        logFont.lfHeight = wenhPif40->fntProp.cyFontActual;
                        logFont.lfWidth = wenhPif40->fntProp.cxFontActual;
                        logFont.lfEscapement = 0;
                        logFont.lfOrientation = 0;
                        logFont.lfWeight = FW_DONTCARE;
                        logFont.lfItalic = FALSE;
                        logFont.lfUnderline = FALSE;
                        logFont.lfStrikeOut = FALSE;
                        logFont.lfCharSet = DEFAULT_CHARSET;
                        logFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
                        logFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
                        logFont.lfQuality = DEFAULT_QUALITY;
                        logFont.lfPitchAndFamily = DEFAULT_PITCH;
                        if (wenhPif40->fntProp.flFnt & FNT_TT) {
                            memcpy (logFont.lfFaceName, wenhPif40->fntProp.achTTFaceName, LF_FACESIZE);
                            memcpy (ExtraData->FontName, wenhPif40->fntProp.achTTFaceName, LF_FACESIZE);
                        } else {
                            memcpy (logFont.lfFaceName, wenhPif40->fntProp.achRasterFaceName, LF_FACESIZE);
                            memcpy (ExtraData->FontName, wenhPif40->fntProp.achRasterFaceName, LF_FACESIZE);
                        }
                        dc = CreateDCA ("DISPLAY", NULL, NULL, NULL);
                        if (dc) {
                            font = CreateFontIndirectA (&logFont);
                            if (font) {
                                oldObject = SelectObject (dc, font);

                                if (GetTextMetrics (dc, &tm)) {
                                    ExtraData->xFontSize = tm.tmAveCharWidth;
                                    ExtraData->yFontSize = tm.tmHeight;
                                    ExtraData->FontWeight = tm.tmWeight;
                                    ExtraData->FontFamily = tm.tmPitchAndFamily;
                                }
                                SelectObject (dc, oldObject);
                                DeleteObject (font);
                            }
                            DeleteDC (dc);
                        }
                    }
                }
            }
            w386ext30 = pFindEnhPifSignature (fileImage, W386HDRSIG30);
            if (w386ext30) {
                if (((w386ext30->PfW386Flags & fRealMode      ) == fRealMode      ) ||
                    ((w386ext30->PfW386Flags & fRealModeSilent) == fRealModeSilent)
                    ) {
                    *MsDosMode = TRUE;
                }
                if (ExtraData) {
                    ExtraData->FullScreen = (w386ext30->PfW386Flags & fFullScreen) != 0;
                }
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            result = FALSE;
        }
    }
    __finally {
        UnmapFile (fileImage, mapHandle, fileHandle);
    }
    return result;
}

BOOL
ExtractPifInfoW(
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData       OPTIONAL
    )
{
    PCSTR  aTarget = NULL;
    PCSTR  aParams = NULL;
    PCSTR  aWorkDir = NULL;
    PCSTR  aIconPath = NULL;
    PCSTR  aFileName;
    PCWSTR tempStrW;
    BOOL   result;
    LNK_EXTRA_DATAA extraDataA;

    aFileName = ConvertWtoA (FileName);

    result = ExtractPifInfoA (
                aFileName,
                &aTarget,
                &aParams,
                &aWorkDir,
                &aIconPath,
                IconNumber,
                MsDosMode,
                ExtraData?&extraDataA:NULL
                );
    FreeConvertedStr (aFileName);

    if (Target) {
        *Target = NULL;
        if (aTarget) {
            tempStrW = ConvertAtoW (aTarget);
            *Target = DuplicatePathStringW (tempStrW, 0);
            FreeConvertedStr (tempStrW);
        }
    }
    if (aTarget) {
        FreePathStringA (aTarget);
    }

    if (Params) {
        *Params = NULL;
        if (aParams) {
            tempStrW = ConvertAtoW (aParams);
            *Params = DuplicatePathStringW (tempStrW, 0);
            FreeConvertedStr (tempStrW);
        }
    }
    if (aParams) {
        FreePathStringA (aParams);
    }

    if (WorkDir) {
        *WorkDir = NULL;
        if (aWorkDir) {
            tempStrW = ConvertAtoW (aWorkDir);
            *WorkDir = DuplicatePathStringW (tempStrW, 0);
            FreeConvertedStr (tempStrW);
        }
    }
    if (aWorkDir) {
        FreePathStringA (aWorkDir);
    }

    if (IconPath) {
        *IconPath = NULL;
        if (aIconPath) {
            tempStrW = ConvertAtoW (aIconPath);
            *IconPath = DuplicatePathStringW (tempStrW, 0);
            FreeConvertedStr (tempStrW);
        }
    }
    if (aIconPath) {
        FreePathStringA (aIconPath);
    }

    if (ExtraData) {
        ExtraData->FullScreen = extraDataA.FullScreen;
        ExtraData->xSize = extraDataA.xSize;
        ExtraData->ySize = extraDataA.ySize;
        ExtraData->QuickEdit = extraDataA.QuickEdit;
        tempStrW = ConvertAtoW (extraDataA.FontName);
        StringCopyW (ExtraData->FontName, tempStrW);
        FreeConvertedStr (tempStrW);
        ExtraData->xFontSize = extraDataA.xFontSize;
        ExtraData->yFontSize = extraDataA.yFontSize;
        ExtraData->FontWeight = extraDataA.FontWeight;
        ExtraData->FontFamily = extraDataA.FontFamily;
        ExtraData->CurrentCodePage = extraDataA.CurrentCodePage;
    }

    return result;
}

BOOL
ExtractUrlInfoA(
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber
    )
{
    CHAR buffer [MAXINISIZE];

    buffer [0] = 0;
    GetPrivateProfileStringA ("InternetShortcut", "URL", "", buffer, MAXINISIZE - 1, FileName);
    if (Target) {
        *Target = DuplicatePathStringA (buffer, 0);
    }

    buffer [0] = 0;
    GetPrivateProfileStringA ("InternetShortcut", "IconFile", "", buffer, MAXINISIZE - 1, FileName);
    if (IconPath) {
        *IconPath = DuplicatePathStringA (buffer, 0);
    }

    if (IconNumber) {
        *IconNumber = GetPrivateProfileIntA ("InternetShortcut", "IconIndex", 0, FileName);
    }

    return TRUE;
}

BOOL
ExtractUrlInfoW(
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber
    )
{
    WCHAR buffer [MAXINISIZE];

    buffer [0] = 0;
    GetPrivateProfileStringW (L"InternetShortcut", L"URL", L"", buffer, MAXINISIZE - 1, FileName);
    if (Target) {
        *Target = DuplicatePathStringW (buffer, 0);
    }

    buffer [0] = 0;
    GetPrivateProfileStringW (L"InternetShortcut", L"IconFile", L"", buffer, MAXINISIZE - 1, FileName);
    if (IconPath) {
        *IconPath = DuplicatePathStringW (buffer, 0);
    }

    if (IconNumber) {
        *IconNumber = GetPrivateProfileIntW (L"InternetShortcut", L"IconIndex", 0, FileName);
    }

    return TRUE;
}

BOOL
ExtractShellLinkInfoA (
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    CHAR tempStr [MEMDB_MAX];
    PCSTR sanitizedStr = NULL;
    PCWSTR fileNameW;
    PSTR strPtr;
    HRESULT hres;
    WIN32_FIND_DATAA fd;
    IShellLinkDataList *shellLinkDataList;
    LPEXP_SZ_LINK expSzLink;
    LPITEMIDLIST idList;
    IShellFolder *desktopFolder = NULL;
    STRRET folderName;
    PCSTR convStr;

    if (Target) {
        *Target = NULL;
    }
    if (Params) {
        *Params = NULL;
    }
    if (WorkDir) {
        *WorkDir = NULL;
    }
    if (IconPath) {
        *IconPath = NULL;
    }

    fileNameW = ConvertAtoW (FileName);
    hres = PersistFile->lpVtbl->Load(PersistFile, fileNameW, STGM_READ);
    FreeConvertedStr (fileNameW);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot load link %s", FileName));
        return FALSE;
    }

    //
    // Get the link target
    //
    hres = ShellLink->lpVtbl->GetPath (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                &fd,
                                SLGP_RAWPATH
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    if (Target) {
        sanitizedStr = SanitizePathA (tempStr);
        *Target = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
        if (sanitizedStr) {
            FreePathStringA (sanitizedStr);
            sanitizedStr = NULL;
        }

        // One more thing: let's see if the actual target is a EXPAND_SZ
        hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &shellLinkDataList);
        if (SUCCEEDED(hres)) {
            hres = shellLinkDataList->lpVtbl->CopyDataBlock (shellLinkDataList, EXP_SZ_LINK_SIG, (LPVOID*)&expSzLink);
            if (SUCCEEDED(hres)) {
                if (expSzLink->szTarget [0]) {
                    FreePathStringA (*Target);
                    sanitizedStr = SanitizePathA (expSzLink->szTarget);
                    *Target = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
                    if (sanitizedStr) {
                        FreePathStringA (sanitizedStr);
                        sanitizedStr = NULL;
                    }
                }
                LocalFree (expSzLink);
            }
            shellLinkDataList->lpVtbl->Release (shellLinkDataList);
        }
    }

    //
    // Get the link working directory
    //
    hres = ShellLink->lpVtbl->GetWorkingDirectory (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr)
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    if (WorkDir) {
        sanitizedStr = SanitizePathA (tempStr);
        if (sanitizedStr) {
            strPtr = (PSTR)GetEndOfStringA (sanitizedStr);
            if (strPtr) {
                strPtr = _mbsdec (sanitizedStr, strPtr);
                if (strPtr) {
                    if (_mbsnextc (strPtr) == '\\') {
                        *strPtr = 0;
                    }
                }
            }
        }
        *WorkDir = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
        if (sanitizedStr) {
            FreePathStringA (sanitizedStr);
            sanitizedStr = NULL;
        }
    }

    //
    // Get the arguments.
    //
    hres = ShellLink->lpVtbl->GetArguments (
                                ShellLink,
                                tempStr,
                                MEMDB_MAX
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read arguments for link %s", FileName));
        return FALSE;
    }
    if (Params) {
        *Params = DuplicatePathStringA (tempStr, 0);
    }

    //
    // Get icon path
    //
    hres = ShellLink->lpVtbl->GetIconLocation (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                IconNumber
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read icon path for link %s", FileName));
        return FALSE;
    }
    if (IconPath) {
        sanitizedStr = SanitizePathA (tempStr);
        *IconPath = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
        if (sanitizedStr) {
            FreePathStringA (sanitizedStr);
            sanitizedStr = NULL;
        }

        // One more thing: let's see if the actual icon path is a EXPAND_SZ
        hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &shellLinkDataList);
        if (SUCCEEDED(hres)) {
            hres = shellLinkDataList->lpVtbl->CopyDataBlock (shellLinkDataList, EXP_SZ_ICON_SIG, (LPVOID*)&expSzLink);
            if (SUCCEEDED(hres)) {
                if (expSzLink->szTarget [0]) {
                    FreePathStringA (*IconPath);
                    sanitizedStr = SanitizePathA (expSzLink->szTarget);
                    *IconPath = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
                    if (sanitizedStr) {
                        FreePathStringA (sanitizedStr);
                        sanitizedStr = NULL;
                    }
                }
                LocalFree (expSzLink);
            }
            shellLinkDataList->lpVtbl->Release (shellLinkDataList);
        }
    }

    //
    // Get hot key
    //
    hres = ShellLink->lpVtbl->GetHotkey (
                                ShellLink,
                                HotKey
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read hot key for link %s", FileName));
        return FALSE;
    }

    return TRUE;
}

BOOL
ExtractShellLinkInfoW (
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    WCHAR tempStr [MEMDB_MAX];
    PCWSTR sanitizedStr = NULL;
    PWSTR strPtr;
    HRESULT hres;
    WIN32_FIND_DATAW fd;
    IShellLinkDataList *shellLinkDataList;
    LPEXP_SZ_LINK expSzLink;
    LPITEMIDLIST idList;
    IShellFolder *desktopFolder = NULL;
    STRRET folderName;
    PCWSTR convStr;

    if (Target) {
        *Target = NULL;
    }
    if (Params) {
        *Params = NULL;
    }
    if (WorkDir) {
        *WorkDir = NULL;
    }
    if (IconPath) {
        *IconPath = NULL;
    }

    hres = PersistFile->lpVtbl->Load(PersistFile, FileName, STGM_READ);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot load link %s", FileName));
        return FALSE;
    }

    //
    // Get the link target
    //
    hres = ShellLink->lpVtbl->GetPath (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                &fd,
                                SLGP_RAWPATH
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    if (Target) {
        sanitizedStr = SanitizePathW (tempStr);
        *Target = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
        if (sanitizedStr) {
            FreePathStringW (sanitizedStr);
            sanitizedStr = NULL;
        }

        // One more thing: let's see if the actual icon path is a EXPAND_SZ
        hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &shellLinkDataList);
        if (SUCCEEDED(hres)) {
            hres = shellLinkDataList->lpVtbl->CopyDataBlock (shellLinkDataList, EXP_SZ_LINK_SIG, (LPVOID*)&expSzLink);
            if (SUCCEEDED(hres)) {
                if (expSzLink->swzTarget [0]) {
                    FreePathStringW (*Target);
                    sanitizedStr = SanitizePathW (expSzLink->swzTarget);
                    *Target = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
                    if (sanitizedStr) {
                        FreePathStringW (sanitizedStr);
                        sanitizedStr = NULL;
                    }
                }
                LocalFree (expSzLink);
            }
            shellLinkDataList->lpVtbl->Release (shellLinkDataList);
        }
    }

    //
    // Get the link working directory
    //
    hres = ShellLink->lpVtbl->GetWorkingDirectory (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr)
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    if (WorkDir) {
        sanitizedStr = SanitizePathW (tempStr);
        if (sanitizedStr) {
            strPtr = GetEndOfStringW (sanitizedStr) - 1;
            if (strPtr >= sanitizedStr) {
                if (*strPtr == L'\\') {
                    *strPtr = 0;
                }
            }
        }
        *WorkDir = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
        if (sanitizedStr) {
            FreePathStringW (sanitizedStr);
            sanitizedStr = NULL;
        }
    }

    //
    // Get the arguments.
    //
    hres = ShellLink->lpVtbl->GetArguments (
                                ShellLink,
                                tempStr,
                                MEMDB_MAX
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read arguments for link %s", FileName));
        return FALSE;
    }
    if (Params) {
        *Params = DuplicatePathStringW (tempStr, 0);
    }

    //
    // Get icon path
    //
    hres = ShellLink->lpVtbl->GetIconLocation (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                IconNumber
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read icon path for link %s", FileName));
        return FALSE;
    }
    if (IconPath) {
        sanitizedStr = SanitizePathW (tempStr);
        *IconPath = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
        if (sanitizedStr) {
            FreePathStringW (sanitizedStr);
            sanitizedStr = NULL;
        }

        // One more thing: let's see if the actual icon path is a EXPAND_SZ
        hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &shellLinkDataList);
        if (SUCCEEDED(hres)) {
            hres = shellLinkDataList->lpVtbl->CopyDataBlock (shellLinkDataList, EXP_SZ_ICON_SIG, (LPVOID*)&expSzLink);
            if (SUCCEEDED(hres)) {
                if (expSzLink->swzTarget [0]) {
                    FreePathStringW (*IconPath);
                    sanitizedStr = SanitizePathW (expSzLink->swzTarget);
                    *IconPath = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
                    if (sanitizedStr) {
                        FreePathStringW (sanitizedStr);
                        sanitizedStr = NULL;
                    }
                }
                LocalFree (expSzLink);
            }
            shellLinkDataList->lpVtbl->Release (shellLinkDataList);
        }
    }

    //
    // Get hot key
    //
    hres = ShellLink->lpVtbl->GetHotkey (
                                ShellLink,
                                HotKey
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read hot key for link %s", FileName));
        return FALSE;
    }

    return TRUE;
}

BOOL
ExtractShortcutInfoA (
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData, OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCSTR shortcutExt = NULL;

    *MsDosMode  = FALSE;
    *DosApp     = FALSE;
    *HotKey     = 0;

    if (Target) {
        *Target = NULL;
    }
    if (Params) {
        *Params = NULL;
    }
    if (WorkDir) {
        *WorkDir = NULL;
    }
    if (IconPath) {
        *IconPath = NULL;
    }
    if (ExtraData) {
        ZeroMemory (ExtraData, sizeof (LNK_EXTRA_DATAA));
    }

    shortcutExt = GetFileExtensionFromPathA (FileName);

    if (shortcutExt != NULL) {
        if (StringIMatchA (shortcutExt, "LNK")) {
            return ExtractShellLinkInfoA (
                        FileName,
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        HotKey,
                        ShellLink,
                        PersistFile
                        );

        } else if (StringIMatchA (shortcutExt, "PIF")) {

            *DosApp = TRUE;
            return ExtractPifInfoA (
                        FileName,
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        MsDosMode,
                        ExtraData
                        );

        } else if (StringIMatchA (shortcutExt, "URL")) {

            *Params = NULL;
            *WorkDir = NULL;
            return ExtractUrlInfoA (
                        FileName,
                        Target,
                        IconPath,
                        IconNumber
                        );

        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

BOOL
ExtractShortcutInfoW (
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData, OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCWSTR shortcutExt = NULL;

    *MsDosMode  = FALSE;
    *DosApp     = FALSE;
    *HotKey     = 0;

    if (Target) {
        *Target = NULL;
    }
    if (Params) {
        *Params = NULL;
    }
    if (WorkDir) {
        *WorkDir = NULL;
    }
    if (IconPath) {
        *IconPath = NULL;
    }
    if (ExtraData) {
        ZeroMemory (ExtraData, sizeof (LNK_EXTRA_DATAW));
    }

    shortcutExt = GetFileExtensionFromPathW (FileName);

    if (shortcutExt != NULL) {
        if (StringIMatchW (shortcutExt, L"LNK")) {
            return ExtractShellLinkInfoW (
                        FileName,
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        HotKey,
                        ShellLink,
                        PersistFile
                        );

        } else if (StringIMatchW (shortcutExt, L"PIF")) {

            *DosApp = TRUE;
            return ExtractPifInfoW (
                        FileName,
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        MsDosMode,
                        ExtraData
                        );

        } else if (StringIMatchW (shortcutExt, L"URL")) {

            *Params = NULL;
            *WorkDir = NULL;
            return ExtractUrlInfoW (
                        FileName,
                        Target,
                        IconPath,
                        IconNumber
                        );

        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

BOOL
ModifyShellLinkFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,               OPTIONAL
    IN      PCSTR Params,               OPTIONAL
    IN      PCSTR WorkDir,              OPTIONAL
    IN      PCSTR IconPath,             OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAA ExtraData, OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCWSTR fileNameW = NULL;
    PCWSTR faceNameW;
    HRESULT comResult;

    __try {
        if (!DoesFileExistA (FileName)) {
            __leave;
        }
        if (((Target   == NULL) || (Target   [0] == 0)) &&
            ((Params   == NULL) || (Params   [0] == 0)) &&
            ((WorkDir  == NULL) || (WorkDir  [0] == 0)) &&
            ((IconPath == NULL) || (IconPath [0] == 0)) &&
            (HotKey == 0) &&
            (ExtraData == NULL)
            ) {
            __leave;
        }

        fileNameW = ConvertAtoW (FileName);
        comResult = PersistFile->lpVtbl->Load(PersistFile, fileNameW, STGM_READ);
        if (comResult != S_OK) {
            LOGA ((LOG_ERROR, "LINKEDIT: Load failed for %s", FileName));
            __leave;
        }

        if (Target != NULL) {
            comResult = ShellLink->lpVtbl->SetPath (ShellLink, Target);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SetPath failed for %s", FileName));
            }
        }
        if (Params != NULL) {
            comResult = ShellLink->lpVtbl->SetArguments (ShellLink, Params);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SetArguments failed for %s", FileName));
            }
        }
        if (WorkDir != NULL) {
            comResult = ShellLink->lpVtbl->SetWorkingDirectory (ShellLink, WorkDir);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SetWorkingDirectory failed for %s", FileName));
            }
        }
        if (IconPath != NULL) {
            comResult = ShellLink->lpVtbl->SetIconLocation (ShellLink, IconPath, IconNumber);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SetIconLocation failed for %s", FileName));
            }
        }
        // NTRAID#NTBUG9-153303-2000/08/01-jimschm Add HotKey processing here

        //
        // add NT_CONSOLE_PROPS
        //
        if (ExtraData) {

            HRESULT hres;
            NT_CONSOLE_PROPS props;
            NT_CONSOLE_PROPS *oldProps;

            IShellLinkDataList *psldl;
            //
            // Get a pointer to the IShellLinkDataList interface.
            //
            hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &psldl);

            if (!SUCCEEDED (hres)) {
                DEBUGMSGA ((DBG_WARNING, "Cannot get IShellLinkDataList interface"));
                __leave;
            }

            ZeroMemory (&props, sizeof (NT_CONSOLE_PROPS));
            props.cbSize = sizeof (NT_CONSOLE_PROPS);
            props.dwSignature = NT_CONSOLE_PROPS_SIG;

            //
            // let's try to get the extra data
            //
            comResult = psldl->lpVtbl->CopyDataBlock (psldl, NT_CONSOLE_PROPS_SIG, &oldProps);
            if ((comResult != S_OK) || (oldProps->cbSize != props.cbSize)) {
                // no extra data exists. We need to fill some good data for this console
                props.wFillAttribute = 0x0007;
                props.wPopupFillAttribute = 0x00f5;
                props.dwWindowOrigin.X = 0;
                props.dwWindowOrigin.Y = 0;
                props.nFont = 0;
                props.nInputBufferSize = 0;
                props.uCursorSize = 0x0019;
                props.bInsertMode = FALSE;
                props.bAutoPosition = TRUE;
                props.uHistoryBufferSize = 0x0032;
                props.uNumberOfHistoryBuffers = 0x0004;
                props.bHistoryNoDup = FALSE;
                props.ColorTable [0] = 0x00000000;
                props.ColorTable [1] = 0x00800000;
                props.ColorTable [2] = 0x00008000;
                props.ColorTable [3] = 0x00808000;
                props.ColorTable [4] = 0x00000080;
                props.ColorTable [5] = 0x00800080;
                props.ColorTable [6] = 0x00008080;
                props.ColorTable [7] = 0x00c0c0c0;
                props.ColorTable [8] = 0x00808080;
                props.ColorTable [9] = 0x00ff0000;
                props.ColorTable [10] = 0x0000ff00;
                props.ColorTable [11] = 0x00ffff00;
                props.ColorTable [12] = 0x000000ff;
                props.ColorTable [13] = 0x00ff00ff;
                props.ColorTable [14] = 0x0000ffff;
                props.ColorTable [15] = 0x00ffffff;
            } else {
                props.wFillAttribute = oldProps->wFillAttribute;
                props.wPopupFillAttribute = oldProps->wPopupFillAttribute;
                props.dwWindowOrigin.X = oldProps->dwWindowOrigin.X;
                props.dwWindowOrigin.Y = oldProps->dwWindowOrigin.Y;
                props.nFont = oldProps->nFont;
                props.nInputBufferSize = oldProps->nInputBufferSize;
                props.uCursorSize = oldProps->uCursorSize;
                props.bInsertMode = oldProps->bInsertMode;
                props.bAutoPosition = oldProps->bAutoPosition;
                props.uHistoryBufferSize = oldProps->uHistoryBufferSize;
                props.uNumberOfHistoryBuffers = oldProps->uNumberOfHistoryBuffers;
                props.bHistoryNoDup = oldProps->bHistoryNoDup;
                props.ColorTable [0] = oldProps->ColorTable [0];
                props.ColorTable [1] = oldProps->ColorTable [1];
                props.ColorTable [2] = oldProps->ColorTable [2];
                props.ColorTable [3] = oldProps->ColorTable [3];
                props.ColorTable [4] = oldProps->ColorTable [4];
                props.ColorTable [5] = oldProps->ColorTable [5];
                props.ColorTable [6] = oldProps->ColorTable [6];
                props.ColorTable [7] = oldProps->ColorTable [7];
                props.ColorTable [8] = oldProps->ColorTable [8];
                props.ColorTable [9] = oldProps->ColorTable [9];
                props.ColorTable [10] = oldProps->ColorTable [10];
                props.ColorTable [11] = oldProps->ColorTable [11];
                props.ColorTable [12] = oldProps->ColorTable [12];
                props.ColorTable [13] = oldProps->ColorTable [13];
                props.ColorTable [14] = oldProps->ColorTable [14];
                props.ColorTable [15] = oldProps->ColorTable [15];
                psldl->lpVtbl->RemoveDataBlock (psldl, NT_CONSOLE_PROPS_SIG);
            }

            props.dwScreenBufferSize.X = (SHORT)ExtraData->xSize;
            props.dwScreenBufferSize.Y = (SHORT)ExtraData->ySize;
            props.dwWindowSize.X = (SHORT)ExtraData->xSize;
            props.dwWindowSize.Y = (SHORT)ExtraData->ySize;
            props.dwFontSize.X = (UINT)ExtraData->xFontSize;
            props.dwFontSize.Y = (UINT)ExtraData->yFontSize;
            props.uFontFamily = ExtraData->FontFamily;
            props.uFontWeight = ExtraData->FontWeight;
            faceNameW = ConvertAtoW (ExtraData->FontName);
            StringCopyW (props.FaceName, faceNameW);
            FreeConvertedStr (faceNameW);
            props.bFullScreen = ExtraData->FullScreen;
            props.bQuickEdit = ExtraData->QuickEdit;
            comResult = psldl->lpVtbl->AddDataBlock (psldl, &props);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: AddDataBlock failed for %s", FileName));
            }
        }

        comResult = PersistFile->lpVtbl->Save (PersistFile, fileNameW, FALSE);
        if (comResult != S_OK) {
            DEBUGMSGA ((DBG_WARNING, "LINKEDIT: Save failed for %s", FileName));
        }

        comResult = PersistFile->lpVtbl->SaveCompleted (PersistFile, fileNameW);
        if (comResult != S_OK) {
            DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SaveCompleted failed for %s", FileName));
        }

        FreeConvertedStr (fileNameW);
        fileNameW = NULL;
    }
    __finally {
        if (fileNameW) {
            FreeConvertedStr (fileNameW);
            fileNameW = NULL;
        }
    }
    return TRUE;
}

BOOL
ModifyShellLinkFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,               OPTIONAL
    IN      PCWSTR Params,               OPTIONAL
    IN      PCWSTR WorkDir,              OPTIONAL
    IN      PCWSTR IconPath,             OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAW ExtraData, OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    HRESULT comResult;

    __try {
        if (!DoesFileExistW (FileName)) {
            __leave;
        }
        if (((Target   == NULL) || (Target   [0] == 0)) &&
            ((Params   == NULL) || (Params   [0] == 0)) &&
            ((WorkDir  == NULL) || (WorkDir  [0] == 0)) &&
            ((IconPath == NULL) || (IconPath [0] == 0)) &&
            (HotKey == 0) &&
            (ExtraData == NULL)
            ) {
            __leave;
        }

        comResult = PersistFile->lpVtbl->Load(PersistFile, FileName, STGM_READ);
        if (comResult != S_OK) {
            LOGW ((LOG_ERROR, "LINKEDIT: Load failed for %s", FileName));
            __leave;
        }

        if (Target != NULL) {
            comResult = ShellLink->lpVtbl->SetPath (ShellLink, Target);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SetPath failed for %s", FileName));
            }
        }
        if (Params != NULL) {
            comResult = ShellLink->lpVtbl->SetArguments (ShellLink, Params);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SetArguments failed for %s", FileName));
            }
        }
        if (WorkDir != NULL) {
            comResult = ShellLink->lpVtbl->SetWorkingDirectory (ShellLink, WorkDir);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SetWorkingDirectory failed for %s", FileName));
            }
        }
        if (IconPath != NULL) {
            comResult = ShellLink->lpVtbl->SetIconLocation (ShellLink, IconPath, IconNumber);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SetIconLocation failed for %s", FileName));
            }
        }
        // NTRAID#NTBUG9-153303-2000/08/01-jimschm Add HotKey processing here

        //
        // add NT_CONSOLE_PROPS
        //
        if (ExtraData) {

            HRESULT hres;
            NT_CONSOLE_PROPS props;
            NT_CONSOLE_PROPS *oldProps;

            IShellLinkDataList *psldl;
            //
            // Get a pointer to the IShellLinkDataList interface.
            //
            hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &psldl);

            if (!SUCCEEDED (hres)) {
                DEBUGMSGW ((DBG_WARNING, "Cannot get IShellLinkDataList interface"));
                __leave;
            }

            ZeroMemory (&props, sizeof (NT_CONSOLE_PROPS));
            props.cbSize = sizeof (NT_CONSOLE_PROPS);
            props.dwSignature = NT_CONSOLE_PROPS_SIG;

            //
            // let's try to get the extra data
            //
            comResult = psldl->lpVtbl->CopyDataBlock (psldl, NT_CONSOLE_PROPS_SIG, &oldProps);
            if ((comResult != S_OK) || (oldProps->cbSize != props.cbSize)) {
                // no extra data exists. We need to fill some good data for this console
                props.wFillAttribute = 0x0007;
                props.wPopupFillAttribute = 0x00f5;
                props.dwWindowOrigin.X = 0;
                props.dwWindowOrigin.Y = 0;
                props.nFont = 0;
                props.nInputBufferSize = 0;
                props.uCursorSize = 0x0019;
                props.bInsertMode = FALSE;
                props.bAutoPosition = TRUE;
                props.uHistoryBufferSize = 0x0032;
                props.uNumberOfHistoryBuffers = 0x0004;
                props.bHistoryNoDup = FALSE;
                props.ColorTable [0] = 0x00000000;
                props.ColorTable [1] = 0x00800000;
                props.ColorTable [2] = 0x00008000;
                props.ColorTable [3] = 0x00808000;
                props.ColorTable [4] = 0x00000080;
                props.ColorTable [5] = 0x00800080;
                props.ColorTable [6] = 0x00008080;
                props.ColorTable [7] = 0x00c0c0c0;
                props.ColorTable [8] = 0x00808080;
                props.ColorTable [9] = 0x00ff0000;
                props.ColorTable [10] = 0x0000ff00;
                props.ColorTable [11] = 0x00ffff00;
                props.ColorTable [12] = 0x000000ff;
                props.ColorTable [13] = 0x00ff00ff;
                props.ColorTable [14] = 0x0000ffff;
                props.ColorTable [15] = 0x00ffffff;
            } else {
                props.wFillAttribute = oldProps->wFillAttribute;
                props.wPopupFillAttribute = oldProps->wPopupFillAttribute;
                props.dwWindowOrigin.X = oldProps->dwWindowOrigin.X;
                props.dwWindowOrigin.Y = oldProps->dwWindowOrigin.Y;
                props.nFont = oldProps->nFont;
                props.nInputBufferSize = oldProps->nInputBufferSize;
                props.uCursorSize = oldProps->uCursorSize;
                props.bInsertMode = oldProps->bInsertMode;
                props.bAutoPosition = oldProps->bAutoPosition;
                props.uHistoryBufferSize = oldProps->uHistoryBufferSize;
                props.uNumberOfHistoryBuffers = oldProps->uNumberOfHistoryBuffers;
                props.bHistoryNoDup = oldProps->bHistoryNoDup;
                props.ColorTable [0] = oldProps->ColorTable [0];
                props.ColorTable [1] = oldProps->ColorTable [1];
                props.ColorTable [2] = oldProps->ColorTable [2];
                props.ColorTable [3] = oldProps->ColorTable [3];
                props.ColorTable [4] = oldProps->ColorTable [4];
                props.ColorTable [5] = oldProps->ColorTable [5];
                props.ColorTable [6] = oldProps->ColorTable [6];
                props.ColorTable [7] = oldProps->ColorTable [7];
                props.ColorTable [8] = oldProps->ColorTable [8];
                props.ColorTable [9] = oldProps->ColorTable [9];
                props.ColorTable [10] = oldProps->ColorTable [10];
                props.ColorTable [11] = oldProps->ColorTable [11];
                props.ColorTable [12] = oldProps->ColorTable [12];
                props.ColorTable [13] = oldProps->ColorTable [13];
                props.ColorTable [14] = oldProps->ColorTable [14];
                props.ColorTable [15] = oldProps->ColorTable [15];
                psldl->lpVtbl->RemoveDataBlock (psldl, NT_CONSOLE_PROPS_SIG);
            }

            props.dwScreenBufferSize.X = (SHORT)ExtraData->xSize;
            props.dwScreenBufferSize.Y = (SHORT)ExtraData->ySize;
            props.dwWindowSize.X = (SHORT)ExtraData->xSize;
            props.dwWindowSize.Y = (SHORT)ExtraData->ySize;
            props.dwFontSize.X = (UINT)ExtraData->xFontSize;
            props.dwFontSize.Y = (UINT)ExtraData->yFontSize;
            props.uFontFamily = ExtraData->FontFamily;
            props.uFontWeight = ExtraData->FontWeight;
            StringCopyW (props.FaceName, ExtraData->FontName);
            props.bFullScreen = ExtraData->FullScreen;
            props.bQuickEdit = ExtraData->QuickEdit;
            comResult = psldl->lpVtbl->AddDataBlock (psldl, &props);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: AddDataBlock failed for %s", FileName));
            }
        }

        comResult = PersistFile->lpVtbl->Save (PersistFile, FileName, FALSE);
        if (comResult != S_OK) {
            DEBUGMSGW ((DBG_WARNING, "LINKEDIT: Save failed for %s", FileName));
        }

        comResult = PersistFile->lpVtbl->SaveCompleted (PersistFile, FileName);
        if (comResult != S_OK) {
            DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SaveCompleted failed for %s", FileName));
        }
    }
    __finally {
    }
    return TRUE;
}

BOOL
ModifyPifFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,       OPTIONAL
    IN      PCSTR Params,       OPTIONAL
    IN      PCSTR WorkDir,      OPTIONAL
    IN      PCSTR IconPath,     OPTIONAL
    IN      INT  IconNumber
    )
{
    PCSTR fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PSTDPIF stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    __try {
        fileImage = MapFileIntoMemoryExA (FileName, &fileHandle, &mapHandle, TRUE);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;
            if (Target != NULL) {
                strncpy (stdPif->startfile, Target, PIFSTARTLOCSIZE);
            }

            if (Params != NULL) {
                strncpy (stdPif->params, Params, PIFPARAMSSIZE);
            }

            if (WorkDir != NULL) {
                strncpy (stdPif->defpath, WorkDir, PIFDEFPATHSIZE);
            }

            if (IconPath != NULL) {
                wenhPif40 = (PWENHPIF40) pFindEnhPifSignature ((PVOID)fileImage, WENHHDRSIG40);

                if (wenhPif40 != NULL) {
                    strncpy (wenhPif40->achIconFileProp, IconPath, PIFDEFFILESIZE);
                    wenhPif40->wIconIndexProp = (WORD)IconNumber;
                }
            }
            // in all cases we want to take off MSDOS mode otherwise NT won't start these PIFs
            w386ext30 = pFindEnhPifSignature ((PVOID)fileImage, W386HDRSIG30);
            if (w386ext30) {
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealMode);
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealModeSilent);
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            // let's just do nothing and exit from here

            DEBUGMSGW ((DBG_WARNING, "Exception thrown when processing %s", FileName));
        }
    }
    __finally {
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return TRUE;
}

BOOL
ModifyPifFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,          OPTIONAL
    IN      PCWSTR Params,          OPTIONAL
    IN      PCWSTR WorkDir,         OPTIONAL
    IN      PCWSTR IconPath,        OPTIONAL
    IN      INT  IconNumber
    )
{
    PCSTR fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCSTR AnsiStr = NULL;
    PSTDPIF stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    __try {
        fileImage = MapFileIntoMemoryExW (FileName, &fileHandle, &mapHandle, TRUE);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;
            if (Target != NULL) {

                AnsiStr = ConvertWtoA (Target);
                strncpy (stdPif->startfile, AnsiStr, PIFSTARTLOCSIZE);
                FreeConvertedStr (AnsiStr);
            }

            if (Params != NULL) {

                AnsiStr = ConvertWtoA (Params);
                strncpy (stdPif->params, AnsiStr, PIFPARAMSSIZE);
                FreeConvertedStr (AnsiStr);
            }

            if (WorkDir != NULL) {

                AnsiStr = ConvertWtoA (WorkDir);
                strncpy (stdPif->defpath, AnsiStr, PIFDEFPATHSIZE);
                FreeConvertedStr (AnsiStr);
            }

            if (IconPath != NULL) {
                wenhPif40 = (PWENHPIF40) pFindEnhPifSignature ((PVOID)fileImage, WENHHDRSIG40);

                if (wenhPif40 != NULL) {

                    AnsiStr = ConvertWtoA (IconPath);
                    strncpy (wenhPif40->achIconFileProp, AnsiStr, PIFDEFFILESIZE);
                    FreeConvertedStr (AnsiStr);

                    wenhPif40->wIconIndexProp = (WORD)IconNumber;
                }
            }
            // in all cases we want to take off MSDOS mode otherwise NT won't start these PIFs
            w386ext30 = pFindEnhPifSignature ((PVOID)fileImage, W386HDRSIG30);
            if (w386ext30) {
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealMode);
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealModeSilent);
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            // let's just do nothing and exit from here

            DEBUGMSGW ((DBG_WARNING, "Exception thrown when processing %s", FileName));
        }
    }
    __finally {
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return TRUE;
}

BOOL
ModifyUrlFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,           OPTIONAL
    IN      PCSTR IconPath,         OPTIONAL
    IN      INT  IconNumber
    )
{
    CHAR buffer [12];

    if (Target != NULL) {
        WritePrivateProfileStringA ("InternetShortcut", "URL", Target, FileName);
    }
    if (IconPath != NULL) {
        WritePrivateProfileStringA ("InternetShortcut", "IconFile", IconPath, FileName);
        wsprintfA (buffer, "%d", IconNumber);
        WritePrivateProfileStringA ("InternetShortcut", "IconIndex", buffer, FileName);
    }
    return TRUE;
}

BOOL
ModifyUrlFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,          OPTIONAL
    IN      PCWSTR IconPath,        OPTIONAL
    IN      INT  IconNumber
    )
{
    WCHAR buffer [12];

    if (Target != NULL) {
        WritePrivateProfileStringW (L"InternetShortcut", L"URL", Target, FileName);
    }
    if (IconPath != NULL) {
        WritePrivateProfileStringW (L"InternetShortcut", L"IconFile", IconPath, FileName);
        wsprintfW (buffer, L"%d", IconNumber);
        WritePrivateProfileStringW (L"InternetShortcut", L"IconIndex", buffer, FileName);
    }
    return TRUE;
}

BOOL
ModifyShortcutFileExA (
    IN      PCSTR FileName,
    IN      PCSTR ForcedExtension,        OPTIONAL
    IN      PCSTR Target,                 OPTIONAL
    IN      PCSTR Params,                 OPTIONAL
    IN      PCSTR WorkDir,                OPTIONAL
    IN      PCSTR IconPath,               OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAA ExtraData,   OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCSTR shortcutExt;

    __try {
        shortcutExt = ForcedExtension;
        if (!shortcutExt) {
            shortcutExt = GetFileExtensionFromPathA (FileName);
        }
        if (shortcutExt) {
            if (StringIMatchA (shortcutExt, "LNK")) {
                return ModifyShellLinkFileA (
                            FileName,
                            Target,
                            Params,
                            WorkDir,
                            IconPath,
                            IconNumber,
                            HotKey,
                            NULL,
                            ShellLink,
                            PersistFile
                            );

            } else if (StringIMatchA (shortcutExt, "PIF")) {
                return ModifyPifFileA (
                            FileName,
                            Target,
                            Params,
                            WorkDir,
                            IconPath,
                            IconNumber
                            );
            } else if (StringIMatchA (shortcutExt, "URL")) {
                return ModifyUrlFileA (
                            FileName,
                            Target,
                            IconPath,
                            IconNumber
                            );
            }
        }
    }
    __except (1) {
        LOGA ((LOG_ERROR, "Cannot process shortcut %s", FileName));
    }

    return TRUE;
}

BOOL
ModifyShortcutFileExW (
    IN      PCWSTR FileName,
    IN      PCWSTR ForcedExtension,       OPTIONAL
    IN      PCWSTR Target,                OPTIONAL
    IN      PCWSTR Params,                OPTIONAL
    IN      PCWSTR WorkDir,               OPTIONAL
    IN      PCWSTR IconPath,              OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAW ExtraData,   OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCWSTR shortcutExt;

    __try {
        shortcutExt = ForcedExtension;
        if (!shortcutExt) {
            shortcutExt = GetFileExtensionFromPathW (FileName);
        }
        if (shortcutExt) {
            if (StringIMatchW (shortcutExt, L"LNK")) {
                return ModifyShellLinkFileW (
                            FileName,
                            Target,
                            Params,
                            WorkDir,
                            IconPath,
                            IconNumber,
                            HotKey,
                            NULL,
                            ShellLink,
                            PersistFile
                            );

            } else if (StringIMatchW (shortcutExt, L"PIF")) {
                return ModifyPifFileW (
                            FileName,
                            Target,
                            Params,
                            WorkDir,
                            IconPath,
                            IconNumber
                            );
            } else if (StringIMatchW (shortcutExt, L"URL")) {
                return ModifyUrlFileW (
                            FileName,
                            Target,
                            IconPath,
                            IconNumber
                            );
            }
        }
    }
    __except (1) {
        LOGW ((LOG_ERROR, "Cannot process shortcut %s", FileName));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\basereg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    <filename>

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\basemem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    basemem.c

Abstract:

    Implements macros and declares functions for basic allocation functions.
    Consolidated into this file from debug.c and main.c

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:

--*/


#include "pch.h"


//
// Includes
//

#include "utilsp.h"


//
// Constants
//

#ifdef DEBUG

#define TRAIL_SIG               0x708aa210
#define TRACK_SIGNATURE         0x30405060

#endif

//
// Macros
//

#define REUSE_SIZE_PTR(ptr) ((PDWORD) ((PBYTE) ptr - sizeof (DWORD)))
#define REUSE_TAG_PTR(ptr)  ((PDWORD) ((PBYTE) ptr + (*REUSE_SIZE_PTR(ptr))))


//
// Types
//

#ifdef DEBUG

typedef struct _tagTRACKSTRUCT {

    DWORD Signature;
    PCSTR File;
    DWORD Line;
    SIZE_T Size;
    PSTR Comment;
    PCSTR CallerFile;
    DWORD CallerLine;
    BOOL Allocated;
    struct _tagTRACKSTRUCT *PrevAlloc;
    struct _tagTRACKSTRUCT *NextAlloc;

} TRACKSTRUCT, *PTRACKSTRUCT;

#endif

//
// Globals
//

#ifdef DEBUG

PTRACKSTRUCT g_TrackHead = NULL;

#endif

//
// Heap debug statistics
//

static SIZE_T g_TotalBytesAllocated = 0;
static SIZE_T g_MaxBytesInUse = 0;
static SIZE_T g_HeapAllocs = 0;
static SIZE_T g_HeapReAllocs = 0;
static SIZE_T g_HeapFrees = 0;
static SIZE_T g_HeapAllocFails = 0;
static SIZE_T g_HeapReAllocFails = 0;
static SIZE_T g_HeapFreeFails = 0;

//
// Out of memory string -- loaded at initialization
//
PCSTR g_OutOfMemoryString = NULL;
PCSTR g_OutOfMemoryRetry = NULL;
HWND g_OutOfMemoryParentWnd;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

#ifdef DEBUG

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );



VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    );

VOID
pTrackDelete (
    PTRACKSTRUCT p
    );

#endif

//
// Macro expansion definition
//

// None

//
// Code
//



void
HeapCallFailed (
    PCSTR Msg,
    PCSTR File,
    DWORD Line
    )
{
    CHAR Msg2[2048];

    wsprintfA (Msg2, "Error in %s line %u\n\n", File, Line);
    if (_tcslen(Msg) + _tcslen(Msg2) < 2025) {
        strcat (Msg2, Msg);
    }
    strcat (Msg2, "\n\nBreak execution now?");

    if (IDYES == MessageBoxA (GetFocus(), Msg2, "Heap Call Failed", MB_YESNO|MB_APPLMODAL)) {
        DebugBreak ();
    }
}

#ifdef DEBUG

SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T rc;

    EnterCriticalSection (&g_MemAllocCs);

    rc = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);

    LeaveCriticalSection (&g_MemAllocCs);

    return rc;
}

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T size;
    PCVOID RealPtr;
    SIZE_T SizeAdjust;

    SizeAdjust = sizeof (TRACKSTRUCT);
    RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);

    if (IsBadWritePtr ((PBYTE) RealPtr - 8, 8)) {
        CHAR BadPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  This address is not valid.",
            (DWORD)((UBINT)CallerPtr >> 32),
            (DWORD)(UBINT)CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    size = HeapSize (hHeap, 0, RealPtr);
    if (size == (SIZE_T)-1) {
        CHAR BadPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  "
                "This address is not the start of a memory block.",
            (DWORD)((UBINT)CallerPtr >> 32),
            (DWORD)(UBINT)CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    return size;
}

PVOID
DebugHeapAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    SIZE_T BytesToAlloc
    )
{
    PVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD TrackStructSize;
    DWORD OrgError;

    EnterCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            // we want to go on, most likely we will AV shortly
        }

        RealPtr = SafeHeapAlloc(hHeap, Flags, BytesToAlloc + SizeAdjust);
        if (RealPtr) {
            g_HeapAllocs++;
            g_TotalBytesAllocated += HeapSize (hHeap, 0, RealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) RealPtr);
            *((PDWORD) ((PBYTE) RealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_HeapAllocFails++;
        }

        if (RealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) RealPtr + TrackStructSize);
        }

        if (ReturnPtr && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory (ReturnPtr, BytesToAlloc, 0xAA);
        }

        if (RealPtr) {
            SetLastError(OrgError);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

PVOID
DebugHeapReAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr,
    SIZE_T BytesToAlloc
    )
{
    UBINT lastSize;
    PVOID NewRealPtr;
    PCVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD OrgError;
    DWORD TrackStructSize;
    SIZE_T OrgSize;
    PTRACKSTRUCT pts = NULL;

    EnterCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - TrackStructSize);
        pts = (PTRACKSTRUCT) RealPtr;
        OrgSize = pts->Size;

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            // we want to go on, most likely we will AV shortly
        }

        lastSize = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (lastSize == (UBINT)INVALID_PTR) {
            // we want to go on, most likely we will AV shortly
        }

        pTrackDelete (pts);

        NewRealPtr = SafeHeapReAlloc (hHeap, Flags, (PVOID) RealPtr, BytesToAlloc + SizeAdjust);
        if (NewRealPtr) {
            g_HeapReAllocs++;
            g_TotalBytesAllocated -= lastSize;
            g_TotalBytesAllocated += HeapSize (hHeap, 0, NewRealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) NewRealPtr);
            *((PDWORD) ((PBYTE) NewRealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_HeapReAllocFails++;

            // Put original address back in
            pTrackInsert (
                pts->File,
                pts->Line,
                pts->Size,
                pts
                );

        }

        if (NewRealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) NewRealPtr + TrackStructSize);
        }

        if (ReturnPtr && BytesToAlloc > OrgSize && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory ((PBYTE) ReturnPtr + OrgSize, BytesToAlloc - OrgSize, 0xAA);
        }

        if (ReturnPtr) {
            SetLastError (OrgError);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

BOOL
DebugHeapFree (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr
    )
{
    UBINT size;
    PCVOID RealPtr;
    DWORD SizeAdjust;
    DWORD OrgError;
    BOOL Result = FALSE;
    PTRACKSTRUCT pts = NULL;

    EnterCriticalSection (&g_MemAllocCs);

    __try {
        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);
        pts = (PTRACKSTRUCT) RealPtr;

        if (*((PDWORD) ((PBYTE) CallerPtr + pts->Size)) != TRAIL_SIG) {
            HeapCallFailed ("Heap tag was overwritten!", File, Line);
            __leave;
        }

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        size = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (size == (UBINT)INVALID_PTR) {
            g_HeapFreeFails++;
            __leave;
        }

        pTrackDelete ((PTRACKSTRUCT) RealPtr);

        if (!HeapFree (hHeap, Flags, (PVOID) RealPtr)) {
            CHAR BadPtrMsg[256];

            wsprintfA (
                BadPtrMsg,
                "Attempt to free memory at 0x%08x with flags 0x%08x.  "
                "HeapFree() failed.",
                CallerPtr,
                Flags
                );

            HeapCallFailed (BadPtrMsg, File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        g_HeapFrees++;
        if (g_TotalBytesAllocated < size) {
            DEBUGMSG ((DBG_WARNING, "Total bytes allocated is less than amount being freed.  "
                                    "This suggests memory corruption."));
            g_TotalBytesAllocated = 0;
        } else {
            g_TotalBytesAllocated -= size;
        }

        SetLastError (OrgError);
        Result = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return Result;

}

VOID
DumpHeapStats (
    VOID
    )
{
    CHAR OutputMsg[4096];

    wsprintfA (OutputMsg,
               "Bytes currently allocated: %u\n"
               "Peak bytes allocated: %u\n"
               "Allocation count: %u\n"
               "Reallocation count: %u\n"
               "Free count: %u\n",
               g_TotalBytesAllocated,
               g_MaxBytesInUse,
               g_HeapAllocs,
               g_HeapReAllocs,
               g_HeapFrees
               );

    if (g_HeapAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Allocation failures: %u\n",
                   g_HeapAllocFails);
    }
    if (g_HeapReAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Reallocation failures: %u\n",
                   g_HeapReAllocFails);
    }
    if (g_HeapFreeFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Free failures: %u\n",
                   g_HeapFreeFails);
    }

    DEBUGMSG ((DBG_STATS, "%s", OutputMsg));

#ifdef CONSOLE
    printf ("%s", OutputMsg);
#endif // #ifndef CONSOLE
}

void
DebugHeapCheck (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap
    )
{
    EnterCriticalSection (&g_MemAllocCs);

    if (!HeapValidate (hHeap, 0, NULL)) {
        HeapCallFailed ("HeapCheck failed: Heap is corrupt!", File, Line);
    }

    LeaveCriticalSection (&g_MemAllocCs);
}

#endif

PVOID
ReuseAlloc (
    HANDLE Heap,
    PVOID OldPtr,
    DWORD SizeNeeded
    )
{
    DWORD CurrentSize;
    PVOID Ptr = NULL;
    UINT AllocAdjustment = sizeof(DWORD);

    //
    // HeapSize is not very good, so while it may look good, don't
    // use it.
    //

#ifdef DEBUG
    AllocAdjustment += sizeof (DWORD);
#endif

    if (!OldPtr) {
        Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
    } else {

        CurrentSize = *REUSE_SIZE_PTR(OldPtr);

#ifdef DEBUG
        if (*REUSE_TAG_PTR(OldPtr) != 0x10a28a70) {
            DEBUGMSG ((DBG_WHOOPS, "MemReuse detected corruption!"));
            Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
        } else
#endif

        if (SizeNeeded > CurrentSize) {
            SizeNeeded += 1024 - (SizeNeeded & 1023);

            Ptr = MemReAlloc (Heap, 0, REUSE_SIZE_PTR(OldPtr), SizeNeeded + AllocAdjustment);
            OldPtr = NULL;
        }
    }

    if (Ptr) {
        *((PDWORD) Ptr) = SizeNeeded;
        Ptr = (PVOID) ((PBYTE) Ptr + sizeof (DWORD));

#ifdef DEBUG
        *REUSE_TAG_PTR(Ptr) = 0x10a28a70;
#endif
    }

    return Ptr ? Ptr : OldPtr;
}

VOID
ReuseFree (
    HANDLE Heap,
    PVOID Ptr
    )
{
    if (Ptr) {
        MemFree (Heap, 0, REUSE_SIZE_PTR(Ptr));
    }
}


VOID
SetOutOfMemoryParent (
    HWND hwnd
    )
{
    g_OutOfMemoryParentWnd = hwnd;
}


VOID
OutOfMemory_Terminate (
    VOID
    )
{
    if (!g_OutOfMemoryString || !g_OutOfMemoryString[0]) {
        return;
    }

    MessageBoxA (
        g_OutOfMemoryParentWnd,
        g_OutOfMemoryString,
        NULL,
        MB_OK|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
        );

    ExitProcess (0);
    //
    // Not needed, will never get here
    //
    // TerminateProcess (GetModuleHandle (NULL), 0);
}

VOID
pValidateBlock (
    PVOID Block,
    SIZE_T Size
    )

/*++

Routine Description:

  pValidateBlock makes sure Block is non-NULL.  If it is NULL, then the user
  is given a popup, unless the request size is bogus.

  There are two cases for the popup.

   - If g_OutOfMemoryParentWnd was set with SetOutOfMemoryParent,
     then the user is asked to close other programs, and is given a retry
     option.

   - If there is no out of memory parent, then the user is told they
     need to get more memory.

  In either case, Setup is terminated.  In GUI mode, Setup will be
  stuck and the machine will be unbootable.

Arguments:

  Block - Specifies the block to validate.
  Size - Specifies the request size

Return Value:

  none

--*/

{
    LONG rc;

    if (!Block && Size < 0x2000000) {
        if (g_OutOfMemoryParentWnd) {
            rc = MessageBoxA (
                    g_OutOfMemoryParentWnd,
                    g_OutOfMemoryRetry,
                    NULL,
                    MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                    );

            if (rc == IDCANCEL) {
                OutOfMemory_Terminate();
            }
        } else {
            OutOfMemory_Terminate();
        }
    } else {
        if (!Block) {
            // this is serious. We want to break now and give Dr. Watson a
            // chance to get our stack.
            DebugBreak ();
        }
    }
}

PVOID
SafeHeapAlloc (
    HANDLE Heap,
    DWORD Flags,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapAlloc (Heap, Flags, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

PVOID
SafeHeapReAlloc (
    HANDLE Heap,
    DWORD Flags,
    PVOID OldBlock,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapReAlloc (Heap, Flags, OldBlock, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

#ifdef DEBUG

VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    )
{
    p->Signature = TRACK_SIGNATURE;
    if (g_TrackAlloc) {
        p->File = SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (File));
        if (p->File) {
            StringCopyA ((PSTR)p->File, File);
        }
    } else {
        p->File      = File;
        p->Allocated = FALSE;
    }
    p->Line      = Line;
    p->Size      = Size;
    p->Comment   = g_TrackComment ? SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (g_TrackComment)) : NULL;
    p->PrevAlloc = NULL;
    p->NextAlloc = g_TrackHead;
    p->CallerFile = g_TrackFile;
    p->CallerLine = g_TrackLine;

    if (p->Comment) {
        StringCopyA (p->Comment, g_TrackComment);
    }

    if (g_TrackHead) {
        g_TrackHead->PrevAlloc = p;
    }

    g_TrackHead = p;
}

VOID
pTrackDelete (
    PTRACKSTRUCT p
    )
{
    if (p->Signature != TRACK_SIGNATURE) {
        DEBUGMSG ((DBG_WARNING, "A tracking signature is invalid.  "
                                "This suggests memory corruption."));
        return;
    }

    if (p->PrevAlloc) {
        p->PrevAlloc->NextAlloc = p->NextAlloc;
    } else {
        g_TrackHead = p->NextAlloc;
    }

    if (p->NextAlloc) {
        p->NextAlloc->PrevAlloc = p->PrevAlloc;
    }
    if (p->Allocated) {
        if (p->File) {
            HeapFree (g_hHeap, 0, (PSTR)p->File);
        }
    }
}

VOID
DumpHeapLeaks (
    VOID
    )
{
    CHAR LineBuf[4096];
    PTRACKSTRUCT p;
    BOOL BadMem = FALSE;

    if (g_TrackHead) {

        __try {

            for (p = g_TrackHead ; p ; p = p->NextAlloc) {

                __try {

                    if (p->Comment) {

                        if (p->CallerFile) {
                            wsprintfA (
                                LineBuf,
                                "%s line %u\n"
                                    "  %s\n"
                                    "  Caller: %s line %u",
                                p->File,
                                p->Line,
                                p->Comment,
                                p->CallerFile,
                                p->CallerLine
                                );
                        } else {
                            wsprintfA (LineBuf, "%s line %u\n  %s", p->File, p->Line, p->Comment);
                        }
                    } else {

                        if (p->CallerFile) {
                            wsprintfA (
                                LineBuf,
                                "%s line %u\n"
                                    "  Caller: %s line %u\n",
                                p->File,
                                p->Line,
                                p->CallerFile,
                                p->CallerLine
                                );
                        } else {
                            wsprintfA (LineBuf, "(direct alloc) %s line %u", p->File, p->Line);
                        }
                    }

                }
                __except (TRUE) {
                    wsprintfA (LineBuf, "Address %Xh was freed, but not by MemFree!!", p);
                    BadMem = TRUE;
                }

                DEBUGMSG (("Leaks", "%s", LineBuf));

#ifdef CONSOLE
                printf ("%s", LineBuf);
#endif

                //lint --e(774)
                if (BadMem) {
                    break;
                }
            }
        }
        __except (TRUE) {
        }
    }
}
/*
VOID
DumpHeapLeaks (
    VOID
    )
{
    HANDLE File;
    CHAR LineBuf[2048];
    PTRACKSTRUCT p;
    DWORD DontCare;
    DWORD Count;
    BOOL BadMem = FALSE;
    CHAR TempPath[MAX_TCHAR_PATH];
    CHAR memtrackLogPath[] = "?:\\memtrack.log";

    GetSystemDirectory(TempPath, MAX_TCHAR_PATH);
    memtrackLogPath[0] = TempPath[0];

    File = CreateFileA (memtrackLogPath, GENERIC_WRITE, 0, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
                        );

    if (File != INVALID_HANDLE_VALUE) {

        SetFilePointer (File, 0, NULL, FILE_END);

        if (g_TrackHead) {

            Count = 0;
            __try {
                for (p = g_TrackHead ; p ; p = p->NextAlloc) {
                    Count++;
                    __try {
                        if (p->Comment) {
                            if (p->CallerFile) {
                                wsprintfA (
                                    LineBuf,
                                    "%s line %u\r\n"
                                        "  %s\r\n"
                                        "  Caller: %s line %u\r\n"
                                        "\r\n",
                                    p->File,
                                    p->Line,
                                    p->Comment,
                                    p->CallerFile,
                                    p->CallerLine
                                    );
                            } else {
                                wsprintfA (LineBuf, "%s line %u\r\n  %s\r\n\r\n", p->File, p->Line, p->Comment);
                            }
                        } else {
                            if (p->CallerFile) {
                                wsprintfA (
                                    LineBuf,
                                    "%s line %u\r\n"
                                        "  Caller: %s line %u\r\n"
                                        "\r\n",
                                    p->File,
                                    p->Line,
                                    p->CallerFile,
                                    p->CallerLine
                                    );
                            } else {
                                wsprintfA (LineBuf, "(direct alloc) %s line %u\r\n\r\n", p->File, p->Line);
                            }
                        }

                    }
                    __except (TRUE) {
                        wsprintfA (LineBuf, "Address %Xh was freed, but not by MemFree!!\r\n", p);
                        BadMem = TRUE;
                    }
                    WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);

                    //lint --e(774)
                    if (BadMem) {
                        break;
                    }
                }
            }
            __except (TRUE) {
            }

            wsprintfA (LineBuf, "\r\n%i item%s allocated but not freed.\r\n\r\n", Count, Count == 1 ? "":"s");
            WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);
        }

        wsprintfA (
           LineBuf,
           "Bytes currently allocated: %u\r\n"
           "Peak bytes allocated: %u\r\n"
           "Allocation count: %u\r\n"
           "Reallocation count: %u\r\n"
           "Free count: %u\r\n\r\n\r\n\r\n\r\n",
           g_TotalBytesAllocated,
           g_MaxBytesInUse,
           g_HeapAllocs,
           g_HeapReAllocs,
           g_HeapFrees
           );

        WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);

        CloseHandle (File);
    }
}
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\blobs.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    blobs.c

Abstract:

    Implements a set of APIs to manage BLOBS and arrays of BLOBS.

Author:

    Ovidiu Temereanca (ovidiut)   24-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_BLOBS       "Blobs"

//
// Strings
//

// None

//
// Constants
//

#define BLOB_SIGNATURE              0x79563442
#define BLOB_GROWDATASIZE_DEFAULT   1024
#define BLOBS_GROWCOUNT_DEFAULT     64
#define BLOBS_SIGNATURE             0x12567841

//
// Macros
//

// None

//
// Types
//

typedef struct {
    DWORD       BlobSignature;
    DWORD       DataSize;
    DWORD       Flags;
} BLOBHDR, *PBLOBHDR;

typedef struct {
    DWORD       BlobsArraySignature;
    DWORD       BlobsCount;
} BLOBSARRAYHDR, *PBLOBSARRAYHDR;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


#ifdef DEBUG

#define ASSERT_VALID_BLOB(b)            MYASSERT (pIsValidBlob (b))
#define ASSERT_VALID_BLOBS_ARRAY(a)     MYASSERT (pIsValidBlobsArray (a))

BOOL
pIsValidBlob (
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    pIsValidBlob checks if the passed-in blob points to a valid OURBLOB blob structure

Arguments:

    Blob - Specifies a pointer to the blob to be checked

Return Value:

    TRUE if the check was successful.
    FALSE if not.

--*/

{
    BOOL b = TRUE;

    if (!Blob) {
        return FALSE;
    }

    __try {
        b = !Blob->Data && !Blob->End && !Blob->Index && !Blob->AllocSize ||
            Blob->Data && Blob->AllocSize && Blob->End <= Blob->AllocSize && Blob->Index <= Blob->AllocSize;
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

BOOL
pIsValidBlobsArray (
    IN      PBLOBS BlobsArray
    )

/*++

Routine Description:

    pIsValidBlobsArray checks if the passed-in bloba array points to a valid BLOBS array structure

Arguments:

    BlobsArray - Specifies a pointer to the blobs array to be checked

Return Value:

    TRUE if the check was successful.
    FALSE if not.

--*/

{
    BOOL b = TRUE;

    if (!BlobsArray) {
        return FALSE;
    }

    __try {
        b = !BlobsArray->Blobs && !BlobsArray->BlobsCount && !BlobsArray->BlobsAllocated ||
            BlobsArray->Signature == BLOBS_SIGNATURE &&
            BlobsArray->Blobs &&
            BlobsArray->BlobsAllocated &&
            BlobsArray->BlobsGrowCount &&
            BlobsArray->BlobsCount <= BlobsArray->BlobsAllocated;
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#else

#define ASSERT_VALID_BLOB(b)
#define ASSERT_VALID_BLOBS_ARRAY(a)

#endif


PVOID
pBlobAllocateMemory (
    IN      DWORD Size
    )

/*++

Routine Description:

    pBlobAllocateMemory is a private function that allocates space from the process heap

Arguments:

    Size - Specifies the size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if not enough memory

--*/

{
    MYASSERT (Size);
    return HeapAlloc (g_hHeap, 0, Size);
}


static
PVOID
pReAllocateMemory (
    IN      PVOID OldBuffer,
    IN      DWORD NewSize
    )

/*++

Routine Description:

    pReAllocateMemory is a private function that re-allocates space from the process heap

Arguments:

    OldBuffer - Specifies the buffer to be re-allocated
    Size - Specifies the size (in bytes) to allocate.

Return Value:

    A pointer to the successfully re-allocated memory or NULL if not enough memory

--*/

{
    MYASSERT (OldBuffer);
    MYASSERT (NewSize);
    return HeapReAlloc (g_hHeap, 0, OldBuffer, NewSize);
}


VOID
pBlobFreeMemory (
    IN      PVOID Buffer
    )

/*++

Routine Description:

    pBlobFreeMemory is a private function that frees space allocated from the process heap

Arguments:

    Buffer - Specifies a pointer to buffer to free.

Return Value:

    none

--*/

{
    MYASSERT (Buffer);
    HeapFree (g_hHeap, 0, Buffer);
}


POURBLOB
BlobCreate (
    VOID
    )
{
    POURBLOB newBlob;

    newBlob = pBlobAllocateMemory (DWSIZEOF (OURBLOB));
    if (newBlob) {
        ZeroMemory (newBlob, DWSIZEOF (OURBLOB));
    }
    return newBlob;
}


POURBLOB
BlobDuplicate (
    IN      POURBLOB SourceBlob
    )

/*++

Routine Description:

    BlobDuplicate duplicates the data in the source blob, so the resulting blob will
    have an identical copy of data

Arguments:

    SourceBlob - Specifies the blob source of data

Return Value:

    Pointer to the new blob if duplicate was successful; NULL if not enough memory

--*/

{
    POURBLOB newBlob;
    DWORD dataSize;

    newBlob = BlobCreate ();
    if (newBlob && SourceBlob->Data) {
        dataSize = BlobGetDataSize (SourceBlob);
        newBlob->Data = pBlobAllocateMemory (dataSize);
        if (!newBlob->Data) {
            BlobDestroy (newBlob);
            return NULL;
        }
        newBlob->AllocSize = dataSize;
        newBlob->End = dataSize;
        CopyMemory (newBlob->Data, SourceBlob->Data, dataSize);
        newBlob->Flags = SourceBlob->Flags;
    }
    return newBlob;
}


VOID
BlobClear (
    IN OUT  POURBLOB Blob
    )

/*++

Routine Description:

    BlobClear clears the specified blob (frees its associated data)

Arguments:

    Blob - Specifies the blob to clear

Return Value:

    none

--*/

{
    if (Blob && Blob->Data) {
        pBlobFreeMemory (Blob->Data);
        ZeroMemory (Blob, DWSIZEOF (OURBLOB));
    }
}


VOID
BlobDestroy (
    IN OUT  POURBLOB Blob
    )

/*++

Routine Description:

    BlobDestroy destroys the specified blob (frees its associated data and the blob itself)

Arguments:

    Blob - Specifies the blob to destroy

Return Value:

    none

--*/

{
    if (Blob) {
        BlobClear (Blob);
        pBlobFreeMemory (Blob);
    }
}


BOOL
BlobSetIndex (
    IN OUT  POURBLOB Blob,
    IN      DWORD Index
    )

/*++

Routine Description:

    BlobSetIndex sets the current read/write pointer

Arguments:

    Blob - Specifies the blob
    Index - Specifies the new index value

Return Value:

    TRUE if the index move was successful

--*/

{
    ASSERT_VALID_BLOB (Blob);

    if (Index > Blob->End) {
        DEBUGMSG ((DBG_BLOBS, "BlobSetIndex: invalid Index specified (%lu)", Index));
        MYASSERT (FALSE);   //lint !e506
        return FALSE;
    }

    Blob->Index = Index;
    return TRUE;
}


DWORD
BlobGetRecordedDataType (
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    BlobGetRecordedDataType returns the data type recorded at current read position

Arguments:

    Blob - Specifies the blob

Return Value:

    The current data type if the blob records data type and the read position is valid;
    BDT_NONE otherwise

--*/

{
    PBYTE p;

    if (BlobRecordsDataType (Blob)) {
        p = BlobGetPointer (Blob);
        if (p) {
            return *(DWORD*)p;
        }
    }
    return BDT_NONE;
}


BOOL
BlobWriteEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD DataType,         OPTIONAL
    IN      BOOL RecordDataSize,
    IN      DWORD DataSize,
    IN      PCVOID Data
    )

/*++

Routine Description:

    BlobWriteEx writes data at the current index position, growing the blob if necessary
    and adjusting it's size.

Arguments:

    Blob - Specifies the blob
    DataType - Specifies the type of data to be stored; can be zero only if the blob
               doesn't record data types
    RecordDataSize - Specifies TRUE if this size has to be recorded in the blob
    DataSize - Specifies the size, in bytes, of the data to be stored
    Data - Specifies the data

Return Value:

    TRUE if write was successful; FALSE if not enough memory

--*/

{
    PBYTE p;
    DWORD totalDataSize;
    DWORD growTo;
    DWORD d;

    ASSERT_VALID_BLOB (Blob);
    MYASSERT (DataSize);

    MYASSERT (DataType || !BlobRecordsDataType (Blob));
    if (!DataType && BlobRecordsDataType (Blob)) {
        return FALSE;
    }

    if (!Blob->GrowSize) {
        Blob->GrowSize = BLOB_GROWDATASIZE_DEFAULT;
    }

    totalDataSize = Blob->Index + DataSize;
    if (BlobRecordsDataType (Blob)) {
        //
        // add the size of a DWORD
        //
        totalDataSize += DWSIZEOF (DWORD);
    }
    if (BlobRecordsDataSize (Blob) || RecordDataSize) {
        //
        // add the size of a DWORD
        //
        totalDataSize += DWSIZEOF (DWORD);
    }
    if (totalDataSize > Blob->AllocSize) {
        d = totalDataSize + Blob->GrowSize - 1;
        growTo = d - d % Blob->GrowSize;
    } else {
        growTo = 0;
    }

    if (!Blob->Data) {
        Blob->Data = (PBYTE) pBlobAllocateMemory (growTo);
        if (!Blob->Data) {
            DEBUGMSG ((DBG_ERROR, "BlobWriteEx: pBlobAllocateMemory (%lu) failed", growTo));
            return FALSE;
        }

        Blob->AllocSize = growTo;
    } else if (growTo) {
        p = pReAllocateMemory (Blob->Data, growTo);
        if (!p) {
            DEBUGMSG ((DBG_ERROR, "BlobWriteEx: pReAllocateMemory (%lu) failed", growTo));
            return FALSE;
        }

        Blob->AllocSize = growTo;
        Blob->Data = p;
    }

    p = BlobGetPointer (Blob);

    if (BlobRecordsDataType (Blob)) {
        *(PDWORD)p = DataType;
        p += DWSIZEOF (DWORD);
        Blob->Index += DWSIZEOF (DWORD);
    }
    if (BlobRecordsDataSize (Blob) || RecordDataSize) {
        *(PDWORD)p = DataSize;
        p += DWSIZEOF (DWORD);
        Blob->Index += DWSIZEOF (DWORD);
    }

    CopyMemory (p, Data, DataSize);
    Blob->Index += DataSize;

    //
    // adjust EOF
    //
    if (Blob->Index > Blob->End) {
        Blob->End = Blob->Index;
    }

    return TRUE;
}


PBYTE
BlobReadEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD ExpectedDataType,     OPTIONAL
    IN      DWORD ExpectedDataSize,     OPTIONAL
    IN      BOOL RecordedDataSize,
    OUT     PDWORD ActualDataSize,      OPTIONAL
    OUT     PVOID Data,                 OPTIONAL
    IN      PMHANDLE Pool               OPTIONAL
    )

/*++

Routine Description:

    BlobReadEx reads data from the specified blob, at the current index position

Arguments:

    Blob - Specifies the blob to read from
    ExpectedDataType - Specifies the expected data type; optional
    ExpectedDataSize - Specifies the expected data size; optional
    RecordedDataSize - Specifies TRUE if the data size was recorded in the blob
    ActualDataSize - Receives the actual data size; optional
    Data - Receives the actual data; optional; if NULL, a buffer will be allocated
    Pool - Specifies the pool to use for memory allocations; optional;
           if NULL, the process heap will be used

Return Value:

    A pointer to the buffer containing the data; NULL if an error occured
    or some data conditions don't match

--*/

{
    DWORD initialIndex;
    PBYTE readPtr;
    DWORD actualDataType;
    DWORD actualDataSize = 0;

    ASSERT_VALID_BLOB (Blob);

    readPtr = BlobGetPointer (Blob);
    if (!readPtr) {
        return NULL;
    }

    //
    // data size must be available some way
    //
    MYASSERT (BlobRecordsDataSize (Blob) || RecordedDataSize || ExpectedDataSize);

    initialIndex = BlobGetIndex (Blob);

    if (BlobRecordsDataType (Blob)) {

        if (readPtr + DWSIZEOF (DWORD) > BlobGetEOF (Blob)) {
            return NULL;
        }
        //
        // check actual data type
        //
        actualDataType = *(DWORD*)readPtr;

        if (ExpectedDataType && ExpectedDataType != actualDataType) {

            DEBUGMSG ((
                DBG_ERROR,
                "BlobReadEx: Actual data type (%lu) different than expected data type (%lu)",
                actualDataType,
                ExpectedDataType
                ));

            return NULL;
        }

        Blob->Index += DWSIZEOF (DWORD);
        readPtr += DWSIZEOF (DWORD);
    }

    if (BlobRecordsDataSize (Blob) || RecordedDataSize) {

        if (readPtr + DWSIZEOF (DWORD) > BlobGetEOF (Blob)) {
            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }
        //
        // read actual data size
        //
        actualDataSize = *(DWORD*)readPtr;

        if (ExpectedDataSize && ExpectedDataSize != actualDataSize) {

            DEBUGMSG ((
                DBG_ERROR,
                "BlobReadEx: Actual data size (%lu) different than expected data size (%lu)",
                actualDataSize,
                ExpectedDataSize
                ));

            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }

        Blob->Index += DWSIZEOF (DWORD);
        readPtr += DWSIZEOF (DWORD);

    } else {
        actualDataSize = ExpectedDataSize;
    }

    if (!actualDataSize) {
        BlobSetIndex (Blob, initialIndex);
        return NULL;
    }

    if (ActualDataSize) {
        *ActualDataSize = actualDataSize;
    }

    //
    // don't read over end of file
    //
    if (readPtr + actualDataSize > BlobGetEOF (Blob)) {
        //
        // corrupt blob; undo anyway
        //
        MYASSERT (FALSE);   //lint !e506
        BlobSetIndex (Blob, initialIndex);
        return NULL;
    }

    if (!Data) {

        if (Pool) {
            Data = PmGetMemory (Pool, actualDataSize);
        } else {
            Data = pBlobAllocateMemory (actualDataSize);
        }

        if (!Data) {
            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }
    }

    CopyMemory (Data, readPtr, actualDataSize);

    Blob->Index += actualDataSize;

    return Data;
}


BOOL
BlobWriteDword (
    IN OUT  POURBLOB Blob,
    IN      DWORD Data
    )

/*++

Routine Description:

    BlobWriteDword writes a DWORD at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the DWORD

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_DWORD, FALSE, DWSIZEOF (DWORD), &Data);
}


BOOL
BlobReadDword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORD Data
    )

/*++

Routine Description:

    BlobReadDword reads a DWORD from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives the DWORD

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    return BlobReadEx (Blob, BDT_DWORD, DWSIZEOF (DWORD), FALSE, NULL, Data, NULL) != NULL;
}


BOOL
BlobWriteQword (
    IN OUT  POURBLOB Blob,
    IN      DWORDLONG Data
    )

/*++

Routine Description:

    BlobWriteQword writes a DWORDLONG at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the DWORDLONG

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_QWORD, FALSE, DWSIZEOF (DWORDLONG), &Data);
}


BOOL
BlobReadQword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORDLONG Data
    )

/*++

Routine Description:

    BlobReadQword reads a DWORDLONG from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives the DWORDLONG

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    return BlobReadEx (Blob, BDT_QWORD, DWSIZEOF (DWORDLONG), FALSE, NULL, Data, NULL) != NULL;
}


/*++

Routine Description:

    BlobWriteString writes a string at the current writing position in the specified blob;
    the string is stored in UNICODE inside the blob if BF_UNICODESTRINGS is set

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the string

Return Value:

    TRUE if data was successfully stored in the blob

--*/

BOOL
BlobWriteStringA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    )
{
    PCWSTR unicodeString;
    BOOL b;

    if (BlobRecordsUnicodeStrings (Blob)) {
        unicodeString = ConvertAtoW (Data);
        b = BlobWriteStringW (Blob, unicodeString);
        FreeConvertedStr (unicodeString);
        return b;
    }
    return BlobWriteEx (Blob, BDT_SZA, TRUE, SizeOfStringA (Data), Data);
}


BOOL
BlobWriteStringW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    )
{
    return BlobWriteEx (Blob, BDT_SZW, TRUE, SizeOfStringW (Data), Data);
}


/*++

Routine Description:

    BlobReadString reads a string from the current reading position in the specified blob;
    the string may be converted to the ANSI/UNICODE format.
    If the blob doesn't store data types, this is assumed to be BDT_SZA for the ANSI version
    and BDT_SZW for the UNICODE version of this function

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated string
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

BOOL
BlobReadStringA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PSTR ansiString;
    PCWSTR unicodeString;
    DWORD dataType;
    DWORD index;
    DWORD length = 0;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    ansiString = NULL;
    unicodeString = NULL;

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_SZA) {

            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_SZW) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, &length, NULL, Pool);

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadStringA: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        if (BlobRecordsUnicodeStrings (Blob)) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, &length, NULL, Pool);

        } else {
            //
            // assume an ANSI string is stored there
            //
            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, NULL, NULL, Pool);
        }
    }

    if (!ansiString) {

        if (!unicodeString) {
            return FALSE;
        }

        if (Pool) {
            ansiString = PmGetMemory (Pool, length);
        } else {
            ansiString = pBlobAllocateMemory (length);
        }

        if (ansiString) {
            DirectUnicodeToDbcsN (ansiString, unicodeString, length);
        }

        if (Pool) {
            PmReleaseMemory (Pool, (PVOID)unicodeString);
        } else {
            pBlobFreeMemory ((PVOID)unicodeString);
        }

        if (!ansiString) {
            //
            // recover prev state
            //
            BlobSetIndex (Blob, index);

            return FALSE;
        }
    }

    *Data = ansiString;
    return TRUE;
}

BOOL
BlobReadStringW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PWSTR unicodeString;
    PCSTR ansiString;
    DWORD dataType;
    DWORD index;
    DWORD length;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_SZW) {

            unicodeString = (PWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_SZA) {

            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, &length, NULL, Pool);

            if (!ansiString) {
                return FALSE;
            }

            if (Pool) {
                unicodeString = PmGetMemory (Pool, length * DWSIZEOF (WCHAR));
            } else {
                unicodeString = pBlobAllocateMemory (length * DWSIZEOF (WCHAR));
            }
            if (unicodeString) {
                DirectDbcsToUnicodeN (unicodeString, ansiString, length);
            }

            if (Pool) {
                PmReleaseMemory (Pool, (PVOID)ansiString);
            } else {
                pBlobFreeMemory ((PVOID)ansiString);
            }

            if (!unicodeString) {
                //
                // recover prev state
                //
                BlobSetIndex (Blob, index);
                return FALSE;
            }

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadStringW: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        //
        // assume an UNICODE string is stored there
        //
        unicodeString = (PWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, NULL, NULL, Pool);
    }

    if (!unicodeString) {
        return FALSE;
    }

    *Data = unicodeString;
    return TRUE;
}


/*++

Routine Description:

    BlobWriteMultiSz writes a multisz at the current writing position in the specified blob;
    the multisz is stored in UNICODE inside the blob if BF_UNICODESTRINGS is set

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the multisz

Return Value:

    TRUE if data was successfully stored in the blob

--*/

BOOL
BlobWriteMultiSzA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    )
{
    PWSTR unicodeString;
    BOOL b;
    DWORD stringSize = SizeOfMultiSzA (Data);

    if (BlobRecordsUnicodeStrings (Blob)) {
        unicodeString = AllocTextW (stringSize);
        DirectDbcsToUnicodeN (unicodeString, Data, stringSize);
        b = BlobWriteMultiSzW (Blob, unicodeString);
        FreeTextW (unicodeString);
        return b;
    }

    return BlobWriteEx (Blob, BDT_MULTISZA, TRUE, stringSize, Data);
}

BOOL
BlobWriteMultiSzW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    )
{
    return BlobWriteEx (Blob, BDT_MULTISZW, TRUE, SizeOfMultiSzW (Data), Data);
}



/*++

Routine Description:

    BlobReadMultiSz reads a multisz from the current reading position in the specified blob;
    the string may be converted to the ANSI/UNICODE format.
    If the blob doesn't store data types, this is assumed to be BDT_MULTISZA for the ANSI version
    and BDT_MULTISZW for the UNICODE version of this function

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated multisz
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

BOOL
BlobReadMultiSzA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PSTR ansiString;
    PCWSTR unicodeString;
    DWORD dataType;
    DWORD index;
    DWORD length = 0;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    ansiString = NULL;
    unicodeString = NULL;

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_MULTISZA) {

            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_MULTISZW) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, &length, NULL, Pool);

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadMultiSzA: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        if (BlobRecordsUnicodeStrings (Blob)) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, &length, NULL, Pool);

        } else {
            //
            // assume an ANSI string is stored there
            //
            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, NULL, NULL, Pool);
        }
    }

    if (!ansiString) {
        if (!unicodeString) {
            return FALSE;
        }

        if (Pool) {
            ansiString = PmGetMemory (Pool, length);
        } else {
            ansiString = pBlobAllocateMemory (length);
        }

        if (ansiString) {
            DirectUnicodeToDbcsN (ansiString, unicodeString, length);
        }

        if (Pool) {
            PmReleaseMemory (Pool, (PVOID)unicodeString);
        } else {
            pBlobFreeMemory ((PVOID)unicodeString);
        }

        if (!ansiString) {
            //
            // recover prev state
            //
            BlobSetIndex (Blob, index);
            return FALSE;
        }
    }

    *Data = ansiString;
    return TRUE;
}

BOOL
BlobReadMultiSzW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PWSTR unicodeString;
    PCSTR ansiString;
    DWORD dataType;
    DWORD index;
    DWORD length;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_MULTISZW) {

            unicodeString = (PWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_MULTISZA) {

            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, &length, NULL, Pool);

            if (!ansiString) {
                return FALSE;
            }

            if (Pool) {
                unicodeString = PmGetMemory (Pool, length * DWSIZEOF (WCHAR));
            } else {
                unicodeString = pBlobAllocateMemory (length * DWSIZEOF (WCHAR));
            }

            if (unicodeString) {
                DirectDbcsToUnicodeN (unicodeString, ansiString, length);
            }

            if (Pool) {
                PmReleaseMemory (Pool, (PVOID)ansiString);
            } else {
                pBlobFreeMemory ((PVOID)ansiString);
            }

            if (!unicodeString) {
                //
                // recover prev state
                //
                BlobSetIndex (Blob, index);

                return FALSE;
            }

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadMultiSzW: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        //
        // assume an UNICODE string is stored there
        //
        unicodeString = (PWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, NULL, NULL, Pool);
    }

    if (!unicodeString) {
        return FALSE;
    }

    *Data = unicodeString;
    return TRUE;
}


BOOL
BlobWriteBinaryEx (
    IN OUT  POURBLOB Blob,
    IN      PBYTE Data,
    IN      DWORD Size,
    IN      BOOL RecordDataSize
    )

/*++

Routine Description:

    BlobWriteBinary writes a buffer at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the source buffer
    Size - Specifies the size of the buffer
    RecordDataSize - Specifies TRUE if data size should be recorded, too

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_BINARY, RecordDataSize, Size, Data);
}


BOOL
BlobReadBinary (
    IN OUT  POURBLOB Blob,
    OUT     PBYTE* Data,
    OUT     PDWORD Size,
    IN      PMHANDLE Pool       OPTIONAL
    )

/*++

Routine Description:

    BlobReadBinary reads a buffer from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated buffer
    Size - Receives the size of the buffer
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    *Data = BlobReadEx (Blob, BDT_BINARY, 0, TRUE, Size, NULL, Pool);
    return *Data != NULL;
}


BOOL
BlobWriteToFile (
    IN      POURBLOB Blob,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobWriteToFile writes the specified blob to the given file

Arguments:

    Blob - Specifies the blob to save
    File - Specifies the handle of the file to write the blob to

Return Value:

    TRUE if blob was successfully written to the file

--*/

{
    BLOBHDR header;
    DWORD d;

    if (!Blob->End) {
        DEBUGMSG ((DBG_BLOBS, "BlobWriteToFile: Did not write empty blob to file"));
        return FALSE;
    }

    //
    // save blob's Flags and End position
    //
    header.BlobSignature = BLOB_SIGNATURE;
    header.DataSize = Blob->End;
    header.Flags = Blob->Flags;

    if (!WriteFile (File, &header, DWSIZEOF (BLOBHDR), &d, NULL) || d != DWSIZEOF (BLOBHDR)) {
        DEBUGMSG ((DBG_ERROR, "BlobWriteToFile: Error writing blob header!"));
        return FALSE;
    }
    if (!WriteFile (File, Blob->Data, Blob->End, &d, NULL) || d != Blob->End) {
        DEBUGMSG ((DBG_ERROR, "BlobWriteToFile: Error writing blob data!"));
        return FALSE;
    }
    return TRUE;
}


BOOL
BlobReadFromFile (
    OUT     POURBLOB Blob,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobReadFromFile reads data from the given file in the specified blob

Arguments:

    Blob - Receives the data
    File - Specifies the handle of the file to read from

Return Value:

    TRUE if blob was successfully read from the file

--*/

{
    BLOBHDR header;
    DWORD d;

    //
    // read blob's Flags and End position
    //
    if (!ReadFile (File, &header, DWSIZEOF (BLOBHDR), &d, NULL) || d != DWSIZEOF (BLOBHDR)) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Error reading blob header!"));
        return FALSE;
    }

    if (header.BlobSignature != BLOB_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Not a valid blob signature!"));
        return FALSE;
    }

    Blob->Data = pBlobAllocateMemory (header.DataSize);
    if (!Blob->Data) {
        return FALSE;
    }

    if (!ReadFile (File, Blob->Data, header.DataSize, &d, NULL) || d != header.DataSize) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Error reading blob data!"));
        pBlobFreeMemory (Blob->Data);
        Blob->Data = NULL;
        return FALSE;
    }

    Blob->AllocSize = header.DataSize;
    Blob->End = header.DataSize;
    Blob->Flags = header.Flags;
    Blob->Index = 0;
    return TRUE;
}


BOOL
BlobsAdd (
    IN OUT  PBLOBS BlobsArray,
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    BlobsAdd adds the specified Blob to a blobs array

Arguments:

    BlobsArray - Specifies the array to add to
    Blob - Specifies the blob to add

Return Value:

    TRUE if the new blob pointer was added successfully

--*/

{
    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    if (!BlobsArray->BlobsGrowCount) {
        BlobsArray->BlobsGrowCount = BLOBS_GROWCOUNT_DEFAULT;
    }

    if (!BlobsArray->Blobs) {

        BlobsArray->Blobs = (POURBLOB*)pBlobAllocateMemory (
                                        BlobsArray->BlobsGrowCount * DWSIZEOF (POURBLOB)
                                        );
        if (!BlobsArray->Blobs) {
            DEBUGMSG ((DBG_ERROR, "BlobsAddE: Initial alloc failed"));
            return FALSE;
        }
        BlobsArray->Signature = BLOBS_SIGNATURE;
        BlobsArray->BlobsAllocated = BlobsArray->BlobsGrowCount;
        BlobsArray->BlobsCount = 0;

    } else if (BlobsArray->BlobsCount == BlobsArray->BlobsAllocated) {

        BlobsArray->BlobsAllocated += BlobsArray->BlobsGrowCount;
        BlobsArray->Blobs = (POURBLOB*)pReAllocateMemory (
                                        BlobsArray->Blobs,
                                        BlobsArray->BlobsAllocated * DWSIZEOF (POURBLOB)
                                        );
        if (!BlobsArray->Blobs) {
            BlobsArray->BlobsAllocated -= BlobsArray->BlobsGrowCount;
            DEBUGMSG ((DBG_ERROR, "BlobsAdd: Realloc failed"));
            return FALSE;
        }
    }

    *(BlobsArray->Blobs + BlobsArray->BlobsCount) = Blob;
    BlobsArray->BlobsCount++;

    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);
    return TRUE;
}


VOID
BlobsFree (
    IN OUT  PBLOBS BlobsArray,
    IN      BOOL DestroyBlobs
    )

/*++

Routine Description:

    BlobsFree destroys the array and optionally destroys all blobs in it

Arguments:

    BlobsArray - Specifies the array to delete
    DestroyBlobs - Specifies TRUE if the component blobs are to be deleted, too

Return Value:

    none

--*/

{
    BLOB_ENUM e;

    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    if (DestroyBlobs) {
        if (EnumFirstBlob (&e, BlobsArray)) {
            do {
                BlobDestroy (e.CurrentBlob);
            } while (EnumNextBlob (&e));
        }
    }

    pBlobFreeMemory (BlobsArray->Blobs);
    ZeroMemory (BlobsArray, DWSIZEOF (BLOBS));
}


BOOL
EnumFirstBlob (
    OUT     PBLOB_ENUM BlobEnum,
    IN      PBLOBS BlobsArray
    )

/*++

Routine Description:

    EnumFirstBlob enumerates the first blob in the given array

Arguments:

    BlobEnum - Receives enum info
    BlobsArray - Specifies the array to enum from

Return Value:

    TRUE if a first blob was found; FALSE if array is empty

--*/

{
    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    BlobEnum->Index = 0;
    BlobEnum->Array = BlobsArray;
    return EnumNextBlob (BlobEnum);
}


BOOL
EnumNextBlob (
    IN OUT  PBLOB_ENUM BlobEnum
    )

/*++

Routine Description:

    EnumNextBlob enumerates the next blob in the given array

Arguments:

    BlobEnum - Specifies/receives enum info

Return Value:

    TRUE if a next blob was found; FALSE if no more blobs

--*/

{
    if (BlobEnum->Index >= BlobEnum->Array->BlobsCount) {
        return FALSE;
    }

    BlobEnum->CurrentBlob = *(BlobEnum->Array->Blobs + BlobEnum->Index);
    BlobEnum->Index++;
    return TRUE;
}


BOOL
BlobsWriteToFile (
    IN      PBLOBS BlobsArray,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobsWriteToFile writes the specified blobs array to the given file

Arguments:

    BlobsArray - Specifies the blobs array to save
    File - Specifies the handle of the file to write the array to

Return Value:

    TRUE if array was successfully written to the file

--*/

{
    BLOBSARRAYHDR header;
    DWORD d;
    POURBLOB* blob;

    if (!BlobsArray->BlobsCount) {
        DEBUGMSG ((DBG_BLOBS, "BlobsWriteToFile: Did not write empty blobs array to file"));
        return FALSE;
    }

    //
    // save blobs count
    //
    header.BlobsArraySignature = BLOBS_SIGNATURE;
    header.BlobsCount = BlobsArray->BlobsCount;

    if (!WriteFile (File, &header, DWSIZEOF (BLOBSARRAYHDR), &d, NULL) ||
        d != DWSIZEOF (BLOBSARRAYHDR)
        ) {
        DEBUGMSG ((DBG_ERROR, "BlobsWriteToFile: Error writing blobs array header!"));
        return FALSE;
    }
    for (blob = BlobsArray->Blobs; blob < BlobsArray->Blobs + BlobsArray->BlobsCount; blob++) {
        if (!BlobWriteToFile (*blob, File)) {
            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsWriteToFile: Error writing blob # %lu to file",
                blob - BlobsArray->Blobs
                ));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
BlobsReadFromFile (
    OUT     PBLOBS BlobsArray,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobsReadFromFile reads data from the given file in the specified blobs array

Arguments:

    BlobsArray - Receives the data
    File - Specifies the handle of the file to read from

Return Value:

    TRUE if array was successfully read from the file

--*/

{
    BLOBSARRAYHDR header;
    DWORD d;
    UINT u;
    POURBLOB blob;

    //
    // read blobs count
    //
    if (!ReadFile (File, &header, DWSIZEOF (BLOBSARRAYHDR), &d, NULL) ||
        d != DWSIZEOF (BLOBSARRAYHDR)
        ) {
        DEBUGMSG ((DBG_ERROR, "BlobsReadFromFile: Error reading blobs array header!"));
        return FALSE;
    }

    if (header.BlobsArraySignature != BLOBS_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "BlobsReadFromFile: Not a valid blobs array signature!"));
        return FALSE;
    }

    BlobsArray->Blobs = (POURBLOB*)pBlobAllocateMemory (header.BlobsCount * DWSIZEOF (POURBLOB*));
    if (!BlobsArray->Blobs) {
        return FALSE;
    }

    ZeroMemory (BlobsArray->Blobs, header.BlobsCount * DWSIZEOF (POURBLOB));

    BlobsArray->Signature = BLOBS_SIGNATURE;
    BlobsArray->BlobsAllocated = header.BlobsCount;
    BlobsArray->BlobsCount = 0;
    BlobsArray->BlobsGrowCount = BLOBS_GROWCOUNT_DEFAULT;

    for (u = 0; u < header.BlobsCount; u++) {

        blob = BlobCreate ();
        if (!blob) {
            return FALSE;
        }

        if (!BlobReadFromFile (blob, File)) {

            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsReadFromFile: Error reading blob # %lu from file",
                u
                ));

            BlobsFree (BlobsArray, TRUE);
            return FALSE;
        }

        if (!BlobsAdd (BlobsArray, blob)) {
            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsReadFromFile: Error adding blob # %lu to array",
                u
                ));

            BlobsFree (BlobsArray, TRUE);
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\dbgtrack.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgtrack.c

Abstract:

    Allocation tracking implementation. From old debug.c

Author:

    Marc R. Whitten  (marcw) 09-Sept-1999

Revision History:

--*/

//
// Includes
//

#include "pch.h"

//
// NOTE: No code should appear outside the #ifdef DEBUG
//

#ifdef DEBUG

#pragma message("DEBUG macros enabled")



//
// Strings
//

// None

//
// Constants
//

#define TRACK_BUCKETS           1501
#define BUCKET_ITEMS_PER_POOL   8192




//
// Macros
//

// None

//
// Types
//

typedef UBINT ALLOCATION_ITEM_OFFSET;

typedef struct _tagTRACKBUCKETITEM {
    struct _tagTRACKBUCKETITEM *Next;
    struct _tagTRACKBUCKETITEM *Prev;
    ALLOCTYPE Type;
    PVOID Ptr;
    ALLOCATION_ITEM_OFFSET ItemOffset;
} TRACKBUCKETITEM, *PTRACKBUCKETITEM;

typedef struct _tagBUCKETPOOL {
    UINT Count;
    TRACKBUCKETITEM Items[BUCKET_ITEMS_PER_POOL];
} TRACKBUCKETPOOL, *PTRACKBUCKETPOOL;


typedef struct {
    ALLOCTYPE Type;
    PVOID Ptr;
    PCSTR FileName;
    UINT Line;
    BOOL Allocated;
} ALLOCATION_ITEM, *PALLOCATION_ITEM;

//
// Globals
//

PTRACKBUCKETITEM g_TrackBuckets[TRACK_BUCKETS];
PTRACKBUCKETITEM g_TrackPoolDelHead;
PTRACKBUCKETPOOL g_TrackPool;

//
// The following pointer can be used to help identify memory leak sources.
// It is copied to the memory tracking log.
//
PCSTR g_TrackComment;
PCSTR g_TrackFile;
UINT g_TrackLine;
BOOL g_TrackAlloc;
INT g_UseCount;
UINT g_DisableTrackComment = 0;
GROWBUFFER g_AllocationList;
PVOID g_FirstDeletedAlloc;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
DisableTrackComment (
    VOID
    )
{
    g_DisableTrackComment ++;
}

VOID
EnableTrackComment (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        g_DisableTrackComment --;
    }
}



PBYTE
pOurTrackedGbGrow (
    IN      PGROWBUFFER Buffer,
    IN      UINT Bytes
    )
{
    PBYTE p;
    BOOL trackMsg = FALSE;

    //
    // Because grow buffers themselves cause tracking, we have to
    // call the untracked version.  To eliminate confusion, we
    // give a helpful note.
    //

    if (!g_TrackFile) {
        trackMsg = TRUE;
        g_TrackFile = "<allocation tracking in dbgtrack.c, not a real leak>";
        g_TrackLine = __LINE__;
    }

    p = (PSTR) RealGbGrow (Buffer, Bytes);

    if (trackMsg) {
        g_TrackFile = NULL;
    }

    return p;
}


INT
TrackPushEx (
    PCSTR Msg,
    PCSTR File,
    UINT Line,
    BOOL Alloc
    )
{
    if (g_DisableTrackComment > 0) {
        return 0;
    }

    if (g_UseCount > 0) {
        g_UseCount++;
        return 0;
    }

    TrackPush (Msg, File, Line);
    g_TrackAlloc = TRUE;

    return 0;
}


INT
TrackPush (
    PCSTR Msg,
    PCSTR File,
    UINT Line
    )
{
    static CHAR Buffer[1024];

    if (g_DisableTrackComment > 0) {
        return 0;
    }

    if (g_UseCount > 0) {
        g_UseCount++;
        return 0;
    }

    if (Msg) {
        wsprintfA (Buffer, "%s line %u [%s]", File, Line, Msg);
    } else {
        wsprintfA (Buffer, "%s line %u", File, Line);
    }

    g_TrackFile = File;
    g_TrackLine = Line;
    g_TrackAlloc = FALSE;

    g_TrackComment = Buffer;
    g_UseCount = 1;

    return 0;
}


INT
TrackPop (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        return 0;
    }

    g_UseCount--;

    if (!g_UseCount) {
        g_TrackComment = NULL;
        g_TrackFile = NULL;
        g_TrackLine = 0;
        g_TrackAlloc = FALSE;
    }

    return 0;
}


VOID
TrackDump (
    VOID
    )
{
    if (g_UseCount > 0) {
        DEBUGMSGA (("Caller", "%s line %u (%s)", g_TrackFile, g_TrackLine, g_TrackComment));
    }
}


VOID
InitAllocationTracking (
    VOID
    )
{
    ZeroMemory (&g_AllocationList, sizeof (g_AllocationList));
    g_AllocationList.GrowSize = 65536;
    g_FirstDeletedAlloc = NULL;
}


VOID
FreeAllocationTracking (
    VOID
    )
{
    UINT Size;
    UINT u;
    PALLOCATION_ITEM Item;
    GROWBUFFER Msg = INIT_GROWBUFFER;
    CHAR Text[1024];
    PSTR p;
    UINT Bytes;

    Size = g_AllocationList.End / sizeof (ALLOCATION_ITEM);;

    for (u = 0 ; u < Size ; u++) {
        Item = (PALLOCATION_ITEM) g_AllocationList.Buf + u;
        if (!Item->FileName) {
            continue;
        }

        Bytes = (UINT) wsprintfA (Text, "%s line %u\r\n", Item->FileName, Item->Line);
        p = (PSTR) pOurTrackedGbGrow (&Msg, Bytes);

        if (p) {
            CopyMemory (p, Text, Bytes);
        }
    }

    if (Msg.End) {

        p = (PSTR) pOurTrackedGbGrow (&Msg, 1);
        if (p) {
            *p = 0;
            DEBUGMSGA (("Leaks", "%s", Msg.Buf));
        }

        GbFree (&Msg);
    }

    GbFree (&g_AllocationList);
    g_FirstDeletedAlloc = NULL;

    // Intentional leak -- who cares about track memory
    g_TrackPoolDelHead = NULL;
    g_TrackPool = NULL;
}


PTRACKBUCKETITEM
pAllocTrackBucketItem (
    VOID
    )
{
    PTRACKBUCKETITEM BucketItem;

    if (g_TrackPoolDelHead) {
        BucketItem = g_TrackPoolDelHead;
        g_TrackPoolDelHead = BucketItem->Next;
    } else {

        if (!g_TrackPool || g_TrackPool->Count == BUCKET_ITEMS_PER_POOL) {
            g_TrackPool = (PTRACKBUCKETPOOL) SafeHeapAlloc (g_hHeap, 0, sizeof (TRACKBUCKETPOOL));
            if (!g_TrackPool) {
                return NULL;
            }

            g_TrackPool->Count = 0;
        }

        BucketItem = g_TrackPool->Items + g_TrackPool->Count;
        g_TrackPool->Count++;
    }

    return BucketItem;
}

VOID
pFreeTrackBucketItem (
    PTRACKBUCKETITEM BucketItem
    )
{
    BucketItem->Next = g_TrackPoolDelHead;
    g_TrackPoolDelHead = BucketItem;
}



DWORD
pComputeTrackHashVal (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    DWORD Hash;

    Hash = (DWORD) ((DWORD)Type << 16) ^ (DWORD)(UBINT)Ptr;
    return Hash % TRACK_BUCKETS;
}


VOID
pTrackHashTableInsert (
    IN      PBYTE Base,
    IN      ALLOCATION_ITEM_OFFSET ItemOffset
    )
{
    DWORD Hash;
    PTRACKBUCKETITEM BucketItem;
    PALLOCATION_ITEM Item;

    Item = (PALLOCATION_ITEM) (Base + ItemOffset);

    Hash = pComputeTrackHashVal (Item->Type, Item->Ptr);

    BucketItem = pAllocTrackBucketItem();

    if (!BucketItem) {
        DEBUGMSG ((DBG_WHOOPS, "pTrackHashTableInsert failed to alloc memory"));
        return;
    }

    BucketItem->Prev = NULL;
    BucketItem->Next = g_TrackBuckets[Hash];
    BucketItem->Type = Item->Type;
    BucketItem->Ptr  = Item->Ptr;
    BucketItem->ItemOffset = ItemOffset;

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem;
    }

    g_TrackBuckets[Hash] = BucketItem;
}

VOID
pTrackHashTableDelete (
    IN      PTRACKBUCKETITEM BucketItem
    )
{
    DWORD Hash;

    Hash = pComputeTrackHashVal (BucketItem->Type, BucketItem->Ptr);

    if (BucketItem->Prev) {
        BucketItem->Prev->Next = BucketItem->Next;
    } else {
        g_TrackBuckets[Hash] = BucketItem->Next;
    }

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem->Prev;
    }

    pFreeTrackBucketItem (BucketItem);
}

PTRACKBUCKETITEM
pTrackHashTableFind (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PTRACKBUCKETITEM BucketItem;
    DWORD Hash;

    Hash = pComputeTrackHashVal (Type, Ptr);

    BucketItem = g_TrackBuckets[Hash];
    while (BucketItem) {
        if (BucketItem->Type == Type && BucketItem->Ptr == Ptr) {
            return BucketItem;
        }

        BucketItem = BucketItem->Next;
    }

    return NULL;
}


VOID
DebugRegisterAllocationEx (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line,
    IN      BOOL Alloc
    )
{
    PALLOCATION_ITEM Item;

    MYASSERT (File);

    if (!g_FirstDeletedAlloc) {
        Item = (PALLOCATION_ITEM) pOurTrackedGbGrow (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        Item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item->Ptr;
    }

    if (Item) {
        Item->Type = Type;
        Item->Ptr = Ptr;
        if (Alloc) {
            Item->FileName = SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (File));
            if (Item->FileName) {
                StringCopyA ((PSTR)Item->FileName, File);
            }
            Item->Allocated = TRUE;
        } else {
            Item->FileName = File;
            Item->Allocated = FALSE;
        }
        Item->Line = Line;

        pTrackHashTableInsert (
            g_AllocationList.Buf,
            (ALLOCATION_ITEM_OFFSET) ((PBYTE) Item - g_AllocationList.Buf)
            );
        //DEBUGMSG ((DBG_VERBOSE, "Allocation: File=%s, Line=%d, Size=%d", File, Line, Size));
    }
}


VOID
DebugRegisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line
    )
{
    PALLOCATION_ITEM Item;

    MYASSERT (File);

    if (!g_FirstDeletedAlloc) {
        Item = (PALLOCATION_ITEM) pOurTrackedGbGrow (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        Item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item->Ptr;
    }

    if (Item) {
        Item->Type = Type;
        Item->Ptr = Ptr;
        Item->FileName = File;
        Item->Line = Line;
        Item->Allocated = FALSE;

        pTrackHashTableInsert (
            g_AllocationList.Buf,
            (ALLOCATION_ITEM_OFFSET) ((PBYTE) Item - g_AllocationList.Buf)
            );
    }
}


VOID
DebugUnregisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PALLOCATION_ITEM Item;
    PTRACKBUCKETITEM BucketItem;

    BucketItem = pTrackHashTableFind (Type, Ptr);
    if (!g_AllocationList.Buf) {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Allocation buffer already freed"));
        return;
    }

    if (BucketItem) {
        Item = (PALLOCATION_ITEM) (g_AllocationList.Buf + BucketItem->ItemOffset);

        if (Item->Allocated) {
            HeapFree (g_hHeap, 0, (PSTR)Item->FileName);
        }
        Item->FileName = NULL;
        Item->Type = (ALLOCTYPE) -1;
        Item->Ptr = g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item;

        pTrackHashTableDelete (BucketItem);

    } else {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Pointer not registered"));
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\growbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growbuf.c

Abstract:

    Simple buffer management functions that allow variable blocks to
    be added as an array.  (Initially used to build a SID array, where
    each SID can be a different size.)

Author:

    Jim Schmidt (jimschm)   05-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     11-Aug-1998 Added GrowBufAppendString
    calinn      15-Jan-1998 modified MultiSzAppend


--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_GROWBUF     "GrowBuffer"

//
// Strings
//

// None

//
// Constants
//

#define DEFAULT_GROW_SIZE 8192

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

#ifdef DEBUG

DWORD g_GbCurrActiveAlloc = 0;
DWORD g_GbCurrUsedAlloc = 0;
DWORD g_GbMaxActiveAlloc = 0;
DWORD g_GbMaxUsedAlloc = 0;

#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  GrowBuffer makes sure there is enough bytes in the buffer
  to accomodate SpaceNeeded.  It allocates an initial buffer
  when no buffer is allocated, and it reallocates the buffer
  in increments of GrowBuf->Size (or DEFAULT_GROW_SIZE) when
  needed.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE NewBuffer;
    DWORD TotalSpaceNeeded;
    DWORD GrowTo;

    MYASSERT(SpaceNeeded);

    if (!GrowBuf->Buf) {
        GrowBuf->Size = 0;
        GrowBuf->End = 0;
#ifdef DEBUG
        GrowBuf->StatEnd = 0;
#endif
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = DEFAULT_GROW_SIZE;
    }

#ifdef DEBUG
    g_GbCurrActiveAlloc -= GrowBuf->Size;
    g_GbCurrUsedAlloc -= GrowBuf->StatEnd;
#endif

    TotalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (TotalSpaceNeeded > GrowBuf->Size) {
        GrowTo = (TotalSpaceNeeded + GrowBuf->GrowSize) - (TotalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        GrowTo = 0;
    }

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAlloc (g_hHeap, 0, GrowTo);
        if (!GrowBuf->Buf) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Initial alloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
    } else if (GrowTo) {
        NewBuffer = MemReAlloc (g_hHeap, 0, GrowBuf->Buf, GrowTo);
        if (!NewBuffer) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Realloc failed"));
            return NULL;
        }

#ifdef DEBUG
        if (GrowBuf->Buf != NewBuffer) {
            DEBUGMSG ((
                DBG_WARNING,
                "GbGrow: Realloc caused growbuffer to move %u bytes to new location; "
                    "any pointers inside old buffer are now invalid",
                GrowBuf->Size
                ));

            if (GrowBuf->Size > 32767) {
                TRACKDUMP();
            }
        }
#endif

        GrowBuf->Size = GrowTo;
        GrowBuf->Buf = NewBuffer;
    }

    NewBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

#ifdef DEBUG
    GrowBuf->StatEnd = GrowBuf->End;
    g_GbCurrActiveAlloc += GrowBuf->Size;
    if (g_GbMaxActiveAlloc < g_GbCurrActiveAlloc) {
        g_GbMaxActiveAlloc = g_GbCurrActiveAlloc;
    }
    g_GbCurrUsedAlloc += GrowBuf->StatEnd;
    if (g_GbMaxUsedAlloc < g_GbCurrUsedAlloc) {
        g_GbMaxUsedAlloc = g_GbCurrUsedAlloc;
    }
#endif

    return NewBuffer;
}


VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  FreeGrowBuffer frees a buffer allocated by GrowBuffer.

Arguments:

  GrowBuf  - A pointer to the same structure passed to GrowBuffer

Return Value:

  none

--*/


{
    MYASSERT(GrowBuf);

#ifdef DEBUG
    g_GbCurrActiveAlloc -= GrowBuf->Size;
    g_GbCurrUsedAlloc -= GrowBuf->StatEnd;
#endif

    if (GrowBuf->Buf) {
        MemFree (g_hHeap, 0, GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}


/*++

Routine Descriptions:

  MultiSzAppend
    This function is a general-purpose function to append a string
    to a grow buffer.

  MultiSzAppendVal
    This function adds a key=decimal_val string, where key is a
    specified string, and decimal_val is a specified DWORD.

  MultiSzAppendString
    This function adds key=string to the grow buffer, where key
    is a specified string, and string is a specified string value.

Arguments:

  GrowBuf  - The buffer to append the string or key/value pair
  Key      - The key part of the key=val pair
  Val      - The val part of the key=val pair

Return Value:

  TRUE if the function succeeded, or FALSE if a memory allocation
  failure occurred.

--*/


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    PSTR p;

    p = (PSTR) GbGrow (GrowBuf, SizeOfStringA (String) + sizeof(CHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyA (p, String);
    GrowBuf->End -= sizeof (CHAR);
    GrowBuf->Buf[GrowBuf->End] = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    )
{
    PWSTR p;

    p = (PWSTR) GbGrow (GrowBuf, SizeOfStringW (String) + sizeof(WCHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyW (p, String);
    GrowBuf->End -= sizeof (WCHAR);
    *((PWCHAR) (GrowBuf->Buf + GrowBuf->End)) = 0;

    return TRUE;
}

BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    )
{
    PDWORD p;

    p = (PDWORD) GbGrow (GrowBuf, sizeof (DWORD));
    if (!p) {
        return FALSE;
    }

    *p = d;

    return TRUE;
}


BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID Ptr
    )
{
    PCVOID *p;

    p = (PVOID *) GbGrow (GrowBuf, sizeof (PVOID));
    if (!p) {
        return FALSE;
    }

    *p = Ptr;

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendString copies the specified string to the end of the grow
  buffer.  This is the equivalent of strcat.  The grow buffer is
  automatically expanded as necessary.

Arguments:

  GrowBuf - Specifies the destination grow buffer
  String  - Specifies the string to append

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringA (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        StringCopyA (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


BOOL
RealGbAppendStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringW (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        StringCopyW (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendStringAB copies the specified string range to the
  end of the grow buffer.  This concatenates the string to the
  existing buffer contents, and keeps the buffer terminated.

Arguments:

  GrowBuf    - Specifies the destination grow buffer
  Start      - Specifies the start of string to append
  EndPlusOne - Specifies one logical character beyond the end of
               the string, and can point to a nul.

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringABA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT)((UBINT) EndPlusOne - (UBINT) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (CHAR));

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (CHAR);
    }

    return TRUE;
}


BOOL
RealGbAppendStringABW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT)((UBINT) EndPlusOne - (UBINT) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd > sizeof (WCHAR)) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (WCHAR));

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PWSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (WCHAR);
    }

    return TRUE;
}



/*++

Routine Description:

  GrowBufCopyString copies the specified string to the end of the grow buffer.

Arguments:

  GrowBuf - Specifies the grow buffer to add to, receives the updated buffer

  String - Specifies the string to add to GrowBuf

Return Value:



--*/

BOOL
RealGbCopyStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringA (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}


BOOL
RealGbCopyStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringW (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}

BOOL
RealGbCopyQuotedStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringA (String);

    Buf = RealGbGrow (GrowBuf, Size + 2 * sizeof (CHAR));
    if (!Buf) {
        return FALSE;
    }

    *((CHAR *)(Buf)) = '\"';
    CopyMemory (Buf + sizeof (CHAR), String, Size);
    *((CHAR *)(Buf + Size)) = '\"';
    *((CHAR *)(Buf + Size + sizeof (CHAR))) = 0;
    return TRUE;
}


BOOL
RealGbCopyQuotedStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringW (String);

    Buf = RealGbGrow (GrowBuf, Size + 2 * sizeof (WCHAR));
    if (!Buf) {
        return FALSE;
    }

    *((WCHAR *)(Buf)) = L'\"';
    CopyMemory (Buf + sizeof (WCHAR), String, Size);
    *((WCHAR *)(Buf + Size)) = L'\"';
    *((WCHAR *)(Buf + Size + sizeof (WCHAR))) = 0;
    return TRUE;
}


#ifdef DEBUG

VOID
GbDumpStatistics (
    VOID
    )
{
    DEBUGMSG ((
        DBG_STATS,
        "Grow buffers usage:\nPeak   : Usable:%-8d Used:%-8d\nCurrent: Usable:%-8d Leak:%-8d",
        g_GbMaxActiveAlloc,
        g_GbMaxUsedAlloc,
        g_GbCurrActiveAlloc,
        g_GbCurrUsedAlloc
        ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\exclist.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    exclist.c

Abstract:

    Implements a set of APIs to manage exclusion lists of objects
    of various well-known types.

Author:

    Ovidiu Temereanca (ovidiut)   23-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_EXCLIST         "ExcList"

//
// Strings
//

#define S_EXCLUSIONLIST     "ExcList"

//
// Constants
//

// None

//
// Macros
//

#define pAllocateMemory(Size)   PmGetMemory (g_ElPool,Size)

#define pFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_ElPool, (PVOID)Buffer)


//
// Types
//

typedef struct {
    DWORD TypeId;
    PCSTR TypeName;
} EXCLISTPROPS, *PEXCLISTPROPS;


//
// Globals
//

PMHANDLE g_ElPool;
GROWLIST* g_ElTypeLists;

//
// Macro expansion li