get device.
    By having the NT GDI realize the brush, in essence allows us to cache the
    physical representation of the brush, for future use.

Arguments:

    pbo         - Points to the BRUSHOBJ which is to be realized. All the other
                  parameters, except for psoDst, can be queried from this
                  object. Parameter specifications are provided as an
                  optimization. This parameter is best used only as a parameter
                  for BRUSHOBJ_pvAllocRBrush, which allocates the memory for
                  the realized brush.

    psoDst      - Points to the surface for which the brush is to be realized.
                  This surface could be the physical surface for the device,
                  a device format bitmap, or a standard format bitmap.

    psoPattern  - Points to the surface that describes the pattern for the
                  brush. For a raster device, this always represents a bitmap.
                  For a vector device, this is always one of the pattern
                  surfaces returned by DrvEnablePDEV.

    psoMask     - Points to a transparency mask for the brush. This is a one
                  bit per pixel bitmap that has the same extent as the pattern.
                  A mask of zero means the pixel is considered a background
                  pixel for the brush. (In transparent background mode, the
                  background pixels are unaffected in a fill.) Pen Plotters can
                  ignore this parameter because they never draw background
                  information.

    pxlo        - Points to an XLATEOBJ that tells how to interpret the colors
                  in the pattern. An XLATEOBJXxx service routine can be called
                  to translate the colors to device color indexes. Vector
                  devices should translate color zero through the XLATEOBJ to
                  get the foreground color for the brush.

    iHatch      - If this is less than HS_API_MAX, then it indicates that
                  psoPattern is one of the hatch brushes returned by
                  DrvEnablePDEV, such as HS_HORIZONTAL.

Return Value:

    DrvRealizeBrush returns TRUE if the brush was successfully realized.
    Otherwise, FALSE is returned and an error code is logged.


Author:

    09-Feb-1994 Wed 10:04:17 updated  
        Put the CloneSURFOBJToHT() back for all psoPatterns, (this was to
        prevent GDI go into GP), now we will raised a bug against it.

    13-Jan-1994 Thu 23:12:40 updated  
        Totally re-write so that we will cached the psoPattern always

    01-Dec-1993 Wed 17:27:19 updated  
        clean up, and re-write to generate the standard brush string.

Revision History:


--*/

{
    PPDEV   pPDev;


    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvRealizeBrush has invalid pPDev"));
        return(FALSE);
    }

    //
    // We don't check if iHatch is valid or not at this poin.
    // We should always get a psoPattern that either points to the user
    // defined pattern or to the standard monochrome pattern.
    //

    if ((psoPattern) &&
        (psoPattern->iType == STYPE_BITMAP)) {

        PDEVBRUSH   pBrush;
        SURFOBJ     *psoHT;
        HBITMAP     hBmp;
        SIZEL       szlPat;
        SIZEL       szlHT;
        RECTL       rclHT;
        LONG        Size;
        DWORD       OffBGR;
        BOOL        RetOk;

        //
        // leave room for the color table. then allocate the new device brush
        //

        PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: psoPat=%08lx [%ld], psoMask=%08lx, iHatch=%ld",
                    psoPattern, psoPattern->iBitmapFormat, psoMask, iHatch));

        PLOTDBG(DBG_RBRUSH, ("psoPattern size = %ld x %ld",
                                    (LONG)psoPattern->sizlBitmap.cx,
                                    (LONG)psoPattern->sizlBitmap.cy));

#if DBG
        if ((DBG_PLOTFILENAME & DBG_SHOWSTDPAT) &&
            ((psoPattern->iBitmapFormat == BMF_1BPP) ||
             (iHatch < HS_DDI_MAX))) {

            LPBYTE  pbSrc;
            LPBYTE  pbCur;
            LONG    x;
            LONG    y;
            BYTE    bData;
            BYTE    Mask;
            BYTE    Buf[128];


            //
            // Debug code that allows the pattern to be displayed with
            // ASCII codes on the debug terminal. This was very helpful
            // during development.
            //

            pbSrc = psoPattern->pvScan0;

            for (y = 0; y < psoPattern->sizlBitmap.cy; y++) {

                pbCur  = pbSrc;
                pbSrc += psoPattern->lDelta;
                Mask   = 0x0;
                Size   = 0;

                for (x = 0;
                     x < psoPattern->sizlBitmap.cx && Size < sizeof(Buf);
                     x++)
                {

                    if (!(Mask >>= 1)) {

                        Mask  = 0x80;
                        bData = *pbCur++;
                    }

                    Buf[Size++] = (BYTE)((bData & Mask) ? 0xdb : 0xb0);
                }

                if (Size < sizeof(Buf))
                {
                    Buf[Size] = '\0';
                }
                else
                {
                    //
                    // Error case. Null-terminate anyway.
                    //
                    Buf[sizeof(Buf) - 1] = '\0';
                }

                DBGP((Buf));
            }
        }
#endif

        //
        // For pen plotter, we need to remember this one as well.
        //

        szlHT  =
        szlPat = psoPattern->sizlBitmap;

        PLOTDBG(DBG_RBRUSH,
                ("DrvRealizeBrush: BG=%08lx, FG=%08lx",
                    (DWORD)XLATEOBJ_iXlate(pxlo, 1),
                    (DWORD)XLATEOBJ_iXlate(pxlo, 0)));

        if (IS_RASTER(pPDev)) {

            //
            // For raster plotters, we will clone the surface and halftone
            // the orignal pattern into a halftone bitmap which itself is
            // tile-able. This allows us to use our color reduction code,
            // to make the pattern look good.
            //

            if ((iHatch >= HS_DDI_MAX) &&
                (!IsHTCompatibleSurfObj(pPDev,
                                        psoPattern,
                                        pxlo,
                                        ISHTF_ALTFMT | ISHTF_DSTPRIM_OK))) {

                GetMinHTSize(pPDev, &szlHT);
            }

            rclHT.left   =
            rclHT.top    = 0;
            rclHT.right  = szlHT.cx;
            rclHT.bottom = szlHT.cy;

            PLOTDBG(DBG_RBRUSH,
                    ("DrvRealizeBrush: PatSize=%ld x %ld, HT=%ld x %ld",
                        szlPat.cx, szlPat.cy, szlHT.cx, szlHT.cy));

            //
            // Go generate the bits for the pattern.
            //

            if (psoHT = CloneSURFOBJToHT(pPDev,         // pPDev,
                                         psoDst,        // psoDst,
                                         psoPattern,    // psoSrc,
                                         pxlo,          // pxlo,
                                         &hBmp,         // hBmp,
                                         &rclHT,        // prclDst,
                                         NULL)) {       // prclSrc,

                RetOk = TRUE;

            } else {

                PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: Clone PATTERN FAILED"));
                return(FALSE);
            }

        } else {

            //
            // For Pen type plotter we will never do a standard pattern in the
            // memory (compatible DC). For user defined patterns we will
            // only hatch '\' with background color and a '/' with foreground
            // color with double standard line spacing. This is the best we
            // can hope for on a pen plotter.
            //

            RetOk = TRUE;
            psoHT = psoPattern;
            hBmp  = NULL;
        }

        if (RetOk) {

            //
            // Now Allocate device brush, remember we will only allocate the
            // minimum size.
            //

            Size = (LONG)psoHT->cjBits - (LONG)sizeof(pBrush->BmpBits);

            if (Size < 0) {

                Size = sizeof(DEVBRUSH);

            } else {

                Size += sizeof(DEVBRUSH);
            }

            //
            // Following are the user defined pattern sizes which can be handled
            // internally by HPGL2. This is only for raster plotters. Pen
            // plotters will have a cross hatch to show an emulation of the
            // pattern.
            //

            if ((iHatch >= HS_DDI_MAX)  &&
                (IS_RASTER(pPDev))      &&
                ((szlPat.cx == 8)   ||
                 (szlPat.cx == 16)  ||
                 (szlPat.cx == 32)  ||
                 (szlPat.cx == 64))     &&
                ((szlPat.cy == 8)   ||
                 (szlPat.cy == 16)  ||
                 (szlPat.cy == 32)  ||
                 (szlPat.cy == 64))) {

                //
                // Adding the size which stored the BGR format of the pattern
                //

                OffBGR  = Size;
                Size   += (psoPattern->sizlBitmap.cx * 3) *
                          psoPattern->sizlBitmap.cy;

            } else {

                OffBGR = 0;
            }

            PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: AllocDEVBRUSH(Bmp=%ld,BGR=%ld), TOT=%ld",
                                psoHT->cjBits, Size - OffBGR, Size));

            //
            // Now ask the NT graphics engine to allocate the device
            // brush memory for us. This is done, so NT knows how to discard
            // the memory when it is no longer needed (The brush getting
            // destroyed).
            //

            if (pBrush = (PDEVBRUSH)BRUSHOBJ_pvAllocRbrush(pbo, Size)) {

                //
                // Set up either standard pattern or user defined pattern
                // HPGL/2 FT command string pointer and parameters.
                //

                pBrush->psoMask       = psoMask;
                pBrush->PatIndex      = (WORD)iHatch;
                pBrush->Uniq          = (WORD)(pPDev->DevBrushUniq += 1);
                pBrush->LineSpacing   = (LONG)PATLINESPACE(pPDev);
                pBrush->ColorFG       = (DWORD)XLATEOBJ_iXlate(pxlo, 1);
                pBrush->ColorBG       = (DWORD)XLATEOBJ_iXlate(pxlo, 0);
                pBrush->sizlBitmap    = psoHT->sizlBitmap;
                pBrush->ScanLineDelta = psoHT->lDelta;
                pBrush->BmpFormat     = (WORD)psoHT->iBitmapFormat;
                pBrush->BmpFlags      = (WORD)psoHT->fjBitmap;
                pBrush->pbgr24        = NULL;
                pBrush->cxbgr24       =
                pBrush->cybgr24       = 0;

                PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: DevBrush's Uniq = %ld",
                                            pBrush->Uniq));

                //
                // Check to see if the cache is wrapping and handle it.
                //

                if (pBrush->Uniq == 0) {

                    ResetDBCache(pPDev);

                    pBrush->Uniq        =
                    pPDev->DevBrushUniq = 1;

                    PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: Reset DB Cache, (Uniq WRAP)"));
                }

                //
                // Is it a user defined pattern.
                //

                if (iHatch >= HS_DDI_MAX) {

                    //
                    // Check to see if the brush could be downloaded to the
                    // target device as an HPGL2 brush. If this is the case
                    // save that information.
                    //

                    if (OffBGR) {

                        pBrush->pbgr24  = (LPBYTE)pBrush + OffBGR;
                        pBrush->cxbgr24 = (WORD)psoPattern->sizlBitmap.cx;
                        pBrush->cybgr24 = (WORD)psoPattern->sizlBitmap.cy;

                        ZeroMemory(pBrush->pbgr24, Size - OffBGR);

                        CopyUserPatBGR(pPDev, psoPattern, pxlo, pBrush->pbgr24);

                    } else if (!IS_RASTER(pPDev)) {

                        //
                        // If we are not talking to a RASTER plotter, not much
                        // we can do here. Trigger the simulation.
                        //

                        pBrush->pbgr24 = (LPBYTE)-1;
                    }
                }

                //
                // Copy down the halftoned bits if any.
                //

                if (psoHT->cjBits) {

                    CopyMemory((LPBYTE)pBrush->BmpBits,
                               (LPBYTE)psoHT->pvBits,
                               psoHT->cjBits);
                }

                //
                // Now record the realized brush pointer in the BRUSHOBJ.
                //

                pbo->pvRbrush = (LPVOID)pBrush;

            } else {

                PLOTERR(("DrvRealizeBrush: brush allocation failed"));

                RetOk = FALSE;
            }

        } else {

            PLOTERR(("DrvRealizeBrush: Cloning the psoPattern failed!"));
            RetOk = FALSE;
        }

        if (psoHT != psoPattern) {

            EngUnlockSurface(psoHT);
        }

        if (hBmp) {

            EngDeleteSurface((HSURF)hBmp);
        }

        return(RetOk);

    } else {

        PLOTASSERT(0, "The psoPattern is not a bitmap (psoPattern= %08lx)",
                (psoPattern) &&
                (psoPattern->iType == STYPE_BITMAP), psoPattern);

        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\enable.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    enable.h


Abstract:

    This module contains local #defines used by enable.c


Author:

    12-Nov-1993 Fri 10:27:07 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTENABLE_
#define _PLOTENABLE_



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\escape.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    escape.c


Abstract:

   This module contains the code to implement the DrvEscape() driver call


Author:

    15:30 on Mon 06 Dec 1993    
        Created it


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgEscape

#define DBG_DRVESCAPE         0x00000001


DEFINE_DBGVAR(0);



#define pbIn     ((BYTE *)pvIn)
#define pdwIn    ((DWORD *)pvIn)
#define pdwOut   ((DWORD *)pvOut)



ULONG
DrvEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
)

/*++

Routine Description:

    Performs the escape functions.  Currently,  only 3 are defined -
    one to query the escapes supported,  the other for raw data, and the
    last for setting the COPYCOUNT.


Arguments:

    pso     - The surface object interested

    iEsc    - The function requested

    cjIn    - Number of bytes in the following

    pvIn    - Location of input data

    cjOut   - Number of bytes in the following

    pvOut   - Location of output area


Return Value:

    ULONG depends on the escape


Author:

    05-Jul-1996 Fri 13:18:54 created  
        Re-write comment, and fix the PASSTHROUGH problem

Revision History:


--*/

{
    ULONG   ulRes;
    PPDEV   pPDev;
    DWORD   cbWritten;


    UNREFERENCED_PARAMETER( cjOut );
    UNREFERENCED_PARAMETER( pvOut );


    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvEscape: Invalid pPDev"));
        return(FALSE);
    }

    ulRes = 0;                 /*  Return failure,  by default */

    switch (iEsc) {

    case QUERYESCSUPPORT:

        PLOTDBG(DBG_DRVESCAPE, ("DrvEscape: in QUERYESCAPESUPPORT"));

        if ((cjIn == 4) && (pvIn)) {

            //
            // Data may be valid,  so check for supported function
            //

            switch (*pdwIn) {

            case QUERYESCSUPPORT:
            case PASSTHROUGH:

                ulRes = 1;                 /* ALWAYS supported */
                break;

            case SETCOPYCOUNT:

                //
                // if the target device actually allows us to tell it
                // how many copies to print of a document, then pass
                // that information back to the caller.
                //

                if (pPDev->pPlotGPC->MaxCopies > 1) {

                    ulRes = 1;
                }

                break;
            }
        }

        break;

    case PASSTHROUGH:

        PLOTDBG(DBG_DRVESCAPE, ("DrvEscape: in PASSTHROUGH"));

        //
        // 05-Jul-1996 Fri 12:59:31 updated  
        //
        // This simply passes the RAW data to the target device, untouched.
        //
        // Win 3.1 actually uses the first 2 bytes as a count of the number of
        // bytes that follow!  So we will check if cjIn represents more data
        // than the first WORD of pvIn
        //

        if (EngCheckAbort(pPDev->pso)) {

            //
            // Set the cancel DOC flag
            //

            pPDev->Flags |= PDEVF_CANCEL_JOB;

            PLOTERR(("DrvEscape(PASSTHROUGH): Job Canceled"));

        } else if ((cjIn <= sizeof(WORD)) || (pvIn == NULL)) {

            SetLastError(ERROR_INVALID_PARAMETER);

            PLOTERR(("DrvEscape(PASSTHROUGH): cjIn <= 2 or pvIn=NULL, nothing to output"));

        } else {

            union {
                WORD    wCount;
                BYTE    bCount[2];
            } u;

            u.bCount[0] = pbIn[0];
            u.bCount[1] = pbIn[1];
            cbWritten   = 0;

            if ((u.wCount == 0) ||
                ((cjIn - sizeof(WORD)) < (DWORD)u.wCount)) {

                PLOTERR(("DrvEscape(PASSTHROUGH): cjIn to small OR wCount is zero/too big"));

                SetLastError(ERROR_INVALID_DATA);

            } else if ((WritePrinter(pPDev->hPrinter,
                                        (LPVOID)(pbIn + 2),
                                        (DWORD)u.wCount,
                                        &cbWritten))    &&
                       ((DWORD)u.wCount == cbWritten)) {

                ulRes = (DWORD)u.wCount;

            } else {

                PLOTERR(("DrvEscape(PASSTHROUGH): WritePrinter() FAILED, cbWritten=%ld bytes",
                            cbWritten));
            }
        }

        break;

    case SETCOPYCOUNT:

        //
        // Input data is a DWORD count of copies
        //

        PLOTDBG(DBG_DRVESCAPE, ("DrvEscape: in SETCOPYCOUNT"));

        if ((pdwIn) && (*pdwIn)) {

            //
            // Load the value of current copies since we will, and Check that
            // is within the printers range,  and truncate if it is not.
            // The device information structure, tells us the maximum amount
            // of copies the device can generate on its own. We save this new
            // Copy amount inside of our current DEVMODE that we have stored,
            // as part of our PDEV. The copy count actually gets output
            // later to the target device.
            //

            pPDev->PlotDM.dm.dmCopies = (SHORT)*pdwIn;

            if ((WORD)pPDev->PlotDM.dm.dmCopies > pPDev->pPlotGPC->MaxCopies) {

               pPDev->PlotDM.dm.dmCopies = (SHORT)pPDev->pPlotGPC->MaxCopies;
            }

            if ((pdwOut) && (cjOut)) {

                cbWritten = (DWORD)pPDev->PlotDM.dm.dmCopies;

                CopyMemory(pdwOut,
                           &cbWritten,
                           (cjOut >= sizeof(DWORD)) ? sizeof(DWORD) : cjOut);
            }


            //
            // Success!
            //

            ulRes = 1;
        }

        break;

    default:

        PLOTERR(("DrvEscape: Unsupported Escape Code : %d\n", iEsc ));

        SetLastError(ERROR_INVALID_FUNCTION);
        break;
    }

    return(ulRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\enable.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    enable.c


Abstract:

    This module contains the Plotter driver's Enable and Disable functions
    and related routines.

    The functions dealing with driver initialization are as follows:

        DrvEnableDriver()
        DrvEnablePDEV()
        DrvResetPDEV()
        DrvCompletePDEV()
        DrvEnableSurface()
        DrvDisableSurface()
        DrvDisablePDEV()
        DrvDisableDriver()

Author:

    12-Nov-1993 Fri 10:16:36 updated  
        Move all #define related only to this function to here

    15-Nov-1993 Mon 19:31:34 updated  
        clean up / debugging information

    05-Jan-1994 Wed 22:50:28 updated  
        Move ColorMap's RGB pen color to local so that we only need array
        reference, it defined PenRGBColor as DWORD from RGB() macro

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgEnable

#define DBG_ENABLEDRV       0x00000001
#define DBG_DISABLEDRV      0x00000002
#define DBG_ENABLEPDEV      0x00000004
#define DBG_COMPLETEPDEV    0x00000008
#define DBG_DISABLEPDEV     0x00000010
#define DBG_ENABLESURF      0x00000020
#define DBG_DISABLESURF     0x00000040
#define DBG_GDICAPS         0x00000080
#define DBG_DEVCAPS         0x00000100
#define DBG_PENPAL          0x00000200
#define DBG_BAND            0x00000400
#define DBG_DLLINIT         0x00000800


DEFINE_DBGVAR(0);

#if DBG
TCHAR   DebugDLLName[] = TEXT("PLOTTER");
#endif

#define FIXUP_PLOTGPC_PDATA(pd,ps,v)                                        \
    if (ps->v) {pd->v=(LPVOID)((LPBYTE)pd+((LPBYTE)(ps->v)-(LPBYTE)ps));}

//
// Local funtion prototypes.
//

BOOL
CommonStartPDEV(
    PDEV        *pPDev,
    DEVMODEW    *pPlotDMIn,
    ULONG       cPatterns,
    HSURF       *phsurfPatterns,
    ULONG       cjDevCaps,
    ULONG       *pDevCaps,
    ULONG       cjDevInfo,
    DEVINFO     *pDevInfo
    );



//
// Define the table with the hooked function pointers. This table is passed
// back to the NT graphic engine at DrvEnableDriver time. From then on GDI
// will call our driver via these supplied hook procs.
//


static const DRVFN DrvFuncTable[] = {

        {  INDEX_DrvDisableDriver,       (PFN)DrvDisableDriver      },
        {  INDEX_DrvEnablePDEV,          (PFN)DrvEnablePDEV         },
        {  INDEX_DrvResetPDEV,           (PFN)DrvResetPDEV          },
        {  INDEX_DrvCompletePDEV,        (PFN)DrvCompletePDEV       },
        {  INDEX_DrvDisablePDEV,         (PFN)DrvDisablePDEV        },
        {  INDEX_DrvEnableSurface,       (PFN)DrvEnableSurface      },
        {  INDEX_DrvDisableSurface,      (PFN)DrvDisableSurface     },

        // {  INDEX_DrvQueryFont,           (PFN)DrvQueryFont          },
        // {  INDEX_DrvQueryFontTree,       (PFN)DrvQueryFontTree      },
        // {  INDEX_DrvQueryFontData,       (PFN)DrvQueryFontData      },

        {  INDEX_DrvStrokePath,          (PFN)DrvStrokePath         },
        {  INDEX_DrvStrokeAndFillPath,   (PFN)DrvStrokeAndFillPath  },
        {  INDEX_DrvFillPath,            (PFN)DrvFillPath           },
        {  INDEX_DrvRealizeBrush,        (PFN)DrvRealizeBrush       },
        {  INDEX_DrvBitBlt,              (PFN)DrvBitBlt             },
        {  INDEX_DrvStretchBlt,          (PFN)DrvStretchBlt         },
        {  INDEX_DrvCopyBits,            (PFN)DrvCopyBits           },

        {  INDEX_DrvPaint,               (PFN)DrvPaint              },
        {  INDEX_DrvGetGlyphMode,        (PFN)DrvGetGlyphMode       },
        {  INDEX_DrvTextOut,             (PFN)DrvTextOut            },
        {  INDEX_DrvSendPage,            (PFN)DrvSendPage           },
        {  INDEX_DrvStartPage,           (PFN)DrvStartPage          },
        {  INDEX_DrvStartDoc,            (PFN)DrvStartDoc           },
        {  INDEX_DrvEndDoc,              (PFN)DrvEndDoc             },

        {  INDEX_DrvEscape,              (PFN)DrvEscape             },
    };

#define TOTAL_DRVFUNC   (sizeof(DrvFuncTable)/sizeof(DrvFuncTable[0]))

#ifdef USERMODE_DRIVER


HINSTANCE   ghInstance;

BOOL
DllMain(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
DrvQueryDriverInfo(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Query driver information

Arguments:

    dwMode - Specify the information being queried
    pBuffer - Points to output buffer
    cbBuf - Size of output buffer in bytes
    pcbNeeded - Return the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch (dwMode)
    {
    case DRVQUERY_USERMODE:

        PLOTASSERT(1, "DrvQueryDriverInfo: pcbNeeded [%08lx] is NULL", pcbNeeded != NULL, pcbNeeded);
        *pcbNeeded = sizeof(DWORD);

        if (pBuffer == NULL || cbBuf < sizeof(DWORD))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PDWORD) pBuffer) = TRUE;
        return TRUE;

    default:

        PLOTERR(("Unknown dwMode in DrvQueryDriverInfo: %d\n", dwMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}

#endif // USERMODE_DRIVER



BOOL
DrvEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cb,
    DRVENABLEDATA   *pded
    )

/*++

Routine Description:

    Requests the driver to fill in a structure containing recognized functions
    and other control information.  One time initialization, such as semaphore
    allocation may be performed,  but no device activity should happen.  That
    is done when DrvEnablePDEV is called.  This function is the only way the
    engine can determine what functions we supply to it.

Arguments:

    iEngineVersion  - The engine version which we run under

    cb              - total bytes in pded

    pded            - Pointer to the DRVENABLEDATA data structure


Return Value:

    TRUE if sucssfully FALSE otherwise


Author:

    01-Dec-1993 Wed 02:03:20 created  

    03-Mar-1994 Thu 10:04:30 updated  
        Adding EngineVersion check to make sure ourself can run correctly.


Revision History:


--*/

{
    PLOTDBG(DBG_ENABLEDRV, ("DrvEnableDriver: EngineVersion=%08lx, Request=%08lx",
                                    iEngineVersion, DDI_DRIVER_VERSION_NT4));

    //
    // Verify the Engine version is at least what we know we can work with.
    // If its older, error out now, as we don't know what may happen.
    //

    if (iEngineVersion < DDI_DRIVER_VERSION_NT4) {

        PLOTRIP(("DrvEnableDriver: EARLIER VERSION: EngineVersion(%08lx) < Request(%08lx)",
                                    iEngineVersion, DDI_DRIVER_VERSION_NT4));

        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return(FALSE);
    }

    //
    // cb is a count of the number of bytes available in pded.  It is not
    // clear that there is any significant use of the engine version number.
    // Returns TRUE if successfully enabled,  otherwise FALSE.
    //
    // iEngineVersion is the engine version while DDI_DRIVER_VERSION is the
    // driver version. So, unless we re-compile the driver and get a new
    // version of driver, we can only stick with our version.
    //

    if (cb < sizeof(DRVENABLEDATA)) {

        SetLastError(ERROR_INVALID_PARAMETER);

        PLOTRIP(("DrvEnableDriver: cb=%ld, should be %ld\n",
                                                cb, sizeof(DRVENABLEDATA)));
        return(FALSE);
    }

    pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    //
    // Fill in the driver table returned to the engine.  This table is used
    // by GDI to call the rest of our functinos.
    //

    pded->c      = TOTAL_DRVFUNC;
    pded->pdrvfn = (DRVFN *)DrvFuncTable;

    //
    // Initialize the GPC cache
    //

    InitCachedData();

    return(TRUE);
}





VOID
DrvDisableDriver(
    VOID
    )

/*++

Routine Description:

    Called just before the engine unloads the driver.  Main purpose is
    to allow freeing of any resources obtained during the DrvEnableDriver()
    call.

Arguments:

    NONE

Return Value:

    VOID

Author:

    01-Dec-1993 Wed 02:02:18 created  

    01-Feb-1994 Tue 22:03:03 updated  
        Make sure we unload the cache.


Revision History:


--*/

{
    DestroyCachedData();

    PLOTDBG(DBG_DISABLEDRV, ("DrvDisableDriver: Done!!"));
}




VOID
FreeAllocMem(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function frees all the memory allocated during the lifetime of the
    PDEV.


Arguments:

    pPDev   - Our instance data


Return Value:

    VOID


Author:

    24-Oct-1995 Tue 16:28:35 created  


Revision History:


--*/

{
    //
    // Free any memory allocated during PDEV initialization.
    //

    if (pPDev) {

        PDRVHTINFO  pDrvHTInfo;

        if (pPDev->hPalDefault) {

            EngDeletePalette(pPDev->hPalDefault);
            pPDev->hPalDefault = NULL;
        }

        if (pDrvHTInfo = (PDRVHTINFO)(pPDev->pvDrvHTData)) {

            if (pDrvHTInfo->pHTXB) {

                LocalFree((HLOCAL)pDrvHTInfo->pHTXB);
                pDrvHTInfo->pHTXB = NULL;
            }

            pPDev->pvDrvHTData = NULL;
        }

        if (pPDev->pPenCache) {

            LocalFree((HLOCAL)pPDev->pPenCache);
            pPDev->pPenCache = NULL;
        }

        if (pPDev->pTransPosTable) {

            LocalFree((HLOCAL)pPDev->pTransPosTable);
            pPDev->pTransPosTable = NULL;
        }

        FreeOutBuffer(pPDev);

        LocalFree((HLOCAL)pPDev);
    }
}



DHPDEV
DrvEnablePDEV(
    DEVMODEW    *pPlotDMIn,
    PWSTR       pwszLogAddr,
    ULONG       cPatterns,
    HSURF       *phsurfPatterns,
    ULONG       cjDevCaps,
    ULONG       *pDevCaps,
    ULONG       cjDevInfo,
    DEVINFO     *pDevInfo,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver
    )

/*++

Routine Description:

    Function called to let the driver create the data structures
    needed to support the device,  and also to tell the engine
    about its capabilities.  This is the stage where we find out
    exactly which device we are dealing with,  and so we need to
    find out its capabilities.

Arguments:

    pPlotDMIn       - Pointer to the DEVMODE data structure

    pwszLogAddr     - pointer to the output location, (ie. LPT1

    cPatterns       - Count of pattern to be set in phsurfPatterns

    phsurfPatterns  - pointer to the standard pattern HSURF array

    cjDevCaps       - total size of pDevCaps pointed to.

    pDevCaps        - pointer to the device cap DWORDs

    cjDevInfo       - total size of pDevInfo pointed to

    pDevInfo        - pointer to the DEVINFO data structure

    hdev            - Handle to the logical device from the engine

    pwszDeviceName  - pointer to the plotter device name

    hDriver         - handle to this driver


Return Value:

    DHPDEV  if sucessful, NULL if failed


Author:

    15-Dec-1993 Wed 21:04:40 updated  
        Add cached mechanism for the PLOTGPC

    14-Dec-1993 Tue 20:22:26 updated  
        Update how the pen plotter data should work

    23-Nov-1993 Tue 19:48:08 updated  
        Clean up and using new devmode.c in ..\lib directory

    17:30 on Mon  1 Apr 1991    
        Took skeletal code from RASDD printer driver

    16-Jul-1996 Tue 13:59:15 updated  
        Fix up the pData in the PLOTGPC/GPCVARSIZE structure, since the
        pointer is based on the cached GPC not the clone copy of it


Revision History:


--*/

{
    PPDEV       pPDev = NULL;
    PPLOTGPC    pPlotGPC;
    LPWSTR      pwszDataFile = NULL;

#ifdef USERMODE_DRIVER

    PDRIVER_INFO_2 pDriverInfo = NULL;
    DWORD       dwBytesNeeded;

#endif


    UNREFERENCED_PARAMETER(pwszLogAddr);

    #ifndef USERMODE_DRIVER

    pwszDataFile = EngGetPrinterDataFileName(hdev);

    #else

    if (!GetPrinterDriver(hDriver, NULL, 2, NULL, 0, &dwBytesNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverInfo = (PDRIVER_INFO_2)LocalAlloc(LPTR, dwBytesNeeded)) &&
        GetPrinterDriver(hDriver, NULL, 2, (LPBYTE)pDriverInfo, dwBytesNeeded, &dwBytesNeeded))
    {
        pwszDataFile = pDriverInfo->pDataFile;
    }

    #endif  // !USERMODE_DRIVER

    if (!pwszDataFile) {

        PLOTRIP(("DrvEnablePDEV: pwszDataFile is NULL"));

    } else if (!(pPlotGPC = GetCachedPlotGPC(pwszDataFile))) {

        PLOTRIP(("DrvEnablePDEV: GetCachedPlotGPC(%ws) failed", pwszDataFile));

    } else if (!(pPDev = (PPDEV)LocalAlloc(LPTR,
                                           sizeof(PDEV) + sizeof(DRVHTINFO) +
                                                    pPlotGPC->cjThis +
                                                    pPlotGPC->SizeExtra))) {

        //
        // Free the cached pPlotGPC before we leave
        //

        UnGetCachedPlotGPC(pPlotGPC);

        PLOTRIP(("DrvEnablePDEV: LocalAlloc(PDEV + DRVHTINFO + pPlotGPC) failed."));

    } else {

        PLOTDBG(DBG_ENABLEPDEV,("EnablePDEV: PlotGPC data file=%ws",
                                                            pwszDataFile));

        //
        // If we got the PDEV set the ID for later checking, also set the
        // hPrinter so we can use it later
        //

        pPDev->pvDrvHTData = (LPVOID)((LPBYTE)pPDev + sizeof(PDEV));
        pPDev->hPrinter    = hDriver;
        pPDev->SizePDEV    = sizeof(PDEV);
        pPDev->PDEVBegID   = PDEV_BEG_ID;
        pPDev->PDEVEndID   = PDEV_END_ID;

        //
        // We will get the PLOTGPC from the cach, the pPlotGPC is
        // allocated by the ReadPlotGPCFromFile() using LocalAlloc().
        //
        // *** NOW we will Clone the cached pPlotGPC then un-cached it
        //

        pPDev->pPlotGPC = (PPLOTGPC)((LPBYTE)pPDev + sizeof (PDEV) +
                                                            sizeof(DRVHTINFO));

        CopyMemory(pPDev->pPlotGPC,
                   pPlotGPC,
                   pPlotGPC->cjThis + pPlotGPC->SizeExtra);

        //
        // 16-Jul-1996 Tue 13:59:15 updated  
        //  Fix up the pData in the PLOTGPC/GPCVARSIZE structure, since the
        //  pointer is based on the cached GPC not the clone copy of it
        //

        FIXUP_PLOTGPC_PDATA(pPDev->pPlotGPC, pPlotGPC, InitString.pData);
        FIXUP_PLOTGPC_PDATA(pPDev->pPlotGPC, pPlotGPC, Forms.pData);
        FIXUP_PLOTGPC_PDATA(pPDev->pPlotGPC, pPlotGPC, Pens.pData);

        UnGetCachedPlotGPC(pPlotGPC);

        //
        // Now, depending on if its a pen/raster device, we will update
        // the pen data.
        //

        PLOTASSERT(1, "Raster Plotter should not have PEN data [%08lx]",
                        ((pPDev->pPlotGPC->Flags & PLOTF_RASTER) &&
                         (pPDev->pPlotGPC->Pens.pData == NULL))     ||
                        ((!(pPDev->pPlotGPC->Flags & PLOTF_RASTER)) &&
                         (pPDev->pPlotGPC->Pens.pData != NULL)),
                         pPDev->pPlotGPC->Pens.pData);

        //
        // Read the data from the registry which defines device settings.
        // The user may have modified the paper type loaded etc.
        //

        GetDefaultPlotterForm(pPDev->pPlotGPC, &(pPDev->CurPaper));

        //
        // Set the default Flags in case we did not update from the registry
        //

        pPDev->PPData.Flags = PPF_AUTO_ROTATE     |
                              PPF_SMALLER_FORM    |
                              PPF_MANUAL_FEED_CX;

        if (IS_RASTER(pPDev)) {

            //
            // Raster devices do not need pen data
            //

            UpdateFromRegistry(hDriver,
                               &(pPDev->pPlotGPC->ci),
                               &(pPDev->pPlotGPC->DevicePelsDPI),
                               &(pPDev->pPlotGPC->HTPatternSize),
                               &(pPDev->CurPaper),
                               &(pPDev->PPData),
                               NULL,
                               0,
                               NULL);

        } else {

            //
            // The Pen plotter does not need ColorInfo, DevicePelsDPI and
            // HTPatternSize
            //

            UpdateFromRegistry(hDriver,
                               NULL,
                               NULL,
                               NULL,
                               &(pPDev->CurPaper),
                               &(pPDev->PPData),
                               NULL,
                               MAKELONG(0xFFFF, pPDev->pPlotGPC->MaxPens),
                               (PPENDATA)pPDev->pPlotGPC->Pens.pData);
        }

        //
        // common code for DrvEnablePDEV and DrvResetPDEV
        // we must first copy the device name to the pPDev->PlotDM
        // then call the common code.
        //

        WCPYFIELDNAME(pPDev->PlotDM.dm.dmDeviceName, pwszDeviceName);

        if (!CommonStartPDEV(pPDev,
                             pPlotDMIn,
                             cPatterns,
                             phsurfPatterns,
                             cjDevCaps,
                             pDevCaps,
                             cjDevInfo,
                             pDevInfo)) {

            FreeAllocMem(pPDev);
            pPDev = NULL;

        }
    }

#ifdef USERMODE_DRIVER

    if (pDriverInfo) {

       LocalFree((HLOCAL)pDriverInfo);
    }

#endif // USERMODE_DRIVER

    return((DHPDEV)pPDev);
}




BOOL
DrvResetPDEV(
    DHPDEV      dhpdevOld,
    DHPDEV      dhpdevNew
    )

/*++

Routine Description:

   Called when an application wishes to change the output style in the
   midst of a job.  Typically this would be to change from portrait to
   landscape or vice versa.  Any other sensible change is permitted.

Arguments:

    dhpdevOld   - the OLD pPDev which we returned in DrvEnablePDEV

    dhpdevNew   - the NEW pPDev which we returned in DrvEnablePDEV


Return Value:


    BOOLEAN


Author:

    23-Nov-1993 Tue 20:07:45 updated  
        totaly re-write

    17:30 on Mon  1 Apr 1991    
        Took skeletal code from RASDD printer driver





Revision History:


--*/

{
#define pPDevOld    ((PDEV *) dhpdevOld)
#define pPDevNew    ((PDEV *) dhpdevNew)

    //
    // Make sure we got the correct pPlotDMin for this pPDev
    //

    if ((pPDevOld->PlotDM.dm.dmDriverVersion !=
                                pPDevNew->PlotDM.dm.dmDriverVersion) ||
        (wcscmp((LPWSTR)pPDevOld->PlotDM.dm.dmDeviceName,
                (LPWSTR)pPDevNew->PlotDM.dm.dmDeviceName))) {

        PLOTERR(("DrvResetPDEV: Incompatible PLOTDEVMODE"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // We have nothing to carry over from old to new
    //

    return(TRUE);


#undef pPDevNew
#undef pPDevOld
}



VOID
DrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hpdev
    )

/*++

Routine Description:

    Called when the engine has completed installation of the physical
    device.  Basically it provides the connection between the
    engine's hpdev and ours.  Some functions require us to pass in
    the engines's hpdev,  so we save it now in our pdev so that we
    can get to it later.

Arguments:

    dhpdev  - Returned from dhpdevCreatePDEV

    hpdev   - Engine's corresponding handle


Return Value:

    VOID


Author:

    01-Dec-1993 Wed 01:56:58 created  


Revision History:


--*/

{
    //
    // Simply record the value in the PDEV we have allocated.
    //

    ((PPDEV)dhpdev)->hpdev = hpdev;

    PLOTDBG(DBG_COMPLETEPDEV, ("CompletePDEV: Done!"));
}



VOID
DrvDisablePDEV(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Called when the engine has finished with this PDEV.  Basically we throw
    away all connections etc. then free the memory.

Arguments:

    dhpdev  - OUR handle to the pdev

Return Value:

    VOID


Author:

    01-Dec-1993 Wed 01:55:43 created  


Revision History:


--*/

{
#define pPDev  ((PDEV *) dhpdev)

    //
    // Undo all that has been done with the PDEV.  Basically this means
    // freeing the memory we consumed.
    //

    FreeAllocMem(pPDev);

    PLOTDBG(DBG_DISABLEPDEV, ("DrvDisablePDEV: FreeAllocMem() completes"));

#undef pPDev
}




HSURF
DrvEnableSurface(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Function to create the physical drawing surface for the pdev
    that was created earlier.  Since we don't really have a bitmap surface,
    all we do here is allocate the output buffer. This is typical for a
    Device Managed Surface. After this call completes succesfully, GDI can
    start drawing on our surface.



Arguments:

    dhpdev  - OUR handle to the pdev

Return Value:

    HSURF for the surface we created


Author:

    01-Dec-1993 Wed 01:47:36 created  

    10-Dec-1993 Fri 16:36:37 updated  
        Move PlotCreatePalette() to here to prevent GP

    16-Dec-1993 Thu 12:16:11 updated  
        Move PlotCreatePalette() out to SendPageHeader() in output.c so that
        we do not sending some PC commands which has no effects.

    06-Jan-1994 Thu 04:12:37 updated  
        Re-arrange the code sequence.
        Adding Error codes so it will failed the call if engine said so.

Revision History:


--*/

{
#define  pPDev ((PPDEV)dhpdev)

    PDRVHTINFO  pDrvHTInfo;
    SIZEL       SurfSize;


    pDrvHTInfo = (PDRVHTINFO)(pPDev->pvDrvHTData);

    //
    // Make sure we delete this xlate table before we process the new
    // surface
    //

    if (pDrvHTInfo->pHTXB) {

        LocalFree((HLOCAL)pDrvHTInfo->pHTXB);
        pDrvHTInfo->pHTXB = NULL;
    }

    pDrvHTInfo->Flags       = 0;
    pDrvHTInfo->PalXlate[0] = 0xff;
    pDrvHTInfo->HTPalXor    = HTPALXOR_SRCCOPY;

    //
    // Since output is expected to follow this call,  allocate storage for the
    // output buffer.  This used to be statically allocated within the PDEV but
    // now we can save that space for INFO type DCs, since CreateIC won't
    // actually end up calling DrvEnableSurface.
    //

    if (!AllocOutBuffer(pPDev)) {

        PLOTERR(("DrvEnableSurface: AllocOutBuffer() failed"));

        return(NULL);
    }

    //
    // For now pass in my PDev pointer as the dhsurf value.  If we actually
    // need to pass back an hsurf to the engine later, We can use this value
    // as a pointer to the hsurf value stored in our PDev.
    //

    SurfSize.cx  = pPDev->HorzRes;
    SurfSize.cy  = pPDev->VertRes;

    if (!(pPDev->hsurf = EngCreateDeviceSurface((DHSURF)pPDev, SurfSize,
                         IS_RASTER(pPDev) ? BMF_24BPP : BMF_4BPP))) {
        PLOTERR(("DrvEnableSurface: EngCreateDeviceSurface() failed"));
        return(NULL);
    }

    //
    //
    // Now we need to associate the newly created surface with the already
    // created PDEV. In this function, we inform the NT graphics engine,
    // which functions our driver supports.
    //

    if (!EngAssociateSurface(pPDev->hsurf,
                             (HDEV)pPDev->hpdev,
                             HOOK_BITBLT                |
                                 HOOK_STRETCHBLT        |
                                 HOOK_COPYBITS          |
                                 HOOK_STROKEPATH        |
                                 HOOK_FILLPATH          |
                                 HOOK_STROKEANDFILLPATH |
                                 HOOK_PAINT             |
                                 HOOK_TEXTOUT)) {

        PLOTERR(("DrvEnableSurface: EngAssociateSurface() failed"));

        DrvDisableSurface((DHPDEV)pPDev->hpdev);
        EngDeleteSurface(pPDev->hsurf);

        return(NULL);
    }

    return(pPDev->hsurf);

#undef pPDev
}



VOID
DrvDisableSurface(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    The drawing surface is no longer required,  so we can delete any
    memory we allocated in conjunction with it.

Arguments:

    dhpdev  - our pPDev


Return Value:

    VOID


Author:

    01-Dec-1993 Wed 01:45:39 created  


Revision History:


--*/

{
#define  pPDev ((PPDEV)dhpdev)

    if (pPDev->hsurf) {

        EngDeleteSurface(pPDev->hsurf);
    }

#undef pPDev
}




DWORD
hypot(
    DWORD   x,
    DWORD   y
    )

/*++

Routine Description:

    Returns the length of the hypotenous of a xRight triangle whose sides
    are passed in as the parameters.

Arguments:

    x   - x side of the triangle

    y   - y size of the triangle

Return Value:

    hypotenous


Author:

    13:54 on Tue 02 Feb 1993    
        Re-instated from Win 3.1,  for compatability.

    01-Dec-1993 Wed 01:10:55 updated  
        update to DWORD

Revision History:


--*/

{
    DWORD   hypo;
    DWORD   Delta;
    DWORD   Target;

    //
    // Finds the hypoteneous of a xRight triangle with legs equal to x and y.
    // Assumes x, y, hypo are integers. Use sq(x) + sq(y) = sq(hypo);
    // Start with MAX(x, y), use sq(x + 1) = sq(x) + 2x + 1 to incrementally
    // get to the target hypotenouse.
    //

    hypo    = max(x, y);
    Target  = min(x, y);
    Target *= Target;

    for (Delta = 0; Delta < Target; hypo++) {

        Delta += (DWORD)((hypo << 1) + 1);
    }

    return(hypo);
}




VOID
FillDeviceCaps(
    PPDEV   pPDev,
    GDIINFO *pGDIInfo
    )

/*++

Routine Description:

    Set up the device caps for this particular plotter.  Some fields require
    calculations based on device resolution, etc.

    We simply fill the GDIINFO structure passed to us.  The calling
    function will take care of copying the information into the
    Graphics Engine's buffer.


Arguments:

    pPDev       - Pointer to the PDEV data structure

    pGDIInfo    - Pointer to the GDIINFO data structure to be filled in


Return Value:

    VOID


Author:

    24-Nov-1993 Wed 22:38:10 updated  
        Re-write, and using CurForm to replace the pform and PAPER_DIM

    23-Dec-1993 Thu 21:56:20 updated  
        Make halftone bitmap surface also look at dmColor which set by the
        user if it want to print grey scale or device is not color

    07-Feb-1994 Mon 20:37:13 updated  
        When is DMCOLOR_COLOR the ulNumColors return to the engine will be
        MaxPens which specified in the PCD file not 8


Revision History:


--*/

{
    PDRVHTINFO  pDrvHTInfo;
    LONG        Scale;


    //
    // we will always start from clean state
    //

    ZeroMemory(pGDIInfo, sizeof(GDIINFO));

    //
    // Get pDrvHTInfo data pointer and set the basic version information
    //

    pDrvHTInfo             = (PDRVHTINFO)pPDev->pvDrvHTData;
    pGDIInfo->ulVersion    = DRIVER_VERSION;
    pGDIInfo->ulTechnology = (IS_RASTER(pPDev) ? DT_RASPRINTER : DT_PLOTTER);

    //
    // We have pPDev->PlotForm updated during the ValidateSetPLOTDM() call, so
    // use it, we need to look into the dmScale to see if we need to scale
    // all of the values.
    //

    Scale                = (LONG)pPDev->PlotDM.dm.dmScale;
    pGDIInfo->ulHorzSize = pPDev->PlotForm.LogExt.cx / (Scale * 10);
    pGDIInfo->ulVertSize = pPDev->PlotForm.LogExt.cy / (Scale * 10);
    pPDev->HorzRes       =
    pGDIInfo->ulHorzRes  = SPLTOENGUNITS(pPDev, pPDev->PlotForm.LogExt.cx);
    pPDev->VertRes       =
    pGDIInfo->ulVertRes  = SPLTOENGUNITS(pPDev, pPDev->PlotForm.LogExt.cy);

    PLOTDBG(DBG_GDICAPS, ("GDICAPS: H/V Size=%d x %d, H/V Res=%ld x %ld",
                            pGDIInfo->ulHorzSize, pGDIInfo->ulVertSize,
                            pGDIInfo->ulHorzRes, pGDIInfo->ulVertRes));

    pGDIInfo->szlPhysSize.cx  = SPLTOENGUNITS(pPDev,pPDev->PlotForm.LogSize.cx);
    pGDIInfo->szlPhysSize.cy  = SPLTOENGUNITS(pPDev,pPDev->PlotForm.LogSize.cy);
    pGDIInfo->ptlPhysOffset.x = SPLTOENGUNITS(pPDev,pPDev->PlotForm.PhyOrg.x);
    pGDIInfo->ptlPhysOffset.y = SPLTOENGUNITS(pPDev,pPDev->PlotForm.PhyOrg.y);

    PLOTDBG(DBG_GDICAPS, ("GDICAPS: PhySize= %d x %d, PhyOff=(%ld, %ld)",
                pGDIInfo->szlPhysSize.cx, pGDIInfo->szlPhysSize.cy,
                pGDIInfo->ptlPhysOffset.x, pGDIInfo->ptlPhysOffset.y));

    //
    // Assume the device has a 1:1 aspect ratio
    //

    pGDIInfo->ulLogPixelsX =
    pGDIInfo->ulLogPixelsY = (pPDev->lCurResolution * Scale / 100);

    PLOTDBG(DBG_GDICAPS, ("GDICAPS: LogPixelsX/Y = %d x %d",
                pGDIInfo->ulLogPixelsX, pGDIInfo->ulLogPixelsY));

    pGDIInfo->ulAspectX    =
    pGDIInfo->ulAspectY    = pPDev->lCurResolution;
    pGDIInfo->ulAspectXY   = hypot(pGDIInfo->ulAspectX, pGDIInfo->ulAspectY);


    pGDIInfo->ciDevice        = pPDev->pPlotGPC->ci;
    pGDIInfo->ulDevicePelsDPI = (DWORD)pPDev->pPlotGPC->DevicePelsDPI *
                                (DWORD)Scale / (DWORD)100;
    pGDIInfo->ulHTPatternSize = pPDev->pPlotGPC->HTPatternSize;
    pGDIInfo->flHTFlags       = HT_FLAG_HAS_BLACK_DYE;
    pGDIInfo->ulPrimaryOrder  = PRIMARY_ORDER_CBA;

    PLOTDBG(DBG_GDICAPS, ("GDICAPS: HTPatSize=%ld, DevPelsDPI=%ld, PrimaryOrder=%ld",
                    pGDIInfo->ulHTPatternSize, pGDIInfo->ulDevicePelsDPI,
                    pGDIInfo->ulPrimaryOrder));

    //
    // If the device is a color device, then set up the Halftoning info now.
    //

    if (pPDev->PlotDM.dm.dmColor == DMCOLOR_COLOR) {

        //
        // Do this only if we really want to do color in R/G/B not C/M/Y
        //

        PLOTDBG(DBG_DEVCAPS, ("FillDeviceCaps: Doing Color Output"));

        pDrvHTInfo->HTPalCount     = 8;
        pDrvHTInfo->HTBmpFormat    = (BYTE)BMF_4BPP;
        pDrvHTInfo->AltBmpFormat   = (BYTE)BMF_1BPP;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_4BPP;

    } else {

        pDrvHTInfo->HTPalCount     = 2;
        pDrvHTInfo->HTBmpFormat    = (BYTE)BMF_1BPP;
        pDrvHTInfo->AltBmpFormat   = (BYTE)0xff;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_1BPP;

        //
        // Using this flag will give us a good benefit, the flag notifies gdi
        // and halftone eng. that the output from halftone will be
        // 0=white and 1=black
        // as opposed to the typical 0=black, 1=white, so that at 99% of time
        // we do not have to flip the B/W buffer except if CopyBits is from the
        // calling app.
        //
        // pGDIInfo->flHTFlags |= HT_FLAG_OUTPUT_CMY;
        //

        PLOTDBG(DBG_DEVCAPS, ("FillDeviceCaps: Doing GREY SCALE (%hs) Output",
            (pGDIInfo->flHTFlags & HT_FLAG_OUTPUT_CMY) ? "CMY: 0=W, 1=K" :
                                                         "RGB: 0=K, 1=W"));
    }

    pGDIInfo->ulNumColors   = pPDev->pPlotGPC->MaxPens;
    pDrvHTInfo->Flags       = 0;
    pDrvHTInfo->PalXlate[0] = 0xff;
    pDrvHTInfo->HTPalXor    = HTPALXOR_SRCCOPY;

    pGDIInfo->cBitsPixel = 24;
    pGDIInfo->cPlanes    = 1;

    //
    // Some other information the Engine expects us to fill in.
    //

    pGDIInfo->ulDACRed     = 0;
    pGDIInfo->ulDACGreen   = 0;
    pGDIInfo->ulDACBlue    = 0;
    pGDIInfo->flRaster     = 0;
    pGDIInfo->flTextCaps   = 0;
    pGDIInfo->xStyleStep   = 1;
    pGDIInfo->yStyleStep   = 1;
    pGDIInfo->denStyleStep = PLOT_STYLE_STEP(pPDev);

}





BOOL
FillDevInfo(
    PPDEV   pPDev,
    DEVINFO *pDevInfo
    )

/*++

Routine Description:

    Set up the device info for this particular plotter.  Some fields
    require calculations based on device resolution, etc.

    We simply fill the DevInfo structure passed to us.  The calling
    function will take care of copying the information into the
    Graphics Engine's buffer.


Arguments:

    pPDev           - pointer to the PDEV data structure

    pDevInfo        - pointer to the DEVINFO to be filled


Return Value:

    TRUE if sucessful FALSE otherwise


Author:

    01-Dec-1993 Wed 00:46:00 created  

    10-Dec-1993 Fri 16:37:06 updated  
        Temp. disable and move the PlotCreatePalette to EnableSurf call

    17-Dec-1993 Fri 16:37:06 updated  
        Move PlotCreatePalette to StartDoc time

    05-Jan-1994 Wed 22:54:21 updated  
        Move PenColor Reference to this file and reference that directly as
        DWORD generate by RGB() marco

    14-Jan-1994 Fri 15:35:02 updated  
        Remove HTPatternSize param

    23-Feb-1994 Wed 13:02:09 updated  
        Make sure we return GCAPS_HALFTONE so that we will get DrvStretchBlt()
        callback

Revision History:


--*/

{

    //
    // Start with a clean slate.
    //

    ZeroMemory(pDevInfo, sizeof(DEVINFO));

    //
    // fill in the graphics capabilities flags we know we can handle at
    // the very least.
    //

    pDevInfo->flGraphicsCaps = GCAPS_ALTERNATEFILL  |
                               GCAPS_HORIZSTRIKE    |
                               GCAPS_VERTSTRIKE     |
                               GCAPS_VECTORFONT;

    //
    // If RGB mode is on for color handling then text can be opaque
    //

    if (IS_RASTER(pPDev)) {

        pDevInfo->flGraphicsCaps |= GCAPS_HALFTONE;

        if (IS_COLOR(pPDev)) {

            pDevInfo->flGraphicsCaps |= GCAPS_OPAQUERECT;
        }
    }

    //
    // Check and set the BEZIER capability of the device....
    //

    if (IS_BEZIER(pPDev)) {

        pDevInfo->flGraphicsCaps |= GCAPS_BEZIERS;
    }

    if (IS_WINDINGFILL(pPDev)) {

        pDevInfo->flGraphicsCaps |= GCAPS_WINDINGFILL;
    }

    //
    // We don't process DrvDitherColor (perhaps later?), so set the size of
    // the Dither Brush to 0 to indicate this to the engine. THIS IS IN THE
    // SPEC FOR DrvDitherBrush () function.
    //

    pDevInfo->cxDither = 0;
    pDevInfo->cyDither = 0;

    //
    // the following line is set by PH. According to PH, we need
    // to have 16 colors. We cannot only have 9 colors (for pen plotter).
    //
    //
    // 01-Dec-1993 Wed 01:31:16 updated  
    //  The reason that engine need 16 colors is it optimized by using bit 3
    //  as duplicate bit (used only bit 0/1/2) and bit 3 always mask off, so
    //  that engine can do faster comparsion
    //

    //
    // If its a raster device, tell the engine that we are a 24 bit color
    // device. This way we get the max resolution for bitmaps and brushes
    // and can reducedown as required.
    //

    if (IS_RASTER(pPDev)) {

        pDevInfo->iDitherFormat = BMF_24BPP;

    } else {

        pDevInfo->iDitherFormat = BMF_4BPP;
    }

    if (pPDev->hPalDefault) {

        EngDeletePalette(pPDev->hPalDefault);
        pPDev->hPalDefault = NULL;
    }

    //
    // Create the Pen palette based only on the total number of pens the
    // device can handle.
    //

    if (IS_RASTER(pPDev)) {

        //
        // This is a raster device, we will always make it a 24-bit device so
        // the engine will pass back max color info and we can dither/halftone
        // as we see fit. If we don't do this, the Engine will reduce bitmaps
        // to our color space before passing the bitmaps onto us.
        //

        if (!(pDevInfo->hpalDefault =
                                EngCreatePalette(PAL_BGR, 0, 0, 0, 0, 0))) {

            //
            // The create failed so raise an error
            //

            PLOTERR(("FillDevInfo: EngCreatePalette(PAL_BGR) failed."));
            return(FALSE);
        }

    } else {

        DWORD       DevColor[MAX_PENPLOTTER_PENS + 2];
        PDWORD      pdwCur;
        PPENDATA    pPenData;
        PALENTRY    PalEntry;
        UINT        cPens;

        extern PALENTRY PlotPenPal[];


        PLOTASSERT(1, "Too many pens defined for pen plotter (%ld)",
                      (pPDev->pPlotGPC->Pens.Count <= MAX_PENPLOTTER_PENS),
                      pPDev->pPlotGPC->Pens.Count);

        if (pPDev->pPlotGPC->Pens.Count > MAX_PENPLOTTER_PENS)
        {
            return(FALSE);
        }

        //
        // Get the start of where to fill colors
        //

        pdwCur = &DevColor[0];

        //
        // 1st Entry is always WHITE
        //

        *pdwCur++ = RGB(255, 255, 255);

        //
        //  Now go into a loop loading up the rest of the colors
        //

        PLOTDBG(DBG_PENPAL, ("Pen Palette #%02ld = 255:255:255", 0));

        for (cPens = 1, pPenData = (PPENDATA)pPDev->pPlotGPC->Pens.pData;
             cPens <= (UINT)pPDev->pPlotGPC->Pens.Count;
             pPenData++) {

            //
            // Place the RGB value into the palette
            //

            PalEntry  = PlotPenPal[pPenData->ColorIdx];
            *pdwCur++ = RGB(PalEntry.R, PalEntry.G, PalEntry.B);

            PLOTDBG(DBG_PENPAL, ("Pen Palette #%02ld = %03ld:%03ld:%03ld",
                        cPens,
                        (LONG)PalEntry.R, (LONG)PalEntry.G, (LONG)PalEntry.B));

            //
            // Track total number of pens defined
            //

            ++cPens;
        }

        //
        // Last Pen is BRIGHT YELLOW WHITE, this is done so that a non-white
        // will map to this pen, in order to effect painting on the device.
        // Otherwise, if a non-white pen, gets mapped to white, nothing
        // would get rendered on the surface.
        //

        *pdwCur++ = RGB(255, 255, 254);
        cPens++;

        PLOTDBG(DBG_PENPAL, ("Pen Palette #%02ld = 255:255:254", cPens - 1));

        //
        // Now create the engine palette
        //

        if (!(pDevInfo->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                                       cPens,
                                                       DevColor,
                                                       0,
                                                       0,
                                                       0))) {
            //
            // The create failed so raise an error
            //

            PLOTERR(("FillDevInfo: EngCreatePalette(PAL_INDEXED=%ld) failed.",
                                                                        cPens));
            return(FALSE);
        }
    }

    //
    // Save the created palette / later we need to destroy it.
    //

    pPDev->hPalDefault = pDevInfo->hpalDefault;

    return(TRUE);
}




BOOL
CommonStartPDEV(
    PDEV        *pPDev,
    DEVMODEW    *pPlotDMIn,
    ULONG       cPatterns,
    HSURF       *phsurfPatterns,
    ULONG       cjDevCaps,
    ULONG       *pDevCaps,
    ULONG       cjDevInfo,
    DEVINFO     *pDevInfo
    )

/*++

Routine Description:

    Function to perform the PDEV initialization.  This is common to
    DrvEnablePDEV and DrvResetPDEV.  The individual functions
    do whatever is required before calling into here.

Arguments:

    pPDev           - the pPDev which we returned in DrvEnablePDEV

    pPlotDMIn       - Pointer to the DEVMODE data structure

    cPatterns       - Count of patterns to be set in phsurfPatterns

    phsurfPatterns  - pointer to the standard pattern HSURF array

    cjDevCaps       - total size of pDevCaps pointed to.

    pDevCaps        - pointer to the device cap DWORDs

    cjDevInfo       - total size of pDevInfo pointed to

    pDevInfo        - pointer to the DEVINFO data structure


Return Value:

    BOOLEAN


Author:

    23-Nov-1993 Tue 20:13:10 created  
        Re-write

    05-Jan-1994 Wed 23:34:18 updated  
        Make PlotXDPI for the Pen Plotter rather than PLOTTER_UNITS_DPI

    06-Jan-1994 Thu 13:10:11 updated  
        Change RasterDPI always be the resoluton reports back to the engine

Revision History:


--*/

{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    DWORD   dmErrBits;


    //
    // Validate the DEVMODE structure passed in by the user, If OK, set the
    // appropriate fields in the PDEV, the validateSetPlotDM() will always
    // return a valid PLOTDEVMODE so we just use it. Any valid DM info will
    // merged into the final DEVMODE
    //

    if (dmErrBits = ValidateSetPLOTDM(pPDev->hPrinter,
                                      pPDev->pPlotGPC,
                                      pPDev->PlotDM.dm.dmDeviceName,
                                      (PPLOTDEVMODE)pPlotDMIn,
                                      &(pPDev->PlotDM),
                                      &(pPDev->CurForm))) {

        PLOTWARN(("CommonStartPDEV: ValidateSetPLOTDM() ErrBits=%08lx",
                                                            dmErrBits));
    }

    //
    // fill in our PDEV structure...
    //
    // The RasterDPI will be used for raster printer resolution, for pen
    // plotters this is the GPC's ideal resolution.
    //

    pPDev->lCurResolution = (LONG)pPDev->pPlotGPC->RasterXDPI;

    PLOTDBG(DBG_GDICAPS, ("CURRENT Resolution = %ld", pPDev->lCurResolution));

    SetPlotForm(&(pPDev->PlotForm),
                pPDev->pPlotGPC,
                &(pPDev->CurPaper),
                &(pPDev->CurForm),
                &(pPDev->PlotDM),
                &(pPDev->PPData));

    //
    // fill in the device capabilities in GDIINFO data structure for the engine
    //

    if ((cjDevCaps) && (pDevCaps)) {

        FillDeviceCaps(pPDev, &GdiInfo);
        CopyMemory(pDevCaps, &GdiInfo, min(cjDevCaps, sizeof(GDIINFO)));
    }

    //
    // Fill in DevInfo data structrue
    //

    if ((cjDevInfo) && (pDevInfo)) {

        if (!FillDevInfo(pPDev, &DevInfo)) {

            return(FALSE);
        }

        CopyMemory(pDevInfo, &DevInfo, min(cjDevInfo, sizeof(DEVINFO)));
    }

    //
    // Set it to NULL so that the engine can create halftone one for us
    //

    if ((cPatterns) && (phsurfPatterns)) {

        ZeroMemory(phsurfPatterns, sizeof(HSURF) * cPatterns);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\escape.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    escape.h


Abstract:

    This module contains prototype and #defines for escape.c


Author:

    18-Nov-1993 Thu 04:49:28 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTESCAPE_
#define _PLOTESCAPE_


BOOL
DrvStartPage(
    SURFOBJ *pso
    );



#endif  // _PLOTESCAPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\htblt.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    htblt.c


Abstract:

    This module contains all halftone bitblt functions.



Development History:

    26-Mar-1992 Thu 23:54:07 updated 
        1) add the prclBound parameter to the bDoClipObj()
        2) Remove 'pco' parameter and replaced it with prclClipBound parameter,
           since pco is never referenced, prclClipBound is used for the
           halftone.
        3) Add another parameter to do NOTSRCCOPY

    11-Feb-1993 Thu 21:32:07 updated  
        Major re-write to have DrvStretchBlt(), DrvCopyBits) do the right
        things.

    15-Nov-1993 Mon 19:28:03 updated  
        clean up/debugging information

    06-Dec-1993 Mon 19:28:03 updated  
        Made all bitblt go through HandleComplexBitmap.

    18-Dec-1993 Sat 08:52:56 updated  
        Move halftone related stuff to htblt.c

    18-Mar-1994 Fri 14:00:14 updated 
        Adding PLOTF_RTL_NO_DPI_XY, PLOTF_RTLMONO_NO_CID and
        PLOTF_RTLMONO_FIXPAL flags


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgHTBlt

#define DBG_HTBLT           0x00000001
#define DBG_ISHTBITS        0x00000002
#define DBG_HTXB            0x00000004
#define DBG_OUTHTBMP        0x00000008
#define DBG_HTBLT_SKIP      0x00000010
#define DBG_TILEBLT         0x00000020
#define DBG_CREATESURFOBJ   0x00000040
#define DBG_BMPDELTA        0x00000080
#define DBG_CLONESURFOBJ    0x00000100
#define DBG_CLONEMASK       0x00000200
#define DBG_HTBLT_CLR       0x00000400

DEFINE_DBGVAR(0);


//
// This is the local structure used in this module only
//

#define SEND_PLOTCMDS(pPDev,pcmd)   OutputBytes(pPDev,(pcmd)+1,(LONG)*(pcmd))
#define COPY_PLOTCMDS(cmd,ps,s)     if (sizeof(cmd) > cmd[0]+s){CopyMemory(&cmd[cmd[0]+1],ps,s); cmd[0]+=s;}
#define INIT_PLOTCMDS(cmd)          cmd[0]=0
#define CHECK_PLOTCMDS(cmd)                                             \
{                                                                       \
    cmd[cmd[0]+1]=0; PLOTASSERT(1,"Command buffer MUST > %ld bytes",    \
    cmd[0]<sizeof(cmd),sizeof(cmd));                                    \
}

#define DELETE_SURFOBJ(pso, phBmp)                                      \
{                                                                       \
    if (pso)      { EngUnlockSurface(pso); pso=NULL;                  } \
    if (*(phBmp)) { EngDeleteSurface((HSURF)*(phBmp)); *(phBmp)=NULL; } \
}


typedef struct _RTLCLRCONFIG {
    BYTE    ColorModel;
    BYTE    EncodingMode;
    BYTE    BitsPerIndex;
    BYTE    BitsPerR;
    BYTE    BitsPerG;
    BYTE    BitsPerB;
    } RTLCLRCONFIG, FAR *PRTLCLRCONFIG;


const POINTL ptlZeroOrigin = {0,0};

static const OUTHTBMPFUNC HTBmpFuncTable[] = { Output1bppHTBmp,
                                               Output1bppRotateHTBmp,
                                               Output4bppHTBmp,
                                               Output4bppRotateHTBmp };



#if DBG
static const LPSTR pszHTBmpFunc[] = { "Output1bppHTBmp",
                                      "Output1bppRotateHTBmp",
                                      "Output4bppHTBmp",
                                      "Output4bppRotateHTBmp" };
#endif

#define DEF_MONOPALIDX_0        0xFFFFFF
#define DEF_MONOPALIDX_1        0x000000
#define DEVTODECI(pPdev, x)     DIVRNDUP((x) * 720, (pPDev)->lCurResolution)
#define MAX_HP_Y_MOVE           32767


static BYTE     StartGraf[]  = "\033*r#ds1A";
static BYTE     EndGraf[]    = "\033*rC";
static BYTE     XMoveDECI[]  = "\033&a0h#dH";
static BYTE     YMoveDECI[]  = "\033*b#dY";
static BYTE     YMoveDPI[]   = "\033*p#pY";
static BYTE     XYMoveDPI[]  = "\033*p#px#pY";
static BYTE     SetRGBCmd[]  = "\033*v#da#db#dc#dI";
static DWORD    DefWKPal[]   = { 0x00FFFFFF, 0x00000000 };


//
// ROP2 used for devices that require  BYTE ALIGNMENT of RTL data
//

#define HPBHF_nD_LAST       0x01
#define HPBHF_nS            0x02
#define HPBHF_1_FIRST       0x40
#define HPBHF_PAD_1         0x80

typedef struct  _HPBAHACK {
    BYTE    Rop3RTL;
    BYTE    Flags;
    } HPBAHACK, *PHPBAHACK;

//
// 0x00: 0          [INV] 0xff: 1
// 0x55: ~D         [INV] 0xaa: D
// 0x33: ~S         [INV] 0xcc: S
// 0x11: ~(D | S)   [INV] 0xee: D | S
// 0x22: D & ~S     [INV] 0xdd: S | ~D
// 0x44: S & ~D     [INV] 0xbb: D | ~S
// 0x66: D ^ S      [INV] 0x99: ~(D ^ S)
// 0x77: ~(D & S)   [INV] 0x88: D & S
//
//
// 1. HPBHF_PAD_1   - TRUE if we are not doing AND operation
// 2. HPBHF_nS      - If we have to manually flip the source
// 3. HPBHF_nD_LAST - If we have to invert the source in HPGL2 afterward
//
//
// Rop2 0x00, 0x05, 0x0A and 0x0F should not come to OutputHTBitmap
//

//
// This table tells us how to simulate certain ROPS by combining rops that
// the target device is known to support. Some times we end up having to
// send the bitmap more than once, but it does end up coming out correctly.
//
static HPBAHACK HPBAHack[] = {

    { 0xAA, 0                                                      }, // 0       0x00
    { 0xEE,                 HPBHF_PAD_1 |            HPBHF_nD_LAST }, // SoD_n   0x01
    { 0x88,                               HPBHF_nS                 }, // nS_aD   0x02
    { 0xEE, HPBHF_1_FIRST | HPBHF_PAD_1 | HPBHF_nS                 }, // nS      0x03
    { 0xEE,                 HPBHF_PAD_1 | HPBHF_nS | HPBHF_nD_LAST }, // nS_oD_n 0x04
    { 0xAA,                                          HPBHF_nD_LAST }, // nD      0x05
    { 0x66,                 HPBHF_PAD_1                            }, // SxD     0x06
    { 0x88,                                          HPBHF_nD_LAST }, // SaD_n   0x07
    { 0x88,                                                        }, // SaD     0x08
    { 0x66,                 HPBHF_PAD_1 |            HPBHF_nD_LAST }, // SxD_n   0x09
    { 0xAA,                 0                                      }, // D       0x0A
    { 0xEE,                 HPBHF_PAD_1 | HPBHF_nS                 }, // nS_oD   0x0B
    { 0xEE, HPBHF_1_FIRST | HPBHF_PAD_1                            }, // S       0x0C
    { 0x88,                               HPBHF_nS | HPBHF_nD_LAST }, // nS_aD_n 0x0D
    { 0xEE,                 HPBHF_PAD_1                            }, // SoD     0x0E
    { 0xAA, 0                                                      }  // 1       0x0F
};


//
// To make it print correctly in poster mode for the BYTE ALIGNED plotters
// we assume paper is white and do a SRC AND DST
//

#define ROP3_BYTEALIGN_POSTER   0x88



extern PALENTRY HTPal[];






BOOL
IsHTCompatibleSurfObj(
    PPDEV       pPDev,
    SURFOBJ     *pso,
    XLATEOBJ    *pxlo,
    DWORD       Flags
    )
/*++

Routine Description:

    This function determines if the surface object is compatible with the
    plotter halftone output format.

Arguments:

    pPDev       - Pointer to the PPDEV data structure to determine what
                  type of postscript output for current device

    pso         - engine SURFOBJ to be examine

    pxlo        - engine XLATEOBJ for source -> postscript translation

    Flags       - specified ISHTF_xxxx

Return Value:

    BOOLEAN true if the pso is compatible with halftone output format, if
    return value is true, the pDrvHTInfo->pHTXB is a valid traslation from
    indices to 3 planes


Development History:

    11-Feb-1993 Thu 18:49:55 created  

    16-Mar-1994 Wed 14:24:04 updated  
        Change it so if pxlo is NULL then the xlate will be match the pso
        format


Revision History:


--*/

{
    LPPALETTEENTRY  pPal;
    PDRVHTINFO      pDrvHTInfo;
    PALETTEENTRY    SrcPal[18];
    PPALENTRY       pPalEntry;
    HTXB            PalNibble[HTPAL_XLATE_COUNT];
    ULONG           HTPalXor;
    UINT            i;
    HTXB            htXB;
    BOOL            GenHTXB = FALSE;
    BOOL            RetVal;
    BYTE            PalXlate[HTPAL_XLATE_COUNT];
    UINT            AltFmt;
    UINT            BmpFormat;
    UINT            cPal;


    if (!(pDrvHTInfo = (PDRVHTINFO)(pPDev->pvDrvHTData))) {

        PLOTERR(("IsHTCompatibleSurfObj: pDrvHTInfo = NULL?"));
        return(FALSE);
    }

    PLOTDBG(DBG_ISHTBITS, ("IsHTCompatibleSurfObj: Type=%ld, BMF=%ld",
                                (DWORD)pso->iType, (DWORD)pso->iBitmapFormat));

    //
    // Make sure these fields' value are valid before the translation is
    // created:
    //
    //  1. pso->iBitmapFormat is one of 1BPP or 4BPP depending on current
    //     PLOT's surface
    //  2. pxlo is non null
    //  3. pxlo->fXlate is XO_TABLE
    //  4. pxlo->cPal is less than or equal to the halftone palette count
    //  5. pxlo->pulXlate is valid
    //  6. source color table is within the range of the halftone palette
    //
    //  If your device uses an indexed palette then you must call
    //  XLATEOBJ_cGetPalette() to get the source palette and make sure that the
    //  count returned is within your device's range, if we are a 24-bit device
    //  then you can just get the source palette our from pxlo->pulxlate which
    //  has the entire source palette for the bitmap
    //

    RetVal = FALSE;
    AltFmt = (UINT)((Flags & ISHTF_ALTFMT) ? pDrvHTInfo->AltBmpFormat : 0xFFFF);

    if ((pso->iType == STYPE_BITMAP)                        &&
        (BmpFormat = (UINT)pso->iBitmapFormat)              &&
        ((BmpFormat == (UINT)pDrvHTInfo->HTBmpFormat)   ||
         (BmpFormat == AltFmt))) {

        HTPalXor             = pDrvHTInfo->HTPalXor;
        pDrvHTInfo->HTPalXor = HTPALXOR_SRCCOPY;

        if (pxlo) {

            if (BmpFormat == BMF_4BPP) {

                i = (UINT)((Flags & ISHTF_HTXB) ? 8 : 16);

            } else {

                i = 2;
            }

            cPal = XLATEOBJ_cGetPalette(pxlo,
                                        XO_SRCPALETTE,
                                        sizeof(SrcPal) / sizeof(PALETTEENTRY),
                                        (ULONG *)SrcPal);

            PLOTDBG(DBG_ISHTBITS, ("pxlo: flXlate=%08lx, SrcType=%ld, DstType=%ld, cPal=%ld",
                    (DWORD)pxlo->flXlate,
                    (DWORD)pxlo->iSrcType,
                    (DWORD)pxlo->iDstType, cPal));

            if ((cPal) && (cPal <= i)) {

                PLOTDBG(DBG_ISHTBITS,
                        ("IsHTCompatibleSurfObj: HTPalXor=%08lx", HTPalXor));

                RetVal = TRUE;

                for (i = 0, pPal = SrcPal; i < cPal && i < sizeof(PalXlate); i++, pPal++ ) {

                    HTXB_R(htXB)  = pPal->peRed;
                    HTXB_G(htXB)  = pPal->peGreen;
                    HTXB_B(htXB)  = pPal->peBlue;
                    htXB.dw      ^= HTPalXor;

                    if (((HTXB_R(htXB) != PAL_MAX_I) &&
                         (HTXB_R(htXB) != PAL_MIN_I))   ||
                        ((HTXB_G(htXB) != PAL_MAX_I) &&
                         (HTXB_G(htXB) != PAL_MIN_I))   ||
                        ((HTXB_B(htXB) != PAL_MAX_I) &&
                         (HTXB_B(htXB) != PAL_MIN_I))) {

                        PLOTDBG(DBG_ISHTBITS,
                                ("SrcPal has NON 0xff/0x00 intensity, NOT HTPalette"));
                        return(FALSE);
                    }

                    PalXlate[i]  =
                    HTXB_I(htXB) = (BYTE)((HTXB_R(htXB) & 0x01) |
                                          (HTXB_G(htXB) & 0x02) |
                                          (HTXB_B(htXB) & 0x04));
                    PalNibble[i] = htXB;

                    if (pDrvHTInfo->PalXlate[i] != HTXB_I(htXB)) {

                        GenHTXB = TRUE;
                    }

                    PLOTDBG(DBG_HTXB,
                            ("%d - %02x:%02x:%02x, Idx=%d, PalXlate=%d",
                            i,
                            (BYTE)HTXB_R(htXB),
                            (BYTE)HTXB_G(htXB),
                            (BYTE)HTXB_B(htXB),
                            (INT)PalXlate[i],
                            (INT)pDrvHTInfo->PalXlate[i]));
                }

                if (BmpFormat == (UINT)BMF_1BPP) {

                    //
                    // For 1 BPP, if the DSTPRIM_OK is set and the destination
                    // is 4BPP then we will deem the surfaces compatible
                    //

                    if ((Flags & ISHTF_DSTPRIM_OK)      &&
                        ((pDrvHTInfo->HTBmpFormat == BMF_4BPP)   ||
                         (AltFmt == BMF_4BPP))) {

                        NULL;

                    } else if (((PalXlate[0] != 0) && (PalXlate[0] != 7)) ||
                               ((PalXlate[1] != 0) && (PalXlate[1] != 7))) {

                        RetVal = FALSE;
                        PLOTDBG(DBG_HTXB, ("NON-BLACK/WHITE MONO BITMAP, NOT HTPalette"));
                    }
                }
            }

        } else {

            //
            // If the pxlo is NULL and the FORMAT is the same, we assume an
            // identity translation. Otherwise we fail.
            //

            PLOTDBG(DBG_HTXB, ("pxlo=NULL, Xlate to same as BmpFormat=%ld",
                                                            (DWORD)BmpFormat));

            RetVal = TRUE;

            if (BmpFormat == BMF_4BPP) {

                cPal      = 8;
                pPalEntry = HTPal;

            } else {

                cPal      = 2;
                pPalEntry = (PPALENTRY)SrcPal;

                CopyMemory(pPalEntry + 0, &HTPal[0], sizeof(PALENTRY));
                CopyMemory(pPalEntry + 1, &HTPal[7], sizeof(PALENTRY));
            }

            for (i = 0; i < cPal; i++, pPalEntry++) {

                HTXB_R(htXB)  = pPalEntry->R;
                HTXB_G(htXB)  = pPalEntry->G;
                HTXB_B(htXB)  = pPalEntry->B;
                htXB.dw      ^= HTPalXor;
                PalXlate[i]   =
                HTXB_I(htXB)  = (BYTE)((HTXB_R(htXB) & 0x01) |
                                       (HTXB_G(htXB) & 0x02) |
                                       (HTXB_B(htXB) & 0x04));
                PalNibble[i]  = htXB;

                if (pDrvHTInfo->PalXlate[i] != HTXB_I(htXB)) {

                    GenHTXB = TRUE;
                }
            }
        }

        if (!RetVal) {

            PLOTDBG(DBG_HTXB, ("**** IsHTCompatibleSurfObj = NO ****"));
            return(FALSE);
        }

        if ((Flags & ISHTF_HTXB) && (GenHTXB)) {

            //
            // Copy down the pal xlate
            //

            PLOTDBG(DBG_HTXB, (" --- Copy XLATE TABLE ---"));

            CopyMemory(pDrvHTInfo->PalXlate, PalXlate, sizeof(PalXlate));

            //
            // We only really generate 4bpp to 3 planes if the destination
            // format is BMF_4BPP
            //

            if (BmpFormat == (UINT)BMF_1BPP) {

                pDrvHTInfo->RTLPal[0].Pal = HTPal[PalXlate[0]];
                pDrvHTInfo->RTLPal[1].Pal = HTPal[PalXlate[1]];

                PLOTDBG(DBG_HTXB, ("IsHTCompatibleSurfObj: MONO 1BPP: 0=%02lx:%02lx:%02lx, 1=%02lx:%02lx:%02lx",
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.R,
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.G,
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.B,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.R,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.G,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.B));

            } else if (BmpFormat == (UINT)BMF_4BPP) {

                PHTXB   pTmpHTXB;
                UINT    h;
                UINT    l;
                DWORD   HighNibble;


                PLOTDBG(DBG_HTXB, ("--- Generate 4bpp --> 3 planes xlate ---"));

                if (!(pDrvHTInfo->pHTXB)) {

                    PLOTDBG(DBG_HTXB, ("IsHTCompatibleSurfObj: Allocate pHTXB=%ld",
                                                            HTXB_TABLE_SIZE));

                    if (!(pDrvHTInfo->pHTXB =
                                (PHTXB)LocalAlloc(LPTR, HTXB_TABLE_SIZE))) {

                        PLOTERR(("IsHTCompatibleSurfObj: LocalAlloc(HTXB_TABLE_SIZE) failed"));
                        return(FALSE);
                    }
                }

                pDrvHTInfo->RTLPal[0].Pal = HTPal[0];
                pDrvHTInfo->RTLPal[1].Pal = HTPal[1];

                PLOTDBG(DBG_HTXB, ("IsHTCompatibleSurfObj: COLOR 4BPP: 0=%02lx:%02lx:%02lx, 1=%02lx:%02lx:%02lx",
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.R,
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.G,
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.B,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.R,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.G,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.B));

                //
                // Generate 4bpp to 3 planes xlate table
                //

                for (h = 0, pTmpHTXB = pDrvHTInfo->pHTXB;
                     h < HTXB_H_NIBBLE_MAX;
                     h++, pTmpHTXB += HTXB_L_NIBBLE_DUP) {

                    HighNibble = (DWORD)(PalNibble[h].dw & 0xaaaaaaaaL);

                    for (l = 0; l < HTXB_L_NIBBLE_MAX; l++, pTmpHTXB++) {

                        pTmpHTXB->dw = (DWORD)((HighNibble) |
                                               (PalNibble[l].dw & 0x55555555L));
                    }

                    //
                    // Duplicate low nibble high order bit, 8 of them
                    //

                    CopyMemory(pTmpHTXB,
                               pTmpHTXB - HTXB_L_NIBBLE_MAX,
                               sizeof(HTXB) * HTXB_L_NIBBLE_DUP);
                }

                //
                // Copy high nibble duplication, 128 of them
                //

                CopyMemory(pTmpHTXB,
                           pDrvHTInfo->pHTXB,
                           sizeof(HTXB) * HTXB_H_NIBBLE_DUP);
            }
        }
    }

    PLOTDBG(DBG_HTXB, ("*** IsHTCompatibleSurfObj = %hs ***", (RetVal) ? "TRUE" : "FALSE"));

    return(RetVal);
}




DWORD
ExitToHPGL2Mode(
    PPDEV   pPDev,
    LPBYTE  pHPGL2ModeCmds,
    LPDWORD pOHTFlags,
    DWORD   OHTFlags
    )

/*++

Routine Description:

    This function will exit to HPGL2 Mode


Arguments:

    pPDev           - Pointer to the PDEV

    pHTGL2ModeCmds  - Pointer to our internal command to switch to HPGL2

    OHTFlags        - Current OHTFlags

Return Value:

    New OHTFlags



Development History:

    10-Feb-1994 Thu 12:51:14 created 


Revision History:


--*/

{
    if (OHTFlags & OHTF_IN_RTLMODE) {

        if (OHTFlags & OHTF_SET_TR1) {

            //
            // Send STM command here
            //

            OutputString(pPDev, "\033*v1N");
        }

        SEND_PLOTCMDS(pPDev, pHPGL2ModeCmds);

        OHTFlags &= ~OHTF_IN_RTLMODE;

        PLOTDBG(DBG_HTBLT, ("*** BackTo HPGL/2: %ld=[%hs]",
                                (DWORD)*pHPGL2ModeCmds, pHPGL2ModeCmds + 1));
    }

    //
    // If we need to clear clip window do it now
    //

    if (OHTFlags & OHTF_CLIPWINDOW) {

        ClearClipWindow(pPDev);

        OHTFlags &= ~OHTF_CLIPWINDOW;

        PLOTDBG(DBG_HTBLT, ("OutputHTBitmap: ClearClipWindow"));
    }

    if (OHTFlags & OHTF_SET_TR1) {

        OutputString(pPDev, "TR0;");
    }

    OHTFlags = 0;

    if (pOHTFlags) {

        *pOHTFlags = OHTFlags;
    }

    return(OHTFlags);
}




VOID
MoveRelativeY(
    PPDEV   pPDev,
    LONG    Y
    )

/*++

Routine Description:

    Move relative Y positiion by batch for devices that have y coordinate
    move limitations.

Arguments:

    pPDev   - Pointer to our PDEV

    Y       - Relative amount to move

Return Value:

    VOID



Development History:

    13-Apr-1994 Wed 14:38:18 created  


Revision History:


--*/

{
    LPSTR   pMove;
    LONG    SendY;
    BOOL    Negative;


    pMove = (LPSTR)(RTL_NO_DPI_XY(pPDev) ? YMoveDECI : YMoveDPI);

    if (Negative = (Y < 0)) {

        Y = -Y;
    }

    while (Y) {

        if ((SendY = Y) > MAX_HP_Y_MOVE) {

            SendY = MAX_HP_Y_MOVE;
        }

        OutputFormatStr(pPDev, pMove, (Negative) ? -SendY : SendY);

        Y -= SendY;
    }
}





BOOL
OutputHTBitmap(
    PPDEV   pPDev,
    SURFOBJ *psoHT,
    CLIPOBJ *pco,
    PPOINTL pptlDest,
    PRECTL  prclSrc,
    DWORD   Rop3,
    LPDWORD pOHTFlags
    )
/*++

Routine Description:

    This function will handle complex type of region bitmaps

Arguments:

    pPDev       - Pointer to the PDEV

    psoHI       - the surface object of the halftone bitmap to be output

    pco         - a clip object associated with psoHT

    pptlDest    - pointer to the starting destination point

    prclSrc     - pointer to the source bitmap rectangle area to be copied
                  to the destination, if this is NULL then a whole psoHT will
                  be copied to the destination

    Rop3        - a Rop3 to send for the source

    pOHTFlags   - Pointer to the DWORD containing the current OHTF_xxxx, if this
                  pointer is NULL then this function will enter RTL mode first
                  and exit to HPGL2 mode when it returns,  if this pointer is
                  specified then the pOHTFlags will be used and at return the
                  current OHTFlags will be written to the location pointed to
                  by pOHTFlags




Return Value:

    TRUE if sucessful, FALSE if failure



Development History:

    04-Nov-1993 Thu 15:30:13 updated  

    24-Dec-1993 Fri 05:21:57 updated  
        Total re-write so that take all the bitmap orientations and enum
        rects works correctly. this is the major bitmap function entry point
        it will call appropriate bitmap function to redner the final output.

        The other things is we need to check if switch between HPGL/2 and RTL
        can be more efficient.   Make sure we can eaiser to adapate to rotate
        the bitmap to the left if necessary.

        Correct LogExt.cx useage, we must do SPLTOENGUNITS first

    29-Dec-1993 Wed 10:59:41 updated  
        Change bMore=CLIPOBJ_bEnum sequence,
        Change PLOTDBGBLK() macro by adding automatical semi in macro

    13-Jan-1994 Thu 14:09:51 updated  
        add prclSrc

    14-Jan-1994 Fri 21:03:26 updated  
        add Rop3


    16-Jan-1994 Thu 14:09:51 updated  
        Change OutputHTBitmap to take Rop4 to send to plotter.

    08-Feb-1994 Tue 15:54:24 updated  
        Make sure we do nothing if source is not visible

    21-Mar-1994 Mon 14:20:18 updated 
        Allocate extra 2 bytes for the scan/rot buffer in case if we must do
        byte aligned.  And if we need to do byte aligned thing then always
        move the HCAPS to the byte boundary first

    13-Apr-1994 Wed 14:59:56 updated  
        1. Batch the Relative Y move to have 32767 limitation problem solved.
        2. GrayScale/gamma correct the input BITMAP color

    20-Aug-1994 Sat 21:37:37 updated  
        Add the bitmap offset location from the FORM imageable area, otherwise
        our bitmap will have different offset then the HPGL/2 drawing commands

Revision History:

    22-Oct-1999 Fri 12:17:21 updated  
        Return FALSE right away if a job canceled, since this function can
        take very long time to finished.


--*/

{
#define pDrvHTInfo  ((PDRVHTINFO)pPDev->pvDrvHTData)


    PRECTL          prcl;
    OUTHTBMPFUNC    HTBmpFunc;
    HTBMPINFO       HTBmpInfo;
    HTENUMRCL       HTEnumRCL;
    RTLCLRCONFIG    RTLClrConfig;
    RECTL           rclSrc;
    RECTL           rclDest;
    POINTL          CursorPos;
    POINTL          BmpOffset;
    SIZEL           Size;
    HPBAHACK        CurHPBAHack;
    LONG            cxLogExt;
    LONG            TempY;
    DWORD           OHTFlags;
    DWORD           PlotFlags;
    BOOL            More;
    BOOL            RetVal;
    BOOL            BmpRotate;
    BOOL            FirstEnumRCL = TRUE;
    UINT            i;
    BYTE            HPGL2ModeCmds[16];
    BYTE            RTLModeCmds[32];



    if (PLOT_CANCEL_JOB(pPDev)) {

        return(FALSE);
    }

    PlotFlags = GET_PLOTFLAGS(pPDev);
    OHTFlags  = (DWORD)((pOHTFlags) ? (*pOHTFlags & OHTF_MASK) : 0);

    //
    // Set up exit HPGL/2 and enter RTL mode commands
    //

    INIT_PLOTCMDS(HPGL2ModeCmds);

    if (PF_PUSHPAL(PlotFlags)) {

        COPY_PLOTCMDS(HPGL2ModeCmds, "\033*p1P", 5);
    }

    COPY_PLOTCMDS(HPGL2ModeCmds, "\033%0B", 4);
    CHECK_PLOTCMDS(HPGL2ModeCmds);

    if (OHTFlags & OHTF_EXIT_TO_HPGL2) {

        PLOTDBG(DBG_HTBLT, ("OutputHTBitmap: Force Exit to HPGL2 Mode"));

        ExitToHPGL2Mode(pPDev, HPGL2ModeCmds, pOHTFlags, OHTFlags);
        return(TRUE);
    }

    //
    // Make sure the caller is right about this,
    // so check to see which formats we can handle.
    //

    PLOTASSERT(1, "OutputHTBitmap: Invalid Bitmap Format %ld passed",
                (psoHT->iBitmapFormat ==
                            pDrvHTInfo->HTBmpFormat) ||
                (psoHT->iBitmapFormat ==
                            pDrvHTInfo->AltBmpFormat),
                psoHT->iBitmapFormat);

    //
    // First set some basic information in HTBmpInfo
    //

    HTBmpInfo.pPDev = pPDev;
    HTBmpInfo.Flags = 0;
    HTBmpInfo.Delta = psoHT->lDelta;

    //
    // We will set color format for the HPGL/2 Plotter to the same one as
    // the bitmap format passed, this will allow us to use the 1bpp output
    // function for the 4bpp surfaces
    //

    RTLClrConfig.ColorModel   = 0;
    RTLClrConfig.EncodingMode = 0;

    //
    // cxLogExt = the output bitmap function index number
    // Size.cx  = Count of mono scan lines needed for each pixel line, and
    //            final count of scan buffer needed
    // Size.cy  = count of rotation buffer needed (Must be DWORD aligned)
    //

    if (psoHT->iBitmapFormat == BMF_1BPP) {

        cxLogExt                  = 0;
        Size.cx                   = 1;
        RTLClrConfig.BitsPerIndex = 1;

    } else {

        //
        // 4 bits per pel, 3 planes that is
        //

        cxLogExt                  = 2;
        Size.cx                   = 3;
        RTLClrConfig.BitsPerIndex = 3;
    }

    RTLClrConfig.BitsPerR =
    RTLClrConfig.BitsPerG =
    RTLClrConfig.BitsPerB = 8;

    //
    // We have almost everything setup, now check how to send to the output
    // bitmap function, get the full destination size first
    //
    //
    //************************************************************************
    // The Following RTL switching, config color command and other related
    // commands MUST be sent in this order
    //************************************************************************"

    //
    // 1: Initialize the enter RTL command buffer
    //

    INIT_PLOTCMDS(RTLModeCmds);

    //
    // 2. commands to go into RTL mode, and back to HPGL/2 mode, the mode
    //    switching assumes that the current positions are retained.
    //

    COPY_PLOTCMDS(RTLModeCmds, "\033%0A", 4);

    //
    // 3. Push/Pop the HPGL/2 palette commands if this is required (PCD file)
    //

    if (PF_PUSHPAL(PlotFlags)) {

        COPY_PLOTCMDS(RTLModeCmds, "\033*p0P", 5);
    }

    //
    // 4. Color configuration commands and exit back to HPGL/2 command
    //

    if ((RTLClrConfig.BitsPerIndex != 1) ||
        (!PF_RTLMONO_NO_CID(PlotFlags))) {

        //
        // We only do this if we are COLOR or if we must send CID when mono
        // device
        //

        COPY_PLOTCMDS(RTLModeCmds, "\033*v6W", 5);
        COPY_PLOTCMDS(RTLModeCmds, &RTLClrConfig, 6);
    }


    CHECK_PLOTCMDS(RTLModeCmds);

    //
    // Now Check the source
    //

    rclSrc.left   =
    rclSrc.top    = 0;
    rclSrc.right  = psoHT->sizlBitmap.cx;
    rclSrc.bottom = psoHT->sizlBitmap.cy;

    if (prclSrc) {

        PLOTASSERT(1, "OutputHTBitmap: Invalid prclSrc [%08lx] passed",
                ((prclSrc->left   >= 0)                         &&
                 (prclSrc->top    >= 0)                         &&
                 (prclSrc->right  <= psoHT->sizlBitmap.cx)      &&
                 (prclSrc->bottom <= psoHT->sizlBitmap.cy)      &&
                 (prclSrc->left   <= prclSrc->right)            &&
                 (prclSrc->top    <= prclSrc->bottom)), prclSrc);

        if (!IntersectRECTL(&rclSrc, prclSrc)) {

            PLOTWARN(("OutputHTBitmap: EMPTY SRC Passed, Done!"));
            ExitToHPGL2Mode(pPDev, HPGL2ModeCmds, pOHTFlags, OHTFlags);
            return(TRUE);
        }
    }

    if (BmpRotate = (pPDev->PlotForm.BmpRotMode != BMP_ROT_NONE)) {

        //
        // We must allocate rotation buffer and it must be DWORD aligned.
        //

        Size.cx *= ((psoHT->sizlBitmap.cy + 23) >> 3);

        if (psoHT->iBitmapFormat == BMF_1BPP) {

            //
            // We also have to take into acount the fact that pixels can start
            // anywhere in the first byte, causing us to allocate and extra byte
            // for the shift.
            //


            Size.cy = (LONG)((psoHT->sizlBitmap.cy + 23) >> 3);
            Size.cy = (LONG)(DW_ALIGN(Size.cy) << 3);

        } else {

            Size.cy = (LONG)((psoHT->sizlBitmap.cy + 3) >> 1);
            Size.cy = (LONG)(DW_ALIGN(Size.cy) << 1);
        }

        ++cxLogExt;

    } else {

        //
        // For a non-rotated 4BPP bitmap, we need an extra buffer to
        // ensure the final 4bpp bitmap is DWORD aligned. This will speed up
        // the 4bpp to 3 plane translation.
        //

        Size.cy  = (LONG)((psoHT->sizlBitmap.cx + 23) >> 3);
        Size.cx *= Size.cy;

        if (psoHT->iBitmapFormat == BMF_4BPP) {

            //
            // Make sure the we allocate a rotation buffer for alignment
            // purposes
            //

            Size.cy = (LONG)((psoHT->sizlBitmap.cx + 3) << 1);
            Size.cy = (LONG)DW_ALIGN(Size.cy);

        } else {

            //
            // BMF_1BPP will be left/right shifted on a per byte basis on
            // the fly.
            //

            Size.cy = 0;
        }
    }

    HTBmpFunc = HTBmpFuncTable[cxLogExt];

    //
    // Make sure the first buffer is DWORD aligned, otherwise the next
    // buffer (pRotBuf) will not start on a DWORD boundary.
    //

    Size.cx = DW_ALIGN(Size.cx);

    PLOTDBGBLK(HTBmpInfo.cScanBuf = Size.cx;
               HTBmpInfo.cRotBuf  = Size.cy)

    PLOTDBG(DBG_OUTHTBMP, ("OutputHTBitmap: [%hs] - ScanBuf=%ld, RotBuf=%ld",
                            pszHTBmpFunc[cxLogExt], Size.cx, Size.cy));

    //
    // Allocate scan buffer and rotation temp buffer if needed
    //

    if (!(HTBmpInfo.pScanBuf = (LPBYTE)LocalAlloc(LPTR, Size.cx + Size.cy))) {

        PLOTERR(("OutputHTBmp: LocalAlloc(%ld) Failed, cx=%ld, cy=%ld",
                Size.cx + Size.cy, Size.cx, Size.cy));

        ExitToHPGL2Mode(pPDev, HPGL2ModeCmds, pOHTFlags, OHTFlags);
        return(FALSE);
    }

    HTBmpInfo.pRotBuf = (Size.cy) ? (HTBmpInfo.pScanBuf + Size.cx) : NULL;

    //
    // Set up local variables for the command mode and other one time variables
    //

    cxLogExt = SPLTOENGUNITS(pPDev, pPDev->PlotForm.LogExt.cx);

    //
    // Now set up the rclDest for the bitmap we will output to. And set More to
    // false, which means one RECT.
    //

    rclDest.left   = pptlDest->x;
    rclDest.top    = pptlDest->y;
    rclDest.right  = rclDest.left + (rclSrc.right - rclSrc.left);
    rclDest.bottom = rclDest.top  + (rclSrc.bottom - rclSrc.top);


    //
    // The following variables are essential for the default assumptions.
    //
    //  1. RetVal       = TRUE if no clip rect we return OK
    //  2. More         = FALSE default as current HTEnumRCL.c and rectl
    //                    without calling CLIPOBJ_bEnum()
    //  3. HTEnumRCL.c  = 1 to have only one default HTEnumRCL.rcl
    //

    RetVal         = TRUE;
    More           = FALSE;
    HTEnumRCL.c    = 1;

    if ((!pco) || (pco->iDComplexity == DC_TRIVIAL)) {

        //
        // The whole output destination rectangle is visible
        //

        PLOTDBG(DBG_OUTHTBMP, ("OutputHTBitmap: pco=%hs",
                                            (pco) ? "DC_TRIVIAL" : "NULL"));

        HTEnumRCL.rcl[0] = rclDest;

    } else if (pco->iDComplexity == DC_RECT) {

        //
        // The visible area is one rectangle so intersect with the destination
        //

        PLOTDBG(DBG_OUTHTBMP, ("OutputHTBitmap: pco=DC_RECT"));

        HTEnumRCL.rcl[0] = pco->rclBounds;

    } else {

        //
        // We have a complex clipping region to be computed, call engine to start
        // enumerating the rectangles and set More = TRUE so we can get the first
        // batch of rectangles.
        //

        PLOTDBG(DBG_OUTHTBMP, ("OutputHTBitmap: pco=DC_COMPLEX, EnumRects now"));

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        More = TRUE;
    }

    Rop3 &= 0xFF;

    PLOTASSERT(1, "OutputHTBitmap: The Rop required PATTERN? [%04lx]",
                        !ROP3_NEED_PAT(Rop3), Rop3);

    if (PF_BYTEALIGN(PlotFlags)) {

        if (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) {

            PLOTWARN(("OutputHTBitmap: ByteAlign/Poster Mode Rop3 0x%02lx -> 0x%02lx",
                        Rop3, ROP3_BYTEALIGN_POSTER));
            Rop3 = ROP3_BYTEALIGN_POSTER;
        }

        OHTFlags    &= ~OHTF_SET_TR1;
        CurHPBAHack  = HPBAHack[Rop3 & 0x0F];

        if (CurHPBAHack.Flags & HPBHF_nS) {

            HTBmpInfo.Flags |= HTBIF_FLIP_MONOBITS;
        }

        if (CurHPBAHack.Flags & HPBHF_PAD_1) {

            HTBmpInfo.Flags |= HTBIF_BA_PAD_1;
        }

        PLOTDBG(DBG_HTBLT, ("OutpputHTBitmap: BA HACK: Rop3=%02lx -> %02lx, Flags=%04lx",
                        (DWORD)Rop3,
                        (DWORD)CurHPBAHack.Rop3RTL,
                        (DWORD)CurHPBAHack.Flags));

    } else {

        CurHPBAHack.Rop3RTL   = (BYTE)Rop3;
        CurHPBAHack.Flags     = 0;
    }

    //
    // To have correct image area located for the bitmap, we must offset all
    // bitmaps with these amounts
    //

    BmpOffset.x = SPLTOENGUNITS(pPDev, pPDev->PlotForm.BmpOffset.x);
    BmpOffset.y = SPLTOENGUNITS(pPDev, pPDev->PlotForm.BmpOffset.y);

    //
    // We have 'More' and HTEnumRCL structure set, now go through each clipping
    // rectangle and call the halftone output fucntion to do the real work
    //

    do {

        //
        // If More is true then we need to get the next batch of rectangles.
        //

        if (More) {

            More = CLIPOBJ_bEnum(pco, sizeof(HTEnumRCL), (ULONG *)&HTEnumRCL);
        }

        //
        // prcl will point to the first enumerated rectangle.
        //

        prcl = (PRECTL)&HTEnumRCL.rcl[0];

        while (HTEnumRCL.c-- && More != DDI_ERROR) {

            if (PLOT_CANCEL_JOB(pPDev)) {

                RetVal =
                More   = FALSE;
                break;
            }

            //
            // Only do this rectangle area if it is visible
            //

            HTBmpInfo.rclBmp = *prcl;

            if (IntersectRECTL(&(HTBmpInfo.rclBmp), &rclDest)) {

                //
                // For the very first time, we want to switch to PP1
                //

                if (FirstEnumRCL) {

                    SetPixelPlacement(pPDev, SPP_MODE_EDGE);
                    FirstEnumRCL = FALSE;
                }

                //
                // Now compute useable information to be passed to the output
                // halftoned bitmap function
                //

                HTBmpInfo.OffBmp.x  = rclSrc.left +
                                      (HTBmpInfo.rclBmp.left - rclDest.left);
                HTBmpInfo.OffBmp.y  = rclSrc.top +
                                      (HTBmpInfo.rclBmp.top - rclDest.top);
                HTBmpInfo.szlBmp.cx = HTBmpInfo.rclBmp.right -
                                      HTBmpInfo.rclBmp.left;
                HTBmpInfo.szlBmp.cy = HTBmpInfo.rclBmp.bottom -
                                      HTBmpInfo.rclBmp.top;
                HTBmpInfo.pScan0    = (LPBYTE)psoHT->pvScan0 +
                                      (HTBmpInfo.OffBmp.y * HTBmpInfo.Delta);

                PLOTDBG(DBG_HTBLT, ("OutputHTBitmap: rclBmp=(%ld, %ld)-(%ld, %ld) [%ld x %ld] Off=(%ld, %ld)",
                            HTBmpInfo.rclBmp.left, HTBmpInfo.rclBmp.top,
                            HTBmpInfo.rclBmp.right, HTBmpInfo.rclBmp.bottom,
                            HTBmpInfo.szlBmp.cx, HTBmpInfo.szlBmp.cy,
                            HTBmpInfo.OffBmp.x, HTBmpInfo.OffBmp.y));

                //
                // Now set the correct cursor position based on the rotation
                //

                if (BmpRotate) {

                    Size.cx     = HTBmpInfo.szlBmp.cy;
                    Size.cy     = HTBmpInfo.szlBmp.cx;
                    CursorPos.x = HTBmpInfo.rclBmp.top;
                    CursorPos.y = cxLogExt - HTBmpInfo.rclBmp.right;

                } else {

                    Size        = HTBmpInfo.szlBmp;
                    CursorPos.x = HTBmpInfo.rclBmp.left;
                    CursorPos.y = HTBmpInfo.rclBmp.top;
                }

                //
                // Add in the bitmap offset location from the imageable area
                //

                CursorPos.x += BmpOffset.x;
                CursorPos.y += BmpOffset.y;

                //
                // If we need to BYTE align, then make the X cursor position
                // byte aligned first
                //

                if (PF_BYTEALIGN(PlotFlags)) {

                    if (i = (UINT)(CursorPos.x & 0x07)) {

                        //
                        // We really need to byte aligne x and we also have to
                        // increase the source width to accomodate the changes
                        //

                        PLOTDBG(DBG_HTBLT,
                                ("OutputHTBitmap: NEED BYTE ALIGN X: %ld -> %ld, SRC WIDTH: %ld -> %ld",
                                    CursorPos.x, CursorPos.x - i,
                                    Size.cx, Size.cx + i));

                        Size.cx     += i;
                        CursorPos.x -= i;
                    }

                    Size.cx = (LONG)((Size.cx + 7) & ~(DWORD)7);
                }

                PLOTDBG(DBG_HTBLT,
                        ("OutputHTBitmap: ABS CAP: (%ld, %ld) --> (%ld, %ld), RELATIVE=(%ld, %ld)",
                                pPDev->ptlRTLCAP.x, pPDev->ptlRTLCAP.y,
                                CursorPos.x, CursorPos.y,
                                CursorPos.x - pPDev->ptlRTLCAP.x,
                                CursorPos.y - pPDev->ptlRTLCAP.y));

                if (!(OHTFlags & OHTF_DONE_ROPTR1)) {

                    if (OHTFlags & OHTF_IN_RTLMODE) {

                        SEND_PLOTCMDS(pPDev, HPGL2ModeCmds);

                        OHTFlags &= ~OHTF_IN_RTLMODE;

                        PLOTDBG(DBG_HTBLT, ("*** Enter HPGL/2: %ld=[%hs]",
                                    (DWORD)HPGL2ModeCmds[0], &HPGL2ModeCmds[1]));
                    }

                    SetRopMode(pPDev,
                               (CurHPBAHack.Flags & HPBHF_1_FIRST) ?
                                    0x88 : CurHPBAHack.Rop3RTL);

                    if (OHTFlags & OHTF_SET_TR1) {

                        OutputString(pPDev, "TR1;");
                    }
                }

                //
                // Entering RTL mode if not already so
                //

                if (!(OHTFlags & OHTF_IN_RTLMODE)) {

                    PLOTDBG(DBG_HTBLT, ("*** Enter RTL: %ld=[%hs]",
                                    (DWORD)RTLModeCmds[0], &RTLModeCmds[1]));

                    SEND_PLOTCMDS(pPDev, RTLModeCmds);

                    if (OHTFlags & OHTF_SET_TR1) {

                        //
                        // Send STM command here
                        //

                        OutputString(pPDev, "\033*v0N");
                    }

                    if (CurHPBAHack.Flags & HPBHF_nS) {

                        HTBmpInfo.Flags |= HTBIF_FLIP_MONOBITS;

                    } else {

                        HTBmpInfo.Flags &= ~HTBIF_FLIP_MONOBITS;
                    }

                    //
                    // If bitmap is monochrome then make sure we set the
                    // palette correctly only if we can set it
                    //

                    if ((RTLClrConfig.BitsPerIndex == 1) &&
                        (!(OHTFlags & OHTF_DONE_ROPTR1))) {

                        PALDW   RTLPal;
                        BOOL    FlipMono = FALSE;

                        for (i = 0; i < 2; i++) {

                            RTLPal.dw = pDrvHTInfo->RTLPal[i].dw;

                            //
                            // Convert the color through gamma/gray scale
                            //

                            GetFinalColor(pPDev, &(RTLPal.Pal));

                            if (RTLPal.dw != DefWKPal[i]) {

                                if (PF_RTLMONO_FIXPAL(PlotFlags)) {

                                    FlipMono = TRUE;

                                } else {

                                    OutputFormatStr(pPDev,
                                                    SetRGBCmd,
                                                    (DWORD)RTLPal.Pal.R,
                                                    (DWORD)RTLPal.Pal.G,
                                                    (DWORD)RTLPal.Pal.B,
                                                    i);

                                    PLOTDBG(DBG_HTBLT_CLR,
                                            ("OutputHTBitmap: Change RTLPal[%ld]=%02lx:%02lx:%02lx",
                                                    (DWORD)i,
                                                    (DWORD)RTLPal.Pal.R,
                                                    (DWORD)RTLPal.Pal.G,
                                                    (DWORD)RTLPal.Pal.B));
                                }
                            }
                        }

                        if (FlipMono) {

                            HTBmpInfo.Flags ^= HTBIF_FLIP_MONOBITS;

                            PLOTDBG(DBG_HTBLT_CLR, ("OutputHTBitmap: Flip MONO Bits"));
                        }
                    }
                }

                OHTFlags |= (OHTF_IN_RTLMODE | OHTF_DONE_ROPTR1);

                TempY = CursorPos.y - pPDev->ptlRTLCAP.y;

                if (PF_RTL_NO_DPI_XY(PlotFlags)) {


                    //
                    // We will move X in absolute movements (not relative)
                    // by always outputing position 0 to flush out the device
                    // X CAP then move absolute to final X position. We will
                    // us relative movement for the Y coordinate.
                    //

                    OutputFormatStr(pPDev,
                                    XMoveDECI,
                                    DEVTODECI(pPDev, CursorPos.x));

                } else {

                    if ((TempY <= MAX_HP_Y_MOVE) &&
                        (TempY >= -MAX_HP_Y_MOVE)) {

                        OutputFormatStr(pPDev,
                                        XYMoveDPI,
                                        CursorPos.x - pPDev->ptlRTLCAP.x,
                                        TempY);
                        TempY = 0;

                    } else {

                        OutputFormatStr(pPDev,
                                        XYMoveDPI,
                                        CursorPos.x - pPDev->ptlRTLCAP.x,
                                        0);
                    }
                }

                MoveRelativeY(pPDev, TempY);

                //
                // Update new cursor position after the RTL commands, the
                // CursorPos and pPDev->ptlRTLCAPS always are ABSOLUTE
                // coordinates but we will send the RTL RELATIVE
                // command to position the bitmap.
                //

                pPDev->ptlRTLCAP.x = CursorPos.x;
                pPDev->ptlRTLCAP.y = CursorPos.y + Size.cy;

                //
                // Output Start Graphic commands
                //


                OutputFormatStr(pPDev, StartGraf, Size.cx);

                //
                // Fill One first if we are simulating rops the device can't
                // handle
                //

                if (CurHPBAHack.Flags & HPBHF_1_FIRST) {

                    FillRect1bppBmp(&HTBmpInfo, 0xFF, FALSE, BmpRotate);

                    OutputBytes(HTBmpInfo.pPDev, EndGraf, sizeof(EndGraf));

                    if (CurHPBAHack.Rop3RTL != 0xAA) {

                        SEND_PLOTCMDS(pPDev, HPGL2ModeCmds);
                        SetRopMode(pPDev, CurHPBAHack.Rop3RTL);
                        SEND_PLOTCMDS(pPDev, RTLModeCmds);

                        MoveRelativeY(pPDev, -Size.cy);
                        OutputFormatStr(pPDev, StartGraf, Size.cx);
                    }
                }

                //
                // Now call the functions to really output the bitmap
                //

                if (CurHPBAHack.Rop3RTL != 0xAA) {

                    if (RetVal = HTBmpFunc(&HTBmpInfo)) {

                        //
                        // If output is ok then send End Graphic command now
                        //

                        OutputBytes(HTBmpInfo.pPDev, EndGraf, sizeof(EndGraf));

                    } else {

                        PLOTERR(("OutputHTBitmap: HTBmpFunc = FALSE (failed)"));

                        More = FALSE;
                        break;
                    }
                }

                if (CurHPBAHack.Flags & HPBHF_nD_LAST) {

                    SEND_PLOTCMDS(pPDev, HPGL2ModeCmds);
                    SetRopMode(pPDev, 0x66);
                    SEND_PLOTCMDS(pPDev, RTLModeCmds);

                    if ((CurHPBAHack.Flags & HPBHF_1_FIRST) ||
                        (CurHPBAHack.Rop3RTL != 0xAA)) {

                        MoveRelativeY(pPDev, -Size.cy);
                        OutputFormatStr(pPDev, StartGraf, Size.cx);

                        OHTFlags |= OHTF_IN_RTLMODE;
                    }

                    FillRect1bppBmp(&HTBmpInfo, 0x00, TRUE, BmpRotate);
                    OutputBytes(HTBmpInfo.pPDev, EndGraf, sizeof(EndGraf));

                }

                if (PF_BYTEALIGN(PlotFlags)) {

                    OHTFlags &= ~OHTF_DONE_ROPTR1;
                }

            } else {

                PLOTDBG(DBG_HTBLT_SKIP, ("OutputHTBitmap: INVISIBLE rcl=(%ld, %ld)-(%ld, %ld)",
                            prcl->left, prcl->top, prcl->right, prcl->bottom));
            }

            prcl++;
        }

        if (More == DDI_ERROR)
        {
            More = FALSE;
            RetVal = FALSE;
        }

    } while (More);

    //
    // Finally return to HPGL/2 mode
    //

    if ((!RetVal) || (!pOHTFlags)) {

        ExitToHPGL2Mode(pPDev, HPGL2ModeCmds, pOHTFlags, OHTFlags);

    }

    if (pOHTFlags) {

        *pOHTFlags = OHTFlags;
    }

    //
    // Get rid of any resources we allocated
    //

    LocalFree((HLOCAL)HTBmpInfo.pScanBuf);

    return(RetVal);


#undef pDrvHTInfo
}




LONG
GetBmpDelta(
    DWORD   SurfaceFormat,
    DWORD   cx
    )

/*++

Routine Description:


    This function calculates the total bytes needed in order to advance a
    scan line based on the bitmap format and alignment.

Arguments:

    SurfaceFormat   - Surface format of the bitmap, this must be one of the
                      standard formats which are defined as BMF_xxx

    cx              - Total Pels per scan line in the bitmap.

Return Value:

    The return value is the total bytes in one scan line if it is greater than
    zero



Development History:

    19-Jan-1994 Wed 16:19:39 created 


Revision History:



--*/

{
    DWORD   Delta = cx;

    switch (SurfaceFormat) {

    case BMF_32BPP:

        Delta <<= 5;
        break;

    case BMF_24BPP:

        Delta *= 24;
        break;

    case BMF_16BPP:

        Delta <<= 4;
        break;

    case BMF_8BPP:

        Delta <<= 3;
        break;

    case BMF_4BPP:

        Delta <<= 2;
        break;

    case BMF_1BPP:

        break;

    default:

        PLOTERR(("GetBmpDelta: Invalid BMF_xxx format = %ld", SurfaceFormat));
        break;
    }

    Delta = (DWORD)DW_ALIGN((Delta + 7) >> 3);

    PLOTDBG(DBG_BMPDELTA, ("Format=%ld, cx=%ld, Delta=%ld",
                                            SurfaceFormat, cx, Delta));

    return((LONG)Delta);
}




SURFOBJ *
CreateBitmapSURFOBJ(
    PPDEV   pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format,
    LPVOID  pvBits
    )

/*++

Routine Description:

    This function creates a bitmap and locks the bitmap to return a SURFOBJ

Arguments:

    pPDev   - Pointer to our PDEV

    phBmp   - Pointer the HBITMAP location to be returned for the bitmap

    cxSize  - CX size of bitmap to be created

    cySize  - CY size of bitmap to be created

    Format  - one of BMF_xxx bitmap format to be created

    pvBits  - the buffer to be used

Return Value:

    SURFOBJ if sucessful, NULL if failed



Development History:

    19-Jan-1994 Wed 16:31:50 created  


Revision History:


--*/

{
    SURFOBJ *pso = NULL;
    SIZEL   szlBmp;


    szlBmp.cx = cxSize;
    szlBmp.cy = cySize;

    PLOTDBG(DBG_CREATESURFOBJ, ("CreateBitmapSURFOBJ: Format=%ld, Size=%ld x %ld",
                                                Format, cxSize, cySize));

    if (*phBmp = EngCreateBitmap(szlBmp,
                                 GetBmpDelta(Format, cxSize),
                                 Format,
                                 BMF_TOPDOWN | BMF_NOZEROINIT,
                                 pvBits)) {

        if (EngAssociateSurface((HSURF)*phBmp, (HDEV)pPDev->hpdev, 0)) {

            if (pso = EngLockSurface((HSURF)*phBmp)) {

                //
                // Sucessful lock down, return it
                //

                return(pso);

            } else {

                PLOTERR(("CreateBmpSurfObj: EngLockSruface(hBmp) failed!"));
            }

        } else {

            PLOTERR(("CreateBmpSurfObj: EngAssociateSurface() failed!"));
        }

    } else {

        PLOTERR(("CreateBMPSurfObj: FAILED to create Bitmap Format=%ld, %ld x %ld",
                                        Format, cxSize, cySize));
    }

    DELETE_SURFOBJ(pso, phBmp);

    return(NULL);
}




BOOL
HalftoneBlt(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoHTBlt,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlHTOrigin,
    BOOL        DoStretchBlt
    )

/*++

Routine Description:


Arguments:

    pPDev           - Pointer to our PDEV

    psoDst          - destination surfobj

    psoHTBlt        - the final halftoned result will be stored, must be a
                      4/1 halftoned bitmap format

    psoSrc          - source surfobj must be BITMAP

    pxlo            - xlate object from source to the plotter device

    prclDest        - rectangle area for the destination

    prclSrc         - rectangle area to be halftoned from the source, if NULL
                      then full source size is used

    pptlHTOrigin    - the halftone origin, if NULL then (0,0) is assumed

    StretchBlt      - if TRUE then a stretch from rclSrc to rclDst otherwise
                      a tiling is done


Return Value:

    BOOL to indicate operation status



Development History:

    19-Jan-1994 Wed 15:44:57 created  


Revision History:


--*/

{
    SIZEL   szlSrc;
    RECTL   rclSrc;
    RECTL   rclDst;
    RECTL   rclCur;
    RECTL   rclHTBlt;


    if (PLOT_CANCEL_JOB(pPDev)) {

        return(FALSE);
    }

    PLOTASSERT(1, "HalftoneBlt: psoSrc type [%ld] is not a bitmap",
                        psoSrc->iType == STYPE_BITMAP, (LONG)psoSrc->iType);
    PLOTASSERT(1, "HalftoneBlt: psoHTBlt type [%ld] is not a bitmap",
                        psoHTBlt->iType == STYPE_BITMAP, (LONG)psoHTBlt->iType);

    if (pPDev->psoHTBlt) {

        PLOTERR(("HalftoneBlt: EngStretchBlt(HALFTONE) RECURSIVE CALLS NOT ALLOWED!"));
        return(FALSE);
    }

    pPDev->psoHTBlt = psoHTBlt;

    if (prclSrc) {

        rclSrc = *prclSrc;

    } else {

        rclSrc.left   =
        rclSrc.top    = 0;
        rclSrc.right  = psoSrc->sizlBitmap.cx;
        rclSrc.bottom = psoSrc->sizlBitmap.cy;
    }

    if (prclDst) {

        rclDst = *prclDst;

    } else {

        rclDst.left   =
        rclDst.top    = 0;
        rclDst.right  = psoHTBlt->sizlBitmap.cx;
        rclDst.bottom = psoHTBlt->sizlBitmap.cy;
    }

    if (!pptlHTOrigin) {

        pptlHTOrigin = (PPOINTL)&ptlZeroOrigin;
    }

    if (DoStretchBlt) {

        szlSrc.cx = rclDst.right - rclDst.left;
        szlSrc.cy = rclDst.bottom - rclDst.top;

    } else {

        szlSrc.cx = rclSrc.right - rclSrc.left;
        szlSrc.cy = rclSrc.bottom - rclSrc.top;
    }

    PLOTDBG(DBG_HTBLT, ("HalftoneBlt: %hs BLT, (%ld,%ld)-(%ld,%ld), SRC=%ldx%ld",
                    (DoStretchBlt) ? "STRETCH" : "TILE",
                    rclDst.left, rclDst.top, rclDst.right,rclDst.bottom,
                    szlSrc.cx, szlSrc.cy));

    //
    // Start to tile it, rclCur is current RECTL on the destination
    //

    rclHTBlt.top  = 0;
    rclCur.top    =
    rclCur.bottom = rclDst.top;

    while (rclCur.top < rclDst.bottom) {

        //
        // Check the Current Bottom, clip it if necessary
        //

        if ((rclCur.bottom += szlSrc.cy) > rclDst.bottom) {

            rclCur.bottom = rclDst.bottom;
        }

        rclHTBlt.bottom = rclHTBlt.top + (rclCur.bottom - rclCur.top);

        rclHTBlt.left   = 0;
        rclCur.left     =
        rclCur.right    = rclDst.left;

        while (rclCur.left < rclDst.right) {

            //
            // Check the Current right, clip it if necessary
            //

            if ((rclCur.right += szlSrc.cx) > rclDst.right) {

                rclCur.right = rclDst.right;
            }

            //
            // Set it for the tiling rectangle in psoHTBlt
            //

            rclHTBlt.right = rclHTBlt.left + (rclCur.right - rclCur.left);

            PLOTDBG(DBG_HTBLT, ("HalftoneBlt: TILE (%ld,%ld)-(%ld,%ld)->(%ld,%ld)-(%ld,%ld)=%ld x %ld",
                            rclCur.left, rclCur.top, rclCur.right, rclCur.bottom,
                            rclHTBlt.left, rclHTBlt.top,
                            rclHTBlt.right, rclHTBlt.bottom,
                            rclCur.right - rclCur.left,
                            rclCur.bottom - rclCur.top));

            //
            // Set it before the call for the DrvCopyBits()
            //

            pPDev->rclHTBlt = rclHTBlt;

            if (!EngStretchBlt(psoDst,              // Dest
                               psoSrc,              // SRC
                               NULL,                // MASK
                               NULL,                // CLIPOBJ
                               pxlo,                // XLATEOBJ
                               NULL,                // COLORADJUSTMENT
                               pptlHTOrigin,        // BRUSH ORG
                               &rclCur,             // DEST RECT
                               &rclSrc,             // SRC RECT
                               NULL,                // MASK POINT
                               HALFTONE)) {         // HALFTONE MODE

                PLOTERR(("HalftoneeBlt: EngStretchBits(DST=(%ld,%ld)-(%ld,%ld), SRC=(%ld,%ld) FAIELD!",
                                    rclCur.left, rclCur.top,
                                    rclCur.right, rclCur.bottom,
                                    rclSrc.left, rclSrc.top));

                pPDev->psoHTBlt = NULL;
                return(FALSE);
            }

            rclHTBlt.left = rclHTBlt.right;
            rclCur.left   = rclCur.right;
        }

        rclHTBlt.top = rclHTBlt.bottom;
        rclCur.top   = rclCur.bottom;
    }

    pPDev->psoHTBlt = NULL;

    return(TRUE);
}




SURFOBJ *
CreateSolidColorSURFOBJ(
    PPDEV   pPDev,
    SURFOBJ *psoDst,
    HBITMAP *phBmp,
    DWORD   SolidColor
    )

/*++

Routine Description:

    This function creates a SOLID color bitmap surfobj which can be used to
    blt around.

Arguments:

    pPDev       - Pointer to our PDEV

    phBmp       - Pointer the HBITMAP location to be returned for the bitmap

    SolidColor  - Solid color


Return Value:

    SURFOBJ if sucessful, NULL if failed


Development History:

    19-Jan-1994 Wed 16:35:54 created  


Revision History:


--*/

{
    SURFOBJ *psoHT    = NULL;
    HBITMAP hBmpSolid = NULL;
    SURFOBJ *psoSolid;


    //
    // First create a 24-bit source color bitmap
    //

    if (psoSolid = CreateBitmapSURFOBJ(pPDev,
                                       &hBmpSolid,
                                       1,
                                       1,
                                       BMF_24BPP,
                                       NULL)) {

        LPBYTE      pbgr        = (LPBYTE)psoSolid->pvScan0;
        PPALENTRY   pPal        = (PPALENTRY)&SolidColor;
        DWORD       HTCellSize  = (DWORD)HTPATSIZE(pPDev);

        *pbgr++ = pPal->R;
        *pbgr++ = pPal->G;
        *pbgr++ = pPal->B;

        //
        // Create a compatible halftone surface with size of halftone cell
        //

        if (psoHT = CreateBitmapSURFOBJ(pPDev,
                                        phBmp,
                                        HTCellSize,
                                        HTCellSize,
                                        (DWORD)HTBMPFORMAT(pPDev),
                                        NULL)) {

            //
            // Now halftone blt it
            //

            if (!HalftoneBlt(pPDev,         // pPDev
                             psoDst,        // psoDst
                             psoHT,         // psoHTBlt
                             psoSolid,      // psoSrc
                             NULL,          // pxlo,
                             NULL,          // prclDst
                             NULL,          // prclSrc
                             NULL,          // pptlHTOrigin
                             TRUE)) {       // DoStretchBlt

                PLOTERR(("CreateSolidColorSURFOBJ: HalftoneBlt(STRETCH) Failed"));

                DELETE_SURFOBJ(psoHT, phBmp);
            }

        } else {

            PLOTERR(("CreateSolidColorSURFOBJ: Create 24BPP SOURCE failed"));
        }

    } else {

        PLOTERR(("CreateSolidColorSURFOBJ: Create 24BPP SOURCE failed"));
    }

    DELETE_SURFOBJ(psoSolid, &hBmpSolid);

    return(psoHT);
}



SURFOBJ *
CloneBrushSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    HBITMAP     *phBmp,
    BRUSHOBJ    *pbo
    )

/*++

Routine Description:

    This function clones the surface object passed in


Arguments:

    pPDev   - Points to our PPDEV

    psoDst  - the surface object for the plotter

    phBmp   - Pointer to stored hBbitmap created for the cloned surface

    pbo     - BRUSHOBJ to be cloned


Return Value:

    pointer to the cloned surface object, NULL if failure



Development History:

    09-Feb-1994 Wed 13:04:46 updated  
        Make it assert and handle it when things not supposed happened.

    04-Jan-1994 Tue 12:11:23 created  


Revision History:


--*/

{
    //
    // Ceate a Solid color brush if so, NOTE: All brush patterns created
    // here have brush origin at (0,0) we will align the brush origin
    // when we actually do the ROPs
    //

    if (!IS_RASTER(pPDev)) {

        return(FALSE);
    }

    if (pbo->iSolidColor & 0xFF000000) {

        PDEVBRUSH   pDevBrush = (PDEVBRUSH)pbo->pvRbrush;

        if ((pDevBrush) || (pDevBrush = BRUSHOBJ_pvGetRbrush(pbo))) {

            return(CreateBitmapSURFOBJ(pPDev,
                                       phBmp,
                                       pDevBrush->sizlBitmap.cx,
                                       pDevBrush->sizlBitmap.cy,
                                       pDevBrush->BmpFormat,
                                       pDevBrush->BmpBits));

        } else {

            return(FALSE);
        }

    } else {

        return(CreateSolidColorSURFOBJ(pPDev,
                                       psoDst,
                                       phBmp,
                                       pbo->iSolidColor));
    }
}




SURFOBJ *
CloneSURFOBJToHT(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    HBITMAP     *phBmp,
    PRECTL      prclDst,
    PRECTL      prclSrc
    )
/*++

Routine Description:

    This function clones the surface object passed in


Arguments:

    pPDev           - Pointer to our PPDEV

    psoDst          - the surface object for the plotter, if psoDst is NULL
                      then only the bitmapp will be created

    psoSrc          - The surface object to be cloned

    pxlo            - XLATE object to be used from source to plotter surfobj

    phBmp           - Pointer to stored hBbitmap created for the cloned surface

    prclDst         - rectangle rectangle size/location to be cloned

    prclSrc         - source rectangle size/location to be cloned

Return Value:

    pointer to the cloned surface object, NULL if failed.

    if this function is sucessful it will MODIFY the prclSrc to reflect cloned
    surface object



Development History:

    04-Jan-1994 Tue 12:11:23 created  

Revision History:


--*/

{
    SURFOBJ *psoHT;
    RECTL   rclDst;
    RECTL   rclSrc;
    POINTL  ptlHTOrigin;


    rclSrc.left   =
    rclSrc.top    = 0;
    rclSrc.right  = psoSrc->sizlBitmap.cx;
    rclSrc.bottom = psoSrc->sizlBitmap.cy;

    if (prclSrc) {

        if (!IntersectRECTL(&rclSrc, prclSrc)) {

            PLOTDBG(DBG_CLONESURFOBJ, ("CloneSURFOBJToHT: Source rectangle is empty"));
            return(NULL);
        }
    }

    PLOTDBG(DBG_CLONESURFOBJ, ("CloneSURFOBJToHT: rclSrc=(%ld, %ld)-(%ld,%ld) = %ld x %ld",
                    rclSrc.left, rclSrc.top,
                    rclSrc.right, rclSrc.bottom,
                    rclSrc.right - rclSrc.left,
                    rclSrc.bottom - rclSrc.top));

    rclDst.left   =
    rclDst.top    = 0;
    rclDst.right  = psoDst->sizlBitmap.cx;
    rclDst.bottom = psoDst->sizlBitmap.cy;

    if (prclDst) {

        if (!IntersectRECTL(&rclDst, prclDst)) {

            PLOTDBG(DBG_CLONESURFOBJ, ("CloneSURFOBJToHT: Source rectangle is empty"));
            return(NULL);
        }
    }

    PLOTDBG(DBG_CLONESURFOBJ, ("CloneSURFOBJToHT: rclDst=(%ld, %ld)-(%ld,%ld) = %ld x %ld",
                    rclDst.left, rclDst.top,
                    rclDst.right, rclDst.bottom,
                    rclDst.right - rclDst.left,
                    rclDst.bottom - rclDst.top));

    if (psoHT = CreateBitmapSURFOBJ(pPDev,
                                    phBmp,
                                    rclDst.right -= rclDst.left,
                                    rclDst.bottom -= rclDst.top,
                                    HTBMPFORMAT(pPDev),
                                    NULL)) {

        //
        // Halftone and tile the source to the destination
        //

        ptlHTOrigin.x = rclDst.left;
        ptlHTOrigin.y = rclDst.top;

        if (prclSrc) {

            if ((rclDst.left = prclSrc->left) > 0) {

                rclDst.left = 0;
            }

            if ((rclDst.top = prclSrc->top) > 0) {

                rclDst.top = 0;
            }

            //
            // Modify the source to reflect the cloned source
            //

            *prclSrc = rclDst;
        }


        if (psoDst) {

            if (!HalftoneBlt(pPDev,
                             psoDst,
                             psoHT,
                             psoSrc,
                             pxlo,
                             &rclDst,
                             &rclSrc,
                             &ptlHTOrigin,
                             FALSE)) {

                PLOTERR(("CloneSURFOBJToHT: HalftoneBlt(TILE) Failed"));

                DELETE_SURFOBJ(psoHT, phBmp);
            }
        }

    } else {

        PLOTERR(("CreateSolidColorSURFOBJ: Create Halftone SURFOBJ failed"));
    }

    return(psoHT);
}



SURFOBJ *
CloneMaskSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoMask,
    HBITMAP     *phBmp,
    PRECTL      prclMask
    )
/*++

Routine Description:

    This function clones the mask surface object passed in


Arguments:

    pPDev           - Pointer to our PPDEV

    psoMask         - The mask surface object to be cloned

    phBmp           - Pointer to stored hBbitmap created for the cloned surface

    prclMask        - Mask source rectangle size/location to be cloned

Return Value:

    pointer to the cloned surface object or original passed in psoMask, NULL if
    failed.

    if this function is sucessful it will MODIFY the prclMask to reflect cloned
    surface object



Development History:

    04-Jan-1994 Tue 12:11:23 created 


Revision History:


--*/

{
    SURFOBJ *psoHT;
    RECTL   rclMask;
    DWORD   cxMask;
    DWORD   cyMask;
    DWORD   xLoop;


    if (PLOT_CANCEL_JOB(pPDev)) {

        return(FALSE);
    }

    PLOTASSERT(1, "CloneMaskSURFOBJ: psoMask=%08lx is not 1BPP",
                        (psoMask)   &&
                        (psoMask->iType == STYPE_BITMAP) &&
                        (psoMask->iBitmapFormat == BMF_1BPP), psoMask);

    PLOTDBG(DBG_CLONEMASK, ("CloneMaskSURFOBJ: prclMask=(%ld, %ld)-(%ld,%ld) = %ld x %ld",
                    prclMask->left, prclMask->top,
                    prclMask->right, prclMask->bottom,
                    prclMask->right - prclMask->left,
                    prclMask->bottom - prclMask->top));

    rclMask.left   =
    rclMask.top    = 0;
    rclMask.right  = psoMask->sizlBitmap.cx;
    rclMask.bottom = psoMask->sizlBitmap.cy;

    if (!IntersectRECTL(&rclMask, prclMask)) {

        PLOTDBG(DBG_CLONEMASK, ("CloneMaskSURFOBJ: Mask rectangle is empty"));
        return(NULL);
    }

    cxMask = rclMask.right - rclMask.left;
    cyMask = rclMask.bottom - rclMask.top;

    PLOTDBG(DBG_CLONEMASK, ("CloneMaskSURFOBJ: rclMask=(%ld, %ld)-(%ld,%ld) = %ld x %ld",
                    rclMask.left, rclMask.top,
                    rclMask.right, rclMask.bottom,
                    rclMask.right - rclMask.left,
                    rclMask.bottom - rclMask.top));

    if (psoHT = CreateBitmapSURFOBJ(pPDev,
                                    phBmp,
                                    cxMask,
                                    cyMask,
                                    HTBMPFORMAT(pPDev),
                                    NULL)) {
        //
        // Update prclMask
        //

        prclMask->left   =
        prclMask->top    = 0;
        prclMask->right  = cxMask;
        prclMask->bottom = cyMask;

        if (psoHT->iBitmapFormat == BMF_1BPP) {

            //
            // !Remember: Our BMF_1BPP 0=BLACK, 1=WHITE
            //

            if (!EngBitBlt(psoHT,                   // psoDst
                           psoMask,                 // psoSrc
                           NULL,                    // psoMask
                           NULL,                    // pco
                           NULL,                    // pxlo
                           prclMask,                // prclDst
                           (PPOINTL)&rclMask,       // pptlSrc
                           NULL,                    // pptlMask
                           NULL,                    // pbo
                           (PPOINTL)&ptlZeroOrigin, // pptlBrushOrg ZERO
                           0x3333)) {               // NOTSRCCOPY

                PLOTERR(("DrvBitBlt: EngBitBlt(Mask 0x3333) FAILED"));
            }

        } else {

            BYTE    SrcMaskBeg;
            BYTE    SrcMask;
            BYTE    DstMask;
            BYTE    bSrc;
            BYTE    bDst;
            LPBYTE  pbSrcBeg;
            LPBYTE  pbDstBeg;
            LPBYTE  pbSrc;
            LPBYTE  pbDst;


            PLOTASSERT(1, "CloneMaskSURFOBJ: Cloned Mask psoHT=%08lx is not 4BPP",
                        (psoHT->iBitmapFormat == BMF_4BPP), psoHT);

            //
            // get the starting location of the original 1BPP mask
            //

            pbSrcBeg   = (LPBYTE)psoMask->pvScan0 +
                         (rclMask.top * psoMask->lDelta) +
                         (rclMask.left >> 3);
            SrcMaskBeg = (BYTE)(0x80 >> (rclMask.left & 0x07));
            pbDstBeg   = psoHT->pvScan0;

            while (cyMask--) {

                xLoop     = cxMask;
                pbSrc     = pbSrcBeg;
                pbSrcBeg += psoMask->lDelta;
                pbDst     = pbDstBeg;
                pbDstBeg += psoHT->lDelta;
                SrcMask   = SrcMaskBeg;
                DstMask   = 0xF0;
                bSrc      = *pbSrc++;
                bDst      = 0xFF;

                while (xLoop--) {

                    if (!SrcMask) {

                        SrcMask = 0x80;
                        bSrc    = *pbSrc++;
                    }

                    if (bSrc & SrcMask) {

                        bDst ^= DstMask;
                    }

                    SrcMask >>= 1;

                    if ((DstMask ^= 0xFF) == 0xF0) {

                        *pbDst++ = bDst;
                        bDst     = 0xFF;
                    }
                }
            }
        }

    } else {

        PLOTERR(("CloneMaskSURFOBJ: Create Mask SURFOBJ failed"));
    }

    return(psoHT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\htblt.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    htblt.h


Abstract:

    This module contains definitions and prototypes for htblt.c


Author:
    18-Dec-1993 Sat 08:50:09 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    10-Feb-1994 Thu 15:24:13 updated  
        Adding MonoPal[] to the DRVHTINFO


--*/


#ifndef _HTBLT_
#define _HTBLT_


typedef struct _FOURBYTES {
    BYTE    b1st;
    BYTE    b2nd;
    BYTE    b3rd;
    BYTE    b4th;
    } FOURBYTES, *PFOURBYTES, FAR *LPFOURBYTES;

typedef union _HTXB {
    FOURBYTES   b4;
    DWORD       dw;
    } HTXB, *PHTXB, FAR *LPHTXB;


#define HTXB_H_NIBBLE_MAX   8
#define HTXB_L_NIBBLE_MAX   8
#define HTXB_H_NIBBLE_DUP   128
#define HTXB_L_NIBBLE_DUP   8
#define HTXB_COUNT          (HTXB_H_NIBBLE_DUP * 2)
#define HTXB_TABLE_SIZE     (HTXB_COUNT * sizeof(HTXB))

#define HTPAL_XLATE_COUNT   8

#define HTPALXOR_NOTSRCCOPY (DWORD)0xffffffff
#define HTPALXOR_SRCCOPY    (DWORD)0x0


#define DHIF_IN_STRETCHBLT  0x01

typedef union _PALDW {
    DWORD       dw;
    PALENTRY    Pal;
    } PALDW;

typedef struct _DRVHTINFO {
    BYTE            Flags;
    BYTE            HTPalCount;
    BYTE            HTBmpFormat;
    BYTE            AltBmpFormat;
    DWORD           HTPalXor;
    PHTXB           pHTXB;
    PALDW           RTLPal[2];
    BYTE            PalXlate[HTPAL_XLATE_COUNT];
    } DRVHTINFO, *PDRVHTINFO;

#define PAL_MIN_I           0x00
#define PAL_MAX_I           0xff

#define HTXB_R(htxb)        htxb.b4.b1st
#define HTXB_G(htxb)        htxb.b4.b2nd
#define HTXB_B(htxb)        htxb.b4.b3rd
#define HTXB_I(htxb)        htxb.b4.b4th

#define RGB_BLACK           0x00000000
#define RGB_WHITE           0x00FFFFFF

#define P4B_TO_3P_DW(dwRet, pHTXB, pbData)                                  \
{                                                                           \
        (dwRet) = (DWORD)((pHTXB[*(pbData + 0)].dw & (DWORD)0xc0c0c0c0) |   \
                          (pHTXB[*(pbData + 1)].dw & (DWORD)0x30303030) |   \
                          (pHTXB[*(pbData + 2)].dw & (DWORD)0x0c0c0c0c) |   \
                          (pHTXB[*(pbData + 3)].dw & (DWORD)0x03030303));   \
        ++((LPDWORD)pbData);                                                        \
}


//
// When outputing halftoned bitmaps, the HTENUMRCLS structure can accomodate
// up to MAX_HTENUM_RECTLS when calling the engine.
//

#define MAX_HTENUM_RECTLS       8


typedef struct _HTENUMRCLS {
    DWORD   c;                      // count of rectangles enumerated
    RECTL   rcl[MAX_HTENUM_RECTLS]; // enumerated rectangles array
    } HTENUMRCL, *PHTENUMRCL;

//
// HTBMPINFO is passed to the halftone bitmap output function
//

#define HTBIF_FLIP_MONOBITS     0x00000001
#define HTBIF_BA_PAD_1          0x00000002

typedef struct _HTBMPINFO {
    PPDEV   pPDev;              // Our pPDev
    LPBYTE  pScan0;             // point to the first scan line of the bitmap
    LONG    Delta;              // count to be added to next scan line
    RECTL   rclBmp;             // visible area for the final output
    POINTL  OffBmp;             // x/y offset from the rclBmp.left
    SIZEL   szlBmp;             // size of visible rectangle
    LPBYTE  pScanBuf;           // pointer to scan buffer (may be RGB 3 scans)
    LPBYTE  pRotBuf;            // tempoprary rotation buffer if not null
    DWORD   Flags;              // HTBIF_xxxx
    PLOTDBGBLK(DWORD cScanBuf)  // debug check
    PLOTDBGBLK(DWORD cRotBuf)   // debug check
    } HTBMPINFO, FAR *PHTBMPINFO;

typedef BOOL (*OUTHTBMPFUNC)(PHTBMPINFO);

#define ISHTF_ALTFMT        0x0001
#define ISHTF_HTXB          0x0002
#define ISHTF_DSTPRIM_OK    0x0004



#define OHTF_IN_RTLMODE     0x00000001
#define OHTF_CLIPWINDOW     0x00000002
#define OHTF_SET_TR1        0x00000004
#define OHTF_DONE_ROPTR1    0x08000000
#define OHTF_EXIT_TO_HPGL2  0x80000000

#define OHTF_MASK           (OHTF_IN_RTLMODE        |   \
                             OHTF_CLIPWINDOW        |   \
                             OHTF_SET_TR1           |   \
                             OHTF_DONE_ROPTR1       |   \
                             OHTF_EXIT_TO_HPGL2)

//
// Functions prototype
//

BOOL
IsHTCompatibleSurfObj(
    PPDEV       pPDev,
    SURFOBJ     *pso,
    XLATEOBJ    *pxlo,
    DWORD       Flags
    );

BOOL
OutputHTBitmap(
    PPDEV   pPDev,
    SURFOBJ *psoHT,
    CLIPOBJ *pco,
    PPOINTL pptlDest,
    PRECTL  prclSrc,
    DWORD   Rop3,
    LPDWORD pOHTFlags
    );

LONG
GetBmpDelta(
    DWORD   SurfaceFormat,
    DWORD   cx
    );

SURFOBJ *
CreateBitmapSURFOBJ(
    PPDEV   pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format,
    LPVOID  pvBits
    );

BOOL
HalftoneBlt(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoHTBlt,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlHTOrigin,
    BOOL        DoStretchBlt
    );

SURFOBJ *
CreateSolidColorSURFOBJ(
    PPDEV   pPDev,
    SURFOBJ *psoDst,
    HBITMAP *phBmp,
    DWORD   SolidColor
    );

SURFOBJ *
CloneBrushSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    HBITMAP     *phBmp,
    BRUSHOBJ    *pbo
    );

SURFOBJ *
CloneSURFOBJToHT(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    HBITMAP     *phBmp,
    PRECTL      prclDst,
    PRECTL      prclSrc
    );

SURFOBJ *
CloneMaskSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoMask,
    HBITMAP     *phBmp,
    PRECTL      prclMask
    );

#endif  // _HTBLT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\htbmp1.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    htbmp1.c


Abstract:

    This module contains functions used to output halftoned 1BPP bitmaps
    to the target device. Rotation is also handled here.

Author:

    21-Dec-1993 Tue 21:35:56 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    10-Feb-1994 Thu 16:52:55 updated  
        Remove pDrvHTInfo->PalXlate[] reference, all monochrome bitmap will
        be sent as index 0/1 color pal set before hand (in OutputHTBitmap)


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgHTBmp1

#define DBG_OUTPUT1BPP      0x00000001
#define DBG_OUTPUT1BPP_ROT  0x00000002
#define DBG_JOBCANCEL       0x00000004
#define DBG_SHOWSCAN        0x80000000

DEFINE_DBGVAR(0);



#define HTBIF_MONO_BA       (HTBIF_FLIP_MONOBITS | HTBIF_BA_PAD_1)




//
// Very useful macro for outputing scan line in a text representation to
// the debug output stream.
//

#define SHOW_SCAN                                                           \
{                                                                           \
    if (DBG_PLOTFILENAME & DBG_SHOWSCAN) {                                  \
                                                                            \
        LPBYTE  pbCur;                                                      \
        UINT    cx;                                                         \
        UINT    x;                                                          \
        UINT    Size;                                                       \
        BYTE    bData;                                                      \
        BYTE    Mask;                                                       \
        BYTE    Buf[128];                                                   \
                                                                            \
        pbCur = pbScanSrc;                                                  \
        Mask  = 0;                                                          \
                                                                            \
        if ((cx = RTLScans.cxBytes << 3) >= sizeof(Buf)) {                  \
                                                                            \
            cx = sizeof(Buf) - 1;                                           \
        }                                                                   \
                                                                            \
        for (Size = x = 0; x < cx; x++) {                                   \
                                                                            \
            if (!(Mask >>= 1)) {                                            \
                                                                            \
                Mask  = 0x80;                                               \
                bData = *pbCur++;                                           \
            }                                                               \
                                                                            \
            Buf[Size++] = (BYTE)((bData & Mask) ? 178 : 176);               \
        }                                                                   \
                                                                            \
        Buf[Size] = '\0';                                                   \
        DBGP((Buf));                                                        \
     }                                                                      \
}




//
// To Use OUT_ONE_1BPP_SCAN, the following variables must be set ahead of time
//
//  HTBmpInfo   - The whole structure with bitmap info set
//  cxDestBytes - Total size of destination scan line buffer per plane
//
//  This macro will directly return a FALSE if a CANCEL JOB is detected in
//  the PDEV
//
//  This function will only allowe the pbScanSrc passed = HTBmpInfo.pScanBuf
//
//  21-Mar-1994 Mon 17:00:21 updated  
//      If we shift to to the left then we will only load last source if
//      we have a valid last source line.
//


#define OUT_ONE_1BPP_SCAN                                                   \
{                                                                           \
    LPBYTE  pbTempS;                                                        \
                                                                            \
    if (LShift) {                                                           \
                                                                            \
        BYTE    b0;                                                         \
        INT     SL;                                                         \
        INT     SR;                                                         \
                                                                            \
        pbTempS = HTBmpInfo.pScanBuf;                                       \
        Loop    = RTLScans.cxBytes;                                         \
                                                                            \
        if ((SL = LShift) > 0) {                                            \
                                                                            \
            b0 = *pbScanSrc++;                                              \
            SR = 8 - SL;                                                    \
                                                                            \
            while (Loop--) {                                                \
                                                                            \
                *pbTempS = (b0 << SL);                                      \
                                                                            \
                if ((Loop) || (FullSrc)) {                                  \
                                                                            \
                    *pbTempS++ |= ((b0 = *pbScanSrc++) >> SR);              \
                }                                                           \
            }                                                               \
                                                                            \
        } else {                                                            \
                                                                            \
            SR = -SL;                                                       \
            SL = 8 - SR;                                                    \
            b0 = 0;                                                         \
                                                                            \
            while (Loop--) {                                                \
                                                                            \
                *pbTempS    = (b0 << SL);                                   \
                *pbTempS++ |= ((b0 = *pbScanSrc++) >> SR);                  \
            }                                                               \
        }                                                                   \
                                                                            \
        pbScanSrc = HTBmpInfo.pScanBuf;                                     \
    }                                                                       \
                                                                            \
    if (HTBmpInfo.Flags & HTBIF_FLIP_MONOBITS) {                            \
                                                                            \
        pbTempS = (LPBYTE)pbScanSrc;                                        \
        Loop    = RTLScans.cxBytes;                                         \
                                                                            \
        while (Loop--) {                                                    \
                                                                            \
            *pbTempS++ ^= 0xFF;                                             \
        }                                                                   \
    }                                                                       \
                                                                            \
    if (HTBmpInfo.Flags & HTBIF_BA_PAD_1) {                                 \
                                                                            \
        *(pbScanSrc          ) |= MaskBA[0];                                \
        *(pbScanSrc + MaskIdx) |= MaskBA[1];                                \
                                                                            \
    } else {                                                                \
                                                                            \
        *(pbScanSrc          ) &= MaskBA[0];                                \
        *(pbScanSrc + MaskIdx) &= MaskBA[1];                                \
    }                                                                       \
                                                                            \
    OutputRTLScans(HTBmpInfo.pPDev,                                         \
                   pbScanSrc,                                               \
                   NULL,                                                    \
                   NULL,                                                    \
                   &RTLScans);                                              \
}




BOOL
FillRect1bppBmp(
    PHTBMPINFO  pHTBmpInfo,
    BYTE        FillByte,
    BOOL        Pad1,
    BOOL        Rotate
    )

/*++

Routine Description:

    This function fills a 1BPP bitmap with the passed mode.

Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  fuction to output the bitmap

    FillByte    - Byte to be filled

    Pad1        - TRUE if need to pad 1 bit else 0 bit

    Rotate      - TRUE if bitmap should be rotated

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    06-Apr-1994 Wed 14:34:28 created  
        For Fill the area 0,1 or inversion, so we will get away of some device
        600 byte alignment problem


Revision History:


--*/

{
    LPBYTE      pbScanSrc;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    DWORD       FullSrc;
    DWORD       Loop;
    INT         LShift;
    UINT        MaskIdx;
    BYTE        MaskBA[2];


    HTBmpInfo = *pHTBmpInfo;
    LShift    = 0;

    //
    // Mode <0: Invert Bits       (Pad 0 : XOR)
    //      =0: Fill All ZERO     (Pad 1 : AND)
    //      >0: Fill All Ones     (Pad 0 : OR)
    //

    if (Rotate) {

        HTBmpInfo.szlBmp.cx = pHTBmpInfo->szlBmp.cy;
        HTBmpInfo.szlBmp.cy = pHTBmpInfo->szlBmp.cx;
        FullSrc             = (DWORD)(HTBmpInfo.rclBmp.top & 0x07);

    } else {

        FullSrc = (DWORD)(HTBmpInfo.rclBmp.left & 0x07);
    }

    HTBmpInfo.Flags = (BYTE)((Pad1) ? HTBIF_BA_PAD_1 : 0);


    //
    // Some devices require that the scanlines produced be byte aligned,
    // not allowing us to simply position to the correct coordinate, and
    // output the scan line. Instead we must determine the nearest byte
    // aligned starting coordinate, and shift the resulting scan line
    // accordingly. Finally we must output the shifted scan line, in such
    // a way as to not affect the padding area (if possible).
    //

    if (NEED_BYTEALIGN(HTBmpInfo.pPDev)) {

        //
        // Now we must shift either left or right, depending on the rclBmp.left
        // location.
        //

        HTBmpInfo.szlBmp.cx += FullSrc;

        //
        // Determine the correct mask byte to use, so we only affect bits
        // in the original position (not ones we are forced to shift
        // to in order to overcome device positioning limitations.
        //

        MaskIdx   = (UINT)FullSrc;
        MaskBA[0] = (BYTE)((MaskIdx) ? ((0xFF >> MaskIdx) ^ 0xFF) : 0);

        if (MaskIdx = (INT)(HTBmpInfo.szlBmp.cx & 0x07)) {

            //
            // Increase cx so that it covers the last full byte, this way the
            // compression will not try to clear it
            //

            MaskBA[1]            = (BYTE)(0xFF >> MaskIdx);
            HTBmpInfo.szlBmp.cx += (8 - MaskIdx);

        } else {

            MaskBA[1] = 0;
        }

        if (HTBmpInfo.Flags & HTBIF_BA_PAD_1) {

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=1: OR %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));

        } else {

            MaskBA[0] ^= 0xFF;
            MaskBA[1] ^= 0xFF;

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=0: AND %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));
        }

    } else {

        HTBmpInfo.Flags &= ~(HTBIF_MONO_BA);
        MaskBA[0]        =
        MaskBA[1]        = 0xFF;
    }

    //
    // If we are shifting to the left then we might have SRC BYTES <= DST BYTES
    // so we need to make sure we do not read the extra byte.
    // This guarantees we will never OVERREAD the source.
    //

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cx,
                  HTBmpInfo.szlBmp.cy,
                  TRUE);

    FullSrc = 0;
    MaskIdx = RTLScans.cxBytes - 1;

#if DBG
    if (DBG_PLOTFILENAME & DBG_SHOWSCAN) {

        DBGP(("\n\n"));
    }
#endif


    //
    // Stay in a loop processing the source till we are done.
    //

    while (RTLScans.Flags & RTLSF_MORE_SCAN) {

        FillMemory(pbScanSrc = HTBmpInfo.pScanBuf,
                   RTLScans.cxBytes,
                   FillByte);

        OUT_ONE_1BPP_SCAN;
#if DBG
        SHOW_SCAN;
#endif
    }

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}





BOOL
Output1bppHTBmp(
    PHTBMPINFO  pHTBmpInfo
    )

/*++

Routine Description:

    This function outputs a 1 bpp halftoned bitmap

Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  fuction to output the bitmap

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    Created JB

    21-Dec-1993 Tue 16:05:08 Updated  
        Re-write to make it take HTBMPINFO

    23-Dec-1993 Thu 22:47:45 updated  
        We must check if the source bit 1 is BLACK, if not then we need to
        flip it

    25-Jan-1994 Tue 17:32:36 updated  
        Fixed dwFlipCount mis-computation from DW_ALIGN(cxDestBytes) to
        (DWORD)(DW_ALIGN(7cxDestBytes) >> 2);

    22-Feb-1994 Tue 14:54:42 updated  
        Using RTLScans data structure

    16-Mar-1994 Wed 16:54:59 updated  
        Updated so we do not copy to the temp. buffer anymore, the masking
        of last source byte problem in OutputRTLScans() will be smart enough
        to put the original byte back after the masking


Revision History:


--*/

{
    LPBYTE      pbScanSrc;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    DWORD       FullSrc;
    DWORD       Loop;
    INT         LShift;
    UINT        MaskIdx;
    BYTE        MaskBA[2];



    HTBmpInfo         = *pHTBmpInfo;
    HTBmpInfo.pScan0 += (HTBmpInfo.OffBmp.x >> 3);
    LShift            = (INT)(HTBmpInfo.OffBmp.x & 0x07);
    Loop              = (DWORD)((HTBmpInfo.szlBmp.cx + (LONG)LShift + 7) >> 3);

    if (NEED_BYTEALIGN(HTBmpInfo.pPDev)) {

        //
        // Based on some devices requiring byte aligned coordinates for
        // outputing graphics, we have to handle that situation now.
        // We do this by finding the closest byte aligned position,
        // then shifting, masking and padding to effect the corect pixels
        // on the target device.
        //


        FullSrc              = (INT)(HTBmpInfo.rclBmp.left & 0x07);
        HTBmpInfo.szlBmp.cx += FullSrc;
        LShift              -= FullSrc;

        //
        // Check and compute masking since we are handling the byte align
        // requirement of the target device.
        //

        MaskIdx   = (UINT)FullSrc;
        MaskBA[0] = (BYTE)((MaskIdx) ? ((0xFF >> MaskIdx) ^ 0xFF) : 0);

        if (MaskIdx = (INT)(HTBmpInfo.szlBmp.cx & 0x07)) {

            //
            // Increase cx so that it covers the last byte, this way the
            // compression will not try to clear it
            //

            MaskBA[1]            = (BYTE)(0xFF >> MaskIdx);
            HTBmpInfo.szlBmp.cx += (8 - MaskIdx);

        } else {

            MaskBA[1] = 0;
        }

        if (HTBmpInfo.Flags & HTBIF_BA_PAD_1) {

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=1: OR %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));

        } else {

            MaskBA[0] ^= 0xFF;
            MaskBA[1] ^= 0xFF;

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=0: AND %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));
        }

    } else {

        HTBmpInfo.Flags &= ~(HTBIF_MONO_BA);
        MaskBA[0]        =
        MaskBA[1]        = 0xFF;
    }

    PLOTDBG(DBG_OUTPUT1BPP, ("Output1bppHTBmp: LShift=%d", LShift));

    //
    // If we are shifting to the left then we might have SRC BYTES <= DST BYTES
    // so we need to make sure we do not read the extra byte.
    // This guarantees we will never OVERREAD the source.
    //

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cx,
                  HTBmpInfo.szlBmp.cy,
                  TRUE);

    FullSrc = ((LShift > 0) && (Loop >= RTLScans.cxBytes)) ? 1 : 0;
    MaskIdx = RTLScans.cxBytes - 1;

#if DBG
    if (DBG_PLOTFILENAME & DBG_SHOWSCAN) {

        DBGP(("\n\n"));
    }
#endif

    while (RTLScans.Flags & RTLSF_MORE_SCAN) {

        if (LShift) {

            pbScanSrc = HTBmpInfo.pScan0;

        } else {

            //
            // Make copy if we do not shift it to temp buffer, so we always
            // output from temp buffer
            //

            CopyMemory(pbScanSrc = HTBmpInfo.pScanBuf,
                       HTBmpInfo.pScan0,
                       RTLScans.cxBytes);
        }

        HTBmpInfo.pScan0 += HTBmpInfo.Delta;

        OUT_ONE_1BPP_SCAN;
#if DBG
        SHOW_SCAN;
#endif
    }

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}





BOOL
Output1bppRotateHTBmp(
    PHTBMPINFO  pHTBmpInfo
    )

/*++

Routine Description:

    This function outputs a 1 bpp halftoned bitmap and rotates it to the left
    as illustrated

           cx               Org ---- +X -->
        +-------+           | @------------+
        |       |           | |            |
        | ***** |           | |  *         |
       c|   *   |             |  *        c|
       y|   *   |          +Y |  *******  y|
        |   *   |             |  *         |
        |   *   |           | |  *         |
        |   *   |           V |            |
        |   *   |             +------------+
        +-------+


Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  function to output the bitmap

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    Created JB

    21-Dec-1993 Tue 16:05:08 Updated  
        Re-write to make it take HTBMPINFO

    23-Dec-1993 Thu 22:47:45 updated  
        We must check if the source bit 1 is BLACK, if not then we need to
        flip it, we will flip using DWORD mode and only do it at time we
        have transpos the buffer.

    25-Jan-1994 Tue 17:32:36 updated  
        Fixed dwFlipCount mis-computation from (TPInfo.cbDestScan << 1) to
        (TPInfo.cbDestScan >> 2)

    22-Feb-1994 Tue 14:54:42 updated  
        Using RTLScans data structure

Revision History:


--*/

{
    LPBYTE      pbCurScan;
    LPBYTE      pbScanSrc;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    TPINFO      TPInfo;
    DWORD       FullSrc;
    DWORD       EndX;
    DWORD       Loop;
    INT         LShift;
    UINT        MaskIdx;
    BYTE        MaskBA[2];



    //
    // EndX is the pixel we will start reading from in the X direction. We must
    // setup the varialbe before we call OUT_1BMP_SETUP, also set LShift to 0
    // because we will never left shift in this mode.
    //

    HTBmpInfo         = *pHTBmpInfo;
    EndX              = (DWORD)(HTBmpInfo.OffBmp.x + HTBmpInfo.szlBmp.cx - 1);
    HTBmpInfo.pScan0 += (EndX >> 3);
    LShift            = 0;
    FullSrc           =
    TPInfo.DestXStart = 0;
    TPInfo.cySrc      = HTBmpInfo.szlBmp.cy;


    //
    // Since we are having to rotate anyway, in this model, we will correctly
    // identify the x coordinate to be bytealigned, and have the correct
    // LShift amount after the rotation (taking into account). This way, we
    // don't have to addionally shift.
    //

    if (NEED_BYTEALIGN(HTBmpInfo.pPDev)) {

        //
        // In order for us to start at the correct offset, the TPInfo.DestXStart
        // will be set to the correct location. When we rotate to the right,
        // the original rclBmp.top is the left offset for the RTL coordinate in
        // the target device.
        //

        TPInfo.DestXStart    = (DWORD)(HTBmpInfo.rclBmp.top & 0x07);
        HTBmpInfo.szlBmp.cy += TPInfo.DestXStart;

        //
        // Create the correct mask for the byte aligned mode. This way,
        // we don't affect pixels that fall into the area we send data
        // to in order to take into account the byte aligned position change.
        //

        MaskIdx   = (UINT)TPInfo.DestXStart;
        MaskBA[0] = (BYTE)((MaskIdx) ? ((0xFF >> MaskIdx) ^ 0xFF) : 0);

        if (MaskIdx = (INT)(HTBmpInfo.szlBmp.cy & 0x07)) {

            //
            // Increase cx so that it cover the last full byte, this way the
            // compression in effect will not try to clear it
            //

            MaskBA[1]            = (BYTE)(0xFF >> MaskIdx);
            HTBmpInfo.szlBmp.cy += (8 - MaskIdx);

        } else {

            MaskBA[1] = 0;
        }

        if (HTBmpInfo.Flags & HTBIF_BA_PAD_1) {

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=1: OR %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));

        } else {

            MaskBA[0] ^= 0xFF;
            MaskBA[1] ^= 0xFF;

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=0: AND %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));
        }

    } else {

        HTBmpInfo.Flags &= ~(HTBIF_MONO_BA);
        MaskBA[0]        =
        MaskBA[1]        = 0xFF;
    }

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cy,
                  HTBmpInfo.szlBmp.cx,
                  TRUE);

    MaskIdx           = RTLScans.cxBytes - 1;
    TPInfo.pPDev      = HTBmpInfo.pPDev;
    TPInfo.pSrc       = HTBmpInfo.pScan0;
    TPInfo.pDest      = HTBmpInfo.pRotBuf;
    TPInfo.cbSrcScan  = HTBmpInfo.Delta;
    TPInfo.cbDestScan = DW_ALIGN(RTLScans.cxBytes);

    PLOTASSERT(1, "The RotBuf size is too small (%ld)",
                (DWORD)(TPInfo.cbDestScan << 3) <= HTBmpInfo.cRotBuf,
                                                    HTBmpInfo.cRotBuf);

    //
    // We will always do the first transpose and set the correct pbCurScan
    // first. We will make EndX the loop counter and increment it by one
    // first. We do this because we increment pbCurScan in the inner loop.
    // We use (6 - EndX++) based on the fact we are rotating 90 degrees to the
    // right. The first scan line is EndX == 7 , the second is at EndX == 6 and
    // so forth. We use 6, in order to go back one extra scan line so that the
    // inner loop will do pbCurScan += TPInfo.cbNextScan will cancel the effect
    // the first time around (since we incremented to accomodate). The EndX++
    // is needed for the same reason, since we do an EndX-- in the inner loop.
    //

    //
    // Win64 fix: Increase a pointer with a INT_PTR quantity.
    //
    EndX      &= 0x07;
    pbCurScan  = TPInfo.pDest + (INT_PTR)((6 - (INT_PTR)EndX++) * TPInfo.cbDestScan);

    TransPos1BPP(&TPInfo);

#if DBG
    if (DBG_PLOTFILENAME & DBG_SHOWSCAN) {

        DBGP(("\n\n"));
    }
#endif

    while (RTLScans.Flags & RTLSF_MORE_SCAN) {


        //
        // Do the transpose only if the source goes into the new byte position.
        // After the transpose (right 90 degrees) the TPInfo.pDest now points
        // to the first scan line and TPInfo.pDest + TPInfo.cbDestScan has the
        // 2nd scan line and so forth.
        //

        if (EndX--) {

            //
            // Still not finished the rotated buffer's scan line yet so
            // increment the pbScanSrc to the next scan line
            //

            pbCurScan += TPInfo.cbDestScan;

        } else {

            TransPos1BPP(&TPInfo);

            //
            // Point to the first scan line in the rotated direction by
            // computing correctly by the TRANSPOS function, even if we
            // rotated left.
            //

            EndX      = 7;
            pbCurScan = TPInfo.pDest;
        }

        //
        // Output one 1bpp scan line and handle shift control
        //

        pbScanSrc = pbCurScan;


        OUT_ONE_1BPP_SCAN;
#if DBG
        SHOW_SCAN;
#endif
    }

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\htbmp1.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    htbmp1.h


Abstract:

    This module contains definitions and prototypes for htbmp1.c


Author:

    21-Dec-1993 Tue 21:33:43 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _HTBMP1BPP_
#define _HTBMP1BPP_


BOOL
FillRect1bppBmp(
    PHTBMPINFO  pHTBmpInfo,
    BYTE        FillByte,
    BOOL        Pad1,
    BOOL        Rotate
    );

BOOL
Output1bppHTBmp(
    PHTBMPINFO  pHTBmpInfo
    );

BOOL
Output1bppRotateHTBmp(
    PHTBMPINFO  pHTBmpInfo
    );



#endif  // _HTBMP1BPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\htbmp4.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    htbmp4.h


Abstract:

    This module contains prototypes and definitions for htbmp4.c


Author:

    21-Dec-1993 Tue 21:33:43 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _HTBMP4BPP_
#define _HTBMP4BPP_


BOOL
Output4bppHTBmp(
    PHTBMPINFO  pHTBmpInfo
    );

BOOL
Output4bppRotateHTBmp(
    PHTBMPINFO  pHTBmpInfo
    );



#endif  // _HTBMP4BPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\output.c ===
/*++


Copyright (c) 1990-2003 Microsoft Corporation


Module Name:

    output.c


Abstract:

    This module contains common plotter output functions to the spooler and
    printer.


Author:


    15-Nov-1993 Mon 19:36:04 updatee  
        clean up / update / re-write / debugging information

    30-Nov-1993 Tue 19:47:16 updated  
        update coordinate system during send_page

    21-Dec-1993 Tue 15:49:10 updated  
        organizied, and restructre pen cache, remove SendDefaultPalette()

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgOutput

#define DBG_SENDTRAILER     0x00000001
#define DBG_FLUSHBUF        0x00000002
#define DBG_FINDCACHEDPEN   0x00000004
#define DBG_CREATEPAL       0x00000008
#define DBG_FILLTYPE        0x00000010
#define DBG_PENUM           0x00000020
#define DBG_GETFINALCOLOR   0x00000040
#define DBG_SETCLIPWINDOW   0x00000080
#define DBG_OUTPUTXYPARMS   0x00000100
#define DBG_PAGE_HEADER     0x00000200
#define DBG_BESTPEN         0x00000400
#define DBG_BESTPEN_ALL     0x00000800


DEFINE_DBGVAR(0);

#define MIN_POSTER_SIZE     (1024L * 1024L * 12L)

#if DBG

static LPSTR    pHSFillTypeName[] = {

            "HS_HORIZONTAL",
            "HS_VERTICAL",
            "HS_FDIAGONAL",
            "HS_BDIAGONAL",
            "HS_CROSS",
            "HS_DIAGCROSS",
            "HS_SOLIDCLR",
            "HS_FT_USER_DEFINED"
        };

#endif

//
// Local #defines and data structures only used in this file
//
// Define, GDI fill types and the HPGL2 code used to simulate them
//

static const LPSTR  pHSFillType[] = {

            "3,#d,0",           // HS_HORIZONTAL       0    /* ----- */
            "3,#d,90",          // HS_VERTICAL         1    /* ||||| */
            "3,#d,135",         // HS_FDIAGONAL        2    /* \\\\\ */
            "3,#d,45",          // HS_BDIAGONAL        3    /* ///// */
            "4,#d,0",           // HS_CROSS            4    /* +++++ */
            "4,#d,45",          // HS_DIAGCROSS        5    /* xxxxx */
            "" ,                // HS_SOLIDCLR         6
            "11,#d",            // HS_FT_USER_DEFINED  7
        };

//
// HTPal tells the engine what formats we support for halftoning
//
// ulHTOutputFormat  = HT_FORMAT_4BPP
// ulPrimaryOrder    = PRIMARY_ORDER_CBA
// flHTFlags        &= ~HT_FLAG_OUTPUT_CMY
//

PALENTRY   HTPal[] = {

    //
    //       B     G     R     F
    //-----------------------------
        { 0x00, 0x00, 0x00, 0x00 },     // 0:K
        { 0x00, 0x00, 0xFF, 0x00 },     // 1:R
        { 0x00, 0xFF, 0x00, 0x00 },     // 2:G
        { 0x00, 0xFF, 0xFF, 0x00 },     // 3:Y
        { 0xFF, 0x00, 0x00, 0x00 },     // 4:B
        { 0xFF, 0x00, 0xFF, 0x00 },     // 5:M
        { 0xFF, 0xFF, 0x00, 0x00 },     // 6:C
        { 0xFF, 0xFF, 0xFF, 0x00 }      // 7:W
    };


//
// Define the RGB colors for the pen indices.  see inc\plotgpc.h for color
// assignment for the each PC_IDX_XXXX
//


PALENTRY    PlotPenPal[PC_IDX_TOTAL] = {

    //
    //      B   G   R  F
    //------------------------------------------
        { 255,255,255, 0 },     // PC_IDX_WHITE
        {   0,  0,  0, 0 },     // PC_IDX_BLACK
        {   0,  0,255, 0 },     // PC_IDX_RED
        {   0,255,  0, 0 },     // PC_IDX_GREEN
        {   0,255,255, 0 },     // PC_IDX_YELLOW
        { 255,  0,  0, 0 },     // PC_IDX_BLUE
        { 255,  0,255, 0 },     // PC_IDX_MAGENTA
        { 255,255,  0, 0 },     // PC_IDX_CYAN
        {   0,128,255, 0 },     // PC_IDX_ORANGE
        {   0,192,255, 0 },     // PC_IDX_BROWN
        { 255,  0,128, 0 }      // PC_IDX_VIOLET
    };

#define PE_BASE_BITS            6
#define PE_BASE_NUM             (DWORD)(1 << PE_BASE_BITS)
#define PE_TERM_ADDER           ((PE_BASE_NUM * 3) - 1)


#define DEF_FORMATSTR_CHAR      '#'
#define TOTAL_LOCKED_PENS       COUNT_ARRAY(HTPal)
#define PEF_CACHE_LOCKED        0x01


typedef struct _PENENTRY {
    WORD        Next;
    WORD        PenNumber;
    PALENTRY    PalEntry;
    } PENENTRY, FAR *PPENENTRY;

#define PCF_HAS_LOCKED_PENS     0x01

typedef struct _PENCACHE {
    WORD        Head;
    BYTE        Flags;
    BYTE        peFlags;
    WORD        CurCount;
    WORD        MaxCount;
    PENENTRY    PenEntries[1];
    } PENCACHE, FAR *PPENCACHE;

#define INTENSITY(r,g,b)        (BYTE)(((WORD)((r) * 30) +      \
                                        (WORD)((g) * 59) +      \
                                        (WORD)((b) * 11)) / 100)

#define SAME_PPALENTRY(p1,p2)   (((p1)->R == (p2)->R) &&        \
                                 ((p1)->G == (p2)->G) &&        \
                                 ((p1)->B == (p2)->B))



BYTE    HPRGBGamma2p0[] = {

              0,  //   0
             16,  //   1
             23,  //   2
             28,  //   3
             32,  //   4
             36,  //   5
             39,  //   6
             42,  //   7
             45,  //   8
             48,  //   9
             50,  //  10
             53,  //  11
             55,  //  12
             58,  //  13
             60,  //  14
             62,  //  15
             64,  //  16
             66,  //  17
             68,  //  18
             70,  //  19
             71,  //  20
             73,  //  21
             75,  //  22
             77,  //  23
             78,  //  24
             80,  //  25
             81,  //  26
             83,  //  27
             84,  //  28
             86,  //  29
             87,  //  30
             89,  //  31
             90,  //  32
             92,  //  33
             93,  //  34
             94,  //  35
             96,  //  36
             97,  //  37
             98,  //  38
            100,  //  39
            101,  //  40
            102,  //  41
            103,  //  42
            105,  //  43
            106,  //  44
            107,  //  45
            108,  //  46
            109,  //  47
            111,  //  48
            112,  //  49
            113,  //  50
            114,  //  51
            115,  //  52
            116,  //  53
            117,  //  54
            118,  //  55
            119,  //  56
            121,  //  57
            122,  //  58
            123,  //  59
            124,  //  60
            125,  //  61
            126,  //  62
            127,  //  63
            128,  //  64
            129,  //  65
            130,  //  66
            131,  //  67
            132,  //  68
            133,  //  69
            134,  //  70
            135,  //  71
            135,  //  72
            136,  //  73
            137,  //  74
            138,  //  75
            139,  //  76
            140,  //  77
            141,  //  78
            142,  //  79
            143,  //  80
            144,  //  81
            145,  //  82
            145,  //  83
            146,  //  84
            147,  //  85
            148,  //  86
            149,  //  87
            150,  //  88
            151,  //  89
            151,  //  90
            152,  //  91
            153,  //  92
            154,  //  93
            155,  //  94
            156,  //  95
            156,  //  96
            157,  //  97
            158,  //  98
            159,  //  99
            160,  // 100
            160,  // 101
            161,  // 102
            162,  // 103
            163,  // 104
            164,  // 105
            164,  // 106
            165,  // 107
            166,  // 108
            167,  // 109
            167,  // 110
            168,  // 111
            169,  // 112
            170,  // 113
            170,  // 114
            171,  // 115
            172,  // 116
            173,  // 117
            173,  // 118
            174,  // 119
            175,  // 120
            176,  // 121
            176,  // 122
            177,  // 123
            178,  // 124
            179,  // 125
            179,  // 126
            180,  // 127
            181,  // 128
            181,  // 129
            182,  // 130
            183,  // 131
            183,  // 132
            184,  // 133
            185,  // 134
            186,  // 135
            186,  // 136
            187,  // 137
            188,  // 138
            188,  // 139
            189,  // 140
            190,  // 141
            190,  // 142
            191,  // 143
            192,  // 144
            192,  // 145
            193,  // 146
            194,  // 147
            194,  // 148
            195,  // 149
            196,  // 150
            196,  // 151
            197,  // 152
            198,  // 153
            198,  // 154
            199,  // 155
            199,  // 156
            200,  // 157
            201,  // 158
            201,  // 159
            202,  // 160
            203,  // 161
            203,  // 162
            204,  // 163
            204,  // 164
            205,  // 165
            206,  // 166
            206,  // 167
            207,  // 168
            208,  // 169
            208,  // 170
            209,  // 171
            209,  // 172
            210,  // 173
            211,  // 174
            211,  // 175
            212,  // 176
            212,  // 177
            213,  // 178
            214,  // 179
            214,  // 180
            215,  // 181
            215,  // 182
            216,  // 183
            217,  // 184
            217,  // 185
            218,  // 186
            218,  // 187
            219,  // 188
            220,  // 189
            220,  // 190
            221,  // 191
            221,  // 192
            222,  // 193
            222,  // 194
            223,  // 195
            224,  // 196
            224,  // 197
            225,  // 198
            225,  // 199
            226,  // 200
            226,  // 201
            227,  // 202
            228,  // 203
            228,  // 204
            229,  // 205
            229,  // 206
            230,  // 207
            230,  // 208
            231,  // 209
            231,  // 210
            232,  // 211
            233,  // 212
            233,  // 213
            234,  // 214
            234,  // 215
            235,  // 216
            235,  // 217
            236,  // 218
            236,  // 219
            237,  // 220
            237,  // 221
            238,  // 222
            238,  // 223
            239,  // 224
            240,  // 225
            240,  // 226
            241,  // 227
            241,  // 228
            242,  // 229
            242,  // 230
            243,  // 231
            243,  // 232
            244,  // 233
            244,  // 234
            245,  // 235
            245,  // 236
            246,  // 237
            246,  // 238
            247,  // 239
            247,  // 240
            248,  // 241
            248,  // 242
            249,  // 243
            249,  // 244
            250,  // 245
            250,  // 246
            251,  // 247
            251,  // 248
            252,  // 249
            252,  // 250
            253,  // 251
            253,  // 252
            254,  // 253
            254,  // 254
            255   // 255
        };




LONG
BestMatchNonWhitePen(
    PPDEV   pPDev,
    LONG    R,
    LONG    G,
    LONG    B
    )

/*++

Routine Description:

    This functions locates the best match of a current pen given an RGB color.

Arguments:

    pPDev       - Pointer to our PDEV

    R           - Red color

    G           - Green color

    B           - Blue color

Return Value:

    LONG        - Pen Index, this function assumes 0 is always white and 1
                  up to the max are the rest of the pens.
Author:

    08-Feb-1994 Tue 00:23:36 created  

    23-Jun-1994 Thu 14:00:00 updated  
        Updated for non-white pen match

Revision History:


--*/

{
    PPENDATA    pPenData;
    PALENTRY    PenPalEntry;
    LONG        LeastDiff;
    WORD        ColorIdx;
    UINT        Count;
    UINT        RetIdx;
    UINT        i;

    PLOTDBGBLK(PALENTRY RetPal)



    if (IS_RASTER(pPDev)) {

        PLOTASSERT(0, "BestMatchNonWhitePen: This is not PEN plotter",
                !IS_RASTER(pPDev), 0);

        return(0);
    }

    if (!(pPenData = (PPENDATA)pPDev->pPlotGPC->Pens.pData)) {

        PLOTWARN(("BestMatchNonWhitePen: pPlotGPC->Pens.pData=NULL"));

        return(0);
    }

    if (!(Count = (UINT)pPDev->pPlotGPC->Pens.Count)) {

        PLOTWARN(("BestMatchNonWhitePen: pPlotGPC->Pens.Count=0"));
        return(0);
    }

    PLOTDBGBLK(RetPal.R = 255)
    PLOTDBGBLK(RetPal.G = 255)
    PLOTDBGBLK(RetPal.B = 255)

    RetIdx    = 0;
    LeastDiff = (3 * (256 * 256));

    for (i = 1; i < Count; i++, pPenData++) {

        if (((ColorIdx = pPenData->ColorIdx) < PC_IDX_TOTAL)    &&
            (ColorIdx != PC_IDX_WHITE)) {

            LONG    Temp;
            LONG    Diff;


            PenPalEntry = PlotPenPal[ColorIdx];

            Temp        = R - (LONG)((DWORD)PenPalEntry.R);
            Diff        = Temp * Temp;

            Temp        = G - (LONG)((DWORD)PenPalEntry.G);
            Diff       += Temp * Temp;

            Temp        = B - (LONG)((DWORD)PenPalEntry.B);
            Diff       += Temp * Temp;

            PLOTDBG(DBG_BESTPEN_ALL,
                    ("BestMatchNonWhitePen: %2ld: (%03ld:%03ld:%03ld) DIF=%ld",
                        i, (DWORD)PenPalEntry.R, (DWORD)PenPalEntry.G,
                        (DWORD)PenPalEntry.B, Diff));

            if (Diff < LeastDiff) {

                RetIdx = i;

                PLOTDBGBLK(RetPal = PenPalEntry)

                if (!(LeastDiff = Diff)) {

                    //
                    // We have exact match
                    //

                    break;
                }
            }
        }
    }

    if (!RetIdx) {

        PLOTWARN(("BestMatchNonWhitePen: Cannot find one make it WHITE"));
    }

    PLOTDBG(DBG_BESTPEN,
            ("BestMatchNonWhitePen: RGB=%02lx:%02lx:%02lx [%ld/%ld]=%02lx:%02lx:%02lx",
            R, G, B,
            (LONG)RetIdx, (LONG)pPDev->pPlotGPC->Pens.Count,
            (LONG)RetPal.R,
            (LONG)RetPal.G,
            (LONG)RetPal.B));

    return((LONG)RetIdx);
}




VOID
GetFinalColor(
    PPDEV       pPDev,
    PPALENTRY   pPalEntry
    )

/*++

Routine Description:

    This function modifies the input RGB color based on Grayscale and GAMMA

Arguments:

    pPDev       - Our PDEV

    pPalEntry   - Pointer to the PALENTRY of interest


Return Value:

    VOID but pPalEntry will be modified


Author:

    12-Apr-1994 Tue 14:03:37 created  


Revision History:


--*/

{
    PALENTRY    PalEntry = *pPalEntry;


    //
    // Do Gamma correction first
    //

    PalEntry.R = HPRGBGamma2p0[PalEntry.R];
    PalEntry.G = HPRGBGamma2p0[PalEntry.G];
    PalEntry.B = HPRGBGamma2p0[PalEntry.B];

    //
    // If were in GRAYSCALE mode we need to convert the color to grayscale
    //

    if (pPDev->PlotDM.dm.dmColor != DMCOLOR_COLOR) {

        PalEntry.R =
        PalEntry.G =
        PalEntry.B = (BYTE)INTENSITY(PalEntry.R, PalEntry.G, PalEntry.B);
    }

    PLOTDBG(DBG_GETFINALCOLOR,
            ("GetFinalColor: %hs RGB=%03ld:%03ld:%03ld -> Gamma=%03ld:%03ld:%03ld",
            (pPDev->PlotDM.dm.dmColor != DMCOLOR_COLOR) ? "MONO" : "COLOR",
            (DWORD)pPalEntry->R, (DWORD)pPalEntry->G, (DWORD)pPalEntry->B,
            (DWORD)PalEntry.R, (DWORD)PalEntry.G, (DWORD)PalEntry.B));

    //
    // Save it back and return
    //

    *pPalEntry = PalEntry;
}




LONG
FindCachedPen(
    PPDEV       pPDev,
    PPALENTRY   pPalEntry
    )

/*++

Routine Description:

    This function searhes the PenCache and returns the pen number if it is
    found. If it is not found, it will add the new pen to the cache and
    delete one if needed. Finally it returns the pen back to the caller.

Arguments:

    pPDev       - Pointer to the device PDEV

    pPalEntry   - Pointer to the PALENTRY for the specified RGB to locate.

Return Value:

    DWORD - a Pen number, if an error occurred  0 is returned

Author:

    21-Dec-1993 Tue 12:42:31 updated  
        re-write to make it as one pass search and adding. and commented

    30-Nov-1993 Tue 23:19:04 created  


Revision History:


--*/

{
    PPENCACHE   pPenCache;
    PPENENTRY   pPenStart;
    PPENENTRY   pCurPen;
    PPENENTRY   pPrevPen;
    PPENENTRY   pPrevDelPen;
    PALENTRY    PalEntry;
    LONG        Count;


    PLOTASSERT(1, "FindCahcedPen: The pPalEntry = NULL", pPalEntry, 0);


    if (!IS_RASTER(pPDev)) {

        //
        // Since this is the index type of palette, the PalEntry should be
        // also passed as index in the BGR's B component
        //

        Count = (LONG)RGB(pPalEntry->B, pPalEntry->G, pPalEntry->R);

        PLOTDBG(DBG_FINDCACHEDPEN, ("FindCachedPen: PEN PLOTTER=%ld", Count));

        if (Count > (LONG)((DWORD)pPDev->pPlotGPC->Pens.Count)) {

            PLOTERR(("FindCachedPen: INVALID Pen Color Index = %ld, Set to 1",
                    Count));

            Count = 1;
        }

        return(Count);
    }

    //
    // If we dont have a pen cache, nothing we can do but return an error.
    //

    if (!(pPenCache = (PPENCACHE)pPDev->pPenCache)) {

        PLOTERR(("FindCahcedPen: The pPenCache=NULL?"));
        return(0);
    }

    //
    // Make sure we set the flag correctly, the current PENENTRY flag is
    // located in peFlags field
    //

    PalEntry       = *pPalEntry;
    PalEntry.Flags = pPenCache->peFlags;

    //
    // Convert to final color through gamma/gray scale
    //

    GetFinalColor(pPDev, &PalEntry);

    pPenStart   = &(pPenCache->PenEntries[0]);
    pCurPen     = pPenStart + pPenCache->Head;
    pPrevPen    =
    pPrevDelPen = NULL;
    Count       = (LONG)pPenCache->CurCount;

    while (Count--) {

        if (SAME_PPALENTRY(&(pCurPen->PalEntry), &PalEntry)) {

            PLOTDBG(DBG_FINDCACHEDPEN,
                    ("FindCachedPen: Found Pen #%ld=%02lx:%02lx:%02lx, Linkes=%ld",
                            (DWORD)pCurPen->PenNumber,
                            (DWORD)PalEntry.R,
                            (DWORD)PalEntry.G,
                            (DWORD)PalEntry.B,
                            (DWORD)(pPenCache->CurCount - Count)));

            //
            // Found the color for that pen, exit this loop since we are done.
            //

            break;
        }

        //
        // Keep track of a pen that makes sense to delete in case we need
        // to delete an entry in order to add the new one that is not found.
        // If the entry was used for something longer term, it would be locked
        // and thus would not be a candidate for removal.
        //

        if (!(pCurPen->PalEntry.Flags & PEF_CACHE_LOCKED)) {

            //
            // If this pen is not locked then it must ok to delete if we need to
            //

            pPrevDelPen = pPrevPen;
        }

        pPrevPen = pCurPen;
        pCurPen  = pPenStart + pCurPen->Next;
    }

    //
    // If Count != -1 then we must have found a match, so we are done.
    //

    if (Count == -1) {

        //
        // We did not find the pen, so add it to the cache, remember if the
        // cache is full we must delete the last UNLOCKED entry
        //

        if (pPenCache->CurCount >= pPenCache->MaxCount) {

            //
            // Now delete the last un-locked entry, and add the new item to
            // that deleted entry
            //

            if (!(pPrevPen = pPrevDelPen)) {

                //
                // This is very strange, the last unlocked is the head?, this
                // is only possible if we have MaxCount = TOTAL_LOCKED_PENS + 1
                //

                PLOTDBG(DBG_FINDCACHEDPEN, ("FindCachedPen: ??? Last unlocked pen is Linked List Head"));

                pCurPen = pPenStart + pPenCache->Head;

            } else {

                pCurPen = pPenStart + pPrevPen->Next;
            }

            PLOTASSERT(1, "Pen #%ld is a LOCKED pen",
                        !(pCurPen->PalEntry.Flags & PEF_CACHE_LOCKED),
                        (DWORD)pCurPen->PenNumber);

            PLOTDBG(DBG_FINDCACHEDPEN,
                    ("FindCachedPen: REPLACE Pen #%ld=%02lx:%02lx:%02lx -> %02lx:%02lx:%02lx [%ld]",
                        (DWORD)pCurPen->PenNumber,
                        (DWORD)pCurPen->PalEntry.R, (DWORD)pCurPen->PalEntry.G,
                        (DWORD)pCurPen->PalEntry.B,
                        (DWORD)PalEntry.R, (DWORD)PalEntry.G, (DWORD)PalEntry.B,
                        (DWORD)(pCurPen - pPenStart)));
        } else {

            //
            // Increment the cached pen count
            //

            ++(pPenCache->CurCount);

            PLOTDBG(DBG_FINDCACHEDPEN,
                    ("FindCachedPen: ADD New Pen #%ld=%02lx:%02lx:%02lx [%ld/%ld]",
                        (DWORD)pCurPen->PenNumber,
                        (DWORD)PalEntry.R, (DWORD)PalEntry.G, (DWORD)PalEntry.B,
                        pPenCache->CurCount, pPenCache->MaxCount));
        }

        //
        // set the pen color in the cache and output the commands to the
        // plotter to add or change the current pen color setting
        //

        pCurPen->PalEntry = PalEntry;

        OutputFormatStr(pPDev, "PC#d,#d,#d,#d;", (LONG)pCurPen->PenNumber,
                        (LONG)PalEntry.R, (LONG)PalEntry.G, (LONG)PalEntry.B);
    }

    //
    // Now move the pCurPen to the head of the linked list
    //

    if (pPrevPen) {

        //
        // Only move the current pen to the link list head if not already so
        //

        PLOTDBG(DBG_FINDCACHEDPEN,
                ("FindCachedPen: MOVE Pen #%ld to Linked List Head [%ld --> %ld]",
                                (DWORD)pCurPen->PenNumber,
                                (DWORD)pPenCache->Head,
                                (DWORD)(pCurPen - pPenStart)));

        pPrevPen->Next  = pCurPen->Next;
        pCurPen->Next   = pPenCache->Head;
        pPenCache->Head = (WORD)(pCurPen - pPenStart);
    }

    return(pCurPen->PenNumber);
}




BOOL
PlotCreatePalette(
    PPDEV   pPDev
    )

/*++

Routine Description:


    This function creates a pen cache. It initializes the cache accordingly

Arguments:

    pPDev   - Pointer to the PDEV

Return Value:


    BOOL to indicate operation


Author:

    30-Nov-1993 Tue 23:23:17 created  

    21-Dec-1993 Tue 12:40:30 updated  
        Simplify version re-write

    23-Dec-1993 Thu 20:16:52 updated  
        Add NP number of pens command back to be able to use HPGL/2 palette


Revision History:


--*/

{
    if (!pPDev->pPlotGPC->MaxPens) {

        PLOTWARN(("PlotCreatePalette: Device MaxPens = 0"));

    } else if (IS_RASTER(pPDev)) {

        PPENCACHE   pPenCache;
        PPENENTRY   pPenEntry;
        DWORD       dw;
        UINT        Index;

        //
        // If this is the first time around then go ahead and alloc the memory
        // for our pen pallete cache. If the memory is already allocated then
        // we don't need to worry about it.
        //

        PLOTASSERT(1, "PlotCreatePalette: device has too few pens [%ld] available",
                        pPDev->pPlotGPC->MaxPens > TOTAL_LOCKED_PENS,
                        (DWORD)pPDev->pPlotGPC->MaxPens);

        dw = (DWORD)(sizeof(PENCACHE) +
                     sizeof(PENENTRY) * (pPDev->pPlotGPC->MaxPens - 1));

        if (pPDev->pPenCache == NULL) {

            PLOTDBG(DBG_CREATEPAL, ("PlotCreatePalette: Create NEW Palette"));

            pPDev->pPenCache = (LPVOID)LocalAlloc(LPTR, dw);

        } else {

            PLOTDBG(DBG_CREATEPAL, ("PlotCreatePalette: Re-Initialized Palette"));
        }

        if (pPenCache = (PPENCACHE)pPDev->pPenCache) {

            //
            // 1. Clear everything to zero
            // 2. Set MaxCount to the amount specified in the GPC
            // 3. Initialize the whole linked list as a linear list with
            //    the pen number set
            // 4. Make last index link to 0xffff to prevent us from using it
            //

            ZeroMemory(pPenCache, dw);

            pPenCache->MaxCount = (WORD)pPDev->pPlotGPC->MaxPens;

            for (Index = 0, pPenEntry = &(pPenCache->PenEntries[0]);
                 Index < (UINT)pPenCache->MaxCount;
                 Index++, pPenEntry++) {

                pPenEntry->Next      = (WORD)(Index + 1);
                pPenEntry->PenNumber = (WORD)Index;
            }

            pPenCache->PenEntries[pPenCache->MaxCount-1].Next = (WORD)0xffff;

            //
            // Before we add any pen palette we will establish the size of the
            // HPGL/2 Pen palette, and reset every pen back to our
            // standard which is used by gdi and the halftone Eng. (= 0.26mm wide)
            //

            OutputFormatStr(pPDev, "NP#d", (LONG)pPenCache->MaxCount);


            //
            // Now, add the entries we know we must keep around and make sure
            // they get locked.
            //

            PLOTDBG(DBG_CREATEPAL,
                    ("PlotCreatePalette: add all %ld standard locked pens",
                                                            TOTAL_LOCKED_PENS));

            pPenCache->peFlags = PEF_CACHE_LOCKED;

            for (Index = 0; Index < (LONG)TOTAL_LOCKED_PENS; Index++) {

                FindCachedPen(pPDev, (PPALENTRY)&HTPal[Index]);
            }


            //
            // Now set the flag telling us the cache contains locked pens, and
            // unlock the cache.
            //

            pPenCache->Flags   |= PCF_HAS_LOCKED_PENS;
            pPenCache->peFlags  = 0;

        } else {

            PLOTERR(("PlotCreatePalette: LocalAlloc(PENCACHE=%ld) failed", dw));
            return(FALSE);
        }

    } else {

        pPDev->BrightestPen = BestMatchNonWhitePen(pPDev, 255, 255, 255);

        PLOTDBG(DBG_CREATEPAL,
                ("PlotCreatePalette: Pen Plotter's Closest NON-WHITE PEN Index=ld",
                pPDev->BrightestPen));
    }

    return(TRUE);
}




UINT
AllocOutBuffer(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function allocates a buffer to be used for caching output data
    specific to this job. This keeps us from making calls to EngWritePrinter
    with very small amounts of data.

Arguments:

    pPDev   - Pointer to our pdev


Return Value:

    UINT count of how many bytes were allocated. If the buffer was already
    allocated, return the size. If an error occured (allocating memory)
    return 0.

Author:

    16-Nov-1993 Tue 07:39:46 created  


Revision History:


--*/

{
    if ((!(pPDev->pOutBuffer)) &&
        (!(pPDev->pOutBuffer = (LPBYTE)LocalAlloc(LPTR,
                                                  OUTPUT_BUFFER_SIZE + 16)))) {

        PLOTERR(("CreateOutputBuffer: LocalAlloc(OutBuffer=%ld) failed",
                                                        OUTPUT_BUFFER_SIZE));
        return(0);
    }

    pPDev->cbBufferBytes = 0;

    return(OUTPUT_BUFFER_SIZE);
}




VOID
FreeOutBuffer(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function frees the allocated output buffer

Arguments:

    pPDev   - pointer to the PDEV


Return Value:

    VOID


Author:

    16-Nov-1993 Tue 07:46:16 created  


Revision History:


--*/

{
    if (pPDev->pOutBuffer) {

        LocalFree((HLOCAL)pPDev->pOutBuffer);
        pPDev->pOutBuffer = NULL;
    }

    pPDev->cbBufferBytes = 0;
}





BOOL
FlushOutBuffer(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function flushes the current contents of the output buffer by writing
    the contents to the target device via EngWritePrinter.

Arguments:

    pPDev   - Pointer to the PDEV


Return Value:

    BOOL to indicate the result (TRUE == success)


Author:

    16-Nov-1993 Tue 09:56:27 created  


Revision History:

    14-Sep-1999 Tue 17:36:08 updated  
        Remove Checking for EngAbort(), this check in user mode will somehow
        return true at end of job and cause all output got cut off.

--*/

{
    if (PLOT_CANCEL_JOB(pPDev)) {

       return(FALSE);
    }

    if (pPDev->cbBufferBytes) {

        DWORD cbWritten;


        if (pPDev->cbBufferBytes > OUTPUT_BUFFER_SIZE) {

            PLOTASSERT(1, "OutputBytes: pPDev->cbBufferBytes (%ld) OVERRUN",
                        pPDev->cbBufferBytes <= OUTPUT_BUFFER_SIZE,
                        pPDev->cbBufferBytes);

            pPDev->cbBufferBytes  = OUTPUT_BUFFER_SIZE;
            pPDev->Flags         |= PDEVF_CANCEL_JOB;

            return(FALSE);
        }

        //
        // We need to be concerned with the job getting cancelled from
        // either the app or the spooler.
        // If the job is cancelled from the client app and we were printing
        // direct then EngCheckAbort() should return true.
        // If the job was cancelled from the spooler (ie printman) then
        // the write printer will fail.
        // Anywhere we do prolonged processing we need to look and verify
        // we break out of any loop if the job is cancelled. Currently
        // we do this in OutputBitmapSection, DoPolygon, DoRectFill, and
        // DrvTextOut when we are enuming our STROBJ glyphs
        //

        if ((!WritePrinter(pPDev->hPrinter,
                              pPDev->pOutBuffer,
                              pPDev->cbBufferBytes,
                              &cbWritten)) ||
            (cbWritten != pPDev->cbBufferBytes)) {

            //
            // Set the cancel flag in our pdev;
            //

            PLOTDBG(DBG_FLUSHBUF, ("FlushOutBuffer: WritePrinter() failure"));

            pPDev->Flags |= PDEVF_CANCEL_JOB;
            return(FALSE);
        }
#if 0
        if (EngCheckAbort(pPDev->pso)) {

            PLOTDBG(DBG_FLUSHBUF, ("FlushOutBuffer: EngCheckAbort return TRUE"));

            pPDev->Flags |= PDEVF_CANCEL_JOB;
            return(FALSE);
        }
#endif
        //
        // Reset to zero for clearing the buffer
        //

        pPDev->cbBufferBytes = 0;
    }

    return(TRUE);
}





LONG
OutputBytes(
    PPDEV   pPDev,
    LPBYTE  pBuf,
    LONG    cBuf
    )

/*++

Routine Description:

    This function output cBuf bytes from pBuf, by copying them into the
    output buffer (and flushing if required).

Arguments:

    pPDev   - Pointer to the PDEV

    pBuf    - Pointer to the buffer location

    cBuf    - Size of the buffer in bytes

Return Value:

    LONG    size of the buffer output, if < 0 then error occurred


Author:

    16-Nov-1993 Tue 08:18:41 created  

    07-Dec-1993 Tue 17:21:53 updated  
        re-write, so it do bulk copy rather than byte by byte

Revision History:


--*/

{
    LPBYTE  pOrgBuf = pBuf;
    LONG    cSize;


    while (cBuf > 0) {

        if (PLOT_CANCEL_JOB(pPDev)) {

            return(-1);
        }

        if (pPDev->cbBufferBytes >= OUTPUT_BUFFER_SIZE) {

            if (!FlushOutBuffer(pPDev)) {

                return(-1);
            }
        }

        if ((cSize = OUTPUT_BUFFER_SIZE - pPDev->cbBufferBytes) > cBuf) {

            cSize = cBuf;
        }

        CopyMemory(pPDev->pOutBuffer + pPDev->cbBufferBytes, pBuf, cSize);

        pPDev->cbBufferBytes += cSize;
        pBuf                 += cSize;
        cBuf                 -= cSize;
    }

    return((LONG)(pBuf - pOrgBuf));
}




LONG
OutputString(
    PPDEV   pPDev,
    LPSTR   pszStr
    )

/*++

Routine Description:


    This function outputs a null terminated string to the destination buffer

Arguments:

    pPDev   - Pointer to the PDEV

    pszStr  - Pointer to the NULL terminated string


Return Value:

    LONG    size of the string output, if < 0 then error occurred

Author:

    16-Nov-1993 Tue 08:20:55 created  

    07-Dec-1993 Tue 17:21:37 updated  
        re-write to call OutputBytes()

Revision History:


--*/

{
    return(OutputBytes(pPDev, pszStr, strlen(pszStr)));
}





LONG
LONGToASCII(
    LONG    Number,
    LPSTR   pStr16,
    size_t  cchStr16,
    BYTE    NumType
    )

/*++

Routine Description:

    This function convert a LONG number to ANSI ASCII

Arguments:

    Number  - 32-bit LONG number

    pStr16  - minimum 12 bytes to store the converted result


Return Value:

    LONG    - size of number string returned


Author:

    16-Nov-1993 Tue 08:24:07 created  

    16-Feb-1994 Wed 10:50:55 updated  
        Updated so upper case character treated as polyline encoded mode

Revision History:


--*/

{
    LPSTR   pOrgStr = pStr16;
    size_t  cchOrgStr = cchStr16;
    LPSTR   pNumStr;
    BYTE    NumStr[16];         // maximum for LONG are 1 sign + 10 digits


    if ((NumType >= 'A') && (NumType <= 'Z')) {

        //
        // Polyline encoded number
        //

        PLOTDBG(DBG_PENUM,  ("LONGToASCII: Convert PE Number %ld, Base=%ld",
                                    Number, PE_BASE_NUM));

        if (Number < 0) {

            Number = 1 - Number - Number;

        } else {

            Number += Number;
        }

        while (Number >= PE_BASE_NUM) {

            if (cchStr16 > 0)
            {
                *pStr16++   = (BYTE)(63 + (Number & (PE_BASE_NUM - 1)));
                cchStr16--;
            }
            else
            {
                return 0;
            }

            Number    >>= PE_BASE_BITS;
        }

        if (cchStr16 > 0)
        {
            *pStr16++ = (BYTE)(PE_TERM_ADDER + Number);
            cchStr16--;
        }
        else
        {
            return 0;
        }

        PLOTDBG(DBG_PENUM, ("LONGToASCII: LAST DIGIT: Number=%ld, [%02lx]",
                                Number, Number + PE_TERM_ADDER));


    } else {

        if (Number < 0) {

            Number    = -Number;
            if (cchStr16 > 0)
            {
                *pStr16++ = '-';
                cchStr16--;
            }
            else
            {
                return 0;
            }
        }

        pNumStr = NumStr;

        do {

            *pNumStr++ =  (CHAR)((Number % 10) + '0');

        } while (Number /= 10);

        //
        // Now reverse the digits
        //

        while (pNumStr > NumStr && cchStr16--) {

            *pStr16++ = *(--pNumStr);
        }
    }

    if (cchStr16 == 0)
    {
        pStr16 = pOrgStr + cchOrgStr - 1;
    }
    *pStr16 = '\0';                 // null teriminated

    return((UINT)(pStr16 - pOrgStr));
}



LONG
OutputXYParams(
    PPDEV   pPDev,
    PPOINTL pPtXY,
    PPOINTL pPtOffset,
    PPOINTL pPtCurPos,
    UINT    cPoints,
    UINT    MaxCurPosSkips,
    BYTE    NumType
    )

/*++

Routine Description:

    This function outputs long numbers, and inserts a ',' between numbers
    (other than the last number)

Arguments:

    pPDev           - Pointer to the PDEV

    pPtXY           - Pointer to the array of POINTL data structure for the XY pair

    pPtOffset       - Points to the POINTL Offset to be add to the pPtXY, NULL if
                      no offset need to be added

    pPtCurPos       - Points to the POINTL Current position in <<DEVICE>>
                      coordinates to be substracted, this is used to output XY pair as
                      relative model, if the pointer is NULL then absolute model is
                      used, if the pointer is passed and return sucessful then the
                      final XY position is written back to this POINTL

    cPoints         - count of total pPtXY pairs need to be output

    MaxCurPosSkips  - How many points before the current position will be
                      updated

    NumType         - one of 'l', 'L', 'F', 'f', 'p', 'P', 'D', 'd'

Return Value:

    if sucessful it return the total number of bytes sent to the destination,
    if negative an error occurred

Author:

    17-Feb-1994 Thu 10:13:09 created  


Revision History:


--*/

{
    LONG    Size = 0;
    POINTL  ptNow;
    POINTL  ptTmp;
    POINTL  ptOffset;
    POINTL  ptCurPos;
    UINT    XCount;
    UINT    YCount;
    UINT    XIdxStart;
    UINT    CurPosSkips;
    BOOL    NeedComma;
    BYTE    XBuf[16];
    BYTE    YBuf[16];


    NeedComma = (BOOL)((NumType >= 'a') && (NumType <= 'z'));

    if (pPtOffset) {

        ptOffset = *pPtOffset;

    } else {

        ptOffset.x =
        ptOffset.y = 0;
    }

    XIdxStart = 0;

    if (pPtCurPos) {

        ptCurPos = *pPtCurPos;

    } else if (!NeedComma) {

        XBuf[0]   = '=';
        XIdxStart = 1;
    }

    CurPosSkips = MaxCurPosSkips;

    while (cPoints--) {

        ptNow.x = pPtXY->x + ptOffset.x;
        ptNow.y = pPtXY->y + ptOffset.y;

        ++pPtXY;

        XCount = XIdxStart;
        YCount = 0;

        switch (NumType) {

        case 'L':
        case 'l':

            ptNow.x = LTODEVL(pPDev, ptNow.x);
            ptNow.y = LTODEVL(pPDev, ptNow.y);
            break;

        case 'F':
        case 'f':

            ptNow.x = FXTODEVL(pPDev, ptNow.x);
            ptNow.y = FXTODEVL(pPDev, ptNow.y);
            break;

        case 'D':
        case 'd':

            break;

        case 'P':
        case 'p':

            if (ptNow.x >= 0) {

                XBuf[XCount++] = '+';
            }

            if (ptNow.y >= 0) {

                YBuf[YCount++] = '+';
            }

            break;

        default:

            PLOTASSERT(1,"OutputXYParams: Invalid Format type '%c'",0,NumType);
            return(-2);
        }

        if (pPtCurPos) {

            ptTmp    = ptNow;
            ptNow.x -= ptCurPos.x;
            ptNow.y -= ptCurPos.y;

            if (!(--CurPosSkips)) {

                ptCurPos    = ptTmp;
                CurPosSkips = MaxCurPosSkips;
            }

            if ((ptNow.x == 0) && (ptNow.y == 0) && (MaxCurPosSkips == 1)) {

                //
                // We do not need to move to the same position here
                //

                PLOTDBG(DBG_OUTPUTXYPARMS, ("OutputXYParms: ABS=(%ld, %ld), REL=(%ld, %ld) --- SKIP",
                            ptTmp.x, ptTmp.y, ptNow.x, ptNow.y));

                continue;

            } else {


                PLOTDBG(DBG_OUTPUTXYPARMS, ("OutputXYParms: ABS=(%ld, %ld), REL=(%ld, %ld)",
                        ptTmp.x, ptTmp.y, ptNow.x, ptNow.y));
            }

        } else {

            PLOTDBG(DBG_OUTPUTXYPARMS, ("OutputXYParms: ABS=(%ld, %ld)",
                        ptNow.x, ptNow.y));
        }


        XCount += LONGToASCII(ptNow.x, &XBuf[XCount], CCHOF(XBuf) - XCount, NumType);
        YCount += LONGToASCII(ptNow.y, &YBuf[YCount], CCHOF(YBuf) - YCount, NumType);

        if (NeedComma) {

            XBuf[XCount++] = ',';

            if (cPoints) {

                YBuf[YCount++] = ',';
            }
        }

        if ((OutputBytes(pPDev, XBuf, XCount) < 0)  ||
            (OutputBytes(pPDev, YBuf, YCount) < 0)) {

            return(-1);
        }

        Size += (XCount + YCount);
    }


    //
    // return back the new current position.
    //

    if (pPtCurPos) {

        *pPtCurPos = ptCurPos;
    }

    return(Size);
}




LONG
OutputLONGParams(
    PPDEV   pPDev,
    PLONG   pNumbers,
    UINT    cNumber,
    BYTE    NumType
    )

/*++

Routine Description:

    This functions outputs LONG numbers and inserts a ',' between all but the
    last numbers.

Arguments:

    pPDev       - Pointer to the PDEV

    pNumbers    - Point to the LONG arrary of numbers

    cNumber     - Total number to be output

    NumType     - one of 'l', 'L', 'F', 'f', 'p', 'P', 'D', 'd'

Return Value:

    The return value is the total number of bytes sent to the destination.
    If negative an error occurred.

Author:

    16-Nov-1993 Tue 09:37:32 created  

    16-Feb-1994 Wed 10:49:16 updated  
        Updated to add upper case of format char as in polyline encoded mode

Revision History:


--*/

{
    LONG    Size = 0;
    LONG    Count;
    LONG    Num;
    BOOL    NeedComma;
    BYTE    NumBuf[16];


    NeedComma = (BOOL)((NumType >= 'a') && (NumType <= 'z'));

    while (cNumber--) {

        Num   = *pNumbers++;
        Count = 0;

        switch (NumType) {

        case 'L':
        case 'l':

            Num = LTODEVL(pPDev, Num);
            break;

        case 'F':
        case 'f':

            Num = FXTODEVL(pPDev, Num);
            break;

        case 'D':
        case 'd':

            break;

        case 'P':
        case 'p':

            if (Num >= 0) {

                NumBuf[Count++] = '+';
            }

            break;

        default:

            PLOTASSERT(1,"OutputLONGParams: Invalid Format type '%c'",0,NumType);
            return(-2);
        }

        Count += LONGToASCII(Num, &NumBuf[Count], CCHOF(NumBuf) - Count, NumType);

        if ((NeedComma) && (cNumber)) {

            NumBuf[Count++] = ',';
        }

        if (OutputBytes(pPDev, NumBuf, Count) < 0) {

            return(-1);
        }

        Size += Count;
    }

    return(Size);
}

//
// The following #define code is used by the OutputFormatStrDELI() and
// OutputFormatStr() functions, it was easier to maintain this way
//
//  16-Feb-1994 Wed 10:50:24 updated  
//      Updated to add upper case of format char as in polyline encoded mode
//


#define DO_FORMATSTR(pPDev, NumFormatChar, pszFormat)                       \
{                                                                           \
    LPSTR   pLast;                                                          \
    va_list vaList;                                                         \
    LONG    Num;                                                            \
    LONG    Size;                                                           \
    LONG    Count;                                                          \
    BYTE    bCur;                                                           \
    BYTE    NumBuf[16];                                                     \
                                                                            \
    va_start(vaList, pszFormat);                                            \
                                                                            \
    Size  = 0;                                                              \
    pLast = pszFormat;                                                      \
                                                                            \
    while (bCur = *pszFormat++) {                                           \
                                                                            \
        if (bCur == NumFormatChar) {                                        \
                                                                            \
            if (Count = (LONG)(pszFormat - pLast - 1)) {                    \
                                                                            \
                Size += Count;                                              \
                                                                            \
                if (OutputBytes(pPDev, pLast, Count) < 0) {                 \
                                                                            \
                    return(-1);                                             \
                }                                                           \
            }                                                               \
                                                                            \
            Num    = va_arg(vaList, LONG);                                  \
            Count  = 0;                                                     \
                                                                            \
            switch (bCur = *pszFormat++) {                                  \
                                                                            \
            case 'L':                                                       \
            case 'l':                                                       \
                                                                            \
                Num = LTODEVL(pPDev, Num);                                  \
                break;                                                      \
                                                                            \
            case 'F':                                                       \
            case 'f':                                                       \
                                                                            \
                Num = FXTODEVL(pPDev, Num);                                 \
                break;                                                      \
                                                                            \
            case 'D':                                                       \
            case 'd':                                                       \
                                                                            \
                break;                                                      \
                                                                            \
            case 'P':                                                       \
            case 'p':                                                       \
                                                                            \
                if (Num >= 0) {                                             \
                                                                            \
                    NumBuf[Count++] = '+';                                  \
                }                                                           \
                                                                            \
                break;                                                      \
                                                                            \
            default:                                                        \
                                                                            \
                PLOTASSERT(1,"Invalid Format type '%c'",0,*(pszFormat-1));  \
                return(-2);                                                 \
            }                                                               \
                                                                            \
            Count += LONGToASCII(Num, &NumBuf[Count], sizeof(NumBuf) - Count, bCur);                \
            Size  += Count;                                                 \
            pLast  = pszFormat;                                             \
                                                                            \
            if (OutputBytes(pPDev, NumBuf, Count) < 0) {                    \
                                                                            \
                return(-1);                                                 \
            }                                                               \
        }                                                                   \
    }                                                                       \
                                                                            \
    if (Count = (LONG)(pszFormat - pLast - 1)) {                            \
                                                                            \
        Size += Count;                                                      \
                                                                            \
        if (OutputBytes(pPDev, pLast, Count) < 0) {                         \
                                                                            \
            return(-1);                                                     \
        }                                                                   \
    }                                                                       \
                                                                            \
    va_end(vaList);                                                         \
                                                                            \
    return(Size);                                                           \
}



LONG
cdecl
OutputFormatStrDELI(
    PPDEV   pPDev,
    CHAR    NumFormatChar,
    LPSTR   pszFormat,
    ...
    )

/*++

Routine Description:

    This function outputs a string and optionally replaces '#' with LONG numbers
    passed on the stack

Arguments:

    pPDev           - Pointer to the PDEV

    NumFormatChar   - the character in the pszFormat string will be replaced
                      by LONG numbers on the stack

    pszFormat       - a ASCII string, only 'NumFormatChar' will be replaced
                      with a 32-bit LONG number on the stack

Return Value:

    LONG size of the string write to the output buffer, a negative number
    indicates an error


Author:

    16-Nov-1993 Tue 07:56:18 created  


Revision History:


--*/

{
    DO_FORMATSTR(pPDev, NumFormatChar, pszFormat);
}




LONG
cdecl
OutputFormatStr(
    PPDEV   pPDev,
    LPSTR   pszFormat,
    ...
    )

/*++

Routine Description:

    This function outputs the passed stack variables with the default format.

Arguments:

    pPDev       - Pointer to the PDEV

    pszFormat   - a ASCII string, only '#' will be replaced with a 32-bit
                  LONG number on the stack

Return Value:

    LONG size of the string written to the output buffer, a negative number
    siginals an error


Author:

    16-Nov-1993 Tue 07:56:18 created  


Revision History:


--*/

{
    DO_FORMATSTR(pPDev, DEF_FORMATSTR_CHAR, pszFormat);
}




BOOL
OutputCommaSep(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This funtion outputs a ',' (comma ) to the destination

Arguments:

    pPDev   - Pointer to the PDEV


Return Value:

    BOOL


Author:

    16-Nov-1993 Tue 10:46:42 created  


Revision History:


--*/

{
    return(OutputString(pPDev, ",") == 1);
}




VOID
ClearClipWindow(
    PPDEV pPDev
    )

/*++

Routine Description:

    This function clears the input window (plotter CLIP RECT) in the
    target device using the correct HPGL2 command.

Arguments:

    pPDev   - Pointer to the PDEV data structure

Return Value:

    VOID


Author:

    30-Nov-1993 Tue 19:56:09 updated  
        style clean up, commented

Revision History:


--*/

{
    if (pPDev->Flags & PDEVF_HAS_CLIPRECT) {

        pPDev->Flags &= ~PDEVF_HAS_CLIPRECT;
        OutputString(pPDev, "IW;");
    }
}



VOID
SetClipWindow(
    PPDEV   pPDev,
    PRECTL  pClipRectl
    )

/*++

Routine Description:

    This function sets the device clip rect to prevent objects drawn outside
    the rect from appearing on the target surface. The target device is doing
    the actual clipping in this case.

Arguments:

    pPDev       - Pointer to the PDEV data structure

    pClipRectl  - Pointer to the RECTL data structure which defines the clipping
                  rect to set inside the target device in engine units.

Return Value:

    VOID


Author:

    30-Nov-1993 Tue 19:56:45 created  
        style clean up, commented


Revision History:


--*/

{

    POINTL      ptlPlot;
    SIZEL       szlRect;
    RECTL       rclCurClip;


    ptlPlot.x  = LTODEVL(pPDev, pClipRectl->left);
    ptlPlot.y  = LTODEVL(pPDev, pClipRectl->top );
    szlRect.cx = LTODEVL(pPDev, pClipRectl->right)  - ptlPlot.x;
    szlRect.cy = LTODEVL(pPDev, pClipRectl->bottom ) - ptlPlot.y;

    if ((szlRect.cx) && (szlRect.cy)) {

        //
        // Here we try to be intelligent about sending down coordinates thate
        // are too small and would adversly affect the target device.
        //

        if (szlRect.cx < (LONG)pPDev->MinLToDevL) {

            PLOTWARN(("SetClipWindow: cxRect=%ld < MIN=%ld, Make it as MIN",
                            szlRect.cx, (LONG)pPDev->MinLToDevL));

            szlRect.cx = (LONG)pPDev->MinLToDevL ;
        }

        if (szlRect.cy < (LONG)pPDev->MinLToDevL) {

            PLOTWARN(("SetClipWindow: cyRect=%ld < MIN=%ld, Make it as MIN",
                            szlRect.cy, (LONG)pPDev->MinLToDevL));

            szlRect.cy = (LONG)pPDev->MinLToDevL ;
        }

    } else {

        PLOTWARN(( "SetClipWindow: Clipping out EVERYTHING...."));
    }

    rclCurClip.right  = (rclCurClip.left = ptlPlot.x) + szlRect.cx;
    rclCurClip.bottom = (rclCurClip.top = ptlPlot.y) + szlRect.cy;

    if ((pPDev->Flags & PDEVF_HAS_CLIPRECT)             &&
        (pPDev->rclCurClip.left   == rclCurClip.left)   &&
        (pPDev->rclCurClip.top    == rclCurClip.top)    &&
        (pPDev->rclCurClip.right  == rclCurClip.right)  &&
        (pPDev->rclCurClip.bottom == rclCurClip.bottom)) {

        PLOTDBG(DBG_SETCLIPWINDOW, ("SetClipWindow: PP%ld, (%ld, %ld)-(%d, %ld) *CACHED*",
                pPDev->Flags & PDEVF_PP_CENTER ? 0 : 1,
                rclCurClip.left, rclCurClip.top,
                rclCurClip.right, rclCurClip.bottom));

    } else {

        PLOTDBG(DBG_SETCLIPWINDOW, ("SetClipWindow: PP%ld, (%ld, %ld)-(%d, %ld)",
                pPDev->Flags & PDEVF_PP_CENTER ? 0 : 1,
                rclCurClip.left, rclCurClip.top,
                rclCurClip.right, rclCurClip.bottom));

        pPDev->rclCurClip  = rclCurClip;
        pPDev->Flags      |= PDEVF_HAS_CLIPRECT;

        if (pPDev->Flags & PDEVF_PP_CENTER) {

            --rclCurClip.right;
            --rclCurClip.bottom;
        }

        OutputFormatStr(pPDev,
                        "IW#d,#d,#d,#d",
                        rclCurClip.left,            // LL x
                        rclCurClip.bottom,          // LL y
                        rclCurClip.right,           // UR x
                        rclCurClip.top);            // UR y
    }
}




VOID
SetPixelPlacement(
    PPDEV   pPDev,
    UINT    SetMode
    )

/*++

Routine Description:

    This function sets the pixel placement to the center or edge. This
    defines if a pixel is drawn at the intersection of the vertical and
    horizontal coordinates, or on the edge.


Arguments:

    pPDev   - Pointer to the PDEV data structure

    SetMode - SPP_MODE_CENTER (Intersection of pixel GRID) or
              SPP_MODE_EDGE (non intersection of the pixel GRID)

              SPP_FORCE_SET, force to reset regardless of the current cached mode

Return Value:

    VOID


Author:

    25-Jan-1996 Thu 13:33:15 created  


Revision History:


--*/

{
    UINT    CurMode;


    CurMode = (pPDev->Flags & PDEVF_PP_CENTER) ? SPP_MODE_CENTER :
                                                 SPP_MODE_EDGE;

    if ((SetMode & SPP_FORCE_SET) ||
        ((SetMode & SPP_MODE_MASK) != CurMode)) {

        //
        // Set it now
        //

        if ((SetMode & SPP_MODE_MASK) == SPP_MODE_CENTER) {

            pPDev->Flags |= PDEVF_PP_CENTER;
            OutputString(pPDev, "PP0");

        } else {

            pPDev->Flags &= ~PDEVF_PP_CENTER;
            OutputString(pPDev, "PP1");
        }

        if (pPDev->Flags & PDEVF_HAS_CLIPRECT) {

            RECTL   rclCurClip = pPDev->rclCurClip;

            //
            // Make sure we really reset the clipping rectangle
            //

            --(pPDev->rclCurClip.left);

            SetClipWindow(pPDev, &rclCurClip);
        }
    }
}



BOOL
SetRopMode(
    PPDEV   pPDev,
    DWORD   Rop
    )

/*++

Routine Description:

    This function sends the Rop3 mode to the plotter if it is different than
    the current setting.


Arguments:

    pPDev   - Pointer to the PDEV

    Rop     - a Rop3 code


Return Value:

    TRUE/FALSE


Author:

    27-Jan-1994 Thu 18:55:54 created  


Revision History:


--*/

{
    if (pPDev->LastDevROP != (WORD)(Rop &= 0xFF)) {

        pPDev->LastDevROP = (WORD)Rop;

        if (Rop == 0xCC) {

            return(OutputFormatStr(pPDev, "MC0;"));

        } else {

            return(OutputFormatStr(pPDev, "MC1,#d;", (LONG)Rop));
        }
    }

    return(TRUE);
}




BOOL
SetHSFillType(
    PPDEV   pPDev,
    DWORD   HSFillTypeIndex,
    LONG    lParam
    )

/*++

Routine Description:

    This function set the fill type on the plotter only if not already so


Arguments:

    pPDev           - Pointer to our PDEV

    HSFillTypeIdx   - a index to pHSFillType, if invalid or out of range then
                      a solid color HS_SOLIDCLR is assumed

    lParam          - a Long parameter to be sent with FT

Return Value:

    TRUE/FALSE


Author:

    27-Jan-1994 Thu 19:00:21 created  


Revision History:


--*/

{
    WORD    Index;


    PLOTASSERT(1, "SetFillType: Invalid HSFillTypeIndex=%ld passed, set to SOLID",
                    HSFillTypeIndex <= HS_FT_USER_DEFINED, HSFillTypeIndex);


    if (HSFillTypeIndex > HS_FT_USER_DEFINED) {

        HSFillTypeIndex = HS_DDI_MAX;
    }

    if ((Index = (WORD)HSFillTypeIndex) == (WORD)HS_FT_USER_DEFINED) {

        if ((lParam < 0) || (lParam > RF_MAX_IDX)) {

            PLOTASSERT(1, "SetFillType: User defined ID [%ld] invalid, make it 1",
                            (lParam > 0) && (lParam <= RF_MAX_IDX), lParam);

            lParam = 1;
        }

        Index += (WORD)lParam;
    }

    if (Index != pPDev->LastFillTypeIndex) {

        PLOTDBG(DBG_FILLTYPE, ("SetFillType: Change %hs (%ld) -> %hs (%ld)",
                    (pPDev->LastFillTypeIndex > HS_FT_USER_DEFINED) ?
                        pHSFillTypeName[HS_FT_USER_DEFINED] :
                        pHSFillTypeName[pPDev->LastFillTypeIndex],
                    (pPDev->LastFillTypeIndex > HS_FT_USER_DEFINED) ?
                        pPDev->LastFillTypeIndex - HS_FT_USER_DEFINED :
                        lParam,
                    (Index > HS_FT_USER_DEFINED) ?
                        pHSFillTypeName[HS_FT_USER_DEFINED] :
                        pHSFillTypeName[Index],
                    (Index > HS_FT_USER_DEFINED) ?
                        Index - HS_FT_USER_DEFINED : lParam));

        pPDev->LastFillTypeIndex = Index;

        if ((!OutputString(pPDev, "FT")) ||
            (!OutputFormatStr(pPDev, pHSFillType[HSFillTypeIndex], lParam))) {

            return(FALSE);
        }

    } else {

        PLOTDBG(DBG_FILLTYPE, ("SetFillType: HSFillType is SAME = %hs",
                                (Index > HS_FT_USER_DEFINED) ?
                                    pHSFillTypeName[HS_FT_USER_DEFINED] :
                                    pHSFillTypeName[Index]));
    }

    return(TRUE);
}




BOOL
SendPageHeader(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function sends the initialization data to the device for each new
    page. Correct coordinate system and scaling is set.

Arguments:


    pPDev   - Pointer to the PDEV data structure for the page


Return Value:

    BOOL

Author:

    30-Nov-1993 Tue 19:53:13 updated  
        Re-write and update to correct system for the NT

    29-Nov-1993 Mon 23:55:43 updated  
        Re-write

    24-Nov-1993 Wed 22:38:10 updated  
        Using CurForm to replace the pform and PAPER_DIM

    06-Jan-1994 Thu 00:21:17 updated  
        Update for SPLTOPLOTUNITS() macro

    15-Feb-1994 Tue 09:59:34 updated  
        Set physical position and anchor corner after command is sent

    18-Mar-1994 Fri 12:58:24 updated  
        add ptlRTLCAP to zero at Page Reset

    24-May-1994 Tue 00:59:17 updated  
        SC command should range from 0 to DEVSIZE - 1

Revision History:


--*/

{
    PPLOTGPC    pPlotGPC;
    LONG        xMin;
    LONG        xMax;
    LONG        yMin;
    LONG        yMax;


    //
    // Compute minimum required pel size in PLOTDPI from RASTER DPI
    //
    // pPDev->MinLToDevL = (WORD)DIVRNDUP(__PLOT_DPI, _CURR_DPI);
    //

    pPDev->MinLToDevL = (WORD)LTODEVL(pPDev, 1);

    PLOTDBG(DBG_PAGE_HEADER,
            ("SendPageHeader: MinLToDevL=LTODEVL(1)=%ld", pPDev->MinLToDevL));

    //
    // Speedy access
    //

    pPlotGPC = pPDev->pPlotGPC;

    //
    // First, output the Init string that the pPlotGPC has. The PCD file is
    // responsible for all initialization upto and including the IN command.
    //

    if ((pPlotGPC->InitString.pData) &&
        (pPlotGPC->InitString.SizeEach)) {

        OutputBytes(pPDev,
                    (LPBYTE)pPlotGPC->InitString.pData,
                    (LONG)pPlotGPC->InitString.SizeEach);
    }

    //
    // DMRES_DRAFT         (-1)
    // DMRES_LOW           (-2)
    // DMRES_MEDIUM        (-3)
    // DMRES_HIGH          (-4)
    //
    // Assume BEST quality
    //

    xMax = 100;

    switch (pPDev->PlotDM.dm.dmPrintQuality) {

    case DMRES_DRAFT:

        xMax = 0;
        break;

    case DMRES_HIGH:

        xMax = 100;
        break;

    default:

        switch (pPlotGPC->MaxQuality) {

        case 2:

            xMax = 0;
            break;

        case 3:

            xMax = 50;
            break;

        default:

            xMax = 34;
            break;
        }

        if (pPDev->PlotDM.dm.dmPrintQuality == DMRES_MEDIUM) {

            xMax = 100 - xMax;
        }

        break;
    }

    OutputFormatStr(pPDev, "QL#d", xMax);

    //
    // PS: This command tells the target device what the hard clip limits should
    //     be. The target device will adjust the command we send if its beyond
    //     the real hard clip limits. Always send CY (lenght) first then CX
    //     (width)
    //
    // RO: Only sent to rotate the target device coordinate system if the
    //     PlotForm.Flags is set accordinly. This is because HPGL2 always
    //     assumes the LONGER side sent using the PS command is X in the
    //     standard coordinate system. Because of this behavior we may have
    //     to swap X and Y in order to correct the coordinate system.
    //
    // IP: This command defines where the users's unit origin and extent is.
    //     We set this so that the origin and extend is exactly the printable
    //     rectangle related to the HARD CLIP LIMITS (not the paper/form size)
    //
    // SC: This defines the user unit scaling. Currently we are 1:1 but use
    //     this command to flip the X or Y origin so we have the same
    //     coordinate system as GDI.
    //
    // ALL PlotForm UNITS are in 1/1000mm or Windows 2000, Windows XP, 
    //  Windows Server 2003  spooler forms units.
    //
    //
    // If we support transparent mode we want to make sure its off to begin
    // with, because the driver assumes its off.
    //

    if (IS_TRANSPARENT(pPDev)) {

        OutputString( pPDev, "TR0;");

    }

    OutputFormatStr(pPDev, "ROPS#d,#d",
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.PlotSize.cy),
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.PlotSize.cx));

    PLOTDBG(DBG_PAGE_HEADER, ("SendPageHeader: ROPS%ld,%ld%hs",
                SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.PlotSize.cy),
                SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.PlotSize.cx),
                (pPDev->PlotForm.Flags & PFF_ROT_COORD_L90) ? "RO90" : ""));

    if (pPDev->PlotForm.Flags & PFF_ROT_COORD_L90) {

        OutputString(pPDev, "RO90");
    }

    //
    // Compute the scaling amount and direction, if FLIP_X_COORD or a
    // FLIP_Y_COORD flags are set then we need to flip the scale in X or Y
    // direction.
    //

#if 1
    xMin =
    xMax = pPDev->HorzRes - 1;
    yMin =
    yMax = pPDev->VertRes - 1;
#else
    xMin =
    xMax = SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogExt.cx) - 1;
    yMin =
    yMax = SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogExt.cy) - 1;
#endif

    if (pPDev->PlotForm.Flags & PFF_FLIP_X_COORD) {

        xMax = 0;

    } else {

        xMin = 0;
    }

    if (pPDev->PlotForm.Flags & PFF_FLIP_Y_COORD) {

        yMax = 0;

    } else {

        yMin = 0;
    }

    //
    // IP   - to set the p1/p2
    // SC   - to scale it (only used to flip the HPGL/2 coordinate)
    // AC   - anchor point to default (0, 0)
    //

    OutputFormatStr(pPDev, "IP#d,#d,#d,#dSC#d,#d,#d,#dAC",
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogOrg.x),
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogOrg.y),
                        SPLTOPLOTUNITS(pPlotGPC,
                                       (pPDev->PlotForm.LogOrg.x +
                                            pPDev->PlotForm.LogExt.cx)) - 1,
                        SPLTOPLOTUNITS(pPlotGPC,
                                       (pPDev->PlotForm.LogOrg.y +
                                            pPDev->PlotForm.LogExt.cy)) - 1,
                        xMin, xMax, yMin, yMax);

    PLOTDBG(DBG_PAGE_HEADER, ("SendPageHeader: IP%ld,%ld,%ld,%ldSC%ld,%ld,%ld,%ldAC",
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogOrg.x),
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogOrg.y),
                        SPLTOPLOTUNITS(pPlotGPC,
                                       (pPDev->PlotForm.LogOrg.x +
                                            pPDev->PlotForm.LogExt.cx)) - 1,
                        SPLTOPLOTUNITS(pPlotGPC,
                                       (pPDev->PlotForm.LogOrg.y +
                                            pPDev->PlotForm.LogExt.cy)) - 1,
                        xMin, xMax, yMin, yMax));
    //
    // Set RTL CAP back to zero, this is true after a EscE is sent
    //

    pPDev->ptlRTLCAP.x       =
    pPDev->ptlRTLCAP.y       =
    pPDev->ptlAnchorCorner.x =
    pPDev->ptlAnchorCorner.y = 0;
    pPDev->PenWidth.Integer  =
    pPDev->PenWidth.Decimal  = 0;

    //
    // Reset pen position to (0,0)
    //

    OutputString(pPDev, "PA0,0");

    if ((IS_COLOR(pPDev)) && (IS_RASTER(pPDev))) {

        //
        // !!!Work around some color device limitations in order to make
        // TR/ROP function correctly.
        //

        OutputString(pPDev, "PC1,255,0,0PC2,255,255,255SP1PD99,0SP2PD0,0PU");
    }

    //
    // Create the pallete, this will send out the pens as needed
    //

    if (!PlotCreatePalette(pPDev)) {

        PLOTERR(("DrvEnableSurface: PlotCreatePalette() failed."));
        return(FALSE);
    }

    //
    // Reset PW to 0
    //

    OutputString(pPDev, "WU0PW0");

    if (IS_RASTER(pPDev)) {


        //
        // If we are in poster mode, set up for it now.
        //

        if (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) {

            xMin = SPLTOENGUNITS(pPDev, pPDev->PlotForm.PlotSize.cx);
            yMin = SPLTOENGUNITS(pPDev, pPDev->PlotForm.PlotSize.cy);

            xMax = GetBmpDelta(HTBMPFORMAT(pPDev), xMin);
            yMax = xMax * yMin;

            PLOTDBG(DBG_PAGE_HEADER,
                    ("SendPageHeader: ** POSTER MODE *** Scan=%ld bytes x cy (%ld) = %ld bytes",
                    xMax, yMin, yMax));

            if (yMax <= MIN_POSTER_SIZE) {

                pPDev->PlotDM.Flags &= ~PDMF_PLOT_ON_THE_FLY;

                PLOTDBG(DBG_PAGE_HEADER,
                        ("SendPageHeader: Size <= %ld bytes, Turn OFF Poster Mode",
                        MIN_POSTER_SIZE));
            }
        }

        OutputFormatStr(pPDev,
                        ";\033%0A\033*t#dR\033*v1N\033&a#dN\033%0B",
                        pPDev->pPlotGPC->RasterXDPI,
                        (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) ? 1 : 0);
    }


    //
    // Whole surface can be drawn to
    //

    ClearClipWindow(pPDev);
    SetPixelPlacement(pPDev, SPP_FORCE_SET | SPP_MODE_EDGE);

    return(TRUE);
}



BOOL
SendPageTrailer(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function does any end of page commands, takes multiple copies into
    account, and ejects the page.

Arguments:

    pPDev   - Pointer to PDEV data structure

Return Value:

    TRUE if sucessful FALSE if failed.

Author:

    15-Feb-1994 Tue 09:56:58 updated  
        I move the physical position setting to the SendPageHeader

    30-Nov-1993 Tue 21:42:21 updated  
        clean up style, commented, Updated


Revision History:


--*/

{
    //
    // Store the pen back to the carousel and advance full page
    //

    OutputString(pPDev, "PUSPPG;");

    //
    // Check to see if were doing multiple copies and send them if we are
    //

    if (pPDev->PlotDM.dm.dmCopies > 1) {

        OutputFormatStr(pPDev, "RP#d;", (LONG)pPDev->PlotDM.dm.dmCopies - 1);
    }

    //
    // Flush the output buffer.
    //

    return(FlushOutBuffer(pPDev));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\htbmp4.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    htbmp4.c


Abstract:

    This module contains functions to output halftoned 4 bit per pel (4 BPP)
    bitmaps to the target device.


Author:

    21-Dec-1993 Tue 21:32:26 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgHTBmp4

#define DBG_OUTPUT4BPP      0x00000001
#define DBG_OUTPUT4BPP_ROT  0x00000002
#define DBG_JOBCANCEL       0x00000004

DEFINE_DBGVAR(0);



//
// To Use OUT_ONE_4BPP_SCAN, the following variables must be set before hand:
//
//  HTBmpInfo       - The whole structure copied down
//  pbScanSrc       - LPBYTE for getting the source scan line buffer
//  pbScanR0        - Red destination scan line buffer pointer
//  pbScanG0        - Green destination scan line buffer pointer
//  pbScanB0        - Blue destination scan line buffer pointer
//  RTLScans.cxBytes- Total size of destination scan line buffer per plane
//  pHTXB           - Computed HTXB xlate table in pPDev
//
//  This macro will always assume the pbScanSrc is DWORD aligned. This
//  makes the inner loop go faster since we only need to move the source once
//  for all raster planes.
//
//  This macro will directly return a FALSE if a CANCEL JOB is detected during
//  procesing.
//
//  This will output directly to RTL.
//
//

#define OUT_ONE_4BPP_SCAN                                                   \
{                                                                           \
    LPBYTE  pbScanR  = pbScanR0;                                            \
    LPBYTE  pbScanG  = pbScanG0;                                            \
    LPBYTE  pbScanB  = pbScanB0;                                            \
    DWORD   LoopHTXB = RTLScans.cxBytes;                                    \
    HTXB    htXB;                                                           \
                                                                            \
    while (LoopHTXB--) {                                                    \
                                                                            \
        P4B_TO_3P_DW(htXB.dw, pHTXB, pbScanSrc);                            \
                                                                            \
        *pbScanR++ = HTXB_R(htXB);                                          \
        *pbScanG++ = HTXB_G(htXB);                                          \
        *pbScanB++ = HTXB_B(htXB);                                          \
    }                                                                       \
                                                                            \
    OutputRTLScans(HTBmpInfo.pPDev,                                         \
                   pbScanR0,                                                \
                   pbScanG0,                                                \
                   pbScanB0,                                                \
                   &RTLScans);                                              \
}



BOOL
Output4bppHTBmp(
    PHTBMPINFO  pHTBmpInfo
    )

/*++

Routine Description:

    This function outputs a 4 bpp halftoned bitmap

Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  fuction to output the bitmap

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    Created 

    18-Jan-1994 Tue 16:05:08 Updated  
        Changed ASSERT to look at pHTBmpInfo instead of HTBmpInfo

    21-Dec-1993 Tue 16:05:08 Updated  
        Re-write to make it take HTBMPINFO

    16-Mar-1994 Wed 16:54:59 updated  
        Updated so we do not copy to the temp. buffer anymore, the masking
        of last source byte problem in OutputRTLScans() will be smart enough
        to put the original byte back after the masking

Revision History:


--*/

{
    LPBYTE      pbScanSrc;
    PHTXB       pHTXB;
    LPBYTE      pbScanR0;
    LPBYTE      pbScanG0;
    LPBYTE      pbScanB0;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    DWORD       LShiftCount;


    PLOTASSERT(1, "Output4bppHTBmp: No DWORD align buffer (pRotBuf)",
                                                        pHTBmpInfo->pRotBuf, 0);
    HTBmpInfo = *pHTBmpInfo;

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cx,
                  HTBmpInfo.szlBmp.cy,
                  FALSE);

    pHTXB             = ((PDRVHTINFO)HTBmpInfo.pPDev->pvDrvHTData)->pHTXB;
    HTBmpInfo.pScan0 += (HTBmpInfo.OffBmp.x >> 1);
    pbScanR0          = HTBmpInfo.pScanBuf;
    pbScanG0          = pbScanR0 + RTLScans.cxBytes;
    pbScanB0          = pbScanG0 + RTLScans.cxBytes;

    PLOTASSERT(1, "The ScanBuf size is too small (%ld)",
                (RTLScans.cxBytes * 3) <= HTBmpInfo.cScanBuf, HTBmpInfo.cScanBuf);

    PLOTASSERT(1, "The RotBuf size is too small (%ld)",
                (DWORD)((HTBmpInfo.szlBmp.cx + 1) >> 1) <= HTBmpInfo.cRotBuf,
                                                        HTBmpInfo.cRotBuf);

    if (HTBmpInfo.OffBmp.x & 0x01) {

        //
        // We must shift one nibble to the left now
        //

        LShiftCount = (DWORD)HTBmpInfo.szlBmp.cx;

        PLOTDBG(DBG_OUTPUT4BPP,
                ("Output4bppHTBmp: Must SHIFT LEFT 1 NIBBLE To align"));

    } else {

        LShiftCount = 0;
    }

    //
    // We must be very careful not to read past the end of the source buffer.
    // This could happen if we pbScanSrc is not DWORD aligned, since this
    // will cause the last conversion macro to load all 4 bytes. To resolve
    // this we can either copy the source buffer to a DWORD aligned temporary
    // location, or handle the last incomplete DWORD differently. This only
    // occurs when the bitmap is NOT rotated, and (pbScanSrc & 0x03).
    //

    while (RTLScans.Flags & RTLSF_MORE_SCAN) {

        //
        // This is the final source for this scan line
        //

        if (LShiftCount) {

            LPBYTE  pbTmp;
            DWORD   PairCount;
            BYTE    b0;
            BYTE    b1;


            pbTmp     = HTBmpInfo.pScan0;
            b1        = *pbTmp;
            pbScanSrc = HTBmpInfo.pRotBuf;
            PairCount = LShiftCount;

            while (PairCount > 1) {

                b0            = b1;
                b1            = *pbTmp++;
                *pbScanSrc++  = (BYTE)((b0 << 4) | (b1 >> 4));
                PairCount    -= 2;
            }

            if (PairCount) {

                //
                // If we have the last nibble to do then make it 0xF0 nibble,
                // so we only look at the bits of interest.
                //

                *pbScanSrc = (BYTE)(b1 << 4);
            }

            //
            // Reset this pointer back to the final shifted source buffer
            //

            pbScanSrc = HTBmpInfo.pRotBuf;

        } else {

            pbScanSrc = HTBmpInfo.pScan0;
        }

        //
        // Output one 4 bpp scan line (3 planes)
        //

        OUT_ONE_4BPP_SCAN;

        //
        // advance source bitmap buffer pointer to next scan line
        //

        HTBmpInfo.pScan0 += HTBmpInfo.Delta;
    }

    //
    // The caller will send END GRAPHIC command if we return TRUE, thus
    // completing the RTL graphic command.
    //

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}





BOOL
Output4bppRotateHTBmp(
    PHTBMPINFO  pHTBmpInfo
    )

/*++

Routine Description:

    This function outputs a 4 bpp halftoned bitmap and rotates it to the left
    as illustrated

           cx               Org ---- +X -->
        +-------+           | @------------+
        |       |           | |            |
        | ***** |           | |  *         |
       c|   *   |             |  *        c|
       y|   *   |          +Y |  *******  y|
        |   *   |             |  *         |
        |   *   |           | |  *         |
        |   *   |           V |            |
        |   *   |             +------------+
        +-------+


Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  fuction to output the bitmap

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    21-Dec-1993 Tue 16:05:08 Updated  
        Re-write to make it take an HTBMPINFO structure.

    Created 


Revision History:


--*/

{
    LPBYTE      pbScanSrc;
    LPBYTE      pb2ndScan;
    PHTXB       pHTXB;
    LPBYTE      pbScanR0;
    LPBYTE      pbScanG0;
    LPBYTE      pbScanB0;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    TPINFO      TPInfo;
    DWORD       EndX;


    //
    // The EndX is the pixel we will start reading in the X direction, we must
    // setup the variable correctly before we call OUT_4BPP_SETUP.
    //

    HTBmpInfo = *pHTBmpInfo;

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cy,
                  HTBmpInfo.szlBmp.cx,
                  FALSE);

    pHTXB             = ((PDRVHTINFO)HTBmpInfo.pPDev->pvDrvHTData)->pHTXB;
    EndX              = (DWORD)(HTBmpInfo.OffBmp.x + HTBmpInfo.szlBmp.cx - 1);
    HTBmpInfo.pScan0 += (EndX >> 1);
    pbScanR0          = HTBmpInfo.pScanBuf;
    pbScanG0          = pbScanR0 + RTLScans.cxBytes;
    pbScanB0          = pbScanG0 + RTLScans.cxBytes;

    PLOTASSERT(1, "The ScanBuf size is too small (%ld)",
                (RTLScans.cxBytes * 3) <= HTBmpInfo.cScanBuf, HTBmpInfo.cScanBuf);

    //
    // after the transpose of the source bitmap into two scanlines the rotated
    // buffer will always start from the high nibble, we will never have
    // an odd src X position.
    // We assume rotation is always to the right 90 degree
    //

    TPInfo.pPDev      = HTBmpInfo.pPDev;
    TPInfo.pSrc       = HTBmpInfo.pScan0;
    TPInfo.pDest      = HTBmpInfo.pRotBuf;
    TPInfo.cbSrcScan  = HTBmpInfo.Delta;
    TPInfo.cbDestScan = (LONG)((HTBmpInfo.szlBmp.cy + 1) >> 1);
    TPInfo.cbDestScan = (LONG)DW_ALIGN(TPInfo.cbDestScan);
    TPInfo.cySrc      = HTBmpInfo.szlBmp.cy;
    TPInfo.DestXStart = 0;

    PLOTASSERT(1, "The RotBuf size is too small (%ld)",
                (DWORD)(TPInfo.cbDestScan << 1) <= HTBmpInfo.cRotBuf,
                                                   HTBmpInfo.cRotBuf);

    //
    // Compute the 2nd scan pointer once, rather than every time in the
    // loop.
    //

    pb2ndScan = TPInfo.pDest + TPInfo.cbDestScan;


    //
    // If we are in an even position do the first transpose once, outside the
    // loop, so we don't have to check this state for ever pass through the
    // loop. If we do the transpose, TPInfo.pSrc, will be decremented by one,
    // and pointing to the correct position.
    //

    if (!(EndX &= 0x01)) {

        TransPos4BPP(&TPInfo);
    }


    while (RTLScans.Flags & RTLSF_MORE_SCAN) {

        //
        // Do the transpose, only if the source goes into the new byte position.
        // After the transpose (right 90 degrees) the TPInfo.pDest will point
        // to the first scan line and TPInfo.pDest + TPInfo.cbDestScan will be
        // the second scan line.
        //


        if (EndX ^= 0x01) {

            pbScanSrc = pb2ndScan;

        } else {

            TransPos4BPP(&TPInfo);

            //
            // Point to the first scan line in the rotated direction. This
            // will be computed correctly by the TRANSPOSE function, even
            // if we rotated left.
            //

            pbScanSrc = TPInfo.pDest;
        }

        //
        // Output one 4bpp scan line (in 3 plane format)
        //

        OUT_ONE_4BPP_SCAN;
    }

    //
    // The caller will send the END GRAPHIC command if we return TRUE, thus
    // completing the RTL graphic command.
    //

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\page.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    page.h


Abstract:

    This module contains prototype and #defines for page.c


Author:

    18-Nov-1993 Thu 04:49:28 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTPAGE_
#define _PLOTPAGE_


BOOL
DrvStartPage(
    SURFOBJ *pso
    );

BOOL
DrvSendPage(
    SURFOBJ *pso
    );

BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pwDocName,
    DWORD   JobId
    );

BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   Flags
    );


#endif  // _PLOTPAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\path.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    path.h


Abstract:

    This module contains prototype and #defines for path.c


Author:

    18-Nov-1993 Thu 04:42:22 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _PLOTPATH_
#define _PLOTPATH_


typedef struct {
   CLIPLINE clipLine;
   RUN      runbuff[50];
} PLOT_CLIPLINE, *PPLOT_CLIPLINE;


BOOL
MovePen(
    PPDEV       pPDev,
    PPOINTFIX   pPtNewPos,
    PPOINTL     pPtDevPos
    );


BOOL
DoStrokePathByEnumingClipLines(
    PPDEV       pPDev,
    SURFOBJ     *pso,
    CLIPOBJ     *pco,
    PATHOBJ     *ppo,
    PPOINTL     pptlBrushOrg,
    BRUSHOBJ    *pbo,
    ROP4        rop4,
    LINEATTRS   *plineattrs
    );

#endif  // _PLOTPATH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\output.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    output.h


Abstract:

    This module contains exported definitions for the output.c module


Author:

    16-Nov-1993 Tue 04:16:47 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _PLOTOUTPUT_
#define _PLOTOUTPUT_



#define OUTPUT_BUFFER_SIZE      (32 * 1024)

#define HS_FT_USER_DEFINED      (HS_DDI_MAX + 1)

#define PLOT_LT_UNDEFINED       0
#define PLOT_LT_SOLID           1
#define PLOT_LT_USERDEFINED     2


#define SETLINETYPESOLID(pPDev)                                 \
{                                                               \
    if ((pPDev)->LastLineType != PLOT_LT_SOLID) {               \
                                                                \
        (pPDev)->LastLineType = PLOT_LT_SOLID;                  \
        OutputString(pPDev, "LT");                              \
    }                                                           \
}

#define SPP_MODE_CENTER         0x00
#define SPP_MODE_EDGE           0x01
#define SPP_MODE_MASK           0x01
#define SPP_FORCE_SET           0x80


LONG
BestMatchNonWhitePen(
    PPDEV   pPDev,
    LONG    R,
    LONG    G,
    LONG    B
    );

VOID
GetFinalColor(
    PPDEV       pPDev,
    PPALENTRY   pPalEntry
    );

LONG
FindCachedPen(
    PPDEV       pPDev,
    PPALENTRY   pPalEntry
    );

BOOL
PlotCreatePalette(
    PPDEV   pPDev
    );

UINT
AllocOutBuffer(
    PPDEV   pPDev
    );

VOID
FreeOutBuffer(
    PPDEV   pPDev
    );

BOOL
FlushOutBuffer(
    PPDEV   pPDev
    );

LONG
OutputBytes(
    PPDEV   pPDev,
    LPBYTE  pBuf,
    LONG    cBuf
    );

LONG
OutputString(
    PPDEV   pPDev,
    LPSTR   pszStr
    );

LONG
LONGToASCII(
    LONG    Number,
    LPSTR   pStr16,
    size_t  cchStr16,
    BYTE    NumType
    );

LONG
OutputXYParams(
    PPDEV   pPDev,
    PPOINTL pPtXY,
    PPOINTL pPtOffset,
    PPOINTL pPtCurPos,
    UINT    cPoints,
    UINT    MaxCurPosSkips,
    BYTE    NumType
    );

LONG
OutputLONGParams(
    PPDEV   pPDev,
    PLONG   pNumbers,
    UINT    cNumber,
    BYTE    NumType
    );

LONG
cdecl
OutputFormatStrDELI(
    PPDEV   pPDev,
    CHAR    NumFormatChar,
    LPSTR   pszFormat,
    ...
    );

LONG
cdecl
OutputFormatStr(
    PPDEV   pPDev,
    LPSTR   pszFormat,
    ...
    );

BOOL
OutputCommaSep(
    PPDEV   pPDev
    );

VOID
ClearClipWindow(
    PPDEV pPDev
    );

VOID
SetClipWindow(
    PPDEV   pPDev,
    PRECTL  pClipRectl
    );

VOID
SetPixelPlacement(
    PPDEV   pPDev,
    UINT    SetMode
    );

BOOL
SetRopMode(
    PPDEV   pPDev,
    DWORD   Rop
    );

BOOL
SetHSFillType(
    PPDEV   pPDev,
    DWORD   HSFillTypeIndex,
    LONG    lParam
    );

BOOL
SendPageHeader(
    PPDEV   pPDev
    );

BOOL
SendPageTrailer(
    PPDEV   pPDev
    );



#endif  // _PLOTOUTPUT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\path.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    path.c


Abstract:

    This module contains Functions related to drawing paths. The main stroke
    drawing entry poing DrvStrokePath, is implemented in this module.


    See also textout.c, bitblt.c:  These two have copies of almost all the
    DrvStrokePath() code.


Author:

    17:30 on Wed 03 Apr 1991    
        Created it

    8/18/92  AP
        I have pretty much rewritten most of this.  Some of the original
        code is left in, mainly to point out things that need to be added.

    15-Nov-1993 Mon 19:40:18 updated  
        clean up / debugging information

    30-Nov-1993 Tue 22:32:12 updated  
        style clean up, updated


    01-Feb-1994              updated  
        Added the ability to stroke styled lines through a complex
        clipping object

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPath

#define DBG_STROKEPATH      0x00000001
#define DBG_SELECTCOLOR     0x00000002
#define DBG_STROKECLIPLINES 0x00000004
#define DBG_MOVEPEN         0x00000008


DEFINE_DBGVAR(0);




BOOL
DoStrokePathByEnumingClipLines(
    PPDEV       pPDev,
    SURFOBJ     *pso,
    CLIPOBJ     *pco,
    PATHOBJ     *ppo,
    PPOINTL     pptlBrushOrg,
    BRUSHOBJ    *pbo,
    ROP4        rop4,
    LINEATTRS   *plineattrs
    )

/*++

Routine Description:

    Strokes a path through a complex clipping region by utilizing the
    engine helper functions. This is done because there is no way to
    fail a DrvStrokePath and have it come back in any simpler format by
    the NT graphics engine. In general, we can fail DrvXXX calls and the
    NT graphic engine will simply the object to draw, then call back into
    the driver. Stroking a path however cannot be simplified any more, so
    the best we can hope for is having the PATHOBJ converted to straight
    line segments (removing BEZIERS if present). We then must stroke the
    path ourselves, using the provided EngXXX helpers.
    Since helper functions exist that allow us to to enumerate the
    portions of a path as CLIPLINE segments that fall within the
    clipping region, we do that here, thus stroking the segments that lie
    inside of the passed CLIPOBJ.


Arguments:

    pPDev            Pointer to the current PDEV

    pso              SURFOBJ to write to

    pco              CLIPOBJ to use when enuming paths

    ppo              PATHOBJ to stroke through clip path

    pptlBrushOrg     BRUSH origin

    pbo              BRUSH to stroke with

    rop4             ROP4 to use

    plineattrs       LINEATTRS structure that describes the styling for the line



Return Value:

    TRUE if sucessful FALSE if failed, If the path we are asked to stroke
          contains BEZIERS, this function will fail in order to allow the
          Engine to break the path down to line segments.

Author:


    2/01/94  JB

Revision History:


--*/

{
    PLOT_CLIPLINE   PlotClipLine;
    CLIPLINE        *pCurClipLine;
    RUN             *pCurRun;
    POINTFIX        ptsfx[2];
    POINTL          ptlCur;
    FIX             iStartInFX;
    FIX             iStopInFX;
    LONG            dx;
    LONG            dy;
    LONG            i;
    BOOL            bMore;
    BOOL            bXordered;
    BOOL            bFlipX;
    BOOL            bFlipY;


    //
    // First check for Beziers and if we have them fail the call since we
    // want straight line segments to stroke, with the appropriate style
    //

    if (ppo->fl & PO_BEZIERS) {

        PLOTDBG(DBG_STROKECLIPLINES,
                ("DoStrokePathByEnumingClipLines:Path had BEZ returning FALSE"));
        return(FALSE);
    }

    if (NULL == pco) {

        PLOTDBG(DBG_STROKECLIPLINES,
                ("DoStrokePathByEnumingClipLines:CLIPOBJ is NULL."));
        return(FALSE);
    }

    //
    // Send out the line attributes , so the residue will be calculated
    // correctly
    //

    DoSetupOfStrokeAttributes(pPDev, pptlBrushOrg, pbo, rop4, NULL);

    //
    // Initiate enumeration of the CLIPLINES by calling the Engine helper
    //

    PATHOBJ_vEnumStartClipLines(ppo, pco, pso, plineattrs);

    //
    // Start a loop to enum through all the available CLIPLINE structures
    //

    pCurClipLine = (CLIPLINE *)&PlotClipLine;

    do {

        //
        // Get the first batch of CLIPLINE structures then go to work on them
        //

        bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(PlotClipLine), pCurClipLine);

        //
        // Calculate dx and dy in order to determine if the line is Xordered or
        // Yordered this is needed because of the way the engine passes us RUNS
        // if dx > dy then the line is said to be Xordered and thus any given
        // RUN iStart and iStop values is a projection on the x axis. Given this
        // informatino we can calculate the adjoining Y coordinate and draw the
        // line appropriately.
        //

        dx = pCurClipLine->ptfxB.x - pCurClipLine->ptfxA.x;
        dy = pCurClipLine->ptfxB.y - pCurClipLine->ptfxA.y;



        if ( bFlipX = (dx < 0 )) {

            dx = -dx;
        }

        if ( bFlipY = (dy < 0 )) {

            dy = -dy;
        }


        //
        // Now calculate if the line is x ordered or y ordered
        //

        bXordered = (dx >= dy);

        PLOTDBG(DBG_STROKECLIPLINES,
                   ("DoStrokePathByEnumingClipLines:Compute ClipLine runs=%u, xordered %d",
                   pCurClipLine->c, bXordered ));

        //
        // Enum through all the given RUNS drawing with the pen down between any
        // iStart and iStop value in each RUN
        //

        for (i = 0, pCurRun = &(pCurClipLine->arun[0]);
             i < (LONG)pCurClipLine->c;
             i++, pCurRun++) {


            //
            // The value of iStart and iStop are always positive!! so
            // we must handle it ourselves, so the correct thing happens
            //

            iStartInFX = LTOFX(pCurRun->iStart);
            iStopInFX  = LTOFX(pCurRun->iStop);


            if (bFlipX ) {

                ptsfx[0].x = -iStartInFX;
                ptsfx[1].x = -iStopInFX;

            } else {

                ptsfx[0].x = iStartInFX;
                ptsfx[1].x = iStopInFX;
            }

            if (bFlipY ) {

                ptsfx[0].y = -iStartInFX;
                ptsfx[1].y = -iStopInFX;

            } else {

                ptsfx[0].y = iStartInFX;
                ptsfx[1].y = iStopInFX;
            }


            //
            // We must output the correct line attributes structure with the
            // correct calculated residue in order for this to work correctly
            //

            HandleLineAttributes(pPDev,
                                 plineattrs,
                                 &pCurClipLine->lStyleState,
                                 pCurRun->iStart);



            //
            // The calculations for the opposing coordinate varies based on the
            // ordering of the line. If the line is Xordered we calculate the
            // Y value, if itsYordered we calculate the X value. We do this
            // in order to determine the correct target coordinate. Since the
            // RUN is given to us as START and STOP, we must manually determine
            // what coordinate this represents inside the device coordinate
            // space. If the RUN is xordered, the x-coordinate is correct, and
            // the y-coordinate must be projected based on the ratio.
            //

            if (bXordered) {

                ptsfx[0].x +=  pCurClipLine->ptfxA.x;
                ptsfx[0].y =   MulDiv( ptsfx[0].y, dy, dx) +
                                                        pCurClipLine->ptfxA.y;
                ptsfx[1].x +=  pCurClipLine->ptfxA.x;
                ptsfx[1].y =   MulDiv( ptsfx[1].y, dy, dx) +
                                                        pCurClipLine->ptfxA.y;

            } else {

                ptsfx[0].x =   MulDiv(ptsfx[0].x, dx, dy) +
                                                        pCurClipLine->ptfxA.x;
                ptsfx[0].y +=  pCurClipLine->ptfxA.y;
                ptsfx[1].x =   MulDiv(ptsfx[1].x, dx, dy) +
                                                        pCurClipLine->ptfxA.x;
                ptsfx[1].y +=  pCurClipLine->ptfxA.y;
            }


            //
            // Do PE with pen up first, in order to move to the starting
            // position.
            //

            OutputString(pPDev, "PE<");

            if (!i) {

                //
                // If we are at first point then output that now.
                //

                ptlCur.x =
                ptlCur.y = 0;

                OutputString(pPDev, "=");
            }


            //
            // Stroke the segment with the pen down.
            //

            OutputXYParams(pPDev,
                           (PPOINTL)ptsfx,
                           (PPOINTL)NULL,
                           (PPOINTL)&ptlCur,
                           (UINT)2,
                           (UINT)1,
                           'F');

            OutputString(pPDev, ";");
        }

    } while (bMore);  // While we need to enum again..

    return(TRUE);
}




BOOL
DrvStrokePath(
    SURFOBJ     *pso,
    PATHOBJ     *ppo,
    CLIPOBJ     *pco,
    XFORMOBJ    *pxo,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrushOrg,
    LINEATTRS   *plineattrs,
    MIX         Mix
    )

/*++

Routine Description:

    The driver's function for the StrokePath

Arguments:

    same as EngStrokePath


Return Value:

    TRUE if sucessful FALSE if failed


Author:

    8/18/92 -- t-alip
      Rewrote it.

    30-Nov-1993 Tue 22:21:51 updated  
        updated by DC

    04-Aug-1994 Thu 20:00:23 updated  
        bug# 22348



Revision History:

    31-Jan-1994 Tue 22:21:51 updated  
         Fixed dopolygon to pass in ROP4 not just MIX

--*/

{
    PPDEV   pPDev;
    BOOL    bRetVal;

    UNREFERENCED_PARAMETER(pxo);



    PLOTDBG(DBG_STROKEPATH, ("DrvStrokePath: Mix = %x", Mix));

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvStrokePath: Invalid pPDev"));
        return(FALSE);
    }

    if (!(bRetVal = DoPolygon(pPDev,
                              NULL,
                              pco,
                              ppo,
                              pptlBrushOrg,
                              NULL,
                              pbo,
                              MixToRop4(Mix),
                              plineattrs,
                              FPOLY_STROKE) )) {

       //
       // Since DoPolygon failed, it can only be because we had both a complex
       // clip and a pathobj, so the thing to here is do the stroke via another
       // method using some of the engine helpers.
       //
       // We will also failed when STYLE LINE + DC_RECT when raster plotter is
       // used
       //

       bRetVal = DoStrokePathByEnumingClipLines( pPDev,
                                                 pso,
                                                 pco,
                                                 ppo,
                                                 pptlBrushOrg,
                                                 pbo,
                                                 MixToRop4(Mix),
                                                 plineattrs);




    }

    return(bRetVal);
}



BOOL
MovePen(
    PPDEV       pPDev,
    PPOINTFIX   pPtNewPos,
    PPOINTL     pPtDevPos
    )

/*++

Routine Description:

   This function sends the HPGL code for the requested pen.


Arguments:

    pPDev       - Pointer to the PDEV data structure

    pPtNewPos   - The location pen will move to, this is in 28.4 fix notation

    pPtDevPos   - The new device coordinate device position


Return Value:

    TRUE if sucessful FALSE otherwise


Author:

    1:04 on Tue 7 Nov 1989     
      Added this commentary, and area fill optimization code.

    30-Nov-1993 Tue 22:05:32 updated  
        Update, commented and clean up style

    16-Feb-1994 Wed 17:10:54 updated  
        Re-write to get rid of the physical position

Revision History:


--*/

{
    POINTL  ptDevPos;


    ptDevPos.x = FXTODEVL(pPDev, pPtNewPos->x);
    ptDevPos.y = FXTODEVL(pPDev, pPtNewPos->y);

    if (pPtDevPos) {

        *pPtDevPos = ptDevPos;
    }

    PLOTDBG( DBG_MOVEPEN,
             ("MovePen: Moving Absolute to FIX = [X=%d,%d] Device = [X=%d, Y=%d]",
             pPtNewPos->x,
             pPtNewPos->y,
             ptDevPos.x,
             ptDevPos.y ));


    return(OutputFormatStr(pPDev, "PE<=#D#D;", ptDevPos.x, ptDevPos.y));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\page.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    page.c

Abstract:

    This module has the code that implements job boundary states. The bulk of
    the processing is in DrvStartPage and DrvSendPage.

Author:

    15:30 on Thu 04 Apr 1991    
        Took skeletal code from RASDD

    15-Nov-1993 Mon 19:39:03 updated  
        clean up / fixed / debugging information

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPage

#define DBG_STARTPAGE       0x00000001
#define DBG_SENDPAGE        0x00000002
#define DBG_STARTDOC        0x00000004
#define DBG_ENDDOC          0x00000008

DEFINE_DBGVAR(0);




BOOL
DrvStartPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Function called by NT GDI, to initiate a new page. This function gets
    called first. Before any drawing functions get called for the page.
    This function, should reset the page in the target device, so all
    drawing starts on a clean page. This is also used to sync up our
    internal representation of cached info, in order to send out the
    correct data for the first drawing objects. Things like current position,
    current color, etc.

Arguments:

    pso - Pointer to the SURFOBJ which belong to this driver


Return Value:

    TRUE if sucessful FALSE otherwise

Author:

    15-Feb-1994 Tue 09:58:26 updated  
        Move PhysPosition and AnchorCorner to the SendPageHeader where the
        commmand is sent.

    30-Nov-1993 Tue 23:08:12 created  


Revision History:


--*/

{
    PPDEV   pPDev;


    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvStartPage: invalid pPDev"));
        return(FALSE);
    }

    //
    // initialize some PDEV values for the current plotter state
    // this will force the correct items to get selected in the
    // target device, since these variables are set to undefined states.
    //

    pPDev->CurPenSelected    = -1;
    pPDev->LastDevROP        = 0xFFFF;
    pPDev->Rop3CopyBits      = 0xCC;
    pPDev->LastFillTypeIndex = 0xFFFF;
    pPDev->LastLineType      = PLOT_LT_UNDEFINED;
    pPDev->DevBrushUniq      = 0;

    ResetDBCache(pPDev);

    return(SendPageHeader(pPDev));
}




BOOL
DrvSendPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Called when the drawing has completed for the current page. We now
    send out the necessary codes to image and output the page on the
    target device.

Arguments:

    pso - Pointer to the SURFOBJ which belong to this driver


Return Value:

    TRUE if sucessful FALSE otherwise

Author:

    30-Nov-1993 Tue 21:34:53 created  


Revision History:


--*/

{
    PPDEV   pPDev;


    //
    // Since all the commands that rendered the page have already been
    // sent to the target device, all that is left is to inform the
    // target device to eject the page. With some devices this may cause
    // all the drawing commands that were stored to be executed now.
    //

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvSendPage: invalid pPDev"));
        return(FALSE);
    }

    if (pso->iType == STYPE_DEVICE) {

        return(SendPageTrailer(pPDev));

    } else {

        PLOTRIP(("DrvSendPage: Invalid surface type %ld passed???",
                                    (LONG)pso->iType));
        return(FALSE);
    }
}




BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pwDocName,
    DWORD   JobId
    )

/*++

Routine Description:

    This function is called once at the begining of a job. Not much processing
    for the current driver.

Arguments:

    pso         - Pointer to the SURFOBJ which belong to this driver

    pwDocName   - Pointer to the document name to be started

    JobID       - Job's ID


Return Value:

    BOOL

Author:

    16-Nov-1993 Tue 01:55:15 updated  
        re-write

    08-Feb-1994 Tue 13:51:59 updated  
        Move to StartPage for now


Revision History:


--*/

{
    PPDEV   pPDev;


    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvStartDoc: invalid pPDev"));
        return(FALSE);
    }


    PLOTDBG(DBG_STARTDOC,("DrvStartDoc: DocName = %s", pwDocName));


    return(TRUE);
}




BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   Flags
    )

/*++

Routine Description:

    This function get called to signify the end of a document. Currently
    we don't do any processing here. However if there was any code that
    should be executed only once at the end of a job, this would be the
    place to put it.


Arguments:

    pso     - Pointer to the SURFOBJ for the device

    Flags   - if ED_ABORTDOC bit is set then the document has been aborted


Return Value:


    BOOLLEAN to specified if function sucessful


Author:

    30-Nov-1993 Tue 21:16:48 created  


Revision History:


--*/

{
    PPDEV   pPDev;


    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvEndDoc: invalid pPDev"));
        return(FALSE);
    }

    PLOTDBG(DBG_ENDDOC,("DrvEndDoc called with Flags = %08lx", Flags));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\pdevinfo.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    pdevinfo.c


Abstract:

    This module contains functions to get / validate the PDEV data structure.
    This structure, is initialized by the driver at DrvEnablePDEV time. The
    handle (or pointer) to is passed to most of the drivers DrvXXX exported
    functions. This is how a driver maintains state, about various items
    of interest in the rendering process.


Author:

    30-Nov-1993 Tue 20:37:26 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPDEVInfo

#define DBG_VALIDATE_PDEV   0x00000001


DEFINE_DBGVAR(0);





PPDEV
ValidatePDEVFromSurfObj(
    SURFOBJ    *pso
    )

/*++

Routine Description:

    This function validates the PDEV to see if it belong to this driver and
    checks to see if it is still usable. It also moves the passed SURFOBJ
    in the data structure which is needed for the driver to occasionally call
    EngCheckAbort, to see if the job has been cancelled.


Arguments:

    pPDev   - Pointer to the PDEV data structure to be validate

Return Value:

    return the passed in PDEV pointer if sucessful, return NULL if failed,
    if it return NULL it will also log the INVALID_HANDLE error code


Author:

    30-Nov-1993 Tue 20:39:12 created  


Revision History:


--*/

{
    PPDEV pPDev;


    pPDev = ((PPDEV)(((SURFOBJ *)pso)->dhpdev));


    if (pPDev) {

        //
        // Look for start marker, size of the data structure, and end marker.
        //

        if (pPDev->PDEVBegID == PDEV_BEG_ID) {

            if (pPDev->SizePDEV == sizeof(PDEV)) {

                if (pPDev->PDEVEndID == PDEV_END_ID) {

                    //
                    // Okay its valid so record the surfobj so we can call
                    // EngCheckAbort() in our output functions
                    //

                    pPDev->pso = pso;

                    //
                    // Check to see if the app or the spooler has canceled
                    // the job, if it has set our cancel bit and fail this
                    // call.
                    //

                    if (EngCheckAbort(pso)) {
                       pPDev->Flags |= PDEVF_CANCEL_JOB;
                       PLOTDBG(DBG_VALIDATE_PDEV,
                                 ("ValidatePDEV: EngCheckAbort returns TRUE"));
                       return(NULL);
                    }

                    return(pPDev);

                } else {

                    PLOTRIP(("ValidatePDEV: Invalid PDEV End ID (%08lx)",
                                                            pPDev->PDEVEndID));
                }

            } else {

                PLOTRIP(("ValidatePDEV: Invalid PDEV size (%ld)",
                                                        pPDev->SizePDEV));
            }

        } else {

            PLOTRIP(("ValidatePDEV: Invalid PDEV Begin ID (%08lx)",
                                        pPDev->PDEVBegID));
        }

    } else {

        PLOTRIP(("ValidatePDEV: NULL pPDev"));
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\plotform.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotform.h


Abstract:

    This module contains prototypes for the plotform.c


Author:

    30-Nov-1993 Tue 20:32:06 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _PLOTFORM_
#define _PLOTFORM_


BOOL
SetPlotForm(
    PPLOTFORM       pPlotForm,
    PPLOTGPC        pPlotGPC,
    PPAPERINFO      pCurPaper,
    PFORMSIZE       pCurForm,
    PPLOTDEVMODE    pPlotDM,
    PPPDATA         pPPData
    );

#endif  // _PLOTFORM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\pdevinfo.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    pdevinfo.h


Abstract:

    This module contains prototypes for pdevinfo.c


Author:

    30-Nov-1993 Tue 20:37:51 created  

    07-Dec-1993 Tue 00:21:25 updated  
        change dhsurf to dhpdev in SURFOBJ_GETPDEV

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

   Dec 06 1993,       Fixed to grab pdev from dhpdev instead of dhsurf

--*/


#ifndef _PDEVINFO_
#define _PDEVINFO_


PPDEV
ValidatePDEVFromSurfObj(
    SURFOBJ *
    );

#define SURFOBJ_GETPDEV(pso)    ValidatePDEVFromSurfObj(pso)


#endif  // _PDEVINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\plotform.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotform.c


Abstract:

    This module contains functions to set the correct HPGL/2 plotter
    coordinate system


Author:

    30-Nov-1993 Tue 20:31:28 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPlotForm


#define DBG_PLOTFORM        0x00000001
#define DBG_FORMSIZE        0x00000002
#define DBG_INTERNAL_ROT    0x00000004
#define DBG_PF              0x00000008


DEFINE_DBGVAR(0);



#if DBG

LPSTR   pBmpRotMode[] = { "----- NONE -----",
                          "BMP_ROT_RIGHT_90" };

#endif




BOOL
SetPlotForm(
    PPLOTFORM       pPlotForm,
    PPLOTGPC        pPlotGPC,
    PPAPERINFO      pCurPaper,
    PFORMSIZE       pCurForm,
    PPLOTDEVMODE    pPlotDM,
    PPPDATA         pPPData
    )

/*++

Routine Description:

    This function computes the current FORM based on the printed margin. Auto
    rotation, landscape and other attributes are taken into account. The
    result is put into a PLOTFORM data structure located in our PDEV. This
    information is used to report data to GDI, as well as compute the HPGL2
    parameters for sizing the target surface.

Arguments:

    pPlotForm   - Pointer to the PLOTFROM data structure which will be updated

    pPlotGPC    - Pointer to the PLOTGPC data structure

    pCurPaper   - Pointer to the PAPERINFO for the paper loaded

    pCurForm    - Pointer to the FORMSIZE for the requested form

    pPlotDM     - Pointer to the validated PLOTDEVMODE data structure

    pPPData     - Pointer to the PPDATA structure

Return Value:

    TRUE if sucessful, FALSE if failed

Author:

    29-Nov-1993 Mon 13:58:09 created  

    17-Dec-1993 Fri 23:09:38 updated  
        Re-write so that we will look at CurPaper rather than pCurForm when
        setting the PSSize, p1/p2 stuff, it also rotate the pCurPaper if
        GPC/user said that the paper should loaded side way

    20-Dec-1993 Mon 12:59:38 updated  
        correct PFF_xxxx flag setting so we always rotate the bitmap to the
        left 90 degree

    23-Dec-1993 Thu 20:35:57 updated  
        Fixed roll paper clipping problem, change behavior, if we have roll
        paper installed then the it will make hard clip limit as big as user
        specified form size.

    24-Dec-1993 Fri 12:20:02 updated  
        Re-plot again, this is become really paint just try to understand what
        HP plotter design problems

    06-Jan-1994 Thu 00:22:45 updated  
        Update SPLTOPLOTUNITS() macro

    07-Feb-1996 Wed 15:46:06 updated  
        Change it so that it always using the current devmode form and then
        clip it to the device size.


Revision History:


    This assumes that the user inserted the paper with width of the form
    first,


    LEGEND:

     +     = Original paper corners
     *     = Original plotter origin and its X/Y coordinate
     @     = the rotated origin using 'RO' command, intended to rotate the X/Y
             axis to the correct orientation for the window system
     #     = Final plotter origin and its X/Y coordinate
     p1,p2 = final P1/P2 which will be used by the plotter driver
     cx,cy = Original paper width/height


     The following explaines how HPGL/2 loads the paper/form and
     assigns the default coordinate system to it, it also shows which way the
     paper is moving,  the illustration to the right is when we need to
     rotate the printing direction and coordinate system when user selects
     the non-conforming X/Y coordinate system as opposed to the HPGL/2 default.


    =======================================================================
    LENGTH >= WIDTH (CY >= CX) case
    =======================================================================

      Portrait Paper      Rotate             Change Origin
      Default             Left 90            Negative Y

    p2   cx                  cx    p1            cx
     +---------+         +---------+         +---------+
     |         |         | <------@|         |         |
     |         |         |    X   ||         |        ^|
     | |      ^|         | |      ||         | |      ||
    c| M      ||  RO90  c| M      ||   IP   c| M      ||
    y| o      || =====> y| o      ||  ====> y| o      ||
     | v      ||         | v     Y||         | v     Y||
     | e     X||         | e      ||         | e      ||
     | |      ||         | |      ||         | |      ||
     | V      ||         | V      ||         | V      ||
     |     Y  ||         |        V|         |     X  ||
     | <------*|         |         |         | <------#|
     +---------+         +---------+         +---------+
               p1       p2

         |
       IP|
         |
         V


      Change Origin
      Negative X

         cx
     +---------+
     | <------#|
     |    Y   ||
     | |      ||
    c| M      ||
    y| o      ||
     | v     X||
     | e      ||
     | |      ||
     | V      ||
     |        V|
     |         |
     +---------+

    =======================================================================
    LENGTH < WIDTH (CY < CX) case
    =======================================================================

     Landscape                  Rotate Left 90           Change Origin
     Paper Default                                       Negative X

           cx        p2        p2       cx                       cx
     +---------------+          +---------------+        +---------------+
     |               |          |               |        |     <--------#|
     |^            | |          | |            ^|        | |       Y    ||
    c||            M |         c| M            ||       c| M            ||
    y||            o |         y| o            ||       y| o            ||
     ||            v |   RO90   | v           X||  IP    | v           X||
     ||Y           e |  =====>  | e            || ====>  | e            ||
     ||            | |          | |            ||        | |            ||
     ||   X        V |          | V       Y    ||        | V            V|
     |*-------->     |          |     <--------@|        |               |
     +---------------+          +---------------+        +---------------+
    p1                                      p1

           |
         IP|
           |
           V

      Change Origin
      Negative X

             cx
     +---------------+
     |               |
     | |            ^|
    c| M            ||
    y| o            ||
     | v           Y||
     | e            ||
     | |            ||
     | V       X    ||
     |     <--------#|
     +---------------+


--*/

{
    PLOTFORM    PF;
    FORMSIZE    DevForm;
    FORMSIZE    ReqForm;
    RECTL       rclDev;
    RECTL       rclLog;
    SIZEL       DeviceSize;
    LONG        lTemp;
    BOOL        DoRotate;


    PLOTDBG(DBG_PF, ("\n************* SetPlotForm *************\n"));

    //
    // We default using DeviceSize to check against the requested paper
    //

    DeviceSize = pPlotGPC->DeviceSize;
    rclDev     = pPlotGPC->DeviceMargin;
    DoRotate   = FALSE;

    //
    // Assume we using the current form from the devmode
    //

    DevForm =
    ReqForm = *pCurForm;

    PLOTDBG(DBG_PF, ("DeviceSize: %ld x %ld,  L=%ld, T=%ld, R=%ld, B=%ld",
                    DeviceSize.cx, DeviceSize.cy,
                    rclDev.left, rclDev.top, rclDev.right, rclDev.bottom));
    PLOTDBG(DBG_PF, ("ReqForm: <%s>",
                    pPlotDM->dm.dmFormName, ReqForm.Size.cx, ReqForm.Size.cy));
    PLOTDBG(DBG_PF, ("ReqForm: %ld x %ld,  L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    ReqForm.Size.cx, ReqForm.Size.cy,
                    ReqForm.ImageArea.left, ReqForm.ImageArea.top,
                    ReqForm.ImageArea.right, ReqForm.ImageArea.bottom,
                    ReqForm.ImageArea.right - ReqForm.ImageArea.left,
                    ReqForm.ImageArea.bottom - ReqForm.ImageArea.top));

    if (pCurPaper->Size.cy == 0) {

        //
        // ROLL PAPER CASE
        //
        // If we have roll paper installed, we must determine the projection
        // of the current form on the roll paper in order to get the size
        // to come out correctly.
        //

        DevForm.Size.cx = pCurPaper->Size.cx;
        DevForm.Size.cy = DeviceSize.cy;

        PLOTDBG(DBG_PF,(">>ROLL FEED<< RollPaper = %ld x %ld, <RESET rclDev to ALL ZEROs>",
                        DevForm.Size.cx, DevForm.Size.cy));

    } else if ((pPlotGPC->Flags & PLOTF_PAPERTRAY) &&
               ((DevForm.Size.cx == DeviceSize.cx) ||
                (DevForm.Size.cy == DeviceSize.cx))) {

        //
        // PAPER TRAY CASE: We need to make the DeviceSize equal to the DevForm
        // so that the margin will be correctly computed
        //

        DoRotate = (BOOL)(DevForm.Size.cx != DeviceSize.cx);

        PLOTDBG(DBG_PF,(">>PAPER TRAY<<  Rotate Paper = %hs",
                                            (DoRotate) ? "YES" : "NO"));


    } else {

        PLOTASSERT(0, "SetPlotForm: Not supposed MANUAL feed the PAPER TRAY type PLOTTER",
                   !(pPlotGPC->Flags & PLOTF_PAPERTRAY), pPlotGPC->Flags);

        PLOTDBG(DBG_PF,(">>MANUAL FEED<<"));

        //
        // MANUAL FEED CASE, this is the way paper is physically loaded, only
        // problem is if the paper is smaller than device can handle then we
        // really don't know where they inserted the paper.
        //

        DoRotate = (BOOL)(!(pPPData->Flags & PPF_MANUAL_FEED_CX));

        PLOTDBG(DBG_PF,("The MANUAL FEED paper Inserted %hs side first.",
                    (DoRotate) ? "Length CY" : "Width CX"));
    }

    if (DoRotate) {

        SWAP(DevForm.Size.cx, DevForm.Size.cy, lTemp);

        PLOTDBG(DBG_PF, ("### Rotated DevForm to %ld x %ld ###",
                        DevForm.Size.cx, DevForm.Size.cy));
    }

    //
    // Make sure largest requested form can be installed on the plotter
    //

    if (DevForm.Size.cx > DeviceSize.cx) {

        PLOTDBG(DBG_PF, ("WIDTH: DevForm (%ld) > DeviceSize (%ld). CORRECT IT",
                    DevForm.Size.cx, DeviceSize.cx));

        DevForm.Size.cx = DeviceSize.cx;
    }

    if (DevForm.Size.cy > DeviceSize.cy) {

        PLOTDBG(DBG_PF, ("HEIGHT: DevForm (%ld) > DeviceSize (%ld). CORRECT IT",
                    DevForm.Size.cy, DeviceSize.cy));

        DevForm.Size.cy = DeviceSize.cy;
    }

    //
    // Figure out how to fit this requested form onto loaded device form
    //

    DoRotate = FALSE;

    if ((DevForm.Size.cx >= ReqForm.Size.cx) &&
        (DevForm.Size.cy >= ReqForm.Size.cy)) {

        //
        // Can print without doing any rotation, but check for paper saver,
        // the paper saver is only possible if:
        //
        //  1) Is a Roll paper,
        //  2) User approves
        //  3) ReqForm length > width
        //  4) DevForm width >= ReqForm length
        //

        if ((pCurPaper->Size.cy == 0)               &&
            (pPPData->Flags & PPF_AUTO_ROTATE)      &&
            (ReqForm.Size.cy >  ReqForm.Size.cx)    &&
            (DevForm.Size.cx >= ReqForm.Size.cy)) {

            PLOTDBG(DBG_PF, ("ROLL PAPER SAVER: Doing AUTO_ROTATE"));

            DoRotate = !DoRotate;
        }

    } else if ((DevForm.Size.cx >= ReqForm.Size.cy) &&
               (DevForm.Size.cy >= ReqForm.Size.cx)) {

        //
        // Can print but we have to rotate the form ourselves
        //

        PLOTDBG(DBG_PF, ("INTERNAL ROTATE to fit Requseted FROM into device"));

        DoRotate = !DoRotate;

    } else {

        //
        // CANNOT print the requested form, so clip the form requested
        //

        PLOTDBG(DBG_PF, (">>>>> ReqForm is TOO BIG to FIT, Need to CLIP IT <<<<<"));

        ReqForm.Size = DevForm.Size;
    }

    if (DoRotate) {

        DoRotate = (BOOL)(pPlotDM->dm.dmOrientation != DMORIENT_LANDSCAPE);

        //
        // If we need to rotate one more time back to the same position for
        // the logical paper size then we must rotate to the left first, this
        // is because ALL our ORIGIN x,y are either at the front of the plotter
        // or at the front panel side of the plotter
        //

        RotatePaper(&(ReqForm.Size),
                    &(ReqForm.ImageArea),
                    (DoRotate) ? RM_L90 : RM_R90);

        PLOTDBG(DBG_PF, ("INTERNAL Rotated ReqForm: %ld x %ld, L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    ReqForm.Size.cx, ReqForm.Size.cy,
                    ReqForm.ImageArea.left, ReqForm.ImageArea.top,
                    ReqForm.ImageArea.right, ReqForm.ImageArea.bottom,
                    ReqForm.ImageArea.right - ReqForm.ImageArea.left,
                    ReqForm.ImageArea.bottom - ReqForm.ImageArea.top));

    } else {

        DoRotate = (BOOL)(pPlotDM->dm.dmOrientation == DMORIENT_LANDSCAPE);
    }

    //
    // Now the ReqForm is guaranteed to fit into the device paper. Find out how
    // it fits into the printable area and set the hardware margins appropriately.
    //

    DevForm.Size             = ReqForm.Size;
    DevForm.ImageArea.left   = rclDev.left;
    DevForm.ImageArea.top    = rclDev.top;
    DevForm.ImageArea.right  = DevForm.Size.cx - rclDev.right;
    DevForm.ImageArea.bottom = DevForm.Size.cy - rclDev.bottom;

    //
    // Intersect the requested form imageable area with the DevForm imageable area
    //

    IntersectRECTL(&(ReqForm.ImageArea), &(DevForm.ImageArea));

    //
    // Now figure out the offset from the logical margin to the physical margin
    //

    rclLog.left   = ReqForm.ImageArea.left - DevForm.ImageArea.left;
    rclLog.top    = ReqForm.ImageArea.top - DevForm.ImageArea.top;
    rclLog.right  = DevForm.ImageArea.right -  ReqForm.ImageArea.right;
    rclLog.bottom = DevForm.ImageArea.bottom -  ReqForm.ImageArea.bottom;

    //
    // Rotate the requested form if necessary
    //

    if (DoRotate) {

        RotatePaper(&(ReqForm.Size), &(ReqForm.ImageArea), RM_R90);

        //
        // Now we can pick the right margin/corner for the rotation
        //
        //         cx        Rotate Left 90     Rotate Right 90
        //      +-------+
        //      |   T   |         cy                 cy
        //      |       |    +------------+     +------------+
        //     c|       |    |     R      |     |     L      |
        //     y|       |   c|            |    c|            |
        //      |L     R|   x|            |    x|            |
        //      |       |    |T          B|     |B          T|
        //      |       |    |            |     |            |
        //      |       |    |     L      |     |     R      |
        //      |   B   |    +------------+     +------------+
        //      +-------+
        //

        PLOTDBG(DBG_PF, ("ROTATED RIGHT ReqForm: %ld x %ld, L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    ReqForm.Size.cx, ReqForm.Size.cy,
                    ReqForm.ImageArea.left, ReqForm.ImageArea.top,
                    ReqForm.ImageArea.right, ReqForm.ImageArea.bottom,
                    ReqForm.ImageArea.right - ReqForm.ImageArea.left,
                    ReqForm.ImageArea.bottom - ReqForm.ImageArea.top));
    }

    PLOTDBG(DBG_PF, ("FINAL DevForm: %ld x %ld, L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    DevForm.Size.cx, DevForm.Size.cy,
                    DevForm.ImageArea.left, DevForm.ImageArea.top,
                    DevForm.ImageArea.right, DevForm.ImageArea.bottom,
                    DevForm.ImageArea.right - DevForm.ImageArea.left,
                    DevForm.ImageArea.bottom - DevForm.ImageArea.top));
    PLOTDBG(DBG_PF, ("FINAL ReqForm: %ld x %ld, L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    ReqForm.Size.cx, ReqForm.Size.cy,
                    ReqForm.ImageArea.left, ReqForm.ImageArea.top,
                    ReqForm.ImageArea.right, ReqForm.ImageArea.bottom,
                    ReqForm.ImageArea.right - ReqForm.ImageArea.left,
                    ReqForm.ImageArea.bottom - ReqForm.ImageArea.top));
    PLOTDBG(DBG_PF, ("rclLog: L=%ld, T=%ld, R=%ld, B=%ld",
                    rclLog.left, rclLog.top, rclLog.right, rclLog.bottom));

    //
    // Set fields in PLOTFORM
    //

    PF.Flags       = 0;
    PF.BmpRotMode  = BMP_ROT_NONE;
    PF.NotUsed     = 0;
    PF.PlotSize.cx = DevForm.ImageArea.right - DevForm.ImageArea.left;
    PF.PlotSize.cy = DevForm.ImageArea.bottom - DevForm.ImageArea.top;
    PF.PhyOrg.x    = ReqForm.ImageArea.left;
    PF.PhyOrg.y    = ReqForm.ImageArea.top;
    PF.LogSize     = ReqForm.Size;
    PF.LogExt.cx   = ReqForm.ImageArea.right - ReqForm.ImageArea.left;
    PF.LogExt.cy   = ReqForm.ImageArea.bottom - ReqForm.ImageArea.top;
    PF.BmpOffset.x = rclLog.left;
    PF.BmpOffset.y = rclLog.top;

    if (PF.PlotSize.cy >= PF.PlotSize.cx) {

        PLOTDBG(DBG_FORMSIZE,(">>>>> Plot SIze: CY >= CX (%ld: VERTICAL%hs) <<<<<",
                    (DoRotate) ? 1 : 2,
                    (DoRotate) ? " + ROTATE" : ""));

        //
        // The Standard HPGL/2 coordinate Y direction in in reverse, the scale
        // is from Max Y to 0.
        //

        if (DoRotate) {

            //
            //   Portrait Paper     Scale Coord X
            //   Default            Negative X
            //
            // p2   cx                  cx
            //  +---------+         +---------+
            //  |         |         | <------#|
            //  |         |         |    Y   ||
            //  | |      ^|         | |      ||
            // c| M      ||        c| M      ||
            // y| o      || ====>  y| o      ||
            //  | v      ||         | v     X||
            //  | e     X||         | e      ||
            //  | |      ||         | |      ||
            //  | V      ||         | V      ||
            //  |     Y  ||         |        V|
            //  | <------*|         |         |
            //  +---------+         +---------+
            //            p1
            //

            PF.Flags      |= PFF_FLIP_X_COORD;
            PF.BmpRotMode  = BMP_ROT_RIGHT_90;
            PF.LogOrg.x    = rclLog.top;
            PF.LogOrg.y    = rclLog.left;

        } else {

            //
            //   Portrait Paper      Rotate            Scale Coord Y
            //   Default             Left 90           Negative Y
            //
            // p2   cx                  cx    p1           cx
            //  +---------+         +---------+        +---------+
            //  |         |         | <------@|        |         |
            //  |         |         |    X   ||        |        ^|
            //  | |      ^|         | |      ||        | |      ||
            // c| M      ||  RO90  c| M      ||       c| M      ||
            // y| o      || =====> y| o      || ====> y| o      ||
            //  | v      ||         | v     Y||        | v     Y||
            //  | e     X||         | e      ||        | e      ||
            //  | |      ||         | |      ||        | |      ||
            //  | V      ||         | V      ||        | V      ||
            //  |     Y  ||         |        V|        |     X  ||
            //  | <------*|         |         |        | <------#|
            //  +---------+         +---------+        +---------+
            //            p1       p2
            //

            PF.Flags    |= (PFF_ROT_COORD_L90 | PFF_FLIP_Y_COORD);
            PF.LogOrg.x  = rclLog.left;
            PF.LogOrg.y  = rclLog.bottom;
        }

    } else {

        PLOTDBG(DBG_FORMSIZE,(">>>>> SetPlotForm: CY < CX (%ld: HORIZONTAL%hs) <<<<<",
                    (DoRotate) ? 3 : 4,
                    (DoRotate) ? " + ROTATE" : ""));

        //
        // The Standard HPGL/2 coordinate X direction in in reverse, the scale
        // is from Max X to 0
        //

        if (DoRotate) {

            //
            //  DoRotate                Rotate Left 90         Scale Coord X
            //  Paper Default                                  Negative X
            //
            //        cx       p2      p2      cx                     cx
            //  +---------------+       +---------------+     +---------------+
            //  |               |       |               |     |     <--------#|
            //  |^            | |       | |            ^|     | |       Y    ||
            // c||            M |      c| M            ||    c| M            ||
            // y||            o |      y| o            ||    y| o            ||
            //  ||            v | RO90  | v           X||     | v           X||
            //  ||Y           e |=====> | e            || ==> | e            ||
            //  ||            | |       | |            ||     | |            ||
            //  ||   X        V |       | V       Y    ||     | V            V|
            //  |*-------->     |       |     <--------@|     |               |
            //  +---------------+       +---------------+     +---------------+
            // p1                                      p1
            //

            PF.Flags      |= (PFF_ROT_COORD_L90 | PFF_FLIP_X_COORD);
            PF.BmpRotMode  = BMP_ROT_RIGHT_90;
            PF.LogOrg.x    = rclLog.top;
            PF.LogOrg.y    = rclLog.left;

        } else {

            //
            //  DoRotate                   Scale Coord X
            //  Paper Default              Negative X
            //
            //        cx       p2                cx
            //  +----------------+         +-----------------+
            //  |                |         |                 |
            //  |^             | |         | |              ^|
            // c||             M |        c| M              ||
            // y||             o |        y| o              ||
            //  ||             v |  ====>  | v             Y||
            //  ||Y            e |         | e              ||
            //  ||             | |         | |              ||
            //  ||   X         V |         | V         X    ||
            //  |*-------->      |         |       <--------#|
            //  +----------------+         +-----------------+
            // p1
            //

            PF.Flags    |= PFF_FLIP_X_COORD;
            PF.LogOrg.x  = rclLog.right;
            PF.LogOrg.y  = rclLog.top;
        }
    }

    PLOTDBG(DBG_PF, ("FINAL LogOrg: (%ld, %ld),  PhyOrg=(%ld, %ld)",
                    PF.LogOrg.x, PF.LogOrg.y, PF.PhyOrg.x, PF.PhyOrg.y));

    //
    // Save result and output some information
    //

    *pPlotForm = PF;

    PLOTDBG(DBG_PLOTFORM,("******************************************************"));
    PLOTDBG(DBG_PLOTFORM,("******* SetPlotForm: ****** %hs --> %hs ******\n",
                        (pPlotDM->dm.dmOrientation == DMORIENT_LANDSCAPE) ?
                                                    "LANDSCAPE" : "PORTRAIT",
                                    (DoRotate) ? "LANDSCAPE" : "PORTRAIT"));
    PLOTDBG(DBG_PLOTFORM,("        Flags =%hs%hs%hs",
            (PF.Flags & PFF_ROT_COORD_L90) ? " <ROT_COORD_L90> " : "",
            (PF.Flags & PFF_FLIP_X_COORD)  ? " <FLIP_X_COORD> " : "",
            (PF.Flags & PFF_FLIP_Y_COORD)  ? " <FLIP_Y_COORD> " : ""));
    PLOTDBG(DBG_PLOTFORM,("   BmpRotMode = %hs", pBmpRotMode[PF.BmpRotMode]));
    PLOTDBG(DBG_PLOTFORM,("     PlotSize = (%7ld x%7ld) [%5ld x%6ld]",
            PF.PlotSize.cx, PF.PlotSize.cy,
            SPLTOPLOTUNITS(pPlotGPC, PF.PlotSize.cx),
            SPLTOPLOTUNITS(pPlotGPC, PF.PlotSize.cy)));
    PLOTDBG(DBG_PLOTFORM,("PhyOrg/Offset = (%7ld,%8ld) [%5ld,%7ld] ",
            PF.PhyOrg.x, PF.PhyOrg.y,
            SPLTOPLOTUNITS(pPlotGPC, PF.PhyOrg.x),
            SPLTOPLOTUNITS(pPlotGPC, PF.PhyOrg.y)));
    PLOTDBG(DBG_PLOTFORM,("      LogSize = (%7ld x%7ld) [%5ld x%6ld]",
            PF.LogSize.cx, PF.LogSize.cy,
            SPLTOPLOTUNITS(pPlotGPC, PF.LogSize.cx),
            SPLTOPLOTUNITS(pPlotGPC, PF.LogSize.cy)));
    PLOTDBG(DBG_PLOTFORM,("    LogOrg/p1 = (%7ld,%8ld) [%5ld,%7ld]",
            PF.LogOrg.x, PF.LogOrg.y,
            SPLTOPLOTUNITS(pPlotGPC, PF.LogOrg.x),
            SPLTOPLOTUNITS(pPlotGPC, PF.LogOrg.y)));
    PLOTDBG(DBG_PLOTFORM,("       LogExt = (%7ld,%8ld) [%5ld,%7ld]\n",
            PF.LogExt.cx, PF.LogExt.cy,
            SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cx),
            SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cy)));
    PLOTDBG(DBG_PLOTFORM,("    BmpOffset = (%7ld,%8ld) [%5ld,%7ld]",
            PF.BmpOffset.x, PF.BmpOffset.y,
            SPLTOPLOTUNITS(pPlotGPC, PF.BmpOffset.x),
            SPLTOPLOTUNITS(pPlotGPC, PF.BmpOffset.y)));
    PLOTDBG(DBG_PLOTFORM,
            ("Commands=PS%ld,%ld;%hsIP%ld,%ld,%ld,%ld;SC%ld,%ld,%ld,%ld\n",
            SPLTOPLOTUNITS(pPlotGPC, PF.PlotSize.cy),
            SPLTOPLOTUNITS(pPlotGPC, PF.PlotSize.cx),
            (PF.Flags & PFF_ROT_COORD_L90) ? "RO90;" : "",
            SPLTOPLOTUNITS(pPlotGPC, PF.LogOrg.x),
            SPLTOPLOTUNITS(pPlotGPC, PF.LogOrg.y),
            SPLTOPLOTUNITS(pPlotGPC, (PF.LogOrg.x + PF.LogExt.cx)) - 1,
            SPLTOPLOTUNITS(pPlotGPC, (PF.LogOrg.y + PF.LogExt.cy)) - 1,
            (PF.Flags & PFF_FLIP_X_COORD) ?
                    SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cx) - 1 : 0,
            (PF.Flags & PFF_FLIP_X_COORD) ?
                    0 : SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cx) - 1,
            (PF.Flags & PFF_FLIP_Y_COORD) ?
                    SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cy) - 1 : 0,
            (PF.Flags & PFF_FLIP_Y_COORD) ?
                    0 : SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cy) - 1));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\pencolor.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    pencolor.h


Abstract:

    This module contains defines for pencolor.c


Author:

    15-Jan-1994 Sat 04:50:57 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PENCOLOR_
#define _PENCOLOR_


LONG
GetColor(
    PPDEV       pPdev,
    BRUSHOBJ    *pbo,
    LPDWORD     pColorFG,
    PDEVBRUSH   *ppDevBrush,
    ROP4        Rop4
    );


VOID
SelectColor(
    PPDEV       pPDev,
    DWORD       Color,
    INTDECIW    PenWidth
    );

#endif  // _PENCOLOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\plotters.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotters.h


Abstract:

    This module contains basic plotter infomation to be includes by most of
    the source file

    This module contains the bulk of the plotter driver defines. It is included
    by most modules.


Development History:

    18-Nov-1993 Thu 01:25:51 created  
        Wrote for the Windows.

    07-Dec-1993 Tue 01:14:40 updated  
        another round of clean up, adding new PDEV stuff

    21-Dec-1993 Tue 10:58:03 updated  
        Change PLOTFORM's flags
        Replaced PAL_BGR_ENTRY with PALENTRY and moved all pen cached stuff to
        local output.c

    06-Jan-1994 Thu 00:05:56 updated  
        remove PLOTTER_UNIT_DPI and used pPlotGPC->PlotXDPI in GPC,
        change PDEV's wCurPenSelected to CurPenSelected (WORD to LONG) to have
        DWORD aligned for next field in the structure.

    14-Jan-1994 Fri 20:24:12 updated  
        Change DEVBRUSH

    19-Jan-1994 Wed 14:28:45 updated  
        Adding hack to handle EngStretchBlt() to our own temp surfobj

    27-Jan-1994 Thu 23:38:48 updated  
        Add DBCACHE structure, modify PDEV to handle cached fill type and
        cached User defined pattern

    03-Mar-1994 Thu 09:40:36 updated  
        Remove dead stufff which confused, adding minimum required DDI version
        for this plotter driver to run

    18-Mar-1994 Fri 12:58:24 updated  
        Adding ptlRTLCAP in PDEV to catch the RTL relative position problem
        Adding PLOTF_RTL_NO_DPI_XY, PLOTF_RTLMONO_NO_CID and
        PLOTF_RTLMONO_FIXPAL flags

    12-Apr-1994 Tue 14:14:15 updated  
        Changed DIVRNDUP from +0.5 round up to round to next smallest integer

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]

    13-Apr-1994 Wed 14:29:57 updated  

        FXTOL(x) is assumed to be (X >> 4) (Defined by WINDDI.H)
        LTOFX(x) is (X << 4)

        IF WINDDI.H changes that definition then we must change LTOFX and
        FXTOL2(x)

Revision History:


--*/

#ifndef _PLOTTER_MAIN_HEADER_
#define _PLOTTER_MAIN_HEADER_

#define DRIVER_VERSION      0x0500

#define COUNT_ARRAY(x)      (sizeof((x)) / sizeof((x)[0]))
#define ABS(Value)          ((Value) > 0 ? (Value) : (-(Value)))
#define DW_ALIGN(x)         (((DWORD)(x) + 3) & ~(DWORD)3)


//
// In order to have the style units mean something we break them up
// into units that are 1/25 of an inch.
//
#define PLOT_STYLE_STEP(p) ((p)->lCurResolution / 25)

//
// Define where WHITE is when the plotter driver is a Pallete device
//
#define WHITE_INDEX         0


//
// The PALENTRY is the correct RGB order for the plotter driver, if any changes
// need to be made to the order then only this structure needs to be changed.
//
// CURRENTLY it is in Blue/Green/Red order, for accessing bits in the BGR format
// instead of RGB
//

typedef struct PALENTRY {
    BYTE    B;
    BYTE    G;
    BYTE    R;
    BYTE    Flags;
    } PALENTRY, FAR *PPALENTRY;


#define PFF_ROT_COORD_L90       0x0001
#define PFF_FLIP_X_COORD        0x0002
#define PFF_FLIP_Y_COORD        0x0004

#define BMP_ROT_NONE            0
#define BMP_ROT_RIGHT_90        1


typedef struct _PLOTFORM {
    WORD    Flags;              // PFF_xxxx flags;
    BYTE    BmpRotMode;         // BMP_ROT_xxx
    BYTE    NotUsed;            // not used
    SIZEL   PlotSize;           // Hard Clip Limit SIZE Size for PS cmd
    POINTL  PhyOrg;             // Physical origin from PlotSize origin
    SIZEL   LogSize;            // Logical Paper Size in 1/1000mm unit
    POINTL  LogOrg;             // Logical left/top margin in 1/1000mm unit
    SIZEL   LogExt;             // Printable area in 1/1000mm unit
    POINTL  BmpOffset;          // Bitmap Offset location
    } PLOTFORM, FAR *PPLOTFORM;


//
// Define the PDEV that this driver uses.
//

#define PDEV_BEG_ID             'tolP'
#define PDEV_END_ID             'VEDP'

#define RF_MAX_IDX              8

typedef struct _DBCACHE {
    WORD    RFIndex;            // RF command index 1-RF_MAX_IDX
    WORD    DBUniq;             // unique for cache
    } DBCACHE, FAR *PDBCACHE;


typedef struct _INTDECIW {
    WORD    Integer;
    WORD    Decimal;
    } INTDECIW, *PINTDECIW;

#define PW_HATCH_INT    0
#define PW_HATCH_DECI   26


typedef struct _PDEV {
    DWORD           PDEVBegID;          // Check if we got the right one

    DWORD           SizePDEV;           // pdev size to be checked against
    DWORD           Flags;              // PDEVF_xxx
    HDEV            hpdev;              // Engines handle to this structure
    HSURF           hsurf;              // Engine's handle to drawing surface
    HPALETTE        hPalDefault;        // default palette for pdev
    SURFOBJ         *pso;               // Current surface
    HANDLE          hPrinter;           // handle to the current pdev printer
    SURFOBJ         *psoHTBlt;          // temporary blt surfobj
    RECTL           rclHTBlt;           // location for curreent psoHTBlt
    PPLOTGPC        pPlotGPC;           // plotter characterization data
    LPBYTE          pOutBuffer;         // output buffer location
    DWORD           cbBufferBytes;      // current count of bytes in output buffer
    PLOTDEVMODE     PlotDM;             // plotter extended devmode structure
    FORMSIZE        CurForm;            // Current user requested form
    PAPERINFO       CurPaper;           // current loaded paper
    PPDATA          PPData;             // PrinterProperties data PPDATA
    PLOTFORM        PlotForm;           // computed current selected form
    LONG            lCurResolution;     // The current resolution.
    LONG            VertRes;            // Printable page height, pels
    LONG            HorzRes;            // Printable page width, pels
    POINTL          ptlAnchorCorner;    // current brush origin.
    POINTL          ptlRTLCAP;          // Current RTL CAP
    RECTL           rclCurClip;         // current clipping rectangle
    LPVOID          pTransPosTable;     // bitmap rotation xlate table
    LPVOID          pvDrvHTData;        // device's halftone info
    LPVOID          pPenCache;          // Pointer to the device pen cache
    LONG            BrightestPen;       // brightest pen for pen plotter
    LONG            CurPenSelected;     // Tracks the pen currently in plotter
    WORD            LastDevROP;         // Current MERGE (ROP2) sent to plotter
    WORD            Rop3CopyBits;       // Rop3 used in DrvCopyBits()
    WORD            LastFillTypeIndex;  // last filltype (FT) index sent
    WORD            LastLineType;       // Last line type used (LT)
    WORD            MinLToDevL;         // Min RasDPI->PlotDPI Transform unit
    WORD            DevBrushUniq;       // uniq number for DEVBRUSH cache
    INTDECIW        PenWidth;           // pen width variable cache
    DBCACHE         DBCache[RF_MAX_IDX];// DevBrush cache

    DWORD           PDEVEndID;          // ending block ID checking
    } PDEV, *PPDEV;


//
// Following are the flags for pPDev->Flags
//

#define PDEVF_CANCEL_JOB            0x80000000
#define PDEVF_IN_BANDHTBLT          0x00000001
#define PDEVF_PP_CENTER             0x00000002
#define PDEVF_HAS_CLIPRECT          0x00000004


#define PLOT_CANCEL_JOB(pPDev)      (pPDev->Flags & PDEVF_CANCEL_JOB)

//
// Following are the flags definitions for the GPC data
//

#define GET_PLOTFLAGS(pPDev)            (DWORD)(pPDev->pPlotGPC->Flags)
#define PF_RASTER(PlotFlags)            (PlotFlags & PLOTF_RASTER)
#define PF_COLOR(PlotFlags)             (PlotFlags & PLOTF_COLOR)
#define PF_BEZIER(PlotFlags)            (PlotFlags & PLOTF_BEZIER)
#define PF_TRANSPARENT(PlotFlags)       (PlotFlags & PLOTF_TRANSPARENT)
#define PF_WINDINGFILL(PlotFlags)       (PlotFlags & PLOTF_WINDINGFILL)
#define PF_ROLLFEED(PlotFlags)          (PlotFlags & PLOTF_ROLLFEED)
#define PF_PAPERTRAY(PlotFlags)         (PlotFlags & PLOTF_PAPERTRAY)
#define PF_BYTEALIGN(PlotFlags)         (PlotFlags & PLOTF_RASTERBYTEALIGN)
#define PF_PUSHPAL(PlotFlags)           (PlotFlags & PLOTF_PUSHPOPPAL)
#define PF_NO_BMP_FONT(PlotFlags)       (PlotFlags & PLOTF_NO_BMP_FONT)
#define PF_RTLMONOENCODE_5(PlotFlags)   (PlotFlags & PLOTF_RTLMONOENCODE_5)
#define PF_RTL_NO_DPI_XY(PlotFlags)     (PlotFlags & PLOTF_RTL_NO_DPI_XY)
#define PF_RTLMONO_NO_CID(PlotFlags)    (PlotFlags & PLOTF_RTLMONO_NO_CID)
#define PF_RTLMONO_FIXPAL(PlotFlags)    (PlotFlags & PLOTF_RTLMONO_FIXPAL)


#define IS_RASTER(pPDev)        (pPDev->pPlotGPC->Flags&PLOTF_RASTER)
#define IS_COLOR(pPDev)         (pPDev->pPlotGPC->Flags&PLOTF_COLOR)
#define IS_BEZIER(pPDev)        (pPDev->pPlotGPC->Flags&PLOTF_BEZIER)
#define IS_TRANSPARENT(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_TRANSPARENT)
#define IS_WINDINGFILL(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_WINDINGFILL)
#define IS_ROLLFEED(pPDev)      (pPDev->pPlotGPC->Flags&PLOTF_ROLLFEED)
#define HAS_PAPERTRAY(pPDev)    (pPDev->pPlotGPC->Flags&PLOTF_PAPERTRAY)
#define NEED_BYTEALIGN(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_RASTERBYTEALIGN)
#define NEED_PUSHPAL(pPDev)     (pPDev->pPlotGPC->Flags&PLOTF_PUSHPOPPAL)
#define NO_BMP_FONT(pPDev)      (pPDev->pPlotGPC->Flags&PLOTF_NO_BMP_FONT)
#define RTLMONOENCODE_5(pPDev)  (pPDev->pPlotGPC->Flags&PLOTF_RTLMONOENCODE_5)
#define RTL_NO_DPI_XY(pPDev)    (pPDev->pPlotGPC->Flags&PLOTF_RTL_NO_DPI_XY)
#define RTLMONO_NO_CID(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_RTLMONO_NO_CID)
#define RTLMONO_FIXPAL(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_RTLMONO_FIXPAL)



#define HTPATSIZE(pPDev)    (((pPDev->pPlotGPC->HTPatternSize>>1)+1)<<1)
#define HTBMPFORMAT(pPDev)  (((PDRVHTINFO)(pPDev->pvDrvHTData))->HTBmpFormat)


#define DB_INV_PATIDX           0xFFFF

//
// This structure defines our realization of a logical brush. Since GDI
// asks us to construct this, GDI keeps giving it back to us
//

typedef struct _DEVBRUSH {
    SURFOBJ     *psoMask;           // the mask for the pattern
    WORD        PatIndex;           // Pattern Index (iHatch HS_xxxx)
    WORD        Uniq;               // Uniq number for DEVBRUSH
    LONG        LineSpacing;        // Brush line spacing
    DWORD       ColorFG;            // foreground color of the brush
    DWORD       ColorBG;            // background color of the brush
    SIZEL       sizlBitmap;         // sizeof the bitmap
    LONG        ScanLineDelta;      // Number of bytes to move per scanline
    WORD        BmpFormat;          // format of the bitmap
    WORD        BmpFlags;           // Flags in surfobj
    LPBYTE      pbgr24;             // 24bpp BGR bitmap for user pattern
    WORD        cxbgr24;            // cx Size of the BGR
    WORD        cybgr24;            // cy Size of the BGR
    BYTE        BmpBits[32];        // pattern bitmap. (min 8x8 of 4bpp)
    } DEVBRUSH, *PDEVBRUSH;


//
// data_structure used in GenPolyGon()
//

typedef struct _POLYGONDATA {
    PPDEV       pPDev;
    SURFOBJ     *pso;               // only required in GenPolygonPath()
    PATHOBJ     *ppo;
    CLIPOBJ     *pco;
    DEVBRUSH    *pBrush;
    PPOINTL     pptlBrushOrg;
    RECTL       *prectl;
    short       iType;              // only required in GenPolygon()
    MIX         mixMode;
    BRUSHOBJ    *pBrushToUse;
    } POLYGONDATA, *PPOLYGONDATA;


//
// Conversion type of things
//

#define DIVROUND(x,y)                   ((y)?(((LONG)(x)+(LONG)((y)>>1))/(LONG)(y)):0)
#define DIVRNDUP(x,y)                   ((y)?(((LONG)(x)+(LONG)((y)-1))/(LONG)(y)):0)
#define __PLOT_DPI                      (LONG)pPDev->pPlotGPC->PlotXDPI
#define _PLOT_DPI                       (LONG)pPlotGPC->PlotXDPI
#define _CURR_DPI                       (LONG)pPDev->lCurResolution

#define LTOFX(x)                        ((x)<<4)

#define DMTOSPL(dm)                     ((LONG)(dm) * 100L)
#define SPLTODM(spl)                    (SHORT)DIVROUND(spl, 100)
#define MMTODM(mm)                      ((LONG)(mm) * 10L)

#define DMTOENGUNITS(pPDev, dm)         DIVROUND((dm)*_CURR_DPI, 254)
#define DMTOPLOTUNITS(pPlotGPC, dm)     DIVROUND((dm)*_PLOT_DPI, 254)

#define MMTOENGUNITS(pPDev, mm)         DMTOENGUNITS(pPDev, MMTODM(mm))
#define MMTOPLOTUNITS(pPlotGPC, mm)     DMTOPLOTUNITS(pPlotGPC, MMTODM(mm))

#define SPLTOENGUNITS(pPDev, spl)       DIVROUND((spl/100)*_CURR_DPI, 254)
#define SPLTOPLOTUNITS(pPlotGPC, spl)   DIVROUND((spl/100)*_PLOT_DPI, 254)

//
// Change to using Raster DPI as user unit
//
// #define ENGTODEV(pPDev, x)              DIVROUND((x)*__PLOT_DPI, _CURR_DPI)
//

#define ENGTODEV(pPDev, x)              (x)
#define FXTODEVL(pPDev, x)              ENGTODEV(pPDev, FXTOLROUND(x))
#define LTODEVL(pPDev, x)               ENGTODEV(pPDev, x)

//
// Minimum type of form supported
//

#define MIN_SPL_FORM_CX             MIN_PLOTGPC_FORM_CX
#define MIN_SPL_FORM_CY             MIN_PLOTGPC_FORM_CY
#define MIN_DM_FORM_CX              SPLTODM(MIN_SPL_FORM_CX)
#define MIN_DM_FORM_CY              SPLTODM(MIN_SPL_FORM_CY)


//
// Finally include this one in order to validate the PDEV
//

#include "pdevinfo.h"


#endif  // _PLOTTER_MAIN_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\polygon.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    polygon.h


Abstract:

    This module contains all #defines for the polygon.c module.


Author:

    18-Nov-1993 Thu 05:21:19 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _PLOTPOLYGON_
#define _PLOTPOLYGON_


//
// Define flags for the DoPolygon and DoFillLogic functions
//
#define FPOLY_WINDING   0x00000001
#define FPOLY_STROKE    0x00000002
#define FPOLY_FILL      0x00000004
#define FPOLY_MASK      (FPOLY_WINDING | FPOLY_STROKE | FPOLY_FILL)


//
// The maximum number of points the HPGL2 language supports for a styled
// line
//
#define MAX_USER_POINTS   20

//
// Allow for extra points needed if we send down to plotter, break for
// starting style state compensation
//
#define MAX_STYLE_ENTRIES 18


BOOL
DoRect(
    PPDEV       pPDev,
    RECTL       *pRectl,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    POINTL      *pptlBrush,
    ROP4        rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    );

BOOL
DoFillByEnumingClipRects(
    PPDEV       pPDev,
    POINTL      *ppointlOffset,
    CLIPOBJ     *pco,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    ROP4        Rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    );

BOOL
PlotCheckForWhiteIfPenPlotter(
    PPDEV       pPDev,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        rop4,
    PULONG      pulFlags
    );

BOOL
DoPolygon(
    PPDEV       pPDev,
    POINTL      *ppointlOffset,
    CLIPOBJ     *pClipObj,
    PATHOBJ     *pPathObj,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    );

VOID
HandleLineAttributes(
    PPDEV       pPDev,
    LINEATTRS   *plineattrs,
    PLONG       pStyleToUse,
    LONG        lExtraStyle
    );

VOID
DoFillLogic(
    PPDEV       pPDev,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        Rop4,
    LINEATTRS   *plineattrs,
    SIZEL       *pszlRect,
    ULONG       ulFlags
    );

VOID
DoSetupOfStrokeAttributes(
    PPDEV       pPDev,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushStroke,
    ROP4        Rop4,
    LINEATTRS   *plineattrs
    );

LONG
DownloadUserDefinedPattern(
    PPDEV       pPDev,
    PDEVBRUSH   pBrush
    );




#endif  _PLOTPOLYGON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\pencolor.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    pencolor.c


Abstract:

    This module contains functions to allow you to get the color of a passed
    brush, as well as select the current color to draw with in the target
    device.

Author:

    15-Jan-1994 Sat 04:49:41 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPenColor

#define DBG_GETCLR          0x00000001
#define DBG_SELECTCOLOR     0x00000002

DEFINE_DBGVAR(0);





LONG
GetColor(
    PPDEV       pPDev,
    BRUSHOBJ    *pbo,
    LPDWORD     pColorFG,
    PDEVBRUSH   *ppDevBrush,
    ROP4        Rop4
    )

/*++

Routine Description:

    Realize the brush color and return the color


Arguments:

    pPDev       - Pointer to our DEV

    pbo         - Engine brush object

    pColorFG    - pointer to the ULONG to received forground color, NULL if
                  not needed

    ppDevBrush  - Pointer to the location to received brush, NULL if not
                  needed

    Rop4        - Rop4 to be used, this function looks at this in order to
                  determine if the brush can be used with the HPGL2 cmds or
                  that the brush will have to be simulated.

Return Value:

    LONG    > 0     The Brush is compatible with device format (Fill command)
            = 0     Failed
            < 0     The brush must send to device via a bitblt

Author:

    13-Jan-1994 Thu 20:18:49 created  

    15-Jan-1994 Sat 06:58:56 updated  
        Change parameters and return value

    16-May-1994 Mon 15:59:45 updated  
        Adding PDEV

Revision History:


--*/

{
    PDEVBRUSH   pDevBrush = NULL;
    LONG        RetVal    = 1;
    DWORD       SolidColor = 0xFFFFFF;
    DWORD       RopBG;
    DWORD       RopFG;


    //
    // Get the ROP for the foureground and background. This information is
    // used to determine if the brush has to be simulated, or can be
    // used with selectable pens in the target device.

    RopBG = ROP4_BG_ROP(Rop4);
    RopFG = ROP4_FG_ROP(Rop4);

    //
    // Get the current color and select the appropriate pen, this should
    // ONLY be a solid color as we don't support stroking with arbitrary
    // brushes.
    //

    if (pbo) {

        //
        // get the brush realization, and select a pen.
        // If the BRUSHOBJ's iSolidColor field is a valid color, then
        // we must do a solid fill with that pen.  Otherwise, we must
        // check the realization of the brush to do a pattern fill.
        //
        // To return a Fillable pattern by DoFill, one of the following conditions
        // must be true and in this sequence
        //
        //  1. SOLID COLOR
        //  2. STANDARD PATTERN
        //  3. Device compatible bitmap
        //

        if ((SolidColor = (DWORD)pbo->iSolidColor) == CLR_INVALID) {

            PLOTDBG(DBG_GETCLR, ("iSolodColor == CLR_INVALID, pBrush=%08lx",
                                                                pbo->pvRbrush));

            //
            // This is a pattern brush, but we will just use its
            // foreground color.
            //

            if ((pDevBrush = (PDEVBRUSH)pbo->pvRbrush) ||
                (pDevBrush = BRUSHOBJ_pvGetRbrush(pbo))) {


                //
                // Grab the foreground color and use it.
                //

                SolidColor = pDevBrush->ColorFG;


                if ((pDevBrush->PatIndex < HS_DDI_MAX) ||
                    (pDevBrush->pbgr24)) {

                    ;

                } else {

                    PLOTDBG(DBG_GETCLR, ("GETColor: NOT DEVICE_PAT"));

                    RetVal = -1;
                }

            } else {

                RetVal = 0;
                PLOTDBG(DBG_GETCLR, ("GetColor(): couldn't realize brush!"));
            }

        } else {

            PLOTDBG(DBG_GETCLR,
                    ("GETColor: is a SOLID COLOR=%08lx", pbo->iSolidColor));
        }

    } else if ((RopFG == 0x00) || (RopBG == 0x00)) {

        if (IS_RASTER(pPDev)) {

            SolidColor = 0x0;

        } else {

            //
            // If we are not a raster device (which supports overprint)
            // match the best non-white pen, in order to fill with.
            //

            SolidColor = (DWORD)BestMatchNonWhitePen(pPDev, 0, 0, 0);

            PLOTDBG(DBG_GETCLR,
                    ("GETColor: pbo=NULL, BLACK Pen Idx=%ld", SolidColor));

        }
    }

    if ((!IS_RASTER(pPDev)) && (SolidColor == 0x00FFFFFF)) {

        SolidColor = WHITE_INDEX;

        PLOTDBG(DBG_GETCLR,
                ("GETColor: Pen plotter using WHITE COLOR Idx=%ld", SolidColor));
    }

    if (pColorFG) {

        *pColorFG = SolidColor;
    }

    if (ppDevBrush) {

        *ppDevBrush = pDevBrush;
    }

    return(RetVal);
}





VOID
SelectColor(
    PPDEV       pPDev,
    DWORD       Color,
    INTDECIW    PenWidth
    )

/*++

Routine Description:

    This function is responsible for handling the mechanism of supporting RGB
    colors on plotters that support this. This is done by using a preset pallete
    position that the engine does not know about, and constantly update it with
    the correct color.

Arguments:

    pPDev       - Pointer to the PDEV data structure

    Color       - Color to be selected

    PenWidth    - INTDECIW data structrue to specified the pen width

Return Value:

    VOID


Author:

    30-Nov-1993 Tue 22:15:12 created  

    12-Apr-1994 Tue 14:35:44 updated  
        Update to take pen plotter into account and take care the error cases

Revision History:


--*/

{

    PLOTASSERT(1, "SelectColor: Invalid RGB Color [%08lx] for Raster DEVICE",
                Color != CLR_INVALID, Color);

    if (Color == CLR_INVALID) {

        //
        // Make it white
        //

        Color = (DWORD)(IS_RASTER(pPDev) ? 0x00FFFFFF : WHITE_INDEX);
    }

    if (IS_RASTER(pPDev)) {

        Color = (DWORD)FindCachedPen(pPDev, (PPALENTRY)&Color);

    } else {

        if (Color > (DWORD)pPDev->pPlotGPC->Pens.Count) {

            Color = (DWORD)pPDev->BrightestPen;

            PLOTDBG(DBG_SELECTCOLOR,
                    ("SelectColor: !!! Match to Closest WHITE PEN=%ld", Color));

            PLOTASSERT(1, "SelectColor: Invalid Pen Index [%08ld] for PEN DEVICE",
                        (Color <= (DWORD)pPDev->pPlotGPC->Pens.Count), Color);

            if (Color > (DWORD)pPDev->pPlotGPC->Pens.Count) {

                Color = WHITE_INDEX;
            }
        }
    }

    //
    // Verify were not selecting the current pen
    //

    if (Color != (DWORD)pPDev->CurPenSelected) {

        PLOTDBG(DBG_SELECTCOLOR,
                ("SelectColor: Current Pen [%ld] != new PEN [%ld]",
                                            pPDev->CurPenSelected, Color));

        OutputFormatStr(pPDev,"SP#d", (LONG)Color);
        pPDev->CurPenSelected = (LONG)Color;

    } else {

        PLOTDBG(DBG_SELECTCOLOR,
                ("SelectColor: Current Pen == new PEN [%ld]", Color));
    }

    //
    // Set the correct pen width in the target device. This will change
    // the pen width for all pens.
    //

    if ((PenWidth.Integer != pPDev->PenWidth.Integer) ||
        (PenWidth.Decimal != pPDev->PenWidth.Decimal)) {

        //
        // Now send the optimal pen width number command to the target device.
        //

        OutputString(pPDev, "PW");

        if ((PenWidth.Integer) || (PenWidth.Decimal == 0)) {

            //
            // This will make the following cases
            //
            // 1. 0.0 ---> 0
            // 2. 3.2 ---> 3
            // 3. 3.0 ---> 3

            OutputFormatStr(pPDev, "#d", PenWidth.Integer);
        }

        if (PenWidth.Decimal) {

            //
            // Do all DECI part as .xx
            //

            OutputFormatStr(pPDev, ".#d", PenWidth.Decimal);
        }

        PLOTDBG(DBG_SELECTCOLOR,
                ("SelectColor: PEN WIDTH Change from %ld.%ldmm to %ld.%ldmm",
                (DWORD)pPDev->PenWidth.Integer, (DWORD)pPDev->PenWidth.Decimal,
                (DWORD)PenWidth.Integer, (DWORD)PenWidth.Decimal));

        //
        // Update the pen width cache
        //

        pPDev->PenWidth = PenWidth;


    } else {

        PLOTDBG(DBG_SELECTCOLOR, ("SelectColor: PEN WIDTH is SAME = %ld.%ld",
                                        PenWidth.Integer, PenWidth.Decimal));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\precomp.h ===
#include <stddef.h>
#include <stdlib.h>
#include <windows.h>
#include <winddi.h>

#define _WINDEFP_NO_PDEVBRUSH
#include <winspool.h>
#include <plotgpc.h>
#include <plotdm.h>
#include <plotters.h>
#include <plotlib.h>
#include <string.h>
#include <strsafe.h>

#include "enable.h"
#include "bitblt.h"
#include "pencolor.h"
#include "polygon.h"
#include "ropblt.h"
#include "output.h"
#include "htblt.h"
#include "plotform.h"
#include "escape.h"
#include "compress.h"
#include "htbmp1.h"
#include "htbmp4.h"
#include "transpos.h"
#include "brush.h"
#include "path.h"
#include "textout.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\polygon.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    polygon.c


Abstract:

    This module contains path forming code utilized by the rest of the
    driver. Path primitive functions (such as DrvStrokePath, DrvTextOut)
    use this code to generate and fill and stroke paths.
    Since this code is aware of all the combinations of complex paths and
    complex clipping regions and how to deal with them.


Development History:

    15:30 on Wed 09 Mar 1993   
        Created it

    15-Nov-1993 Mon 19:42:05 updated  
        clean up / fixed / add debugging information

    27-Jan-1994 Thu 23:40:57 updated  
        Add user defined pattern caching

    16-Mar-1994 Wed 11:21:02 updated 
        Add SetBrushOrigin() so we can align brush origins for filling
        correctly


Environment:

    GDI Device Driver - Plotter.




--*/

#include "precomp.h"
#pragma hdrstop

//
// General debug flags for module, see dbgread.txt for overview.
//

#define DBG_PLOTFILENAME    DbgPolygon

#define DBG_GENPOLYGON      0x00000001
#define DBG_GENPOLYPATH     0x00000002
#define DBG_BEZIER          0x00000004
#define DBG_DORECT          0x00000008
#define DBG_FILL_CLIP       0x00000010
#define DBG_CHECK_FOR_WHITE 0x00000020
#define DBG_USERPAT         0x00000040
#define DBG_FILL_LOGIC      0x00000080
#define DBG_HANDLELINEATTR  0x00000100

DEFINE_DBGVAR(0);

//
// Derive new rect by offsetting the source rect
//

#define POLY_GEN_RECTFIX(dest, src, offset) { dest.x = src->x + offset.x;   \
                                              dest.y = src->y + offset.y; }

//
// Build table with HPGL2 commands for cursor movement, and path construction.
//

static BYTE __ER[]    = { 'E', 'R'      };
static BYTE __RR[]    = { 'R', 'R'      };
static BYTE __EP[]    = { 'E', 'P'      };
static BYTE __FP[]    = { 'F', 'P'      };
static BYTE __PM0[]   = { 'P', 'M', '0' };
static BYTE __PM1[]   = { 'P', 'M', '1' };
static BYTE __PM2[]   = { 'P', 'M', '2' };
static BYTE __TR0[]   = { 'T', 'R', '0' };
static BYTE __TR1[]   = { 'T', 'R', '1' };
static BYTE __SEMI[]  = { ';'           };
static BYTE __1SEMI[] = { '1', ';'      };
static BYTE __BR[]    = { 'B', 'R'      };
static BYTE __BZ[]    = { 'B', 'Z'      };
static BYTE __PE[]    = { 'P', 'E'      };
static BYTE __PD[]    = { 'P', 'D'      };
static BYTE __COMMA[] = { ','           };


//
// Make MACROS for sending out command streams to device
//

#define SEND_ER(pPDev)      OutputBytes(pPDev, __ER    , sizeof(__ER   ) );
#define SEND_RR(pPDev)      OutputBytes(pPDev, __RR    , sizeof(__RR   ) );
#define SEND_EP(pPDev)      OutputBytes(pPDev, __EP    , sizeof(__EP   ) );
#define SEND_FP(pPDev)      OutputBytes(pPDev, __FP    , sizeof(__FP   ) );
#define SEND_PM0(pPDev)     OutputBytes(pPDev, __PM0   , sizeof(__PM0  ) );
#define SEND_PM1(pPDev)     OutputBytes(pPDev, __PM1   , sizeof(__PM1  ) );
#define SEND_PM2(pPDev)     OutputBytes(pPDev, __PM2   , sizeof(__PM2  ) );
#define SEND_TR0(pPDev)     OutputBytes(pPDev, __TR0   , sizeof(__TR0  ) );
#define SEND_TR1(pPDev)     OutputBytes(pPDev, __TR1   , sizeof(__TR1  ) );
#define SEND_SEMI(pPDev)    OutputBytes(pPDev, __SEMI  , sizeof(__SEMI ) );
#define SEND_1SEMI(pPDev)   OutputBytes(pPDev, __1SEMI , sizeof(__1SEMI) );
#define SEND_BR(pPDev)      OutputBytes(pPDev, __BR    , sizeof(__BR   ) );
#define SEND_BZ(pPDev)      OutputBytes(pPDev, __BZ    , sizeof(__BZ   ) );
#define SEND_PE(pPDev)      OutputBytes(pPDev, __PE    , sizeof(__PE   ) );
#define SEND_PD(pPDev)      OutputBytes(pPDev, __PD    , sizeof(__PD   ) );
#define SEND_COMMA(pPDev)   OutputBytes(pPDev, __COMMA , sizeof(__COMMA) );


#define TERM_PE_MODE(pPDev, Mode)                                           \
{                                                                           \
    if (Mode == 'PE') {                                                     \
                                                                            \
        SEND_SEMI(pPDev);                                                   \
        Mode = 0;                                                           \
    }                                                                       \
}

#define SWITCH_TO_PE(pPDev, Mode, PenIsDown)                                \
{                                                                           \
    if (Mode != 'PE') {                                                     \
                                                                            \
        SEND_PE(pPDev);                                                     \
        Mode      = 'PE';                                                   \
        PenIsDown = TRUE;                                                   \
    }                                                                       \
}


#define SWITCH_TO_BR(pPDev, Mode, PenIsDown)                                \
{                                                                           \
    TERM_PE_MODE(pPDev, Mode)                                               \
                                                                            \
    if (Mode != 'BR') {                                                     \
                                                                            \
        if (!PenIsDown) {                                                   \
                                                                            \
            SEND_PD(pPDev);                                                 \
            PenIsDown = TRUE;                                               \
        }                                                                   \
                                                                            \
        SEND_BR(pPDev);                                                     \
        Mode = 'BR';                                                        \
                                                                            \
    } else {                                                                \
                                                                            \
        SEND_COMMA(pPDev);                                                  \
    }                                                                       \
}


#define PLOT_IS_WHITE(pdev, ulCol)  (ulCol == WHITE_INDEX)
#define TOGGLE_DASH(x)              ((x) ? FALSE : TRUE)

#define ROP4_USE_DEST(Rop4)         ((Rop4 & 0x5555) != ((Rop4 & 0xAAAA) >> 1))
#define SET_PP_WITH_ROP4(pPDev, Rop4)                                       \
    SetPixelPlacement(pPDev, (ROP4_USE_DEST(Rop4)) ? SPP_MODE_EDGE :        \
                                                     SPP_MODE_CENTER)



VOID
SetBrushOrigin(
    PPDEV   pPDev,
    PPOINTL pptlBrushOrg
    )

/*++

Routine Description:

    This function sets the brush origin onto the device for the next brush
    fill. Brush origins are used in order for paths being filled to line up
    correctly. In this way, if many different paths are filled, the patterns
    will line up based on the pattern being repeated starting at the correct
    origin.


Arguments:

    pPDev           - Pointer to our PDEV

    pptlBrushOrg    - Pointer to the brush origin to be set


Return Value:

    VOID



Developmet History:
	16-Mar-1994 Wed 10:56:46 created 


--*/

{
    POINTL  ptlAC;


    if (pptlBrushOrg) {

        ptlAC = *pptlBrushOrg;

    } else {

        ptlAC.x =
        ptlAC.y = 0;
    }


    //
    // Check to see if the origin is different, and if it is output the
    // new origin to the device.
    //

    if ((ptlAC.x != pPDev->ptlAnchorCorner.x) ||
        (ptlAC.y != pPDev->ptlAnchorCorner.y)) {

        OutputString(pPDev, "AC");

        if ((ptlAC.x) || (ptlAC.y)) {

            OutputLONGParams(pPDev, (PLONG)&ptlAC, 2, 'd');
        }

        //
        // Save the current setting
        //

        pPDev->ptlAnchorCorner = ptlAC;
    }
}




BOOL
DoRect(
    PPDEV       pPDev,
    RECTL       *pRectl,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    POINTL      *pptlBrush,
    ROP4        rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    )

/*++

Routine Description:

    This function will draw and optionally fill a rectangle. It uses seperate
    BRUSHOBJ's for the outline and interior of the rectangle. Since the stroke
    operation may include data for a styled line (dashes etc.) the LINEATTRS
    structure is included as well.

Arguments:

    pPDev           - Pointer to our PDEV

    pRectl          - rectangle area to fill

    pBrushFill      - Brush used to fill the rectangle

    pBrushStroke    - Brush used to stroke the rectangle

    pptlBrush       - brush origin

    rop4            - rop to be used

    plineattrs      - Pointer to the line attributes for a styled line

    ulFlags         - FPOLY_xxxx flags


Return Value:

    TRUE if sucessful and false if not


Development History:

    15-Feb-1994 Tue 11:59:52 updated 
        We will do RR or RA now

    24-Mar-1994 Thu 19:37:05 updated  
        Do local MovePen and make sure we at least output ONE RASTER PEL


--*/

{
    POINTL      ptlPlot;
    SIZEL       szlRect;


    if (PLOT_CANCEL_JOB(pPDev)) {

        return(FALSE);
    }

    //
    // Check to see if we can short cut some of our work if its a pen plotter
    //

    if (PlotCheckForWhiteIfPenPlotter(pPDev,
                                      pBrushFill,
                                      pBrushStroke,
                                      rop4,
                                      &ulFlags))  {
        return(TRUE);
    }

    PLOTDBG(DBG_DORECT,
            ("DoRect: Passed In RECTL=(%ld, %ld)-(%ld, %ld)=%ld x %ld",
                pRectl->left,   pRectl->top,
                pRectl->right,  pRectl->bottom,
                pRectl->right -  pRectl->left,
                pRectl->bottom -  pRectl->top));

    ptlPlot.x  = LTODEVL(pPDev, pRectl->left);
    ptlPlot.y  = LTODEVL(pPDev, pRectl->top);
    szlRect.cx = LTODEVL(pPDev, pRectl->right)  - ptlPlot.x;
    szlRect.cy = LTODEVL(pPDev, pRectl->bottom) - ptlPlot.y;


    //
    // No need to fill an empty rectangle.
    //

    if ((szlRect.cx) && (szlRect.cy)) {

        SET_PP_WITH_ROP4(pPDev, rop4);

        //
        // If the rectangle is not of sufficient size to actually cause any
        // bits to appear on the target device, we grow the rectangle
        // to the correct amount. This is done because the target device
        // may after converting to physical units, decide there is no work to
        // do. In this case nothing would show up on the page at all. So we
        // opt to have at least a one pixel object show up.
        //

        if (szlRect.cx < (LONG)pPDev->MinLToDevL) {

            PLOTWARN(("DoRect: cxRect=%ld < MIN=%ld, Make it as MIN",
                            szlRect.cx, (LONG)pPDev->MinLToDevL));

            szlRect.cx = (LONG)pPDev->MinLToDevL;
        }

        if (szlRect.cy < (LONG)pPDev->MinLToDevL) {

            PLOTWARN(("DoRect: cyRect=%ld < MIN=%ld, Make it as MIN",
                            szlRect.cy, (LONG)pPDev->MinLToDevL));

            szlRect.cy = (LONG)pPDev->MinLToDevL;
        }

        //
        // Do the MOVE PEN.
        //

        OutputFormatStr(pPDev, "PE<=#D#D;", ptlPlot.x, ptlPlot.y);

        PLOTDBG(DBG_DORECT,
                ("DoRect: PLOTUNIT=%ld, MovePen=(%ld, %ld), RR=%ld x %ld",
                pPDev->pPlotGPC->PlotXDPI,
                ptlPlot.x, ptlPlot.y, szlRect.cx, szlRect.cy));

        //
        // Since all the parameters are set up correctly, call the core routine
        // for filling a rectangle.
        //

        DoFillLogic(pPDev,
                    pptlBrush,
                    pBrushFill,
                    pBrushStroke,
                    rop4,
                    plineattrs,
                    &szlRect,
                    ulFlags);

    } else {

        PLOTDBG(DBG_DORECT, ("DoRect: Pass a NULL Rectl, Do NOTHING"));
    }

    return(!PLOT_CANCEL_JOB(pPDev));
}



BOOL
DoFillByEnumingClipRects(
    PPDEV       pPDev,
    POINTL      *ppointlOffset,
    CLIPOBJ     *pco,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    ROP4        Rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    )

/*++

Routine Description:

    This function, fills a CLIPOBJ by enurating the CLIPOBJ as seperate
    rectangles and filling each of them in turn. This is typically done when
    the CLIPOBJ is comprised of so many path objects, that the path cannot
    be described in HPGL2 (overfilling the path buffer in the target device).


Arguments:

    pPDev           - Pointer to our PDEV

    ppointlOffset   - Extra offset to the output polygon

    pClipObj        - clip object

    pPointlBrushOrg - brush origin for the fill brush.

    pBrushFill      - Brush used to fill the rectangle

    Rop4            - rop to be used

    plineattrs      - Pointer to the line attributes for a styled line

    ulFlags         - FPOLY_xxxx flags


Return Value:

    BOOL    TRUE  - Function succeded
            FALSE - Function failed.

Development History:

    28-Nov-1993 created  

    18-Dec-1993 Sat 10:35:24 updated  
        use PRECTL rather RECTL *, and use INT rater than int, removed compiler
        warning which has unreferenced local variable

    16-Feb-1994 Wed 16:12:53 updated  
        Re-structure and make it Polyline encoded

    09-Apr-1994 Sat 16:38:16 updated  
        Fixed the ptlCur++ twice typo which make us Do the RECT crazy.




--*/
{
    PRECTL      prclCur;
    POINTFIX    ptsFix[4];
    HTENUMRCL   EnumRects;
    POINTL      ptlCur;
    DWORD       MaxRects;
    DWORD       cRects;
    BOOL        bMore;
    BOOL        NeedSendPM0;



    PLOTDBG(DBG_FILL_CLIP,
            ("DoFillByEnumingRects: Maximum polygon points = %d",
                        pPDev->pPlotGPC->MaxPolygonPts));

    PLOTASSERT(1, "DoFillByEnumingRects: Minimum must be 5 points [%ld]",
                pPDev->pPlotGPC->MaxPolygonPts >= 5,
                pPDev->pPlotGPC->MaxPolygonPts);

    //
    // In this mode we will enter polygon mode and try to batch based on the
    // number of points the device can handle in its polygon buffer.
    //

    bMore       = FALSE;
    EnumRects.c = 1;

    if ((!pco) || (pco->iDComplexity == DC_TRIVIAL)) {

        PLOTASSERT(1, "DoFillByEnumingClipRects: Invalid pco TRIVIAL passed (%08lx)",
                    (pco) && (pco->iDComplexity != DC_TRIVIAL), pco);

        return(FALSE);

    } else if (pco->iDComplexity == DC_RECT) {

        //
        // The visible area is one rectangle intersect with the destinaiton
        //

        PLOTDBG(DBG_FILL_CLIP, ("DoFillByEnumingClipRects: pco=DC_RECT"));

        EnumRects.rcl[0] = pco->rclBounds;

    } else {

        //
        // We have complex clipping region to be computed, call engine to start
        // enumerate the rectangles and set More = TRUE so we can get the first
        // batch of rectangles.
        //

        PLOTDBG(DBG_FILL_CLIP, ("DoFillByEnumingClipRects: pco=DC_COMPLEX, EnumRects now"));

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        bMore = TRUE;
    }


    //
    // Calculate how many rects we can do at a time, based on how large of
    // a polygon buffer the target device can hold. Make sure that value
    // is at least 1.
    //

    if (!(MaxRects = (DWORD)pPDev->pPlotGPC->MaxPolygonPts / 7)) {

        MaxRects = 1;
    }

    cRects      = MaxRects;
    NeedSendPM0 = TRUE;

    do {


        //
        // If the job was cancelled, break out now. This is typically done
        // anytime the code enters some looping that may take a while.
        //

        if (PLOT_CANCEL_JOB(pPDev)) {

            return(FALSE);
        }

        //
        // If More is true then we need to get next batch of rectangles
        //

        if (bMore == TRUE) {

            bMore = CLIPOBJ_bEnum(pco, sizeof(EnumRects), (ULONG *)&EnumRects);

            if (bMore == DDI_ERROR || !EnumRects.c) {

                PLOTWARN(("DoFillByEnumingClipRects: MORE CLIPOBJ_bEnum BUT Count=0"));
            }
        }


        PLOTDBG( DBG_FILL_CLIP,
                ("DoFillByEnumingClipRects: Doing batch of %ld clip rects",
                EnumRects.c));


        //
        // prclCur will point to the first enumerated rectangle
        //

        prclCur = (PRECTL)&EnumRects.rcl[0];

        while (bMore != DDI_ERROR && EnumRects.c--) {

            ptsFix[3].x = LTOFX(prclCur->left);
            ptsFix[3].y = LTOFX(prclCur->top);

            MovePen(pPDev, &ptsFix[3], &ptlCur);

            if (NeedSendPM0) {

                SEND_PM0(pPDev);

                NeedSendPM0 = FALSE;
            }

            ptsFix[0].x = LTOFX(prclCur->right);
            ptsFix[0].y = ptsFix[3].y;

            ptsFix[1].x = ptsFix[0].x;
            ptsFix[1].y = LTOFX(prclCur->bottom);;

            ptsFix[2].x = ptsFix[3].x;
            ptsFix[2].y = ptsFix[1].y;

            SEND_PE(pPDev);

            OutputXYParams(pPDev,
                           (PPOINTL)ptsFix,
                           (PPOINTL)NULL,
                           (PPOINTL)&ptlCur,
                           (UINT)4,
                           (UINT)1,
                           'F');


            PLOTDBG(DBG_FILL_CLIP,
               ("DoFillByEnumingRects: Rect = (%ld, %ld) - (%ld, %ld)",
                 FXTOL(ptsFix[3].x), FXTOL( ptsFix[3].y),
                 FXTOL(ptsFix[1].x), FXTOL( ptsFix[1].y) ));

#if DBG
            if ((FXTODEVL(pPdev, ptsFix[1].x - ptsFix[3].x) >= (1016 * 34)) ||
                (FXTODEVL(pPdev, ptsFix[1].y - ptsFix[3].y) >= (1016 * 34)))  {

                PLOTWARN(("DoFillByEnumingClipRect: *** BIG RECT (%ld x %ld) *****",
                            FXTODEVL( pPDev, ptsFix[1].x - ptsFix[3].x),
                            FXTODEVL( pPDev, ptsFix[1].y - ptsFix[3].y)));
            }
#endif

            SEND_SEMI(pPDev);
            SEND_PM1(pPDev);
            SEND_SEMI(pPDev);

            //
            // 5 points per RECT polygon, so if we hit the limit then batch
            // it out first. we also calling the DoFillLogic when we are at
            // the very last enumeration of clipping rectangle.
            //

            --cRects;
            ++prclCur;

            if ((!cRects)     ||
                ((!EnumRects.c) && (!bMore))) {

                PLOTDBG(DBG_FILL_CLIP,
                        ("DoFillByEnumingRects: Hit MaxPolyPts limit"));

                //
                // We have hit the limit so close the polygon and do the fill
                // logic then continue till were done
                //

                SEND_PM2(pPDev);
                SETLINETYPESOLID(pPDev);

                DoFillLogic(pPDev,
                            pPointlBrushOrg,
                            pBrushFill,
                            NULL,
                            Rop4,
                            plineattrs,
                            NULL,
                            ulFlags);

                //
                // Reset the count of points generated thus far, and set the
                // flag to init polygon mode
                //

                cRects      = MaxRects;
                NeedSendPM0 = TRUE;
            }
        }

    } while (bMore);

    if (cRects != MaxRects) {

        PLOTWARN(("DoFillByEnumingRects: Why are we here?? Send Last Batch of =%ld",
                    MaxRects - cRects));

        SEND_PM2(pPDev);
        SETLINETYPESOLID(pPDev);

        DoFillLogic(pPDev,
                    pPointlBrushOrg,
                    pBrushFill,
                    NULL,
                    Rop4,
                    plineattrs,
                    NULL,
                    ulFlags);
    }

    return(!PLOT_CANCEL_JOB(pPDev));
}




BOOL
PlotCheckForWhiteIfPenPlotter(
    PPDEV       pPDev,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        rop4,
    PULONG      pulFlags
    )

/*++

Routine Description:

    This function checks to see if we can safely ignore a drawing command
    if it will cause only white to get rendered. Although this is legal on
    a raster device (white fill over some other previously rendered object),
    it doesn't make sense on a pen plotter.

Arguments:

    pPDev           - Pointer to our PDEV

    pBrushFill      - Brush used to fill the rectangle

    pBrushStroke    - Brush used to stroke the rectangle

    rop4            - rop to be used

    pulFlags        - FPOLY_xxxx flags, may be reset.


Return Value:

    BOOL    TRUE  - Bypass future operations
            FALSE - Operation needs to be completed

Developmet History:

    28-Nov-1993 created  

    15-Jan-1994 Sat 04:57:55 updated  
        Change GetColor() and make it tab 5




--*/
{

    ULONG   StrokeColor;
    ULONG   FillColor;


    //
    // Initially we do a quick check if were a PEN plotter to get rid of
    // either filling or stroking white. If we are a raster device, we
    // support filling white, so we cannot ignore the call.
    //

    if (!IS_RASTER(pPDev)) {

        //
        // Check to see if filling is enabled and if it is undo the fill flag
        // if the fill color is white.
        //

        if (*pulFlags & FPOLY_FILL ) {

            //
            // Get the fill color so we can look at it and decide if its a NOOP
            // on pen plotters. If it is, undo the FILL flag.
            //

            GetColor(pPDev, pBrushFill, &FillColor, NULL, rop4);

            if (PLOT_IS_WHITE( pPDev, FillColor)) {

                *pulFlags &= ~FPOLY_FILL;
            }
        }


        if (*pulFlags & FPOLY_STROKE) {

            //
            // Get the Stroke color so we can look at it and decide it its a
            // NOOP on pen plotters. If it is, undo the STROKE flag.
            //

            GetColor(pPDev, pBrushStroke, &StrokeColor, NULL, rop4);

            if (PLOT_IS_WHITE(pPDev, StrokeColor)) {

               *pulFlags &= ~FPOLY_STROKE;
            }
        }

        if (!(*pulFlags & (FPOLY_STROKE | FPOLY_FILL))) {

            //
            // Nothing left to do so simply return success
            //

            PLOTDBG(DBG_CHECK_FOR_WHITE,
                     ("PlotCheckForWhiteIfPen: ALL WHITE detected"));
            return(TRUE);
        }

        PLOTDBG(DBG_CHECK_FOR_WHITE,
                 ("PlotCheckForWhiteIfPen: Painting required!"));
    }

    return(FALSE);
}



BOOL
DoPolygon(
    PPDEV       pPDev,
    POINTL      *ppointlOffset,
    CLIPOBJ     *pClipObj,
    PATHOBJ     *pPathObj,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    )

/*++

Routine Description:

    This function is the core path handling function for the entire driver.
    The passed PATHOBJ and CLIPOBJ are looked at, and various logic is
    enabled to determine the correct sequence of events to get the target
    path filled. Since HPGL2 cannot handle complex clipping, this function
    must deal with the issue of having both a COMPLEX CLIPOBJ, and a
    COMPLEX PATHOBJ. When this function decides the work it needs to do
    is too complex, it fails this call, the NT graphics engine in turn will
    break down the work, most likely calling DrvPaint multiple times in
    order to get the object drawn.

Arguments:

    pPDev           - Pointer to our PDEV

    ppointlOffset   - Extra offset to the output polygon

    pClipObj        - clip object

    pPathObj        - The path object to be used

    pPointlBrushOrg - brush origin in the brush to be fill or stroke

    pBrushFill      - brush object to be used in the FILL

    pBrushStroke    - brush object to be used in the STROKE

    rop4            - Rop4 used in the fill

    plineattrs      - LINEATTRS for style lines stroke

    ulFlags         - polygon flags for stroke or fill


Return Value:

    BOOL    TRUE  - Function succeded
            FALSE - Function failed

Development History:

    28-Nov-1993 created  

    28-Jan-1994 Fri 00:58:25 updated  
        Style, commented, re-structure the loop and reduce code size.

    04-Aug-1994 Thu 20:00:23 updated 
        bug# 22348 which actually is a raster plotter firmware bug





--*/
{
    PRECTL      prclClip = NULL;
    POINTFIX    *pptfx;
    POINTFIX    ptOffsetFix;
    POINTFIX    ptStart;
    POINTL      ptlCur;
    PATHDATA    pd;
    DWORD       cptfx;
    DWORD       cptExtra;
    UINT        cCurPosSkips;
    WORD        PolyMode;
    BOOL        bPathCameFromClip = FALSE;
    BOOL        bStrokeOnTheFly    = FALSE;
    BOOL        bFirstSubPath;
    BOOL        bMore;
    BOOL        bRet;
    BOOL        PenIsDown;
    BYTE        NumType;


    //
    // Check to see if we can short cut some of our work if its a pen plotter
    //

    if (PlotCheckForWhiteIfPenPlotter(pPDev,
                                      pBrushFill,
                                      pBrushStroke,
                                      rop4,
                                      &ulFlags))  {
        return(TRUE);
    }

    //
    // There are a few different scenarios to deal with here when the
    // item in question is too complex and we need to fail. They are
    // catagorized as follows
    //
    //    1) The fill mode is unsupported, in which case we fail the call
    //       and it should come back in in a simpler format (DrvPaint)
    //
    //    2) We have a CLIPOBJ thats more complicated than a RECT and, a
    //       PATHOBJ, if we only have a clipobj we can enum it as a path
    //

    if ((ulFlags & FPOLY_WINDING) &&
        (!IS_WINDINGFILL(pPDev))) {

       //
       // The plotter cannot support WINDING Mode fills, all we can do
       // is fail the call and have it come back in a mode we can support
       //

       PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: Can't do WINDING, return(FALSE)"));

       return(FALSE);
    }

    if (pClipObj != NULL) {

       //
       // We have a clipobj so decide what to do
       //

       if (pClipObj->iDComplexity == DC_COMPLEX) {

            //
            // Since the clipobj is complex we have two choices, either there is
            // no PATHOBJ, in which case we will enum the clipobj as a path, or
            // if there is a pathobj we must fail the call. HPGL2 doesn't
            // support COMPLEX clipping objects.
            //

            if (pPathObj != NULL) {

                //
                // We have a complex clip and a path? we cannot handle this so
                // fail the call, the NT graphics engine will simplify the
                // object by calling into other primitives (like DrvPaint).
                //

                PLOTDBG(DBG_GENPOLYGON,
                        ("DoPolygon: pco=COMPLEX, pPath != NULL, can handle, FALSE"));

                return(FALSE);
            }

            //
            // We have come this far, so we must have a CLIPOBJ that is complex
            // and we will go ahead and enum it as a path.
            //

            if ((pPathObj = CLIPOBJ_ppoGetPath(pClipObj)) == NULL) {

                PLOTERR(("Engine path from clipobj returns NULL"));
                return(FALSE);
            }


            //
            // Record the fact that the PATHOBJ is really coming froma CLIPOBJ
            //

            bPathCameFromClip = TRUE;

       } else if (pClipObj->iDComplexity == DC_RECT) {

            //
            // We have a RECT CLIPOBJ, if we have no PATHOBJ we simply fill
            // the clipping rectangle. If we do have a PATHOBJ we need to set
            // the HPGL2 clip window before enumerating and filling the PATHOBJ.
            //

            if (pPathObj != NULL) {

                //
                // Some plotters have a firmware bug with clipping windows
                // when using styled lines that keep the styled lines from
                // being rendered, even though they fit inside the CLIPOBJ.
                //
                // We get around this limitation by failing this call. This in
                // turn will cause DoStrokePathByEnumingClipLines() to be used
                // instead.
                //

                if ((IS_RASTER(pPDev))                  &&
                    (ulFlags & FPOLY_STROKE)            &&
                    (plineattrs)                        &&
                    ((plineattrs->fl & LA_ALTERNATE)    ||
                     ((plineattrs->cstyle) &&
                      (plineattrs->pstyle)))) {

                    PLOTWARN(("DoPolygon: RASTER/Stroke/DC_RECT/PathObj/StyleLine: (Firmware BUG) FAILED and using EnumClipLine()"));

                    return(FALSE);
                }

                prclClip = &pClipObj->rclBounds;

            } else {

                //
                // Simply call the fill rect code and return, no more work
                // to do in this function.
                //

                return(DoRect(pPDev,
                              &pClipObj->rclBounds,
                              pBrushFill,
                              pBrushStroke,
                              pPointlBrushOrg,
                              rop4,
                              plineattrs,
                              ulFlags));

            }

        } else {

            //
            // CLIPOBJ is trivial so we simply ignore it and fill using the
            // passed PATHOBJ.
            //

            NULL;
        }

    } else {

        //
        // No CLIPOBJ so use the PATHOBJ passed in.
        //

        NULL;
    }

    //
    // Setup the offset coordinate data, in case were coming from
    // DrvTextOut. In this case there is an offset passed in that
    // must be applied to each point. This is used when the glyphs we
    // are painting, are actually interpreted as paths. In this case,
    // the paths are fixed based on the origin of the glyph. We must
    // add the current X/Y position in order to render the glyph in the
    // correct place on the page.
    //

    if (ppointlOffset) {

        ptOffsetFix.x = LTOFX(ppointlOffset->x);
        ptOffsetFix.y = LTOFX(ppointlOffset->y);

    } else {

        ptOffsetFix.x =
        ptOffsetFix.y = 0;
    }

    //
    // First we need to verify that we dont have more points than will fit
    // in our polygon buffer for this device. If this is the case we have two
    // choices. If the path did not come from a clip obj we fail this call,
    // if it did we handle this based on enuming the clipobj as rects and
    // filling. If we were also asked to stroke the PATHOBJ, we need to
    // enumerate the path yet another time.
    //

    cptfx = 0;
    cptExtra = 1;

    PATHOBJ_vEnumStart(pPathObj);

    do {

        bRet = PATHOBJ_bEnum(pPathObj, &pd);

        cptfx += pd.count;

        if ( pd.flags & PD_ENDSUBPATH ) {

            //
            // Count both the ENDSUBPATH and the PM1 as taking space...
            //

            cptExtra++;

            if (!(pd.flags & PD_CLOSEFIGURE)) {

                //
                // Since we were not asked to close the figure, we will generate
                // a move back to our starting point with the pen up, in order
                // eliminate problems with HPGL/2 closing the polygon for
                // us when we send the PM2

                cptExtra++;
            }
        }

    } while ((bRet) && (!PLOT_CANCEL_JOB(pPDev)));


    PLOTDBG(DBG_GENPOLYGON,
                ("DoPolygon: Total points = %d, Extra %d",
                cptfx, cptExtra ));

    //
    // We will only do this if we have any points to do, first set bRet to
    // true in case we were not asked to do anything.
    //

    bRet = TRUE;

    if (cptfx) {

        SET_PP_WITH_ROP4(pPDev, rop4);

        //
        // Now add in the extra points that account for the PM0 and PM1
        // since we have some REAL points in the path.
        //

        cptfx += cptExtra;


        if (cptfx > pPDev->pPlotGPC->MaxPolygonPts) {

            PLOTWARN(("DoPolygon: Too many polygon points = %ld > PCD=%ld",
                            cptfx, pPDev->pPlotGPC->MaxPolygonPts));

            if (bPathCameFromClip) {

                PLOTWARN(("DoPolygon: Using DoFillByEnumingClipRects()"));

                //
                // The path the engine created for us to enum must be freed.
                //

                EngDeletePath(pPathObj);

                //
                // Since the path is to complex to fill with native  HPLG2
                // path code, we must do it the slower way.
                //

                return(DoFillByEnumingClipRects(pPDev,
                                                ppointlOffset,
                                                pClipObj,
                                                pPointlBrushOrg,
                                                pBrushFill,
                                                rop4,
                                                plineattrs,
                                                ulFlags));

            } else {

                //
                // If were dealing with a REAL PATHOBJ and there are too many
                // points in the polygon, and were being asked to FILL, all
                // we can do is fail the call and have the NT graphics engine
                // simplify the object.
                //

                if (ulFlags & FPOLY_FILL) {

                    PLOTERR(("DoPolygon: Too many POINTS, return FALSE"));
                    return(FALSE);

                } else if (ulFlags & FPOLY_STROKE) {

                    //
                    // Since were stroking we can go ahead and do it on the
                    // fly. Rather than building up a POLYGON object in the
                    // target device and asking the device to stroke it, we
                    // simply set up the correct stroke attributes, and request
                    // each path component to be stroked individually.
                    //

                    PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: Is stroking manually"));


                    //
                    // At this point were ONLY being asked to stroke so we simply
                    // setup up the stroke color and set a flag to keep us from
                    // going into polygon mode.
                    //

                    DoSetupOfStrokeAttributes( pPDev,
                                               pPointlBrushOrg,
                                               pBrushStroke,
                                               rop4,
                                               plineattrs );

                    bStrokeOnTheFly = TRUE;
                }
            }
        }

        //
        // At this point were sure to actually do some real RENDERING so set
        // the clip window in the target device.
        //

        if (prclClip) {

            PLOTDBG(DBG_GENPOLYGON,
            ("DoPolygon: Setting Clip Window to: (%ld, %ld)-(%ld, %ld)=%ld x %ld",
                    prclClip->left,   prclClip->top,
                    prclClip->right,  prclClip->bottom,
                    prclClip->right -  prclClip->left,
                    prclClip->bottom -  prclClip->top));


            SetClipWindow( pPDev, prclClip);
        }

        //
        // Now setup to enumerate the PATHOBJ and output the points.
        //

        PATHOBJ_vEnumStart(pPathObj);

        PenIsDown     = FALSE;
        PolyMode      = 0;
        bFirstSubPath = TRUE;

        do {

            //
            // Check to see if the print job has been cancelled.
            //

            if (PLOT_CANCEL_JOB(pPDev)) {

                bRet = FALSE;
                break;
            }

            bMore = PATHOBJ_bEnum(pPathObj, &pd);
            cptfx = pd.count;
            pptfx = pd.pptfx;

            //
            // Check the BEGINSUBPATH or if this is our first time here.
            //

            if ((pd.flags & PD_BEGINSUBPATH) || (bFirstSubPath)) {

                PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: Getting PD_BEGINSUBPATH"));

                TERM_PE_MODE(pPDev, PolyMode);

                ptStart.x = pptfx->x + ptOffsetFix.x;
                ptStart.y = pptfx->y + ptOffsetFix.y;

                MovePen(pPDev, &ptStart, &ptlCur);
                PenIsDown = FALSE;

                pptfx++;
                cptfx--;

                if ((!bStrokeOnTheFly) && (bFirstSubPath)) {

                    SEND_PM0(pPDev);
                }

                bFirstSubPath = FALSE;
            }

            //
            // Now check if we are sending out Beziers.
            //

            if (pd.flags & PD_BEZIERS) {

                PLOTASSERT(1, "DoPolygon: PD_BEZIERS (count % 3) != 0 (%ld)",
                                                      (cptfx % 3) == 0, cptfx);

                SWITCH_TO_BR(pPDev, PolyMode, PenIsDown);

                NumType      = 'f';
                cCurPosSkips = 3;

            } else {

                SWITCH_TO_PE(pPDev, PolyMode, PenIsDown);

                NumType      = 'F';
                cCurPosSkips = 1;
            }

            PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: OutputXYParam(%ld pts=%hs)",
                    cptfx, (pd.flags & PD_BEZIERS) ? "BEZIER" : "POLYGON"));

            OutputXYParams(pPDev,
                           (PPOINTL)pptfx,
                           (PPOINTL)&ptOffsetFix,
                           (PPOINTL)&ptlCur,
                           (UINT)cptfx,
                           (UINT)cCurPosSkips,
                           NumType);

            //
            // Check to see if we are ending the sub path.
            //

            if (pd.flags & PD_ENDSUBPATH) {

                PLOTDBG(DBG_GENPOLYGON,
                       ("DoPolygon: Getting PD_ENDSUBPATH   %hs",
                       (pd.flags & PD_CLOSEFIGURE) ? "PD_CLOSEFIGURE" : ""));

                //
                // If we are not closing the figure then move the pen to the
                // starting position so we do not have the plotter automatically
                // close the sub-path.
                //

                if (pd.flags & PD_CLOSEFIGURE) {

                    PLOTDBG(DBG_GENPOLYGON,
                            ("DoPolygon: OutputXYParam(1) to ptStart=(%ld, %ld)",
                                                ptStart.x, ptStart.y));

                    //
                    // We must not pass the ptOffsetFix, because we already
                    // added it into the ptStart at BEGSUBPATH.
                    //

                    SWITCH_TO_PE(pPDev, PolyMode, PenIsDown);

                    OutputXYParams(pPDev,
                                   (PPOINTL)&ptStart,
                                   (PPOINTL)NULL,
                                   (PPOINTL)&ptlCur,
                                   (UINT)1,
                                   (UINT)1,
                                   'F');
                }

                TERM_PE_MODE(pPDev, PolyMode);

                if (!(pd.flags & PD_CLOSEFIGURE)) {

                    MovePen(pPDev, &ptStart, &ptlCur);
                    PenIsDown = FALSE;
                }

                //
                // If we are not stroking on the fly, close the subpath.
                //

                if (!bStrokeOnTheFly) {

                    SEND_PM1(pPDev);
                }

            }

        } while (bMore);

        TERM_PE_MODE(pPDev, PolyMode);

        //
        // Now end polygon mode.
        //

        if ((bRet)                  &&
            (!bStrokeOnTheFly)      &&
            (!PLOT_CANCEL_JOB(pPDev))) {

            SEND_PM2(pPDev);
            SETLINETYPESOLID(pPDev);

            //
            // Now fill and/or stroke the current polygon.
            //

            DoFillLogic(pPDev,
                        pPointlBrushOrg,
                        pBrushFill,
                        pBrushStroke,
                        rop4,
                        plineattrs,
                        NULL,
                        ulFlags);
        }

        //
        // If we set a clip window, clear it.
        //

        if (prclClip) {

            ClearClipWindow(pPDev);
        }

    } else {

        PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: PATHOBJ_bEnum=NO POINT"));
    }

    //
    // If the path was constructed from a complex clip object we need to
    // delete that path now.
    //

    if (bPathCameFromClip) {

       EngDeletePath(pPathObj);
    }

    return(bRet);
}





VOID
HandleLineAttributes(
    PPDEV       pPDev,
    LINEATTRS   *plineattrs,
    PLONG       pStyleToUse,
    LONG        lExtraStyle
    )

/*++

Routine Description:

    This function does any setup necessary to correctly handle stroking of
    a path. It does this by looking at the LINEATTRS structure passed in
    and setting up the HPGL2 plotter with the appropriate style info using
    HPGL2 styled line commands.

Arguments:

    pPDev           - Pointer to our PDEV

    plineattrs      - LINEATTRS for style lines stroke

    pStyleToUse     - The starting style offset to use, if this is NULL then
                      we use the starting member in plineatts.

    lExtraStyle     - Any extra style to use based on the current run

Return Value:

    VOID


Development History:

    01-Feb-1994 created 




--*/
{
    LONG        lTotLen = 0L;
    INT         i;
    LONG        lScaleVal;
    INT         iCount;
    PFLOAT_LONG pStartStyle;
    FLOAT_LONG  aAlternate[2];
    BOOL        bSolid = TRUE;
    LONG        lStyleState;
    PLONG       pArrayToUse;


    PLOTDBG( DBG_HANDLELINEATTR,
             ("HandleLineAttr: plineattrs = %hs",
             (plineattrs) ? "Exists" : "NULL" ));

    if (plineattrs) {

        PLOTASSERT(1,
                  "HandleLineAttrs: Getting a LA_GEOMETRIC and cannot handle %u",
                  (!(plineattrs->fl & LA_GEOMETRIC)),
                  plineattrs->fl);

        //
        // Set up the correct lStyleState to use, the passed one has precedence
        // over the one imbedded in the lineattributes structure.
        //

        if (pStyleToUse) {

            lStyleState = *pStyleToUse;

        } else {

            lStyleState = plineattrs->elStyleState.l;
        }

        if (plineattrs->fl & LA_ALTERNATE) {

            PLOTDBG( DBG_HANDLELINEATTR,
                    ("HandleLineAttr: plineattrs has LA_ALTERNATE bit set!"));
            //
            // This is a special case where every other pixel is on...
            //

            pStartStyle     = &aAlternate[0];
            iCount          = sizeof(aAlternate) / sizeof(aAlternate[0]);

            aAlternate[0].l = 1;
            aAlternate[1].l = 1;

        } else if ((plineattrs->cstyle != 0) &&
                   (plineattrs->pstyle != (PFLOAT_LONG)NULL)) {

           //
           // There is a user defined style passed in so set up for it
           //

            iCount      = plineattrs->cstyle;
            pStartStyle = plineattrs->pstyle;

            PLOTDBG(DBG_HANDLELINEATTR, ("HandleLineAttr: Count = %ld",
                                            plineattrs->cstyle));

        } else {

           //
           // This is a SOLID line, so simply set the number of points to 0
           //

           iCount = 0;
        }

        if (iCount) {

            PFLOAT_LONG pCurStyle;
            INT         idx;
            LONG        lTempValue;
            LONG        lValueToEnd;
            BOOL        bInDash;
            LONG        convArray[MAX_USER_POINTS];
            PLONG       pConverted;
            LONG        newArray[MAX_USER_POINTS+2];
            PLONG       pNewArray;
            LONG        lCountOfNewArray = CCHOF(newArray);


            PLOTASSERT(0,
                       "HandleLineAttributes: Getting more than 18 points (%ld)",
                       (iCount <= MAX_STYLE_ENTRIES) ,
                       iCount);

            //
            // Record our current DASH state, the line either starts with
            // a gap or a dash.
            //

            if (plineattrs->fl & LA_STARTGAP) {

                bInDash = FALSE;

            } else {

                bInDash = TRUE;
            }

            //
            // Since we know we can't handle more than 20 points sent to HPGL2
            // we limit it now to 18 in order to compensate for the up-to 2
            // additional points we may add later.
            //

            iCount = min(MAX_STYLE_ENTRIES, iCount);


            //
            // Get our scaling value, so we can convert style units to
            // our units.
            //

            lScaleVal = PLOT_STYLE_STEP(pPDev);


            //
            // Now convert to the new units, and store the result in the
            // new array. Also keep track of the total length of the style
            //

            for (i = 0, pConverted = &convArray[0], lTotLen = 0,
                                                pCurStyle = pStartStyle;
                 i < iCount ;
                 i++, pCurStyle++, pConverted++) {

                *pConverted = pCurStyle->l * lScaleVal;

                PLOTDBG( DBG_HANDLELINEATTR,
                         ("HandleLineAttr: Orig Array [%ld]= %ld becomes %ld",
                          i, pCurStyle->l, *pConverted ));

                lTotLen += *pConverted;
            }


            //
            // Now convert the passed style state and extra info into the
            // real final style state to use, we do this by taking the value of
            // interest which is packed into the HIWORD and LOWORD of
            // lstylestate based on the DDK definition, then we must add on
            // any additional distance (which may have come from enuming
            // a CLIPLINE structure).
            //

            lStyleState = (HIWORD(lStyleState) * PLOT_STYLE_STEP(pPDev) +
                           LOWORD(lStyleState) + lExtraStyle) % lTotLen ;

            PLOTDBG(DBG_HANDLELINEATTR,
                    ("HandleLineAttributes: Computed Style state = %ld, extra = %ld",
                    lStyleState, lExtraStyle));

            //
            // Set up our final pointer to the new array, since we may be done
            // based on the final computed stylestate being 0.
            //

            pNewArray = &newArray[0];


            if (lStyleState != 0) {

                lTempValue = 0;

                //
                // Since lStyleState has a value other than zero we must
                // construct a new style array to pass to HPGL2 that has been
                // rotated in order to take into account the style state.
                // the code below constructs the new array.
                //

                for (i=0, pConverted = &convArray[0];
                     i < iCount ;
                     i++, pConverted++) {

                    //
                    // At this point were looking for the entry which partially
                    // encompasses the style state derived. Based on this
                    // we can create a new array that is a transformation of the
                    // original array rotated the correct amount.
                    //

                    if (lStyleState  < lTempValue + *pConverted) {

                        //
                        // Here is the transition point.
                        //

                        if (lCountOfNewArray > 0)
                        {
                            lCountOfNewArray --;
                            *pNewArray++ = *pConverted - (lStyleState - lTempValue);
                        }

                        //
                        // Record the value that needs to be appended to the end
                        // of the array
                        //

                        lValueToEnd = lStyleState - lTempValue;


                        idx = i;

                        idx++;
                        pConverted++;

                        //
                        // Fill up the end
                        //

                        while (idx++ < iCount && lCountOfNewArray -- > 0) {

                            *pNewArray++ = *pConverted++;
                        }

                        //
                        // Now fill up the beginning...
                        //

                        idx        = 0;
                        pConverted = &convArray[0];

                        //
                        // If there was an odd number we can add together
                        // the starting and ending one since they have the
                        // same state
                        //

                        if ((iCount % 2) == 1 ) {

                            pNewArray--;
                            *pNewArray += *pConverted++;

                            idx++;
                            pNewArray++;
                        }

                        while (idx++ < i && lCountOfNewArray-- > 0) {

                            *pNewArray++ = *pConverted++;
                        }

                        if (lCountOfNewArray-- > 0)
                        {
                            *pNewArray++ = lValueToEnd;
                        }

                        break;
                    }

                    lTempValue += *pConverted;

                    bInDash = TOGGLE_DASH(bInDash);
                }

                pArrayToUse = &newArray[0];
                iCount = (INT)(pNewArray - &newArray[0]);

            } else {

                pArrayToUse = &convArray[0];
            }

            PLOTASSERT(0,
                       "HandleLineAttributes: Getting more than 20 points (%ld)",
                       (iCount <= MAX_USER_POINTS) ,
                       iCount);
            //
            // There is a style pattern so set up for it.
            //

            bSolid = FALSE;


            //
            // Begin the HPGL2 line command to define a custom style type
            //

            OutputString(pPDev, "UL1");

            //
            // If this flag is set, the first segment is a gap NOT a dash so
            // we trick HPGL2 into doing the right thing by having a zero
            // length dash in the begining.
            //

            if (!bInDash) {

               OutputString(pPDev, ",0");
            }

            //
            // Since we output the 0 len dash at the begining if the line
            // starts with a gap, the most additional points we send out
            // is decremented by 1.
            //

            iCount = min((bInDash ? MAX_USER_POINTS : MAX_USER_POINTS - 1) ,
                         iCount);

            //
            // Enum through the points in the style array, converting to our
            // Graphics units and send them to the plotter.
            //

            for (i = 0; i < iCount; i++, pArrayToUse++) {

                PLOTDBG(DBG_HANDLELINEATTR,
                         ("HandleLineAttr: New Array [%ld]= %ld",
                          i, *pArrayToUse));

                OutputFormatStr(pPDev, ",#l", *pArrayToUse);
            }

            //
            // Now output the linetype and specify the total lenght of the
            // pattern.
            //

            OutputFormatStr(pPDev, "LT1,#d,1",
                                ((lTotLen * 254) / pPDev->lCurResolution ) / 10 );

            //
            // Update our linetype in the pdev since we ALWAYS send out this
            // line type
            //

            pPDev->LastLineType = PLOT_LT_USERDEFINED;
        }
    }

    //
    // If it was SOLID just send out the SOLID (default command)
    //

    if (bSolid) {

        PLOTDBG(DBG_HANDLELINEATTR, ("HandleLineAttr: Line type is SOLID"));

        //
        // Send out the correct commands to the plotter
        //

        SETLINETYPESOLID(pPDev);
    }
}





VOID
DoFillLogic(
    PPDEV       pPDev,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        Rop4,
    LINEATTRS   *plineattrs,
    SIZEL       *pszlRect,
    ULONG       ulFlags
    )

/*++

Routine Description:

    This routine has the core logic for filling and already established
    polygon, or a passed in segment.

Arguments:

    pPDev           - Pointer to our PDEV

    pptlBrushOrg    - Pointer to the brush origin to be set

    pBrushFill      - Brush used to fill the rectangle

    pBrushStroke    - Brush used to stroke the rectangle

    Rop4            - rop to be used

    plineattrs      - Pointer to the line attributes for a styled line

    pszlRect        - Pointer to a segment to stroke.

    ulFlags         - FPOLY_XXX, stroking and or filling flags.


Return Value:

    VOID


Development History:

    30-Nov-1993 created  

    15-Jan-1994 Sat 05:02:42 updated  
        Change GetColor() and tabify

    18-Jan-1994 Sat 05:02:42 updated 

    16-Feb-1994 Wed 09:34:06 updated  
        Update for the rectangle polygon case to use RR/ER commands



--*/
{
    INTDECIW    PenWidth;


    if (PLOT_CANCEL_JOB(pPDev)) {

        return;
    }

    //
    // Since a polygon must already be defined this code simply
    // looks at the passed data and sends out the appropriate codes to
    // fill/stroke this polygon correctly.
    //

    PenWidth.Integer =
    PenWidth.Decimal = 0;


    if (ulFlags & FPOLY_FILL) {

        DEVBRUSH    *pDevFill;
        DWORD       FillForeColor;
        LONG        HSType;
        LONG        HSParam;
        BOOL        bSetTransparent = FALSE;


        //
        // If we are filling, get the current color taking the ROP into
        // acount.
        //

        if (!GetColor(pPDev, pBrushFill, &FillForeColor, &pDevFill, Rop4)) {

            PLOTERR(("DoFillLogic: GetColor()=FALSE"));
            return;
        }

        HSType  = -1;
        HSParam = (LONG)((pDevFill) ? pDevFill->LineSpacing : 0);

        //
        // If the plotter cannot support tranparent mode there is no need
        // to wory about backgrounds. we will only ever care about foreground.
        //

        if (((IS_TRANSPARENT(pPDev)) || (!IS_RASTER(pPDev))) &&
            (pDevFill)) {

            //
            // Determine if we are using a Pre-defined pattern to fill with.
            //

            switch(pDevFill->PatIndex) {

            case HS_HORIZONTAL:
            case HS_VERTICAL:
            case HS_BDIAGONAL:
            case HS_FDIAGONAL:
            case HS_CROSS:
            case HS_DIAGCROSS:

                PenWidth.Integer = PW_HATCH_INT;
                PenWidth.Decimal = PW_HATCH_DECI;
                bSetTransparent  = (BOOL)IS_TRANSPARENT(pPDev);

                if ((Rop4 & 0xFF00) != 0xAA00) {

                    if (IS_RASTER(pPDev)) {

                       //
                       // Send out the Background Rop.
                       //

                       SetRopMode(pPDev, ROP4_BG_ROP(Rop4));

                       PLOTDBG(DBG_FILL_LOGIC,
                               ("DoFillLogic: BCK = MC=%02lx", ROP4_BG_ROP(Rop4)));
                    }

                    //
                    // We need to select the background color fill then
                    // select the foreground color back... ONLY if it is
                    // non white.
                    //

                    if ((IS_RASTER(pPDev)) ||
                        (!PLOT_IS_WHITE(pPDev, pDevFill->ColorBG))) {

                        HSType = HS_DDI_MAX;
                    }
                }

                break;

            default:

                //
                // If we are a pen plotter and have a user defined pattern.
                // Do a horizontal hatch for background color and a vertical
                // hatch for the foreground color.
                //

                if ((!IS_RASTER(pPDev)) &&
                    (pDevFill->PatIndex >= HS_DDI_MAX)) {

                    PLOTWARN(("DoFillLogic: PEN+USER PAT, Do HS_FDIAGONAL for BG [%ld]",
                                    pDevFill->ColorBG));

                    HSParam <<= 1;

                    if (!PLOT_IS_WHITE(pPDev, pDevFill->ColorBG)) {

                        HSType = HS_FDIAGONAL;

                    } else {

                        PLOTWARN(("DoFillLogic: PEN+USER PAT, Skip WHITE COLOR"));
                    }
                }

                break;
            }
        }


        //
        // Check for a valid pre-defined hatch type and send out the commands.
        //

        if (HSType != -1) {

            PLOTDBG(DBG_FILL_LOGIC, ("DoFillLogic: Fill BGColor = %08lx", pDevFill->ColorBG));

            SelectColor(pPDev, pDevFill->ColorBG, PenWidth);

            SetHSFillType(pPDev, (DWORD)HSType, HSParam);

            SetBrushOrigin(pPDev, pPointlBrushOrg);

            if (pszlRect) {

                SEND_RR(pPDev);
                OutputLONGParams(pPDev, (PLONG)pszlRect, 2, 'd');
                pszlRect = NULL;

            } else {

                SEND_FP(pPDev);

                //
                // Fill with the correct winding mode.
                //

                if (ulFlags & FPOLY_WINDING) {

                    SEND_1SEMI(pPDev);
                }
            }
        }

        //
        // Send out the foreground ROP.
        //

        if (IS_RASTER(pPDev)) {

            SetRopMode(pPDev, ROP4_FG_ROP(Rop4));
        }

        //
        // Now select the foreground color.
        //

        SelectColor(pPDev, FillForeColor, PenWidth);

        if (bSetTransparent) {

            PLOTDBG(DBG_FILL_LOGIC, ("DoFillLogic: TRANSPARENT MODE"));

            //
            // Set up for transparent.
            //

            SEND_TR1(pPDev);
        }

        if (pDevFill) {

            //
            // If the pattern to fill with is user defined, the convert it
            // to a user defined pattern in HPGL2. A user defined pattern
            // is where the client code passed a bitmap in to GDI that
            // it expects to fill with (with tileing). If its a pen plotter,
            // this won't work, so simulate it with a diagonal fill.
            //

            if (pDevFill->PatIndex >= HS_DDI_MAX) {

                if (IS_RASTER(pPDev)) {

                    DownloadUserDefinedPattern(pPDev, pDevFill);

                } else {

                    PLOTWARN(("DoFillLogic: PEN+USER PAT, Do HS_BDIAGONAL for FG [%ld]",
                                    FillForeColor));

                    SetHSFillType(pPDev, HS_BDIAGONAL, HSParam);
                }

            } else {

                //
                // The pattern is a predefined one, so convert it to an HPGL2
                // pattern type.
                //

                SetHSFillType(pPDev, pDevFill->PatIndex, pDevFill->LineSpacing);
            }

            //
            // Set the brush origin.
            //

            SetBrushOrigin(pPDev, pPointlBrushOrg);

        } else {

            SetHSFillType(pPDev, HS_DDI_MAX, 0);
        }

        //
        // If we were passed a segment, paint it now.
        //

        if (pszlRect) {

            SEND_RR(pPDev);
            OutputLONGParams(pPDev, (PLONG)pszlRect, 2, 'd');
            pszlRect = NULL;

        } else {

            //
            // Execute the command to paint the existing path using the current
            // parameters.
            //

            SEND_FP(pPDev);

            if (ulFlags & FPOLY_WINDING) {

                SEND_1SEMI(pPDev);
            }
        }

        //
        // If we used tranparent mode put it back
        //

        if (bSetTransparent) {

            SEND_TR0(pPDev);
        }
    }

    if (ulFlags & FPOLY_STROKE) {

        DoSetupOfStrokeAttributes(pPDev,
                                  pPointlBrushOrg,
                                  pBrushStroke,
                                  Rop4,
                                  plineattrs);

        //
        // give the plotter the command to stroke the polygon outline!
        //

        if (pszlRect) {

            SEND_ER(pPDev);
            OutputLONGParams(pPDev, (PLONG)pszlRect, 2, 'd');

        } else {

            SEND_EP(pPDev);
        }
    }
}





VOID
DoSetupOfStrokeAttributes(
    PPDEV       pPDev,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushStroke,
    ROP4        Rop4,
    LINEATTRS   *plineattrs
    )

/*++

Routine Description:

    This routine sets up the plotter in order to correctly handle stroking,
    based on the passed brush and lineattributes structures.

Arguments:

    pPDev                Pointer to our current PDEV with state info about
                         driver

    pPointlBrushOrg      Brush origin

    pBrushStroke         BRUSHOBJ to stroke with (should only be solid color)

    Rop4                 The rop to use when stroking

    plineattrs           LINEATTRS structure with the specified line styles


Return Value:

    VOID


Development History:

    01-Feb-1994 Tue 05:02:42 created 



--*/
{
    INTDECIW    PenWidth;
    DWORD       StrokeColor;


    GetColor(pPDev, pBrushStroke, &StrokeColor, NULL, Rop4);

    PenWidth.Integer =
    PenWidth.Decimal = 0;

    SelectColor(pPDev, StrokeColor, PenWidth);

    //
    // Send out the foreground Rop, if we are RASTER
    //

    if (IS_RASTER(pPDev)) {

        SetRopMode(pPDev, ROP4_FG_ROP(Rop4));
    }

    //
    // Handle the line attributes
    //

    HandleLineAttributes(pPDev, plineattrs, NULL, 0);
}




LONG
DownloadUserDefinedPattern(
    PPDEV       pPDev,
    PDEVBRUSH   pBrush
    )

/*++

Routine Description:

    This function defines a user pattern to the HPGL2 device. This is used
    when a client application passes a bitmap to GDI to use for filling
    polygons.

Arguments:

    pPDev   - Pointer to the PDEV

    pBrush  - Pointer to the cached device brush


Return Value:

    INT to indicate a pattern number downloaed/defined


Development History:

    09-Feb-1994 Wed 13:11:01 updated 
        Remove 4bpp/1bpp, it always must have pbgr24

    08-Feb-1994 Tue 01:49:53 updated  
        make PalEntry.B = *pbgr++ as first color, since the order we have
        is PALENTRY and first color is B in the structure.

    27-Jan-1994 Thu 21:20:30 updated  
        Add the RF cache codes

    14-Jan-1994 Fri 15:23:40 updated  
        Added assert for compatible device pattern
        Added so it will take device compatible pattern (8x8,16x16,32x32,64x64)

    13-Jan-1994 Thu 19:04:04 created  
        Re-write

    16-Feb-1994 Wed 11:00:19 updated  
        Change return value to return the HSFillType, and fixed the bugs which
        if we found the cached but we do not set the fill type again

    05-Aug-1994 Fri 18:35:45 updated  
        Bug# 22381, we do FindCachedPen() for during the pattern downloading
        and this causing the problem if the pen is not in the cache then we
        will send the PEN DEFINITION at middle of pattern downloading.  If this
        happened then downloading sequence is broken.  We fixes this by

            1) Cache the pen indices if we have enough memory
            2) Run through FindCachePen() for all the RGB colors in the pattern
            3) Download cached pen indices if we have memory OR run through
               FindCachedPen() again to download the pen indices

        This may still have problem if we have

            1) No pen indices caching memory
            2) more color in the pattern then the max pens in the device

        BUT if this happens then we have no choice but to have the wrong output.




--*/

{
    LONG    HSFillType;
    LONG    RFIndex;


    //
    // Firs we must find the RFIndex
    //
    //

    HSFillType = HS_FT_USER_DEFINED;

    if ((RFIndex = FindDBCache(pPDev, pBrush->Uniq)) < 0) {

        LPBYTE  pbgr24;


        RFIndex = -RFIndex;

        //
        // We must download new pattern to the plotter now, make it positive
        //

        if (pbgr24 = pBrush->pbgr24) {

            PALENTRY    PalEntry;
            LPWORD      pwIdx;
            UINT        Idx;
            UINT        Size;


            Size = (UINT)pBrush->cxbgr24 * (UINT)pBrush->cybgr24;

            PLOTDBG(DBG_USERPAT,
                    ("PlotGenUserDefinedPattern: DOWNLOAD %ld x %ld=%ld USER PAT #%ld",
                    (LONG)pBrush->cxbgr24, (LONG)pBrush->cybgr24, Size, RFIndex));

            if (!(pwIdx = (LPWORD)LocalAlloc(LPTR, Size * sizeof(WORD)))) {

                //
                // Do not have memory to do it, so forget it
                //

                PLOTWARN(("Download User defined pattern NO Memory so REAL TIME RUN"));
            }

            //
            // We must first get all the pens cached so we have the indices to
            // use, otherwise we will download the pen color when the pen color
            // is defined.
            //

            PalEntry.Flags = 0;

            for (Idx = 0; Idx < Size; Idx++) {

                WORD    PenIdx;


                PalEntry.B = *pbgr24++;
                PalEntry.G = *pbgr24++;
                PalEntry.R = *pbgr24++;

                PenIdx = (WORD)FindCachedPen(pPDev, &PalEntry);

                if (pwIdx) {

                    pwIdx[Idx] = PenIdx;
                }
            }

            //
            // Now output the download header/size first
            //

            OutputFormatStr(pPDev, "RF#d,#d,#d", RFIndex,
                            (LONG)pBrush->cxbgr24, (LONG)pBrush->cybgr24);

            //
            // If we cached the indices, then use them. Otherwise, find the
            // cache again.
            //

            if (pwIdx) {

                for (Idx = 0; Idx < Size; Idx++) {

                    OutputFormatStr(pPDev, ",#d", pwIdx[Idx]);
                }

                //
                // Free the indices memory if we have one.
                //

                LocalFree((HLOCAL)pwIdx);

            } else {

                //
                // We do not have cached indices, so run through again.
                //

                pbgr24 = pBrush->pbgr24;

                for (Idx = 0; Idx < Size; Idx++) {

                    PalEntry.B = *pbgr24++;
                    PalEntry.G = *pbgr24++;
                    PalEntry.R = *pbgr24++;

                    OutputFormatStr(pPDev, ",#d", FindCachedPen(pPDev, &PalEntry));
                }
            }

            SEND_SEMI(pPDev);

        } else {

            PLOTERR(("PlotGenUserDefinedPattern: NO pbgr24??, set SOLID"));

            HSFillType = HS_DDI_MAX;
            RFIndex    = 0;
        }

    } else {

        PLOTDBG(DBG_USERPAT,
                ("PlotGenUserDefinedPattern: We have CACHED RFIndex=%ld",
                RFIndex));
    }

    SetHSFillType(pPDev, (DWORD)HSFillType, RFIndex);

    return(RFIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\ropblt.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    ropblt.c


Abstract:

    This module contains code to deal with ROP3 codes


Author:

    07-Jan-1994 Fri 11:04:09 created  

    27-Jan-1994 Thu 23:42:09 updated  
        Bascially re-write the codes, make up our own ROP3 to ROP2s generator
        and mixer.  Cloning the surface object as necessary, some of ROP4 to
        ROP2 (Rop3ToSDMix[]) are hand twiks so that it can handle the one
        which we can not handle before (ie. multiple destinaiton usage cases)

    16-Mar-1994 Wed 11:21:45 updated  
        Update the DoMix2() so the SRC aligned to the destination only if the
        source is not psoMask


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgRopBlt

#define DBG_DOMIX2          0x00000001
#define DBG_CLONESO         0x00000002
#define DBG_ROP3            0x00000004
#define DBG_SPECIALROP      0x00000008

DEFINE_DBGVAR(0);



//****************************************************************************
// All ROP3/2 Related Local defines, structures which are only used in this
// file are located here
//****************************************************************************

#define MIX2_0                  0x00
#define MIX2_SoD_n              0x01
#define MIX2_nS_aD              0x02
#define MIX2_nS                 0x03
#define MIX2_nD_aS              0x04
#define MIX2_nD                 0x05
#define MIX2_SxD                0x06
#define MIX2_SaD_n              0x07
#define MIX2_SaD                0x08
#define MIX2_SxD_n              0x09
#define MIX2_D                  0x0A
#define MIX2_nS_oD              0x0B
#define MIX2_S                  0x0C
#define MIX2_nD_oS              0x0D
#define MIX2_SoD                0x0E
#define MIX2_1                  0x0F
#define MIX2_MASK               0x0F

#define MIXSD_SRC_DST           0x00
#define MIXSD_PAT_DST           0x10
#define MIXSD_SRC_PAT           0x20
#define MIXSD_TMP_DST           0x30
#define MIXSD_MASK              0x30

#define MIX2F_MUL_DST           0x80
#define MIX2F_MUL_SRC           0x40
#define MIX2F_NEED_TMP          0x20
#define MIX2F_COUNT_MASK        0x03

#define MAX_SD_MIXS             4
#define SDMIX_SHIFT_COUNT       6
#define GET_SDMIX_MIX2F(dw)     (BYTE)((dw) >> 24)
#define SET_SDMIX_MIX2F(dw,f)   (dw)|=((DWORD)(f) << 24)
#define GET_MIX2F_COUNT(f)      (((f)&0x3)+1)
#define SET_MIX2F_COUNT(f,c)    (f=(BYTE)((((c)-1)&0x3)|((f)&~0x3)))


//
// DWORD SDMix Bits meaning
//
//  Bit  0- 5:
//       6-11:
//      12-17:
//      18-23:  Each has 6 bits, lower 4 bits denote MIX2 operation code (one
//              of 16 MIX2_xxxx, and upper 2 bits is the MIXSD_xxxx which
//              indicate where the source/destination operands come from.
//
//  Bit 24-25:  2 bits indicate the total MIX2_xxx operation codes minus 1,
//              00=1, 01=2, 02=3, 03=4, maximum will be 4 Mix2 operations
//
//  Bit 26:     Not Used
//  Bit 27:     Not Used
//  Bit 28:     Not Used
//  Bit 29:     Flag MIX2F_NEED_TMP to indicate a temporary surface object is
//              needed to stored the PAT/SRC Mix2 operations.
//  Bit 30:     Flag MIX2F_MUL_SRC to indicate multiple source operations
//              are present in the Mix2s.
//  Bit 31:     Flag MIX2F_MUL_DST to indicate multiple destination operations
//              are present in the Mix2s.
//
// The Rop3ToSDMix[] is a DWORD array. each DWORD (SDMix) is defined
// above.  The Rop3ToSDMix[] only list the first 128 of the ROP3 code, the other
// 128 Rop3 codes (128-255) can be obtains by 'Rop3ToSDMix[Rop3 ^ 0xFF]' and
// the result of the Rop3 must be complemented.
//
// Since all Rop3/Rop2 codes are symmetric, we can complement the Rop3/Rop2
// result by complementing MIX2_xxxx (0->15, 1->14...,7->8).
//
// The [!x] in the Rop3ToSDMix[], indicates the following
//
//  !:  Indicates MIX2F_MUL_DST bit is set for the ROP
//  x:  Is the total number of MIX2_xxx operations
//


const DWORD Rop3ToSDMix[128] = {

        { 0x00000000 }, // [ 1]   0-0x00: 0
        { 0x21000C6E }, // [ 2]   1-0x01: ~(D | (P | S))
        { 0x21000E21 }, // [ 2]   2-0x02: D & ~(P | S)
        { 0x0100044C }, // [ 2]   3-0x03: ~(P | S)
        { 0x01000211 }, // [ 2]   4-0x04: S & ~(D | P)
        { 0x00000011 }, // [ 1]   5-0x05: ~(D | P)
        { 0x01000449 }, // [ 2]   6-0x06: ~(P | ~(D ^ S))
        { 0x01000448 }, // [ 2]   7-0x07: ~(P | (D & S))
        { 0x01000212 }, // [ 2]   8-0x08: S & (D & ~P)
        { 0x01000446 }, // [ 2]   9-0x09: ~(P | (D ^ S))
        { 0x00000012 }, // [ 1]  10-0x0a: D & ~P
        { 0x01000444 }, // [ 2]  11-0x0b: ~(P | (S & ~D))
        { 0x0100048C }, // [ 2]  12-0x0c: S & ~P
        { 0x01000442 }, // [ 2]  13-0x0d: ~(P | (D & ~S))
        { 0x01000441 }, // [ 2]  14-0x0e: ~(P | ~(D | S))
        { 0x00000013 }, // [ 1]  15-0x0f: ~P
        { 0x01000601 }, // [ 2]  16-0x10: P & ~(D | S)
        { 0x00000001 }, // [ 1]  17-0x11: ~(D | S)
        { 0x01000059 }, // [ 2]  18-0x12: ~(S | ~(D ^ P))
        { 0x01000058 }, // [ 2]  19-0x13: ~(S | (D & P))
        { 0x21000C69 }, // [ 2]  20-0x14: ~(D | ~(P ^ S))
        { 0x21000C68 }, // [ 2]  21-0x15: ~(D | (P & S))
        { 0x63586E27 }, // [ 4]  22-0x16: P ^ (S ^ (D & ~(P & S)))
        { 0x63278986 }, // [ 4]  23-0x17: ~(S ^ ((S ^ P) & (D ^ S)))
        { 0x22038996 }, // [ 3]  24-0x18: (S ^ P) & (P ^ D)
        { 0x62009E27 }, // [ 3]  25-0x19: ~(S ^ (D & ~(P & S)))
        { 0x22016FA8 }, // [ 3]  26-0x1a: P ^ (D | (S & P))
        { 0x62009E26 }, // [ 3]  27-0x1b: ~(S ^ (D & (P ^ S)))
        { 0x02016398 }, // [ 3]  28-0x1c: P ^ (S | (D & P))

//        { 0x81000216 }, // [!2]  29-0x1d: ~(D ^ (S & (P ^ D)))
        { 0x6203990E }, // [ 3]  29-0x1d: ~((S & ~P) ^ (S | D))

        { 0x0100058E }, // [ 2]  30-0x1e: P ^ (D | S)
        { 0x010005CE }, // [ 2]  31-0x1f: ~(P & (D | S))
        { 0x21000E22 }, // [ 2]  32-0x20: D & (P & ~S)
        { 0x01000056 }, // [ 2]  33-0x21: ~(S | (D ^ P))
        { 0x00000002 }, // [ 1]  34-0x22: D & ~S
        { 0x01000054 }, // [ 2]  35-0x23: ~(S | (P & ~D))
        { 0x62038986 }, // [ 3]  36-0x24: (S ^ P) & (D ^ S)
        { 0x22019E27 }, // [ 3]  37-0x25: ~(P ^ (D & ~(S & P)))
        { 0x62006FA8 }, // [ 3]  38-0x26: S ^ (D | (P & S))
        { 0x22019E26 }, // [ 3]  39-0x27: ~(P ^ (D & (S ^ P)))
        { 0x21000E26 }, // [ 2]  40-0x28: D & (P ^ S)
        { 0x63646FA8 }, // [ 4]  41-0x29: ~(P ^ (S ^ (D | (P & S))))
        { 0x21000E27 }, // [ 2]  42-0x2a: D & ~(P & S)
        { 0x63278996 }, // [ 4]  43-0x2b: ~(S ^ ((S ^ P) & (P ^ D)))
        { 0x0200660E }, // [ 3]  44-0x2c: S ^ (P & (D | S))
        { 0x01000642 }, // [ 2]  45-0x2d: ~(P ^ (D & ~S))
        { 0x02016396 }, // [ 3]  46-0x2e: P ^ (S | (D ^ P))
        { 0x010005CD }, // [ 2]  47-0x2f: ~(P & (S | ~D))
        { 0x0100050C }, // [ 2]  48-0x30: P & ~S
        { 0x01000052 }, // [ 2]  49-0x31: ~(S | (D & ~P))
        { 0x62006FAE }, // [ 3]  50-0x32: S ^ (D | (P | S))
        { 0x00000003 }, // [ 1]  51-0x33: ~S
        { 0x02006788 }, // [ 3]  52-0x34: S ^ (P | (D & S))
        { 0x02006789 }, // [ 3]  53-0x35: S ^ (P | ~(D ^ S))
        { 0x0100019E }, // [ 2]  54-0x36: S ^ (D | P)
        { 0x010001DE }, // [ 2]  55-0x37: ~(S & (D | P))
        { 0x0201621E }, // [ 3]  56-0x38: P ^ (S & (D | P))
        { 0x01000252 }, // [ 2]  57-0x39: ~(S ^ (D & ~P))
        { 0x02006786 }, // [ 3]  58-0x3a: S ^ (P | (D ^ S))
        { 0x010001DD }, // [ 2]  59-0x3b: ~(S & (P | ~D))
        { 0x0100058C }, // [ 2]  60-0x3c: P ^ S
        { 0x02006781 }, // [ 3]  61-0x3d: S ^ (P | ~(D | S))
        { 0x02006782 }, // [ 3]  62-0x3e: S ^ (P | (D & ~S))
        { 0x010005CC }, // [ 2]  63-0x3f: ~(P & S)
        { 0x01000604 }, // [ 2]  64-0x40: P & (S & ~D)
        { 0x21000C66 }, // [ 2]  65-0x41: ~(D | (P ^ S))
        { 0x81000196 }, // [!2]  66-0x42: ~((S ^ D) & (P ^ D))
        { 0x02009607 }, // [ 3]  67-0x43: ~(S ^ (P & ~(D & S)))
        { 0x00000004 }, // [ 1]  68-0x44: S & ~D
        { 0x21000C62 }, // [ 2]  69-0x45: ~(D | (P & ~S))
        { 0x81000398 }, // [!2]  70-0x46: ~(D ^ (S | (P & D)))
        { 0x02019216 }, // [ 3]  71-0x47: ~(P ^ (S & (D ^ P)))
        { 0x01000216 }, // [ 2]  72-0x48: S & (D ^ P)
        { 0x82019398 }, // [!3]  73-0x49: ~(P ^ (D ^ (S | (P & D))))
        { 0x8100060E }, // [!2]  74-0x4a: ~(D ^ (P & (S | D)))
        { 0x01000644 }, // [ 2]  75-0x4b: ~(P ^ (S & ~D))
        { 0x01000217 }, // [ 2]  76-0x4c: S & ~(D & P)
        { 0x6327E986 }, // [ 4]  77-0x4d: ~(S ^ ((S ^ P) | (D ^ S)))
        { 0x22016FA6 }, // [ 3]  78-0x4e: P ^ (D | (S ^ P))
        { 0x010005CB }, // [ 2]  79-0x4f: ~(P & (D | ~S))
        { 0x00000014 }, // [ 1]  80-0x50: P & ~D
        { 0x21000C64 }, // [ 2]  81-0x51: ~(D | (S & ~P))
        { 0x81000788 }, // [!2]  82-0x52: ~(D ^ (P | (S & D)))
        { 0x02009606 }, // [ 3]  83-0x53: ~(S ^ (P & (D ^ S)))
        { 0x21000C61 }, // [ 2]  84-0x54: ~(D | ~(P | S))
        { 0x00000005 }, // [ 1]  85-0x55: ~D
        { 0x21000DAE }, // [ 2]  86-0x56: D ^ (P | S)
        { 0x21000DEE }, // [ 2]  87-0x57: ~(D & (P | S))
        { 0x22016E2E }, // [ 3]  88-0x58: P ^ (D & (S | P))
        { 0x21000E64 }, // [ 2]  89-0x59: ~(D ^ (S & ~P))
        { 0x00000016 }, // [ 1]  90-0x5a: D ^ P
        { 0x22016FA1 }, // [ 3]  91-0x5b: P ^ (D | ~(S | P))

        { 0x220385EE }, // [ 3]  92-0x5c: (S | P) & ~(P & D)

            // { 0x81000786 }, // [!2]  92-0x5c: ~(D ^ (P | (S ^ D)))

        { 0x21000DEB }, // [ 2]  93-0x5d: ~(D & (P | ~S))
        { 0x22016FA4 }, // [ 3]  94-0x5e: P ^ (D | (S & ~P))
        { 0x00000017 }, // [ 1]  95-0x5f: ~(D & P)
        { 0x01000606 }, // [ 2]  96-0x60: P & (D ^ S)
        { 0x82006788 }, // [!3]  97-0x61: ~(D ^ (S ^ (P | (D & S))))
        { 0x8100021E }, // [!2]  98-0x62: ~(D ^ (S & (P | D)))
        { 0x01000254 }, // [ 2]  99-0x63: ~(S ^ (P & ~D))
        { 0x62006E2E }, // [ 3] 100-0x64: S ^ (D & (P | S))
        { 0x21000E62 }, // [ 2] 101-0x65: ~(D ^ (P & ~S))
        { 0x00000006 }, // [ 1] 102-0x66: D ^ S
        { 0x62006FA1 }, // [ 3] 103-0x67: S ^ (D | ~(P | S))
        { 0x63646FA1 }, // [ 4] 104-0x68: ~(P ^ (S ^ (D | ~(P | S))))
        { 0x21000E66 }, // [ 2] 105-0x69: ~(D ^ (P ^ S))
        { 0x21000DA8 }, // [ 2] 106-0x6a: D ^ (P & S)
        { 0x63646E2E }, // [ 4] 107-0x6b: ~(P ^ (S ^ (D & (P | S))))
        { 0x01000198 }, // [ 2] 108-0x6c: S ^ (D & P)
        { 0x8201921E }, // [!3] 109-0x6d: ~(P ^ (D ^ (S & (P | D))))
        { 0x62006E2B }, // [ 3] 110-0x6e: S ^ (D & (P | ~S))
        { 0x010005C9 }, // [ 2] 111-0x6f: ~(P & ~(D ^ S))
        { 0x01000607 }, // [ 2] 112-0x70: P & ~(D & S)
        { 0x82009196 }, // [!3] 113-0x71: ~(S ^ ((S ^ D) & (P ^ D)))
        { 0x62006FA6 }, // [ 3] 114-0x72: S ^ (D | (P ^ S))
        { 0x010001DB }, // [ 2] 115-0x73: ~(S & (D | ~P))
        { 0x81000396 }, // [!2] 116-0x74: ~(D ^ (S | (P ^ D)))
        { 0x21000DED }, // [ 2] 117-0x75: ~(D & (S | ~P))
        { 0x62006FA2 }, // [ 3] 118-0x76: S ^ (D | (P & ~S))
        { 0x00000007 }, // [ 1] 119-0x77: ~(D & S)
        { 0x01000588 }, // [ 2] 120-0x78: P ^ (D & S)
        { 0x8200660E }, // [!3] 121-0x79: ~(D ^ (S ^ (P & (D | S))))
        { 0x22016E2D }, // [ 3] 122-0x7a: P ^ (D & (S | ~P))
        { 0x010001D9 }, // [ 2] 123-0x7b: ~(S & ~(D ^ P))
        { 0x0200660B }, // [ 3] 124-0x7c: S ^ (P & (D | ~S))
        { 0x21000DE9 }, // [ 2] 125-0x7d: ~(D & ~(P ^ S))
        { 0x6203E986 }, // [ 3] 126-0x7e: (S ^ P) | (D ^ S)
        { 0x21000DE8 }  // [ 2] 127-0x7f: ~(D & (P & S))
    };

extern const POINTL ptlZeroOrigin;

//****************************************************************************
// END OF LOCAL DEFINES/STRUCTURE
//****************************************************************************




BOOL
CloneBitBltSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMask,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PRECTL      prclPat,
    BRUSHOBJ    *pbo,
    PCLONESO    pCloneSO,
    DWORD       RopBG,
    DWORD       RopFG
    )
/*++

Routine Description:

    This function will clone the source/pattern and/or create a temp
    source buffer if we need one

Arguments:

    pPDev       - Pointer to our PDEV

    psoDst      - Pointer to our surfae obj

    psoSrc      - Pointer to source surfae obj

    psoMask     - Pointer to the mask surface object if neeed to be used as pat

    pxlo        - translate object from source to destination

    prclDst     - Pointer to the destination rectangle area for the bitblt

    prclSrc     - Pointer to the source rectangle area

    prclPat     - pointer to the pattern rectangle area

    pbo         - Pointer to the pointer of brush object

    pCloneSO    - Pointer to the CLONSO[3] which stored the clone result

    RopBG       - Background rop3

    RopFG       - Foreground rop3

Return Value:

    BOOLEAN


Author:

    24-Jan-1994 Mon 15:58:27 created  


Revision History:


--*/

{
    DWORD   Index;
    INT     CompPat;
    BYTE    Flags;


    //
    // Invert Rop3 if we are out of data range (128-255) and then invert
    // the final result (by inverting last Mix2 Rop2 code (0-15), all Rop3/Rop2
    // codes are symmetric.
    //

    if ((Index = RopBG) >= 0x80) {

        Index ^= 0xFF;
    }

    Flags = GET_SDMIX_MIX2F(Rop3ToSDMix[Index]);

    if ((Index = RopFG) >= 0x80) {

        Index ^= 0xFF;
    }

    Flags |= GET_SDMIX_MIX2F(Rop3ToSDMix[Index]);

    //
    // Clone the PATTERN if necessary.
    //

    if ((ROP3_NEED_PAT(RopFG)) ||
        (ROP3_NEED_PAT(RopBG))) {

        //
        // Only Clone the MASK/PATTERN if it is required
        //

        PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ: NEED PATTERN "));

        if (psoMask) {

            PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ: Use psoMask as pattern"));

            if (!(pCloneSO[CSI_PAT].pso =
                                    CloneMaskSURFOBJ(pPDev,
                                                     psoMask,
                                                     &pCloneSO[CSI_PAT].hBmp,
                                                     prclPat))) {

                PLOTERR(("CloneBitBltSURFOBJ:: CloneMaskSURFOBJ(psoPat) failed"));
                return(FALSE);
            }

        } else {

            //
            // Firs get the DEVBRUSH out.
            //

            if (!(CompPat = (INT)GetColor(pPDev, pbo, NULL, NULL, RopBG))) {

                PLOTERR(("CloneBitBltSURFOBJ:: GetColor for DEVBRUSH failed"));
                return(FALSE);
            }

            //
            // If we do not have a device compatible pattern or if we have to
            // do a SRC/PAT memory operation then we need to clone the pattern
            //

            if ((CompPat < 0) || (Flags & MIX2F_NEED_TMP)) {

                if (!(pCloneSO[CSI_PAT].pso =
                                    CloneBrushSURFOBJ(pPDev,
                                                      psoDst,
                                                      &pCloneSO[CSI_PAT].hBmp,
                                                      pbo))) {

                    PLOTERR(("CloneBitBltSURFOBJ:: CloneBrushSURFOBJ(psoPat) failed"));
                    return(FALSE);
                }

                prclPat->left   =
                prclPat->top    = 0;
                prclPat->right  = pCloneSO[CSI_PAT].pso->sizlBitmap.cx;
                prclPat->bottom = pCloneSO[CSI_PAT].pso->sizlBitmap.cy;
            }
        }
    }

    //
    // Determine if we need to clone the source
    //

    if ((ROP3_NEED_SRC(RopFG) || ROP3_NEED_SRC(RopBG))) {

        if (IsHTCompatibleSurfObj(pPDev,
                                  psoSrc,
                                  pxlo,
                                  (Flags & MIX2F_NEED_TMP) ?
                                    0 : (ISHTF_ALTFMT | ISHTF_DSTPRIM_OK))) {

            PLOTDBG(DBG_CLONESO,
                    ("CloneBitBltSURFOBJ:: Compatible HT Format, SRC=%ld, DST=%ld [ALT=%ld]",
                            psoSrc->iBitmapFormat,
                            ((PDRVHTINFO)pPDev->pvDrvHTData)->HTBmpFormat,
                            ((PDRVHTINFO)pPDev->pvDrvHTData)->AltBmpFormat));

        } else {

            PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ:: CLONING SOURCE"));

            if (!(pCloneSO[CSI_SRC].pso =
                                    CloneSURFOBJToHT(pPDev,
                                                     psoDst,
                                                     psoSrc,
                                                     pxlo,
                                                     &pCloneSO[CSI_SRC].hBmp,
                                                     prclDst,
                                                     prclSrc))) {

                PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ:: CLONE Source FAILED"));
                return(FALSE);
            }
        }
    }

    //
    // Create a TEMP SURFOBJ for SRC/PAT memory operation if it is required
    //

    if (Flags & MIX2F_NEED_TMP) {

        PLOTDBG(DBG_CLONESO, ("CloneBitbltSURFOBJ: CLONE SRC_TMP (%ld x %ld)",
                            prclSrc->right - prclSrc->left,
                            prclSrc->bottom - prclSrc->top));

        if (!(pCloneSO[CSI_TMP].pso =
                            CreateBitmapSURFOBJ(pPDev,
                                                &pCloneSO[CSI_TMP].hBmp,
                                                prclSrc->right - prclSrc->left,
                                                prclSrc->bottom - prclSrc->top,
                                                HTBMPFORMAT(pPDev),
                                                NULL))) {

            PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ:: CLONE SRC_TMP FAILED"));
            return(FALSE);
        }
    }

    return(TRUE);
}




BOOL
DoSpecialRop3(
    SURFOBJ *psoDst,
    CLIPOBJ *pco,
    PRECTL  prclDst,
    DWORD   Rop3
    )

/*++

Routine Description:

    This function does a white or black fil

Arguments:

    psoDst  - The device surface must be DEVICE

    pco     - Clipping object

    prclDst - RECTL area to be rop'ed

    Rop3    - a special Rop3, 0x00, 0xFF, 0x55, 0xAA


Return Value:


    BOOLEAN

Author:

    15-Jan-1994 Sat 07:38:55 created  


Revision History:


--*/

{
    BRUSHOBJ    bo;
    DEVBRUSH    DevBrush;


    PLOTASSERT(1, "DoSpecialRop3: Passed psoDst (%08lx) != STYPE_DEVICE",
                                        psoDst->iType == STYPE_DEVICE, psoDst);

    PLOTDBG(DBG_SPECIALROP, ("DoSpecialROP[%04lx] (%ld, %ld)-(%ld, %ld)=%ld x %ld",
                                        Rop3,
                                        prclDst->left, prclDst->top,
                                        prclDst->right, prclDst->bottom,
                                        prclDst->right - prclDst->left,
                                        prclDst->bottom - prclDst->top));


    bo.iSolidColor         = (DWORD)((Rop3) ? 0x000000000 : 0x00FFFFFF);
    bo.pvRbrush            = (LPVOID)&DevBrush;

    ZeroMemory(&DevBrush, sizeof(DevBrush));

    if (!DoFill(psoDst,                     // psoDst
                NULL,                       // psoSrc
                pco,                        // pco
                NULL,                       // pxlo
                prclDst,                    // prclDst
                NULL,                       // prclSrc
                &bo,                        // pbo
                (PPOINTL)&ptlZeroOrigin,    // pptlBrushOrg
                Rop3 | (Rop3 << 8))) {      // Rop4

        PLOTERR(("DoSpecialRop3: Rop3=%08lx Failed!!!", Rop3));
        return(FALSE);
    }

    return(TRUE);
}




BOOL
DoMix2(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlSrcOrg,
    DWORD       Mix2
    )

/*++

Routine Description:

    This function is responsible for doing a device copy of a bitmap
    with/without tiling and activating the proper Rop2

Arguments:

    pPDev       - Pointer to the PDEV

    psoDst      - pointer to the destination surface object

    psoSrc      - pointer to the source surface object

    pco         - Pointer to the CLIPOBJ

    pxlo        - the translate object from the source to the destination

    prclDst     - the output destination rectangle area

    prclSrc     - the source rectangle area

    pptlSrcOrg  - brush origin for the source rectangle, if this is NULL then
                  prclSrc will not have to be aligned on the destination

    Mix2        - a rop2 mode 0 - 0x0F

Return Value:

    BOOLEAN

Author:

    08-Feb-1994 Tue 16:33:41 updated  
        fixed ptlSrcOrg problem, we need to modulate with source size before
        it get used.

    27-Jan-1994 Thu 23:45:46 updated  
        Re-write so that it can handle the tiling more efficient.

    13-Jan-1994 Sat 09:34:06 created  

Revision History:


--*/
{
    RECTL       rclSrc;
    RECTL       rclDst;
    POINTL      ptlSrcOrg;
    LONG        cxSrc;
    LONG        cySrc;
    DWORD       OHTFlags = 0;
    BOOL        MemMix2;


    //
    // The final ROP is either a ROP3 or a ROP4 (no mask) and it is always
    // a rop2 operation which deals with the source and destination
    //
    // First make it into a Rop3 representation of Rop2 (Mix2)
    //

    PLOTASSERT(1, "DoMix2: Passed INVALID psoSrc (%08lx) = STYPE_DEVICE",
                    (psoSrc) &&
                    (psoSrc->iType != STYPE_DEVICE), psoSrc);

    PLOTASSERT(1, "DoMix2: Unexpected Mix2 = %u, SHOULD NOT BE HERE",
                (Mix2 != MIX2_0) && (Mix2 != MIX2_1) &&
                (Mix2 != MIX2_D) && (Mix2 != MIX2_nD), Mix2);

    Mix2 &= 0x0F;
    Mix2 |= (DWORD)(Mix2 << 4);

    switch (Mix2) {

    case 0x00:  // 0
    case 0xFF:  // 1
    case 0x55:  // ~D

        DoSpecialRop3(psoDst, pco, prclDst, Mix2);

    case 0xAA:  // D

        return(TRUE);
    }

    if (MemMix2 = (BOOL)(psoDst->iType != STYPE_DEVICE)) {

        //
        // Now make it into Rop4 representation of Rop2 (Mix2)
        //

        Mix2 |= (Mix2 << 8);

    } else {

        if (!IsHTCompatibleSurfObj(pPDev,
                                   psoSrc,
                                   pxlo,
                                   ((pxlo) ? ISHTF_ALTFMT : 0)  |
                                        ISHTF_HTXB              |
                                        ISHTF_DSTPRIM_OK)) {

            PLOTERR(("DoMix2: The psoSrc is not HT compatible format (%08lx",
                                    psoSrc->iBitmapFormat));
            return(FALSE);
        }
    }

    cxSrc = prclSrc->right - prclSrc->left;
    cySrc = prclSrc->bottom - prclSrc->top;

    if (pptlSrcOrg) {

        ptlSrcOrg = *pptlSrcOrg;

        if ((ptlSrcOrg.x = (LONG)(prclDst->left - ptlSrcOrg.x) % cxSrc) < 0) {

            ptlSrcOrg.x += cxSrc;
        }

        if ((ptlSrcOrg.y = (LONG)(prclDst->top - ptlSrcOrg.y) % cySrc) < 0) {

            ptlSrcOrg.y += cySrc;
        }

        PLOTDBG(DBG_DOMIX2, ("DoMix2: ORG ptlSrcOrg=(%ld, %ld) -> (%ld, %ld)",
                    pptlSrcOrg->x, pptlSrcOrg->y, ptlSrcOrg.x, ptlSrcOrg.y));

    } else {

        ptlSrcOrg.x =
        ptlSrcOrg.y = 0;

        PLOTDBG(DBG_DOMIX2, ("DoMix2: >>> DO NOT NEED TO ALIGN SRC on DEST <<<"));
    }

    rclSrc.top    = prclSrc->top + ptlSrcOrg.y;
    rclSrc.bottom = prclSrc->bottom;
    rclDst.top    = prclDst->top;
    rclDst.bottom = rclDst.top + (rclSrc.bottom - rclSrc.top);

    PLOTDBG(DBG_DOMIX2, ("DoMix2: SrcFormat=%ld, DstFormat=%ld %hs",
                psoSrc->iBitmapFormat,
                psoDst->iBitmapFormat,
                (MemMix2) ? "[MemMix2]" : ""));

    PLOTDBG(DBG_DOMIX2, ("DoMix2: ORG: Dst=(%ld, %ld)-(%ld,%ld), Src=(%ld, %ld)-(%ld, %ld)",
                prclDst->left, prclDst->top,
                prclDst->right, prclDst->bottom,
                prclSrc->left, prclSrc->top,
                prclSrc->right, prclSrc->bottom));

    while (rclDst.top < prclDst->bottom) {

        //
        // check if the destination bottom is overhanging, clip it,
        //
        // NOTE: This could happen the first time.
        //

        if (rclDst.bottom > prclDst->bottom) {

            //
            // Clip the source/destination rectangle, because we may do
            // EngBitBlt() or OutputHTBitmap()
            //

            rclSrc.bottom -= (rclDst.bottom - prclDst->bottom);
            rclDst.bottom  = prclDst->bottom;
        }

        rclSrc.left  = prclSrc->left + ptlSrcOrg.x;
        rclSrc.right = prclSrc->right;
        rclDst.left  = prclDst->left;
        rclDst.right = rclDst.left + (rclSrc.right - rclSrc.left);

        while (rclDst.left < prclDst->right) {

            //
            // check if the destination right edge is overhanging, clip it if
            // necessary.
            //
            // NOTE: This could happen the first time.
            //

            if (rclDst.right > prclDst->right) {

                //
                // Clip the source/destination rectangle, because we may do a
                // EngBitBlt() or OutputHTBitmap()
                //

                rclSrc.right -= (rclDst.right - prclDst->right);
                rclDst.right  = prclDst->right;
            }

            PLOTDBG(DBG_DOMIX2, ("DoMix2: TILE: Dst=(%ld, %ld)-(%ld,%ld), Src=(%ld, %ld)-(%ld, %ld)",
                        rclDst.left, rclDst.top, rclDst.right, rclDst.bottom,
                        rclSrc.left, rclSrc.top, rclSrc.right, rclSrc.bottom));

            if (MemMix2) {

                //
                // In the memory version we don't have to worry about PCO so
                // just call EngBitBlt to do the work.
                //

                if (!(EngBitBlt(psoDst,                     // psoDst
                                psoSrc,                     // psoSrc
                                NULL,                       // psoMask
                                pco,                        // pco
                                NULL,                       // pxlo
                                &rclDst,                    // prclDst
                                (PPOINTL)&rclSrc,           // pptlSrc
                                NULL,                       // pptlMask
                                NULL,                       // pbo
                                (PPOINTL)&ptlZeroOrigin,    // pptlBrushOrg
                                Mix2))) {

                    PLOTERR(("DoMix2: EngBitBlt(MemMix2=%04lx) Failed!!!",Mix2));
                    return(FALSE);
                }

            } else {

                if (!OutputHTBitmap(pPDev,
                                    psoSrc,
                                    pco,
                                    (PPOINTL)&rclDst,
                                    &rclSrc,
                                    Mix2,
                                    &OHTFlags)) {

                    PLOTERR(("DoMix2: OutputHTBitmap() Failed!!!"));
                    return(FALSE);
                }
            }

            //
            // Reset <source left> to the original left margin and move the
            // destination right to the left for the next destination RECTL.
            //

            rclSrc.left   = prclSrc->left;
            rclDst.left   = rclDst.right;
            rclDst.right += cxSrc;
        }

        //
        // Reset <source top> to the original top margin and move the
        // destination bottom to the top, and set bottom for the next destination
        // RECTL.
        //

        rclSrc.top     = prclSrc->top;
        rclDst.top     = rclDst.bottom;
        rclDst.bottom += cySrc;
    }

    if (OHTFlags & OHTF_MASK) {

        OHTFlags |= OHTF_EXIT_TO_HPGL2;

        OutputHTBitmap(pPDev, psoSrc, NULL, NULL, NULL, 0xAA, &OHTFlags);
    }

    return(TRUE);
}




BOOL
DoRop3(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoPat,
    SURFOBJ     *psoTmp,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PRECTL      prclPat,
    PPOINTL     pptlPatOrg,
    BRUSHOBJ    *pbo,
    DWORD       Rop3
    )

/*++

Routine Description:

    This function performs ROP3 operations (one at a time)


Arguments:

    pPDev       - Pointer to the PDEV

    psoDst      - pointer to the destination surface object

    psoSrc      - pointer to the source surface object

    psoPat      - Pointer to the pattern surface object

    psoTmp      - pointer to the temp buffer surface object

    pco         - clip object

    prclDst     - pointer to the destination rectangle

    prclSrc     - pointer to the source rectangle

    prclPat     - pointer to the pattern rectangle

    pptlPatOrg  - Pointer to the brush origin, if this is NULL then its assumed
                  the pattern's prclPat does not have to be aligned on the
                  destination

    pbo         - a Brush object if we need to call DoFill()

    Rop3        - a ROP3 to be performed


Return Value:

    BOOL

Author:

    20-Jan-1994 Thu 02:36:00 created  

    27-Jan-1994 Thu 23:46:28 updated  
        Re-write to take other parameter, also move the cloning surface objects
        to the caller (ie. DrvBitBlt())

Revision History:


--*/

{
    RECTL   rclTmp;
    DWORD   SDMix;
    DWORD   Mix2;
    BYTE    Flags;
    UINT    Count;
    BOOL    InvertMix2;
    BOOL    Ok;


    PLOTDBG(DBG_ROP3, ("DoRop3: Rop3=%08lx", Rop3));

    switch (Rop3 &= 0xFF) {

    case 0x00:  // 0
    case 0xFF:  // 1
    case 0x55:  // ~D

        DoSpecialRop3(psoDst, pco, prclDst, Rop3);

    case 0xAA:  // D

        //
        // This is NOP
        //

        return(TRUE);
    }

    //
    // Invert Rop3 if we are out of the data range (128-255) and then invert
    // the final result (by inverting last Mix2 Rop2 code (0-15), all Rop3/Rop2
    // codes are symmetric.
    //

    if (Rop3 >= 0x80) {

        InvertMix2 = TRUE;
        SDMix      = (DWORD)Rop3ToSDMix[Rop3 ^ 0xFF];

        PLOTDBG(DBG_ROP3, ("DoRop3: Need Invert ROP"));

    } else {

        InvertMix2 = FALSE;
        SDMix      = (DWORD)Rop3ToSDMix[Rop3];
    }

    if (psoTmp) {

        rclTmp.left   =
        rclTmp.top    = 0;
        rclTmp.right  = psoTmp->sizlBitmap.cx;
        rclTmp.bottom = psoTmp->sizlBitmap.cy;
    }

    Flags = GET_SDMIX_MIX2F(SDMix);
    Count = (UINT)GET_MIX2F_COUNT(Flags);
    Ok    = TRUE;

    PLOTDBG(DBG_ROP3, ("SDMix=%08lx, Flags=%02x, Count=%u", SDMix, Flags, Count));

    if (Flags & MIX2F_MUL_DST) {

        PLOTWARN(("DoRop3: *** Rop3=%08lx Has Multiple DEST, Mix2s NOT complete ***", Rop3));
    }

    while ((Ok) && (Count--)) {

        Mix2 = (DWORD)(SDMix & MIX2_MASK);

        if ((!Count) && (InvertMix2)) {

            PLOTDBG(DBG_ROP3, ("DoRop3: Invert Last MIX2 %02lx -> %02lx",
                                        Mix2, Mix2 ^ MIX2_MASK));

            Mix2 ^= MIX2_MASK;
        }

        PLOTDBG(DBG_ROP3, ("DoRop3: SD=%02lx, Mix2=%02lx",
                                        SDMix & MIXSD_MASK, Mix2));

        switch (SDMix & MIXSD_MASK) {

        case MIXSD_SRC_DST:

            PLOTASSERT(1, "DoRop3: MIXSD_SRC_DST but psoSrc = NULL, Rop3=%08lx",
                                psoSrc, Rop3);

            Ok = DoMix2(pPDev,
                        psoDst,
                        psoSrc,
                        pco,
                        pxlo,
                        prclDst,
                        prclSrc,
                        NULL,
                        Mix2);

            break;

        case MIXSD_PAT_DST:

            if (psoPat) {

                Ok = DoMix2(pPDev,
                            psoDst,
                            psoPat,
                            pco,
                            NULL,
                            prclDst,
                            prclPat,
                            pptlPatOrg,
                            Mix2);

            } else {

                //
                // A compatible brush object is passed, use DoFill() to do
                // the actual work.
                //

                Mix2 += 1;
                Mix2  = MixToRop4(Mix2 | (Mix2 << 8));

                PLOTDBG(DBG_ROP3, ("DoRop3: DoFill[%04lx] (%ld, %ld)-(%ld, %ld)=%ld x %ld",
                                        Mix2, prclDst->left, prclDst->top,
                                        prclDst->right, prclDst->bottom,
                                        prclDst->right - prclDst->left,
                                        prclDst->bottom - prclDst->top));

                Ok = DoFill(psoDst,                 // psoDst
                            NULL,                   // psoSrc
                            pco,                    // pco
                            NULL,                   // pxlo
                            prclDst,                // prclDst
                            NULL,                   // prclSrc
                            pbo,                    // pbo
                            pptlPatOrg,             // pptlBrushOrg
                            Mix2);                  // Rop4
            }

            break;

        case MIXSD_SRC_PAT:

            PLOTASSERT(1, "DoRop3: MIXSD_SRC_PAT but psoSrc = NULL, Rop3=%08lx",
                                psoSrc, Rop3);
            PLOTASSERT(1, "DoRop3: MIXSD_SRC_PAT but psoPat = NULL, Rop3=%08lx",
                                psoPat, Rop3);
            PLOTASSERT(1, "DoRop3: MIXSD_SRC_PAT but psoTmp = NULL, Rop3=%08lx",
                                psoTmp, Rop3);

            //
            // Firs tile the pattern onto the temp buffer then do SRC/DST
            // using SRCCOPY = MIX2_S
            //

            if (pptlPatOrg) {

                //
                // This is a real pattern we have to tile and align it onto the
                // desination, but since psoTmp is 0,0 - cx,cy we must alter
                // the pptlPatOrg to make it align correctly.
                //

                pptlPatOrg->x -= prclDst->left;
                pptlPatOrg->y -= prclDst->top;
            }

            Ok = DoMix2(pPDev,
                        psoTmp,
                        psoPat,
                        NULL,
                        NULL,
                        &rclTmp,
                        prclPat,
                        pptlPatOrg,
                        MIX2_S);

            if (pptlPatOrg) {

                pptlPatOrg->x += prclDst->left;
                pptlPatOrg->y += prclDst->top;
            }

            //
            // Now We will do the MIX2 operation between SRC and PAT
            //

            if (Ok) {

                Ok = DoMix2(pPDev,
                            psoTmp,
                            psoSrc,
                            NULL,
                            NULL,
                            &rclTmp,
                            prclSrc,
                            NULL,
                            Mix2);
            }

            break;

        case MIXSD_TMP_DST:

            PLOTASSERT(1, "DoRop3: MIXSD_TMP_DST but psoTmp = NULL, Rop3=%08lx",
                                psoTmp, Rop3);

            //
            // Since we already aligned the pattern on the temp buffer
            // we can just do the mix2 without aligning it again.
            //

            Ok = DoMix2(pPDev,
                        psoDst,
                        psoTmp,
                        pco,
                        NULL,
                        prclDst,
                        &rclTmp,
                        NULL,
                        Mix2);

            break;
        }

        SDMix >>= SDMIX_SHIFT_COUNT;
    }

    if (!Ok) {

        PLOTERR(("DoRop3: FAILED in DoMix2() operations"));
    }

    return(Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\ropblt.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    ropblt.h


Abstract:

    This module contains all raster operation codes, #defines and structures.


Author:

    07-Jan-1994 Fri 13:05:10 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _ROPBLT_
#define _ROPBLT_
//
// This table defines the Raster Operations. They are listed in RPN and
//
//    D = Destination surface
//    S = Source surface
//    P = Pattern
//    o = OR operator
//    a = AND operator
//    n = NOT operator
//    x = XOR operator
//
//*****************************************************************************
//  R A S T E R    O P E R A T I O N S
//*****************************************************************************
//
//
//    Dec Hex   Logical Operations          RPN notation    Common name
//  -----------------------------------------------------------------------
//      0-0x00  0                           0
//      1-0x01  ~(D | (P | S))              DPSoon
//      2-0x02  D & ~(P | S)                DPSona
//      3-0x03  ~(P | S)                    PSon
//      4-0x04  S & ~(D | P)                SDPona
//      5-0x05  ~(D | P)                    DPon
//      6-0x06  ~(P | ~(D ^ S))             PDSxnon
//      7-0x07  ~(P | (D & S))              PDSaon
//      8-0x08  S & (D & ~P)                SDPnaa
//      9-0x09  ~(P | (D ^ S))              PDSxon
//     10-0x0a  D & ~P                      DPna
//     11-0x0b  ~(P | (S & ~D))             PSDnaon
//     12-0x0c  S & ~P                      SPna
//     13-0x0d  ~(P | (D & ~S))             PDSnaon
//     14-0x0e  ~(P | ~(D | S))             PDSonon
//     15-0x0f  ~P                          Pn
//     16-0x10  P & ~(D | S)                PDSona
//     17-0x11  ~(D | S)                    DSon            NOTSRCERASE
//     18-0x12  ~(S | ~(D ^ P))             SDPxnon
//     19-0x13  ~(S | (D & P))              SDPaon
//     20-0x14  ~(D | ~(P ^ S))             DPSxnon
//     21-0x15  ~(D | (P & S))              DPSaon
//     22-0x16  P ^ (S ^ (D & ~(P & S)))    PSDPSanaxx
//     23-0x17  ~(S ^ ((S ^ P) & (D ^ S)))  SSPxDSxaxn
//     24-0x18  (S ^ P) & (P ^ D)           SPxPDxa
//     25-0x19  ~(S ^ (D & ~(P & S)))       SDPSanaxn
//     26-0x1a  P ^ (D | (S & P))           PDSPaox
//     27-0x1b  ~(S ^ (D & (P ^ S)))        SDPSxaxn
//     28-0x1c  P ^ (S | (D & P))           PSDPaox
//     29-0x1d  ~(D ^ (S & (P ^ D)))        DSPDxaxn
//     30-0x1e  P ^ (D | S)                 PDSox
//     31-0x1f  ~(P & (D | S))              PDSoan
//     32-0x20  D & (P & ~S)                DPSnaa
//     33-0x21  ~(S | (D ^ P))              SDPxon
//     34-0x22  D & ~S                      DSna
//     35-0x23  ~(S | (P & ~D))             SPDnaon
//     36-0x24  (S ^ P) & (D ^ S)           SPxDSxa
//     37-0x25  ~(P ^ (D & ~(S & P)))       PDSPanaxn
//     38-0x26  S ^ (D | (P & S))           SDPSaox
//     39-0x27  S ^ (D | ~(P ^ S))          SDPSxnox
//     40-0x28  D & (P ^ S)                 DPSxa
//     41-0x29  ~(P ^ (S ^ (D | (P & S))))  PSDPSaoxxn
//     42-0x2a  D & ~(P & S)                DPSana
//     43-0x2b  ~(S ^ ((S ^ P) & (P ^ D)))  SSPxPDxaxn
//     44-0x2c  S ^ (P & (D | S))           SPDSoax
//     45-0x2d  P ^ (S | ~D)                PSDnox
//     46-0x2e  P ^ (S | (D ^ P))           PSDPxox
//     47-0x2f  ~(P & (S | ~D))             PSDnoan
//     48-0x30  P & ~S                      PSna
//     49-0x31  ~(S | (D & ~P))             SDPnaon
//     50-0x32  S ^ (D | (P | S))           SDPSoox
//     51-0x33  ~S                          Sn              NOTSRCCOPY
//     52-0x34  S ^ (P | (D & S))           SPDSaox
//     53-0x35  S ^ (P | ~(D ^ S))          SPDSxnox
//     54-0x36  S ^ (D | P)                 SDPox
//     55-0x37  ~(S & (D | P))              SDPoan
//     56-0x38  P ^ (S & (D | P))           PSDPoax
//     57-0x39  S ^ (P | ~D)                SPDnox
//     58-0x3a  S ^ (P | (D ^ S))           SPDSxox
//     59-0x3b  ~(S & (P | ~D))             SPDnoan
//     60-0x3c  P ^ S                       PSx
//     61-0x3d  S ^ (P | ~(D | S))          SPDSonox
//     62-0x3e  S ^ (P | (D & ~S))          SPDSnaox
//     63-0x3f  ~(P & S)                    PSan
//     64-0x40  P & (S & ~D)                PSDnaa
//     65-0x41  ~(D | (P ^ S))              DPSxon
//     66-0x42  (S ^ D) & (P ^ D)           SDxPDxa
//     67-0x43  ~(S ^ (P & ~(D & S)))       SPDSanaxn
//     68-0x44  S & ~D                      SDna            SRCERASE
//     69-0x45  ~(D | (P & ~S))             DPSnaon
//     70-0x46  D ^ (S | (P & D))           DSPDaox
//     71-0x47  ~(P ^ (S & (D ^ P)))        PSDPxaxn
//     72-0x48  S & (D ^ P)                 SDPxa
//     73-0x49  ~(P ^ (D ^ (S | (P & D))))  PDSPDaoxxn
//     74-0x4a  D ^ (P & (S | D))           DPSDoax
//     75-0x4b  P ^ (D | ~S)                PDSnox
//     76-0x4c  S & ~(D & P)                SDPana
//     77-0x4d  ~(S ^ ((S ^ P) | (D ^ S)))  SSPxDSxoxn
//     78-0x4e  P ^ (D | (S ^ P))           PDSPxox
//     79-0x4f  ~(P & (D | ~S))             PDSnoan
//     80-0x50  P & ~D                      PDna
//     81-0x51  ~(D | (S & ~P))             DSPnaon
//     82-0x52  D ^ (P | (S & D))           DPSDaox
//     83-0x53  ~(S ^ (P & (D ^ S)))        SPDSxaxn
//     84-0x54  ~(D | ~(P | S))             DPSonon
//     85-0x55  ~D                          Dn              DSTINVERT
//     86-0x56  D ^ (P | S)                 DPSox
//     87-0x57  ~(D & (P | S))              DPSoan
//     88-0x58  P ^ (D & (S | P))           PDSPoax
//     89-0x59  D ^ (P | ~S)                DPSnox
//     90-0x5a  D ^ P                       DPx             PATINVERT
//     91-0x5b  D ^ (P | ~(S | D))          DPSDonox
//     92-0x5c  D ^ (P | (S ^ D))           DPSDxox
//     93-0x5d  ~(D & (P | ~S))             DPSnoan
//     94-0x5e  D ^ (P | (S & ~D))          DPSDnaox
//     95-0x5f  ~(D & P)                    DPan
//     96-0x60  P & (D ^ S)                 PDSxa
//     97-0x61  ~(D ^ (S ^ (P | (D & S))))  DSPDSaoxxn
//     98-0x62  D ^ (S & (P | D))           DSPDoax
//     99-0x63  S ^ (D | ~P)                SDPnox
//    100-0x64  S ^ (D & (P | S))           SDPSoax
//    101-0x65  D ^ (S | ~P)                DSPnox
//    102-0x66  D ^ S                       DSx             SRCINVERT
//    103-0x67  S ^ (D | ~(P | S))          SDPSonox
//    104-0x68  ~(D ^ (S ^ (P | ~(D | S)))) DSPDSonoxxn
//    105-0x69  ~(P ^ (D ^ S))              PDSxxn
//    106-0x6a  D ^ (P & S)                 DPSax
//    107-0x6b  ~(P ^ (S ^ (D & (P | S))))  PSDPSoaxxn
//    108-0x6c  S ^ (D & P)                 SDPax
//    109-0x6d  ~(P ^ (D ^ (S & (P | D))))  PDSPDoaxxn
//    110-0x6e  S ^ (D & (P | ~S))          SDPSnoax
//    111-0x6f  ~(P & ~(D ^ S))             PDSxnan
//    112-0x70  P & ~(D & S)                PDSana
//    113-0x71  ~(S ^ ((S ^ D) & (P ^ D)))  SSDxPDxaxn
//    114-0x72  S ^ (D | (P ^ S))           SDPSxox
//    115-0x73  ~(S & (D | ~P))             SDPnoan
//    116-0x74  D ^ (S | (P ^ D))           DSPDxox
//    117-0x75  ~(D & (S | ~P))             DSPnoan
//    118-0x76  S ^ (D | (P & ~S))          SDPSnaox
//    119-0x77  ~(D & S)                    DSan
//    120-0x78  P ^ (D & S)                 PDSax
//    121-0x79  ~(D ^ (S ^ (P & (D | S))))  DSPDSoaxxn
//    122-0x7a  D ^ (P & (S | ~D))          DPSDnoax
//    123-0x7b  ~(S & ~(D ^ P))             SDPxnan
//    124-0x7c  S ^ (P & (D | ~S))          SPDSnoax
//    125-0x7d  ~(D & ~(P ^ S))             DPSxnan
//    126-0x7e  (S ^ P) | (D ^ S)           SPxDSxo
//    127-0x7f  ~(D & (P & S))              DPSaan
//    128-0x80  D & (P & S)                 DPSaa
//    129-0x81  ~((S ^ P) | (D ^ S))        SPxDSxon
//    130-0x82  D & ~(P ^ S)                DPSxna
//    131-0x83  ~(S ^ (P & (D | ~S)))       SPDSnoaxn
//    132-0x84  S & ~(D ^ P)                SDPxna
//    133-0x85  ~(P ^ (D & (S | ~P)))       PDSPnoaxn
//    134-0x86  D ^ (S ^ (P & (D | S)))     DSPDSoaxx
//    135-0x87  ~(P ^ (D & S))              PDSaxn
//    136-0x88  D & S                       DSa             SRCAND
//    137-0x89  ~(S ^ (D | (P & ~S)))       SDPSnaoxn
//    138-0x8a  D & (S | ~P)                DSPnoa
//    139-0x8b  ~(D ^ (S | (P ^ D)))        DSPDxoxn
//    140-0x8c  S & (D | ~P)                SDPnoa
//    141-0x8d  ~(S ^ (D | (P ^ S)))        SDPSxoxn
//    142-0x8e  S ^ ((S ^ D) & (P ^ D))     SSDxPDxax
//    143-0x8f  ~(P & ~(D & S))             PDSanan
//    144-0x90  P & ~(D ^ S)                PDSxna
//    145-0x91  ~(S ^ (D & (P | ~S)))       SDPSnoaxn
//    146-0x92  D ^ (P ^ (S & (D | P)))     DPSDPoaxx
//    147-0x93  ~(S ^ (P & D))              SPDaxn
//    148-0x94  P ^ (S ^ (D & (P | S)))     PSDPSoaxx
//    149-0x95  ~(D ^ (P & S))              DPSaxn
//    150-0x96  D ^ (P ^ S)                 DPSxx
//    151-0x97  P ^ (S ^ (D | ~(P | S)))    PSDPSonoxx
//    152-0x98  ~(S ^ (D | ~(P | S)))       SDPSonoxn
//    153-0x99  ~(D ^ S)                    DSxn
//    154-0x9a  D ^ (P & ~S)                DPSnax
//    155-0x9b  ~(S ^ (D & (P | S)))        SDPSoaxn
//    156-0x9c  S ^ (P & ~D)                SPDnax
//    157-0x9d  ~(D ^ (S & (P | D)))        DSPDoaxn
//    158-0x9e  D ^ (S ^ (P | (D & S)))     DSPDSaoxx
//    159-0x9f  ~(P & (D ^ S))              PDSxan
//    160-0xa0  D & P                       DPa
//    161-0xa1  ~(P ^ (D | (S & ~P)))       PDSPnaoxn
//    162-0xa2  D & (P | ~S)                DPSnoa
//    163-0xa3  ~(D ^ (P | (S ^ D)))        DPSDxoxn
//    164-0xa4  ~(P ^ (D | ~(S | P)))       PDSPonoxn
//    165-0xa5  ~(P ^ D)                    PDxn
//    166-0xa6  D ^ (S & ~P)                DSPnax
//    167-0xa7  ~(P ^ (D & (S | P)))        PDSPoaxn
//    168-0xa8  D & (P | S)                 DPSoa
//    169-0xa9  ~(D ^ (P | S))              DPSoxn
//    170-0xaa  D                           D
//    171-0xab  D | ~(P | S)                DPSono
//    172-0xac  S ^ (P & (D ^ S))           SPDSxax
//    173-0xad  ~(D ^ (P | (S & D)))        DPSDaoxn
//    174-0xae  D | (S & ~P)                DSPnao
//    175-0xaf  D | ~P                      DPno
//    176-0xb0  P & (D | ~S)                PDSnoa
//    177-0xb1  ~(P ^ (D | (S ^ P)))        PDSPxoxn
//    178-0xb2  S ^ ((S ^ P) | (D ^ S))     SSPxDSxox
//    179-0xb3  ~(S & ~(D & P))             SDPanan
//    180-0xb4  P ^ (S & ~D)                PSDnax
//    181-0xb5  ~(D ^ (P & (S | D)))        DPSDoaxn
//    182-0xb6  D ^ (P ^ (S | (D & P)))     DPSDPaoxx
//    183-0xb7  ~(S & (D ^ P))              SDPxan
//    184-0xb8  P ^ (S & (D ^ P))           PSDPxax
//    185-0xb9  ~(D ^ (S | (P & D)))        DSPDaoxn
//    186-0xba  D | (P & ~S)                DPSnao
//    187-0xbb  D | ~S                      DSno            MERGEPAINT
//    188-0xbc  S ^ (P & ~(D & S))          SPDSanax
//    189-0xbd  ~((S ^ D) & (P ^ D))        SDxPDxan
//    190-0xbe  D | (P ^ S)                 DPSxo
//    191-0xbf  D | ~(P & S)                DPSano
//    192-0xc0  P & S                       PSa             MERGECOPY
//    193-0xc1  ~(S ^ (P | (D & ~S)))       SPDSnaoxn
//    194-0xc2  ~(S ^ (P | ~(D | S)))       SPDSonoxn
//    195-0xc3  ~(P ^ S)                    PSxn
//    196-0xc4  S & (P | ~D)                SPDnoa
//    197-0xc5  ~(S ^ (P | (D ^ S)))        SPDSxoxn
//    198-0xc6  S ^ (D & ~P)                SDPnax
//    199-0xc7  ~(P ^ (S & (D | P)))        PSDPoaxn
//    200-0xc8  S & (D | P)                 SDPoa
//    201-0xc9  ~(S ^ (P | D))              SPDoxn
//    202-0xca  D ^ (P & (S ^ D))           DPSDxax
//    203-0xcb  ~(S ^ (P | (D & S)))        SPDSaoxn
//    204-0xcc  S                           S               SRCCOPY
//    205-0xcd  S | ~(D | P)                SDPono
//    206-0xce  S | (D & ~P)                SDPnao
//    207-0xcf  S | ~P                      SPno
//    208-0xd0  P & (S | ~D)                PSDnoa
//    209-0xd1  ~(P ^ (S | (D ^ P)))        PSDPxoxn
//    210-0xd2  P ^ (D & ~S)                PDSnax
//    211-0xd3  ~(S ^ (P & (D | S)))        SPDSoaxn
//    212-0xd4  S ^ ((S ^ P) & (P ^ D))     SSPxPDxax
//    213-0xd5  ~(D & ~(P & S))             DPSanan
//    214-0xd6  P ^ (S ^ (D | (P & S)))     PSDPSaoxx
//    215-0xd7  ~(D & (P ^ S))              DPSxan
//    216-0xd8  P ^ (D & (S ^ P))           PDSPxax
//    217-0xd9  ~(S ^ (D | (P & S)))        SDPSaoxn
//    218-0xda  D ^ (P & ~(S & D))          DPSDanax
//    219-0xdb  ~((S ^ P) & (D ^ S))        SPxDSxan
//    220-0xdc  S | (P & ~D)                SPDnao
//    221-0xdd  S | ~D                      SDno
//    222-0xde  S | (D ^ P)                 SDPxo
//    223-0xdf  S | ~(D & P)                SDPano
//    224-0xe0  P & (D | S)                 PDSoa
//    225-0xe1  ~(P ^ (D | S))              PDSoxn
//    226-0xe2  D ^ (S & (P ^ D))           DSPDxax
//    227-0xe3  ~(P ^ (S | (D & P)))        PSDPaoxn
//    228-0xe4  S ^ (D & (P ^ S))           SDPSxax
//    229-0xe5  ~(P ^ (D | (S & P)))        PDSPaoxn
//    230-0xe6  S ^ (D & ~(P & S))          SDPSanax
//    231-0xe7  ~((S ^ P) & (P ^ D))        SPxPDxan
//    232-0xe8  S ^ ((S ^ P) & (D ^ S))     SSPxDSxax
//    233-0xe9  ~(D ^ (S ^ (P & ~(D & S)))) DSPDSanaxxn
//    234-0xea  D | (P & S)                 DPSao
//    235-0xeb  D | ~(P ^ S)                DPSxno
//    236-0xec  S | (D & P)                 SDPao
//    237-0xed  S | ~(D ^ P)                SDPxno
//    238-0xee  D | S                       DSo             SRCPAINT
//    239-0xef  S | (D | ~P)                SDPnoo
//    240-0xf0  P                           P               PATCOPY
//    241-0xf1  P | ~(D | S)                PDSono
//    242-0xf2  P | (D & ~S)                PDSnao
//    243-0xf3  P | ~S                      PSno
//    244-0xf4  P | (S & ~D)                PSDnao
//    245-0xf5  P | ~D                      PDno
//    246-0xf6  P | (D ^ S)                 PDSxo
//    247-0xf7  P | ~(D & S)                PDSano
//    248-0xf8  P | (D & S)                 PDSao
//    249-0xf9  P | ~(D ^ S)                PDSxno
//    250-0xfa  D | P                       DPo
//    251-0xfb  D | (P | ~S)                DPSnoo          PATPAINT
//    252-0xfc  P | S                       PSo
//    253-0xfd  P | (S | ~D)                PSDnoo
//    254-0xfe  D | (P | S)                 DPSoo
//    255-0xff  1                           1               WHITENESS
//
//
// ********* ALL ROP3/ROP2 CODES are SYMMETRIC ************
//
// Raster Operation Index required [NONE]
//
// 0x00: 0                           [INV] 0xff: 1
//
// Raster Operation Index required [DST ]
//
// 0x55: ~D                          [INV] 0xaa: D
//
// Raster Operation Index required [SRC ]
//
// 0x33: ~S                          [INV] 0xcc: S
//
// Raster Operation Index required [SRC DST ]
//
// 0x11: ~(D | S)                    [INV] 0xee: D | S
// 0x22: D & ~S                      [INV] 0xdd: S | ~D
// 0x44: S & ~D                      [INV] 0xbb: D | ~S
// 0x66: D ^ S                       [INV] 0x99: ~(D ^ S)
// 0x77: ~(D & S)                    [INV] 0x88: D & S
//
// Raster Operation Index required [PAT ]
//
// 0x0f: ~P                          [INV] 0xf0: P
//
// Raster Operation Index required [PAT DST ]
//
// 0x05: ~(D | P)                    [INV] 0xfa: D | P
// 0x0a: D & ~P                      [INV] 0xf5: P | ~D
// 0x50: P & ~D                      [INV] 0xaf: D | ~P
// 0x5a: D ^ P                       [INV] 0xa5: ~(P ^ D)
// 0x5f: ~(D & P)                    [INV] 0xa0: D & P
//
// Raster Operation Index required [PAT SRC ]
//
// 0x03: ~(P | S)                    [INV] 0xfc: P | S
// 0x0c: S & ~P                      [INV] 0xf3: P | ~S
// 0x30: P & ~S                      [INV] 0xcf: S | ~P
// 0x3c: P ^ S                       [INV] 0xc3: ~(P ^ S)
// 0x3f: ~(P & S)                    [INV] 0xc0: P & S
//
// Raster Operation Index required [PAT SRC DST ]
//
// 0x01: ~(D | (P | S))              [INV] 0xfe: D | (P | S)
// 0x02: D & ~(P | S)                [INV] 0xfd: P | (S | ~D)
// 0x04: S & ~(D | P)                [INV] 0xfb: D | (P | ~S)
// 0x06: ~(P | ~(D ^ S))             [INV] 0xf9: P | ~(D ^ S)
// 0x07: ~(P | (D & S))              [INV] 0xf8: P | (D & S)
// 0x08: S & (D & ~P)                [INV] 0xf7: P | ~(D & S)
// 0x09: ~(P | (D ^ S))              [INV] 0xf6: P | (D ^ S)
// 0x0b: ~(P | (S & ~D))             [INV] 0xf4: P | (S & ~D)
// 0x0d: ~(P | (D & ~S))             [INV] 0xf2: P | (D & ~S)
// 0x0e: ~(P | ~(D | S))             [INV] 0xf1: P | ~(D | S)
// 0x10: P & ~(D | S)                [INV] 0xef: S | (D | ~P)
// 0x12: ~(S | ~(D ^ P))             [INV] 0xed: S | ~(D ^ P)
// 0x13: ~(S | (D & P))              [INV] 0xec: S | (D & P)
// 0x14: ~(D | ~(P ^ S))             [INV] 0xeb: D | ~(P ^ S)
// 0x15: ~(D | (P & S))              [INV] 0xea: D | (P & S)
// 0x16: P ^ (S ^ (D & ~(P & S)))    [INV] 0xe9: ~(D ^ (S ^ (P & ~(D & S))))
// 0x17: ~(S ^ ((S ^ P) & (D ^ S)))  [INV] 0xe8: S ^ ((S ^ P) & (D ^ S))
// 0x18: (S ^ P) & (P ^ D)           [INV] 0xe7: ~((S ^ P) & (P ^ D))
// 0x19: ~(S ^ (D & ~(P & S)))       [INV] 0xe6: S ^ (D & ~(P & S))
// 0x1a: P ^ (D | (S & P))           [INV] 0xe5: ~(P ^ (D | (S & P)))
// 0x1b: ~(S ^ (D & (P ^ S)))        [INV] 0xe4: S ^ (D & (P ^ S))
// 0x1c: P ^ (S | (D & P))           [INV] 0xe3: ~(P ^ (S | (D & P)))
// 0x1d: ~(D ^ (S & (P ^ D)))        [INV] 0xe2: D ^ (S & (P ^ D))
// 0x1e: P ^ (D | S)                 [INV] 0xe1: ~(P ^ (D | S))
// 0x1f: ~(P & (D | S))              [INV] 0xe0: P & (D | S)
// 0x20: D & (P & ~S)                [INV] 0xdf: S | ~(D & P)
// 0x21: ~(S | (D ^ P))              [INV] 0xde: S | (D ^ P)
// 0x23: ~(S | (P & ~D))             [INV] 0xdc: S | (P & ~D)
// 0x24: (S ^ P) & (D ^ S)           [INV] 0xdb: ~((S ^ P) & (D ^ S))
// 0x25: ~(P ^ (D & ~(S & P)))       [INV] 0xda: D ^ (P & ~(S & D))
// 0x26: S ^ (D | (P & S))           [INV] 0xd9: ~(S ^ (D | (P & S)))
// 0x27: S ^ (D | ~(P ^ S))          [INV] 0xd8: P ^ (D & (S ^ P))
// 0x28: D & (P ^ S)                 [INV] 0xd7: ~(D & (P ^ S))
// 0x29: ~(P ^ (S ^ (D | (P & S))))  [INV] 0xd6: P ^ (S ^ (D | (P & S)))
// 0x2a: D & ~(P & S)                [INV] 0xd5: ~(D & ~(P & S))
// 0x2b: ~(S ^ ((S ^ P) & (P ^ D)))  [INV] 0xd4: S ^ ((S ^ P) & (P ^ D))
// 0x2c: S ^ (P & (D | S))           [INV] 0xd3: ~(S ^ (P & (D | S)))
// 0x2d: P ^ (S | ~D)                [INV] 0xd2: P ^ (D & ~S)
// 0x2e: P ^ (S | (D ^ P))           [INV] 0xd1: ~(P ^ (S | (D ^ P)))
// 0x2f: ~(P & (S | ~D))             [INV] 0xd0: P & (S | ~D)
// 0x31: ~(S | (D & ~P))             [INV] 0xce: S | (D & ~P)
// 0x32: S ^ (D | (P | S))           [INV] 0xcd: S | ~(D | P)
// 0x34: S ^ (P | (D & S))           [INV] 0xcb: ~(S ^ (P | (D & S)))
// 0x35: S ^ (P | ~(D ^ S))          [INV] 0xca: D ^ (P & (S ^ D))
// 0x36: S ^ (D | P)                 [INV] 0xc9: ~(S ^ (P | D))
// 0x37: ~(S & (D | P))              [INV] 0xc8: S & (D | P)
// 0x38: P ^ (S & (D | P))           [INV] 0xc7: ~(P ^ (S & (D | P)))
// 0x39: S ^ (P | ~D)                [INV] 0xc6: S ^ (D & ~P)
// 0x3a: S ^ (P | (D ^ S))           [INV] 0xc5: ~(S ^ (P | (D ^ S)))
// 0x3b: ~(S & (P | ~D))             [INV] 0xc4: S & (P | ~D)
// 0x3d: S ^ (P | ~(D | S))          [INV] 0xc2: ~(S ^ (P | ~(D | S)))
// 0x3e: S ^ (P | (D & ~S))          [INV] 0xc1: ~(S ^ (P | (D & ~S)))
// 0x40: P & (S & ~D)                [INV] 0xbf: D | ~(P & S)
// 0x41: ~(D | (P ^ S))              [INV] 0xbe: D | (P ^ S)
// 0x42: (S ^ D) & (P ^ D)           [INV] 0xbd: ~((S ^ D) & (P ^ D))
// 0x43: ~(S ^ (P & ~(D & S)))       [INV] 0xbc: S ^ (P & ~(D & S))
// 0x45: ~(D | (P & ~S))             [INV] 0xba: D | (P & ~S)
// 0x46: D ^ (S | (P & D))           [INV] 0xb9: ~(D ^ (S | (P & D)))
// 0x47: ~(P ^ (S & (D ^ P)))        [INV] 0xb8: P ^ (S & (D ^ P))
// 0x48: S & (D ^ P)                 [INV] 0xb7: ~(S & (D ^ P))
// 0x49: ~(P ^ (D ^ (S | (P & D))))  [INV] 0xb6: D ^ (P ^ (S | (D & P)))
// 0x4a: D ^ (P & (S | D))           [INV] 0xb5: ~(D ^ (P & (S | D)))
// 0x4b: P ^ (D | ~S)                [INV] 0xb4: P ^ (S & ~D)
// 0x4c: S & ~(D & P)                [INV] 0xb3: ~(S & ~(D & P))
// 0x4d: ~(S ^ ((S ^ P) | (D ^ S)))  [INV] 0xb2: S ^ ((S ^ P) | (D ^ S))
// 0x4e: P ^ (D | (S ^ P))           [INV] 0xb1: ~(P ^ (D | (S ^ P)))
// 0x4f: ~(P & (D | ~S))             [INV] 0xb0: P & (D | ~S)
// 0x51: ~(D | (S & ~P))             [INV] 0xae: D | (S & ~P)
// 0x52: D ^ (P | (S & D))           [INV] 0xad: ~(D ^ (P | (S & D)))
// 0x53: ~(S ^ (P & (D ^ S)))        [INV] 0xac: S ^ (P & (D ^ S))
// 0x54: ~(D | ~(P | S))             [INV] 0xab: D | ~(P | S)
// 0x56: D ^ (P | S)                 [INV] 0xa9: ~(D ^ (P | S))
// 0x57: ~(D & (P | S))              [INV] 0xa8: D & (P | S)
// 0x58: P ^ (D & (S | P))           [INV] 0xa7: ~(P ^ (D & (S | P)))
// 0x59: D ^ (P | ~S)                [INV] 0xa6: D ^ (S & ~P)
// 0x5b: D ^ (P | ~(S | D))          [INV] 0xa4: ~(P ^ (D | ~(S | P)))
// 0x5c: D ^ (P | (S ^ D))           [INV] 0xa3: ~(D ^ (P | (S ^ D)))
// 0x5d: ~(D & (P | ~S))             [INV] 0xa2: D & (P | ~S)
// 0x5e: D ^ (P | (S & ~D))          [INV] 0xa1: ~(P ^ (D | (S & ~P)))
// 0x60: P & (D ^ S)                 [INV] 0x9f: ~(P & (D ^ S))
// 0x61: ~(D ^ (S ^ (P | (D & S))))  [INV] 0x9e: D ^ (S ^ (P | (D & S)))
// 0x62: D ^ (S & (P | D))           [INV] 0x9d: ~(D ^ (S & (P | D)))
// 0x63: S ^ (D | ~P)                [INV] 0x9c: S ^ (P & ~D)
// 0x64: S ^ (D & (P | S))           [INV] 0x9b: ~(S ^ (D & (P | S)))
// 0x65: D ^ (S | ~P)                [INV] 0x9a: D ^ (P & ~S)
// 0x67: S ^ (D | ~(P | S))          [INV] 0x98: ~(S ^ (D | ~(P | S)))
// 0x68: ~(D ^ (S ^ (P | ~(D | S)))) [INV] 0x97: P ^ (S ^ (D | ~(P | S)))
// 0x69: ~(P ^ (D ^ S))              [INV] 0x96: D ^ (P ^ S)
// 0x6a: D ^ (P & S)                 [INV] 0x95: ~(D ^ (P & S))
// 0x6b: ~(P ^ (S ^ (D & (P | S))))  [INV] 0x94: P ^ (S ^ (D & (P | S)))
// 0x6c: S ^ (D & P)                 [INV] 0x93: ~(S ^ (P & D))
// 0x6d: ~(P ^ (D ^ (S & (P | D))))  [INV] 0x92: D ^ (P ^ (S & (D | P)))
// 0x6e: S ^ (D & (P | ~S))          [INV] 0x91: ~(S ^ (D & (P | ~S)))
// 0x6f: ~(P & ~(D ^ S))             [INV] 0x90: P & ~(D ^ S)
// 0x70: P & ~(D & S)                [INV] 0x8f: ~(P & ~(D & S))
// 0x71: ~(S ^ ((S ^ D) & (P ^ D)))  [INV] 0x8e: S ^ ((S ^ D) & (P ^ D))
// 0x72: S ^ (D | (P ^ S))           [INV] 0x8d: ~(S ^ (D | (P ^ S)))
// 0x73: ~(S & (D | ~P))             [INV] 0x8c: S & (D | ~P)
// 0x74: D ^ (S | (P ^ D))           [INV] 0x8b: ~(D ^ (S | (P ^ D)))
// 0x75: ~(D & (S | ~P))             [INV] 0x8a: D & (S | ~P)
// 0x76: S ^ (D | (P & ~S))          [INV] 0x89: ~(S ^ (D | (P & ~S)))
// 0x78: P ^ (D & S)                 [INV] 0x87: ~(P ^ (D & S))
// 0x79: ~(D ^ (S ^ (P & (D | S))))  [INV] 0x86: D ^ (S ^ (P & (D | S)))
// 0x7a: D ^ (P & (S | ~D))          [INV] 0x85: ~(P ^ (D & (S | ~P)))
// 0x7b: ~(S & ~(D ^ P))             [INV] 0x84: S & ~(D ^ P)
// 0x7c: S ^ (P & (D | ~S))          [INV] 0x83: ~(S ^ (P & (D | ~S)))
// 0x7d: ~(D & ~(P ^ S))             [INV] 0x82: D & ~(P ^ S)
// 0x7e: (S ^ P) | (D ^ S)           [INV] 0x81: ~((S ^ P) | (D ^ S))
// 0x7f: ~(D & (P & S))              [INV] 0x80: D & (P & S)
//
//
// The following macros will tell us if we need to use a 'mask' for ROP4
// and define if S / P / D are in a ROP3
//

#define ROP4_NEED_MASK(Rop4)    (((Rop4 >> 8) & 0xFF) != (Rop4 & 0xFF))
#define ROP3_NEED_PAT(Rop3)     (((Rop3 >> 4) & 0x0F) != (Rop3 & 0x0F))
#define ROP3_NEED_SRC(Rop3)     (((Rop3 >> 2) & 0x33) != (Rop3 & 0x33))
#define ROP3_NEED_DST(Rop3)     (((Rop3 >> 1) & 0x55) != (Rop3 & 0x55))
#define ROP4_FG_ROP(Rop4)       (Rop4 & 0xFF)
#define ROP4_BG_ROP(Rop4)       ((Rop4 >> 8) & 0xFF)


#define CSI_SRC         0
#define CSI_PAT         1
#define CSI_TMP         2
#define CSI_TOTAL       3

typedef struct _CLONESO {
    SURFOBJ *pso;
    HBITMAP hBmp;
    } CLONESO, *PCLONESO;


typedef struct _SDINFO {
    SURFOBJ     *psoDst;    // detination to write BITMAP or DEVICE
    SURFOBJ     *psoSrc;    // source to read must be BITMAP
    PRECTL      prclDst;    // destination rectangle
    PRECTL      prclSrc;    // source rectangle
    PPOINTL     pptlSrcOrg; // brush origin start
    } SDINFO, *PSDINFO;



//
// Function prototypes
//

BOOL
CloneBitBltSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMask,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PRECTL      prclMask,
    BRUSHOBJ    *pbo,
    PCLONESO    pCloneSO,
    DWORD       RopBG,
    DWORD       RopFG
    );

BOOL
DoSpecialRop3(
    SURFOBJ *psoDst,
    CLIPOBJ *pco,
    PRECTL  prclDst,
    DWORD   Rop3
    );

BOOL
DoMix2(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlSrcOrg,
    DWORD       Mix2
    );

BOOL
DoRop3(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoPat,
    SURFOBJ     *psoTmp,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PRECTL      prclPat,
    PPOINTL     pptlPatOrg,
    BRUSHOBJ    *pbo,
    DWORD       Rop3
    );


#endif  // _ROPBLT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\textout.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    textout.c


Abstract:

    This module contains the DrvTextOut entry point. This is the main routine
    called by the NT graphics engine in order to get text rendered on the
    target device. This implementation handles both drawing device paths that
    represent the glyphs of the STROBJ (the line of text to output), as well
    as outputing bitmaps that represent the glyphs on devices that can
    handle raster output.

Author:

    Written by AP on 8/17/92.

    15-Nov-1993 Mon 19:43:58 updated  
        clean up / fixed / add debugging information


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgTextOut

#define DBG_GETGLYPHMODE    0x00000001
#define DBG_TEXTOUT         0x00000002
#define DBG_TEXTOUT1        0x00000004
#define DBG_TEXTOUT2        0x00000008
#define DBG_DRAWLINE        0x00000010
#define DBG_TRUETYPE        0x00000020
#define DBG_TRUETYPE1       0x00000040
#define DBG_TRUETYPE2       0x00000080
#define DBG_BMPFONT         0x00000100
#define DBG_BMPTEXTCLR      0x00000200
#define DBG_DEFCHARINC      0x00000400
#define DBG_SET_FONTTYPE    0x20000000
#define DBG_SHOWRASFONT     0x40000000
#define DBG_NO_RASTER_FONT  0x80000000

DEFINE_DBGVAR(0);


extern PALENTRY HTPal[];




DWORD
DrvGetGlyphMode(
    DHPDEV  dhpdev,
    FONTOBJ *pfo
    )

/*++

Routine Description:

    Asks the driver what sort of font information should be cached for a
    particular font. For remote printer devices, this determines the format
    that gets spooled.  For local devices, this determines what GDI stores in
    its font cache.  This call will be made for each particular font
    realization.

Arguments:

    dhpdev  - Pointer to our PDEV

    pfo     - Pointer to the font object

Return Value:

    DWORD as FO_xxxx


Author:

    27-Jan-1994 Thu 12:51:59 created  

    10-Mar-1994 Thu 00:36:30 updated  
        Re-write, so we will pre-examine the Font type, source and its
        technology together with PDEV setting to let engine know which type of
        the font output we are interested in the DrvTextOut(). Currently this
        is broken in GDI which caused a GP in winsrv. (this is why a
        DBG_SET_FONTTYPE switch is on by default)


Revision History:


--*/

{
#define pPDev   ((PPDEV)dhpdev)

    PIFIMETRICS pifi;
    DWORD       FOType;


    PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Type=%08lx, cxMax=%ld",
                        pfo->flFontType, pfo->cxMax));

    //
    // If we cannot get the IFI metrics for the passed FONTOBJ, only
    // ask for PATHS.
    //

    if (!(pifi = FONTOBJ_pifi(pfo))) {

        PLOTERR(("DrvGetGlyphMode: FONTOBJ_pifi()=NULL, return FO_PATHOBJ"));

        return(FO_PATHOBJ);
    }

    FOType = FO_PATHOBJ;

    //
    // If its a bitmap font, ask for BITS
    //

    if (pifi->flInfo & FM_INFO_TECH_BITMAP) {

        PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: BITMAP FONT, return FO_GLYPHBITS"));

        FOType = FO_GLYPHBITS;

    } else if (pifi->flInfo & FM_INFO_TECH_STROKE) {

        PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: STROKE (Vector) FONT, return FO_PATHOBJ"));

    } else if (pifi->flInfo & FM_INFO_RETURNS_BITMAPS) {

        //
        // Now make a decision on whether to ask for glyphbits or paths.
        // This decision is based on the target device being raster, that
        // bitmap fonts are okay to use, and that the threshold for doing
        // raster fonts versus paths is met.
        //

        DWORD   cxBMFontMax = (DWORD)pPDev->pPlotGPC->RasterXDPI;

        if (pPDev->PlotDM.dm.dmPrintQuality == DMRES_HIGH) {

            cxBMFontMax <<= 3;

        } else {

            cxBMFontMax >>= 2;
        }

        PLOTDBG(DBG_GETGLYPHMODE,
                ("DrvGetGlyphMode: Font CAN return BITMAP, cxBMFontMax=%ld",
                                                    cxBMFontMax));

#if DBG
        if ((!(DBG_PLOTFILENAME & DBG_NO_RASTER_FONT))  &&
            (IS_RASTER(pPDev))                          &&
            (!NO_BMP_FONT(pPDev))                       &&
            (pfo->cxMax <= cxBMFontMax)) {
#else
        if ((IS_RASTER(pPDev))      &&
            (!NO_BMP_FONT(pPDev))   &&
            (pfo->cxMax <= cxBMFontMax)) {
#endif
            PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Convert to BITMAP FONT, FO_GLYPHBITS"));

            FOType = FO_GLYPHBITS;

        } else {

            PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Return as FO_PATHOBJ"));
        }

    } else if (pifi->flInfo & FM_INFO_RETURNS_OUTLINES) {

        PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Font CAN return OUTLINES"));

    } else if (pifi->flInfo & FM_INFO_RETURNS_STROKES) {

        PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Font CAN return STROKES"));
    }

#if DBG
    if (DBG_PLOTFILENAME & DBG_SET_FONTTYPE) {

        if ((FOType == FO_GLYPHBITS) &&
            (!(pfo->flFontType & FO_TYPE_RASTER))) {

            PLOTWARN(("DrvGetGlyphMode: Set FontType to RASTER"));

            pfo->flFontType &= ~(FO_TYPE_TRUETYPE | FO_TYPE_DEVICE);
            pfo->flFontType |= FO_TYPE_RASTER;
        }
    }
#endif
    return(FOType);

#undef pPDev
}




BOOL
BitmapTextOut(
    PPDEV       pPDev,
    STROBJ      *pstro,
    FONTOBJ     *pfo,
    PRECTL      pClipRect,
    LPDWORD     pOHTFlags,
    DWORD       Rop3
    )

/*++

Routine Description:

    This routine outputs the passed STROBJ with bitmaps that represent
    each of the glyphs, rather than converting the glyphs to paths that
    will be filled in the target device.

Arguments:

    pPDev           - Pointer to our PDEV

    pstro           - We pass a string object to be drawn

    pfo             - Pointer to the FONTOBJ

    pClipRect       - Current enumerated clipping rectangle

    pOHTFlags       - Pointer to the current OutputHTBitmap() flags

    Rop3            - Rop3 to be used in the device


Return Value:

    TRUE/FALSE


Author:

    18-Feb-1994 Fri 12:41:57 updated  
        change that so if pfo=NULL then the font already in BITMAP format

    14-Feb-1994 Mon 18:16:25 create  

Revision History:


--*/

{
    GLYPHPOS    *pgp;
    GLYPHBITS   *pgb;
    SURFOBJ     soGlyph;
    POINTL      ptlCur;
    SIZEL       sizlInc;
    RECTL       rclSrc;
    RECTL       rclDst;
    BOOL        MoreGlyphs;
    BOOL        Ok;
    BOOL        FirstCh;
    ULONG       cGlyphs;


    //
    // The public fields of SURFOBJ is what will be used by OutputHTBitmap
    // instead of actually creating a SURFOBJ from the graphics engine. This
    // is a safe thing to do, since only we look at these fields.
    //

    ZeroMemory(&soGlyph, sizeof(SURFOBJ));

    soGlyph.dhsurf        = (DHSURF)'PLOT';
    soGlyph.hsurf         = (HSURF)'TEXT';
    soGlyph.dhpdev        = (DHPDEV)pPDev;
    soGlyph.iBitmapFormat = BMF_1BPP;
    soGlyph.iType         = STYPE_BITMAP;
    soGlyph.fjBitmap      = BMF_TOPDOWN;

    //
    // We will now enumerate each of the glyphs in the STROBJ such that
    // we can image them. If the STROBJ has a non NULL pgp field, this means
    // that the GLYPH definitions are already available, and no enumeration
    // is required. If not, we will make a sequence of calls to STROBJ_bEnum
    // (an engine helper) to enumerate the glyphs. The actual imaging code
    // is the same, regardless of the stat of STROBJ->pgp
    //

    if (pstro->pgp) {

        pgp        = pstro->pgp;
        MoreGlyphs = FALSE;
        cGlyphs    = pstro->cGlyphs;

        PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: Character info already there (%ld glyphs)", cGlyphs));

    } else {

        STROBJ_vEnumStart(pstro);
        MoreGlyphs = TRUE;

        PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: STROBJ enub"));
    }

    //
    // Now straring drawing the glyphs, if we have MoreGlyphs = TRUE  then we
    // will initially do a STROBJ_bEnum first to initialize enumeration of
    // the glyphs
    //

    Ok          = TRUE;
    Rop3       &= 0xFF;
    sizlInc.cx  =
    sizlInc.cy  = 0;
    FirstCh     = TRUE;

    do {

        //
        // Verify the job is not aborting, if it is break out now.
        //

        if (PLOT_CANCEL_JOB(pPDev)) {

           break;
        }


        //
        // Check to see if we need to do an enumeration and start it if
        // it is required.
        //

        if (MoreGlyphs) {

            MoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);

            if (MoreGlyphs == DDI_ERROR) {

                PLOTERR(("DrvTextOut: STROBJ_bEnum()=DDI_ERROR"));
                return(FALSE);
            }
        }

        PLOTDBG(DBG_BMPFONT,
                ("BitmapTextOut: New batch of cGlyphs=%d", cGlyphs));

        //
        // Get the first character position
        //

        if ((FirstCh) && (cGlyphs)) {

            ptlCur  = pgp->ptl;
            FirstCh = FALSE;
        }

        //
        // Start sending each bitmap to the device
        //

        for ( ; (Ok) && (cGlyphs--); pgp++) {

            GLYPHDATA   gd;
            GLYPHDATA   *pgd;


            if (PLOT_CANCEL_JOB(pPDev)) {

                break;
            }

            if (pfo) {

                //
                // This is true type font, so query the bitmap
                //

                pgd = &gd;

                if (FONTOBJ_cGetGlyphs(pfo,
                                       FO_GLYPHBITS,
                                       1,
                                       &(pgp->hg),
                                       (LPVOID)&pgd) != 1) {

                    PLOTERR(("BitmapTextOut: FONTOBJ_cGetGlyphs() FAILED"));
                    return(FALSE);
                }

                pgb = pgd->gdf.pgb;

            } else {

                //
                // For bitmap font, we already have the bitmap
                //

                pgb = pgp->pgdf->pgb;
            }

            //
            // Get the size of the bitmap
            //

            soGlyph.sizlBitmap = pgb->sizlBitmap;

            //
            // Compute new destination position for the text, based on the
            // passed accelerators.
            //

            if (pstro->ulCharInc) {

                sizlInc.cx =
                sizlInc.cy = (LONG)pstro->ulCharInc;

            } else if (pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) {

                sizlInc = soGlyph.sizlBitmap;

            } else {

                ptlCur = pgp->ptl;
            }

            if (!(pstro->flAccel & SO_HORIZONTAL)) {

                sizlInc.cx = 0;
            }

            if (!(pstro->flAccel & SO_VERTICAL)) {

                sizlInc.cy = 0;
            }

            if (pstro->flAccel & SO_REVERSED) {

                sizlInc.cx = -sizlInc.cx;
                sizlInc.cy = -sizlInc.cy;
            }


            //
            // The pgp->ptl informs us where to position the glyph origin in
            // the device surface, and pgb->ptlOrigin informs us of the
            // relationship between character origin and bitmap origin. For
            // example, if (2,-24) is passed in as the character origin, then
            // we would need to reposition rclDst.left right 2 pixels and
            // rclDst.top up 24 pixels.
            //

            rclDst.left    = ptlCur.x + pgb->ptlOrigin.x;
            rclDst.top     = ptlCur.y + pgb->ptlOrigin.y;
            rclDst.right   = rclDst.left + soGlyph.sizlBitmap.cx;
            rclDst.bottom  = rclDst.top + soGlyph.sizlBitmap.cy;
            ptlCur.x      += sizlInc.cx;
            ptlCur.y      += sizlInc.cy;


            //
            // NOTE: If the bitmap size is 1x1 and the value of the glyphdata
            //       is 0 (background only) then we skip this glyph. This is
            //       GDI's way of telling us we have an empty glyph (like a
            //       space).

            if ((soGlyph.sizlBitmap.cx == 1) &&
                (soGlyph.sizlBitmap.cy == 1) &&
                ((pgb->aj[0] & 0x80) == 0x0)) {

                PLOTDBG(DBG_BMPFONT,
                        ("BitmapTextOut: Getting (1x1)=0 bitmap, SKIP it"));

                soGlyph.sizlBitmap.cx =
                soGlyph.sizlBitmap.cy = 0;

            } else {

                rclSrc = rclDst;

                PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: pgp=%08lx, pgb=%08lx, ptl=(%ld, %ld) Inc=(%ld, %ld)",
                                            pgp, pgb, pgp->ptl.x, pgp->ptl.y,
                                            sizlInc.cx, sizlInc.cy));
                PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: Bmp=%ld x %ld, pgb->ptlOrigin=[%ld, %ld]",
                                            soGlyph.sizlBitmap.cx,
                                            soGlyph.sizlBitmap.cy,
                                            pgb->ptlOrigin.x, pgb->ptlOrigin.y));
                PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: rclDst=(%ld, %ld)-(%ld, %ld)",
                        rclDst.left, rclDst.top, rclDst.right, rclDst.bottom));

            }

            //
            // Now verify that we have a glyph to send, and that the glyphs
            // destination position in the target device, lies inside
            // the clipping region.
            //


            if ((soGlyph.sizlBitmap.cx)                 &&
                (soGlyph.sizlBitmap.cy)                 &&
                (IntersectRECTL(&rclDst, pClipRect))) {

                //
                // We will pass the internal version of soGlyph without making
                // a temp. copy.
                //

                soGlyph.pvBits  =
                soGlyph.pvScan0 = (LPVOID)pgb->aj;
                soGlyph.lDelta  = (LONG)((soGlyph.sizlBitmap.cx + 7) >> 3);
                soGlyph.cjBits  = (LONG)(soGlyph.lDelta *
                                         soGlyph.sizlBitmap.cy);
                rclSrc.left     = rclDst.left - rclSrc.left;
                rclSrc.top      = rclDst.top - rclSrc.top;
                rclSrc.right    = rclSrc.left + (rclDst.right - rclDst.left);
                rclSrc.bottom   = rclSrc.top + (rclDst.bottom - rclDst.top);

                PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: rclSrc=(%ld, %ld)-(%ld, %ld)",
                        rclSrc.left, rclSrc.top, rclSrc.right, rclSrc.bottom));

#if DBG
                if (DBG_PLOTFILENAME & DBG_SHOWRASFONT) {

                    LPBYTE  pbSrc;
                    LPBYTE  pbCur;
                    UINT    x;
                    UINT    y;
                    UINT    Size;
                    BYTE    bData;
                    BYTE    Mask;
                    BYTE    Buf[128];

                    DBGP(("================================================="));
                    DBGP(("BitmapTextOut: Size=%ld x %ld, Origin=(%ld, %ld), Clip=(%ld, %ld)-(%ld, %ld)",
                            soGlyph.sizlBitmap.cx, soGlyph.sizlBitmap.cy,
                            pgb->ptlOrigin.x, pgb->ptlOrigin.y,
                            rclSrc.left, rclSrc.top,
                            rclSrc.right, rclSrc.bottom));

                    pbSrc = soGlyph.pvScan0;

                    for (y = 0; y < (UINT)soGlyph.sizlBitmap.cy; y++) {

                        pbCur  = pbSrc;
                        pbSrc += soGlyph.lDelta;
                        Mask   = 0x0;
                        Size   = 0;

                        for (x = 0;
                             x < (UINT)soGlyph.sizlBitmap.cx && Size < sizeof(Buf);
                             x++)
                        {

                            if (!(Mask >>= 1)) {

                                Mask  = 0x80;
                                bData = *pbCur++;
                            }

                            if ((y >= (UINT)rclSrc.top)     &&
                                (y <  (UINT)rclSrc.bottom)  &&
                                (x >= (UINT)rclSrc.left)    &&
                                (x <  (UINT)rclSrc.right)) {

                                Buf[Size++] = (BYTE)((bData & Mask) ? 219 :
                                                                      177);

                            } else {

                                Buf[Size++] = (BYTE)((bData & Mask) ? 178 :
                                                                      176);
                            }
                        }

                        if (Size < sizeof(Buf))
                        {
                            Buf[Size] = '\0';
                        }
                        else
                        {
                            Buf[sizeof(Buf) - 1] = '\0';
                        }

                        DBGP((Buf));
                    }
                }
#endif
                //
                // Now output the bitmap that represents the glyph
                //

                Ok = OutputHTBitmap(pPDev,              // pPDev
                                    &soGlyph,           // psoHT
                                    NULL,               // pco
                                    (PPOINTL)&rclDst,   // pptlDst
                                    &rclSrc,            // prclSrc
                                    Rop3,               // Rop3
                                    pOHTFlags);         // pOHTFlags
            }
        }

    } while ((Ok) && (MoreGlyphs));

    return(Ok);
}




BOOL
OutlineTextOut(
    PPDEV       pPDev,
    STROBJ      *pstro,
    FONTOBJ     *pfo,
    PRECTL      pClipRect,
    BRUSHOBJ    *pboBrush,
    POINTL      *pptlBrushOrg,
    DWORD       OutlineFlags,
    ROP4        Rop4
    )

/*++

Routine Description:


    This routine outputs the passed STROBJ by outputing a path that
    represents each glyph to the target device.

Arguments:

    pPDev           - Pointer to our PDEV

    pstro           - We pass a string object to be drawn

    pfo             - Pointer to the FONTOBJ

    pClipRect       - Current enumerated clipping rectangle

    pboBrush        - Brush object to be used for the text

    pptlBrushOrg    - Brush origin alignment

    OutlineFlags    - specified how to do outline font from FPOLY_xxxx flags

    Rop4            - Rop4 to be used


Return Value:

    TRUE/FALSE


Author:

    18-Feb-1994 Fri 12:41:17 updated  
        Adding the OutlineFlags to specified how to do fill/stroke

    27-Jan-1994 Thu 13:10:34 updated  
        re-write, style update, and arrange codes

    25-Jan-1994 Wed 16:30:08 modified 
        Added FONTOBJ as a parameter and now we only FILL truetype fonts,
        all others are stroked

    18-Dec-1993 Sat 10:38:08 created  
        Change style

    [t-kenl]  Mar 14, 93    taken from DrvTextOut()

Revision History:


--*/

{
    GLYPHPOS    *pgp;
    PATHOBJ     *ppo;
    RECTFX      rectfxBound;
    RECTFX      rclfxClip;
    POINTL      ptlCur;
    SIZEL       sizlInc;
    BOOL        MoreGlyphs;
    BOOL        Ok;
    BOOL        FirstCh;
    ULONG       cGlyphs;

    //
    // We will enumerate each of the glyphs in the passed STROBJ and use
    // the core polygon routine (DoPolygon) to draw each of them as a path.
    // If the STROBJ has a non NULL pgp field, then all the data is already
    // available on each gpyph. If not, we need to make a sequence of calls
    // to the engine helper function STROBJ_bEnum in order to enumerate the
    // glyphs. We will use the same code to output the data in both cases.
    //

    if (pClipRect) {

        rclfxClip.xLeft   = LTOFX(pClipRect->left);
        rclfxClip.yTop    = LTOFX(pClipRect->top);
        rclfxClip.xRight  = LTOFX(pClipRect->right);
        rclfxClip.yBottom = LTOFX(pClipRect->bottom);
    }

    if (pstro->pgp) {

        pgp        = pstro->pgp;
        MoreGlyphs = FALSE;
        cGlyphs    = pstro->cGlyphs;

        PLOTDBG(DBG_TRUETYPE, ("OutlineTextOut: Character info already there (%ld glyphs)", cGlyphs));

    } else {

        STROBJ_vEnumStart(pstro);
        MoreGlyphs = TRUE;

        PLOTDBG(DBG_TRUETYPE, ("OutlineTextOut: STROBJ enub"));
    }

    //
    // Now start drawing the glyphs, if we have MoreGlyphs = TRUE  then we
    // will do a STROBJ_bEnum first, in order to load up the Glyph data.
    //
    // Check the fill flags and set the flag appropriately out of the DEVMODE.
    // We will ONLY fill TrueType fonts, all other types (vector) will only be
    // stroked.
    //

    Ok         = TRUE;
    sizlInc.cx =
    sizlInc.cy = 0;
    FirstCh    = TRUE;

    do {

        //
        // Check to see if the job is being aborted, and exit out if such
        // is the case.
        //

        if (PLOT_CANCEL_JOB(pPDev)) {

           break;
        }

        //
        // We need to enum for more glyph data so do it now.
        //

        if (MoreGlyphs) {

            MoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);

            if (MoreGlyphs == DDI_ERROR) {

                PLOTERR(("DrvTextOut: STROBJ_bEnum()=DDI_ERROR"));
                return(FALSE);
            }
        }

        PLOTDBG(DBG_TRUETYPE1,
                ("OutlineTextOut: New batch of cGlyphs=%d", cGlyphs));

        //
        // Stroke each glyph in this batch, then check if there are more.
        // Getting the first character position
        //

        if ((FirstCh) && (cGlyphs)) {

            ptlCur  = pgp->ptl;
            FirstCh = FALSE;
        }

        for ( ; (Ok) && (cGlyphs--); pgp++) {

            #ifdef USERMODE_DRIVER

            GLYPHDATA   gd;
            GLYPHDATA   *pgd;

            #endif // USERMODE_DRIVER

            if (PLOT_CANCEL_JOB(pPDev)) {

                break;
            }

            //
            // Set up to enumerate path
            //

            #ifdef USERMODE_DRIVER

                pgd = &gd;

                if (FONTOBJ_cGetGlyphs(pfo,
                                       FO_PATHOBJ,
                                       1,
                                       &(pgp->hg),
                                       (LPVOID)&pgd) != 1) {

                    PLOTRIP(("OutlineTextOut: FONTOBJ_cGetGlyphs() FAILED"));
                    return(FALSE);
                }

                ppo = pgd->gdf.ppo;

            #else

            ppo = pgp->pgdf->ppo;

            #endif // USERMODE_DRIVER

            //
            // If the clip rect is not null then verify the glyph actually lies
            // within the clipping rect then OUTPUT!!!
            //

            if (pstro->ulCharInc) {

                PLOTDBG(DBG_DEFCHARINC, ("OutlineTextOut: CharInc=(%ld, %ld)->(%ld, %ld), [%ld]",
                                ptlCur.x, ptlCur.y,
                                ptlCur.x + pstro->ulCharInc, ptlCur.y,
                                pstro->ulCharInc));

                sizlInc.cx =
                sizlInc.cy = (LONG)pstro->ulCharInc;


                //
                // Check the text Accelators and adjust accordingly.
                //

                if (!(pstro->flAccel & SO_HORIZONTAL)) {

                    sizlInc.cx = 0;
                }

                if (!(pstro->flAccel & SO_VERTICAL)) {

                    sizlInc.cy = 0;
                }

                if (pstro->flAccel & SO_REVERSED) {

                    sizlInc.cx = -sizlInc.cx;
                    sizlInc.cy = -sizlInc.cy;
                }

                ptlCur.x += sizlInc.cx;
                ptlCur.y += sizlInc.cy;

            } else {

                ptlCur = pgp->ptl;
            }

            if (pClipRect) {

                //
                // Create a rect in correct device space and compare to the
                // clip rect
                //

                PATHOBJ_vGetBounds(ppo, &rectfxBound);

                //
                // Since the glyph positioning is based on the glyph origin
                // transform now to device space, in order to check if the
                // glyph lies inside the current clipping region.
                //

                rectfxBound.xLeft   += LTOFX(ptlCur.x);
                rectfxBound.yTop    += LTOFX(ptlCur.y);
                rectfxBound.xRight  += LTOFX(ptlCur.x);
                rectfxBound.yBottom += LTOFX(ptlCur.y);

                if ((rectfxBound.xLeft   > rclfxClip.xRight)    ||
                    (rectfxBound.xRight  < rclfxClip.xLeft)     ||
                    (rectfxBound.yTop    > rclfxClip.yBottom)   ||
                    (rectfxBound.yBottom < rclfxClip.yTop)) {

                    PLOTDBG(DBG_TRUETYPE1, ("OutlineTextOut: Outside of CLIP, skipping glyph ..."));
                    continue;
                }
            }

            //
            // Utilize the core path building function, taking advantage of
            // its ability to offset the passed PATH by a specific amount.
            //

            if (!(Ok = DoPolygon(pPDev,
                                 &ptlCur,
                                 NULL,
                                 ppo,
                                 pptlBrushOrg,
                                 pboBrush,
                                 pboBrush,
                                 Rop4,
                                 NULL,
                                 OutlineFlags))) {

                PLOTERR(("OutlineTextOut: Failed in DoPolygon(Options=%08lx)",
                                                        OutlineFlags));

                //
                // If we failed to draw it, then try just stroking it, since
                // that won't depend on any polygon constraints used in the
                // target device, and failing DrvStrokePath, won't make the
                // Text output get broken down to any simpler format.
                //

                if ((OutlineFlags & FPOLY_MASK) != FPOLY_STROKE) {

                    //
                    // If we failed then just stroke it
                    //

                    PLOTERR(("OutlineTextOut: Now TRY DoPolygon(FPOLY_STROKE)"));

                    Ok = DoPolygon(pPDev,
                                   &ptlCur,
                                   NULL,
                                   ppo,
                                   pptlBrushOrg,
                                   NULL,
                                   pboBrush,
                                   Rop4,
                                   NULL,
                                   FPOLY_STROKE);
                }
            }

            //
            // Go to next position

            ptlCur.x += sizlInc.cx;
            ptlCur.y += sizlInc.cy;
        }

    } while ((Ok) && (MoreGlyphs));

    return(TRUE);
}





BOOL
DrvTextOut(
    SURFOBJ     *pso,
    STROBJ      *pstro,
    FONTOBJ     *pfo,
    CLIPOBJ     *pco,
    RECTL       *prclExtra,
    RECTL       *prclOpaque,
    BRUSHOBJ    *pboFore,
    BRUSHOBJ    *pboOpaque,
    POINTL      *pptlBrushOrg,
    MIX         mix
    )

/*++

Routine Description:

    The Graphics Engine will call this routine to render a set of glyphs at
    specified positions. This function will review the passed data, and
    image the glyph either as a path to be filled or stroked, or as a bitmap.

Arguments:

    pso         - pointer to our surface object

    pstro       - pointer to the string object

    pfo         - pointer to the font object

    pco         - clipping object

    prclExtra   - pointer to array of rectangles to be merge with glyphs

    prclOpaque  - Pointer to a rectangle to be fill with pboOpaque brush

    pboFore     - pointer to the brush object for the foreground color

    pboOpqaue   - pointer to the brush object for the opaque rectangle

    pptlBrushOrg- Pointer to the brush alignment

    mix         - Two Rop2 mode


Return Value:

    TRUE/FALSE


Author:

    23-Jan-1994 Thu  2:59:31 created  

    27-Jan-1994 Thu 12:56:11 updated  
        Style, re-write, commented

    10-Mar-1994 Thu 00:30:38 updated  
        1. Make sure we not fill the stroke type of font
        2. Move rclOpqaue and rclExtra process out from the do loop, so that
           when it in the RTL mode for the font it will be correctly processed
           and it will also save output data size by not switching in/out
           RTL/HPGL2 mode just try to do the prclOpaque/prclExtra
        3. Process FO_TYPE correctly for all type of fonts (outline, truetype,
           bitmap, vector, stroke and others)

    11-Mar-1994 Fri 19:24:56 updated  
        Bug# 10276, the clipping window is set for the raster font and clear
        clipping window is done before the exit to HPGL2 mode, this causes
        all raster font after the first clip is not visible to end of the
        page.   Now changed it so we only do clipping window when the font is
        NOT RASTER.

Revision History:


--*/

{
#define pDrvHTInfo  ((PDRVHTINFO)(pPDev->pvDrvHTData))


    PPDEV       pPDev;
    PRECTL      pCurClipRect;
    HTENUMRCL   EnumRects;
    DWORD       RTLPalDW[2];
    DWORD       rgbText;
    DWORD       OHTFlags;
    DWORD       OutlineFlags;
    BOOL        DoRasterFont;
    BOOL        bMore;
    BOOL        bDoClipWindow;
    BOOL        Ok;
    DWORD       BMFontRop3;
    ROP4        Rop4;


    //
    // Transform the MIX to ROP4
    //

    Rop4 = MixToRop4(mix);

    PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: prclOpaque       = %08lx", prclOpaque));
    PLOTDBG(DBG_TEXTOUT, ("            prclExtra        = %08lx", prclExtra));
    PLOTDBG(DBG_TEXTOUT, ("            pstro->flAccel   = %08lx", pstro->flAccel));
    PLOTDBG(DBG_TEXTOUT, ("            pstro->ulCharInc = %ld", pstro->ulCharInc));
    PLOTDBG(DBG_TEXTOUT, ("            pfo->cxMax       = %ld", pfo->cxMax));
    PLOTDBG(DBG_TEXTOUT, ("            FontType         = %08lx", pfo->flFontType));
    PLOTDBG(DBG_TEXTOUT, ("            MIX              = %04lx (Rop=%04lx)", mix, Rop4));

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DoTextOut: Invalid pPDev in pso"));
        return(FALSE);
    }

    if (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) {

        PLOTWARN(("DoTextOut: POSTER Mode IGNORE All Texts"));
        return(TRUE);
    }

    //
    // Since we dont support device fonts, make sure we are not getting one
    // now.
    //

    if (pfo->flFontType & FO_TYPE_DEVICE) {

        PLOTASSERT(1, "DrvTextOut: Getting DEVICE font (%08lx)",
                        !(pfo->flFontType & FO_TYPE_DEVICE ), pfo->flFontType);
        return(FALSE);
    }

    if (DoRasterFont = (BOOL)(pfo->flFontType & FO_TYPE_RASTER)) {

        PLOTDBG(DBG_TEXTOUT1, ("DrvTextOut: We got the BITMAP Font from GDI"));

        //
        // Make pfo = NULL so later we will not try to do FONTOBJ_cGetGlyph in
        // BitmapTextOut
        //

        #ifndef USERMODE_DRIVER

        pfo = NULL;

        #endif // !USERMODE_DRIVER

    } else {

        PIFIMETRICS pifi;

        //
        // Try to find out if we need to fill the font, or just stroke it.
        //

        if ((pifi = FONTOBJ_pifi(pfo)) &&
            (pifi->flInfo & FM_INFO_RETURNS_STROKES)) {

            PLOTDBG(DBG_TEXTOUT1, ("DrvTextOut() Font can only do STROKE"));

            OutlineFlags = FPOLY_STROKE;

        } else {

            PLOTDBG(DBG_TEXTOUT1, ("DrvTextOut() Font We can do FILL, User Said=%hs",
                    (pPDev->PlotDM.Flags & PDMF_FILL_TRUETYPE) ? "FILL" : "STROKE"));

            OutlineFlags = (pPDev->PlotDM.Flags & PDMF_FILL_TRUETYPE) ?
                                (DWORD)FPOLY_FILL : (DWORD)FPOLY_STROKE;
        }
    }

    //
    // Check if we need to opaque the area
    //

    if (prclOpaque) {

        PLOTDBG(DBG_TEXTOUT2, ("prclOpaque=(%ld, %ld) - (%ld, %ld)",
                           prclOpaque->left, prclOpaque->top,
                           prclOpaque->right, prclOpaque->bottom));

        if (!DrvBitBlt(pso,             // Target
                       NULL,            // Source
                       NULL,            // Mask Obj
                       pco,             // Clip Obj
                       NULL,            // XlateOBj
                       prclOpaque,      // Dest Rect Ptr
                       NULL,            // Source Pointl
                       NULL,            // Mask Pointl
                       pboOpaque,       // Brush Obj
                       pptlBrushOrg,    // Brush Origin
                       0xF0F0)) {       // ROP4 (PATCOPY)

            PLOTERR(("DrvTextOut: DrvBitBltBit(pboOpqaue) FAILED!"));
            return(FALSE);
        }
    }

    //
    // We will do prclExtra only if it is not NULL, this simulates the
    // underline or strikeout effects.
    //

    if (prclExtra) {

        //
        // The prclExtra terminated only if all points in rectangle coordinate
        // are all set to zeros
        //

        while ((prclExtra->left)    ||
               (prclExtra->top)     ||
               (prclExtra->right)   ||
               (prclExtra->bottom)) {

            PLOTDBG(DBG_TEXTOUT2, ("prclExtra=(%ld, %ld) - (%ld, %ld)",
                               prclExtra->left, prclExtra->top,
                               prclExtra->right, prclExtra->bottom));

            if (!DrvBitBlt(pso,             // Target
                           NULL,            // Source
                           NULL,            // Mask Obj
                           pco,             // Clip Obj
                           NULL,            // XlateOBj
                           prclExtra,       // Dest Rect Ptr
                           NULL,            // Source Pointl
                           NULL,            // Mask Pointl
                           pboFore,         // Brush Obj
                           pptlBrushOrg,    // Brush Origin
                           Rop4)) {         // ROP4

                PLOTERR(("DrvTextOut: DrvBitBltBit(pboFore) FAILED!"));
                return(FALSE);
            }

            //
            // Now try next EXTRA rectangle
            //

            ++prclExtra;
        }
    }

    //
    // If we are using Raster Font then the mode will be set as following
    //

    if (DoRasterFont) {

        RTLPalDW[0] = pDrvHTInfo->RTLPal[0].dw;
        RTLPalDW[1] = pDrvHTInfo->RTLPal[1].dw;

        //
        // Get the color to use.
        //

        if (!GetColor(pPDev,
                      pboFore,
                      &(pDrvHTInfo->RTLPal[1].dw),
                      NULL,
                      Rop4)) {

            PLOTERR(("DrvTextOut: Get Raster Font Text Color failed! use BLACK"));

            rgbText = 0x0;
        }

        if (pDrvHTInfo->RTLPal[1].dw == 0xFFFFFF) {

            //
            // White Text, our white is 1 and 0=black, so do:"not S and D"
            //

            PLOTDBG(DBG_BMPTEXTCLR, ("DrvTextOut: Doing WHITE TEXT (0xEEEE)"));

            pDrvHTInfo->RTLPal[0].dw = 0x0;
            OHTFlags                 = 0;
            BMFontRop3               = 0xEE;                // S | D

        } else {

            pDrvHTInfo->RTLPal[0].dw = 0xFFFFFF;
            OHTFlags                 = OHTF_SET_TR1;
            BMFontRop3               = 0xCC;                // S
        }

        PLOTDBG(DBG_BMPTEXTCLR,
                ("DrvTextOut: BG=%02x:%02x:%02x, FG=%02x:%02x:%02x, Rop3=%04lx",
                        (DWORD)pDrvHTInfo->RTLPal[0].Pal.R,
                        (DWORD)pDrvHTInfo->RTLPal[0].Pal.G,
                        (DWORD)pDrvHTInfo->RTLPal[0].Pal.B,
                        (DWORD)pDrvHTInfo->RTLPal[1].Pal.R,
                        (DWORD)pDrvHTInfo->RTLPal[1].Pal.G,
                        (DWORD)pDrvHTInfo->RTLPal[1].Pal.B,
                        BMFontRop3));

        //
        // We do not need clip window command in RTL mode
        //

        bDoClipWindow = FALSE;

    } else {

        bDoClipWindow = TRUE;
    }

    bMore       = FALSE;
    Ok          = TRUE;
    EnumRects.c = 1;

    if ((!pco) || (pco->iDComplexity == DC_TRIVIAL)) {

        //
        // The whole output destination rectangle is visible
        //

        PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: pco=%hs",
                                            (pco) ? "DC_TRIVIAL" : "NULL"));

        EnumRects.rcl[0] = pstro->rclBkGround;
        bDoClipWindow    = FALSE;

    } else if (pco->iDComplexity == DC_RECT) {

        //
        // The visible area is one rectangle intersect with the destinaiton
        //

        PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: pco=DC_RECT"));

        EnumRects.rcl[0] = pco->rclBounds;

    } else {

        //
        // We have complex clipping region to be computed, call engine to start
        // enumerating the rectangles and set More = TRUE so we can get the
        // first batch of rectangles.
        //

        PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: pco=DC_COMPLEX, EnumRects now"));

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        bMore = TRUE;
    }

    do {

        //
        // If More is true then we need to get next batch of rectangles. In
        // this mode, we have a set of rectangles that represents the
        // clipping region in the target device. Since none of the devices
        // we handle can acommodate a complex clipping path, we enumerate the
        // cliping path (CLIPOBJ) as rectangles and image the entire STROBJ
        // through these rectangles, trying to determine as quickly as possible
        // when a glyph does not lie in the current clipping rect.
        //

        if (bMore) {

            bMore = CLIPOBJ_bEnum(pco, sizeof(EnumRects), (ULONG *)&EnumRects);
        }

        //
        // prcl will point to the first enumerated rectangle, which may just
        // be the RECT of the clipping area if its DC_RECT.
        //

        pCurClipRect = (PRECTL)&EnumRects.rcl[0];

        while ((Ok) && bMore != DDI_ERROR && (EnumRects.c--)) {

            PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: Clip=(%ld, %ld)-(%ld, %ld) %ld x %ld, Bound=(%ld, %d)-(%ld, %ld), %ld x %ld",
                         pCurClipRect->left, pCurClipRect->top,
                         pCurClipRect->right, pCurClipRect->bottom,
                         pCurClipRect->right - pCurClipRect->left,
                         pCurClipRect->bottom - pCurClipRect->top,
                         pstro->rclBkGround.left, pstro->rclBkGround.top,
                         pstro->rclBkGround.right, pstro->rclBkGround.bottom,
                         pstro->rclBkGround.right - pstro->rclBkGround.left,
                         pstro->rclBkGround.bottom - pstro->rclBkGround.top));

            //
            // If we will output the STROBJ as bitmaps that represent the
            // glyphs of the STROBJ, do it now.
            //

            if (DoRasterFont) {

                if (!(Ok = BitmapTextOut(pPDev,
                                         pstro,
                                         pfo,
                                         pCurClipRect,
                                         &OHTFlags,
                                         BMFontRop3))) {

                    PLOTERR(("DrvTextOut: BitmapTypeTextOut() FAILED"));
                    break;
                }

            } else {

                //
                // If we have a clip window, set it now, this will allow
                // the target device to do any clipping
                //

                if (bDoClipWindow) {

                    SetClipWindow(pPDev, pCurClipRect);
                }

                if (!(Ok = OutlineTextOut(pPDev,
                                          pstro,
                                          pfo,
                                          pCurClipRect,
                                          pboFore,
                                          pptlBrushOrg,
                                          OutlineFlags,
                                          Rop4))) {

                    PLOTERR(("DrvTextOut: TrueTypeTextOut() FAILED!"));
                    break;
                }
            }

            //
            // Goto next clip rectangle
            //

            pCurClipRect++;
        }

    } while ((Ok) && (bMore == TRUE));


    if (DoRasterFont) {

        pDrvHTInfo->RTLPal[0].dw = RTLPalDW[0];
        pDrvHTInfo->RTLPal[1].dw = RTLPalDW[1];

        if (OHTFlags & OHTF_MASK) {

            OHTFlags |= OHTF_EXIT_TO_HPGL2;

            OutputHTBitmap(pPDev, NULL, NULL, NULL, NULL, 0xAA, &OHTFlags);
        }
    }

    //
    // If we had set a clip window now is the time to clear it after exit from
    // RTL Mode
    //

    if (bDoClipWindow) {

        ClearClipWindow(pPDev);
    }

    return(Ok);


#undef  pDrvHTInfo
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\textout.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    textout.h


Abstract:

    This module contains all #defines and prototypes for the textout.c module.


Author:

    18-Nov-1993 Thu 05:18:40 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTTEXTOUT_
#define _PLOTTEXTOUT_







#endif  // _PLOTTEXTOUT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\transpos.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    transpos.h


Abstract:

    This module contains defines and prototypes for the transpos.c module.


Author:

    22-Dec-1993 Wed 15:49:08 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



#ifndef _TRANSPOS_
#define _TRANSPOS_


typedef struct _TPINFO {
    PPDEV   pPDev;
    LPBYTE  pSrc;
    LPBYTE  pDest;
    LONG    cbSrcScan;
    LONG    cbDestScan;
    DWORD   cySrc;
    DWORD   DestXStart;
    } TPINFO, *PTPINFO;


#define _RL_TPI(pTPInfo, cScan)                                         \
{                                                                       \
    pTPInfo->pDest      += (pTPInfo->cbDestScan * cScan)                \
    pTPInfo->cbDestScan  = -pTBInfo->cbDestScan;                        \
    pTPInfo->pSrc       += (pTPInfo->cbSrcScan * (pTPInfo->cySrc - 1)); \
    pTPInfo->cbSrcScan   = -pTBInfo->cbSrcScan;                         \
}


//
// Function prototypes exported by transpos.c
//

BOOL
TransPos4BPP(
    PTPINFO pTPInfo
    );

BOOL
TransPos1BPP(
    PTPINFO pTPInfo
    );



#endif  // _TRANSPOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\transpos.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    transpos.c


Abstract:

    This module implements the functions for transposing an 8BPP, 4BPP and
    1BPP bitmap. There is also a helper function for building a table which
    speeds some of the rotation logic.

Author:

    22-Dec-1993 Wed 13:09:11 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgTransPos

#define DBG_BUILD_TP8x8     0x00000001
#define DBG_TP_1BPP         0x00000002
#define DBG_TP_4BPP         0x00000004

DEFINE_DBGVAR(0);



//
// Private #defines and data structures for use only in this module.
//

#define ENTRY_TP8x8         256
#define SIZE_TP8x8          (sizeof(DWORD) * 2 * ENTRY_TP8x8)



LPDWORD
Build8x8TransPosTable(
    VOID
    )

/*++

Routine Description:

    This function build the 8x8 transpos table for use later in transposing
    1bpp.

Arguments:


Return Value:



Author:

    22-Dec-1993 Wed 14:19:50 created  


Revision History:


--*/

{
    LPDWORD pdwTP8x8;


    //
    // We now build the table which will represent the data for doing a
    // rotation. Basically for each combination of bits in the byte, we
    // build the equivalent 8 byte rotation for those bits. The 1st byte
    // of the translated bytes are mapped to the 0x01 bit of the source and
    // the last byte is mapped to the 0x80 bit.



    if (pdwTP8x8 = (LPDWORD)LocalAlloc(LPTR, SIZE_TP8x8)) {

        LPBYTE  pbData = (LPBYTE)pdwTP8x8;
        WORD    Entry;
        WORD    Bits;

        //
        // Now start buiding the table, for each entry we expand each bit
        // in the byte to the rotate byte value.
        //

        for (Entry = 0; Entry < ENTRY_TP8x8; Entry++) {

            //
            // For each of bit combinations in the byte, we will examine each
            // bit from bit 0 to bit 7, and set each of the trasposed bytes to
            // either 1 (bit set) or 0 (bit clear)
            //

            Bits = (WORD)Entry | (WORD)0xff00;

            while (Bits & 0x0100) {

                *pbData++   = (BYTE)(Bits & 0x01);
                Bits      >>= 1;
            }
        }

    } else {

        PLOTERR(("Build8x8TransPosTable: LocalAlloc(SIZE_TP8x8=%ld) failed",
                                                    SIZE_TP8x8));
    }

    return(pdwTP8x8);
}




BOOL
TransPos4BPP(
    PTPINFO pTPInfo
    )

/*++

Routine Description:

    This function rotates a 4bpp source to a 4bpp destination

Arguments:

    pTPINFO - Pointer to the TPINFO to describe how to do transpose, the fields
              must be set to following

        pPDev:      Pointer to the PDEV
        pSrc:       Pointer to the soruce bitmap starting point
        pDest       Pointer to the destination bitmap location which stores the
                    transpos result starting from the fist destination scan
                    line in the rotated direction (rotating right will have
                    low nibble source bytes as the first destination scan line)
        cbSrcScan:  Count to be added to advance to next source bitmap line
        cbDestScan: Count to be added to advance to the high nibble destination
                    bitmap line
        cySrc       Total source lines to be processed
        DestXStart: not used, Ignored


        NOTE: 1. The size of buffer area pointed to by pDestL must have at least
                 (((cySrc + 1) / 2) * 2) size in bytes, and ABS(DestDelta)
                 must at least half of that size.

              2. Unused last destination byte will be padded with 0

    Current transposition assumes the bitmap is rotated to the right, if caller
    wants to rotate the bitmap to the left then you must first call the macro
    ROTLEFT_4BPP_TPIINFO(pTPInfo)


Return Value:

    TRUE if sucessful, FALSE if failed.

    if sucessful the pTPInfo->pSrc will be automatically:

    1. Incremented by one (1) if cbDestScan is negative (Rotated left 90 degree)
    2. Decremented by one (1) if cbDestScan is positive (Rotated right 90 degree)

Author:

    22-Dec-1993 Wed 13:11:30 created  


Revision History:


--*/

{
    LPBYTE  pSrc;
    LPBYTE  pDest1st;
    LPBYTE  pDest2nd;
    LONG    cbSrcScan;
    DWORD   cySrc;
    BYTE    b0;
    BYTE    b1;


    PLOTASSERT(1, "cbDestScan is not big enough (%ld)",
               (DWORD)(ABS(pTPInfo->cbDestScan)) >=
               (DWORD)(((pTPInfo->cySrc) + 1) >> 1), pTPInfo->cbDestScan);

    //
    // This is a simple 2x2 4bpp transpos, we will transpos only up to cySrc
    // if cySrc is an odd number then the last destination low nibble is set
    // padded with 0
    //
    // Scan 0 - Src0_H Src0_L         pNibbleL - Src0_L Src1_L Src2_L Src3_L
    // Scan 1 - Src1_H Src1_L  ---->  pNibbleH - Src0_H Src1_H Src2_H Src3_H
    // Scan 2 - Src2_H Src2_L
    // Scan 3 - Src3_H Src3_L
    //
    //

    pSrc      = pTPInfo->pSrc;
    cbSrcScan = pTPInfo->cbSrcScan;
    pDest1st  = pTPInfo->pDest;
    pDest2nd  = pDest1st + pTPInfo->cbDestScan;
    cySrc     = pTPInfo->cySrc;

    //
    // Compute the transpose, leaving the last scan line for later. This
    // way we don't pollute the loop with having to check if its the last
    // line.
    //

    while (cySrc > 1) {

        //
        // Compose two input scan line buffers from the input scan buffer
        // by reading in the Y direction
        //

        b0           = *pSrc;
        b1           = *(pSrc += cbSrcScan);
        *pDest1st++  = (BYTE)((b0 << 4) | (b1 & 0x0f));
        *pDest2nd++  = (BYTE)((b1 >> 4) | (b0 & 0xf0));

        pSrc        += cbSrcScan;
        cySrc       -= 2;
    }

    //
    // Deal with last odd source scan line
    //

    if (cySrc > 0) {

        b0        = *pSrc;
        *pDest1st = (BYTE)(b0 <<   4);
        *pDest2nd = (BYTE)(b0 & 0xf0);
    }

    pTPInfo->pSrc += (INT)((pTPInfo->cbDestScan > 0) ? -1 : 1);

    return(TRUE);
}





BOOL
TransPos1BPP(
    PTPINFO pTPInfo
    )

/*++

Routine Description:

    This function rotates a 1bpp source to 1bpp destination.

Arguments:

    pTPINFO - Pointer to the TPINFO to describe how to do the transpose, the
    fields must be set to the following:

        pPDev:      Pointer to the PDEV
        pSrc:       Pointer to the soruce bitmap starting point
        pDest       Pointer to the destination bitmap location which stores the
                    transpos result starting from the fist destination scan
                    line in the rotated direction (rotating right will have
                    0x01 source bit as first destination scan line)
        cbSrcScan:  Count to be added to advance to next source bitmap line
        cbDestScan: Count to be added to advance to the next destination line
        cySrc       Total source lines to be processed
        DestXStart  Specifies where the transposed destination buffer starts,
                    in bit position. It is computed as DestXStart % 8. 0 means
                    it starts at the top bit (0x80), 1 means the next bit (0x40)
                    and so forth.

        NOTE:

              1. The ABS(DestDelta) must be large enough to accomodate the
                 transposed scan line. The size depends on cySrc and DestXStart,
                 the mimimum size must at least be of the size:

                    MinSize = (cySrc + (DestXStart % 8) + 7) / 8

              2. The size of the buffer are pointed to by pDest must have at
                 least ABS(DestDelta) * 8 bytes, if cySrc >= 8, or
                 ABS(DestDelta) * cySrc if cySrc is less than 8.


              3. Unused last byte destinations are padded with 0


    Current transposition assumes the bitmap is rotated to the right, if caller
    wants to rotate the bitmap to the left then you must first call the macro
    ROTLEFT_1BPP_TPIINFO(pTPInfo)


Return Value:

    TRUE if sucessful FALSE if failed

    if sucessful the pTPInfo->pSrc will be automatically

    1. Incremented by one (1) if cbDestScan is negative (Rotated left 90 degree)
    2. Decremented by one (1) if cbDestScan is positive (Rotated right 90 degree)

Author:

    22-Dec-1993 Wed 13:46:01 created  

    24-Dec-1993 Fri 04:58:24 updated  
        Fixed the RemainBits problem, we have to shift final data left if the
        cySrc is already exhausted and RemainBits is not zero.

Revision History:


--*/

{
    LPDWORD pdwTP8x8;
    LPBYTE  pSrc;
    TPINFO  TPInfo;
    INT     RemainBits;
    INT     cbNextDest;
    union {
        BYTE    b[8];
        DWORD   dw[2];
    } TPData;



    TPInfo             = *pTPInfo;
    TPInfo.DestXStart &= 0x07;

    PLOTASSERT(1, "cbDestScan is not big enough (%ld)",
            (DWORD)(ABS(TPInfo.cbDestScan)) >=
            (DWORD)((TPInfo.cySrc + TPInfo.DestXStart + 7) >> 3),
                                                        TPInfo.cbDestScan);
    //
    // Make sure we have the required transpose translate table. If we don't
    // get one built.
    //

    if (!(pdwTP8x8 = (LPDWORD)pTPInfo->pPDev->pTransPosTable)) {

        if (!(pdwTP8x8 = Build8x8TransPosTable())) {

            PLOTERR(("TransPos1BPP: Build 8x8 transpos table failed"));
            return(FALSE);
        }

        pTPInfo->pPDev->pTransPosTable = (LPVOID)pdwTP8x8;
    }

    //
    // set up all required parameters, and start TPData with 0s
    //

    pSrc         = TPInfo.pSrc;
    RemainBits   = (INT)(7 - TPInfo.DestXStart);
    cbNextDest   = (INT)((TPInfo.cbDestScan > 0) ? 1 : -1);
    TPData.dw[0] =
    TPData.dw[1] = 0;

    while (TPInfo.cySrc--) {

        LPDWORD pdwTmp;
        LPBYTE  pbTmp;

        //
        // Translate a byte to 8 bytes with each bit corresponding to each byte
        // each byte is shifted to the left by 1 before combining with the new
        // bit.
        //

        pdwTmp        = pdwTP8x8 + ((UINT)*pSrc << 1);
        TPData.dw[0]  = (TPData.dw[0] << 1) | *(pdwTmp + 0);
        TPData.dw[1]  = (TPData.dw[1] << 1) | *(pdwTmp + 1);
        pSrc         += TPInfo.cbSrcScan;

        //
        // Check to see if we are done with source scan lines. If this is the
        // case we need to possible shift the transposed scan lines by the
        // apropriate number based on RemainBits.
        //

        if (!TPInfo.cySrc) {

            //
            // We are done, check to see if we need to shift the resultant
            // transposed scan lines.
            //

            if (RemainBits) {

                TPData.dw[0] <<= RemainBits;
                TPData.dw[1] <<= RemainBits;

                RemainBits     = 0;
            }
        }

        if (RemainBits--) {

            NULL;

        } else {

            //
            // Save the current result to the output destination scan buffer.
            // Unwind the processing, to give the compiler a chance to generate
            // some fast code, rather that relying on a while loop.
            //

            *(pbTmp  = TPInfo.pDest     ) = TPData.b[0];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[1];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[2];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[3];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[4];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[5];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[6];
            *(pbTmp +  TPInfo.cbDestScan) = TPData.b[7];

            //
            // Reset RemainBits back to 7, TPData back to 0 and and advance to
            // the next destination
            //

            RemainBits    = 7;
            TPData.dw[0]  =
            TPData.dw[1]  = 0;
            TPInfo.pDest += cbNextDest;
        }
    }


    //
    // Since we succeded in transposing the bitmap, the next source byte
    // location must be incremented or decremented by one.
    //
    // The cbNextDest is 1 if the bitmap is rotated to the right 90 degrees, so
    // we want to decrement by 1.
    //
    // The cbNextDest is -1 if the bitmap is rotated to the right 90 degrees, so
    // we want to increment by 1.
    //

    pTPInfo->pSrc -= cbNextDest;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\cpsui.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    cpsui.h


Abstract:

    This module contains defines for cpsui.c


Author:

    03-Nov-1995 Fri 13:44:30 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



typedef struct _EXTRAINFO {
    DWORD   Size;
    LPBYTE  pData;
    } EXTRAINFO, *PEXTRAINFO;

BOOL
CreateOPTTYPE(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData,
    UINT            cLBCBItem,
    PEXTRAINFO      pExtraInfo
    );

POPTITEM
FindOptItem(
    POPTITEM    pOptItem,
    UINT        cOptItem,
    BYTE        DMPubID
    );

LONG
CallCommonPropertySheetUI(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

LONG
DefCommonUIFunc(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam,
    PPRINTERINFO        pPI,
    LONG_PTR            lData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\cpsui.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    cpsui.c


Abstract:

    This module contains helper functions to be used with common UI


Author:

    03-Nov-1995 Fri 13:24:41 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgCPSUI


DEFINE_DBGVAR(0);


#define SIZE_OPTTYPE(cOP)   (sizeof(OPTPARAM) + ((cOP) * sizeof(OPTPARAM)))

extern HMODULE  hPlotUIModule;

static BYTE cTVOP[] = { 2,3,2,3,3,0,0,2,1,1 };

OPDATA  OPNoYes[] = {

            { 0, IDS_CPSUI_NO,  IDI_CPSUI_OFF,  0,  0, 0  },
            { 0, IDS_CPSUI_YES, IDI_CPSUI_ON,   0,  0, 0  }
        };

static const CHAR szCompstui[] = "compstui.dll";



BOOL
CreateOPTTYPE(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData,
    UINT            cLBCBItem,
    PEXTRAINFO      pExtraInfo
    )

/*++

Routine Description:

    This fucntion allocate memory and initialized field for OPTTYPE/OPTPARAM



Arguments:

    pOptItem    - Pointer to OPTITEM data structure

    pOIData     - Pointer to the OIDATA structure


Return Value:




Author:

    03-Nov-1995 Fri 13:25:54 created  


Revision History:


--*/

{
    LPBYTE      pbData = NULL;
    UINT        cOP;
    DWORD       cbOP;
    DWORD       cbECB;
    DWORD       cbExtra;
    DWORD       cbAlloc;
    BYTE        Type;
    DWORD       Flags;


    Flags = pOIData->Flags;

    ZeroMemory(pOptItem, sizeof(OPTITEM));

    pOptItem->cbSize    = sizeof(OPTITEM);
    pOptItem->Level     = pOIData->Level;
    pOptItem->Flags     = (Flags & ODF_CALLBACK) ? OPTIF_CALLBACK : 0;

    if (Flags & ODF_COLLAPSE) {

        pOptItem->Flags |= OPTIF_COLLAPSE;
    }

    pOptItem->pName     = (LPTSTR)pOIData->IDSName;
    pOptItem->HelpIndex = (DWORD)pOIData->HelpIdx;
    pOptItem->DMPubID   = pOIData->DMPubID;

    if ((Type = pOIData->Type) >= sizeof(cTVOP)) {

        pOptItem->Sel = (LONG)pOIData->IconID;
        cOP           = 0;

    } else if (!(cOP = cTVOP[Type])) {

        cOP = cLBCBItem;
    }

    cbOP    = (cOP) ? SIZE_OPTTYPE(cOP) : 0;
    cbECB   = (Flags & ODF_ECB) ? sizeof(EXTCHKBOX) : 0;
    cbExtra = (pExtraInfo) ? pExtraInfo->Size : 0;

    if (cbAlloc = cbOP + cbECB + cbExtra) {

        if (pbData = (LPBYTE)LocalAlloc(LPTR, cbAlloc)) {

            POPDATA pOPData;

            pOPData = (pOIData->Flags & ODF_CALLCREATEOI) ? NULL :
                                                            pOIData->pOPData;

            pOptItem->UserData = (DWORD_PTR)pbData;

            if (cbECB) {

                PEXTCHKBOX  pECB;

                pOptItem->pExtChkBox  =
                pECB                  = (PEXTCHKBOX)pbData;
                pbData               += cbECB;
                pECB->cbSize          = sizeof(EXTCHKBOX);

                if (pOPData) {

                    pECB->Flags           = pOPData->Flags;
                    pECB->pTitle          = (LPTSTR)pOPData->IDSName;
                    pECB->IconID          = (DWORD)pOPData->IconID;
                    pECB->pSeparator      = (LPTSTR)pOPData->IDSSeparator;
                    pECB->pCheckedName    = (LPTSTR)pOPData->IDSCheckedName;
                    pOPData++;
                }
            }

            if (cbOP) {

                POPTTYPE    pOptType;
                POPTPARAM   pOP;
                UINT        i;


                pOptType  = (POPTTYPE)pbData;
                pbData   += cbOP;

                //
                // Initialize the OPTITEM
                //

                pOptItem->pOptType = pOptType;

                //
                // Initialize the OPTTYPE
                //

                pOptType->cbSize    = sizeof(OPTTYPE);
                pOptType->Type      = (BYTE)Type;
                pOptType->Count     = (WORD)cOP;
                pOP                 =
                pOptType->pOptParam = (POPTPARAM)(pOptType + 1);
                pOptType->Style     = pOIData->Style;

                for (i = 0; i < cOP; i++, pOP++) {

                    pOP->cbSize = sizeof(OPTPARAM);

                    if (pOPData) {

                        pOP->Flags  = (BYTE)(pOPData->Flags & 0xFF);
                        pOP->Style  = (BYTE)(pOPData->Style & 0xFF);
                        pOP->pData  = (LPTSTR)pOPData->IDSName;
                        pOP->IconID = (DWORD)pOPData->IconID;
                        pOP->lParam = (LONG)pOPData->sParam;

                        if (Type == TVOT_PUSHBUTTON) {

                            (DWORD_PTR)(pOP->pData) += (DWORD_PTR)pPI;

                        } else {

                            if (Flags & ODF_INC_IDSNAME) {

                                (DWORD_PTR)(pOP->pData) += i;
                            }

                            if (Flags & ODF_INC_ICONID) {

                                (DWORD)(pOP->IconID) += i;
                            }
                        }

                        if (!(Flags & ODF_NO_INC_POPDATA)) {

                            pOPData++;
                        }
                    }
                }
            }

            if (pExtraInfo) {

                pExtraInfo->pData = (cbExtra) ? pbData : 0;
            }

        } else {

            PLOTERR(("CreateOPTTYPE: LocalAlloc%ld) failed", cbAlloc));
            return(FALSE);
        }
    }

    return(TRUE);
}




POPTITEM
FindOptItem(
    POPTITEM        pOptItem,
    UINT            cOptItem,
    BYTE            DMPubID
    )

/*++

Routine Description:

    This function return the first occurence of the DMPubID


Arguments:




Return Value:




Author:

    16-Nov-1995 Thu 21:01:26 created  


Revision History:


--*/

{
    while (cOptItem--) {

        if (pOptItem->DMPubID == DMPubID) {

            return(pOptItem);
        }

        pOptItem++;
    }

    PLOTWARN(("FindOptItem: Cannot Find DMPubID=%u", (UINT)DMPubID));

    return(NULL);

}




LONG
CallCommonPropertySheetUI(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    )

/*++

Routine Description:

    This function dymically load the compstui.dll and call its entry


Arguments:

    pfnPropSheetUI  - Pointer to callback function

    lParam          - lParam for the pfnPropSheetUI

    pResult         - pResult for the CommonPropertySheetUI


Return Value:

    LONG    - as describe in compstui.h


Author:

    01-Nov-1995 Wed 13:11:19 created  


Revision History:


--*/

{
    HINSTANCE           hInstCompstui;
    FARPROC             pProc;
    LONG                Result = ERR_CPSUI_GETLASTERROR;
    static const CHAR   szCommonPropertySheetUI[] = "CommonPropertySheetUIW";


    //
    // ONLY need to call the ANSI version of LoadLibrary
    //


    if ((hInstCompstui = LoadLibraryA(szCompstui)) &&
        (pProc = GetProcAddress(hInstCompstui, szCommonPropertySheetUI))) {

        Result = (LONG) (*pProc)(hWndOwner, pfnPropSheetUI, lParam, pResult);
    }

    if (hInstCompstui) {

        FreeLibrary(hInstCompstui);
    }

    return(Result);
}



LONG
DefCommonUIFunc(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam,
    PPRINTERINFO        pPI,
    LONG_PTR            lData
    )

/*++

Routine Description:

    This is the default processing function for DocumentPropertySheet() and
    PrinterPropertySheet()


Arguments:

    pPSUIInfo   - From the original pfnPropSheetUI(pPSUIInfo, lParam)

    lParam      - From the original pfnPropSheetUI(pPSUIInfo, lParam)

    pPI         - Pointer to our instance data

    lData       - Extra data based on the pPSUIInfo->Reason


Return Value:

    LONG    Result to be return back from the pfnPropSheetUI()


Author:

    05-Feb-1996 Mon 17:47:51 created  


Revision History:


--*/

{
    PPROPSHEETUI_INFO_HEADER    pPSUIInfoHdr;
    LONG                        Result = -1;


    if (pPI) {

        switch (pPSUIInfo->Reason) {

        case PROPSHEETUI_REASON_INIT:

            //
            // Default result
            //

            pPSUIInfo->Result   = CPSUI_CANCEL;
            pPSUIInfo->UserData = (DWORD_PTR)pPI;

            //
            // the lData is the return value from the SetupDPOptItems() or
            // SetupPPOptItems()
            //

            if (lData) {

                PCOMPROPSHEETUI pCPSUI = pPI->pCPSUI;


                pCPSUI->cbSize         = sizeof(COMPROPSHEETUI);
                pCPSUI->hInstCaller    = (HINSTANCE)hPlotUIModule;
                pCPSUI->pCallerName    = (LPTSTR)IDS_PLOTTER_DRIVER;
                pCPSUI->UserData       = (DWORD_PTR)pPI;
                pCPSUI->pHelpFile      = pPI->pHelpFile;
                pCPSUI->IconID         = GetPlotterIconID(pPI);
                pCPSUI->pOptItemName   = pPI->PlotDM.dm.dmDeviceName;
                pCPSUI->CallerVersion  = DRIVER_VERSION;
                pCPSUI->OptItemVersion = (WORD)pPI->pPlotGPC->Version;
                pCPSUI->pOptItem       = pPI->pOptItem;
                pCPSUI->cOptItem       = pPI->cOptItem;

                if (pPI->Flags & PIF_UPDATE_PERMISSION) {

                    pCPSUI->Flags |= CPSUIF_UPDATE_PERMISSION;
                }

                if (pPI->hCPSUI = (HANDLE)
                        pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                                   CPSFUNC_ADD_PCOMPROPSHEETUI,
                                                   (LPARAM)pCPSUI,
                                                   (LPARAM)&lData)) {

                    Result = 1;
                }
            }

            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:

            if (pPSUIInfoHdr = (PPROPSHEETUI_INFO_HEADER)lParam) {

                pPSUIInfoHdr->Flags      = (PSUIHDRF_PROPTITLE |
                                            PSUIHDRF_NOAPPLYNOW);
                pPSUIInfoHdr->pTitle     = (LPTSTR)lData;
                pPSUIInfoHdr->hInst      = (HINSTANCE)hPlotUIModule;
                pPSUIInfoHdr->IconID     = pPI->pCPSUI->IconID;

                Result = 1;
            }

            break;

        case PROPSHEETUI_REASON_SET_RESULT:

            //
            // Save the result and also set the result to the caller.
            //

            if (pPI->hCPSUI == ((PSETRESULT_INFO)lParam)->hSetResult) {

                pPSUIInfo->Result = ((PSETRESULT_INFO)lParam)->Result;
                Result = 1;
            }

            break;

        case PROPSHEETUI_REASON_DESTROY:

            UnMapPrinter(pPI);
            pPSUIInfo->UserData = 0;
            Result              = 1;
            break;

        }
    }

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\docprop.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    docprop.c


Abstract:

    This module contains functions for DrvDocumentPropertySheets


Author:

    07-Dec-1993 Tue 12:15:40 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


#define DBG_PLOTFILENAME    DbgDocProp


extern HMODULE  hPlotUIModule;


#define DBG_DP_SETUP        0x00000001
#define DBG_DP_FORM         0x00000002
#define DBG_HELP            0x00000004

DEFINE_DBGVAR(0);



OPDATA  OPOrientation[] = {

            { 0, IDS_CPSUI_PORTRAIT,  IDI_CPSUI_PORTRAIT,  0, 0, 0   },
            { 0, IDS_CPSUI_LANDSCAPE, IDI_CPSUI_LANDSCAPE, 0, 0, 0   }
        };

OPDATA  OPColor[] = {

            { 0, IDS_CPSUI_MONOCHROME, IDI_CPSUI_MONO,  0, 0, 0   },
            { 0, IDS_CPSUI_COLOR,      IDI_CPSUI_COLOR, 0, 0, 0   }
        };

OPDATA  OPCopyCollate[] = {

            { 0, IDS_CPSUI_COPIES, IDI_CPSUI_COPY, 0, 0,   0 },
            { 0, 0,                1,              0, 0, 100 }
        };

OPDATA  OPScaling[] = {

            { 0, IDS_CPSUI_PERCENT, IDI_CPSUI_SCALING, 0, 0,   0 },
            { 0, 0,                 1,                 0, 0, 100 }
        };

OPDATA  OPPrintQuality[] = {

            { 0, IDS_QUALITY_DRAFT,  IDI_CPSUI_RES_DRAFT,        0, 0, -1 },
            { 0, IDS_QUALITY_LOW,    IDI_CPSUI_RES_LOW,          0, 0, -2 },
            { 0, IDS_QUALITY_MEDIUM, IDI_CPSUI_RES_MEDIUM,       0, 0, -3 },
            { 0, IDS_QUALITY_HIGH,   IDI_CPSUI_RES_PRESENTATION, 0, 0, -4 }
        };

OPDATA  OPHTClrAdj = {

            0,
            PI_OFF(PlotDM) + PLOTDM_OFF(ca),
            IDI_CPSUI_HTCLRADJ,
            PUSHBUTTON_TYPE_HTCLRADJ,
            0,
            0
        };


extern OPDATA  OPNoYes[];

OPDATA  OPFillTrueType[] = {

            { 0, IDS_CPSUI_NO,  IDI_FILL_TRUETYPE_NO,  0,  0, 0  },
            { 0, IDS_CPSUI_YES, IDI_FILL_TRUETYPE_YES, 0,  0, 0  }
        };


OIDATA  DPOIData[] = {

    {
        ODF_PEN_RASTER | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_1,
        DMPUB_FORMNAME,
        TVOT_LISTBOX,
        IDS_CPSUI_FORMNAME,
        0,
        IDH_FORMNAME,
        0,
        (POPDATA)CreateFormOI
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        DMPUB_ORIENTATION,
        TVOT_2STATES,
        IDS_CPSUI_ORIENTATION,
        0,
        IDH_ORIENTATION,
        COUNT_ARRAY(OPOrientation),
        OPOrientation
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        DMPUB_COPIES_COLLATE,
        TVOT_UDARROW,
        IDS_CPSUI_NUM_OF_COPIES,
        0,
        IDH_COPIES_COLLATE,
        COUNT_ARRAY(OPCopyCollate),
        OPCopyCollate
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        DMPUB_PRINTQUALITY,
        TVOT_LISTBOX,
        IDS_CPSUI_PRINTQUALITY,
        0,
        IDH_PRINTQUALITY,
        COUNT_ARRAY(OPPrintQuality),
        OPPrintQuality
    },

    {
        ODF_RASTER | ODF_COLOR,
        0,
        OI_LEVEL_1,
        DMPUB_COLOR,
        TVOT_2STATES,
        IDS_CPSUI_COLOR_APPERANCE,
        0,
        IDH_COLOR,
        COUNT_ARRAY(OPColor),
        OPColor
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        DMPUB_SCALE,
        TVOT_UDARROW,
        IDS_CPSUI_SCALING,
        0,
        IDH_SCALE,
        COUNT_ARRAY(OPScaling),
        OPScaling
    },

    {
        ODF_RASTER,
        0,
        OI_LEVEL_1,
        DP_HTCLRADJ,
        TVOT_PUSHBUTTON,
        IDS_CPSUI_HTCLRADJ,
        OTS_PUSH_ENABLE_ALWAYS,
        IDH_HTCLRADJ,
        1,
        &OPHTClrAdj
    },

    {
        ODF_PEN,
        0,
        OI_LEVEL_1,
        DP_FILL_TRUETYPE,
        TVOT_2STATES,
        IDS_FILL_TRUETYPE,
        0,
        IDH_FILL_TRUETYPE,
        2,
        OPFillTrueType
    },

    {
        ODF_RASTER,
        0,
        OI_LEVEL_1,
        DP_QUICK_POSTER_MODE,
        TVOT_2STATES,
        IDS_POSTER_MODE,
        0,
        IDH_POSTER_MODE,
        2,
        OPNoYes
    }
};



UINT
SetupDPOptItems(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    16-Nov-1995 Thu 14:15:25 created  


Revision History:


--*/

{
    PPLOTDEVMODE    pPlotDM;
    PPLOTGPC        pPlotGPC;
    POPTITEM        pOptItem;
    POPTITEM        pOI;
    POIDATA         pOIData;
    DWORD           Flags;
    DWORD           ODFlags;
    UINT            i;



    pOI      =
    pOptItem = pPI->pOptItem;
    pOIData  = DPOIData;
    i        = (UINT)COUNT_ARRAY(DPOIData);
    pPlotGPC = pPI->pPlotGPC;
    pPlotDM  = &(pPI->PlotDM);
    Flags    = pPlotGPC->Flags;
    ODFlags  = (Flags & PLOTF_RASTER) ? ODF_RASTER : ODF_PEN;

    while (i--) {

        DWORD   OIFlags = pOIData->Flags;


        switch (pOIData->DMPubID) {

        case DMPUB_COPIES_COLLATE:

            if (pPlotGPC->MaxCopies <= 1) {

                OIFlags = 0;
            }

            break;

        case DMPUB_SCALE:

            if (!pPlotGPC->MaxScale) {

                OIFlags = 0;
            }

            break;
        }

        if ((!(OIFlags & ODFlags))                                      ||
            ((OIFlags & ODF_ROLLFEED) && (!(Flags & PLOTF_ROLLFEED)))   ||
            ((OIFlags & ODF_NO_PAPERTRAY) && (Flags & PLOTF_PAPERTRAY)) ||
            ((OIFlags & ODF_COLOR) && (!(Flags & PLOTF_COLOR)))) {

            //
            // Nothing to do here
            //

            NULL;

        } else if (OIFlags & ODF_CALLCREATEOI) {

            pOI += pOIData->pfnCreateOI(pPI,
                                        (LPVOID)((pOptItem) ? pOI : NULL),
                                        pOIData);

        } else if (pOptItem) {

            if (CreateOPTTYPE(pPI, pOI, pOIData, pOIData->cOPData, NULL)) {

                POPTPARAM   pOP = pOI->pOptType->pOptParam;

                switch (pOI->DMPubID) {

                case DMPUB_ORIENTATION:

                    pOI->Sel = (LONG)((pPlotDM->dm.dmOrientation ==
                                                DMORIENT_PORTRAIT) ? 0 : 1);
                    break;

                case DMPUB_COPIES_COLLATE:

                    pOP[1].lParam = (LONG)pPlotGPC->MaxCopies;
                    pOI->Sel      = (LONG)pPlotDM->dm.dmCopies;
                    break;

                case DMPUB_PRINTQUALITY:

                    switch (pPlotGPC->MaxQuality) {

                    case 0:
                    case 1:

                        pPlotDM->dm.dmPrintQuality = DMRES_HIGH;
                        pOP[0].Flags |= OPTPF_HIDE;

                    case 2:

                        pOP[2].Flags |= OPTPF_HIDE;

                    case 3:

                        pOP[1].Flags |= OPTPF_HIDE;
                        break;

                    default:

                        break;
                    }

                    pOI->Sel = (LONG)-(pPlotDM->dm.dmPrintQuality -
                                                                DMRES_DRAFT);
                    break;

                case DMPUB_COLOR:

                    pOI->Sel = (LONG)((pPlotDM->dm.dmColor == DMCOLOR_COLOR) ?
                                                1 : 0);
                    break;

                case DMPUB_SCALE:

                    pOP[1].lParam = (LONG)pPlotGPC->MaxScale;
                    pOI->Sel      = (LONG)pPlotDM->dm.dmScale;
                    break;

                case DP_FILL_TRUETYPE:

                    pOI->Sel = (LONG)((pPlotDM->Flags & PDMF_FILL_TRUETYPE) ?
                                                                        1 : 0);
                    break;


                case DP_QUICK_POSTER_MODE:

                    pOI->Sel = (LONG)((pPlotDM->Flags & PDMF_PLOT_ON_THE_FLY) ?
                                                                        1 : 0);
                    break;
                }

                pOI++;
            }

        } else {

            pOI++;
        }

        pOIData++;
    }

    if ((i = (UINT)(pOI - pOptItem)) && (!pOptItem)) {

        if (pPI->pOptItem = (POPTITEM)LocalAlloc(LPTR, sizeof(OPTITEM) * i)) {

            pPI->cOptItem = (WORD)i;

            //
            // Call myself second time to really create it
            //

            SetupDPOptItems(pPI);

        } else {

            i = 0;

            PLOTERR(("GetPPpOptItem(): LocalAlloc(%ld) failed",
                                            sizeof(OPTITEM) * i));
        }
    }

    return(i);
}



VOID
SaveDPOptItems(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:

    This function save all the device options back to registry if one changed
    and has a update permission


Arguments:

    pPI     - Pointer to the PRINTERINFO


Return Value:

    VOID


Author:

    06-Nov-1995 Mon 18:05:16 created  


Revision History:


--*/

{
    POPTITEM        pOI;
    POPTITEM        pLastItem;
    PPLOTDEVMODE    pPlotDM;
    BYTE            DMPubID;


    pOI       = pPI->pOptItem;
    pLastItem = pOI + pPI->cOptItem - 1;
    pPlotDM   = &(pPI->PlotDM);

    while (pOI <= pLastItem) {

        if (pOI->Flags & OPTIF_CHANGEONCE) {

            switch (pOI->DMPubID) {

            case DMPUB_FORMNAME:

                GetFormSelect(pPI, pOI);
                break;

            case DMPUB_ORIENTATION:

                pPlotDM->dm.dmOrientation = (SHORT)((pOI->Sel) ?
                                                        DMORIENT_LANDSCAPE :
                                                        DMORIENT_PORTRAIT);
                break;

            case DMPUB_COPIES_COLLATE:

                pPlotDM->dm.dmCopies = (SHORT)pOI->Sel;
                break;

            case DMPUB_PRINTQUALITY:

                pPlotDM->dm.dmPrintQuality = (SHORT)(-(pOI->Sel) + DMRES_DRAFT);
                break;

            case DMPUB_COLOR:

                pPlotDM->dm.dmColor = (SHORT)((pOI->Sel) ? DMCOLOR_COLOR :
                                                           DMCOLOR_MONOCHROME);
                break;

            case DMPUB_SCALE:

                pPlotDM->dm.dmScale = (SHORT)pOI->Sel;
                break;

            case DP_FILL_TRUETYPE:

                if (pOI->Sel) {

                    pPlotDM->Flags |= PDMF_FILL_TRUETYPE;

                } else {

                    pPlotDM->Flags &= ~PDMF_FILL_TRUETYPE;
                }

                break;

            case DP_QUICK_POSTER_MODE:

                if (pOI->Sel) {

                    pPlotDM->Flags |= PDMF_PLOT_ON_THE_FLY;

                } else {

                    pPlotDM->Flags &= ~PDMF_PLOT_ON_THE_FLY;
                }

                break;
            }
        }

        pOI++;
    }
}




CPSUICALLBACK
DPCallBack(
    PCPSUICBPARAM   pCPSUICBParam
    )

/*++

Routine Description:

    This is the callback function from the common property sheet UI


Arguments:

    pCPSUICBParam   - Pointer to the CPSUICBPARAM data structure to describe
                      the nature of the callback


Return Value:

    LONG


Author:

    07-Nov-1995 Tue 15:15:02 created  


Revision History:


--*/

{
    POPTITEM    pCurItem = pCPSUICBParam->pCurItem;
    LONG        Action = CPSUICB_ACTION_NONE;

    if (pCPSUICBParam->Reason == CPSUICB_REASON_APPLYNOW) {

        PPRINTERINFO    pPI = (PPRINTERINFO)pCPSUICBParam->UserData;

        if ((pPI->Flags & PIF_UPDATE_PERMISSION) &&
            (pPI->pPlotDMOut)) {

            SaveDPOptItems(pPI);

            PLOTDBG(DBG_DP_SETUP, ("APPLYNOW: ConvertDevmodeOut"));

            ConvertDevmodeOut((PDEVMODE)&(pPI->PlotDM),
                              (PDEVMODE)pPI->pPlotDMIn,
                              (PDEVMODE)pPI->pPlotDMOut);

            pCPSUICBParam->Result = CPSUI_OK;
            Action                = CPSUICB_ACTION_ITEMS_APPLIED;
        }
    }

    return(Action);
}




BOOL
DrvConvertDevMode(
    LPTSTR      pPrinterName,
    PDEVMODE    pDMIn,
    PDEVMODE    pDMOut,
    PLONG       pcbNeeded,
    DWORD       fMode
    )

/*++

Routine Description:

    This function is used by the SetPrinter() and GetPrinter() spooler calls.

Arguments:

    pPrinterName    - Points to printer name string

    pDMIn           - Points to the input devmode

    pDMOut          - Points to the output devmode buffer

    pcbNeeded       - Specifies the size of output buffer on input On output,
                      this is the size of output devmode

    fMode           - Specifies what function to perform


Return Value:

    TRUE if successful
    FALSE otherwise and an error code is logged

Author:

    08-Jan-1996 Mon 12:40:22 created  


Revision History:


--*/

{
    DWORD                       cb;
    INT                         Result;
    static DRIVER_VERSION_INFO  PlotDMVersions = {

        DRIVER_VERSION, PLOTDM_PRIV_SIZE,   // current version/size
        0x0350,         PLOTDM_PRIV_SIZE,   // NT3.51 version/size
    };

    //
    // Call a library routine to handle the common cases
    //

    Result = CommonDrvConvertDevmode(pPrinterName,
                                     pDMIn,
                                     pDMOut,
                                     pcbNeeded,
                                     fMode,
                                     &PlotDMVersions);

    //
    // If not handled by the library routine, we only need to worry
    // about the case when fMode is CDM_DRIVER_DEFAULT
    //

    if ((Result == CDM_RESULT_NOT_HANDLED)  &&
        (fMode == CDM_DRIVER_DEFAULT)) {

        HANDLE  hPrinter;

        if (OpenPrinter(pPrinterName, &hPrinter, NULL)) {

            PPLOTGPC    pPlotGPC;

            if (pPlotGPC = hPrinterToPlotGPC(hPrinter, pDMOut->dmDeviceName, CCHOF(pDMOut->dmDeviceName))) {

                SetDefaultPLOTDM(hPrinter,
                                 pPlotGPC,
                                 pDMOut->dmDeviceName,
                                 (PPLOTDEVMODE)pDMOut,
                                 NULL);

                UnGetCachedPlotGPC(pPlotGPC);
                Result = CDM_RESULT_TRUE;

            } else {

                PLOTERR(("DrvConvertDevMode: hPrinterToPlotGPC(%ws) failed.",
                                                                pPrinterName));

                SetLastError(ERROR_INVALID_DATA);
            }

            ClosePrinter(hPrinter);

        } else {

            PLOTERR(("DrvConvertDevMode: OpenPrinter(%ws) failed.",
                                                            pPrinterName));
            SetLastError(ERROR_INVALID_DATA);
        }
    }

    return(Result == CDM_RESULT_TRUE);
}



LONG
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Show document property dialog box and update the output DEVMODE


Arguments:

    pPSUIInfo   - Pointer to the PROPSHEETUI_INFO data structure

    lParam      - LPARAM for this call, it is a pointer to the
                  DOCUMENTPROPERTYHEADER

Return Value:

    LONG, 1=successful, 0=failed.


Author:

    02-Feb-1996 Fri 10:47:42 created  


Revision History:


--*/

{
    PDOCUMENTPROPERTYHEADER     pDPHdr;
    PPRINTERINFO                pPI;
    LONG_PTR                    Result;


    //
    // Assume faild first
    //

    Result = -1;

    if (pPSUIInfo) {

        if (!(pDPHdr = (PDOCUMENTPROPERTYHEADER)pPSUIInfo->lParamInit)) {

            PLOTERR(("DrvDocumentPropertySheets: Pass a NULL lParamInit"));
            return(-1);
        }

    } else {

        if (pDPHdr = (PDOCUMENTPROPERTYHEADER)lParam) {

            //
            // We do not have pPSUIInfo, so that we assume this is call
            // directly from the spooler and lParam is the pDPHdr
            //

            if ((pDPHdr->fMode == 0) || (pDPHdr->pdmOut == NULL)) {

                Result = (pDPHdr->cbOut = sizeof(PLOTDEVMODE));

            } else if ((pDPHdr->fMode & (DM_COPY | DM_UPDATE))  &&
                       (!(pDPHdr->fMode & DM_NOPERMISSION))     &&
                       (pDPHdr->pdmOut)) {
                //
                // The MapPrinter will allocate memory, set default devmode,
                // reading and validating the GPC then update from current pritner
                // registry, it also will cached the pPI.
                //

                if (pPI = MapPrinter(pDPHdr->hPrinter,
                                     (PPLOTDEVMODE)pDPHdr->pdmIn,
                                     NULL,
                                     0)) {

                    ConvertDevmodeOut((PDEVMODE)&(pPI->PlotDM),
                                      (PDEVMODE)pDPHdr->pdmIn,
                                      (PDEVMODE)pDPHdr->pdmOut);

                    Result = 1;
                    UnMapPrinter(pPI);

                } else {

                    PLOTRIP(("DrvDocumentPropertySheets: MapPrinter() failed"));
                }

            } else {

                Result = 1;
            }

        } else {

            PLOTRIP(("DrvDocumentPropertySheets: ??? pDPHdr (lParam) = NULL"));
        }

        return((LONG)Result);
    }

    //
    // Now, this is the call from common UI, assume error to start with
    //

    if (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) {

        if (!(pPI = MapPrinter(pDPHdr->hPrinter,
                               (PPLOTDEVMODE)pDPHdr->pdmIn,
                               NULL,
                               MPF_HELPFILE | MPF_PCPSUI))) {

            PLOTRIP(("DrvDocumentPropertySheets: MapPrinter() failed"));

            SetLastError(ERROR_INVALID_DATA);
            return(ERR_CPSUI_GETLASTERROR);
        }

        if ((pDPHdr->fMode & (DM_COPY | DM_UPDATE))  &&
            (!(pDPHdr->fMode & DM_NOPERMISSION))     &&
            (pDPHdr->pdmOut)) {

            pPI->Flags      = (PIF_DOCPROP | PIF_UPDATE_PERMISSION);
            pPI->pPlotDMOut = (PPLOTDEVMODE)pDPHdr->pdmOut;

        } else {

            pPI->Flags      = PIF_DOCPROP;
            pPI->pPlotDMOut = NULL;
        }

        //
        // We need to display something to let user modify/update, we wll check
        // which document properties dialog box to be used
        //
        // The return value either IDOK or IDCANCEL
        //

        pPI->pCPSUI->Flags       = 0;
        pPI->pCPSUI->pfnCallBack = DPCallBack;
        pPI->pCPSUI->pDlgPage    = (pDPHdr->fMode & DM_ADVANCED) ?
                                                 CPSUI_PDLGPAGE_ADVDOCPROP :
                                                 CPSUI_PDLGPAGE_DOCPROP;

        Result = (LONG_PTR)SetupDPOptItems(pPI);

    } else {

        pPI    = (PPRINTERINFO)pPSUIInfo->UserData;
        Result = (LONG_PTR)pDPHdr->pszPrinterName;
    }

    return(DefCommonUIFunc(pPSUIInfo, lParam, pPI, Result));
}


// @@BEGIN_DDKSPLIT
// DrvDocumentProperties() and DrvAdvancedDocumentProperties()
// are obsolete, but we keep them here for old application which
// might be using these. But, we don't want these in the DDK samples.


LONG
DrvDocumentProperties(
    HWND            hWnd,
    HANDLE          hPrinter,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pDMOut,
    PPLOTDEVMODE    pDMIn,
    DWORD           fMode
    )

/*++

Routine Description:

    DrvDocumentProperties sets the public members of a PLOTDEVMODE structure
    for the given print document.

Arguments:

    hWnd            - Identifies the parent window of the printer-configuration
                      dialog box.

    hPrinter        - Identifies a printer object.

    pwDeviceName    - Points to a zero-terminated string that specifies the
                      name of the device for which the printer-configuration
                      dialog box should be displayed.

    pDMOut          - Points to a PLOTDEVMODE structure that initializes the
                      dialog box controls. NULL forces the use of the default
                      values.

    pDMIn           - Points to a PLOTDEVMODE structure that receives the
                      printer configuration data specified by the user.

    fMode           - Specifies a mask of values that determines which
                      operations the function performs. If this parameter is
                      zero, DrvDocumentProperties returns the number of bytes
                      required by the printer driver's PLOTDEVMODE structure.
                      Otherwise, use one or more of the following constants to
                      construct a value for this parameter; note, however, that
                      in order to change the print settings, an application
                      must specify at least one input value and one output
                      value:


            Value           Meaning
            ------------------------------------------------------------------

            DM_IN_BUFFER    Input value. Before prompting, copying, or updating,
            (DM_MODIFY)     the function merges the printer driver's current
                            print settings with the settings in the PLOTDEVMODE
                            specified by the pDMIn parameter. The structure
                            is updated only for those members specified by the
                            PLOTDEVMODE structure's dmFields member.  This
                            value is also defined as DM_MODIFY.

            DM_IN_PROMPT    Input value. The function presents the print
            (DM_PROMPT)     driver's Print Setup dialog box, then change the
                            settings in the printer's PLOTDEVMODE structure to
                            the values specified by the user.  This value is
                            also defined as DM_PROMPT.

            DM_OUT_BUFFER   Output value. The function writes the printer
            (DM_COPY)       driver's current print settings, including private
                            data, to the PLOTDEVMODE structure specified by
                            pDMOut. The caller must allocate a buffer large
                            enough to contain the information. If the bit
                            DM_OUT_BUFFER is clear, pDMOut can be NULL. This
                            value is also defined as DM_COPY.


Return Value:

    If fMode is zero, the return value is the size of the buffer (in bytes)
    required to contain the printer driver initialization data. Note that this
    buffer will generally be larger than the PLOTDEVMODE structure if the
    printer driver appends private data to the structure.  If the function
    displays the initialization dialog box, the return value is either IDOK or
    IDCANCEL, depending on which button the user selects.

    If the function does not display the dialog box and is successful, the
    return value is IDOK.  If the function fails, the return value is less than
    zero.

    In order to change print settings that are local to an application, the
    application should:

    * Call with fMode = 0 to get the size of DM_OUT_BUFFER.

    * Modify the returned PLOTDEVMODE structure.

    * Pass the modified PLOTDEVMODE back by calling DrvDocumentProperties,
      specifying both DM_IN_BUFFER and DM_OUT_BUFFER.


Author:

    15-Dec-1993 Wed 15:07:01 updated  
        it seems that spooler never passed a DM_MODIFY to the driver, and that
        caused we never merge the input devmode, we will assume that user has
        valid DM_IN_BUFFER/DM_MODIFY bit set if the pDMIn is not a NULL
        pointer.

    07-Dec-1993 Tue 12:19:47 created  


Revision History:


--*/

{
    DOCUMENTPROPERTYHEADER  DPHdr;
    LONG                    Result;


    DPHdr.cbSize         = sizeof(DPHdr);
    DPHdr.Reserved       = 0;
    DPHdr.hPrinter       = hPrinter;
    DPHdr.pszPrinterName = pwDeviceName;
    DPHdr.pdmIn          = (PDEVMODE)pDMIn;
    DPHdr.pdmOut         = (PDEVMODE)pDMOut;
    DPHdr.cbOut          = sizeof(PLOTDEVMODE);
    DPHdr.fMode          = fMode;

    PLOTDBG(DBG_DP_SETUP, ("DocProp: fMode=%08lx, %ws%ws%ws%ws",
                    fMode,
                    (INT_PTR)((fMode & DM_UPDATE) ? L"DM_UPDATE " : L""),
                    (INT_PTR)((fMode & DM_COPY  ) ? L"DM_COPY " : L""),
                    (INT_PTR)((fMode & DM_PROMPT) ? L"DM_PROMPT " : L""),
                    (INT_PTR)((fMode & DM_MODIFY) ? L"DM_MODIFY " : L"")));

    if (fMode & DM_PROMPT) {

        Result = CPSUI_CANCEL;

        if (CallCommonPropertySheetUI(hWnd,
                                      DrvDocumentPropertySheets,
                                      (LPARAM)&DPHdr,
                                      (LPDWORD)&Result) < 0) {

            Result = CPSUI_CANCEL;
        }

        PLOTDBG(DBG_DP_SETUP, ("Result=%hs",
                (Result == CPSUI_OK) ? "IDOK" : "IDCANCEL"));

        return((Result == CPSUI_OK) ? IDOK : IDCANCEL);

    } else {

        return(DrvDocumentPropertySheets(NULL, (LPARAM)&DPHdr));
    }
}




LONG
DrvAdvancedDocumentProperties(
    HWND            hWnd,
    HANDLE          hPrinter,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pDMOut,
    PPLOTDEVMODE    pDMIn
    )

/*++

Routine Description:

    DrvAdvancedDocumentProperties sets the public members of a PLOTDEVMODE
    structure for the given print document.

Arguments:

    hWnd            - Identifies the parent window of the printer-configuration
                      dialog box.

    hPrinter        - Identifies a printer object.

    pwDeviceName    - Points to a zero-terminated string that specifies the
                      name of the device for which the printer-configuration
                      dialog box should be displayed.

    pDMOut          - Points to a PLOTDEVMODE structure that initializes the
                      dialog box controls. NULL forces the use of the default
                      values.

    pDMIn           - Points to a PLOTDEVMODE structure that receives the
                      printer configuration data specified by the user.


Return Value:

    LONG value depends on the dilaog box outcome eiterh IDOK or IDCANCEL, if
    an error occurred then a negative number is returned


Author:

    07-Dec-1993 Tue 12:19:47 created  


Revision History:


--*/

{
    return((DrvDocumentProperties(hWnd,
                                  hPrinter,
                                  pwDeviceName,
                                  pDMOut,
                                  pDMIn,
                                  DM_PROMPT         |
                                    DM_MODIFY       |
                                    DM_COPY         |
                                    DM_ADVANCED) == CPSUI_OK) ? 1 : 0);
}

// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\help.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    help.h


Abstract:

    This module contains all plotter help related function prototypes and
    defines


Author:

    06-Dec-1993 Mon 15:33:23 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTUI_HELP_
#define _PLOTUI_HELP

LPWSTR
GetPlotHelpFile(
    PPRINTERINFO    pPI
    );

INT
cdecl
PlotUIMsgBox(
    HWND    hWnd,
    LONG    IDString,
    LONG    Style,
    ...
    );

#endif  _PLOTUI_HELP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\help.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    help.c


Abstract:

    This module contains all help functions for the plotter user interface



Development History:

    06-Dec-1993 Mon 14:25:45 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    31-Jan-1994 Mon 09:47:56 updated  
        Change help file location from the system32 directory to the current
        plotui.dll directory


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgHelp


extern HMODULE  hPlotUIModule;


#define DBG_SHOW_HELP       0x00000001

DEFINE_DBGVAR(0);


#define MAX_HELPFILE_NAME   64
#define MAX_IDS_STR_LEN     160
#define cbWSTR(wstr)        ((wcslen(wstr) + 1) * sizeof(WCHAR))



LPWSTR
GetPlotHelpFile(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:

    This function setup the directory path for the driver Help file

Arguments:

    hPrinter    - Handle to the printer

Return Value:

    LPWSTR to the full path HelpFile, NULL if failed


Development History:

    01-Nov-1995 Wed 18:43:40 created  


Revision History:


--*/

{
    PDRIVER_INFO_3  pDI3 = NULL;
    LPWSTR          pHelpFile = NULL;
    WCHAR           HelpFileName[MAX_HELPFILE_NAME];
    DWORD           cb;
    DWORD           cb2;
    HRESULT         hr = E_FAIL;

    if (pPI->pHelpFile) {

        return(pPI->pHelpFile);
    }

    if ((!GetPrinterDriver(pPI->hPrinter, NULL, 3, NULL, 0, &cb))           &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                       &&
        (pDI3 = (PDRIVER_INFO_3)LocalAlloc(LMEM_FIXED, cb))                 &&
        (GetPrinterDriver(pPI->hPrinter, NULL, 3, (LPBYTE)pDI3, cb, &cb))   &&
        (pDI3->pHelpFile)                                                   &&
        (pHelpFile = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                        cbWSTR(pDI3->pHelpFile)))) {

        hr = StringCchCopyW(pHelpFile, cbWSTR(pDI3->pHelpFile)/sizeof(WCHAR), (LPWSTR)pDI3->pHelpFile);

    } else if ((cb2 = LoadString(hPlotUIModule,
                                 IDS_HELP_FILENAME,
                                 &HelpFileName[1],
                                 COUNT_ARRAY(HelpFileName) - 1))            &&
               (cb2 = (cb2 + 1) * sizeof(WCHAR))                            &&
               (!GetPrinterDriverDirectory(NULL, NULL, 1, NULL, 0, &cb))    &&
               (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                &&
               (pHelpFile = (LPWSTR)LocalAlloc(LMEM_FIXED, cb + cb2))       &&
               (GetPrinterDriverDirectory(NULL,
                                          NULL,
                                          1,
                                          (LPBYTE)pHelpFile,
                                          cb,
                                          &cb))) {

        HelpFileName[0] = L'\\';
        hr = StringCchCatW(pHelpFile, (cb + cb2) /sizeof(WCHAR), HelpFileName);
    }

    if (pDI3) {

        LocalFree((HLOCAL)pDI3);
        pDI3 = NULL;
    }

    if (pHelpFile && !SUCCEEDED(hr))
    {
        LocalFree(pHelpFile);
        pHelpFile = NULL;
    }

    PLOTDBG(DBG_SHOW_HELP, ("GetlotHelpFile: '%ws",
                                        (pHelpFile) ? pHelpFile : L"Failed"));

    return(pPI->pHelpFile = pHelpFile);
}




INT
cdecl
PlotUIMsgBox(
    HWND    hWnd,
    LONG    IDString,
    LONG    Style,
    ...
    )

/*++

Routine Description:

    This function pop up a simple message and let user to press key to
    continue

Arguments:

    hWnd        - Handle to the caller window

    IDString    - String ID to be output with

    ...         - Parameter

Return Value:





Development History:

    06-Dec-1993 Mon 21:31:41 created  


Revision History:

    24-Jul-2000 Mon 12:18:12 updated 
        Fix for someone's change due to the fact that NULL character is not
        counted for the string


--*/

{
    va_list vaList;
    LPWSTR  pwTitle;
    LPWSTR  pwFormat;
    LPWSTR  pwMessage;
    INT     i;
    INT     MBRet = IDCANCEL;
    HRESULT hr;

    //
    // We assume that UNICODE flag is turn on for the compilation, bug the
    // format string passed to here is ASCII version, so we need to convert
    // it to LPWSTR before the wvsprintf()
    //
    // 24-Jul-2000 Mon 13:17:13 updated  
    //  1 MAX_IDS_STR_LEN for pwTitle,
    //  1 MAX_IDS_STR_LEN for pwFormat
    //  2 MAX_IDS_STR_LEN for pwMessage (wvsprintf)
    //

    if (!(pwTitle = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                       sizeof(WCHAR) * MAX_IDS_STR_LEN * 4))) {

        return(0);
    }

    if (i = LoadString(hPlotUIModule,
                       IDS_PLOTTER_DRIVER,
                       pwTitle,
                       MAX_IDS_STR_LEN - 1)) {

        pwFormat = pwTitle + i + 1;

        if (i = LoadString(hPlotUIModule,
                           IDString,
                           pwFormat,
                           MAX_IDS_STR_LEN - 1)) {

            pwMessage = pwFormat + i + 1;

            va_start(vaList, Style);
            hr = StringCchVPrintfW(pwMessage, MAX_IDS_STR_LEN - 1, pwFormat, vaList);
            va_end(vaList);

            MBRet = MessageBox(hWnd, pwMessage, pwTitle, MB_APPLMODAL | Style);
        }
    }


    LocalFree((HLOCAL)pwTitle);

    return(MBRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\devcaps.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    devcaps.c


Abstract:

    This module contains API function DrvDeviceCapabilities and other support
    functions


Author:

    02-Dec-1993 Thu 16:49:08 created  

    22-Mar-1994 Tue 13:00:04 updated  
        Update RESOLUTION caps so it return as not supported, this way the
        application will not used to setup the DMRES_xxx fields


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgDevCaps

extern HMODULE  hPlotUIModule;




#define DBG_DEVCAPS_0       0x00000001
#define DBG_DEVCAPS_1       0x00000002

DEFINE_DBGVAR(0);


//
// Local defines only used in this module
//
// The following sizes are copied from the Win 3.1 driver.  They do not appear
// to be defined in any public place,  although it looks like they should be.
//

#define CCHBINNAME          24      // Characters allowed for bin names
#define CCHPAPERNAME        64      // Max length of paper size names
#define DC_SPL_PAPERNAMES   0xFFFF
#define DC_SPL_MEDIAREADY   0xFFFE


#ifdef DBG

LPSTR   pDCCaps[] = {

            "FIELDS",
            "PAPERS",
            "PAPERSIZE",
            "MINEXTENT",
            "MAXEXTENT",
            "BINS",
            "DUPLEX",
            "SIZE",
            "EXTRA",
            "VERSION",
            "DRIVER",
            "BINNAMES",
            "ENUMRESOLUTIONS",
            "FILEDEPENDENCIES",
            "TRUETYPE",
            "PAPERNAMES",
            "ORIENTATION",
            "COPIES",

            //
            // 4.00
            //

            "BINADJUST",
            "EMF_COMPLIANT",
            "DATATYPE_PRODUCED",
            "COLLATE",
            "MANUFACTURER",
            "MODEL",

            //
            // 5.00
            //

            "PERSONALITY",
            "PRINTRATE",
            "PRINTRATEUNIT",
            "PRINTERMEM",
            "MEDIAREADY",
            "STAPLE",
            "PRINTRATEPPM",
            "COLORDEVICE",
            "NUP",
            "NULL"
        };

#endif





INT
CALLBACK
DevCapEnumFormProc(
    PFORM_INFO_1       pFI1,
    DWORD              Index,
    PENUMFORMPARAM     pEFP
    )

/*++

Routine Description:

    This is callback function from PlotEnumForm()

Arguments:

    pFI1    - pointer to the current FORM_INFO_1 data structure passed

    Index   - pFI1 index related to the pFI1Base (0 based)

    pEFP    - Pointer to the EnumFormParam


Return Value:

    > 0: Continue enumerate the next
    = 0: Stop enumerate, but keep the pFI1Base when return from PlotEnumForms
    < 0: Stop enumerate, and free pFI1Base memory

    the form enumerate will only the one has FI1F_VALID_SIZE bit set in the
    flag field, it also call one more time with pFI1 NULL to give the callback
    function a chance to free the memory (by return < 0)

Author:

    03-Dec-1993 Fri 23:00:25 created  

    27-Jan-1994 Thu 16:06:00 updated  
        Fixed the pptOutput which we did not increment the pointer

    12-Jul-1994 Tue 12:47:22 updated  
        Move paper tray checking into the PlotEnumForms() itselft


Revision History:


--*/

{
#define pwOutput    ((WORD *)pEFP->pCurForm)
#define pptOutput   ((POINT *)pEFP->pCurForm)
#define pwchOutput  ((WCHAR *)pEFP->pCurForm)
#define DeviceCap   (pEFP->ReqIndex)


    if (!pwOutput) {

        PLOTASSERT(0, "DevCapEnumFormProc(DevCaps=%ld) pvOutput=NULL",
                        pwOutput, DeviceCap);
        return(0);
    }

    if (!pFI1) {

        //
        // extra call, or no pvOutput, return a -1 to free memory for pFI1Base
        // We want to add the custom paper size so that application know we
        // supports that
        //

        switch (DeviceCap) {

        case DC_PAPERNAMES:

            LoadString(hPlotUIModule,
                       IDS_USERFORM,
                       pwchOutput,
                       CCHPAPERNAME);

            PLOTDBG(DBG_DEVCAPS_1, ("!!! Extra FormName = %s", pwchOutput));

            break;

        case DC_PAPERS:

            *pwOutput = (WORD)DMPAPER_USER;

            PLOTDBG(DBG_DEVCAPS_1, ("!!! Extra FormID = %ld", *pwOutput));

            break;

        case DC_PAPERSIZE:

            //
            // I'm not sure we should return POINT or POINTS structure here, what
            // is Window 3.1 do, because at here we return as dmPaperWidth and
            // dmPaperLength, these fields only as a SHORT (16 bits), we will do
            // win32 documentation said, POINT (32-bit version)
            //
            //
            // Return custom paper sizes as 8.5" x 11"
            //

            pptOutput->x = (LONG)2159;
            pptOutput->y = (LONG)2794;

            PLOTDBG(DBG_DEVCAPS_1, ("!!! Extra FormSize = %ld x %ld",
                        pptOutput->x, pptOutput->y));

            break;
        }

        return(-1);
    }

    switch (DeviceCap) {

    case DC_PAPERNAMES:
    case DC_MEDIAREADY:

        _WCPYSTR(pwchOutput, pFI1->pName, CCHPAPERNAME);
        pwchOutput += CCHPAPERNAME;
        break;

    case DC_PAPERS:

        *pwOutput++ = (WORD)(Index + DMPAPER_FIRST);
        break;

    case DC_PAPERSIZE:

        //
        // I'm not sure we should return POINT or POINTS structure here, what
        // is Window 3.1 do, because at here we return as dmPaperWidth and
        // dmPaperLength, these fields only as a SHORT (16 bits), we will do
        // win32 documentation said, POINT (32-bit version)
        //

        pptOutput->x = (LONG)SPLTODM(pFI1->Size.cx);
        pptOutput->y = (LONG)SPLTODM(pFI1->Size.cy);
        pptOutput++;
        break;
    }

    return(1);

#undef DeviceCap
#undef pwOutput
#undef pptOutput
#undef pwchOutput
}



DWORD
WINAPI
DrvDeviceCapabilities(
    HANDLE  hPrinter,
    LPWSTR  pwDeviceName,
    WORD    DeviceCap,
    VOID    *pvOutput,
    DEVMODE *pDM
    )

/*++

Routine Description:




Arguments:

    hPrinter        - handle the to specific printer.

    pwDeviceName    - pointer to the device name

    DeviceCap       - specific capability to get.

    pvOutput        - Pointer to the output buffer

    pDM             - Ponter to the input DEVMODE


Return Value:

    DWORD   depends on the DeviceCap


Author:

    02-Dec-1993 Thu 16:50:36 created  

    05-Jan-1994 Wed 23:35:19 updated  
        Replace PLOTTER_UNIT_DPI with pPlotGPC->PlotXDPI, pPlotGPC->PlotYDPI,

    06-Jan-1994 Thu 13:10:11 updated  
        Change RasterDPI always be the resoluton reports back to the apps


Revision History:


--*/

{
#define pbOutput    ((BYTE *)pvOutput)
#define psOutput    ((SHORT *)pvOutput)
#define pwOutput    ((WORD *)pvOutput)
#define pptOutput   ((POINT *)pvOutput)
#define pwchOutput  ((WCHAR *)pvOutput)
#define pdwOutput   ((DWORD *)pvOutput)
#define plOutput    ((LONG *)pvOutput)
#define pptsdwRet   ((POINTS *)&dwRet)


    PPRINTERINFO    pPI;
    ENUMFORMPARAM   EnumFormParam;
    DWORD           dwRet;

    ZeroMemory(&EnumFormParam, sizeof(ENUMFORMPARAM));

    //
    // The MapPrinter will allocate memory, set default devmode, reading and
    // validating the GPC then update from current pritner registry, it also
    // will cached the PlotGPC.
    //

    if (!(pPI = MapPrinter(hPrinter,
                           (PPLOTDEVMODE)pDM,
                           NULL,
                           (DeviceCap == DC_MEDIAREADY) ?
                                            MPF_DEVICEDATA : 0))) {

        PLOTERR(("DrvDeviceCapabilities: MapPrinter() failed"));
        return(GDI_ERROR);
    }

    //
    // Start checking DeviceCap now, set dwRet to 0 first for anything we do
    // not support.  We can do return() at any point in this function because
    // we use cached PI, and it will get destroy when the this module
    // get unloaded.
    //

    EnumFormParam.cMaxOut = 0x7FFFFFFF;
    dwRet                 = 0;

    switch (DeviceCap) {

    case DC_BINNAMES:
    case DC_BINS:

        //
        // For current plotter, it always only have ONE bin
        //

        if (pvOutput) {

            if (DeviceCap == DC_BINS) {

                *pwOutput = DMBIN_ONLYONE;

            } else {

                if (pPI->pPlotGPC->Flags & PLOTF_ROLLFEED) {

                    dwRet = IDS_ROLLFEED;

                } else {

                    dwRet = IDS_MAINFEED;
                }

                LoadString(hPlotUIModule, dwRet, pwchOutput, CCHBINNAME);
            }
        }

        dwRet = 1;

        break;

    case DC_COPIES:

        dwRet = (DWORD)pPI->pPlotGPC->MaxCopies;

        break;

    case DC_DRIVER:

        dwRet = (DWORD)pPI->PlotDM.dm.dmDriverVersion;

        break;

    case DC_COLLATE:
    case DC_DUPLEX:

        //
        // plotter now have no duplex support or collation support
        //

        break;

    case DC_ENUMRESOLUTIONS:

        //
        // We only have one resolution setting which will be RasterXDPI and
        // RasterYDPI in the GPC data for the raster able plotter, for pen
        // plotter now we returned pPlotGPC->PlotXDPI, pPlotGPC->PlotYDPI
        //
        // The RasterDPI will be used for raster printer resolution, for pen
        // plotter this is the GPC's ideal resolution
        //
        //
        // We will return not supported (dwRet=0) so that application will not
        // use this to set the DEVMODE's print quality and use the DMRES_XXXX
        // as print qualities which is use by us to send to the plotter
        //

        //
        // 26-Mar-1999 Fri 09:43:38 updated  
        //  We will return one pair of current PlotXDPI, PlotYDPI for DS
        //

        if (pdwOutput) {

            if (pPI->pPlotGPC->Flags & PLOTF_RASTER) {

                pdwOutput[0] = (DWORD)pPI->pPlotGPC->RasterXDPI;
                pdwOutput[1] = (DWORD)pPI->pPlotGPC->RasterYDPI;

            } else {

                pdwOutput[0] = (DWORD)pPI->pPlotGPC->PlotXDPI;
                pdwOutput[1] = (DWORD)pPI->pPlotGPC->PlotYDPI;
            }
        }

        dwRet = 1;
        break;

    case DC_EXTRA:

        dwRet = (DWORD)pPI->PlotDM.dm.dmDriverExtra;
        break;

    case DC_FIELDS:

        dwRet = (DWORD)pPI->PlotDM.dm.dmFields;
        break;

    case DC_FILEDEPENDENCIES:

        //
        // we are supposed to fill in an array of 64 character filenames,
        // this will include the DataFileName, HelpFileName and UIFileName
        // but, if we are to be of any use, we would need to use the
        // fully qualified pathnames, and 64 characters is probably not
        // enough

        if (pwchOutput) {

            *pwchOutput = (WCHAR)0;
        }

        break;

    case DC_MAXEXTENT:

        //
        // This is real problem, the document said that we return a POINT
        // structure but a POINT structure here contains 2 LONGs, so for
        // Windows 3.1 compatibility reason we return a POINTS structure, if device have
        // variable length paper support then return 0x7fff as Window 3.1
        // because a maximum positive number in POINTS is 0x7fff, this number
        // will actually only allowed us to support the paper length up to
        // 10.75 feet.
        //

        pptsdwRet->x = SPLTODM(pPI->pPlotGPC->DeviceSize.cx);

        if (pPI->pPlotGPC->DeviceSize.cy >= 3276700) {

            pptsdwRet->y = 0x7fff;      // 10.75" maximum.

        } else {

            pptsdwRet->y = SPLTODM(pPI->pPlotGPC->DeviceSize.cy);
        }

        break;

    case DC_MINEXTENT:

        //
        // This is real problem, the document said that we return a POINT
        // structure but a POINT structure here contains 2 LONGs, so for Win3.1
        // compatibility reason we return a POINTS structure
        //

        pptsdwRet->x = MIN_DM_FORM_CX;
        pptsdwRet->y = MIN_DM_FORM_CY;

        break;

    case DC_ORIENTATION:

        //
        // We always rotate the page to the left 90 degree from the user's
        // perspective
        //

        dwRet = 90;

        break;


    case DC_SPL_PAPERNAMES:

        if (!pvOutput) {

            PLOTERR(("DrvDeviceCapabilities: Spool's DC_PAPERNAMES, pvOutput=NULL"));
            dwRet = (DWORD)GDI_ERROR;
            break;
        }

        EnumFormParam.cMaxOut = pdwOutput[0];
        DeviceCap             = DC_PAPERNAMES;

        //
        // Fall through
        //

    case DC_PAPERNAMES:
    case DC_PAPERS:
    case DC_PAPERSIZE:

        //
        // One of the problem here is we can cached the FORM_INFO_1 which
        // enum through spooler, because in between calls the data could
        // changed, such as someone add/delete form through the printman, so
        // at here we always free (LocalAlloc() used in PlotEnumForms) the
        // memory afterward
        //

        EnumFormParam.pPlotDM  = &(pPI->PlotDM);
        EnumFormParam.pPlotGPC = pPI->pPlotGPC;
        EnumFormParam.ReqIndex = DeviceCap;
        EnumFormParam.pCurForm = (PFORMSIZE)pvOutput;

        if (!PlotEnumForms(hPrinter, DevCapEnumFormProc, &EnumFormParam)) {

            PLOTERR(("DrvDeviceCapabilities: PlotEnumForms() failed"));
            dwRet = GDI_ERROR;

        } else {

            dwRet = EnumFormParam.ValidCount;
        }

        break;

    case DC_SIZE:

        dwRet = (DWORD)pPI->PlotDM.dm.dmSize;

        break;

    case DC_TRUETYPE:

        //
        // For now we do not return anything, because we draw truetype font
        // as truetype (ie. line/curve segment), if we eventually doing ATM or
        // bitmap truetype download then we will return DCFF_BITMAP but for
        // now return 0
        //

        break;

    case DC_VERSION:

        dwRet = (DWORD)pPI->PlotDM.dm.dmSpecVersion;

        break;

    case DC_PERSONALITY:

        if (pwchOutput) {

            //
            // DDK says an array of string buffers, each 32 characters in length.
            //
            _WCPYSTR(pwchOutput, L"HP-GL/2", 32);
        }

        dwRet = 1;
        break;

    case DC_COLORDEVICE:

        dwRet = (pPI->pPlotGPC->Flags & PLOTF_COLOR) ? 1 : 0;
        break;

    case DC_SPL_MEDIAREADY:

        if (!pwchOutput) {

            PLOTERR(("DrvDeviceCapabilities: Spool's DC_MEDIAREADY, pwchOutput=NULL"));
            dwRet = (DWORD)GDI_ERROR;
            break;
        }

        EnumFormParam.cMaxOut = pdwOutput[0];

        //
        // Fall through for DC_MEDIAREADY
        //

    case DC_MEDIAREADY:

        PLOTDBG(DBG_DEVCAPS_0,
                ("DevCaps(DC_MEDIAREADY:pvOut=%p): CurPaper=%ws, %ldx%ld",
                        pwchOutput, pPI->CurPaper.Name,
                        pPI->CurPaper.Size.cx, pPI->CurPaper.Size.cy));

        if (pPI->CurPaper.Size.cy) {

            //
            // Non Roll Paper
            //

            dwRet = 1;

            if (pwchOutput) {

                if (EnumFormParam.cMaxOut >= 1) {

                    _WCPYSTR(pwchOutput, pPI->CurPaper.Name, CCHPAPERNAME);

                } else {

                    dwRet = 0;
                }
            }

        } else {

            //
            // Roll Paper Installed
            //

            EnumFormParam.pPlotDM  = &(pPI->PlotDM);
            EnumFormParam.pPlotGPC = pPI->pPlotGPC;
            EnumFormParam.ReqIndex = DC_MEDIAREADY;
            EnumFormParam.pCurForm = (PFORMSIZE)pvOutput;

            if (!PlotEnumForms(hPrinter, DevCapEnumFormProc, &EnumFormParam)) {

                PLOTERR(("DrvDeviceCapabilities: PlotEnumForms() failed"));
                dwRet = GDI_ERROR;

            } else {

                //
                // Remove Custom paper size
                //

                dwRet = EnumFormParam.ValidCount - 1;
            }
        }

        break;

    case DC_STAPLE:
    case DC_NUP:

        break;

    default:

        //
        // something is wrong here
        //

        PLOTERR(("DrvDeviceCapabilities: Invalid DeviceCap (%ld) passed.",
                                                                    DeviceCap));
        dwRet = (DWORD)GDI_ERROR;
    }

    PLOTDBG(DBG_DEVCAPS_0,
            ("DrvDeviceCapabilities: DC_%hs, pvOut=%p, dwRet=%ld",
                        pDCCaps[DeviceCap-1], (DWORD_PTR)pvOutput, dwRet));

    UnMapPrinter(pPI);

    return(dwRet);


#undef pbOutput
#undef psOutput
#undef pwOutput
#undef pptOutput
#undef pwchOutput
#undef pdwOutput
#undef plOutput
#undef pptsdwRet
}



DWORD
DrvSplDeviceCaps(
    HANDLE  hPrinter,
    LPWSTR  pwDeviceName,
    WORD    DeviceCap,
    VOID    *pvOutput,
    DWORD   cchBuf,
    DEVMODE *pDM
    )

/*++

Routine Description:

    This function supports the querrying of device capabilities.

Arguments:

    hPrinter        - handle the to specific printer.

    pwDeviceName    - pointer to the device name

    DeviceCap       - specific capability to get.

    pvOutput        - Pointer to the output buffer

    cchBuf          - Count of character for the pvOutput

    pDM             - Ponter to the input DEVMODE


Return Value:

    DWORD   depends on the DeviceCap


Revision History:


--*/

{

    switch (DeviceCap) {

    case DC_PAPERNAMES:
    case DC_MEDIAREADY:

        if (pvOutput) {

            if (cchBuf >= CCHPAPERNAME) {

                DeviceCap            = (DeviceCap == DC_PAPERNAMES) ?
                                                            DC_SPL_PAPERNAMES :
                                                            DC_SPL_MEDIAREADY;
                *((LPDWORD)pvOutput) = (DWORD)(cchBuf / CCHPAPERNAME);

                PLOTDBG(DBG_DEVCAPS_0,
                        ("SplDeviceCap: DC_SPL_MEDIAREADY, cchBuf=%ld (%ld)",
                            cchBuf, *((LPDWORD)pvOutput)));

            } else {

                return(GDI_ERROR);
            }
        }

        return(DrvDeviceCapabilities(hPrinter,
                                     pwDeviceName,
                                     DeviceCap,
                                     pvOutput,
                                     pDM));
        break;

    default:

        return(GDI_ERROR);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\formbox.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    formbox.h


Abstract:

    This module contains FORM's COMBO box add/list/retrieve functions


Author:

    09-Dec-1993 Thu 16:07:35 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _LISTFORM_
#define _LISTFORM_


#define FS_ROLLPAPER    1
#define FS_TRAYPAPER    2

BOOL
GetFormSelect(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem
    );

UINT
CreateFormOI(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData
    );

BOOL
AddFormsToDataBase(
    PPRINTERINFO    pPI,
    BOOL            DeleteFirst
    );

#endif  // _LISTFORM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\formbox.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    formbox.c


Abstract:

    This module contains functions to enumerate valid form and list on the
    combo box


Author:

    09-Dec-1993 Thu 14:31:44 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgFormBox

#define DBG_FORMS           0x00000001
#define DBG_TRAY            0x00000002
#define DBG_PERMISSION      0x00000004


DEFINE_DBGVAR(0);

WCHAR   wszModel[] = L"Model";




BOOL
GetFormSelect(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem
    )

/*++

Routine Description:

    This function retrieve the form selected by the user from the combo
    box

Arguments:

    pPI         - Pointer to the PRINTERINFO

    pOptItem    - Pointer to the FORM's OPTITEM

Return Value:

    TRUE if sucessful and pPI will be set correctly, FALSE if error occurred

Author:

    09-Dec-1993 Thu 14:44:18 created  

    18-Dec-1993 Sat 03:55:30 updated  
        Changed dmFields setting for the PAPER, now we will only set the
        DM_FORMNAME field, this way the returned document properties will be
        always in known form even user defines many forms in spooler.

    06-Nov-1995 Mon 12:56:00 updated  
        Re-write for the New UI

Revision History:


--*/

{
    PAPERINFO   CurPaper;
    POPTPARAM   pOptParam;


    pOptParam = pOptItem->pOptType->pOptParam + pOptItem->Sel;

    if (pOptParam->Style == FS_ROLLPAPER) {

        PFORMSRC    pFS;

        //
        // This was added from the GPC data for the roll feed
        //

        PLOTASSERT(0, "GetComboBoxSelForm: INTERNAL ERROR, ROLLPAPER In document properties",
                            !(pPI->Flags & PIF_DOCPROP), 0);
        PLOTASSERT(0, "GetComboBoxSelForm: INTERNAL ERROR, device CANNOT have ROLLPAPER",
                            pPI->pPlotGPC->Flags & PLOTF_ROLLFEED, 0);

        PLOTDBG(DBG_FORMS,
                ("Roll Feed Paper is selected, (%ld)", pOptParam->lParam));

        if (pOptParam->lParam < (LONG)pPI->pPlotGPC->Forms.Count) {

            pFS = (PFORMSRC)pPI->pPlotGPC->Forms.pData + pOptParam->lParam;

            //
            // Since the RollFeed paper has variable length, and the cy is set
            // to zero at GPC data, we must take that into account
            //

            CurPaper.Size             = pFS->Size;
            CurPaper.ImageArea.left   = pFS->Margin.left;
            CurPaper.ImageArea.top    = pFS->Margin.top;
            CurPaper.ImageArea.right  = CurPaper.Size.cx -
                                                        pFS->Margin.right;
            CurPaper.ImageArea.bottom = pPI->pPlotGPC->DeviceSize.cy -
                                                        pFS->Margin.bottom;
            str2Wstr(CurPaper.Name, CCHOF(CurPaper.Name), pFS->Name);

        } else {

            PLOTERR(("GetComboBoxSelForm: Internal Error, Invalid lParam=%ld",
                     pOptParam->lParam));
            return(FALSE);
        }

    } else {

        FORM_INFO_1 *pFI1;
        DWORD       cb;

        //
        // This form is in the form data base
        //

        pFI1 = pPI->pFI1Base + pOptParam->lParam;

        CurPaper.Size      = pFI1->Size;
        CurPaper.ImageArea = pFI1->ImageableArea;

        WCPYFIELDNAME(CurPaper.Name, pFI1->pName);
    }

    //
    // Now we have current paper validated
    //

    if (pPI->Flags & PIF_DOCPROP) {

        //
        // Turn off first, then turn on paper fields as needed
        //

        pPI->PlotDM.dm.dmFields &= ~DM_PAPER_FIELDS;
        pPI->PlotDM.dm.dmFields |= (DM_FORMNAME | DM_PAPERSIZE);

        //
        // Copy down the dmFormName, dmPaperSize and set dmPaperWidth/Length,
        // the fields for PAPER will bb set to DM_FORMNAME so that we always
        // can find the form also we may set DM_PAPERSIZE if index number is
        // <= DMPAPER_LAST
        //

        WCPYFIELDNAME(pPI->PlotDM.dm.dmFormName, CurPaper.Name);

        pPI->PlotDM.dm.dmPaperSize   = (SHORT)(pOptParam->lParam +
                                                            DMPAPER_FIRST);
        pPI->PlotDM.dm.dmPaperWidth  = SPLTODM(CurPaper.Size.cx);
        pPI->PlotDM.dm.dmPaperLength = SPLTODM(CurPaper.Size.cy);

#if DBG
        *(PRECTL)&pPI->PlotDM.dm.dmBitsPerPel = CurPaper.ImageArea;
#endif

    } else {

        pPI->CurPaper = CurPaper;
    }

    PLOTDBG(DBG_FORMS, ("*** GetComboBoxSelForm from COMBO = '%s'", CurPaper.Name));
    PLOTDBG(DBG_FORMS, ("Size=%ld x %ld", CurPaper.Size.cx, CurPaper.Size.cy));
    PLOTDBG(DBG_FORMS, ("ImageArea=(%ld, %ld) - (%ld, %ld)",
                         CurPaper.ImageArea.left,   CurPaper.ImageArea.top,
                         CurPaper.ImageArea.right,  CurPaper.ImageArea.bottom));

    return(TRUE);
}




UINT
CreateFormOI(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData
    )

/*++

Routine Description:

    This function add the available forms to the combo box, it will optionally
    add the roll feed type of form


Arguments:

    pPI         - Pointer to the PRINTERINFO data structure

    pOptItem    - Pointer to the FORM's OPTITEM

    pOIData     - Pointer to the OIDATA structure

Return Value:

    The form selected, a netavie number means error

Author:

    09-Dec-1993 Thu 14:35:59 created  

    06-Nov-1995 Mon 12:56:24 updated  
        Re-write for the New UI

Revision History:


--*/

{
    LPWSTR          pwSelName;
    POPTPARAM       pOptParam;
    PFORM_INFO_1    pFI1;
    PFORMSRC        pFS;
    ENUMFORMPARAM   EFP;
    DWORD           i;
    LONG            Sel;
    DWORD           cRollPaper;
    EXTRAINFO       EI;


    if (!pOptItem) {

        return(1);
    }

    pwSelName = (LPWSTR)((pPI->Flags & PIF_DOCPROP) ?
                            pPI->PlotDM.dm.dmFormName : pPI->CurPaper.Name);

    PLOTDBG(DBG_FORMS, ("Current Form: <%ws>", pwSelName));

    EFP.pPlotDM  = &(pPI->PlotDM);
    EFP.pPlotGPC = pPI->pPlotGPC;

    if (!PlotEnumForms(pPI->hPrinter, NULL, &EFP)) {

        PLOTERR(("CreateFormOI: PlotEnumForms() failed"));
        return(0);
    }

    cRollPaper = 0;

    if ((!(pPI->Flags & PIF_DOCPROP)) &&
        (pPI->pPlotGPC->Flags & PLOTF_ROLLFEED)) {

        //
        // Add device' roll paper to the combo box too.
        //

        PLOTDBG(DBG_FORMS, ("Device support ROLLFEED so add RollPaper if any"));

        for (i= 0, pFS = (PFORMSRC)pPI->pPlotGPC->Forms.pData;
             i < (DWORD)pPI->pPlotGPC->Forms.Count;
             i++, pFS++) {

            if (!pFS->Size.cy) {

                ++cRollPaper;
            }
        }
    }

    PLOTDBG(DBG_FORMS, ("Valid Count is %ld [%ld + %ld] out of %ld",
                            EFP.ValidCount + cRollPaper,
                            EFP.ValidCount, cRollPaper, EFP.Count));

    EI.Size = (DWORD)(cRollPaper * (sizeof(WCHAR) * CCHFORMNAME));

    if (!CreateOPTTYPE(pPI,
                       pOptItem,
                       pOIData,
                       EFP.ValidCount + cRollPaper,
                       &EI)) {

        LocalFree((HLOCAL)EFP.pFI1Base);
        return(0);
    }

    pPI->pFI1Base             = EFP.pFI1Base;
    pOptItem->pOptType->Style = OTS_LBCB_SORT;
    pOptParam                 = pOptItem->pOptType->pOptParam;

    for (i = 0, Sel = 0, pFI1 = EFP.pFI1Base; i < EFP.Count; i++, pFI1++) {

        if (pFI1->Flags & FI1F_VALID_SIZE) {

            pOptParam->cbSize = sizeof(OPTPARAM);
            pOptParam->Style  = (pPI->pPlotGPC->Flags & PLOTF_PAPERTRAY) ?
                                                            FS_TRAYPAPER : 0;
            pOptParam->pData  = pFI1->pName;
            pOptParam->IconID = (pFI1->Flags & FI1F_ENVELOPE) ?
                                    IDI_CPSUI_ENVELOPE : IDI_CPSUI_STD_FORM;
            pOptParam->lParam = (LONG)i;

            if (!lstrcmp(pwSelName, pOptParam->pData)) {

                pOptItem->Sel = Sel;
            }

            pOptParam++;
            Sel++;
        }
    }

    if (cRollPaper) {

        LPWSTR  pwStr = (LPWSTR)EI.pData;
        size_t  cchpwStr = EI.Size / sizeof(WCHAR);

        //
        // Add device' roll paper to the combo box too.
        //

        for (i = 0, pFS = (PFORMSRC)pPI->pPlotGPC->Forms.pData;
             i < (DWORD)pPI->pPlotGPC->Forms.Count;
             i++, pFS++) {

            if (!(pFS->Size.cy)) {

                //
                // Got one, we have to translated into the UNICODE first
                //

                pOptParam->cbSize = sizeof(OPTPARAM);
                pOptParam->Style   = FS_ROLLPAPER;
                pOptParam->pData   = (LPTSTR)pwStr;
                pwStr             += CCHFORMNAME;
                cchpwStr          -= CCHFORMNAME;
                pOptParam->IconID  = IDI_ROLLPAPER;
                pOptParam->lParam  = (LONG)i;

                str2Wstr(pOptParam->pData, cchpwStr, pFS->Name);

                if (!lstrcmp(pwSelName, pOptParam->pData)) {

                    pOptItem->Sel = Sel;
                }

                pOptParam++;
                Sel++;
            }
        }
    }

    return(1);
}



BOOL
AddFormsToDataBase(
    PPRINTERINFO    pPI,
    BOOL            DeleteFirst
    )

/*++

Routine Description:

    This function add driver supports forms to the data base

Arguments:

    pPI - Pointer to the PRINTERINFO


Return Value:

    BOOLEAN


Author:

    09-Dec-1993 Thu 22:38:27 created  

    27-Apr-1994 Wed 19:18:58 updated  
        Fixed bug# 13592 which printman/spooler did not call ptrprop first but
        docprop so let us into unknown form database state,

Revision History:


--*/

{
    WCHAR       wName[CCHFORMNAME + 2];
    BOOL        bRet;
    LONG        i;
    DWORD       Type;


    Type = REG_SZ;

    if ((GetPrinterData(pPI->hPrinter,
                        wszModel,
                        &Type,
                        (LPBYTE)wName,
                        sizeof(wName),
                        &i) == ERROR_SUCCESS) &&
        (wcscmp(pPI->PlotDM.dm.dmDeviceName, wName))) {

        PLOTDBG(DBG_FORMS, ("Already added forms to the data base for %s",
                                                pPI->PlotDM.dm.dmDeviceName));
        return(TRUE);
    }

    //
    // Find out if we have permission to do this
    //

    if (SetPrinterData(pPI->hPrinter,
                       wszModel,
                       REG_SZ,
                       (LPBYTE)pPI->PlotDM.dm.dmDeviceName,
                       (wcslen(pPI->PlotDM.dm.dmDeviceName) + 1) *
                                            sizeof(WCHAR)) == ERROR_SUCCESS) {

        PFORMSRC    pFS;
        FORM_INFO_1 FI1;

        //
        // We have permission to update the registry so do it now
        //

        pPI->Flags |= PIF_UPDATE_PERMISSION;

        PLOTDBG(DBG_PERMISSION,
                ("!!! MODEL NAME: '%s' not Match, Re-installed Form Database",
                                            pPI->PlotDM.dm.dmDeviceName));

        //
        // Add the driver supportes forms to the system spooler data base if
        // not yet done so
        //

        FI1.pName = wName;

        for (i = 0, pFS = (PFORMSRC)pPI->pPlotGPC->Forms.pData;
             i < (LONG)pPI->pPlotGPC->Forms.Count;
             i++, pFS++) {

            //
            // We will only add the non-roll paper forms
            //

            if (pFS->Size.cy) {

                str2Wstr(wName, CCHOF(wName), pFS->Name);

                //
                // Firstable we will delete the same name form in the data
                // base first, this will ensure we have our curent user defined
                // form can be installed
                //

                if (DeleteFirst) {

                    DeleteForm(pPI->hPrinter, wName);
                }

                FI1.Size                 = pFS->Size;
                FI1.ImageableArea.left   = pFS->Margin.left;
                FI1.ImageableArea.top    = pFS->Margin.top;
                FI1.ImageableArea.right  = FI1.Size.cx - pFS->Margin.right;
                FI1.ImageableArea.bottom = FI1.Size.cy - pFS->Margin.bottom;

                PLOTDBG(DBG_FORMS, (
                        "AddForm: %s-[%ld x %ld] (%ld, %ld)-(%ld, %ld)",
                        FI1.pName, FI1.Size.cx, FI1.Size.cy,
                        FI1.ImageableArea.left, FI1.ImageableArea.top,
                        FI1.ImageableArea.right,FI1.ImageableArea.bottom));

                FI1.Flags = FORM_PRINTER;

                if ((!AddForm(pPI->hPrinter, 1, (LPBYTE)&FI1))  &&
                    (GetLastError() != ERROR_FILE_EXISTS)       &&
                    (GetLastError() != ERROR_ALREADY_EXISTS)) {

                    bRet = FALSE;
                    PLOTERR(("AddFormsToDataBase: AddForm(%s) failed, [%ld]",
                                        wName, GetLastError()));
                }
            }
        }

        return(TRUE);

    } else {

        pPI->Flags &= ~PIF_UPDATE_PERMISSION;

        PLOTDBG(DBG_PERMISSION, ("AddFormsToDataBase(): NO UPDATE PERMISSION"));

        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\pensetup.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    pensetup.h


Abstract:

    This module contains definitions for pen setup


Author:

    09-Dec-1993 Thu 19:38:33 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PENSETUP_
#define _PENSETUP_

POPTITEM
SavePenSet(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem
    );

UINT
CreatePenSetupOI(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData
    );

#endif  // _PENSETUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\plotui.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotinit.c


Abstract:

    This module contains plotter UI dll entry point



Development History:

    18-Nov-1993 Thu 07:12:52 created  

    01-Nov-1995 Wed 10:29:33 updated  
        Re-write for the SUR common UI

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPlotUI


#define DBG_PROCESS_ATTACH  0x00000001
#define DBG_PROCESS_DETACH  0x00000002

DEFINE_DBGVAR(0);




#if DBG
TCHAR   DebugDLLName[] = TEXT("PLOTUI");
#endif


HMODULE     hPlotUIModule = NULL;



BOOL
DllMain(
    HINSTANCE   hModule,
    DWORD       Reason,
    LPVOID      pReserved
    )

/*++

Routine Description:

    This is the DLL entry point


Arguments:

    hMoudle     - handle to the module for this function

    Reason      - The reason called

    pReserved   - Not used, do not touch


Return Value:

    BOOL, we will always return ture and never failed this function


Development History:

    15-Dec-1993 Wed 15:05:56 updated  
        Add the DestroyCachedData()

    18-Nov-1993 Thu 07:13:56 created  


Revision History:


--*/

{

    UNREFERENCED_PARAMETER(pReserved);

    switch (Reason) {

    case DLL_PROCESS_ATTACH:

        PLOTDBG(DBG_PROCESS_ATTACH,
                ("PlotUIDLLEntryFunc: DLL_PROCESS_ATTACH: hModule = %08lx",
                                                                    hModule));
        hPlotUIModule = hModule;

        //
        // Initialize GPC data cache
        //

        if (!InitCachedData())
            return FALSE;

        break;

    case DLL_PROCESS_DETACH:

        //
        // Free up all the memory used by this module
        //

        PLOTDBG(DBG_PROCESS_DETACH,
                ("PlotUIDLLEntryFunc: DLL_PROCESS_DETACH Destroy CACHED Data"));

        DestroyCachedData();
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\pensetup.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    pensetup.c


Abstract:

    This module contains modules to setup the pen


Author:

    09-Dec-1993 Thu 19:38:19 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPenSetup


extern HMODULE  hPlotUIModule;


#define DBG_PENSETUP        0x00000001
#define DBG_HELP            0x00000002
#define DBG_COLOR_CHG       0x00000004
#define DBG_THICK_CHG       0x00000008

DEFINE_DBGVAR(0);

//
//  Installed Pen Set: <Pen Set #1>
//  Pen Setup:
//      Pen Set #1: <Currently Installed>
//          Pen Number 1:
//          Pen Number 2:
//          Pen Number 3:
//          Pen Number 4:
//          Pen Number 5:
//          Pen Number 6:
//          Pen Number 7:
//          Pen Number 8:
//          Pen Number 9:
//          Pen Number 10:
//          Pen Number 11:
//      Pen Set #2;
//      Pen Set #3:
//      Pen Set #4: (Currently Installed>
//      Pen Set #5:
//      Pen Set #6:
//      Pen Set #7:
//      Pen Set #8:
//

EXTPUSH PenSetExtPush = {

            sizeof(EXTPUSH),
            EPF_NO_DOT_DOT_DOT,
            (LPTSTR)IDS_DEFAULT_PENCLR,
            NULL,
            IDI_DEFAULT_PENCLR,
            0
        };


OIDATA  OIPenSet = {

            ODF_PEN | ODF_COLLAPSE | ODF_CALLBACK,
            0,
            OI_LEVEL_2,
            PP_PENSET,
            TVOT_NONE,
            IDS_PENSET_FIRST,
            IDI_PENCLR,
            IDH_PENSET,
            0,
            NULL
        };

OPDATA  OPPenClr = { 0, IDS_COLOR_FIRST, IDI_COLOR_FIRST, 0, 0, 0 };

OIDATA  OIPenNum = {

            ODF_PEN | ODF_COLLAPSE |
                    ODF_INC_IDSNAME | ODF_INC_ICONID | ODF_NO_INC_POPDATA,
            0,
            OI_LEVEL_3,
            PP_PEN_NUM,
            TVOT_LISTBOX,
            IDS_PEN_NUM,
            OTS_LBCB_SORT,
            IDH_PEN_NUM,
            0,
            &OPPenClr
        };




POPTITEM
SavePenSet(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Nov-1995 Mon 18:52:15 created  


Revision History:


--*/

{
    PPENDATA    pPenData;
    UINT        MaxPens;
    UINT        i;


    pPenData = PI_PPENDATA(pPI);
    MaxPens  = (UINT)pPI->pPlotGPC->MaxPens;
    pOptItem++;

    for (i = 0; i < PRK_MAX_PENDATA_SET; i++) {

        UINT    cPens;
        BOOL    SavePen;

        //
        // Must skip the header
        //

        pOptItem++;
        cPens   = MaxPens;
        SavePen = FALSE;

        while (cPens--) {

            if (pOptItem->Flags & OPTIF_CHANGEONCE) {

                pPenData->ColorIdx = (WORD)pOptItem->Sel;
                SavePen            = TRUE;
            }

            pOptItem++;
            pPenData++;
        }

        if (SavePen) {

            if (!SaveToRegistry(pPI->hPrinter,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                MAKELONG(i, MaxPens),
                                pPenData - MaxPens)) {

                PlotUIMsgBox(NULL, IDS_PP_NO_SAVE, MB_ICONSTOP | MB_OK);
            }
        }
    }

    return(pOptItem);
}




UINT
CreatePenSetupOI(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Nov-1995 Mon 16:23:36 created  


Revision History:


--*/

{
    PPENDATA    pPenData;
    POPTITEM    pOI;
    POPTITEM    pOIPen;
    POPTTYPE    pOTPen;
    EXTRAINFO   EI;
    UINT        i;
    UINT        j;
    UINT        MaxPens;
    UINT        cPenClr;
    WCHAR       Buf[128];
    DWORD       dwchSize;
    HRESULT     hr;

    MaxPens  = (UINT)pPI->pPlotGPC->MaxPens;
    cPenClr  = PC_IDX_TOTAL;

    if (!pOptItem) {

        return(((MaxPens + 1) * PRK_MAX_PENDATA_SET) + 1);
    }

    EI.Size  = (UINT)((LoadString(hPlotUIModule,
                                  IDS_PEN_NUM,
                                  Buf,
                                  (sizeof(Buf) / sizeof(WCHAR)) - 1)
                       + 5) * sizeof(WCHAR));
    dwchSize = EI.Size;
    pPenData = PI_PPENDATA(pPI);
    pOTPen   = NULL;
    pOIPen   = NULL;
    pOI      = pOptItem;

    //
    // First: Create PenSetup: HEADER
    //

    if (CreateOPTTYPE(pPI, pOI, pOIData, 0, NULL)) {

        pOI++;
    }

    //
    // Now Create Each pen set
    //

    for (i = (UINT)IDS_PENSET_FIRST; i <= (UINT)IDS_PENSET_LAST; i++) {

        if (CreateOPTTYPE(pPI, pOI, &OIPenSet, 0, NULL)) {

            pOI->pName     = (LPTSTR)UIntToPtr(i);
            pOI->Flags    |= OPTIF_EXT_IS_EXTPUSH;
            pOI->pExtPush  = &PenSetExtPush;
        }

        pOI++;

        for (j = 1; j <= MaxPens; j++, pOI++, pPenData++) {

            if (CreateOPTTYPE(pPI, pOI, &OIPenNum, cPenClr, &EI)) {

                if (pOTPen) {

                    pOI->pOptType = pOTPen;

                } else {

                    pOTPen  = pOI->pOptType;
                    cPenClr = 0;
                }

                if (pOIPen) {

                    pOI->pName = pOIPen->pName;
                    pOIPen++;

                } else {

                    pOI->pName = (LPTSTR)EI.pData;
                    hr = StringCchPrintfW(pOI->pName, dwchSize, L"%ws%u", Buf, j);
                }
            }

            pOI->Sel = pPenData->ColorIdx;
        }

        if (!pOIPen) {

            EI.Size = 0;
            pOIPen  = pOI;
        }

        pOIPen -= MaxPens;
    }

    return (UINT)(pOI - pOptItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\precomp.h ===
#define _WINDEFP_NO_PDEVBRUSH

#include <stddef.h>
#include <stdarg.h>
#include <windows.h>
#include <winddi.h>
#include <winspool.h>
#include <winddiui.h>
#include <strsafe.h>

#include <plotgpc.h>
#include <plotdm.h>
#include <plotters.h>
#include <plotlib.h>

#include "plotui.h"
#include "cpsui.h"

#include "formbox.h"
#include "help.h"
#include "pensetup.h"
#include "ptrinfo.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\ptrinfo.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    uituils.h


Abstract:

    This module contains the defines for UIUtils.c


Author:

    03-Dec-1993 Fri 21:35:50 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



#ifndef _PRINTER_INFO_
#define _PRINTER_INFO_


#define MPF_DEVICEDATA      0x00000001
#define MPF_HELPFILE        0x00000002
#define MPF_PCPSUI          0x00000004


PPRINTERINFO
MapPrinter(
    HANDLE          hPrinter,
    PPLOTDEVMODE    pPlotDMIn,
    LPDWORD         pdwErrIDS,
    DWORD           MPFlags
    );

VOID
UnMapPrinter(
    PPRINTERINFO    pPI
    );

LPBYTE
GetPrinterInfo(
    HANDLE  hPrinter,
    UINT    PrinterInfoLevel
    );

DWORD
GetPlotterIconID(
    PPRINTERINFO    pPI
    );


#endif  // _PRINTER_INFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\qryprint.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    qryprint.c


Abstract:

    This module contains functions called by the spoller to determine if a
    particular job can be print to a given printer



Development History:

    07-Dec-1993 Tue 00:48:24 created  


[Environment:]

    GDI Device Driver - Plotter.



--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgQryPrint

extern HMODULE  hPlotUIModule;


#define DBG_DEVQPRINT       0x00000001
#define DBG_FORMDATA        0x00000002

DEFINE_DBGVAR(0);


#define USER_PAPER          (DM_PAPERWIDTH | DM_PAPERLENGTH | DM_PAPERSIZE)
#define MAX_ERROR_CHARS     512



UINT
cdecl
DQPsprintf(
    HINSTANCE   hInst,
    LPWSTR      pwBuf,
    DWORD       cchBuf,
    LPDWORD     pcchNeeded,
    LPWSTR      pwszFormat,
    ...
    )

/*++

Routine Description:

    This fucntion output the debug informat to the debugger


Arguments:

    hInst       - handle to the driver's instance (hModule)

    pwBuf       - Pointer to the WCHAR buffer for the output

    cchBuf      - Count of characters pointed by the pwBuf, this includs
                  the NULL terminator

    pcchBuf     - pointer to the a DWORD to received total characteers needed
                  for pwBuf (includes null terminator).  If this pointer is
                  NULL then no data is returned.

    pwszFormat  - pointer to WCHAR format string, the introduce character is
                  '%' and it may followed by a format character of following

                    %c = a WCHAR
                    %s = Insert a unicode string.
                    %d = convert to long integer
                    %u = convert to DWORD
                    %x = Convert to lower case hex, 10 = a
                    %X = Convert to upper case hex, 10 = A
                    %! = Load the resource ID unicode string


    ...         - variable data, each one must be pushed as a 32-bit data


Return Value:

    Count of total characters put into the pwBuf. (not includes the null
    terminator).



Development History:

    08-Feb-1996 Thu 00:53:36 created  




--*/

{
#define MAX_CUR_TEXT_CHARS      256

    va_list vaList;
    LPWSTR  pwStrData;
    LPWSTR  pwEndBuf;
    LPWSTR  pwBufOrg;
    WCHAR   c;
    WCHAR   CurText[MAX_CUR_TEXT_CHARS];
    DWORD   cchNeeded, cchSize;
    UINT    i;
    static const LPWSTR pNumFmt[] = { L"%lX", L"%lx", L"%lu", L"%ld" };
    HRESULT hr;

    va_start(vaList, pwszFormat);

    //
    // pwEndBuf = the last character, cchNeeded is start with one since it
    // includes a null terminator
    //

    if (pwBufOrg = pwBuf) {

        pwEndBuf = (pwBuf + cchBuf - 1);

    } else {

        pwEndBuf = pwBuf;
    }

    cchNeeded = 1;

    while (c = *pwszFormat++) {

        pwStrData = NULL;
        cchSize = 0;
        i = 1;

        if (c == L'%') {

            pwStrData = CurText;
            cchSize = CCHOF(CurText);
            i         = 0;

            switch (c = *pwszFormat++) {

            case L's':

                pwStrData = (LPWSTR)va_arg(vaList, LPWSTR);
                cchSize = wcslen(pwStrData) + 1;
                break;

            case L'd':  // Index = 3

                ++i;

            case L'u':  // Index = 2

                ++i;

            case L'x':  // Index = 1

                ++i;

            case L'X':  // Index = 0;

                hr = StringCchPrintfW(pwStrData, cchSize, pNumFmt[i], (DWORD)va_arg(vaList, DWORD));
                i = 0;
                break;

            case '!':

                //
                // %! = load the string from resource ID
                //

                //
                // The LoadString will append a NULL too
                //

                if (!LoadString(hInst,
                                (UINT)va_arg(vaList, UINT),
                                pwStrData,
                                MAX_CUR_TEXT_CHARS)) {

                    // If we can't read the string, put and empty string here.
                    pwStrData[0] = L'\0';
                }
                break;

            case L'c':

                c = (WCHAR)va_arg(vaList, WCHAR);

                //
                // Fall through
                //

            default:

                pwStrData = NULL;
                i         = 1;
                break;
            }
        }

        if (!i) {

            if (pwStrData) {

                i = lstrlen(pwStrData);

            } else {

                c = L' ';
                i = 0;
            }
        }

        cchNeeded += i;

        if (pwBuf < pwEndBuf) {

            if (pwStrData) {

                lstrcpyn(pwBuf, pwStrData, (int)(pwEndBuf - pwBuf + 1));
                pwBuf += lstrlen(pwBuf);

            } else {

                *pwBuf++ = c;
            }

        } else if (!pcchNeeded) {

            break;
        }
    }

    if (pwEndBuf) {

        *pwEndBuf = L'\0';
    }

    if (pcchNeeded) {

        *pcchNeeded = cchNeeded;
    }

    va_end(vaList);

    return((UINT)(pwBuf - pwBufOrg));


#undef MAX_CUR_TEXT_CHARS
}




BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    )

/*++

Routine Description:

   This routine determines whether or not the driver can print the job
   described by pDevMode on the printer described by hPrinter


Arguments:

    pDQPInfo    - Pointer to DEVQUERYPRINT_INFO data structure

        typedef struct _DEVQUERYPRINT_INFO {
            WORD    cbSize;         // size of this structure in bytes
            WORD    Level;          // Level of this info, 1 for this version
            HANDLE  hPrinter;       // handle to the printer for the query
            DEVMODE *pDevMode;      // pointer to the DEVMODE for this job.
            LPTSTR  pszErrorStr;    // pointer to the error string buffer.
            WORD    cchErrorStr;    // count characters of pszErrorStr passed.
            WORD    cchNeeded;      // count characters of pszErrorStr needed.
            } DEVQUERYPRINT_INFO, *PDEVQUERYPRINT_INFO;


        cbSize      - size of this structure

        Level       - This must be one (1) for this version of structure

        hPrinter    - Identifies the printer on which the job is to be printed.

        pDevMode    - Points to the DEVMODE structure that describes the print
                      job that is to be determined as printable or
                      non-printable by hPrinter.  The driver should always
                      validate the DEVMODE structure whenever it is passed in.

        pszErrorStr - This is the pointer to a null terminated unicode string
                      which to stored the reason for non-printable job. If the
                      job is printable then it return TRUE.  If the job
                      is non-printable then it return FALSE,  and a null
                      terminated unicode string pointed by the pszErrorStr for
                      the reason by this job is not printable.  The size of
                      this buffer in characters is specified by the cchErrorStr.

        cchErrorStr - Specified the size of pszErrorStr in characters (includs
                      null terminator) when calling this function.  If an error
                      string is returned due to the non-printable job (returned
                      FALSE), the driver will set ccchNeeded to the total
                      characters (includes null terminator) required for the
                      pszErrorStr,  in this case the driver must always
                      truncate the error string to fit into the pwErrorStr
                      (only if it is not NULL) passed up to the cchErrorStr
                      characters passed.

        cchNeeded   - When driver returned FALSE, it specified total characters
                      required for the pszErrorStr.  If cchNeeded returned
                      from the driver is larger then the cchErrorStr then it
                      indicate the passed pszErrorStr is too small to hold the
                      full error string, in this case the driver must always
                      truncate the error string to fit into the pszErrorStr
                      passed up to the cchErrorStr size.

Return Value:

    BOOLEAN - TRUE  - The job is printable and should not be hold.
              FALSE - The job is not printable and cchNeeded in the
                      DEVQUERYPRINT_INFO data structure specified total
                      characters required for the pszErrorStr.  If returned
                      cchNeeded is greater then cchErrorStr passed then it
                      indicated that pszErrorStr is too small for storing the
                      error string, in this case the driver must always
                      truncate the error string to fit into the pszErrorStr
                      passed, up to the cchErrorStr characters.

    *Note*

        The driver should have some predefined generic resource error strings
        for some possible known errors. such as memroy allocation error, data
        file not found, invalid devmode,... for returning non devmode related
        errors.  The caller can pre-allocated larger buffer (such as 256
        wchars) for storing the error string rather than calling this function
        twice.


Development History:

    07-Feb-1996 Wed 20:37:31 created  



--*/

{
    PPRINTERINFO    pPI = NULL;
    LONG            ErrorResID = 0;
    static WCHAR    wFormat1[] = L"<%s> %!";

    //
    // if it passed a NULL DEVMODE then we just honor it to said can print
    //

    pDQPInfo->cchNeeded = 0;
    ErrorResID          = IDS_FORM_NOT_AVAI;

    if (!pDQPInfo->pDevMode) {

        PLOTWARN(("DevQueryPrint: No DEVMODE passed, CANNOT PRINT"));

        ErrorResID = IDS_INVALID_DATA;

    } else if (!(pPI = MapPrinter(pDQPInfo->hPrinter,
                                  (PPLOTDEVMODE)pDQPInfo->pDevMode,
                                  (LPDWORD)&ErrorResID,
                                  MPF_DEVICEDATA))) {

        //
        // The MapPrinter will allocate memory, set default devmode, reading
        // and validating the GPC then update from current pritner registry,
        //

        PLOTRIP(("DevQueryPrint: MapPrinter() failed"));

    } else if (pPI->dmErrBits & (USER_PAPER | DM_FORMNAME)) {

        //
        // We encounter some errors, and the form has been set to default
        //

        PLOTWARN(("DevQueryPrint: CAN'T PRINT, dmErrBits=%08lx (PAPER/FORM)",
                   pPI->dmErrBits));

    } else if ((pPI->PlotDM.dm.dmFields & DM_FORMNAME) &&
               (wcscmp(pPI->CurPaper.Name, pPI->PlotDM.dm.dmFormName) == 0)) {

        //
        // We can print this form now
        //

        ErrorResID = 0;

        PLOTDBG(DBG_DEVQPRINT, ("DevQueryPrint: Match FormName=%s",
                                                pPI->PlotDM.dm.dmFormName));

    } else if ((!pPI->CurPaper.Size.cy)                                   ||
               (((pPI->PlotDM.dm.dmFields & USER_PAPER) == USER_PAPER) &&
                (pPI->PlotDM.dm.dmPaperSize == DMPAPER_USER))             ||
               (pPI->PPData.Flags & PPF_SMALLER_FORM)) {

        LONG    lTmp;
        SIZEL   szl;
        BOOL    VarLenPaper;

        //
        // 1. If we have ROLL PAPER Installed OR
        // 2. User Defined Paper Size
        // 3. User said OK to print smaller form then installed one
        //
        // THEN we want to see if it can fit into the device installed form
        //

        szl.cx = DMTOSPL(pPI->PlotDM.dm.dmPaperWidth);
        szl.cy = DMTOSPL(pPI->PlotDM.dm.dmPaperLength);

        if (VarLenPaper = (BOOL)!pPI->CurPaper.Size.cy) {

            pPI->CurPaper.Size.cy = pPI->pPlotGPC->DeviceSize.cy;
        }

        PLOTDBG(DBG_DEVQPRINT,
                ("DevQueryPrint: CurPaper=%ldx%ld, Req=%ldx%ld, VarLen=%ld",
                pPI->CurPaper.Size.cx,  pPI->CurPaper.Size.cy,
                szl.cx, szl.cy, VarLenPaper));

        //
        // One of Following conditions met in that sequence then we can print
        // the form on loaded paper
        //
        // 1. Same size (PORTRAIT or LANDSCAPE)
        // 2. Larger Size (PORTRAIT or LANDSCAPE)   AND
        //    Not a variable length paper           AND
        //    PPF_SAMLLER_FORM flag set
        //

        if ((pPI->CurPaper.Size.cx < szl.cx) ||
            (pPI->CurPaper.Size.cy < szl.cy)) {

            //
            // Swap this so we can do one easier comparsion later
            //

            SWAP(szl.cx, szl.cy, lTmp);
        }

        if ((pPI->CurPaper.Size.cx >= szl.cx) &&
            (pPI->CurPaper.Size.cy >= szl.cy)) {

            if ((!VarLenPaper)                          &&
                (!(pPI->PPData.Flags & PPF_SMALLER_FORM)) &&
                ((pPI->CurPaper.Size.cx > szl.cx)  ||
                 (pPI->CurPaper.Size.cy > szl.cy))) {

                PLOTDBG(DBG_DEVQPRINT,
                        ("DevQueryPrint: CAN'T PRINT: user DO NOT want print on larger paper"));

            } else {

                PLOTDBG(DBG_DEVQPRINT,
                        ("DevQueryPrint: Paper Size FITS in DEVICE, %ld x %ld",
                        szl.cx, szl.cy));

                ErrorResID = 0;
            }

        } else {

            DQPsprintf((HINSTANCE)hPlotUIModule,
                       pDQPInfo->pszErrorStr,
                       pDQPInfo->cchErrorStr,
                       &(pDQPInfo->cchNeeded),
                       wFormat1,
                       pPI->PlotDM.dm.dmFormName,
                       IDS_FORM_TOO_BIG);

            PLOTDBG(DBG_DEVQPRINT,
                    ("DevQueryPrint: CAN'T PRINT: Form Size too small"));
        }
    }

    if (pPI)
    {
    PLOTDBG(DBG_DEVQPRINT, ("DevQueryPrint: %s PRINT %s",
                (ErrorResID) ? "CAN'T" : "OK to", pPI->PlotDM.dm.dmFormName));
    }

    if ((!pDQPInfo->cchNeeded) && (ErrorResID)) {

        switch (ErrorResID) {

        case IDS_FORM_NOT_AVAI:

            if (pPI)
            {
                DQPsprintf((HINSTANCE)hPlotUIModule,
                           pDQPInfo->pszErrorStr,
                           pDQPInfo->cchErrorStr,
                           &(pDQPInfo->cchNeeded),
                           wFormat1,
                           pPI->PlotDM.dm.dmFormName,
                           IDS_FORM_NOT_AVAI);
            }
            break;

        default:

            DQPsprintf((HINSTANCE)hPlotUIModule,
                       pDQPInfo->pszErrorStr,
                       pDQPInfo->cchErrorStr,
                       &(pDQPInfo->cchNeeded),
                       L"%!",
                       ErrorResID);
            break;
        }
    }

    //
    // Unget the printer GPC mapping if we got one
    //

    if (pPI) {

        UnMapPrinter(pPI);
    }

    return((!ErrorResID) && (!pDQPInfo->cchNeeded));
}


#if 0


BOOL
WINAPI
DevQueryPrint(
    HANDLE  hPrinter,
    DEVMODE *pDM,
    DWORD   *pdwErrIDS
    )

/*++

Routine Description:

   This routine determines whether or not the driver can print the job
   described by pDevMode on the printer described by hPrinter. If if can, it
   puts zero into pdwErrIDS.  If it cannot, it puts the resource id of the
   string describing why it could not.

Arguments:

    hPrinter    - Handle to the printer to be checked

    pDM         - Point to the DEVMODE passed in

    pdwErrIDS   - Point the the DWORD to received resource string ID number for
                  the error.


Return Value:

   This routine returns TRUE for success, FALSE for failure.

   when it return TRUE, the *pdwErrIDS determine if it can print or not, if
   *pdwErrIDS == 0, then it can print else it contains the string ID for the
   reason why it can not print.



Development History:

    07-Dec-1993 Tue 00:50:32 created  

    14-Jun-1994 Tue 22:43:36 updated  
        Make installed RollPaper always print if the size is reasonable




--*/

{
    PPRINTERINFO    pPI = NULL;


    //
    // if it passed a NULL DEVMODE then we just honor it to said can print
    //

    if (!pDM) {

        PLOTWARN(("DevQueryPrint: No DEVMODE passed, CANNOT PRINT"));

        *pdwErrIDS = IDS_INV_DMSIZE;
        return(TRUE);
    }

    if (!(pPI = MapPrinter(hPrinter,
                           (PPLOTDEVMODE)pDM,
                           pdwErrIDS,
                           MPF_DEVICEDATA))) {

        //
        // The MapPrinter will allocate memory, set default devmode, reading
        // and validating the GPC then update from current pritner registry,
        //

        PLOTRIP(("DevQueryPrint: MapPrinter() failed"));

        return(TRUE);
    }

    //
    // Assume this error
    //

    *pdwErrIDS = IDS_FORM_NOT_AVAI;

    if (pPI->dmErrBits & (USER_PAPER | DM_FORMNAME)) {

        //
        // We encounter some errors, and the form has been set to default
        //

        PLOTWARN(("DevQueryPrint: CAN'T PRINT, dmErrBits=%08lx (PAPER/FORM)",
                   pPI->dmErrBits));

    } else if ((pPI->PlotDM.dm.dmFields & DM_FORMNAME) &&
               (wcscmp(pPI->CurPaper.Name, pPI->PlotDM.dm.dmFormName) == 0)) {

        //
        // We can print this form now
        //

        *pdwErrIDS = 0;

        PLOTDBG(DBG_DEVQPRINT, ("DevQueryPrint: Match FormName=%s",
                                                pPI->PlotDM.dm.dmFormName));


    } else if ((!pPI->CurPaper.Size.cy)                                   ||
               (((pPI->PlotDM.dm.dmFields & USER_PAPER) == USER_PAPER) &&
                (pPI->PlotDM.dm.dmPaperSize == DMPAPER_USER))             ||
               (pPI->PPData.Flags & PPF_SMALLER_FORM)) {

        LONG    lTmp;
        SIZEL   szl;
        BOOL    VarLenPaper;

        //
        // 1. If we have ROLL PAPER Installed OR
        // 2. User Defined Paper Size
        // 3. User said OK to print smaller form then installed one
        //
        // THEN we want to see if it can fit into the device installed form
        //

        szl.cx = DMTOSPL(pPI->PlotDM.dm.dmPaperWidth);
        szl.cy = DMTOSPL(pPI->PlotDM.dm.dmPaperLength);

        if (VarLenPaper = (BOOL)!pPI->CurPaper.Size.cy) {

            pPI->CurPaper.Size.cy = pPI->pPlotGPC->DeviceSize.cy;
        }

        PLOTDBG(DBG_DEVQPRINT,
                ("DevQueryPrint: CurPaper=%ldx%ld, Req=%ldx%ld, VarLen=%ld",
                pPI->CurPaper.Size.cx,  pPI->CurPaper.Size.cy,
                szl.cx, szl.cy, VarLenPaper));

        //
        // One of Following conditions met in that sequence then we can print
        // the form on loaded paper
        //
        // 1. Same size (PORTRAIT or LANDSCAPE)
        // 2. Larger Size (PORTRAIT or LANDSCAPE)   AND
        //    Not a variable length paper           AND
        //    PPF_SAMLLER_FORM flag set
        //

        if ((pPI->CurPaper.Size.cx < szl.cx) ||
            (pPI->CurPaper.Size.cy < szl.cy)) {

            //
            // Swap this so we can do one easier comparsion later
            //

            SWAP(szl.cx, szl.cy, lTmp);
        }

        if ((pPI->CurPaper.Size.cx >= szl.cx) &&
            (pPI->CurPaper.Size.cy >= szl.cy)) {

            if ((!VarLenPaper)                          &&
                (!(pPI->PPData.Flags & PPF_SMALLER_FORM)) &&
                ((pPI->CurPaper.Size.cx > szl.cx)  ||
                 (pPI->CurPaper.Size.cy > szl.cy))) {

                PLOTDBG(DBG_DEVQPRINT,
                        ("DevQueryPrint: CAN'T PRINT: user DO NOT want print on larger paper"));

            } else {

                PLOTDBG(DBG_DEVQPRINT,
                        ("DevQueryPrint: Paper Size FITS in DEVICE, %ld x %ld",
                        szl.cx, szl.cy));

                *pdwErrIDS = 0;
            }

        } else {

            PLOTDBG(DBG_DEVQPRINT,
                    ("DevQueryPrint: CAN'T PRINT: Form Size too small"));
        }
    }

    PLOTDBG(DBG_DEVQPRINT, ("DevQueryPrint: %s PRINT %s",
                (*pdwErrIDS) ? "CAN'T" : "OK to", pPI->PlotDM.dm.dmFormName));

    //
    // Unget the printer GPC mapping if we got one
    //

    UnMapPrinter(pPI);

    return(TRUE);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\upgrade.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    upgrade.c


Abstract:

    This module contains upgrade functions


Author:

    09-Feb-1996 Fri 12:37:01 created  


[Environment:]

    Windows 2000, Windows XP and Windows Server 2003 - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/



#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgUpgrade

extern HMODULE  hPlotUIModule;


#define DBG_UPGRADE         0x00000001

DEFINE_DBGVAR(0);


BOOL
DrvUpgradePrinter(
    DWORD   Level,
    LPBYTE  pDriverUpgradeInfo
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Feb-1996 Fri 12:37:46 created  


Revision History:


--*/

{
    PDRIVER_UPGRADE_INFO_1  pDUI1;
    HANDLE                  hPrinter;
    PRINTER_DEFAULTS        PrinterDef = { NULL, NULL, PRINTER_ALL_ACCESS };
    BOOL                    Ok = FALSE;

    if ((Level == 1)                                            &&
        (pDUI1 = (PDRIVER_UPGRADE_INFO_1)pDriverUpgradeInfo)    &&
        (OpenPrinter(pDUI1->pPrinterName, &hPrinter, &PrinterDef))) {

        PPRINTERINFO    pPI;

        if (pPI = MapPrinter(hPrinter, NULL, NULL, MPF_DEVICEDATA)) {

            Ok = AddFormsToDataBase(pPI, TRUE);

            UnMapPrinter(pPI);
        }

        ClosePrinter(hPrinter);

    } else {

        PLOTERR(("DrvConvertDevMode: OpenPrinter(%ws) failed.",
                                                pDUI1->pPrinterName));
        SetLastError(ERROR_INVALID_DATA);
    }

    return(Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\plotui.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotui.h


Abstract:

    This module contains all plotters's user interface common defines


Author:

    02-Dec-1993 Thu 09:56:07 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTUI_
#define _PLOTUI_

//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif


//
// PrinterINFO data structure which used by following calls to map a hPrinter
// to this data structrue by follwoing funciton
//
//  1. DrvDeviceCapabilities()
//  2. PrinterProperties()
// @@BEGIN_DDKSPLIT
//  3. DrvDocumentProperties()
//  4. DrvAdvancedDocumentProperties()
// @@END_DDKSPLIT
//

#define PIF_UPDATE_PERMISSION       0x01
#define PIF_DOCPROP                 0x02

typedef struct _PRINTERINFO {
    HANDLE          hPrinter;       // Handle to the printer belong to here
    POPTITEM        pOptItem;
    LPWSTR          pHelpFile;      // pointer to the help file
    PFORM_INFO_1    pFI1Base;       // intalled form
    PPLOTGPC        pPlotGPC;       // loaded/updated Plotter GPC data
    WORD            cOptItem;
    BYTE            Flags;
    BYTE            IdxPenSet;      // plotter pen data set
    DWORD           dmErrBits;      // ErrorBits for DM_
    PLOTDEVMODE     PlotDM;         // Validated PLOTDEVMODE
    PAPERINFO       CurPaper;       // Current loaded form on the device
    PPDATA          PPData;         // Printer Prop Data
    HANDLE          hCPSUI;         // handle to the common ui pages
    PCOMPROPSHEETUI pCPSUI;         // pointer to COMPROPSHEETUI
    PPLOTDEVMODE    pPlotDMIn;      // input devmode
    PPLOTDEVMODE    pPlotDMOut;     // output devmode
    DWORD           dw64Align;      // QWORD alignment.
    DWORD           ExtraData;      // starting of extra data
    } PRINTERINFO, *PPRINTERINFO;

#define PI_PADJHTINFO(pPI)      (PDEVHTINFO)&((pPI)->ExtraData)
#define PI_PDEVHTADJDATA(pPI)   (PDEVHTADJDATA)(PI_PADJHTINFO(pPI) + 1)
#define PI_PPENDATA(pPI)        (PPENDATA)&((pPI)->ExtraData)

typedef struct _DOCPROPINFO {
    HWND                    hWnd;
    DWORD                   Result;
    DOCUMENTPROPERTYHEADER  DPHdr;
    } DOCPROPINFO, *PDOCPROPINFO;

typedef struct _DEVPROPINFO {
    HWND                    hWnd;
    DWORD                   Result;
    DEVICEPROPERTYHEADER    DPHdr;
    } DEVPROPINFO, *PDEVPROPINFO;

typedef UINT (* _CREATEOIFUNC)(PPRINTERINFO  pPI,
                               POPTITEM      pOptItem,
                               LPVOID        pOIData);

#define CREATEOIFUNC    UINT


typedef struct _OPDATA {
    WORD    Flags;
    WORD    IDSName;
    WORD    IconID;
    union {
        WORD    Style;
        WORD    IDSSeparator;
        } DUMMYUNIONNAME;
    union {
        WORD    wParam;
        WORD    IDSCheckedName;
        } DUMMYUNIONNAME2;
    SHORT   sParam;
    } OPDATA, *POPDATA;

#define ODF_PEN                 0x00000001
#define ODF_RASTER              0x00000002
#define ODF_PEN_RASTER          (ODF_PEN | ODF_RASTER)
#define ODF_COLOR               0x00000004
#define ODF_ROLLFEED            0x00000008
#define ODF_ECB                 0x00000010
#define ODF_INC_IDSNAME         0x00000020
#define ODF_INC_ICONID          0x00000040
#define ODF_NO_INC_POPDATA      0x00000080
#define ODF_COLLAPSE            0x00000100
#define ODF_CALLBACK            0x00000200
#define ODF_NO_PAPERTRAY        0x00000400
#define ODF_CALLCREATEOI        0x00000800
#define ODF_MANUAL_FEED         0x00001000


#define OI_LEVEL_1              0
#define OI_LEVEL_2              1
#define OI_LEVEL_3              2
#define OI_LEVEL_4              3
#define OI_LEVEL_5              4
#define OI_LEVEL_6              5

typedef struct _OIDATA {
    DWORD               Flags;
    BYTE                NotUsed;
    BYTE                Level;
    BYTE                DMPubID;
    BYTE                Type;
    WORD                IDSName;
    union {
        WORD            IconID;
        WORD            Style;
        } DUMMYUNIONNAME;
    WORD                HelpIdx;
    WORD                cOPData;
    union {
        POPDATA         pOPData;
        _CREATEOIFUNC   pfnCreateOI;
        } DUMMYUNIONNAME2;
    } OIDATA, *POIDATA;

#define PI_OFF(x)               (WORD)FIELD_OFFSET(PRINTERINFO, x)
#define PLOTDM_OFF(x)           (WORD)FIELD_OFFSET(PLOTDEVMODE, x)

#define OPTIF_NONE                  0
#define PP_FORMTRAY_ASSIGN          (DMPUB_USER + 0)
#define PP_INSTALLED_FORM           (DMPUB_USER + 1)
#define PP_MANUAL_FEED_METHOD       (DMPUB_USER + 2)
#define PP_PRINT_FORM_OPTIONS       (DMPUB_USER + 3)
#define PP_AUTO_ROTATE              (DMPUB_USER + 4)
#define PP_PRINT_SMALLER_PAPER      (DMPUB_USER + 5)
#define PP_HT_SETUP                 (DMPUB_USER + 6)
#define PP_INSTALLED_PENSET         (DMPUB_USER + 7)
#define PP_PEN_SETUP                (DMPUB_USER + 8)
#define PP_PENSET                   (DMPUB_USER + 9)
#define PP_PEN_NUM                  (DMPUB_USER + 10)

#define DP_HTCLRADJ                 (DMPUB_USER + 0)
#define DP_FILL_TRUETYPE            (DMPUB_USER + 1)
#define DP_QUICK_POSTER_MODE        (DMPUB_USER + 2)


//
// Icon ID
//

#define IDI_RASTER_ROLLFEED         64089
#define IDI_RASTER_TRAYFEED         64090
#define IDI_PEN_ROLLFEED            64087
#define IDI_PEN_TRAYFEED            64088
#define IDI_ROLLPAPER               64091

#define IDI_PEN_SETUP               64093
#define IDI_PENSET                  64092
#define IDI_DEFAULT_PENCLR          1007
#define IDI_PENCLR                  64092
#define IDI_AUTO_ROTATE_NO          1009
#define IDI_AUTO_ROTATE_YES         1010
#define IDI_PRINT_SMALLER_PAPER_NO  1011
#define IDI_PRINT_SMALLER_PAPER_YES 1012
#define IDI_MANUAL_CX               1013
#define IDI_MANUAL_CY               1014
#define IDI_FILL_TRUETYPE_NO        1015
#define IDI_FILL_TRUETYPE_YES       1016


#define IDI_COLOR_FIRST             IDI_WHITE
#define IDI_WHITE                   1100
#define IDI_BLACK                   1101
#define IDI_RED                     1102
#define IDI_GREEN                   1103
#define IDI_YELLOW                  1104
#define IDI_BLUE                    1105
#define IDI_MAGENTA                 1106
#define IDI_CYAN                    1107
#define IDI_ORANGE                  1108
#define IDI_BROWN                   1109
#define IDI_VIOLET                  1110
#define IDI_COLOR_LAST              IDI_VIOLET


//
// String table ID
//

#define IDS_PLOTTER_DRIVER          1900
#define IDS_CAUTION                 1901
#define IDS_NO_MEMORY               1902
#define IDS_INVALID_DATA            1903
#define IDS_FORM_TOO_BIG            1904
#define IDS_INV_DMSIZE              1905
#define IDS_INV_DMVERSION           1906
#define IDS_INV_DMDRIVEREXTRA       1907
#define IDS_INV_DMCOLOR             1908
#define IDS_INV_DMCOPIES            1909
#define IDS_INV_DMSCALE             1910
#define IDS_INV_DMORIENTATION       1911
#define IDS_INV_DMFORM              1912
#define IDS_INV_DMQUALITY           1913
#define IDS_FORM_NOT_AVAI           1914
#define IDS_MODEL                   1915
#define IDS_HELP_FILENAME           1916
#define IDS_NO_HELP                 1918
#define IDS_PP_NO_SAVE              1919

#define IDS_INSTALLED_FORM          2030

#define IDS_MANUAL_FEEDER           2040
#define IDS_MANUAL_FEED_METHOD      2041
#define IDS_MANUAL_CX               2042
#define IDS_MANUAL_CY               2043
#define IDS_ROLLFEED                2044
#define IDS_MAINFEED                2045

#define IDS_PRINT_FORM_OPTIONS      2050
#define IDS_AUTO_ROTATE             2051
#define IDS_PRINT_SAMLLER_PAPER     2052

#define IDS_INSTALLED_PENSET        2060
#define IDS_PEN_SETUP               2061

#define IDS_PENSET_FIRST            IDS_PENSET_1
#define IDS_PENSET_1                2070
#define IDS_PENSET_2                2071
#define IDS_PENSET_3                2072
#define IDS_PENSET_4                2073
#define IDS_PENSET_5                2074
#define IDS_PENSET_6                2075
#define IDS_PENSET_7                2076
#define IDS_PENSET_8                2077
#define IDS_PENSET_LAST             IDS_PENSET_8

#define IDS_PEN_NUM                 2100
#define IDS_DEFAULT_PENCLR          2101


#define IDS_QUALITY_FIRST           IDS_QUALITY_DRAFT
#define IDS_QUALITY_DRAFT           2110
#define IDS_QUALITY_LOW             2111
#define IDS_QUALITY_MEDIUM          2112
#define IDS_QUALITY_HIGH            2113
#define IDS_QUALITY_LAST            IDS_QUALITY_HIGH

#define IDS_COLOR_FIRST             IDS_WHITE
#define IDS_WHITE                   2120
#define IDS_BLACK                   2121
#define IDS_RED                     2122
#define IDS_GREEN                   2123
#define IDS_YELLOW                  2124
#define IDS_BLUE                    2125
#define IDS_MAGENTA                 2126
#define IDS_CYAN                    2127
#define IDS_ORANGE                  2128
#define IDS_BROWN                   2129
#define IDS_VIOLET                  2130
#define IDS_COLOR_LAST              IDS_VIOLET

#define IDS_FILL_TRUETYPE           2140
#define IDS_POSTER_MODE             2150


#define IDS_USERFORM                2200

//
// Help Index for Printer Properties
//

#define IDH_FORMTRAYASSIGN          5000
#define IDH_FORM_ROLL_FEEDER        5010
#define IDH_FORM_MAIN_FEEDER        5020
#define IDH_FORM_MANUAL_FEEDER      5030
#define IDH_MANUAL_FEED_METHOD      5040
#define IDH_PRINT_FORM_OPTIONS      5050
#define IDH_AUTO_ROTATE             5060
#define IDH_PRINT_SMALLER_PAPER     5070
#define IDH_HALFTONE_SETUP          5080
#define IDH_INSTALLED_PENSET        5090
#define IDH_PEN_SETUP               5100
#define IDH_PENSET                  5110
#define IDH_PEN_NUM                 5120

//
// Help Index for Document Properties

#define IDH_FORMNAME                5500
#define IDH_ORIENTATION             5510
#define IDH_COPIES_COLLATE          5520
#define IDH_PRINTQUALITY            5530
#define IDH_COLOR                   5540
#define IDH_SCALE                   5550
#define IDH_HTCLRADJ                5560
#define IDH_FILL_TRUETYPE           5570
#define IDH_POSTER_MODE             5580

//
// Count of characters
//
#define CCHOF(x) (sizeof(x)/sizeof(*(x)))

#endif  // _PLOTUI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\ptrinfo.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    ptrInfo.c


Abstract:

    This module contains functions to mappring a hPrinter to useful data, it
    will also cached the printerinfo data


Author:

    03-Dec-1993 Fri 00:16:37 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPtrInfo


#define DBG_MAPPRINTER      0x00000001
#define DBG_CACHE_DATA      0x00000002


DEFINE_DBGVAR(0);




PPRINTERINFO
MapPrinter(
    HANDLE          hPrinter,
    PPLOTDEVMODE    pPlotDMIn,
    LPDWORD         pdwErrIDS,
    DWORD           MPFlags
    )

/*++

Routine Description:

    This function map a handle to the printer to useful information for the
    plotter UI


Arguments:

    hPrinter    - Handle to the printer

    pPlotDMIn   - pointer to the PLOTDEVMODE pass in to be validate and merge
                  with default into pPI->PlotDM, if this pointer is NULL then
                  a default PLOTDEVMODE is set in the pPI

    pdwErrIDS   - pointer to a DWORD to store the error string ID if an error
                  occured.

    MPFlags     - MPF_xxxx flags for this function


Return Value:

    return a pointer to the PRINTERINFO data structure, if NULL then it failed

    when a pPI is returned then following fields are set and validated

        hPrinter, pPlotGPC, CurPaper.

    and following fields are set to NULL

        Flags,

Author:

    02-Dec-1993 Thu 23:04:18 created  

    29-Dec-1993 Wed 14:50:23 updated  
        NOT automatically select AUTO_ROTATE if roll feed device


Revision History:


--*/

{
    HANDLE          hHeap;
    PPRINTERINFO    pPI;
    PPLOTGPC        pPlotGPC;
    WCHAR           DeviceName[CCHDEVICENAME];
    UINT            cPenSet;
    UINT            MaxPens;
    DWORD           cbPen;
    DWORD           cb;


    if (!(pPlotGPC = hPrinterToPlotGPC(hPrinter, DeviceName, CCHOF(DeviceName)))) {

        if (pdwErrIDS) {

            *pdwErrIDS = IDS_NO_MEMORY;
        }

        return(NULL);
    }

    cPenSet = 0;

    if (pPlotGPC->Flags & PLOTF_RASTER) {

        cb = sizeof(PRINTERINFO) +
             ((MPFlags & MPF_DEVICEDATA) ?
                    (sizeof(DEVHTADJDATA) + (sizeof(DEVHTINFO) * 2)) : 0);

    } else {

        MaxPens = (UINT)pPlotGPC->MaxPens;
        cbPen   = (DWORD)(sizeof(PENDATA) * MaxPens);
        cPenSet = (MPFlags & MPF_DEVICEDATA) ? PRK_MAX_PENDATA_SET : 1;
        cb      = sizeof(PRINTERINFO) + (DWORD)(cbPen * cPenSet);
    }

    if (!(pPI = (PPRINTERINFO)LocalAlloc(LPTR,
                                         cb + ((MPFlags & MPF_PCPSUI) ?
                                                sizeof(COMPROPSHEETUI) : 0)))) {

        UnGetCachedPlotGPC(pPlotGPC);

        if (pdwErrIDS) {

            *pdwErrIDS = IDS_NO_MEMORY;
        }

        return(NULL);
    }

    if (MPFlags & MPF_PCPSUI) {

        pPI->pCPSUI = (PCOMPROPSHEETUI)((LPBYTE)pPI + cb);
    }

    pPI->hPrinter     = hPrinter;
    pPI->pPlotDMIn    = pPlotDMIn;
    pPI->PPData.Flags = PPF_AUTO_ROTATE     |
                        PPF_SMALLER_FORM    |
                        PPF_MANUAL_FEED_CX;
    pPI->IdxPenSet    = 0;
    pPI->pPlotGPC     = pPlotGPC;
    pPI->dmErrBits    = ValidateSetPLOTDM(hPrinter,
                                          pPlotGPC,
                                          DeviceName,
                                          pPlotDMIn,
                                          &(pPI->PlotDM),
                                          NULL);

    GetDefaultPlotterForm(pPlotGPC, &(pPI->CurPaper));

    if (pPlotGPC->Flags & PLOTF_RASTER) {

        //
        // Get the raster plotter default and settings
        //

        if (MPFlags & MPF_DEVICEDATA) {

            PDEVHTADJDATA   pDHTAD;
            PDEVHTINFO      pDefHTInfo;
            PDEVHTINFO      pAdjHTInfo;

            pAdjHTInfo                = PI_PADJHTINFO(pPI);
            pDHTAD                    = PI_PDEVHTADJDATA(pPI);
            pDefHTInfo                = (PDEVHTINFO)(pDHTAD + 1);

            pDHTAD->DeviceFlags       = (pPlotGPC->Flags & PLOTF_COLOR) ?
                                                    DEVHTADJF_COLOR_DEVICE : 0;
            pDHTAD->DeviceXDPI        = (DWORD)pPI->pPlotGPC->RasterXDPI;
            pDHTAD->DeviceYDPI        = (DWORD)pPI->pPlotGPC->RasterYDPI;
            pDHTAD->pDefHTInfo        = pDefHTInfo;
            pDHTAD->pAdjHTInfo        = pAdjHTInfo;

            pDefHTInfo->HTFlags       = HT_FLAG_HAS_BLACK_DYE;
            pDefHTInfo->HTPatternSize = (DWORD)pPlotGPC->HTPatternSize;
            pDefHTInfo->DevPelsDPI    = (DWORD)pPlotGPC->DevicePelsDPI;
            pDefHTInfo->ColorInfo     = pPlotGPC->ci;
            *pAdjHTInfo               = *pDefHTInfo;

            UpdateFromRegistry(hPrinter,
                               &(pAdjHTInfo->ColorInfo),
                               &(pAdjHTInfo->DevPelsDPI),
                               &(pAdjHTInfo->HTPatternSize),
                               &(pPI->CurPaper),
                               &(pPI->PPData),
                               NULL,
                               0,
                               NULL);
        }

    } else {

        PPENDATA    pPenData;
        WORD        IdxPenSet;

        //
        // Get the pen plotter default and settings
        //

        pPenData = PI_PPENDATA(pPI);

        UpdateFromRegistry(hPrinter,
                           NULL,
                           NULL,
                           NULL,
                           &(pPI->CurPaper),
                           &(pPI->PPData),
                           &(pPI->IdxPenSet),
                           0,
                           NULL);

        if (MPFlags & MPF_DEVICEDATA) {

            IdxPenSet = 0;

        } else {

            IdxPenSet = (WORD)pPI->IdxPenSet;
        }

        //
        // Set default pen set and get all the pen set back
        //

        while (cPenSet--) {

            CopyMemory(pPenData, pPlotGPC->Pens.pData, cbPen);

            UpdateFromRegistry(hPrinter,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               MAKELONG(IdxPenSet, MaxPens),
                               pPenData);

            IdxPenSet++;
            (LPBYTE)pPenData += cbPen;
        }
    }

    if (MPFlags & MPF_HELPFILE) {

        GetPlotHelpFile(pPI);
    }

    return(pPI);
}




VOID
UnMapPrinter(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    01-Nov-1995 Wed 19:05:40 created  


Revision History:


--*/

{
    if (pPI) {

        if (pPI->pPlotGPC) {

            UnGetCachedPlotGPC(pPI->pPlotGPC);
        }

        if (pPI->pFI1Base) {

            LocalFree((HLOCAL)pPI->pFI1Base);
        }

        if (pPI->pHelpFile) {

            LocalFree((HLOCAL)pPI->pHelpFile);
        }

        if (pPI->pOptItem) {

            POPTITEM    pOI = pPI->pOptItem;
            UINT        cOI = (UINT)pPI->cOptItem;

            while (cOI--) {

                if (pOI->UserData) {

                    LocalFree((HLOCAL)pOI->UserData);
                }

                pOI++;
            }

            LocalFree((HLOCAL)pPI->pOptItem);
        }

        LocalFree((HLOCAL)pPI);
    }
}




LPBYTE
GetPrinterInfo(
    HANDLE  hPrinter,
    UINT    PrinterInfoLevel
    )

/*++

Routine Description:

    This function get the DRIVER_INFO_1 Pointer from a hPrinter

Arguments:

    hPrinter            - The handle to the printer interested

    PrinterInfoLevel    - It can be PRINTER_INFO_1, PRINTER_INFO_2,
                          PRINTER_INFO_3, PRINTER_4, PRINTER_INFO_5.

Return Value:

    the return value is NULL if failed else a pointer to the PRINTER_INFO_X
    where X is from 1 to 5. the caller must call LocalFree() to free the
    memory object after using it.


Author:

    16-Nov-1995 Thu 23:58:37 created  


Revision History:


--*/

{
    LPVOID  pb;
    DWORD   cb;

    //
    // Find out total bytes required
    //

    GetPrinter(hPrinter, PrinterInfoLevel, NULL, 0, &cb);

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {

        PLOTERR(("GetPrinterInfo%d: GetPrinterPrinter(1st) error=%08lx",
                                        PrinterInfoLevel, xGetLastError()));

    } else if (!(pb = (LPBYTE)LocalAlloc(LMEM_FIXED, cb))) {

        PLOTERR(("GetPrinterInfo%d: LocalAlloc(%ld) failed", PrinterInfoLevel, cb));

    } else if (GetPrinter(hPrinter, PrinterInfoLevel, pb, cb, &cb)) {

        //
        // Got it allright, so return it
        //

        return(pb);

    } else {

        PLOTERR(("GetPrinterInfo%d: GetPrinterPrinter(2nd) error=%08lx",
                                        PrinterInfoLevel, xGetLastError()));
        LocalFree((HLOCAL)pb);
    }

    return(NULL);
}




DWORD
GetPlotterIconID(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Nov-1995 Wed 19:32:00 created  


Revision History:


--*/

{
    DWORD   Flags;
    DWORD   IconID;


    if ((Flags = pPI->pPlotGPC->Flags) & PLOTF_RASTER) {

        IconID = (Flags & PLOTF_ROLLFEED) ? IDI_RASTER_ROLLFEED :
                                            IDI_RASTER_TRAYFEED;

    } else {

        IconID = (Flags & PLOTF_ROLLFEED) ? IDI_PEN_ROLLFEED :
                                            IDI_PEN_TRAYFEED;
    }

    return(IconID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotui\ptrprop.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    ptrprop.c


Abstract:

    This module contains PrinterProperties() API entry and it's related
    functions


Author:

    06-Dec-1993 Mon 10:30:43 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPtrProp


extern HMODULE  hPlotUIModule;


#define DBG_DEVHTINFO           0x00000001
#define DBG_PP_FORM             0x00000002
#define DBG_EXTRA_DATA          0x00000004
#define DBG_CHK_PENSET_BUTTON   0x00000008

DEFINE_DBGVAR(0);


//
//  Form To Tray Assignment:
//      Roll Paper Feeder: <XYZ>
//          Manual Feed Method:
//  Print Form Options:
//      [] Auto. Rotate To Save Roll Paper:
//      [] Print Smaller Paper Size:
//  Halftone Setup...
//  Installed Pen Set: Pen Set #1
//  Pen Setup:
//      Installed: Pen Set #1
//      Pen Set #1:
//          Pen Number 1:
//          Pen Number 2:
//          Pen Number 3:
//          Pen Number 4:
//          Pen Number 5:
//          Pen Number 6:
//          Pen Number 7:
//          Pen Number 8:
//          Pen Number 9:
//          Pen Number 10:
//          Pen Number 11:
//      Pen Set #2;
//      Pen Set #3:
//      Pen Set #4: <Currently Installed>
//      Pen Set #5:
//      Pen Set #6:
//      Pen Set #7:
//      Pen Set #8:
//

OPDATA  OPPenSet = { 0, IDS_PENSET_FIRST, IDI_PENSET, 0, 0, 0 };

OPDATA  OPAutoRotate[] = {

    { 0, IDS_CPSUI_NO,  IDI_AUTO_ROTATE_NO,  0,  0, 0  },
    { 0, IDS_CPSUI_YES, IDI_AUTO_ROTATE_YES, 0,  0, 0  }
};

OPDATA  OPPrintSmallerPaper[] = {

    { 0, IDS_CPSUI_NO,  IDI_PRINT_SMALLER_PAPER_NO,  0,  0, 0  },
    { 0, IDS_CPSUI_YES, IDI_PRINT_SMALLER_PAPER_YES, 0,  0, 0  }
};


OPDATA  OPManualFeed[] = {

            { 0, IDS_MANUAL_CX, IDI_MANUAL_CX,  0, 0, 0   },
            { 0, IDS_MANUAL_CY, IDI_MANUAL_CY, 0, 0, 0   }
        };

OPDATA  OPHTSetup = {

            0,
            PI_OFF(ExtraData) + sizeof(DEVHTINFO),
            IDI_CPSUI_HALFTONE_SETUP,
            PUSHBUTTON_TYPE_HTSETUP,
            0,
            0
        };


OIDATA  PPOIData[] = {

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        PP_FORMTRAY_ASSIGN,
        TVOT_NONE,
        IDS_CPSUI_FORMTRAYASSIGN,
        IDI_CPSUI_FORMTRAYASSIGN,
        IDH_FORMTRAYASSIGN,
        0,
        NULL
    },

    {
        ODF_RASTER | ODF_ROLLFEED | ODF_CALLBACK | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_2,
        PP_INSTALLED_FORM,
        TVOT_LISTBOX,
        IDS_ROLLFEED,
        OTS_LBCB_SORT,
        IDH_FORM_ROLL_FEEDER,
        0,
        (POPDATA)CreateFormOI
    },

    {
        ODF_RASTER | ODF_MANUAL_FEED | ODF_CALLBACK | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_2,
        PP_INSTALLED_FORM,
        TVOT_LISTBOX,
        IDS_MANUAL_FEEDER,
        OTS_LBCB_SORT,
        IDH_FORM_MANUAL_FEEDER,
        0,
        (POPDATA)CreateFormOI
    },

    {
        ODF_PEN | ODF_CALLBACK | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_2,
        PP_INSTALLED_FORM,
        TVOT_LISTBOX,
        IDS_MAINFEED,
        OTS_LBCB_SORT,
        IDH_FORM_MAIN_FEEDER,
        0,
        (POPDATA)CreateFormOI
    },

    {
        ODF_PEN_RASTER | ODF_CALLBACK | ODF_NO_PAPERTRAY,
        0,
        OI_LEVEL_3,
        PP_MANUAL_FEED_METHOD,
        TVOT_2STATES,
        IDS_MANUAL_FEED_METHOD,
        0,
        IDH_MANUAL_FEED_METHOD,
        COUNT_ARRAY(OPManualFeed),
        OPManualFeed
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        PP_PRINT_FORM_OPTIONS,
        TVOT_NONE,
        IDS_PRINT_FORM_OPTIONS,
        IDI_CPSUI_GENERIC_OPTION,
        IDH_PRINT_FORM_OPTIONS,
        0,
        NULL
    },

    {
        ODF_PEN_RASTER | ODF_ROLLFEED,
        0,
        OI_LEVEL_2,
        PP_AUTO_ROTATE,
        TVOT_2STATES,
        IDS_AUTO_ROTATE,
        0,
        IDH_AUTO_ROTATE,
        2,
        OPAutoRotate
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_2,
        PP_PRINT_SMALLER_PAPER,
        TVOT_2STATES,
        IDS_PRINT_SAMLLER_PAPER,
        0,
        IDH_PRINT_SMALLER_PAPER,
        2,
        OPPrintSmallerPaper
    },

    {
        ODF_RASTER,
        0,
        OI_LEVEL_1,
        PP_HT_SETUP,
        TVOT_PUSHBUTTON,
        IDS_CPSUI_HALFTONE_SETUP,
        0,
        IDH_HALFTONE_SETUP,
        1,
        &OPHTSetup
    },

    {
        ODF_PEN | ODF_INC_IDSNAME | ODF_NO_INC_POPDATA,
        0,
        OI_LEVEL_1,
        PP_INSTALLED_PENSET,
        TVOT_LISTBOX,
        IDS_INSTALLED_PENSET,
        OTS_LBCB_SORT,
        IDH_INSTALLED_PENSET,
        PRK_MAX_PENDATA_SET,
        &OPPenSet
    },

    {
        ODF_PEN | ODF_COLLAPSE | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_1,
        PP_PEN_SETUP,
        TVOT_NONE,
        IDS_PEN_SETUP,
        IDI_PEN_SETUP,
        IDH_PEN_SETUP,
        1,
        (POPDATA)CreatePenSetupOI
    }
};




DWORD
CheckPenSetButton(
    PPRINTERINFO    pPI,
    DWORD           Action
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    30-Nov-1995 Thu 16:41:05 created  


Revision History:


--*/

{
    POPTITEM    pOptItem = pPI->pOptItem;
    POPTITEM    pEndItem = pOptItem + pPI->cOptItem;

    PLOTDBG(DBG_CHK_PENSET_BUTTON,
            ("CheckPenSetButton: pFirst=%08lx, pLast=%08lx, Count=%ld",
            pOptItem, pEndItem, pPI->cOptItem));

    while (pOptItem < pEndItem) {

        if (pOptItem->DMPubID == PP_PENSET) {

            PPENDATA    pPD;
            POPTITEM    pOI;
            DWORD       Flags;
            UINT        i;


            pOI   = pOptItem + 1;
            pPD   = (PPENDATA)pPI->pPlotGPC->Pens.pData;
            i     = (UINT)pPI->pPlotGPC->MaxPens;
            Flags = (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE);

            while (i--) {

                if (pOI->Sel != pPD->ColorIdx) {

                    Flags &= ~(OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE);
                }

                pOI++;
                pPD++;
            }

            if ((Flags & (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE)) !=
                (pOptItem->Flags & (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE))) {

                Action           = CPSUICB_ACTION_REINIT_ITEMS;
                pOptItem->Flags &= ~(OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE);
                pOptItem->Flags |= (Flags | OPTIF_CHANGED);
            }

            pOptItem = pOI;

        } else {

            pOptItem++;
        }
    }

    return(Action);
}



DWORD
CheckInstalledForm(
    PPRINTERINFO    pPI,
    DWORD           Action
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    30-May-1996 Thu 12:34:00 created  


Revision History:


--*/

{
    POPTITEM    pOIForm;
    POPTITEM    pOIFeed;
    POPTITEM    pOITemp;
    POPTPARAM   pOP;
    FORM_INFO_1 *pFI1;
    DWORD       MFFlags;
    DWORD       PSPFlags;
    DWORD       ARFlags;


    if ((pOIForm = FindOptItem(pPI->pOptItem,
                              pPI->cOptItem,
                              PP_INSTALLED_FORM))   &&
        (pOIFeed = FindOptItem(pPI->pOptItem,
                              pPI->cOptItem,
                              PP_MANUAL_FEED_METHOD))) {

        pOP = pOIForm->pOptType->pOptParam + pOIForm->Sel;

        switch (pOP->Style) {

        case FS_ROLLPAPER:
        case FS_TRAYPAPER:

            MFFlags = OPTIF_DISABLED;
            break;

        default:

            pFI1 = pPI->pFI1Base + pOP->lParam;

            if ((pFI1->Size.cx > pPI->pPlotGPC->DeviceSize.cx) ||
                (pFI1->Size.cy > pPI->pPlotGPC->DeviceSize.cx)) {

                MFFlags = (OPTIF_OVERLAY_STOP_ICON | OPTIF_DISABLED);

            } else {

                MFFlags = 0;
            }

            break;
        }

        if ((pOIFeed->Flags & (OPTIF_OVERLAY_STOP_ICON |
                               OPTIF_DISABLED)) != MFFlags) {

            pOIFeed->Flags &= ~(OPTIF_OVERLAY_STOP_ICON | OPTIF_DISABLED);
            pOIFeed->Flags |= (MFFlags | OPTIF_CHANGED);
            Action          = CPSUICB_ACTION_OPTIF_CHANGED;
        }

        if (pOP->Style & FS_ROLLPAPER) {

            ARFlags  = 0;
            PSPFlags = OPTIF_DISABLED;

        } else {

            ARFlags  = OPTIF_DISABLED;
            PSPFlags = 0;
        }

        if ((pOITemp = FindOptItem(pPI->pOptItem,
                                   pPI->cOptItem,
                                   PP_PRINT_SMALLER_PAPER))  &&
            ((pOITemp->Flags & OPTIF_DISABLED) != PSPFlags)) {

            pOITemp->Flags &= ~OPTIF_DISABLED;
            pOITemp->Flags |= (PSPFlags | OPTIF_CHANGED);
            Action          = CPSUICB_ACTION_OPTIF_CHANGED;
        }

        if ((pOITemp = FindOptItem(pPI->pOptItem,
                                   pPI->cOptItem,
                                   PP_AUTO_ROTATE))  &&
            ((pOITemp->Flags & OPTIF_DISABLED) != ARFlags)) {

            pOITemp->Flags &= ~OPTIF_DISABLED;
            pOITemp->Flags |= (ARFlags | OPTIF_CHANGED);
            Action          = CPSUICB_ACTION_OPTIF_CHANGED;
        }
    }

    return(Action);
}



UINT
SetupPPOptItems(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    16-Nov-1995 Thu 14:15:25 created  


Revision History:


--*/

{
    POPTITEM    pOIForm;
    POPTITEM    pOptItem;
    POPTITEM    pOI;
    POIDATA     pOIData;
    WORD        PPFlags;
    DWORD       Flags;
    DWORD       ODFlags;
    UINT        i;



    pOI      =
    pOptItem = pPI->pOptItem;
    pOIData  = PPOIData;
    i        = (UINT)COUNT_ARRAY(PPOIData);
    Flags    = pPI->pPlotGPC->Flags;
    PPFlags  = pPI->PPData.Flags;
    ODFlags  = (Flags & PLOTF_RASTER) ? ODF_RASTER : ODF_PEN;

    while (i--) {

        DWORD   OIFlags = pOIData->Flags;

        if ((!(OIFlags & ODFlags))                                      ||
            ((OIFlags & ODF_MANUAL_FEED) &&
                        (Flags & (PLOTF_ROLLFEED | PLOTF_PAPERTRAY)))   ||
            ((OIFlags & ODF_ROLLFEED) && (!(Flags & PLOTF_ROLLFEED)))   ||
            ((OIFlags & ODF_NO_PAPERTRAY) && (Flags & PLOTF_PAPERTRAY)) ||
            ((OIFlags & ODF_COLOR) && (!(Flags & PLOTF_COLOR)))) {

            //
            // Nothing to do here
            //

            NULL;

        } else if (OIFlags & ODF_CALLCREATEOI) {

            pOI += pOIData->pfnCreateOI(pPI,
                                        (LPVOID)((pOptItem) ? pOI : NULL),
                                        pOIData);

        } else if (pOptItem) {

            if (CreateOPTTYPE(pPI, pOI, pOIData, pOIData->cOPData, NULL)) {

                switch (pOI->DMPubID) {

                case PP_MANUAL_FEED_METHOD:

                    pOI->Sel = (LONG)((PPFlags & PPF_MANUAL_FEED_CX) ? 0 : 1);
                    break;

                case PP_AUTO_ROTATE:

                    pOI->Sel = (LONG)((PPFlags & PPF_AUTO_ROTATE) ? 1 : 0);
                    break;

                case PP_PRINT_SMALLER_PAPER:

                    pOI->Sel = (LONG)((PPFlags & PPF_SMALLER_FORM) ? 1 : 0);
                    break;

                case PP_INSTALLED_PENSET:

                    pOI->Sel = (LONG)pPI->IdxPenSet;
                    break;
                }

                pOI++;
            }

        } else {

            pOI++;
        }

        pOIData++;
    }

    if ((i = (UINT)(pOI - pOptItem)) && (!pOptItem)) {

        if (pPI->pOptItem = (POPTITEM)LocalAlloc(LPTR, sizeof(OPTITEM) * i)) {

            pPI->cOptItem = (WORD)i;

            //
            // Call myself second time to really create it
            //

            SetupPPOptItems(pPI);

            CheckInstalledForm(pPI, 0);
            CheckPenSetButton(pPI, 0);

        } else {

            i = 0;

            PLOTERR(("GetPPpOptItem(): LocalAlloc(%ld) failed",
                                            sizeof(OPTITEM) * i));
        }
    }

    return(i);
}



VOID
SavePPOptItems(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:

    This function save all the device options back to registry if one changed
    and has a update permission


Arguments:

    pPI     - Pointer to the PRINTERINFO


Return Value:

    VOID


Author:

    06-Nov-1995 Mon 18:05:16 created  


Revision History:


--*/

{
    POPTITEM        pOptItem;
    POPTITEM        pLastItem;
    PDEVHTINFO      pAdjHTInfo;
    PCOLORINFO      pCI;
    LPDWORD         pHTPatSize;
    LPDWORD         pDevPelsDPI;
    PPAPERINFO      pCurPaper;
    LPBYTE          pIdxPen;
    WORD            PPFlags;
    BYTE            DMPubID;


    pCI         = NULL;
    pHTPatSize  = NULL;
    pDevPelsDPI = NULL;
    pCurPaper   = NULL;
    pIdxPen     = NULL;


    if (!(pPI->Flags & PIF_UPDATE_PERMISSION)) {

        return;
    }

    pOptItem  = pPI->pOptItem;
    pLastItem = pOptItem + pPI->cOptItem - 1;

    while (pOptItem <= pLastItem) {

        if ((DMPubID = pOptItem->DMPubID) == PP_PEN_SETUP) {

            pOptItem = SavePenSet(pPI, pOptItem);

        } else {

            if (pOptItem->Flags & OPTIF_CHANGEONCE) {

                switch (DMPubID) {

                case PP_INSTALLED_FORM:

                    if (GetFormSelect(pPI, pOptItem)) {

                        pCurPaper = &(pPI->CurPaper);
                    }

                    break;

                case PP_MANUAL_FEED_METHOD:

                    if (pOptItem->Sel) {

                        pPI->PPData.Flags &= ~PPF_MANUAL_FEED_CX;

                    } else {

                        pPI->PPData.Flags |= PPF_MANUAL_FEED_CX;
                    }

                    break;

                case PP_AUTO_ROTATE:

                    if (pOptItem->Sel) {

                        pPI->PPData.Flags |= PPF_AUTO_ROTATE;

                    } else {

                        pPI->PPData.Flags &= ~PPF_AUTO_ROTATE;
                    }

                    break;

                case PP_PRINT_SMALLER_PAPER:

                    if (pOptItem->Sel) {

                        pPI->PPData.Flags |= PPF_SMALLER_FORM;

                    } else {

                        pPI->PPData.Flags &= ~PPF_SMALLER_FORM;
                    }

                    break;

                case PP_HT_SETUP:

                    pAdjHTInfo  = PI_PADJHTINFO(pPI);
                    pCI         = &(pAdjHTInfo->ColorInfo);
                    pDevPelsDPI = &(pAdjHTInfo->DevPelsDPI);
                    pHTPatSize  = &(pAdjHTInfo->HTPatternSize);
                    break;

                case PP_INSTALLED_PENSET:

                    pPI->IdxPenSet = (BYTE)pOptItem->Sel;
                    pIdxPen        = (LPBYTE)&(pPI->IdxPenSet);
                    break;
                }
            }

            pOptItem++;
        }
    }

    if (!SaveToRegistry(pPI->hPrinter,
                        pCI,
                        pDevPelsDPI,
                        pHTPatSize,
                        pCurPaper,
                        &(pPI->PPData),
                        pIdxPen,
                        0,
                        NULL)) {

        PlotUIMsgBox(NULL, IDS_PP_NO_SAVE, MB_ICONSTOP | MB_OK);
    }
}



CPSUICALLBACK
PPCallBack(
    PCPSUICBPARAM   pCPSUICBParam
    )

/*++

Routine Description:

    This is the callback function from the common property sheet UI


Arguments:

    pCPSUICBParam   - Pointer to the CPSUICBPARAM data structure to describe
                      the nature of the callback


Return Value:

    LONG


Author:

    07-Nov-1995 Tue 15:15:02 created  


Revision History:


--*/

{
    POPTITEM        pCurItem = pCPSUICBParam->pCurItem;
    POPTITEM        pItem;
    PPRINTERINFO    pPI = (PPRINTERINFO)pCPSUICBParam->UserData;
    POPTPARAM       pOP;
    DWORD           Flags;
    UINT            i;
    WORD            Reason = pCPSUICBParam->Reason;
    LONG            Action = CPSUICB_ACTION_NONE;



    if (Reason == CPSUICB_REASON_APPLYNOW) {

        PRINTER_INFO_7  PI7;

        SavePPOptItems(pPI);

        pCPSUICBParam->Result = CPSUI_OK;
        Action                = CPSUICB_ACTION_ITEMS_APPLIED;

        PI7.pszObjectGUID = NULL;
        PI7.dwAction      = DSPRINT_UPDATE;

        SetPrinter(pPI->hPrinter, 7, (LPBYTE)&PI7, 0);

    } else if (Reason == CPSUICB_REASON_ITEMS_REVERTED) {

        Action = CheckInstalledForm(pPI, Action);
        Action = CheckPenSetButton(pPI, Action);

    } else {

        switch (pCurItem->DMPubID) {

        case PP_PENSET:

            if ((Reason == CPSUICB_REASON_EXTPUSH)          ||
                (Reason == CPSUICB_REASON_OPTITEM_SETFOCUS)) {

                PPENDATA    pPD;

                pPI   = (PPRINTERINFO)pCPSUICBParam->UserData;
                pPD   = (PPENDATA)pPI->pPlotGPC->Pens.pData;
                i     = (UINT)pPI->pPlotGPC->MaxPens;
                pItem = pCurItem++;

                if (Reason == CPSUICB_REASON_EXTPUSH) {

                    while (i--) {

                        pCurItem->Sel    = pPD->ColorIdx;
                        pCurItem->Flags |= OPTIF_CHANGED;

                        pCurItem++;
                        pPD++;
                    }

                    pItem->Flags |= (OPTIF_EXT_DISABLED |
                                     OPTIF_EXT_HIDE     |
                                     OPTIF_CHANGED);
                    Action        = CPSUICB_ACTION_REINIT_ITEMS;

                } else {

                    Action = CheckPenSetButton(pPI, Action);
                }
            }

            break;

        case PP_INSTALLED_FORM:

            if ((Reason == CPSUICB_REASON_SEL_CHANGED) ||
                (Reason == CPSUICB_REASON_OPTITEM_SETFOCUS)) {

                Action = CheckInstalledForm(pPI, Action);
            }

            break;

        default:

            break;
        }
    }

    return(Action);
}



LONG
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Show document property dialog box and update the output DEVMODE


Arguments:

    pPSUIInfo   - Pointer to the PROPSHEETUI_INFO data structure

    lParam      - LPARAM for this call, it is a pointer to the
                  DEVICEPROPERTYHEADER

Return Value:

    LONG, 1=successful, 0=failed.


Author:

    02-Feb-1996 Fri 10:47:42 created  


Revision History:


--*/

{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PPRINTERINFO            pPI;
    LONG_PTR                Result = -1;

    //
    // The MapPrinter will allocate memory, set default devmode, reading and
    // validating the GPC then update from current pritner registry, it also
    // will cached the pPI.

    if ((!pPSUIInfo) ||
        (!(pDPHdr = (PDEVICEPROPERTYHEADER)pPSUIInfo->lParamInit))) {

        SetLastError(ERROR_INVALID_DATA);
        return(ERR_CPSUI_GETLASTERROR);
    }

    if (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) {

        if (!(pPI = MapPrinter(pDPHdr->hPrinter,
                               NULL,
                               NULL,
                               MPF_HELPFILE | MPF_DEVICEDATA | MPF_PCPSUI))) {

            PLOTRIP(("DrvDevicePropertySheets: MapPrinter() failed"));

            SetLastError(ERROR_INVALID_DATA);
            return(ERR_CPSUI_GETLASTERROR);
        }

        pPI->Flags               = (pDPHdr->Flags & DPS_NOPERMISSION) ?
                                                    0 : PIF_UPDATE_PERMISSION;
        pPI->pCPSUI->Flags       = 0;
        pPI->pCPSUI->pfnCallBack = PPCallBack;
        pPI->pCPSUI->pDlgPage    = CPSUI_PDLGPAGE_PRINTERPROP;

        //
        // Add form to the database and find out if we can update
        //
        //  Move to DrvPrinterEven()
        //
        //
        // AddFormsToDataBase(pPI, TRUE);
        //

        Result = (LONG_PTR)SetupPPOptItems(pPI);

    } else {

        pPI    = (PPRINTERINFO)pPSUIInfo->UserData;
        Result = (LONG_PTR)pDPHdr->pszPrinterName;
    }

    return(DefCommonUIFunc(pPSUIInfo, lParam, pPI, Result));
}



BOOL
PrinterProperties(
    HWND    hWnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    This function first retrieves and displays the current set of printer
    properties for the printer.  The user is allowed to change the current
    printer properties from the displayed dialog box.

Arguments:

    hWnd        - Handle to the caller's window (parent window)

    hPrinter    - Handle to the pritner interested


Return Value:

    TRUE if function sucessful FALSE if failed


Author:

    06-Dec-1993 Mon 11:21:28 created  


Revision History:


--*/

{
    PRINTER_INFO_4          *pPI4;
    DEVICEPROPERTYHEADER    DPHdr;
    LONG                    Result = CPSUI_CANCEL;


    pPI4 = (PRINTER_INFO_4 *)GetPrinterInfo(hPrinter, 4);

    DPHdr.cbSize         = sizeof(DPHdr);
    DPHdr.Flags          = 0;
    DPHdr.hPrinter       = hPrinter;
    DPHdr.pszPrinterName = (pPI4) ? pPI4->pPrinterName : NULL;

    CallCommonPropertySheetUI(hWnd,
                              DrvDevicePropertySheets,
                              (LPARAM)&DPHdr,
                              (LPDWORD)&Result);

    if (pPI4) {

        LocalFree((HLOCAL)pPI4);
    }

    return(Result == CPSUI_OK);
}




BOOL
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    INT     Event,
    DWORD   Flags,
    LPARAM  lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    08-May-1996 Wed 17:38:34 created  


Revision History:

    04-Jun-1996 Tue 14:51:25 updated  
        Matched a ClosePrinter() to OpenPrinter()


--*/

{
    PRINTER_DEFAULTS    PrinterDef = { NULL, NULL, PRINTER_ALL_ACCESS };
    HANDLE              hPrinter;
    BOOL                bRet = TRUE;


    switch (Event) {

    case PRINTER_EVENT_INITIALIZE:

        if (OpenPrinter(pPrinterName, &hPrinter, &PrinterDef)) {

            PPRINTERINFO    pPI;

            if (pPI = MapPrinter(hPrinter, NULL, NULL, MPF_DEVICEDATA)) {

                bRet = AddFormsToDataBase(pPI, FALSE);

                UnMapPrinter(pPI);
            }

            ClosePrinter(hPrinter);
        }

        break;

    default:

        break;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\inc\tty.h ===
// Some General Includes

#include <stddef.h>
#include <stdlib.h>

#ifdef OEMCOM
#include <objbase.h>
#endif

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>


// Macros for Memory Allocation

#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS: Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"
#include "kmode.h"
#include <strsafe.h>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;
    HRESULT hr = S_FALSE;


    // Parameter checking.
    if( (NULL == lpszMessage) 
        || 
        (0 == dwSize) 
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }

        //
        // Just to make sure we dont go into infinite loop and allocate
        // lots of memory, lets bail out if memory requirement becomes huge. 
        // Multiplying by 8, i.e. will loop at most 4 times.
        //
        if ( dwSize > 8*DEBUG_BUFFER_SIZE )
        {
            return FALSE;
        }

        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

        hr = StringCchVPrintfA ( lpszMsgBuf, dwSize, lpszMessage, arglist);
    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED (hr) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;
    HRESULT    hr = S_FALSE;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hr = StringCchVPrintfW (lpszMsgBuf, dwSize, lpszMessage, arglist);
    if ( SUCCEEDED (hr) )
    {
        // Dump string to debug output.
        OutputDebugStringW(lpszMsgBuf);
    }

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//     Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include "kmode.h"


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\tools\ntres\plotgpc.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotgpc.c


Abstract:

    This module contains the function to generate plotter gpc data for
    NT 1.0a
    This module contains the functions required to generate a plotter gpc
    data file.


Development History:

    15-Feb-1994 Tue 22:50:10 updated  
        Add bitmap font caps

    09-Nov-1993 Tue 09:23:48 created 

    18-Mar-1994 Fri 14:00:14 updated  
        Adding PLOTF_RTL_NO_DPI_XY, PLOTF_RTLMONO_NO_CID and
        PLOTF_RTLMONO_FIXPAL flags


[Environment:]

    GDI Device Driver - PLOTTER


[Notes:]


Revision History:


--*/


#if 0

;
; Plotter GPC data file format
;
;  1. All key value(s) for the keyword must be encloses by a {} brace pair.
;  2. Any Strings must be enclosed by quotes ("").
;  3. a ';' denotes a comment to the end of the current line.
;  4. Types
;      a. FLAG      - 1 or 0
;      b. WORD      - 16 bit number
;      c. DWORD     - 32 bit number
;      d. STRING    - ANSI character string, maximum size depends on keyword
;      e. FORMSRC   - 1. 31 byte string for the name of the form (paper source)
;                     2. 2 DWORDs: size width/height (SIZEL) 1/1000mm
;                           ** if height is <= 25400 (1 inch) or it greater
;                              then DeviceSize CY then it is assumed that
;                              the form is variable length and the height
;                              will be reset to zero (0)
;
;                     3. 4 DWORDs: Left/Top/Right/Bottom margins in 1/1000mm
;
;      f. CONSTANT  - Pick from a set of predefined strings in the header file
;      g. COLORINFO - Windows 2000, Windows XP and Windows Server 2003 DDI COLORINFO data structure (30 DWORDs)
;      h. PENDATA   - 1. One word that specifies the location in the carousel
;                        of this pen (1=slot 1, 2=slot 2).
;                     2. constant which specifies the predefined pen color
;                        PC_IDX_xxxx can be one of:
;
;                        Index            R   G   B
;                       ------------------------------
;                       PC_IDX_WHITE     255 255 255
;                       PC_IDX_BLACK       0   0   0
;                       PC_IDX_RED       255   0   0
;                       PC_IDX_GREEN       0 255   0
;                       PC_IDX_YELLOW    255 255   0
;                       PC_IDX_BLUE        0   0 255
;                       PC_IDX_MAGENTA   255   0 255
;                       PC_IDX_CYAN        0 255 255
;                       PC_IDX_ORANGE    255 128   0
;                       PC_IDX_BROWN     255 192   0
;                       PC_IDX_VIOLET    128   0 255
;
;       i. ROPLEVEL - One of following levels:
;
;                       ROP_LEVEL_0 - No Rop support
;                       ROP_LEVEL_1 - ROP1 support (SRC)
;                       ROP_LEVEL_2 - ROP2 support (SRC/DEST)
;                       ROP_LEVEL_3 - ROP3 support (SRC/DEST/PAT)
;
;  *** if DeviceSize' height is <= 25400 (1 inch) then it is assumed that the
;      device can handle variable length paper and the height will be reset to
;      zero (0)
;
;  *** RasterDPI must be defined for both raster and pen plotters. For raster
;      plotters this should be the raster resolution of the device. For pen
;      plotters it should be the ideal resolution for the device that GDI
;      will report back to the calling windows application.
;
;  Keyword              Type    Count          Range/Size
; -------------------------------------------------------------------------
;  DeviceName           STRING    31           Device name as it appears in UI's
;  DeviceSize           DWORD     2            Device cx/cy in 1/1000mm
;  DeviceMargin         DWORD     4            Device L/T/R/B margin in 1/1000mm
;  RasterCap            Flag      1            0/1 (1=Raster Device, 2=Pen Device)
;  ColorCap             Flag      1            0/1 (1=Color Device, 2=Mono)
;  BezierCap            Flag      1            0/1 (1=Device supports HPGL2
;                                                   Beziers extension)
;  RasterByteAlign      Flag      1            0/1 (1=Device must receive all
;                                                   raster data on byte alligned
;                                                   x coordinates)
;  PushPopPal           Flag      1            0/1 (1=Driver must push/pop
;                                                  pallete when switching
;                                                  between RTL / HPGL2)
;  TransparentCap       Flag      1            0/1 (1=Device supports transp. cmd)
;  WindingFillCap       Flag      1            0/1 (1=Device can do winding fills)
;  RollFeedCap          Flag      1            0/1 (1=Device has roll paper src)
;  PaperTrayCap         Flag      1            0/1 has a main paper tray?
;  NoBitmapFont         Flag      1            0/1 Do not do bitmap font
;  RTLMonoEncode5       Flag      1            0/1 RTL Mono Compress Mode 5?
;  RTLNoDPIxy           Flag      1            0/1 NO RTL DPI X,Y Move command
;  RTLMonoNoCID         Flag      1            0/1 RTL Mono No CID command
;  RTLMonoFixPal        Flag      1            0/1 RTL Mono PAL ONLY 0=W, 1=K
;  PlotDPI              DWORD     2            Plotter UNIT X/Y Dots per Inch
;  RasterDPI            WORD      2            Raster (RTL) X/Y Dots per Inch
;  ROPLevel             DWORD     1            0/1/2/3
;  MaxScale             WORD      1            0-10000 (100 times bigger)
;  MaxPens              WORD      1            Device max # of pens for pen plotter
;  MaxCopies            WORD      1            Device max # of copies of each
;                                              page device can render by itself.
;  MaxPolygonPts        WORD      1            Device max # of points when defining
;                                              a polygon to later be stroked or
;                                              filled.
;  MaxQuality           WORD      1            Device maximum quality levels
;  PaperTraySize        DWORD     2            Paper Tray width/height in 1/1000mm
;  COLORINFO            DWORD     30           COLORINFO data structure
;  DevicePelsDPI        DWORD     1            Dots Per Inch
;  HTPatternSize        CONSTANT  1            HT_PATSIZE_xx
;  InitString           STRING    255          Standard string sent to device for
;                                              initialization.
;  PlotPenData          PENDATA   32 (Max)     Pen Plotter's carousel def.
;  FormInfo             FORMSRC   64           Device supported forms
;
; Following are example values for the PLOTTER characterization data:
;

DeviceName      { "HP DesignJet 650C (C2859B)" }; Device Name
DeviceSize      { 914400, 15240000 }            ; Device Size (36" x 50')
DeviceMargin    { 25400, 25400, 5000, 36000 }   ; Device Margin (in 1/1000mm)
RasterCap       { 1 }                           ; Pen/Raster plotter  (0/1)
ColorCap        { 1 }                           ; Color plotter (0/1)
BezierCap       { 1 }                           ; Can do bezier curves (0/1)
RasterByteAlign { 0 }                           ; need to byte aligned (0/1)
PushPopPal      { 1 }                           ; need to push/pop palette (0/1)
TransparentCap  { 0 }                           ; Has transparent mode (0/1)
WindingFillCap  { 0 }                           ; Can do winding fills (0/1)
RollFeedCap     { 1 }                           ; Can do RollPaper feed (0/1)
PaperTrayCap    { 0 }                           ; Has paper input tray (0/1)
NoBitmapFont    { 0 }                           ; Do not do bitmap font
RTLMonoEncode5  { 1 }                           ; RTL Mono Adapt Compression
RTLNoDPIxy      { 0 }                           ; Has RTL DPI XY move comand
RTLMonoNoCID    { 0 }                           ; Has RTL MONO CID Command
RTLMonoFixPal   { 0 }                           ; Can change RTL Palette 0/1
PlotDPI         { 1016, 1016 }                  ; Pen Plotter X/Y DPI
RasterDPI       { 300, 300 }                    ; Raster Plotter X/Y DPI
ROPLevel        { ROP_LEVEL_2 }                 ; ROP levels (0/1/2/3)
MaxScale        { 1600 }                        ; Maximum allowed Scale %
MaxPens         { 256 }                         ; Maximum allowed pens
MaxCopies       { 1 }                           ; Maximum allowed copies
MaxPolygonPts   { 8192 }                        ; Maximum Polygon points
MaxQuality      { 3 }                           ; Maximum quality levels

;
; Only needed if PaperTrayCap = 1,
;
PaperTraySize   { 215900, 279400 }        ; Letter size paper tray
;

COLORINFO       {  6810,  3050,     0,      ; xr, yr, Yr
                   2260,  6550,     0,      ; xg, yg, Yg
                   1810,   500,     0,      ; xb, yb, Yb
                   2000,  2450,     0,      ; xc, yc, Yc
                   5210,  2100,     0,      ; xm, ym, Ym
                   4750,  5100,     0,      ; xy, yy, Yy
                   3324,  3474, 10000,      ; xw, yw, Yw
                  10000, 10000, 10000,      ; RGB gamma
                   1422,   952,   787,      ; Dye correction datas
                    495,   324,   248 }

DevicePelsDPI   { 0 }                       ; effective device DPI (default)
HTPatternSize   { HT_PATSIZE_6x6_M }        ; GDI Halftone pattern size

InitString      { "\033E" }

;
; Only allowed if RasterCap = 0, and must define all pens (MaxPens)
;
; PlotPenData     {  1, PC_WHITE   }
; PlotPenData     {  2, PC_BLACK   }
; PlotPenData     {  3, PC_RED     }
; PlotPenData     {  4, PC_GREEN   }
; PlotPenData     {  5, PC_YELLOW  }
; PlotPenData     {  6, PC_BLUE    }
; PlotPenData     {  7, PC_MAGENTA }
; PlotPenData     {  8, PC_CYAN    }
; PlotPenData     {  9, PC_ORANGE  }
; PlotPenData     { 10, PC_BROWN   }
; PlotPenData     { 11, PC_VIOLET  }
;

FormInfo        { "Roll Paper 24 in",       609600,       0, 0, 0, 0, 0 }
FormInfo        { "Roll Paper 36 in",       914400,       0, 0, 0, 0, 0 }
FormInfo        { "ANSI A 8.5 x 11 in",     215900,  279400, 0, 0, 0, 0 }
FormInfo        { "ANSI B 11 x 17 in",      279400,  431800, 0, 0, 0, 0 }
FormInfo        { "ANSI C 17 x 22 in",      431800,  558800, 0, 0, 0, 0 }
FormInfo        { "ANSI D 22 x 34 in",      558800,  863600, 0, 0, 0, 0 }
FormInfo        { "ANSI E 34 x 44 in",      863600, 1117600, 0, 0, 0, 0 }
FormInfo        { "ISO A4 210 x 297 mm",    210000,  297000, 0, 0, 0, 0 }
FormInfo        { "ISO A3 297 x 420 mm",    297000,  420000, 0, 0, 0, 0 }
FormInfo        { "ISO A2 420 x 594 mm",    420000,  594000, 0, 0, 0, 0 }
FormInfo        { "ISO A1 594 x 841 mm",    594000,  841000, 0, 0, 0, 0 }
FormInfo        { "ISO A0 841 x 1189 mm",   841000, 1189000, 0, 0, 0, 0 }
FormInfo        { "ISO OS A2 480 x 625 mm", 480000,  625000, 0, 0, 0, 0 }
FormInfo        { "ISO OS A1 625 x 900 mm", 625000,  900000, 0, 0, 0, 0 }
FormInfo        { "JIS B4 257 x 364 mm",    257000,  364000, 0, 0, 0, 0 }
FormInfo        { "JIS B3 364 x 515 mm",    364000,  515000, 0, 0, 0, 0 }
FormInfo        { "JIS B2 515 x 728 mm",    515000,  728000, 0, 0, 0, 0 }
FormInfo        { "JIS B1 728 x 1030 mm",   728000, 1030000, 0, 0, 0, 0 }
FormInfo        { "Arch A 9 x 12 in",       228600,  304800, 0, 0, 0, 0 }
FormInfo        { "Arch B 12 x 18 in",      304800,  457200, 0, 0, 0, 0 }
FormInfo        { "Arch C 18 x 24 in",      457200,  609600, 0, 0, 0, 0 }
FormInfo        { "Arch D 24 x 36 in",      609600,  914400, 0, 0, 0, 0 }
FormInfo        { "Arch E 36 x 48 in",      914400, 1219200, 0, 0, 0, 0 }
FormInfo        { "Arch E1 30 x 42 in",     762000, 1066800, 0, 0, 0, 0 }




#endif


#define DBG_PLOTFILENAME    DbgPlotGPC



#include <stddef.h>
#include <windows.h>
#include <winddi.h>
#include <wingdi.h>
#include <winspool.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <strsafe.h>

#include <plotlib.h>

#define DBG_FORM            0x00000001
#define DBG_PAPERTRAY       0x00000002
#define DBG_FULLGPC         0x00000004


DEFINE_DBGVAR(0);


#if DBG
TCHAR   DebugDLLName[] = TEXT("PLOTGPC");
#endif



#define SIZE_ARRAY(a)           (sizeof((a)) / sizeof((a)[0]))
#define SIZE_COLORINFO          (sizeof(COLORINFO) / sizeof(LDECI4))

#define PK_FLAG                 0
#define PK_WORD                 1
#define PK_DWORD                2
#define PK_STRING               3
#define PK_FORMSRC              4
#define PK_PENDATA              5

#define PKF_DEFINED             0x8000
#define PKF_REQ                 0x0001
#define PKF_MUL_OK              0x0002
#define PKF_VARSIZE             0x0004
#define PKF_FS_VARLEN           0x0008
#define PKF_ALL                 0x0010

#define PKF_REQALL              (PKF_REQ | PKF_ALL)
#define PKF_ROLLPAPER           (PKF_MUL_OK | PKF_VARSIZE | PKF_FS_VARLEN)
#define PKF_FORMINFO            (PKF_MUL_OK     |           \
                                 PKF_VARSIZE    |           \
                                 PKF_REQ        |           \
                                 PKF_FS_VARLEN)
#define PKF_PENDATA             (PKF_MUL_OK | PKF_VARSIZE)

#define PLOTOFF(a)              (DWORD)FIELD_OFFSET(PLOTGPC, a)
#define GET_PLOTOFF(pPK)        ((LPBYTE)&PlotGPC + pPK->Data)
#define ADD_PLOTOFF(p, pPK)     ((LPBYTE)(p) + pPK->Data)


//
// The plotval is used to provide a name constant selection.
//

typedef struct _PLOTVAL {
    LPSTR   pValName;
    DWORD   Val;
    } PLOTVAL, *PPLOTVAL;

//
// The keyword parser structure
//

typedef struct _PLOTKEY {
    LPSTR       pKeyword;       // Keyword name
    WORD        KeywordLen;     // Keyword length
    WORD        Flags;          // PKF_xxxx
    WORD        Type;           // PK_xxxx
    SHORT       Count;          // maximum size allowed, < 0 if non-Zero string
    DWORD       Data;           // data
    LPVOID      pInfo;          // extra set of pointer data
    } PLOTKEY, *PPLOTKEY;

//
// Local/Global variables
//

PLOTVAL PenColorVal[PC_IDX_TOTAL + 1] = {

        { "PC_WHITE",   PC_IDX_WHITE    },
        { "PC_BLACK",   PC_IDX_BLACK    },
        { "PC_RED",     PC_IDX_RED      },
        { "PC_GREEN",   PC_IDX_GREEN    },
        { "PC_YELLOW",  PC_IDX_YELLOW   },
        { "PC_BLUE",    PC_IDX_BLUE     },
        { "PC_MAGENTA", PC_IDX_MAGENTA  },
        { "PC_CYAN",    PC_IDX_CYAN     },
        { "PC_ORANGE",  PC_IDX_ORANGE   },
        { "PC_BROWN",   PC_IDX_BROWN    },
        { "PC_VIOLET",  PC_IDX_VIOLET   },
        { NULL,         0xffffffff      }
    };

PLOTVAL ROPLevelVal[ROP_LEVEL_MAX + 2] = {

        { "ROP_LEVEL_0",        ROP_LEVEL_0     },
        { "ROP_LEVEL_1",        ROP_LEVEL_1     },
        { "ROP_LEVEL_2",        ROP_LEVEL_2     },
        { "ROP_LEVEL_3",        ROP_LEVEL_3     },
        { NULL,                 0xffffffff      }
    };

PLOTVAL HTPatSizeVal[] = {

        { "HT_PATSIZE_2x2",     HT_PATSIZE_2x2     },
        { "HT_PATSIZE_2x2_M",   HT_PATSIZE_2x2_M   },
        { "HT_PATSIZE_4x4",     HT_PATSIZE_4x4     },
        { "HT_PATSIZE_4x4_M",   HT_PATSIZE_4x4_M   },
        { "HT_PATSIZE_6x6",     HT_PATSIZE_6x6     },
        { "HT_PATSIZE_6x6_M",   HT_PATSIZE_6x6_M   },
        { "HT_PATSIZE_8x8",     HT_PATSIZE_8x8     },
        { "HT_PATSIZE_8x8_M",   HT_PATSIZE_8x8_M   },
        { "HT_PATSIZE_10x10",   HT_PATSIZE_10x10   },
        { "HT_PATSIZE_10x10_M", HT_PATSIZE_10x10_M },
        { "HT_PATSIZE_12x12",   HT_PATSIZE_12x12   },
        { "HT_PATSIZE_12x12_M", HT_PATSIZE_12x12_M },
        { "HT_PATSIZE_14x14",   HT_PATSIZE_14x14   },
        { "HT_PATSIZE_14x14_M", HT_PATSIZE_14x14_M },
        { "HT_PATSIZE_16x16",   HT_PATSIZE_16x16   },
        { "HT_PATSIZE_16x16_M", HT_PATSIZE_16x16_M },
        { NULL,                 0xffffffff         }
    };


BYTE        InitString[512] = "";
FORMSRC     AvaiForms[64];
PENDATA     AvaiPenData[MAX_PENPLOTTER_PENS];

UINT        MaxKeywordLen      = 0;
UINT        MaxPCValLen        = 0;
CHAR        szFormInfo[]       = "FormInfo";
CHAR        szPenData[]        = "PlotPenData";
CHAR        szPaperTrayCap[]   = "PaperTrayCap";
CHAR        szPaperTraySize[]  = "PaperTraySize";
CHAR        szNoBmpFont[]      = "NoBitmapFont";
CHAR        szRTLMonoEncode5[] = "RTLMonoEncode5";
CHAR        szRTLNoDPIxy[]     = "RTLNoDPIxy";
CHAR        szRTLMonoNoCID[]   = "RTLMonoNoCID";
CHAR        szRTLMonoFixPal[]  = "RTLMonoFixPal";



FILE        *InFile;
FILE        *OutFile;
UINT        LineNo;
CHAR        InFileName[80];



//
// The keys to search / parse
//

PLOTKEY PlotKey[] = {

    { "DeviceName",     0,PKF_REQ,        PK_STRING, (SHORT)CCHDEVICENAME,          PLOTOFF(DeviceName),    NULL         },
    { "DeviceSize",     0,PKF_REQALL,     PK_DWORD,  2,                             PLOTOFF(DeviceSize),    NULL         },
    { "DeviceMargin",   0,PKF_REQALL,     PK_DWORD,  4,                             PLOTOFF(DeviceMargin),  NULL         },
    { "RasterCap",      0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_RASTER,           NULL         },
    { "ColorCap",       0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_COLOR,            NULL         },
    { "BezierCap",      0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_BEZIER,           NULL         },
    { "RasterByteAlign",0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_RASTERBYTEALIGN,  NULL         },
    { "PushPopPal",     0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_PUSHPOPPAL,       NULL         },
    { "TransparentCap", 0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_TRANSPARENT,      NULL         },
    { "WindingFillCap", 0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_WINDINGFILL,      NULL         },
    { "RollFeedCap",    0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_ROLLFEED,         NULL         },
    { szPaperTrayCap,   0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_PAPERTRAY,        NULL         },
    { szNoBmpFont,      0,0,              PK_FLAG,   1,                             PLOTF_NO_BMP_FONT,      NULL         },
    { szRTLMonoEncode5, 0,0,              PK_FLAG,   1,                             PLOTF_RTLMONOENCODE_5,  NULL         },
    { szRTLNoDPIxy,     0,0,              PK_FLAG,   1,                             PLOTF_RTL_NO_DPI_XY,    NULL         },
    { szRTLMonoNoCID,   0,0,              PK_FLAG,   1,                             PLOTF_RTLMONO_NO_CID,   NULL         },
    { szRTLMonoFixPal,  0,0,              PK_FLAG,   1,                             PLOTF_RTLMONO_FIXPAL,   NULL         },
    { "PlotDPI",        0,PKF_REQALL,     PK_DWORD,  2,                             PLOTOFF(PlotXDPI),      NULL         },
    { "RasterDPI",      0,PKF_REQALL,     PK_WORD,   2,                             PLOTOFF(RasterXDPI),    NULL         },
    { "ROPLevel",       0,0,              PK_WORD,   1,                             PLOTOFF(ROPLevel),      ROPLevelVal  },
    { "MaxScale",       0,0,              PK_WORD,   1,                             PLOTOFF(MaxScale),      NULL         },
    { "MaxPens",        0,PKF_REQ,        PK_WORD,   1,                             PLOTOFF(MaxPens),       NULL         },
    { "MaxCopies",      0,0,              PK_WORD,   1,                             PLOTOFF(MaxCopies),     NULL         },
    { "MaxPolygonPts",  0,PKF_REQ,        PK_WORD,   1,                             PLOTOFF(MaxPolygonPts), NULL         },
    { "MaxQuality",     0,0,              PK_WORD,   1,                             PLOTOFF(MaxQuality),    NULL         },
    { szPaperTraySize,  0,PKF_ALL,        PK_DWORD,  2,                             PLOTOFF(PaperTraySize), NULL         },
    { "COLORINFO",      0,0,              PK_DWORD,  (SHORT)SIZE_COLORINFO,         PLOTOFF(ci),            NULL         },
    { "DevicePelsDPI",  0,0,              PK_DWORD,  1,                             PLOTOFF(DevicePelsDPI), NULL         },
    { "HTPatternSize",  0,0,              PK_DWORD,  1,                             PLOTOFF(HTPatternSize), HTPatSizeVal },
    { "InitString",     0,PKF_VARSIZE,    PK_STRING, -(SHORT)SIZE_ARRAY(InitString),PLOTOFF(InitString),    InitString   },
    { szPenData,        0,PKF_PENDATA,    PK_PENDATA,(SHORT)SIZE_ARRAY(AvaiPenData),PLOTOFF(Pens),          AvaiPenData  },
    { szFormInfo,       0,PKF_FORMINFO,   PK_FORMSRC,(SHORT)SIZE_ARRAY(AvaiForms),  PLOTOFF(Forms),         AvaiForms    },
    { NULL,             0 }
};


//
// Current default plotter's GPC
//

PLOTGPC PlotGPC = {

            PLOTGPC_ID,                         // ID
            PLOTGPC_VERSION,                    // Version
            sizeof(PLOTGPC),                    // cjThis
            0,                                  // SizeExtra
            "HPGL/2 Plotter",                   // DeviceName,
            { 215900, 279400 },                 // DeviceSize
            { 5000, 5000, 5000, 36000 },        // DeviceMargin
            0,                                  // Flags
            1016,                               // PlotXDPI
            1016,                               // PlotYDPI
            300,                                // RasterXDPI
            300,                                // RasterYDPI
            ROP_LEVEL_0,                        // ROPLevel
            100,                                // MaxScale
            8,                                  // MaxPens
            1,                                  // MaxCopies
            128,                                // MaxPolygonPts
            4,                                  // MaxQuality 100 levels

            { -1, -1 },                         // PaperTraySize = 0

            {                                   // ci
                { 6810, 3050,     0 },          // xr, yr, Yr
                { 2260, 6550,     0 },          // xg, yg, Yg
                { 1810,  500,     0 },          // xb, yb, Yb
                { 2000, 2450,     0 },          // xc, yc, Yc
                { 5210, 2100,     0 },          // xm, ym, Ym
                { 4750, 5100,     0 },          // xy, yy, Yy
                { 3324, 3474, 10000 },          // xw, yw, Yw
                10000, 10000, 10000,            // RGBB gamma
                1422,  952,                     // M/C, Y/C
                 787,  495,                     // C/M, Y/M
                 324,  248                      // C/Y, M/Y
            },

            0,                                  // DevicePelsDPI
            0xffffffff,                         // HTPatternSize

            { 0, 0,                NULL },      // init string
            { 0, sizeof(FORMSRC),  NULL },      // Forms
            { 0, sizeof(PENDATA),  NULL }       // Pens
        };



VOID
ShowUsage(
    VOID
    )
{
    fprintf(stderr, "\nPlotGPC [-?] InputDataFile [OutputPlotGPC]\n");
    fprintf(stderr, "Build NT Plotter GPC data file\n\n");
    fprintf(stderr, "               -?: display this message.\n");
    fprintf(stderr, "    InputDataFile: input ASCII data file\n");
    fprintf(stderr, "    OutputPlotGPC: output binary plotter gpc data file\n");

}



VOID
cdecl
DispError(
    INT     Level,
    LPSTR   pStr,
    ...
    )
{
    va_list vaList;

    if (Level) {

        if (Level > 2) {

            fprintf(stderr, "%s\n", InFileName);

        } else {

            fprintf(stderr, "\n%s(%u): ", InFileName, LineNo);
        }

        if (Level < 0) {

            fprintf(stderr, "INTERNAL ERROR: ");

        } else if (Level == 1) {

            fprintf(stderr, "warning: ");

        } else if (Level >= 2) {

            fprintf(stderr, "error: ");
        }

    } else {

        fprintf(stderr, "\n!!! ");
    }

    va_start(vaList, pStr);
    vfprintf(stderr, pStr, vaList);
    va_end(vaList);
}



VOID
ShowSpaces(
    UINT    Spaces
    )
{
    BYTE    Buf[81];


    while (Spaces) {

        memset(Buf, ' ', sizeof(Buf));

        if (Spaces > (sizeof(Buf) - 1)) {

            Buf[sizeof(Buf) - 1] = '\0';
            Spaces -= (sizeof(Buf) - 1);

        } else {

            Buf[Spaces] = '\0';
            Spaces = 0;
        }

        fprintf(stdout, "%s", Buf);
    }
}


VOID
ShowNumbers(
    LPBYTE      pNum,
    PPLOTVAL    pPV,
    WORD        Type,
    UINT        Count,
    UINT        NumDigits,
    UINT        NumPerLine
    )

/*++

Routine Description:

    This function shows numbers in the passed format.


Arguments:

    pNum        - Points to the number

    pPV         - Point to the value constant key name to be displayed

    Type        - PK_xxx type

    Count       - Total numbers

    NumDigits   - Total digits per number

    NumPerLine  - Total number per line to display


Return Value:

    VOID



Development History:

    09-Nov-1993 Tue 19:45:13 created  


Revision History:


--*/

{
    DWORD       *pdw;
    WORD        *pw;
    DWORD       dw;
    UINT        Wrap;
    static BYTE DigitFormat[] = "%4lu";


    if (NumDigits > 9) {

        NumDigits = 9;
    }

    DigitFormat[1] = (BYTE)(NumDigits + '0');
    pdw            = NULL;
    pw             = NULL;
    Wrap           = 0;


    if (pPV) {

        Count = 1;
    }

    switch (Type) {

    case PK_DWORD:

        pdw = (DWORD *)pNum;
        break;

    case PK_WORD:

        pw = (WORD *)pNum;
        break;

    default:

        DispError(-1, "ShowNumbers only allowes PK_WORD, PK_DWORD");
        return;
    }

    while (Count--) {

        if (pdw) {

            dw = *pdw++;

        } else {

            dw = (DWORD)*pw++;
        }

        if (pPV) {

            pPV += dw;

            fprintf(stdout, "%s", pPV->pValName);

        } else {

            fprintf(stdout, DigitFormat, dw);
        }

        if (Count) {

            fprintf(stdout, ", ");

            if (++Wrap >= NumPerLine) {

                fprintf(stdout, "\n");
                ShowSpaces(MaxKeywordLen + 3);
                Wrap = 0;
            }
        }
    }
}





UINT
ShowString(
    LPBYTE  pBuf,
    UINT    cBuf
    )

/*++

Routine Description:

    This function displays a formatted string


Arguments:

    pBuf    - points to the string buffer

    cBuf    - Size of the string pointed to by pBuf

Return Value:

    UINT    - total characters displayed



Development History:

    14-Dec-1993 Tue 09:47:06 created  


Revision History:


--*/

{
    BYTE    Ch;
    UINT    i = 1;


    if (!cBuf) {

        cBuf = strlen(pBuf);
    }

    fprintf(stdout, "\"");

    while (cBuf--) {

        Ch  = *pBuf++;
        i  += 2;

        if ((Ch >= ' ') && (Ch <= 0x7f)) {

            if (Ch == '\\') {

                fprintf(stdout, "\\\\");

            } else if (Ch == '\"') {

                fprintf(stdout, "\\\"");

            } else {

                fprintf(stdout, "%c", Ch);
                --i;
            }

        } else {

            if (Ch == '\a') {

                fprintf(stdout, "\\a");

            } else if (Ch == '\b') {

                fprintf(stdout, "\\b");

            } else if (Ch == '\f') {

                fprintf(stdout, "\\f");

            } else if (Ch == '\n') {

                fprintf(stdout, "\\n");

            } else if (Ch == '\r') {

                fprintf(stdout, "\\r");

            } else if (Ch == '\t') {

                fprintf(stdout, "\\t");

            } else {

                fprintf(stdout, "\\x%02x", Ch);
                ++i;
            }
        }
    }

    fprintf(stdout, "\"");

    return(++i);
}





BOOL
ShowOnePlotKey(
    PPLOTGPC    pPlotGPC,
    PPLOTKEY    pPK,
    UINT        VarSizeIdx,
    UINT        MaxLen
    )

/*++

Routine Description:

    This function takes a PLOTKEY structure and displays its content


Arguments:

    pPlotGPC    - Points to the current PLOTGPC data structure

    pPK         - Points to the PLOTKEY data structure

    VarSizeIdx  - a variable size index, must be less then pVS->Count

    MaxLen      - The size to pack the output into

Return Value:

    BOOL



Development History:

    14-Dec-1993 Tue 09:48:13 created  


Revision History:


--*/

{
    PGPCVARSIZE pVS = NULL;
    LPBYTE      pData;
    PFORMSRC    pFS;
    PPENDATA    pPD;
    UINT        i;
    DWORD       dw;



    pData = ADD_PLOTOFF(pPlotGPC, pPK);

    if (pPK->Flags & PKF_VARSIZE) {

        pVS = (PGPCVARSIZE)pData;

        if (VarSizeIdx >= pVS->Count) {

            DispError(-1, "VarSizeIdx [%u] > GPCVarSize.Count [%u",
                                 VarSizeIdx, pVS->Count);

            return(FALSE);
        }

        pData = (LPBYTE)pPK->pInfo + (pVS->SizeEach * VarSizeIdx);
    }

    fprintf(stdout, "\n%s", pPK->pKeyword);
    ShowSpaces(MaxKeywordLen - pPK->KeywordLen + 1);
    fprintf(stdout, "{ ");


    switch (pPK->Type) {

    case PK_FLAG:

        fprintf(stdout, "%c", (pPlotGPC->Flags & pPK->Data) ? '1' : '0');
        break;

    case PK_WORD:
    case PK_DWORD:

        ShowNumbers(pData,
                    (PPLOTVAL)pPK->pInfo,
                    pPK->Type,
                    (UINT)pPK->Count,
                    (pPK->Data == PLOTOFF(ci)) ? 5 : 0,
                    (pPK->Data == PLOTOFF(ci)) ? 3 : 6);

        break;

    case PK_STRING:

        if (pVS) {

            ShowString(pData, pVS->SizeEach);

        } else {

            ShowString(pData, 0);
        }

        break;

    case PK_FORMSRC:

        pFS = (PFORMSRC)pData;
        i   = ShowString(pFS->Name, 0);

        fprintf(stdout, ",");
        ShowSpaces(MaxLen + 2 - i);
        fprintf(stdout, "%7lu,%8lu,%5lu,%5lu,%5lu,%5lu",
                    pFS->Size.cx, pFS->Size.cy,
                    pFS->Margin.left,   pFS->Margin.top,
                    pFS->Margin.right,  pFS->Margin.bottom);
        break;

    case PK_PENDATA:

        pPD = (PPENDATA)pData;
        dw  = VarSizeIdx + 1;

        ShowNumbers((LPBYTE)&dw, NULL, PK_DWORD, 1, 2, 1);
        fprintf(stdout, ", ");
        i = ShowString(PenColorVal[pPD->ColorIdx].pValName, 0);
        ShowSpaces(MaxLen + 2 - i);
        break;
    }

    fprintf(stdout, " }");

    return(TRUE);
}



VOID
ShowPlotGPC(
    PPLOTGPC    pPlotGPC
    )

/*++

Routine Description:

    This function show current settings of plotter GPC structure.

Arguments:

    pPlotGPC    - the GPC to be displayed


Return Value:

    VOID



Development History:

    09-Nov-1993 Tue 19:07:05 created  


Revision History:


--*/

{
    PGPCVARSIZE pVS;
    PFORMSRC    pFS;
    PPLOTKEY    pPK;
    PLOTKEY     PK;
    UINT        i;
    UINT        Size;
    UINT        Count;
    UINT        MaxLen = 0;


    fprintf(stdout, "\n\n;\n; '%s' plotter characterization data\n;\n",
                                        pPlotGPC->DeviceName);

    pPK = &PlotKey[0];

    while (pPK->pKeyword) {

        PK = *pPK++;

        if (PK.Flags & PKF_VARSIZE) {

            pVS      = (PGPCVARSIZE)ADD_PLOTOFF(pPlotGPC, (&PK));
            Count    = pVS->Count;
            PK.pInfo = pVS->pData;

        } else {

            Count = 1;
        }

        if (PK.Type == PK_FORMSRC) {

            if (PK.Flags & PKF_VARSIZE) {

                pFS = (PFORMSRC)PK.pInfo;

            } else {

                pFS = (PFORMSRC)ADD_PLOTOFF(pPlotGPC, pPK);
            }

            for (MaxLen = i = 0; i < Count; i++, pFS++) {

                if ((Size = strlen(pFS->Name)) > MaxLen) {

                    MaxLen = Size;
                }
            }
        }

        if (PK.Type == PK_PENDATA) {

            MaxLen = MaxPCValLen;
        }

        if (Count > 1) {

            fprintf(stdout, "\n");
        }

        for (i = 0; i < Count; i++) {

            ShowOnePlotKey(pPlotGPC, &PK, i, MaxLen);
        }
    }

    fprintf(stdout, "\n\n");
}




#if 0


VOID
ShowUndefined(
    VOID
    )

/*++

Routine Description:

    This function displayes all undefined keywords


Arguments:


    nono


Return Value:

    VOID


Development History:

    12-Nov-1993 Fri 17:20:24 created 


Revision History:


--*/

{
    PPLOTKEY    pPK;
    BOOL        Ok = TRUE;


    pPK = (PPLOTKEY)&PlotKey[0];

    while (pPK->pKeyword) {

        if (!(pPK->Flags & PKF_DEFINED)) {

            DispError(1, "keyword '%s' not defined.", pPK->pKeyword);
            Ok = FALSE;
        }

        ++pPK;
    }

    if (!Ok) {

        fprintf(stdout, "\n\n");
    }
}

#endif



LPBYTE
GetOneLine(
    BOOL    SkipFrontSpace
    )

/*++

Routine Description:

    This function return the next line in the input file string


Arguments:

    SkipFrontSpace  - skip the white space in the begining of the line

Return Value:

    pointer to the string, NULL if Error/EOF



Development History:

    09-Nov-1993 Tue 10:39:31 created  


Revision History:


--*/

{
    LPBYTE      pLine;
    static BYTE LineBuf[1024];


    while (fgets(LineBuf, sizeof(LineBuf) - 1, InFile)) {

        ++LineNo;

        //
        // Skip End white spaces
        //

        pLine = &LineBuf[strlen(LineBuf)];

        while ((pLine > LineBuf) && (isspace(*(pLine - 1)))) {

            --pLine;
        }

        *pLine = '\0';

        //
        // Skip Front white spaces
        //

        pLine = LineBuf;

        if (SkipFrontSpace) {

            while ((*pLine) && (isspace(*pLine))) {

                ++pLine;
            }
        }

        if (*pLine) {

            return(pLine);
        }
    }

    return (NULL);
}






LPBYTE
ParseString(
    LPSTR   pKeyword,
    LPBYTE  *pLineLoc,
    LPBYTE  pBuf,
    SHORT   cBuf
    )

/*++

Routine Description:

    This function takes a pBuf and parses a series of characters into a string,
    it may contain escape format characters, the string may or may not be NULL
    terminated

Arguments:

    pKeyword    - Current keyword name

    pLineLoc    - Pointer to pointer of buffer line location

    pBuf        - Pointer to the buffer

    cBuf        - size of output buffer, if negative then NULL is allowed in
                  the string

Return Value:

    LPBYTE points to the end of the string, NULL if failure.



Development History:

    14-Dec-1993 Tue 09:52:07 created 


Revision History:


--*/

{
#define STR_STATE_ERROR     -1
#define STR_STATE_END       0
#define STR_STATE_BYTE      1
#define STR_STATE_BKSLASH   2
#define STR_STATE_HEX1      3
#define STR_STATE_HEX2      4
#define STR_STATE_OCT2      5
#define STR_STATE_OCT3      6

    LPBYTE  pLine;
    LPBYTE  pStrBuf;
    LPBYTE  pEnd;
    INT     State;
    INT     Number;
    BOOL    Error = FALSE;
    BOOL    szStr;
    BYTE    Ch;


    if (cBuf < 0) {

        cBuf  = -cBuf;
        szStr = FALSE;

    } else {

        szStr = TRUE;
    }

    pLine   = *pLineLoc;
    pStrBuf = pBuf;
    pEnd    = pBuf + cBuf - 1;
    State   = STR_STATE_BYTE;

    while ((State != STR_STATE_ERROR)   &&
           (State != STR_STATE_END)     &&
           (pBuf <= pEnd)               &&
           (Ch = *pLine++)) {

        switch (State) {

        case STR_STATE_BYTE:

            if (Ch == '\\') {

                //
                // Check if end of the line, if so read the next line in
                // without stripping white space.
                //

                if (*pLine == '\0') {

                    if (!(pLine = GetOneLine(FALSE))) {

                        Ch = 0;
                        State = STR_STATE_ERROR;

                    } else {

                        continue;
                    }

                } else {

                    State = STR_STATE_BKSLASH;
                }

            } else if (Ch == '\"') {

                State = STR_STATE_END;
            }

            break;

        case STR_STATE_BKSLASH:

            State = STR_STATE_BYTE;

            switch (Ch) {

            case '0':       //
            case '1':       // Maximum OCT number is 377
            case '2':
            case '3':

                Number = (INT)(Ch - '0');
                State  = STR_STATE_OCT2;
                break;

            case 'x':

                Number = 0;
                State  = STR_STATE_HEX1;
                break;

            case 'a':

                Ch = '\a';
                break;

            case 'b':

                Ch = '\b';
                break;

            case 'f':

                Ch = '\f';
                break;

            case 'n':

                Ch = '\n';
                break;

            case 'r':

                Ch = '\r';
                break;

            case 't':

                Ch = '\t';
                break;

            case '\\':
            case '\"':

                break;

            default:

                DispError(2, "Invalid escape character '%c' (%s)", Ch, pKeyword);
                State = STR_STATE_ERROR;
            }

            break;

        case STR_STATE_OCT2:
        case STR_STATE_OCT3:

            if ((Ch >= '0') && (Ch <= '7')) {

                Number = (INT)((Number * 8) + (Ch - '0'));

                if (State == STR_STATE_OCT2) {

                    State = STR_STATE_OCT3;

                } else {

                    State = STR_STATE_BYTE;
                    Ch    = (BYTE)Number;
                }

            } else {

                DispError(2, "invalid digits for octal number '%c'", Ch);
                State = STR_STATE_ERROR;
            }

            break;

        case STR_STATE_HEX1:
        case STR_STATE_HEX2:

            if ((Ch >= '0') && (Ch <= '9')) {

                Number = (INT)((Number << 4) | (Ch - '0'));

            } else if ((Ch >= 'a') && (Ch <= 'f')) {

                Number = (INT)((Number << 4) | (Ch - 'a' + 10));

            } else if ((Ch >= 'A') && (Ch <= 'F')) {

                Number = (INT)((Number << 4) | (Ch - 'A' + 10));

            } else if (State == STR_STATE_HEX1) {

                DispError(2, "string hex escape must have at least one hex digit");

                State = STR_STATE_ERROR;

            } else {

                --pLine;        // re-process current one
            }

            if (State == STR_STATE_HEX1) {

                State = STR_STATE_HEX2;

            } else {

                Ch    = (BYTE)Number;
                State = STR_STATE_BYTE;
            }
        }

        if (State == STR_STATE_BYTE) {

            if ((szStr) && (!Ch)) {

                //
                // Do not allowe zero in the string
                //

                DispError(2, "CANNOT have NULL char. in the middle of '%s' string",
                                                    pKeyword);
                State = STR_STATE_ERROR;

            } else {

                *pBuf++ = Ch;
            }
        }
    }

    if (State != STR_STATE_END) {

        Error = TRUE;

        if (pBuf > pEnd) {

            DispError(2, "string too big: maximum length is %u for '%s'.",
                                                cBuf - 1, pKeyword);

        } else if (Ch == 0) {

            DispError(2, "string must end with a '\"'");
        }
    }

    *pLineLoc = pLine;

    if (Error) {

        return(NULL);

    } else {

        *pBuf = '\0';

        if (pStrBuf == pBuf) {

            DispError(1, "NULL string is defined for '%s'", pKeyword);
        }

        return(pBuf);
    }

#undef STR_STATE_ERROR
#undef STR_STATE_END
#undef STR_STATE_BYTE
#undef STR_STATE_BKSLASH
#undef STR_STATE_HEX1
#undef STR_STATE_HEX2
#undef STR_STATE_OCT2
#undef STR_STATE_OCT3
}





LPBYTE
GetNextToken(
    LPSTR   pKeyword,
    LPBYTE  pBuf,
    SHORT   cBuf
    )

/*++

Routine Description:

    This function retrieves the next token from the input file


Arguments:

    pKeyword    - Current keyword name

    pBuf        - pointer to the string parsing output buffer, if not NULL

    cBuf        - size of pBuf


Return Value:

    LPBYTE  - a pointer to the output buffer or token string, NULL if failure



Development History:

    09-Nov-1993 Tue 11:21:11 created 


Revision History:


--*/

{
    static LPBYTE   pLine = NULL;
    static BYTE     LastCh = '\0';


    if (pLine == NULL) {

        LineNo = 0;
        pLine  = GetOneLine(TRUE);
    }

    if (LastCh) {

        *pLine = LastCh;
        LastCh = '\0';
    }

    LastCh = 0;

    if (pBuf) {

        if (!cBuf) {

            return(pBuf);
        }

        //
        // reading a string section
        //

        while (pLine) {

            while((*pLine) &&
                  ((isspace(*pLine)) ||
                   (*pLine == ','))) {

                pLine++;
            }

            if ((*pLine) && (*pLine != ';')) {

                if (*pLine++ != '"') {

                    DispError(2, "string must enclosed by \" (Quote)");
                    return(NULL);
                }

                return(ParseString(pKeyword, &pLine, pBuf, cBuf));

            } else {

                pLine = GetOneLine(TRUE);
            }
        }

    } else {

        while (pLine) {

            while((*pLine) &&
                  ((isspace(*pLine)) ||
                   (*pLine == ','))) {

                pLine++;
            }

            if ((*pLine) && (*pLine != ';')) {

                LPBYTE  pLineRet = pLine;

                while((*pLine)           &&
                      (!isspace(*pLine)) &&
                      (*pLine != ',')    &&
                      (*pLine != '{')    &&
                      (*pLine != '}')) {

                    ++pLine;
                }

                if ((*pLine == '{') ||
                    (*pLine == '}')) {

                    if (pLine == pLineRet) {

                        ++pLine;
                    }

                    LastCh = *pLine;
                    *pLine = '\0';

                } else {

                    *pLine++ = '\0';
                }

                // fprintf(stderr, "\nTOKEN = '%s'", pLineRet);
                return(pLineRet);

            } else {

                pLine = GetOneLine(TRUE);
            }
        }
    }

    return(NULL);
}


BOOL
CheckSingleToken(
    BYTE    Token
    )

/*++

Routine Description:

    Check if a single character 'Token' exists


Arguments:

    Token   - Token to be checked


Return Value:

    TRUE if found, FALSE otherwise


Development History:

    09-Nov-1993 Tue 12:13:33 created  

Revision History:


--*/

{
    LPBYTE  pToken;


    if (!(pToken = GetNextToken(NULL, NULL, 0))) {

        DispError(2, "Unexpected end of file.");
        return(FALSE);
    }

    return(*pToken == Token);
}




BOOL
ConvertNumber(
    LPSTR   pBuf,
    BOOL    NegOk,
    LONG    *pRetVal
    )

/*++

Routine Description:

    Convert pBuf to a number based on the parameters passed


Arguments:

    pBuf    - Point to the string to be converted to a number

    NegOk   - TRUE if a negative number is allowed

    pRetVal - Pointer to a LONG to return a converted number

Return Value:

    TRUE if sucessful, FALSE if falied.



Development History:

    09-Nov-1993 Tue 18:47:43 created  


Revision History:


--*/

{
    if ((*pRetVal = atol(pBuf)) < 0) {

        if (!NegOk) {

            DispError(2, "expect a positive number. [%s]", pBuf);
            return(FALSE);
        }

    } else if (*pRetVal == 0) {

        if (*pBuf != '0') {

            DispError(2, "expect a number. [%s]", pBuf);
            return(FALSE);
        }
    }

    return(TRUE);

}




INT
ReadNumbers(
    LPSTR       pKeyword,
    LPVOID      pNumbers,
    PPLOTVAL    pPlotVal,
    UINT        Total,
    UINT        Type,
    UINT        Flags
    )

/*++

Routine Description:

    This function reads the next token and returns a number, the number can be

        1. '0x' prefixed for a hex type
        2. normal for an integer type


Arguments:

    pPK     - Pointer to PLOTKEY

Return Value:


    Expanded to DWORD, this function will only read positive numbers



Development History:

    09-Nov-1993 Tue 11:03:36 created  


Revision History:


--*/

{
    PPLOTVAL    pPV;
    LPBYTE      pToken;
    UINT        Count;
    DWORD       SetBit;
    DWORD       *pdw;
    WORD        *pw;


    pdw = NULL;
    pw  = NULL;

    switch (Type) {

    case PK_WORD:

        pw = (WORD *)pNumbers;
        break;

    case PK_DWORD:

        pdw = (DWORD *)pNumbers;
        break;

    case PK_FLAG:

        if (Total != 1) {

            DispError(-1, "PK_FLAG has more than one count");
            Total = 1;
        }

        SetBit = *(DWORD *)pNumbers;

        break;

    default:

        DispError(-1, "!!Unknow key type!!, internal error");
        return(-1);
    }

    for (Count = 0; Count < Total; Count++) {

        LONG    RetVal;
        BYTE    Ch;


        RetVal = 0;

        if (pToken = GetNextToken(pKeyword, NULL, 0)) {

            if (*pToken == '}') {

                if (!Count) {

                    DispError(1, "%s none of %u numbers defined",
                                                            pKeyword, Total);

                } else {

                    DispError(1, "%s defined only %u of %u numbers",
                                                    pKeyword, Count, Total);
                }

                if (Flags & PKF_ALL) {

                    DispError(2, "All %u numbers in keyword '%s' must defined",
                                        Total, pKeyword);
                    return(-1);

                } else {

                    return(0x01);
                }

            } else if (pPV = pPlotVal) {

                while (pPV->pValName) {

                    if (!_stricmp(pToken, pPV->pValName)) {

                        break;
                    }

                    ++pPV;
                }

                if (pPV->pValName) {

                    RetVal = pPV->Val;

                } else {

                    DispError(2, "unknown key value '%s' for keyword '%s'",
                                                    pToken, pKeyword);
                    return(-1);
                }

            } else if ((*pToken == '0') &&
                       ((*(pToken + 1) == 'x') || (*(pToken + 1) == 'X'))) {

                   //
                   // This is a Hex type format
                   //

                   pToken += 2;

                   while (Ch = *pToken++) {

                       if ((Ch >= '0') && (Ch <= '9')) {

                           Ch -= '0';

                       } else if ((Ch >= 'a') && (Ch <= 'f')) {

                           Ch = (Ch - 'a') + 10;

                       } else if ((Ch >= 'A') && (Ch <= 'F')) {

                           Ch = (Ch - 'A') + 10;

                       }  else {

                           break;
                       }

                       RetVal = (LONG)(((DWORD)RetVal << 4) | (DWORD)Ch);
                   }

            } else if (!ConvertNumber(pToken, Type == PK_FLAG, &RetVal)) {

                DispError(2, "expect another %u numbers. [%s]",
                                                Total - Count, pToken);
                return(-1);
            }

            if (pdw) {

                *pdw++ = (DWORD)RetVal;

            } else if (pw) {

                *pw++ = (WORD)RetVal;

            } else {

                if (RetVal) {

                    PlotGPC.Flags |= SetBit;

                } else {

                    PlotGPC.Flags &= ~SetBit;
                }
            }

        } else {

            DispError(2, "'%s' expect another %u numbers. [End Of File]",
                                                pKeyword, Total - Count);
            return(-1);
        }
    }

    return(0);
}





INT
ReadString(
    PPLOTKEY    pPK
    )

/*++

Routine Description:

    This function reads in the string for the PK (plotkey)


Arguments:

    pPK - Points to the PLOTKEY data structure


Return Value:

    size of the string that was read.


Development History:

    12-Nov-1993 Fri 12:25:50 created  


Revision History:


--*/

{
    LPBYTE  pBuf;
    LPBYTE  pEnd;


    pBuf = (LPBYTE)((pPK->Flags & PKF_VARSIZE) ? pPK->pInfo : GET_PLOTOFF(pPK));

    if (!(pPK->Flags & PKF_VARSIZE)) {

        if (pPK->Count < 0) {

            DispError(-1, "'%s' is a non-variable size string, it CANNOT have NULL char",
                                                    pPK->pKeyword);
            return(-1);
        }
    }

    if (pEnd = GetNextToken(pPK->pKeyword, pBuf, pPK->Count)) {

        UINT    Size = (UINT)(pEnd - pBuf);

        if (pPK->Flags & PKF_VARSIZE) {

            PGPCVARSIZE pVS;


            pVS = (PGPCVARSIZE)GET_PLOTOFF(pPK);

            if (Size) {

                pVS->Count = 1;
            }

            pVS->SizeEach = (WORD)Size;
            pVS->pData    = NULL;
        }

        return((pBuf[0] == '\0') ? 0x02 : 0x00);
    }

    return(-1);
}




BOOL
CheckFormSrc(
    LPBYTE      pKeyword,
    WORD        Flags,
    SIZEL       *pSize,
    RECTL       *pMargin,
    LPSTR       pFormName,
    INT         ErrNo
    )

/*++

Routine Description:

    Check if FORMSRC input is valid

Arguments:

    pKeyword    - Point to current keyword

    Flags       - PKF_xxxx

    pSize       - pointer to SIZEL for Form size

    RECTL       - Pointer to the RECTL for margins

    pFormName   - Name of the form

    ErrNo       - error number to send to DispError() if an error occurs


Return Value:


    TRUE if OK, FALSE otherwise



Development History:

    18-Nov-1993 Thu 00:04:12 created  


Revision History:


--*/

{

    if (pSize->cx < MIN_PLOTGPC_FORM_CX) {

        DispError(ErrNo, "minimum height for '%s' (%s) must >= %lu",
                                    pFormName, pKeyword, MIN_PLOTGPC_FORM_CX);
        return(FALSE);
    }

    if (pSize->cy < MIN_PLOTGPC_FORM_CY) {

        if (Flags & PKF_FS_VARLEN) {

            if (pSize->cy) {

                pSize->cy = 0;
                DispError(1, "ASSUME variable length (set to 0) for '%s' (%s)",
                                                    pFormName, pKeyword);
            }

        } else {

            DispError(ErrNo, "minimum height for '%s' (%s) must >= %lu",
                                pFormName, pKeyword, MIN_PLOTGPC_FORM_CY);
            return(FALSE);
        }
    }

    if ((pSize->cx - pMargin->left - pMargin->right) < MIN_PLOTGPC_FORM_CX) {

        DispError(ErrNo, "invalid left/right margins for '%s' (%s)",
                                                    pFormName, pKeyword);
        return(FALSE);
    }

    if ((pSize->cy) &&
        ((pSize->cx - pMargin->left - pMargin->right) < MIN_PLOTGPC_FORM_CY)) {

        DispError(ErrNo, "invalid top/bottom margins for '%s' (%s)",
                                                    pFormName, pKeyword);
        return(FALSE);
    }

    return(TRUE);
}




INT
ReadFormSrc(
    PPLOTKEY    pPK
    )

/*++

Routine Description:

    Input a FORMSRC line from the input file.


Arguments:

    pPK - Pointer to the PLOTKEY data structure


Return Value:

    INT - >= 0 if OK, -1 if failure, a 0 return means no '}' end bracket is read
    a > 0 means '}' already read.



Development History:

    12-Nov-1993 Fri 13:34:50 created  


Revision History:


--*/

{
    PGPCVARSIZE pVS;
    PFORMSRC    pFS;


    pVS = NULL;
    pFS = (PFORMSRC)GET_PLOTOFF(pPK);

    if (pPK->Flags & PKF_VARSIZE) {

        pVS = (PGPCVARSIZE)pFS;
        pFS = (PFORMSRC)pPK->pInfo;

        if (pVS->Count >= pPK->Count) {

            DispError(2, "too many '%s' defined, allowed only (%u)",
                                            pPK->pKeyword, pPK->Count);
            return(-1);
        }

        pFS += pVS->Count;
    }

    ZeroMemory(pFS, sizeof(FORMSRC));

    if ((GetNextToken(pPK->pKeyword, pFS->Name, CCHFORMNAME)) &&
        (pFS->Name[0]) &&
        (ReadNumbers(pPK->pKeyword,
                     (LPVOID)&pFS->Size,
                     NULL,
                     6,
                     PK_DWORD,
                     PKF_REQ) >= 0) &&
        (CheckFormSrc(pPK->pKeyword,
                      pPK->Flags,
                      &(pFS->Size),
                      &(pFS->Margin),
                      &(pFS->Name[0]),
                      2))) {

        if (pVS) {

            PFORMSRC    pOrgFS = (PFORMSRC)pPK->pInfo;
            UINT        i = pVS->Count;

            while (i--) {

                if (_stricmp(pFS->Name, pOrgFS->Name) == 0) {

                    DispError(2, "'%s' already defined in keyword '%s'",
                                                pOrgFS->Name, pPK->pKeyword);
                    return(-1);
                }

                pOrgFS++;
            }

            pVS->Count    += 1;
            pVS->SizeEach  = sizeof(FORMSRC);
            pVS->pData     = NULL;

        }

        return(0);
    }

    return(-1);
}





INT
ReadPenData(
    PPLOTKEY    pPK
    )

/*++

Routine Description:

    Read a PENDATA structure


Arguments:

    pPK - Pointer to the PLOTKEY data structure


Return Value:

    INT - >= 0 if OK, -1 if failed,  0 if no '}' end bracket is
    definined, > 0 means '}' already read.



Development History:

    12-Nov-1993 Fri 13:34:50 created  


Revision History:


--*/

{
    PGPCVARSIZE pVS;
    PPENDATA    pPD;
    PENDATA     PD;
    WORD        IdxPen;
    INT         Ret;


    pVS = (PGPCVARSIZE)GET_PLOTOFF(pPK);
    pPD = (PPENDATA)pPK->pInfo;

    if ((ReadNumbers(pPK->pKeyword,
                     (LPVOID)&IdxPen,
                     NULL,
                     1,
                     PK_WORD,
                     PKF_REQ) == 0) &&
        ((Ret = ReadNumbers(pPK->pKeyword,
                            (LPVOID)&PD.ColorIdx,
                            PenColorVal,
                            1,
                            PK_WORD,
                            PKF_REQ)) >= 0)) {

        if (IdxPen <= 0) {

            DispError(2, "first pen number started at one (1), not zero (0).");
            return(-1);
        }

        if (IdxPen > MAX_PENPLOTTER_PENS) {

            DispError(2, "maximum pen number is '%s'.", MAX_PENPLOTTER_PENS);
            return(-1);
        }

        pPD += (IdxPen - 1);

        if (pPD->ColorIdx != 0xffff) {

            DispError(1, "redefined Pen #%d for '%s' keyword '%s'",
                                        IdxPen, pPK->pKeyword);

        } else {

            ++pVS->Count;
        }

        *pPD = PD;

        pVS->SizeEach = sizeof(PENDATA);
        pVS->pData    = NULL;

        return(Ret);
    }

    return(-1);
}




PPLOTGPC
GetFullPlotGPC(
    VOID
    )

/*++

Routine Description:

    This function converts the current contents of PlotGPC to allocated memory
    so it has the entire PLOTGPC defined

Arguments:

    VOID


Return Value:

    PPLOTGPC, Pointer to the PLOTGPC packed and converted, NULL if failure



Development History:

    17-Nov-1993 Wed 17:08:53 created  


Revision History:


--*/

{
    PPLOTGPC    pPlotGPC;
    LPBYTE      pData;
    DWORD       InitStrSize[2];
    DWORD       FormsSize[2];
    DWORD       PlotPensSize[2];
    DWORD       SizeExtra;



    if ((PlotGPC.InitString.Count == 1)   ||
        (PlotGPC.InitString.SizeEach)) {

        //
        // Include the NULL terminated character
        //

        InitStrSize[0] = PlotGPC.InitString.SizeEach + 1;

    } else {

        InitStrSize[0] = 0;
        ZeroMemory(&(PlotGPC.InitString), sizeof(GPCVARSIZE));
    }

    if ((PlotGPC.Forms.Count)                       &&
        (PlotGPC.Forms.SizeEach == sizeof(FORMSRC))) {

        FormsSize[0] = sizeof(FORMSRC) * PlotGPC.Forms.Count;

    } else {

        FormsSize[0] = 0;
        ZeroMemory(&(PlotGPC.Forms), sizeof(GPCVARSIZE));
    }

    if ((PlotGPC.Pens.Count)                        &&
        (PlotGPC.Pens.SizeEach == sizeof(PENDATA))) {

        PlotPensSize[0] = sizeof(PENDATA) * PlotGPC.Pens.Count;

    } else {

        PlotPensSize[0] = 0;
        ZeroMemory(&(PlotGPC.Pens), sizeof(GPCVARSIZE));
    }

    SizeExtra = (InitStrSize[1]  = DWORD_ALIGNED(InitStrSize[0])) +
                (FormsSize[1]    = DWORD_ALIGNED(FormsSize[0]))   +
                (PlotPensSize[1] = DWORD_ALIGNED(PlotPensSize[0]));


    PLOTDBG(DBG_FULLGPC, ("Size = PLOTGPC=%ld + SizeExtra=%ld = %ld",
                    sizeof(PLOTGPC), SizeExtra,  sizeof(PLOTGPC) + SizeExtra));


    if (pPlotGPC = (PPLOTGPC)LocalAlloc(LPTR, sizeof(PLOTGPC) + SizeExtra)) {

        PlotGPC.SizeExtra = (WORD)SizeExtra;

        CopyMemory(pData = (LPBYTE)pPlotGPC, &PlotGPC, sizeof(PLOTGPC));

        pData += sizeof(PLOTGPC);

        if (InitStrSize[0]) {

            CopyMemory(pData, InitString, InitStrSize[0]);
            pPlotGPC->InitString.pData = (LPVOID)pData;
            pData += InitStrSize[1];
        }

        if (FormsSize[0]) {

            CopyMemory(pData, AvaiForms, FormsSize[0]);
            pPlotGPC->Forms.pData = (LPVOID)pData;
            pData += FormsSize[1];
        }

        if (PlotPensSize[0]) {

            CopyMemory(pData, AvaiPenData, PlotPensSize[0]);
            pPlotGPC->Pens.pData = (LPVOID)pData;
            pData += PlotPensSize[1];
        }
    }

    return(pPlotGPC);
}




INT
ParsePlotGPC(
    VOID
    )

/*++

Routine Description:

    This function parses a PlotGPC from a text file


Arguments:

    VOID


Return Value:

    INT, >= 0 means ok, -x if a failure occured.


Development History:

    09-Nov-1993 Tue 12:19:20 created  


Revision History:


--*/

{
    LPBYTE      pToken;
    PPLOTKEY    pPK;
    INT         Result;
    LONG        cy;
    INT         i;


    while (pToken = GetNextToken(NULL, NULL, 0)) {

        pPK = (PPLOTKEY)&PlotKey[0];

        while (pPK->pKeyword) {

            if (!_stricmp(pToken, pPK->pKeyword)) {

                break;
            }

            ++pPK;
        }

        if (pPK->pKeyword) {

            // fprintf(stderr, "\nFound keyword '%s'", pToken);

            if ((pPK->Flags & PKF_DEFINED) &&
                (!(pPK->Flags & PKF_MUL_OK))) {

                DispError(1, "keyword '%s' section redefined.", pToken);
            }

            if (!CheckSingleToken('{')) {

                DispError(2, "expect '{' after keyword '%s. key values must enclosed in {}",
                                                        pPK->pKeyword);
                return(-1);
            }

            switch (pPK->Type) {

            case PK_FLAG:

                Result = ReadNumbers(pPK->pKeyword,
                                     (LPVOID)&(pPK->Data),
                                     (PPLOTVAL)pPK->pInfo,
                                     pPK->Count,
                                     PK_FLAG,
                                     pPK->Flags);
                break;

            case PK_WORD:
            case PK_DWORD:

                Result = ReadNumbers(pPK->pKeyword,
                                     (LPVOID)GET_PLOTOFF(pPK),
                                     (PPLOTVAL)pPK->pInfo,
                                     pPK->Count,
                                     pPK->Type,
                                     pPK->Flags);
                break;

            case PK_STRING:

                Result = ReadString(pPK);
                break;

            case PK_FORMSRC:

                Result = ReadFormSrc(pPK);
                break;

            case PK_PENDATA:

                Result = ReadPenData(pPK);
                break;

            default:

                Result = -1;
                break;
            }

            if (Result < 0) {

                return(-1);
            }

            if (!(Result & 0x01)) {

                if (!CheckSingleToken('}')) {

                    DispError(2, "unbalanced braces, missing '}' at end of keyword '%s'",
                                                        pPK->pKeyword);
                    return(-1);
                }
            }

            if (!(Result & 0x02)) {

                pPK->Flags |= PKF_DEFINED;
            }

        } else {

            DispError(2, "Unknown keyword '%s'", pToken);
            return(-1);
        }
    }

    if (PlotGPC.Flags & PLOTF_RASTER) {

        if (PlotGPC.Flags & PLOTF_COLOR) {

            PlotGPC.Flags &= ~PLOTF_RTLMONO_NO_CID;
        }

        if ((pPK->pKeyword == szRTLMonoEncode5) &&
            (!(pPK->Flags & PKF_DEFINED))) {

            Result = -1;
            DispError(2, "Flag keyword '%s' must defined for RASTER Plotter.", pPK->pKeyword);
        }

    } else {

        PlotGPC.Flags |= (PLOTF_NO_BMP_FONT     |
                          PLOTF_RTL_NO_DPI_XY   |
                          PLOTF_RTLMONO_NO_CID  |
                          PLOTF_RTLMONO_FIXPAL);
    }

    //
    // Find out if a required keyword is missing
    //

    Result = 1;
    pPK    = (PPLOTKEY)&PlotKey[0];

    while (pPK->pKeyword) {

        if ((PlotGPC.Flags & PLOTF_RASTER)      &&
            (pPK->pKeyword == szRTLMonoEncode5) &&
            (!(pPK->Flags & PKF_DEFINED))) {

            Result = -1;
            DispError(2, "Flag keyword '%s' must defined for RASTER Plotter.", pPK->pKeyword);
        }

        if ((pPK->Flags & PKF_REQ) &&
            (!(pPK->Flags & PKF_DEFINED))) {

            Result = -1;
            DispError(2, "required keyword '%s' undefined", pPK->pKeyword);
        }

        ++pPK;
    }

    //
    // Validate DeviceSize/DeviceMargins
    //

    if (PlotGPC.DeviceSize.cx < MIN_PLOTGPC_FORM_CX) {

        DispError(2, "Invalid DeviceSize CX = %ld", PlotGPC.DeviceSize.cx);
        Result = -1;
    }

    if (PlotGPC.DeviceSize.cy < MIN_PLOTGPC_FORM_CY) {

        if (PlotGPC.Flags & PLOTF_ROLLFEED) {

            PlotGPC.DeviceSize.cy = 15240000;   // default to 50' of length
            DispError(1, "Assume device length can handle up to 50 feet of paper");

        } else {

            PlotGPC.DeviceSize.cy = 279400;     // default to 11" of length
            DispError(1, "Assume device length can handle up to 11 inch of paper");
        }
    }

    if (PlotGPC.DeviceSize.cx - (PlotGPC.DeviceMargin.left +
                        PlotGPC.DeviceMargin.right) < MIN_PLOTGPC_FORM_CX) {

        DispError(3, "Invalid DeviceMargin left/right (%ld/%ld",
                        PlotGPC.DeviceMargin.left, PlotGPC.DeviceMargin.right);
        Result = -1;
    }

    if (PlotGPC.DeviceSize.cy - (PlotGPC.DeviceMargin.top +
                        PlotGPC.DeviceMargin.bottom) < MIN_PLOTGPC_FORM_CY) {

        DispError(3, "Invalid DeviceMargin top/bottom (%ld/%ld",
                        PlotGPC.DeviceMargin.top, PlotGPC.DeviceMargin.bottom);
        Result = -1;
    }

    for (i = 0; i < (INT)PlotGPC.Forms.Count; i++) {

        if ((!(PlotGPC.Flags & PLOTF_ROLLFEED)) &&
            (AvaiForms[i].Size.cy == 0)) {

            DispError(3, "%s '%s', the device CANNOT handle roll paper",
                            szFormInfo, AvaiForms[i].Name);

            Result = -1;
        }

        if ((cy = AvaiForms[i].Size.cy) == 0) {

            cy = PlotGPC.DeviceSize.cy;
        }

        if (((AvaiForms[i].Size.cx <= PlotGPC.DeviceSize.cx) &&
             (cy <= PlotGPC.DeviceSize.cy))                         ||
            ((AvaiForms[i].Size.cx <= PlotGPC.DeviceSize.cy) &&
             (cy <= PlotGPC.DeviceSize.cx))) {

            NULL;

        } else {

            DispError(3, "%s '%s' size too big for device to handle",
                                szFormInfo, AvaiForms[i].Name);

            Result = -1;
        }
    }

    //
    // Find out if pen data must be present
    //

    if (PlotGPC.Flags & PLOTF_RASTER) {

        if (PlotGPC.Pens.Count) {

            DispError(3, "CANNOT define Pen colors for a raster device");
            Result = -1;
        }

    } else {

        if (!(PlotGPC.Flags & PLOTF_NO_BMP_FONT)) {

            DispError(3, "PEN plotter MUST SET '%s' to 1", szNoBmpFont);
            Result = -1;
        }

        if (!(PlotGPC.Flags & PLOTF_COLOR)) {

            DispError(3, "PEN plotter must specify COLOR. (ColorCap {1})");
            Result = -1;
        }

        if (PlotGPC.MaxPens > MAX_PENPLOTTER_PENS) {

            DispError(3, "maximum plotter Pens allowed are %ld, you defined %ld",
                                MAX_PENPLOTTER_PENS, PlotGPC.MaxPens);

            PlotGPC.MaxPens = MAX_PENPLOTTER_PENS;
            Result = -1;
        }

        if (PlotGPC.Pens.Count < PlotGPC.MaxPens) {

            DispError(3, "only %ld pens out of %ld pens defined",
                            PlotGPC.Pens.Count, PlotGPC.MaxPens);
            Result = -1;
        }

        if (PlotGPC.Pens.Count > PlotGPC.MaxPens) {

            DispError(3, "too many pens (%ld) defined for '%s', Maximum is %ld",
                        PlotGPC.Pens.Count, szPenData, PlotGPC.MaxPens);
            Result = -1;
        }

        for (i = 0; i < PlotGPC.MaxPens; i++) {

            if (AvaiPenData[i].ColorIdx == 0xffff) {

                DispError(3, "'%s' Pen #%ld undefined", szPenData, i + 1);
                Result = -1;
            }
        }
    }

    if (PlotGPC.Flags & PLOTF_PAPERTRAY) {

        if ((PlotGPC.PaperTraySize.cx < 0) ||
            (PlotGPC.PaperTraySize.cy < 0)) {

            DispError(3, "'%s' defined, but '%s' not defined",
                                            szPaperTrayCap, szPaperTraySize);

            Result = -1;

        } else if ((PlotGPC.PaperTraySize.cx == 0) ||
                   (PlotGPC.PaperTraySize.cy == 0)) {

            DispError(3, "'%s': Invalid Size (%ld x %ld), must have a size",
                            szPaperTraySize,
                            PlotGPC.PaperTraySize.cx,
                            PlotGPC.PaperTraySize.cy);
            Result = -1;

        } else if ((PlotGPC.PaperTraySize.cx != PlotGPC.DeviceSize.cx) &&
                   (PlotGPC.PaperTraySize.cy != PlotGPC.DeviceSize.cx)) {

            DispError(3, "'%s': Invalid Size (%ld x %ld), one of width/height must eqaul device width (%ld)",
                            szPaperTraySize,
                            PlotGPC.PaperTraySize.cx,
                            PlotGPC.PaperTraySize.cy, PlotGPC.DeviceSize.cx);

            Result = -1;
        }
    }

    return(Result);
}





VOID
CopyPlotGPCToPCD(
    PPLOTGPC_PCD  pPlotGPC_PCD,
    PPLOTGPC      pPlotGPC
    )

/*++

Routine Description:

    This function copies a PLOTGPC structure into a PLOTGPC_GPC structure.

Arguments:

    pPlotGPC_PCD  - destination
    pPlotGPC      - source

Return Value:

    None 


Development History:

    1 Feb 2000

Revision History:

--*/

{
    // All the datatypes upto InitString are the same in both the structures.
    CopyMemory(pPlotGPC_PCD, 
               pPlotGPC, 
               (LPBYTE)&(pPlotGPC_PCD->InitString) - (LPBYTE)pPlotGPC_PCD);

    // We need the size of PLOTGPC_PCD here, not the size of PLOTGPC
    pPlotGPC_PCD->cjThis = sizeof(PLOTGPC_PCD);  
    
    pPlotGPC_PCD->InitString.Count     = pPlotGPC->InitString.Count;
    pPlotGPC_PCD->InitString.SizeEach  = pPlotGPC->InitString.SizeEach;
    if (pPlotGPC->InitString.pData) {
        pPlotGPC_PCD->InitString.pData = (DWORD)(ULONG_PTR)(pPlotGPC->InitString.pData) 
                                                    - (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD));
    } else {
        pPlotGPC_PCD->InitString.pData = 0;
    }

    pPlotGPC_PCD->Forms.Count          = pPlotGPC->Forms.Count;
    pPlotGPC_PCD->Forms.SizeEach       = pPlotGPC->Forms.SizeEach;
    if (pPlotGPC->Forms.pData) {
        pPlotGPC_PCD->Forms.pData      = (DWORD)(ULONG_PTR)(pPlotGPC->Forms.pData)
                                                    - (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD));
    } else {
        pPlotGPC_PCD->Forms.pData      = 0;
    }

    pPlotGPC_PCD->Pens.Count           = pPlotGPC->Pens.Count;
    pPlotGPC_PCD->Pens.SizeEach        = pPlotGPC->Pens.SizeEach;
    if (pPlotGPC->Pens.pData) {
        pPlotGPC_PCD->Pens.pData       = (DWORD)(ULONG_PTR)(pPlotGPC->Pens.pData)
                                                    - (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD));
    } else {
        pPlotGPC_PCD->Pens.pData       = 0;
    }
}



VOID
WritePlotGPCToFile(
    PPLOTGPC  pPlotGPC
    )

/*++

Routine Description:

    This routine writes out pPlotGPC into a .pcd file. A FILE* pointer
    to the file should be present in OutFile.

Arguments:

    pPlotGPC      - pointer to the PLOTGPC structure to be written. Some elements
                    maybe modified in *pPlotGPC in this function.

Return Value:

    None 


Development History:

    1 Feb 2000

Revision History:

--*/

{
    PLOTGPC_PCD PlotGPC_PCD;

    //
    // make the references to offset
    //
    if (pPlotGPC->InitString.pData) {

        (LPBYTE)pPlotGPC->InitString.pData -= (ULONG_PTR)pPlotGPC;
    }

    if (pPlotGPC->Forms.pData) {

        (LPBYTE)pPlotGPC->Forms.pData -= (ULONG_PTR)pPlotGPC;
    }

    if (pPlotGPC->Pens.pData) {

        (LPBYTE)pPlotGPC->Pens.pData -= (ULONG_PTR)pPlotGPC;
    }

    CopyPlotGPCToPCD(&PlotGPC_PCD, pPlotGPC);

    if (OutFile) {

        fwrite(&PlotGPC_PCD,
               PlotGPC_PCD.cjThis,
               1,
               OutFile);

        fwrite((LPBYTE)pPlotGPC + pPlotGPC->cjThis,
               PlotGPC.SizeExtra,
               1,
               OutFile);
    }

}

//
//***************************************************************************
// C main function entry point
//***************************************************************************
//


#define MAIN_SHOW_USAGE     0x0001


int __cdecl
main(
    INT     argc,
    CHAR    **argv
    )
{
    PPLOTGPC    pPlotGPC = NULL;
    INT         RetVal = 1;
    UINT        Flags = 0;
    UINT        i;
    LPSTR       pOutFile = NULL;
    PPLOTKEY    pPK;
    PPLOTVAL    pPV;


    memset(AvaiPenData, 0xff, sizeof(AvaiPenData));

    pPV         = PenColorVal;
    MaxPCValLen = 0;

    while (pPV->pValName) {

        if ((i = (UINT)strlen(pPV->pValName)) > MaxPCValLen) {

            MaxPCValLen = i;
        }

        ++pPV;
    }

    pPK           = &PlotKey[0];
    MaxKeywordLen = 0;

    while (pPK->pKeyword) {

        if ((pPK->KeywordLen = (WORD)strlen(pPK->pKeyword)) > MaxKeywordLen) {

            MaxKeywordLen = pPK->KeywordLen;
        }

        ++pPK;
    }

    InFile  = NULL;
    OutFile = NULL;

    if (argc > 1) {

        for (--argc, ++argv; argc > 0; --argc, ++argv) {

            if (**argv == '-' ) {

                switch (*(*argv + 1)) {

                case '?':
                case 'h':
                case 'H':

                    Flags |= MAIN_SHOW_USAGE;
                    RetVal = -1;
                    break;
                }

            } else if (InFile) {

                if ((OutFile) && (OutFile != stdout)) {

                    DispError(0, "Unknown parameter '%s'", *argv);
                    Flags |= MAIN_SHOW_USAGE;
                    RetVal = 0;

                } else if ((OutFile = fopen(pOutFile = *argv, "wb")) == NULL) {

                    DispError(0, "Cannot open output file '%s'\n", *argv);
                    RetVal = 0;
                }

            } else {

                if (SUCCEEDED(StringCchCopyA(InFileName, CCHOF(InFileName), *argv)))
                {

                    if ((InFile = fopen(*argv, "rt" )) == NULL) {

                        DispError(0, "Cannot open input file '%s'\n", *argv);
                        RetVal = -1;
                    }
                }
                else
                {
                    DispError(0, "Wrong filename '%s'\n", *argv);
                    RetVal = -1;
                }

            }
        }

    } else {

        Flags |= MAIN_SHOW_USAGE;
        RetVal = -1;
    }

    if (Flags & MAIN_SHOW_USAGE) {

        ShowUsage();
    }

    if ((RetVal >= 0) &&
        (InFile)) {

        RetVal = ParsePlotGPC();
    }

    if (RetVal >= 0) {

        //
        // if (InFile) {
        //
        //     ShowUndefined();
        // }
        //

        if (pPlotGPC = GetFullPlotGPC()) {

            ValidatePlotGPC(pPlotGPC);
            ShowPlotGPC(pPlotGPC);
            WritePlotGPCToFile(pPlotGPC);
        }

    } else {

        fprintf(stdout, "\n");
    }

    if (InFile) {

        fclose(InFile);
    }

    if ((OutFile) && (OutFile != stdout)) {

        fclose(OutFile);
    }


#if (DBG && GPC_READ_TEST)

    if (pOutFile) {

        LPWSTR      pwStr = NULL;
        PPLOTGPC    pReadPlotGPC;
        UINT        Idx = 0;


        pwStr = str2MemWstr(pOutFile);

        if (pReadPlotGPC = ReadPlotGPCFromFile(pwStr)) {

            ShowPlotGPC(pReadPlotGPC);

            //
            // make the references to offset
            //

            if (pReadPlotGPC->InitString.pData) {

                (LPBYTE)pReadPlotGPC->InitString.pData -= (DWORD)pReadPlotGPC;
            }

            if (pReadPlotGPC->Forms.pData) {

                (LPBYTE)pReadPlotGPC->Forms.pData -= (DWORD)pReadPlotGPC;
            }

            if (pReadPlotGPC->Pens.pData) {

                (LPBYTE)pReadPlotGPC->Pens.pData -= (DWORD)pReadPlotGPC;
            }

            if ((pPlotGPC->cjThis != pReadPlotGPC->cjThis) ||
                (pPlotGPC->SizeExtra != pReadPlotGPC->SizeExtra)) {

                DispError(-1, "Write / Read Size different");

            } else {

                UINT    i;
                LPBYTE  pP1;
                LPBYTE  pP2;

                pP1 = (LPBYTE)pPlotGPC;
                pP2 = (LPBYTE)pReadPlotGPC;
                Idx = pPlotGPC->cjThis + pPlotGPC->SizeExtra;

                for (i = 0; i < Idx; i++) {

                    if (*pP1 != *pP2) {

                        fprintf(stdout, "\nOffset 0x%04x: Write = %02x, Read = %02x",
                                            i, *pP1, *pP2);
                    }

                    ++pP1;
                    ++pP2;
                }
            }

            LocalFree(pReadPlotGPC);

        } else {

            DispError(-1, "ReadPlotGPCFromFile(%s) failed", pOutFile);
        }

        if (pwStr) {

            LocalFree(pwStr);
        }
    }
#endif

    if (pPlotGPC) {

        LocalFree((HLOCAL)pPlotGPC);
    }

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\inc\name.h ===
//   Copyright (c) 1996-2003  Microsoft Corporation

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";



CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrWritePrinter[] = "WritePrinter";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\inc\ttyui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   TTYUI.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//              for TTYUI user mode Module.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _TTYUI_H
#define _TTYUI_H


////////////////////////////////////////////////////////
//      TTY UI Defines
////////////////////////////////////////////////////////

// fMode values.
#define OEMDM_SIZE      1
#define OEMDM_DEFAULT   2
#define OEMDM_CONVERT   3
#define OEMDM_VALIDATE  4

// tty Signature and version.
    #define OEM_SIGNATURE   'TTY0'
    #define TESTSTRING      "This is the TTY driver"
    #define PROP_TITLE      L"TTY UI Page"
    #define DLLTEXT(s)      __TEXT("TTYUI:  ") __TEXT(s)

#define OEM_VERSION      0x92823141L

// OEM UI Misc defines.
#define OEM_ITEMS       5
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define PATH_SEPARATOR  '\\'


#define MAX_INT_FIELD_WIDTH  4
#define MAX_CMD_LEN  100
#define RADIX  10
#define TTYSTRUCT_VER  8
#define FIRSTSTRINGID   IDS_STRING1
#define LASTSTRINGID     IDS_STRING14

#define  TTY_CB_BEGINJOB             1
#define  TTY_CB_ENDJOB                 2
#define  TTY_CB_PAPERSELECT        3
#define  TTY_CB_FEEDSELECT          4
#define  TTY_CB_BOLD_ON                7
#define  TTY_CB_BOLD_OFF                8
#define  TTY_CB_UNDERLINE_ON             9
#define  TTY_CB_UNDERLINE_OFF             10



////////////////////////////////////////////////////////
//      tty UI Type Defines
////////////////////////////////////////////////////////

typedef struct tag_DMEXTRAHDR {
    DWORD   dwSize;
    DWORD   dwSignature;
    DWORD   dwVersion;
} DMEXTRAHDR, *PDMEXTRAHDR;


typedef struct tag_OEMUI_EXTRADATA {
    DMEXTRAHDR  dmExtraHdr;
    BYTE        cbTestString[sizeof(TESTSTRING)];
} OEMUI_EXTRADATA, *POEMUI_EXTRADATA;





typedef  struct
{
    BYTE  strCmd[MAX_CMD_LEN] ;
    DWORD   dwLen ;
}   CMDSTR, *PCMDSTR ;



// this structure used as static storage inside dialog proc.
//  update  #define TTYSTRUCT_VER  8  defined above.
//   when changing this struct.

typedef  struct
{
    DWORD       dwVersion ;   // holds version of REGSTRUCT.
    INT       iCodePage ;         //  negative for built in GTT, the CP value otherwise
    BOOL    bIsMM ;  //  set true if units are tenths of mm, else 1/100 of inch.
    RECT  rcMargin ;   // user defined unprintable margins in above units.
    CMDSTR     BeginJob, EndJob, PaperSelect, FeedSelect,
        Sel_10_cpi, Sel_12_cpi, Sel_17_cpi,
        Bold_ON, Bold_OFF, Underline_ON, Underline_OFF;
    DWORD       dwGlyphBufSiz,   // size of  aubGlyphBuf
                        dwSpoolBufSiz;  //  size of aubSpoolBuf
    PBYTE  aubGlyphBuf, aubSpoolBuf ;  //  used by  OutputCharStr method
}       REGSTRUCT, *PREGSTRUCT ;





typedef  struct
{
// per invocation globals
    HANDLE  hPrinter ;   // so we can access registry within DialogProc.
    HANDLE  hOEMHeap ;
    PWSTR   pwHelpFile ;  // fully qualified path to helpfile.
    DWORD       dwUseCount ;  // usage count
    REGSTRUCT   regStruct ;    // stuff that goes into registry
}   GLOBALSTRUCT ,  *PGLOBALSTRUCT ;



////////////////////////////////////////////////////////
//      TTY UI Prototypes
////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//   Windows 2000, Windows XP, Windows Server 2003
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.

// kill 2 lines for IA 64
//#define WINVER          0x0500
//#define _WIN32_WINNT    0x0500


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\oemcom.cpp ===
/*++

Copyright (c) 1996-2003 Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003 Unidrv driver

Revision History:

              Created it.

--*/

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#include <tty.h>
#include <printoem.h>
#include <prntfont.h>
#include "..\inc\name.h"
#include <initguid.h>
#include <prcomoem.h>
#include <assert.h>
#include "oemcom.h"
#include "ttyui.h"
#include "debug.h"
#include <strsafe.h>

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{
    VERBOSE(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        VERBOSE(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ;
    }
    else if (iid == IID_IPrintOemUni2)
    {
        *ppv = static_cast<IPrintOemUni2*>(this) ;
        VERBOSE(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ;
    }
    else
    {
        *ppv = NULL ;
        WARNING(DLLTEXT("IOemCB:Return NULL.\n")) ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release()
{
   VERBOSE(DLLTEXT("IOemCB::Release() entry.\r\n"));
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

IOemCB::~IOemCB()
{
    //
    // Make sure that driver's helper function interface is released.
    //
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    //
    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    //

    assert(0 == m_cRef) ;
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

    //
    // Need to store pointer to Driver Helper functions, if we already haven't.
    //
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        //
        // Get Interface to Helper Functions.
        //
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            //
            // Make sure that interface pointer reflects interface query failure.
            //
            this->pOEMHelp = NULL;
        }
    }

    if (this->pOEMHelp)
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));

    if(OEMEnableDriver(dwDriverVersion, cbSize, pded) )
        return S_OK;
    return E_FAIL;
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));

    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL ;
    }
    return S_OK;
}


// the following OEM function is called by Unidrv to provide
// the OEM dll with an interface it can use to access Unidrv's
// helper functions like WriteSpoolBuf etc.
//  warning: calling this more per IOemCB object than once will result
//  in mismatched reference counts.


LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *ppDevOem)
{
    VERBOSE(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));

    if(*ppDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,
                phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded) )
        return S_OK;
    return E_FAIL;

}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));

    OEMDisablePDEV(pdevobj) ;
    return S_OK;
};

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{

    LONG lReturn = FALSE;
    VERBOSE(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    VERBOSE(DLLTEXT("        Function:%s:"),pMethodName);

    if (pMethodName == NULL)
    {
        lReturn = FALSE;
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
#if 0
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#endif
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
#endif
#if 0
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
#if 0
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
#if 0
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':

                if (!strcmp(pstrOutputCharStr, pMethodName))
                   lReturn = TRUE;

                break;

            case (WCHAR)'R':
#if 0
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'S':

                if (!strcmp(pstrSendFontCmd, pMethodName))
                           lReturn = TRUE;

                break;

            case (WCHAR)'T':
                if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
#endif
#if 0
                else if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
#endif
                break;
#if 0
            case (WCHAR)'W':
                if (!strcmp(pstrWritePrinter,pMethodName) )
                    lReturn = TRUE;
#endif
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
{
    VERBOSE(DLLTEXT("IOemCB::DevMode() entry.\r\n"));

    return E_NOTIMPL;

}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    VERBOSE(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    VERBOSE(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    DWORD dwResult;
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    PCMDSTR      pSelectCmd = NULL ;   // points to one of the command structures
                                                //  in pMyStuff.

    *piResult =  0 ;   //  for all non movement commands
    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;

    switch(dwCallbackID)
    {
        case  TTY_CB_BEGINJOB:
            pSelectCmd = &pMyStuff->BeginJob ;
            break;
        case  TTY_CB_ENDJOB:
            pSelectCmd = &pMyStuff->EndJob ;
            break;
        case  TTY_CB_PAPERSELECT:
            pSelectCmd = &pMyStuff->PaperSelect ;
            break;
        case  TTY_CB_FEEDSELECT:
            pSelectCmd = &pMyStuff->FeedSelect ;
            break;
        case  TTY_CB_BOLD_ON:
            pSelectCmd = &pMyStuff->Bold_ON ;
            break;
        case  TTY_CB_BOLD_OFF:
            pSelectCmd = &pMyStuff->Bold_OFF ;
            break;
        case  TTY_CB_UNDERLINE_ON:
            pSelectCmd = &pMyStuff->Underline_ON ;
            break;
        case  TTY_CB_UNDERLINE_OFF:
            pSelectCmd = &pMyStuff->Underline_OFF ;
            break;

        default:
            return S_OK;
    }

    if(pSelectCmd)
         pOEMHelp->DrvWriteSpoolBuf(pdevobj, pSelectCmd->strCmd, pSelectCmd->dwLen,
                &dwResult);

#if 0

    //  this code is just to test new Unidrv helper functions.


     pOEMHelp->DrvWriteAbortBuf(pdevobj, pSelectCmd->strCmd, pSelectCmd->dwLen,
                3000);


     //  temp variables:
     DWORD     dwcursorPosX,  dwcursorPosY,  cbNeeded ;
     PBYTE      pBuffer;

        pOEMHelp->DrvGetStandardVariable(      pdevobj,
                                                        SVI_CURSORORIGINX,
                                                        &dwcursorPosX,
                                                        sizeof(DWORD),
                                                        &cbNeeded);

        pOEMHelp->DrvGetStandardVariable(      pdevobj,
                                                        SVI_CURSORORIGINY,
                                                        &dwcursorPosY,
                                                        sizeof(DWORD),
                                                        &cbNeeded);

        pOEMHelp->DrvGetGPDData(       pdevobj,
            GPD_OEMCUSTOMDATA,     // Type of the data
            NULL,   // reserved. Should be set to 0
            NULL,     // Caller allocated Buffer to be copied
            0,     // Size of the buffer
            &cbNeeded   // New Size of the buffer if needed.
            ) ;

        pBuffer = (PBYTE)MemAlloc(cbNeeded);

        pOEMHelp->DrvGetGPDData(       pdevobj,
            GPD_OEMCUSTOMDATA,     // Type of the data
            NULL,   // reserved. Should be set to 0
            pBuffer,     // Caller allocated Buffer to be copied
            cbNeeded,     // Size of the buffer
            &cbNeeded   // New Size of the buffer if needed.
            ) ;

     pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuffer, cbNeeded,
                &dwResult);


    MemFree(pBuffer);

#endif

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    return E_NOTIMPL ;
/*  if (*ppbResult = OEMImageProcessing(pdevobj, pSrcBitmap,
            pBitmapInfoHeader, pColorTable, dwCallbackID, pIPParams))
        return S_OK;
    else
        return E_FAIL; */
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
//    DWORD dwResult;
    VERBOSE(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    return E_NOTIMPL ;

/*  if (OEMFilterGraphics( pdevobj,  pBuf,  dwLen))
        return S_OK;
    else
        return E_FAIL; */
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IOemCB::Compression() entry.\r\n"));

    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
{
    VERBOSE(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
{
    VERBOSE(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
{
    VERBOSE(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}



LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    DWORD  dwI, dwGetInfo, dwResult, dwGlyphBufSiz, dwSpoolBufSiz, dwDst;
    PREGSTRUCT pMyStuff;

    VERBOSE(DLLTEXT("OEMOutputCharStr() entry.\r\n"));

    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;

    //  is the glyph buffers cache large enough?

    dwGlyphBufSiz = dwCount * sizeof(TRANSDATA);

    if(dwGlyphBufSiz > pMyStuff->dwGlyphBufSiz)   //  need to realloc mem.
    {
        if(pMyStuff->aubGlyphBuf)
        {
            MemFree(pMyStuff->aubGlyphBuf) ;
            pMyStuff->dwGlyphBufSiz = 0 ;
        }
        if(pMyStuff->aubGlyphBuf = (PBYTE)MemAlloc(dwGlyphBufSiz))
            pMyStuff->dwGlyphBufSiz = dwGlyphBufSiz ;
        else
            return(E_FAIL);   //  unable to alloc needed buffers.
    }


    dwSpoolBufSiz = dwCount * sizeof(WORD);  // assume worst case.

    if(dwSpoolBufSiz > pMyStuff->dwSpoolBufSiz)   //  need to realloc mem.
    {
        if(pMyStuff->aubSpoolBuf)
        {
            MemFree(pMyStuff->aubSpoolBuf) ;
            pMyStuff->dwSpoolBufSiz = 0 ;
        }
        if(pMyStuff->aubSpoolBuf = (PBYTE)MemAlloc(dwSpoolBufSiz))
            pMyStuff->dwSpoolBufSiz = dwSpoolBufSiz ;
        else
            return(E_FAIL);   //  unable to alloc needed buffers.
    }

    if(dwType != TYPE_GLYPHHANDLE)
        return(E_FAIL);  // E_FAIL  can only handle device fonts.

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = dwType;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = pMyStuff->aubGlyphBuf ;
        GStr.dwGlyphOutSize = dwGlyphBufSiz;   // instead of pMyStuff->dwGlyphBufSiz, which cause AV
        dwGetInfo = GStr.dwSize;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            dwGetInfo, &dwGetInfo))
        {
            WARNING(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return(E_FAIL);
        }


        pTrans = (PTRANSDATA)pMyStuff->aubGlyphBuf;

        for (dwDst =  dwI = 0 ; dwI < dwCount; dwI++, pTrans++)
        {
            VERBOSE(DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),pTrans->ubCodePageID);
            VERBOSE(DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),pTrans->ubType);
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
                case MTYPE_DIRECT:
                    pMyStuff->aubSpoolBuf[dwDst++] =  pTrans->uCode.ubCode ;
                    break;
                case MTYPE_PAIRED:
                    VERBOSE(DLLTEXT("TYPE_TRANSDATA:ubPairs:0x%x\n"),*(PWORD)(pTrans->uCode.ubPairs));
                    pMyStuff->aubSpoolBuf[dwDst++] =  pTrans->uCode.ubPairs[0] ;
                    pMyStuff->aubSpoolBuf[dwDst++] =  pTrans->uCode.ubPairs[1] ;
                    break;
                default:
                    return (E_FAIL);  // no other MTYPE is supported.
                    break;
            }
        }


        // send dst bytes to printer.
        pOEMHelp->DrvWriteSpoolBuf(pdevobj, pMyStuff->aubSpoolBuf, dwDst,
           &dwResult);

        if(dwResult == dwDst)
            return S_OK;
        return E_FAIL ;
}


LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
{
    VERBOSE(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));

    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    PCMDSTR      pSelectCmd ;   // points to one of the font selection
            // command structures in pMyStuff.
    DWORD dwResult;

     //  I expect pFInv to contain either "10", "12" or "17"

    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;

    if(pFInv->dwCount == 2  &&  pFInv->pubCommand[0] == '1')
    {
        if (pFInv->pubCommand[1] == '2')
            pSelectCmd = &pMyStuff->Sel_12_cpi ;
        else if (pFInv->pubCommand[1] == '7')
            pSelectCmd = &pMyStuff->Sel_17_cpi ;
        else if (pFInv->pubCommand[1] == '0')
            pSelectCmd = &pMyStuff->Sel_10_cpi ;
        else
            return S_OK;    //  maybe asking to deselect a font.  Don't do anything!
    }
    else
        return S_OK;    //  maybe asking to deselect a font.  Don't do anything!

     pOEMHelp->DrvWriteSpoolBuf(pdevobj, pSelectCmd->strCmd, pSelectCmd->dwLen,
                &dwResult);

    return S_OK;
}



LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded
    )
{
    VERBOSE(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));

    if(OEMTTYGetInfo( pdevobj,      dwInfoIndex,
           pOutputBuf,    dwSize,   pcbcNeeded) )
        return S_OK;
    return E_FAIL ;
}


LONG __stdcall  IOemCB:: WritePrinter (  PDEVOBJ    pdevobj,
                                      PVOID      pBuf,
                                     DWORD      cbBuffer,
                                    PDWORD     pcbWritten)
{
    VERBOSE(DLLTEXT("IOemCB::WritePrinter() entry.\r\n"));

    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    VERBOSE(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}



///////////////////////////////////////////////////////////

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;

    return SUCCEEDED(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Copyright (c) 1996-2003  Microsoft Corporation
// Used by OEMUD.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\ttyud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   TTYUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//              for TTYUD kernel mode Module.
//
//  PLATFORMS:
//     Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _TTYUD_H
#define _TTYUD_H


////////////////////////////////////////////////////////
//      TTY UD Defines
////////////////////////////////////////////////////////

extern DWORD    gdwDrvMemPoolTag;

#define MemAlloc(size)      EngAllocMem(0, size, gdwDrvMemPoolTag)
#define MemAllocZ(size)     EngAllocMem(FL_ZERO_MEMORY, size, gdwDrvMemPoolTag)
#define MemFree(p)          { if (p) EngFreeMem(p); }



////////////////////////////////////////////////////////
//      TTY UD Type Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      TTY UD Prototypes
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\ttyud.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   TTYUD.cpp
//
//
//  PURPOSE:  Main file for TTY kernel mode module.
//
//
//  Functions:
//
//
//
//
//  PLATFORMS:  Windows 2000, Windows XP, Windows Server 2003
//
//

#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winspool.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <winddi.h>

#ifdef __cplusplus
}
#endif


#include <tchar.h>
#include <excpt.h>


#include <PRINTOEM.H>

#include "ttyui.h"
#include "TTYUD.h"
#include "debug.h"
#include <STRSAFE.H>

DWORD gdwDrvMemPoolTag = 'Oem5';      // for MemAlloc debugging purposes



#define     TTY_INFO_MARGINS  1
#define     TTY_INFO_CODEPAGE  2
#define     TTY_INFO_NUM_UFMS    3
#define     TTY_INFO_UFM_IDS    4

#define     NUM_UFMS    3             //  for internal use only.  use TTY_INFO_NUM_UFMS
    //  to query number of font sizes supported.



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////



BOOL APIENTRY OEMGetInfo(IN DWORD dwInfo, OUT PVOID pBuffer, IN DWORD cbSize,
                         OUT PDWORD pcbNeeded) ;
PDEVOEM APIENTRY OEMEnablePDEV(PDEVOBJ pdevobj, PWSTR pPrinterName, ULONG cPatterns,
                               HSURF *phsurfPatterns, ULONG cjGdiInfo, GDIINFO *pGdiInfo,
                               ULONG cjDevInfo, DEVINFO *pDevInfo, DRVENABLEDATA *pded) ;
VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj) ;
BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded) ;


PBYTE APIENTRY OEMImageProcessing(PDEVOBJ pdevobj, PBYTE pSrcBitmap, PBITMAPINFOHEADER pBitmapInfo,
                                  PBYTE pColorTable, DWORD dwCallbackID, PIPPARAMS pIPParams) ;

BOOL APIENTRY OEMFilterGraphics(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen) ;




// Need to export these functions as c declarations.
extern "C" {


PBYTE APIENTRY OEMImageProcessing(PDEVOBJ pdevobj, PBYTE pSrcBitmap, PBITMAPINFOHEADER pBitmapInfo,
                                  PBYTE pColorTable, DWORD dwCallbackID, PIPPARAMS pIPParams)
{
    VERBOSE(DLLTEXT("OEMImageProcessing() entry.\r\n"));

    return ((PBYTE)TRUE);
}


BOOL APIENTRY OEMFilterGraphics(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen)
{
    VERBOSE(DLLTEXT("OEMFilterGraphics() entry.\r\n"));

    return TRUE;
}




BOOL APIENTRY OEMGetInfo(IN DWORD dwInfo, OUT PVOID pBuffer, IN DWORD cbSize,
                         OUT PDWORD pcbNeeded)
{

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo)
          &&
          (OEMGI_GETINTERFACEVERSION != dwInfo)
          &&
          (OEMGI_GETVERSION != dwInfo)
        )
        ||
        (NULL == pcbNeeded)
      )
    {
      VERBOSE(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
            *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer)
        ||
        (4 > cbSize)
      )
    {
        // VERBOSE(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        EngSetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
        case OEMGI_GETSIGNATURE:
            *(LPDWORD)pBuffer = OEM_SIGNATURE;
            break;

        case OEMGI_GETINTERFACEVERSION:
            *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
            break;

        case OEMGI_GETVERSION:
            *(LPDWORD)pBuffer = OEM_VERSION;
            break;
    }

    return TRUE;
}



PDEVOEM APIENTRY OEMEnablePDEV(PDEVOBJ pdevobj, PWSTR pPrinterName, ULONG cPatterns,
                               HSURF *phsurfPatterns, ULONG cjGdiInfo, GDIINFO *pGdiInfo,
                               ULONG cjDevInfo, DEVINFO *pDevInfo, DRVENABLEDATA *pded)
{
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    DWORD   dwStatus, cbNeeded, dwType ;
    LPTSTR  pValueName = TEXT("TTY DeviceConfig");
                // these strings must match strings in oemui.cpp - VinitMyStuff()

    VERBOSE(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    pMyStuff = (PREGSTRUCT)MemAlloc(sizeof(REGSTRUCT)) ;
    if(!pMyStuff)
        return ((PDEVOEM)NULL) ;  //  failed.

    pdevobj->pdevOEM = (PDEVOEM)pMyStuff ;

    dwStatus =  EngGetPrinterData(
    pdevobj->hPrinter, // handle of printer object
    pValueName, // address of value name
    &dwType,    // address receiving value type
    (LPBYTE)pMyStuff,
                // address of array of bytes that receives data
    sizeof(REGSTRUCT),  // size, in bytes, of array
    &cbNeeded   // address of variable
            //  with number of bytes retrieved (or required)
    );
    if (dwStatus != ERROR_SUCCESS || pMyStuff->dwVersion != TTYSTRUCT_VER
        ||  dwType !=  REG_BINARY
        ||  cbNeeded != sizeof(REGSTRUCT))
    {
        //  Init secret block with defaults

        pMyStuff->dwVersion = TTYSTRUCT_VER ;
        //  version stamp to avoid incompatible structures.

        pMyStuff->bIsMM = TRUE ;  // default to mm units
        //  read margin values from registry and store into temp RECT

        pMyStuff->iCodePage =  1252 ;  //   keep in sync with oemui.cpp - VinitMyStuff()
        pMyStuff->rcMargin.left  = pMyStuff->rcMargin.top  =
        pMyStuff->rcMargin.right  =  pMyStuff->rcMargin.bottom  = 0 ;
        pMyStuff->BeginJob.dwLen =
        pMyStuff->EndJob.dwLen =
        pMyStuff->PaperSelect.dwLen =
        pMyStuff->FeedSelect.dwLen =
        pMyStuff->Sel_10_cpi.dwLen =
        pMyStuff->Sel_12_cpi.dwLen =
        pMyStuff->Sel_17_cpi.dwLen =
        pMyStuff->Bold_ON.dwLen =
        pMyStuff->Bold_OFF.dwLen =
        pMyStuff->Underline_ON.dwLen =
        pMyStuff->Underline_OFF.dwLen = 0 ;

        // more fields here!
        pMyStuff->dwGlyphBufSiz =
        pMyStuff->dwSpoolBufSiz = 0 ;
        pMyStuff->aubGlyphBuf =
        pMyStuff->aubSpoolBuf  = NULL ;
    }

    return ((PDEVOEM)pMyStuff) ;
}


VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
    VERBOSE(DLLTEXT("OEMDisablePDEV() entry.\r\n"));

    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals

    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;
    if(pMyStuff->aubGlyphBuf)
        MemFree(pMyStuff->aubGlyphBuf) ;
    if(pMyStuff->aubSpoolBuf)
        MemFree(pMyStuff->aubSpoolBuf) ;
    MemFree(pdevobj->pdevOEM);
}


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // Validate paramters.
    if(   (PRINTER_OEMINTF_VERSION != dwOEMintfVersion) ||
        //  above check not needed for COM
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        //  VERBOSE(ERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\r\n"));

        return FALSE;
    }

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION ; //   not  DDI_DRIVER_VERSION;
    pded->c = 0;

    return TRUE;
}


BOOL    APIENTRY   OEMTTYGetInfo(PDEVOBJ pdevobj,    DWORD  dwInfoIndex,
        PVOID   pOutBuf,  DWORD  dwSize, DWORD  *pcbNeeded
)
{
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    REGSTRUCT  MyStuff;   // temp  structure to hold registry data

    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;

    if(!pMyStuff)
    {
        DWORD   dwStatus, cbNeeded, dwType ;
        LPTSTR  pValueName = TEXT("TTY DeviceConfig");
                // these strings must match strings in oemui.cpp - VinitMyStuff()
                //  and OEMEnablePDEV()

        pMyStuff =    &MyStuff;
		
		pMyStuff->dwVersion = 0 ;

        dwStatus =  EngGetPrinterData(
            pdevobj->hPrinter, // handle of printer object
            pValueName, // address of value name
            &dwType,    // address receiving value type
            (LPBYTE)pMyStuff ,
                        // address of array of bytes that receives data
            sizeof(REGSTRUCT),  // size, in bytes, of array
            &cbNeeded   // address of variable
                    //  with number of bytes retrieved (or required)
            );
        if (dwStatus != ERROR_SUCCESS || pMyStuff->dwVersion != TTYSTRUCT_VER
                ||  dwType !=  REG_BINARY
                ||  cbNeeded != sizeof(REGSTRUCT))
        {
            //  set to defaults
            pMyStuff->iCodePage =  1252 ;  //   keep in sync with oemui.cpp - VinitMyStuff()
            pMyStuff->rcMargin.left  = pMyStuff->rcMargin.top  =
            pMyStuff->rcMargin.right  =  pMyStuff->rcMargin.bottom  = 0 ;
        }
    }

    switch  (dwInfoIndex)
    {
        case  TTY_INFO_MARGINS:
            *pcbNeeded = sizeof(RECT) ;
            if(!pOutBuf  ||  dwSize < *pcbNeeded)
                return(FALSE) ;
            *(LPRECT)pOutBuf = pMyStuff->rcMargin ;
            break;
        case  TTY_INFO_CODEPAGE:
            *pcbNeeded = sizeof(INT) ;
            if(!pOutBuf  ||  dwSize < *pcbNeeded)
                return(FALSE) ;
            *(INT *)pOutBuf = pMyStuff->iCodePage ;
            break;
        case  TTY_INFO_NUM_UFMS:
            *pcbNeeded = sizeof(DWORD) ;
            if(!pOutBuf  ||  dwSize < *pcbNeeded)
                return(FALSE) ;
            *(DWORD *)pOutBuf = NUM_UFMS ;  //  Number of resource IDs returned
            //  during a query for TTY_INFO_UFM_IDS
            break;
        case  TTY_INFO_UFM_IDS:
            // return resource IDs of the UFMs for 10,12, 17 cpi fonts.
            *pcbNeeded = NUM_UFMS * sizeof(DWORD) ;
            if(!pOutBuf  ||  dwSize < *pcbNeeded)
                return(FALSE) ;
            switch(pMyStuff->iCodePage)
            {
                
				case (-1):  // codepage 437
                    ((DWORD *)pOutBuf)[0] = 4 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 5;
                    ((DWORD *)pOutBuf)[2] = 6;
                    break;
                case (850):  // codepage 850
                    ((DWORD *)pOutBuf)[0] = 7;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 8;
                    ((DWORD *)pOutBuf)[2] = 9;
                    break;

				case (-3):  // codepage 863
                    ((DWORD *)pOutBuf)[0] = 7;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 8;
                    ((DWORD *)pOutBuf)[2] = 9;
                    break;

                case (-17):  // codepage 932
                    ((DWORD *)pOutBuf)[0] = 13 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 14 ;
                    ((DWORD *)pOutBuf)[2] = 15 ;
                    break;
                case (-16):  // codepage 936
                    ((DWORD *)pOutBuf)[0] = 16 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 17 ;
                    ((DWORD *)pOutBuf)[2] = 18 ;
                    break;
                case (-18):  // codepage 949
                    ((DWORD *)pOutBuf)[0] = 19 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 20 ;
                    ((DWORD *)pOutBuf)[2] = 21 ;
                    break;
                case (-10):  // codepage 950
                    ((DWORD *)pOutBuf)[0] = 22 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 23 ;
                    ((DWORD *)pOutBuf)[2] = 24 ;
                    break;
				case (1250):  // codepage 1250
                    ((DWORD *)pOutBuf)[0] = 25 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 26;
                    ((DWORD *)pOutBuf)[2] = 27;
                    break;
                case (1251):  // codepage 1251
                    ((DWORD *)pOutBuf)[0] = 28;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 29;
                    ((DWORD *)pOutBuf)[2] = 30;
                    break;
                case (1252):  // codepage 1252
                    ((DWORD *)pOutBuf)[0] = 31;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 32;
                    ((DWORD *)pOutBuf)[2] = 33;
                    break;
                case (1253):  // codepage 1253
                    ((DWORD *)pOutBuf)[0] = 34 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 35;
                    ((DWORD *)pOutBuf)[2] = 36;
                    break;
                case (1254):  // codepage 1254
                    ((DWORD *)pOutBuf)[0] = 37 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 38;
                    ((DWORD *)pOutBuf)[2] = 39;
                    break;
                case (852):	// codepage 852
					((DWORD *)pOutBuf)[0] = 40 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 41;
                    ((DWORD *)pOutBuf)[2] = 42;
		    
					break;
				case (857):	// codepage 857
					((DWORD *)pOutBuf)[0] = 43 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 44;
                    ((DWORD *)pOutBuf)[2] = 45;
		    
					break;
                default:
                    ((DWORD *)pOutBuf)[0] = 1 ;  //  '10 cpi'
                    ((DWORD *)pOutBuf)[1] = 2 ;  //  '12 cpi'
                    ((DWORD *)pOutBuf)[2] = 3 ;  //  '17 cpi'
                    break;
            }
            break;
        default:
            *pcbNeeded  = 0 ;  // no data availible
            return(FALSE) ;   // unsupported index
    }
    return(TRUE);
}

} // End of extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	 Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"
#include <strsafe.h>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;
    HRESULT hr = S_FALSE;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }

        //
        // Just to make sure we dont go into infinite loop and allocate
        // lots of memory, lets bail out if memory requirement becomes huge.
        // Multiplying by 8, i.e. will loop at most 4 times.
        //
        if ( dwSize > 8*DEBUG_BUFFER_SIZE )
        {
            return FALSE;
        }

        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

        hr = StringCchVPrintfA ( lpszMsgBuf, dwSize, lpszMessage, arglist);
    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED (hr) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;
    HRESULT    hr = S_FALSE;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hr = StringCchVPrintfW (lpszMsgBuf, dwSize, lpszMessage, arglist);
    if ( SUCCEEDED (hr) )
    {
        // Dump string to debug output.
        OutputDebugStringW(lpszMsgBuf);
    }

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(__TEXT("pPSUIInfo:\r\n"));
    VERBOSE(__TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(__TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(__TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(__TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(__TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(__TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(__TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(__TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(__TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\render\oemcom.h ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003 Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB
//
class IOemCB:public IPrintOemUni2
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
    										MIX         mix);
	
	//
	// OEMWritePrinter - UNIDRV only
	//
	
	STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
	                                 PVOID      pBuf,
		                             DWORD      cbBuffer,
    								 PDWORD     pcbWritten);


    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };

    ~IOemCB();

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\resource.h ===
//  Copyright (c) 1996-2003  Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ttyui.rc
//
#define IDC_STATIC      -1
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3
#define  IDS_STRING4             4
#define  IDS_STRING5             5
#define  IDS_STRING6             6
#define  IDS_STRING7             7
#define  IDS_STRING8             8
#define  IDS_STRING9             9
#define  IDS_STRING10            10
#define  IDS_STRING11            11
#define  IDS_STRING12            12

#define  IDS_STRING13            13
#define  IDS_STRING14            14
#define  IDS_STRING15            15
#define  IDS_STRING16            16
#define  IDS_STRING17            17
#define  IDS_STRING18            18
#define  IDS_STRING19            19
#define  IDS_STRING20            20
#define  IDS_STRING21            21

#define IDD_DOC_PROPPAGE                102
#define IDD_DEV_PROPPAGE                103
#define IDD_DEV_PROPPAGE2               104
#define IDC_SETUP_STRING                1000
#define IDC_EDIT10                      1000
#define IDC_EDIT1                       1005
#define IDC_EDIT2                       1006
#define IDC_EDIT3                       1007
#define IDC_EDIT4                       1008
#define IDC_EDIT5                       1009
#define IDC_EDIT6                       1011
#define IDC_EDIT7                       1012
#define IDC_EDIT8                       1013
#define IDC_EDIT9                       1014
#define IDC_RADIO1                      1015
#define IDC_RADIO2                      1016
#define IDC_BUTTON1                     1018
#define IDC_COMBO1                      1020
#define IDC_EDIT11                      1021
#define IDC_EDIT12                      1022
#define IDC_EDIT13                      1023
#define IDC_EDIT14                      1024
#define IDC_EDIT15                      1025
#define IDC_EDIT16                      1026
#define IDC_EDIT17                      1027
#define IDC_CHKBOX1                      1028

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\oemcomui.h ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003 Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB
//
class IOemCB: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );

    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );


    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           );



    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB();


protected:
    IPrintOemDriverUI* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\ttyui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   TTYUI.cpp
//
//
//  PURPOSE:  Main file for TTY UI user mode module.
//
//
//  Functions:
//
//
//
//
//  PLATFORMS:  Windows 2000, Windows XP, Windows Server 2003
//
//

#include <WINDOWS.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>
#include <stdlib.h>
#include <TCHAR.H>
#include <WINSPOOL.H>

#include "resource.h"
#include "TTYUI.h"
#include "ttyuihlp.h"
#include "debug.h"
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL GLOBALS
////////////////////////////////////////////////////////

HINSTANCE ghInstance = NULL;


////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

INT_PTR CALLBACK DevPropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DevPropPage2Proc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
BOOL   HexStringToBinary(LPBYTE  lpHex, LPBYTE  lpBinary,
    DWORD  nHexLen,  //  num bytes in src buffer lpHex.
    DWORD  nBinaryLen,    //  num bytes in dest buffer lpBinary
    DWORD * lpnBinBytes);   //  num bytes written to dest buffer lpBinary
BOOL   BinaryToHexString(LPBYTE  lpBinary, LPBYTE  lpHex,
    DWORD  nBinaryLen,   //  num bytes to process in lpBinary
    DWORD  nHexLen);  //  num bytes in dest buffer lpHex.
void  VinitMyStuff(
    PGLOBALSTRUCT  pGlobals,   // points to private structure for static storage
    BOOL    bSave   // save to registry  instead of reading from...
    ) ;
void            vSetGetCodePage(HWND hDlg,
    INT  *piCodePage,
    BOOL    bMode) ;   // TRUE:  Set,  FALSE:  Get code page.

BOOL   PrintUIHelp(
    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam,
    PGLOBALSTRUCT  pGlobals
    ) ;
BOOL    InitHelpfileName(PGLOBALSTRUCT  pGlobals) ;
PWSTR  PwstrCreateQualifiedName(
    HANDLE  hHeap,
    PWSTR   pDir,
    PWSTR   pFile
    );





// Need to export these functions as c declarations.
extern "C" {



//////////////////////////////////////////////////////////////////////////
//  Function:   DllMain
//
//  Description:  Dll entry point for initialization..
//
//
//  Comments:
//
//
//  History:
//      1/27/97 APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
    switch(wReason)
    {
        case DLL_PROCESS_ATTACH:
            // VERBOSE(DLLTEXT("Process attach.\r\n"));

            // Save DLL instance for use later.
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            // VERBOSE(DLLTEXT("Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            // VERBOSE(DLLTEXT("Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            // VERBOSE(DLLTEXT("Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


BOOL APIENTRY OEMGetInfo(IN DWORD dwInfo, OUT PVOID pBuffer, IN DWORD cbSize,
                         OUT PDWORD pcbNeeded)
{
    // VERBOSE(DLLTEXT("OEMGetInfo(%#x) entry.\r\n"), dwInfo);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo)
          &&
          (OEMGI_GETINTERFACEVERSION != dwInfo)
          &&
          (OEMGI_GETVERSION != dwInfo)
        )
        ||
        (NULL == pcbNeeded)
      )
    {
        WARNING(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
            *pcbNeeded = 0;

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer)
        ||
        (4 > cbSize)
      )
    {
        WARNING(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        // Return insufficient buffer size.
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
        case OEMGI_GETSIGNATURE:
            *(LPDWORD)pBuffer = OEM_SIGNATURE;
            break;

        case OEMGI_GETINTERFACEVERSION:
            *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
            break;

        case OEMGI_GETVERSION:
            *(LPDWORD)pBuffer = OEM_VERSION;
            break;
    }

    return TRUE;
}



LRESULT APIENTRY OEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LRESULT    lResult  = CPSUI_CANCEL ;
    LONG   lRet;


    VERBOSE(DLLTEXT("OEMDevicePropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        VERBOSE(ERRORTEXT("OEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;


                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEV_PROPPAGE);
                Page.pfnDlgProc = DevPropPageProc;

                //  allocate structure to hold static data for
                //  PropertySheet Dialog function

                pPSUIInfo->UserData =
                Page.lParam = (LPARAM)HeapAlloc(
                    ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->hOEMHeap,
                    HEAP_ZERO_MEMORY , sizeof(GLOBALSTRUCT) );

                if(!Page.lParam)
                       return -1;   // HeapAlloc failed.

                ((PGLOBALSTRUCT)Page.lParam)->hPrinter =
                    ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->hPrinter ;

                ((PGLOBALSTRUCT)Page.lParam)->hOEMHeap =
                    ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->hOEMHeap ;


                // Add property sheets.
                lResult = (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                        CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0) > 0 ? TRUE : FALSE);

                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEV_PROPPAGE2);
                Page.pfnDlgProc = DevPropPage2Proc;

                // Add another property sheet.
                if(lResult)
                {
                    lResult = (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                            CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0) > 0 ? TRUE : FALSE);
                }
                pPSUIInfo->Result = lResult;
                lRet = (lResult) ? 1 : -1 ;
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
                lRet = (lResult) ? 1 : -1 ;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            lRet = (lResult) ? 1 : -1 ;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
                pPSUIInfo->Result = lResult;
                lRet =  1  ;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            if(pPSUIInfo->UserData)
                HeapFree(
                    ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->hOEMHeap,
                    0 , (void *)pPSUIInfo->UserData );
            lResult = TRUE;
            lRet = (lResult) ? 1 : -1 ;
            break;
        default:

            lRet =  -1  ;
    }

    // pPSUIInfo->Result = lResult;
    return lRet;
}





} // End of extern "C"



//////////////////////////////////////////////////////////////////////////
//  Function:   DevPropPageProc
//
//  Description:  Generic property page procedure.
//
//
//
//
//  Comments:
//
//
//  History:
//      02/12/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DevPropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    //  RECT  rcMargin ;   // temp storage during conversions.
    PGLOBALSTRUCT  pGlobals;   // points to private structure for static storage
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    TCHAR  szIntString[MAX_INT_FIELD_WIDTH + 2] ;
    BYTE   szString[MAX_CMD_LEN + 1] ;
    BOOL bStatus = FALSE;


    switch (uiMsg)
    {
        case WM_INITDIALOG:

            pGlobals = (PGLOBALSTRUCT) ((PROPSHEETPAGE *)lParam)->lParam ;
            if(!pGlobals)
                return FALSE ;
            pMyStuff = &pGlobals->regStruct ;
            //  at WM_INITDIALOG time, lParam points to   PROPSHEETPAGE.
            //  extract and save ptr to GLOBALSTRUCT for future ref.
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pGlobals) ;

            VinitMyStuff( pGlobals, FALSE) ;


            SendDlgItemMessage(hDlg, IDC_EDIT10, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT11, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT12, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT13, EM_LIMITTEXT, MAX_CMD_LEN, 0);

            SendDlgItemMessage(hDlg, IDC_EDIT14, EM_LIMITTEXT, MAX_INT_FIELD_WIDTH, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT15, EM_LIMITTEXT, MAX_INT_FIELD_WIDTH, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT16, EM_LIMITTEXT, MAX_INT_FIELD_WIDTH, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT17, EM_LIMITTEXT, MAX_INT_FIELD_WIDTH, 0);


            if(pMyStuff->bIsMM)
                CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1) ;
            else
            {
                CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2) ;
                //  convert RECT values to inches
                pMyStuff->rcMargin.left  = MulDiv(pMyStuff->rcMargin.left, 100, 254) ;
                pMyStuff->rcMargin.top  = MulDiv(pMyStuff->rcMargin.top, 100, 254) ;
                pMyStuff->rcMargin.right  = MulDiv(pMyStuff->rcMargin.right, 100, 254) ;
                pMyStuff->rcMargin.bottom  = MulDiv(pMyStuff->rcMargin.bottom, 100, 254) ;
            }
            //   convert int to ascii string
            _itot(pMyStuff->rcMargin.left, szIntString, RADIX ) ;
            SetDlgItemText(hDlg, IDC_EDIT14, szIntString);
            _itot(pMyStuff->rcMargin.top, szIntString, RADIX) ;
            SetDlgItemText(hDlg, IDC_EDIT15, szIntString);
            _itot(pMyStuff->rcMargin.right, szIntString, RADIX) ;
            SetDlgItemText(hDlg, IDC_EDIT16, szIntString);
            _itot(pMyStuff->rcMargin.bottom, szIntString, RADIX) ;
            SetDlgItemText(hDlg, IDC_EDIT17, szIntString);

//**            init other edit boxes with corresponding command strings from registry

            if(BinaryToHexString(pMyStuff->BeginJob.strCmd, szString,
                    pMyStuff->BeginJob.dwLen,   MAX_CMD_LEN + 1))
                SetDlgItemTextA(hDlg, IDC_EDIT10, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->EndJob.strCmd, szString,
                    pMyStuff->EndJob.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT11, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->PaperSelect.strCmd, szString,
                    pMyStuff->PaperSelect.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT12, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->FeedSelect.strCmd, szString,
                    pMyStuff->FeedSelect.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT13, (LPCSTR)szString);

            break;

        case WM_NOTIFY:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            if(!pGlobals)
                return FALSE ;

            pMyStuff = &pGlobals->regStruct ;
            switch (((LPNMHDR)lParam)->code)  // type of notification message
            {
                case PSN_SETACTIVE:
                    break;

                case PSN_KILLACTIVE:
                //  formerly  case  IDC_BUTTON1:
                // convert user command to binary and back to
                                                //  verify proper entry.
                {
//**                        extract all command strings
                        GetDlgItemTextA(hDlg, IDC_EDIT10, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->BeginJob.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->BeginJob.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT11, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->EndJob.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->EndJob.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT12, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->PaperSelect.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->PaperSelect.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT13, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->FeedSelect.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->FeedSelect.dwLen) ;

                        //  reinitialize edit boxes with binary translated strings.
                        if(BinaryToHexString(pMyStuff->BeginJob.strCmd, szString,
                                pMyStuff->BeginJob.dwLen,   MAX_CMD_LEN + 1))
                            SetDlgItemTextA(hDlg, IDC_EDIT10, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->EndJob.strCmd, szString,
                                pMyStuff->EndJob.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT11, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->PaperSelect.strCmd, szString,
                                pMyStuff->PaperSelect.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT12, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->FeedSelect.strCmd, szString,
                                pMyStuff->FeedSelect.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT13, (LPCSTR)szString);
                }
                break;

                case PSN_APPLY:
                    {

                        //  MessageBox(hDlg, szString, "TTY settings", MB_OK);

                        //  load numbers in edit boxes into rcMargin

                        GetDlgItemText(hDlg, IDC_EDIT14, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.left = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT15, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.top = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT16, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.right = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT17, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.bottom = _ttoi(szIntString) ;

                        if(!pMyStuff->bIsMM )
                        {
                            //  convert RECT values from inches back to mm
                            pMyStuff->rcMargin.left  = MulDiv(pMyStuff->rcMargin.left, 254, 100) ;
                            pMyStuff->rcMargin.top  = MulDiv(pMyStuff->rcMargin.top, 254, 100) ;
                            pMyStuff->rcMargin.right  = MulDiv(pMyStuff->rcMargin.right, 254, 100) ;
                            pMyStuff->rcMargin.bottom  = MulDiv(pMyStuff->rcMargin.bottom, 254, 100) ;
                        }
//**                        extract all command strings
                        GetDlgItemTextA(hDlg, IDC_EDIT10, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->BeginJob.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->BeginJob.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT11, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->EndJob.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->EndJob.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT12, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->PaperSelect.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->PaperSelect.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT13, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->FeedSelect.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->FeedSelect.dwLen) ;

                        //  reinitialize edit boxes with binary translated strings.
                        if(BinaryToHexString(pMyStuff->BeginJob.strCmd, szString,
                                pMyStuff->BeginJob.dwLen,   MAX_CMD_LEN + 1))
                            SetDlgItemTextA(hDlg, IDC_EDIT10, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->EndJob.strCmd, szString,
                                pMyStuff->EndJob.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT11, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->PaperSelect.strCmd, szString,
                                pMyStuff->PaperSelect.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT12, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->FeedSelect.strCmd, szString,
                                pMyStuff->FeedSelect.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT13, (LPCSTR)szString);


                        //   store MyStuff in registry.
                         VinitMyStuff(pGlobals,  TRUE) ;

                    }
                    break;

                case PSN_RESET:
                    break;
            }
            break;
        case  WM_COMMAND:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            if(!pGlobals)
                return FALSE ;

            pMyStuff = &pGlobals->regStruct ;

            if(HIWORD(wParam) == EN_CHANGE)
                // type of notification message
            {
                switch(LOWORD(wParam))
                {
                    case  IDC_EDIT10:
                    case  IDC_EDIT11:
                    case  IDC_EDIT12:
                    case  IDC_EDIT13:
                    case  IDC_EDIT14:
                    case  IDC_EDIT15:
                    case  IDC_EDIT16:
                    case  IDC_EDIT17:
                        PropSheet_Changed(GetParent( hDlg ), hDlg);
                        break;
                    default:
                        break;
                }

            }


            switch(LOWORD(wParam))
            {
                case  IDC_RADIO1:  // convert to MM
                {
                    if(!pMyStuff->bIsMM )
                    {
                        // assume all values are inches
                        // convert to mm.  and store in edit boxes.

                        //  load numbers in edit boxes into rcMargin

                        GetDlgItemText(hDlg, IDC_EDIT14, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.left = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT15, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.top = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT16, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.right = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT17, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.bottom = _ttoi(szIntString) ;

                        //  convert RECT values from inches back to mm
                        pMyStuff->rcMargin.left  = MulDiv(pMyStuff->rcMargin.left, 254, 100) ;
                        pMyStuff->rcMargin.top  = MulDiv(pMyStuff->rcMargin.top, 254, 100) ;
                        pMyStuff->rcMargin.right  = MulDiv(pMyStuff->rcMargin.right, 254, 100) ;
                        pMyStuff->rcMargin.bottom  = MulDiv(pMyStuff->rcMargin.bottom, 254, 100) ;

                        //  load numbers from  rcMargin into edit boxes

                        _itot(pMyStuff->rcMargin.left, szIntString, RADIX ) ;
                        SetDlgItemText(hDlg, IDC_EDIT14, szIntString);
                        _itot(pMyStuff->rcMargin.top, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT15, szIntString);
                        _itot(pMyStuff->rcMargin.right, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT16, szIntString);
                        _itot(pMyStuff->rcMargin.bottom, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT17, szIntString);

                        pMyStuff->bIsMM = TRUE ;
                    }

                }
                break;
                case  IDC_RADIO2:  // convert to inches
                {
                    if(pMyStuff->bIsMM )
                    {
                        // assume all values are mm
                        // convert to inches.  and store in edit boxes.

                        //  load numbers in edit boxes into rcMargin

                        GetDlgItemText(hDlg, IDC_EDIT14, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.left = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT15, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.top = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT16, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.right = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT17, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.bottom = _ttoi(szIntString) ;

                        //  convert RECT values from mm back to inches
                        pMyStuff->rcMargin.left  = MulDiv(pMyStuff->rcMargin.left, 100, 254) ;
                        pMyStuff->rcMargin.top  = MulDiv(pMyStuff->rcMargin.top, 100, 254) ;
                        pMyStuff->rcMargin.right  = MulDiv(pMyStuff->rcMargin.right, 100, 254) ;
                        pMyStuff->rcMargin.bottom  = MulDiv(pMyStuff->rcMargin.bottom, 100, 254) ;

                        //  load numbers from  rcMargin into edit boxes

                        _itot(pMyStuff->rcMargin.left, szIntString, RADIX ) ;
                        SetDlgItemText(hDlg, IDC_EDIT14, szIntString);
                        _itot(pMyStuff->rcMargin.top, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT15, szIntString);
                        _itot(pMyStuff->rcMargin.right, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT16, szIntString);
                        _itot(pMyStuff->rcMargin.bottom, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT17, szIntString);

                        pMyStuff->bIsMM = FALSE ;
                    }
                }
                break;
            }
            break;
        case WM_HELP:
        case WM_CONTEXTMENU:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            if(!pGlobals)
                return FALSE ;
            //  pMyStuff = &pGlobals->regStruct ;
            bStatus = PrintUIHelp(uiMsg,  hDlg,  wParam,  lParam, pGlobals) ;
            break;

    }

    return bStatus ;
}

void  VinitMyStuff(
    PGLOBALSTRUCT  pGlobals,   // points to private structure for static storage
    BOOL    bSave   // save to registry  instead of reading from...
)
{
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    DWORD   dwStatus, cbNeeded, dwType ;
    LPTSTR  pValueName = TEXT("TTY DeviceConfig");
                // these strings must match strings in ttyud.cpp - OEMEnablePDEV()

    pMyStuff = &pGlobals->regStruct ;

    if(bSave)    //  save to registry
    {
        if(--pGlobals->dwUseCount)
            return ;
        //  you are the last property page to perform
        //  shutdown routine.  Save MyStuff to registry.

        SetPrinterData(
            pGlobals->hPrinter,    // handle of printer object
            pValueName,  // address of value name
            REG_BINARY, // flag for value type
            (LPBYTE)pMyStuff ,   // address of array that specifies printer data
            sizeof(REGSTRUCT)    // size, in bytes, of array
           );


        return ;
    }

    //  read from registry

    if(pGlobals->dwUseCount)
    {
        pGlobals->dwUseCount++ ;
        return ;
    }
    dwStatus =  GetPrinterData(
        pGlobals->hPrinter, // handle of printer object   saved previously.
        pValueName, // address of value name
        &dwType,    // address receiving value type
        (LPBYTE)pMyStuff,  // address of array of bytes that receives data
        sizeof(REGSTRUCT),  // size, in bytes, of array
        &cbNeeded   // address of variable
                //  with number of bytes retrieved (or required)
        );


    if (dwStatus != ERROR_SUCCESS || pMyStuff->dwVersion != TTYSTRUCT_VER
        ||  dwType !=  REG_BINARY
        ||  cbNeeded != sizeof(REGSTRUCT))
    {
        //  Init secret block with defaults

        pMyStuff->dwVersion = TTYSTRUCT_VER ;
        //  version stamp to avoid incompatible structures.

        pMyStuff->bIsMM = TRUE ;  // default to mm units
        //  read margin values from registry and store into temp RECT
        pMyStuff->iCodePage = 1252 ;
        pMyStuff->rcMargin.left  = pMyStuff->rcMargin.top  =
        pMyStuff->rcMargin.right  =  pMyStuff->rcMargin.bottom  = 0 ;
        pMyStuff->BeginJob.dwLen =
        pMyStuff->EndJob.dwLen =
        pMyStuff->PaperSelect.dwLen =
        pMyStuff->FeedSelect.dwLen =
        pMyStuff->Sel_10_cpi.dwLen =
        pMyStuff->Sel_12_cpi.dwLen =
        pMyStuff->Sel_17_cpi.dwLen =
        pMyStuff->Bold_ON.dwLen =
        pMyStuff->Bold_OFF.dwLen =
        pMyStuff->Underline_ON.dwLen =
        pMyStuff->Underline_OFF.dwLen = 0 ;

        // more fields here!
        pMyStuff->dwGlyphBufSiz =
        pMyStuff->dwSpoolBufSiz = 0 ;
        pMyStuff->aubGlyphBuf =
        pMyStuff->aubSpoolBuf  = NULL ;
    }

    InitHelpfileName(pGlobals) ;

    pGlobals->dwUseCount = 1 ;
    return ;
}

BOOL   BinaryToHexString(LPBYTE  lpBinary, LPBYTE  lpHex,
DWORD  nBinaryLen,   //  num bytes to process in lpBinary
DWORD  nHexLen)  //  num bytes in dest buffer lpHex.
{
    //  how do I translate TCHAR to ascii?
    //   use  Set GetDlgItemTextA
    //  add NULL termination to lpHex

    //  return FALSE if dest buffer exhausted


    DWORD  dwSrc, dwDst ;
    BOOL   bHexmode = FALSE ;
    BYTE  Nibble ;

    for(dwSrc = dwDst = 0 ; dwSrc < nBinaryLen ; dwSrc++)
    {
        if(lpBinary[dwSrc] < 0x21  ||  lpBinary[dwSrc] > 0x7e
            ||  lpBinary[dwSrc] == '<')
        {
            //  enter hexmode if not already
            if(!bHexmode)
            {
                if(dwDst + 5 >  nHexLen)
                    return(FALSE);
                lpHex[dwDst++] = '<' ;
                bHexmode = TRUE ;
            }
            else if(dwDst + 4 >  nHexLen)
                return(FALSE);

            Nibble = (lpBinary[dwSrc]  >> 4) & 0x0f  ;
            if(Nibble < 0x0a)
                lpHex[dwDst++] = '0' + Nibble ;
            else
                lpHex[dwDst++] = 'A' + Nibble - 0x0a ;
            // loNibble
            Nibble = lpBinary[dwSrc]  & 0x0f  ;
            if(Nibble < 0x0a)
                lpHex[dwDst++] = '0' + Nibble ;
            else
                lpHex[dwDst++] = 'A' + Nibble - 0x0a ;
        }
        else
        {
            //  exit hexmode if not already
            if(bHexmode)
            {
                lpHex[dwDst++] = '>' ;
                bHexmode = FALSE ;
            }
            if(dwDst + 2 >  nHexLen)
                return(FALSE);
            lpHex[dwDst++] =  lpBinary[dwSrc];
        }
    }
    if(bHexmode)
    {
        lpHex[dwDst++] = '>' ;
        bHexmode = FALSE ;
    }
    lpHex[dwDst] = '\0' ;  // null terminate string.
    return(TRUE);
}



BOOL   HexStringToBinary(LPBYTE  lpHex, LPBYTE  lpBinary,
DWORD  nHexLen,  //  num bytes in src buffer lpHex.
DWORD  nBinaryLen,    //  num bytes in dest buffer lpBinary
DWORD * lpnBinBytes)   //  num bytes written to dest buffer lpBinary
{
    //  how do I translate TCHAR to ascii?
    //   use  Set GetDlgItemTextA

    //  return FALSE if dest buffer exhausted


    DWORD  dwSrc, dwDst ;
    BOOL   bHexmode = FALSE, bHiByte ;
    BYTE  Nibble ;

    lpHex[nHexLen - 1] = '\0' ;  // null terminate src string
                //  to prevent overrun accidents.

    for(dwSrc = dwDst = 0 ; lpHex[dwSrc] ; dwSrc++)
    {
        if(bHexmode)  //  hexmode processing:
                            //  recognize only 0-9, a-f, A-F and >
                            //  all other chars are ignored.
        {
            if(lpHex[dwSrc] >= '0'  &&  lpHex[dwSrc] <= '9')
            {
                //  digits
                Nibble =   lpHex[dwSrc] - '0' ;
            }
            else if(lpHex[dwSrc] >= 'a'  &&  lpHex[dwSrc] <= 'f')
            {
                //  lower case hex digits
                Nibble =   0x0a + lpHex[dwSrc] - 'a' ;
            }
            else if(lpHex[dwSrc] >= 'A'  &&  lpHex[dwSrc] <= 'F')
            {
                //  upper case hex digits
                Nibble =   0x0a + lpHex[dwSrc] - 'A' ;
            }
            else if(lpHex[dwSrc] == '>')
            {
                    bHexmode = FALSE ;
                    continue;   // do not attempt to save anything.
            }
            else
                continue;   // totally ignore unexpected characters.
            if(bHiByte)
            {
                lpBinary[dwDst] = Nibble << 4 ;
                bHiByte = FALSE ;
            }
            else  // lowByte processing
            {
                if(dwDst + 1 >  nBinaryLen)
                {
                    *lpnBinBytes = dwDst ;
                    return(FALSE);
                }
                lpBinary[dwDst++] |= Nibble ;
                bHiByte = TRUE ;
            }
        }
        else if(lpHex[dwSrc] == '<')
        {
                bHiByte = bHexmode = TRUE ;
        }
        else
        {
            if(dwDst + 1 >  nBinaryLen)
            {
                *lpnBinBytes = dwDst ;
                return(FALSE);
            }
            lpBinary[dwDst++] = lpHex[dwSrc] ;
        }
    }
    *lpnBinBytes = dwDst ;
    return(TRUE);
}


// revised version for drop down list box

void            vSetGetCodePage(HWND hDlg,
INT  *piCodePage,
BOOL    bMode)   // TRUE:  Set,  FALSE:  Get code page.
{

    typedef  struct
    {
        INT  iCodepage ;  //  store this value in registry
    } CODEPAGE ;

    #define   NUM_CODEPAGES  14

    CODEPAGE  codepage[NUM_CODEPAGES] ;
    DWORD  dwI ;


    codepage[0].iCodepage = -1 ;    //    CP437.gtt   "United States"
    codepage[1].iCodepage = 850 ;  //  use 850 instead of -2 (IBM CP850.gtt   "Multilingual - Latin 1"
    codepage[2].iCodepage = -3 ;  //  CP863.gtt   "Canadian French"

    codepage[3].iCodepage = -10 ;     //     950.gtt    Traditional Chinese
    codepage[4].iCodepage = -16 ;     //     936.gtt        Simplified Chinese
    codepage[5].iCodepage = -17 ;     //     932.gtt       Japanese
    codepage[6].iCodepage = -18 ;     //     949.gtt   Korean

    codepage[7].iCodepage = 1250;   //  Eastern European
    codepage[8].iCodepage = 1251;   //  Cyrillic
    codepage[9].iCodepage = 1252;   //  US (ANSI)
    codepage[10].iCodepage = 1253;   //  Greek
    codepage[11].iCodepage = 1254;   //  Turkish

    codepage[12].iCodepage = 852;    //  Slavic - Latin 2
    codepage[13].iCodepage = 857;    //  Turkish IBM

/*
    codepage[17].iCodepage = 1255;   //  Hebrew
    codepage[18].iCodepage = 1256;   //  Arabic
    codepage[19].iCodepage = 1257;   //  Baltic
    codepage[20].iCodepage = 1258;   //  Vietnamese
    codepage[4].iCodepage = -11 ;     //     949_ISC.gtt
    codepage[5].iCodepage = -12 ;     //     932_JIS.gtt
    codepage[6].iCodepage = -13 ;     //     932_JISA.gtt
    codepage[7].iCodepage = -14 ;     //     950_NS86.gtt
    codepage[8].iCodepage = -15 ;     //     950_TCA.gtt
*/




    if(bMode)
    {
        dwI = (DWORD)SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCURSEL, 0, 0);
        if (dwI == CB_ERR)
            dwI = 0 ;

        *piCodePage = codepage[dwI].iCodepage ;
    }
    else        // need to initialize list box selection.
    {
        for(dwI = 0 ; dwI < NUM_CODEPAGES ; dwI++)
        {
            if(codepage[dwI].iCodepage ==  *piCodePage)
                break;
        }
        dwI %= NUM_CODEPAGES ;
        SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, dwI, NULL);
    }

}


INT_PTR CALLBACK DevPropPage2Proc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    PGLOBALSTRUCT  pGlobals;   // points to private structure for static storage
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    BYTE   szString[MAX_CMD_LEN + 1] ;
    TCHAR  tbuffer[MAX_CMD_LEN] ;
    DWORD   dwI ;
    BOOL    bStatus = FALSE;


    switch (uiMsg)
    {
        case WM_INITDIALOG:

            pGlobals = (PGLOBALSTRUCT) ((PROPSHEETPAGE *)lParam)->lParam ;
            if(!pGlobals)
                return FALSE ;

            pMyStuff = &pGlobals->regStruct ;
            //  at WM_INITDIALOG time, lParam points to   PROPSHEETPAGE.
            //  extract and save ptr to GLOBALSTRUCT for future ref.
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pGlobals) ;

            VinitMyStuff( pGlobals, FALSE) ;


            SendDlgItemMessage(hDlg, IDC_EDIT1, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT2, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT3, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT6, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT7, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT8, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT9, EM_LIMITTEXT, MAX_CMD_LEN, 0);

            for(dwI = FIRSTSTRINGID ; dwI <= LASTSTRINGID ; dwI++)
            {
                LoadString( ((PROPSHEETPAGE *)lParam)->hInstance, (UINT)dwI, tbuffer, MAX_CMD_LEN);
                (DWORD)SendDlgItemMessage(hDlg, IDC_COMBO1, CB_ADDSTRING, 0, (LPARAM)tbuffer);
            }

            vSetGetCodePage(hDlg, &pMyStuff->iCodePage, FALSE) ;  // Get code page.

//**            init other edit boxes with corresponding command strings from registry

            if(BinaryToHexString(pMyStuff->Sel_10_cpi.strCmd, szString,
                    pMyStuff->Sel_10_cpi.dwLen,   MAX_CMD_LEN + 1))
                SetDlgItemTextA(hDlg, IDC_EDIT1, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Sel_12_cpi.strCmd, szString,
                    pMyStuff->Sel_12_cpi.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT2, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Sel_17_cpi.strCmd, szString,
                    pMyStuff->Sel_17_cpi.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT3, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Bold_ON.strCmd, szString,
                    pMyStuff->Bold_ON.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT6, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Bold_OFF.strCmd, szString,
                    pMyStuff->Bold_OFF.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT7, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Underline_ON.strCmd, szString,
                    pMyStuff->Underline_ON.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT8, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Underline_OFF.strCmd, szString,
                    pMyStuff->Underline_OFF.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT9, (LPCSTR)szString);



            break;

        case WM_NOTIFY:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            if(!pGlobals)
                return FALSE ;

            pMyStuff = &pGlobals->regStruct ;

            switch (((LPNMHDR)lParam)->code)  // type of notification message
            {
                case PSN_SETACTIVE:
                    break;

                case PSN_KILLACTIVE:
                //  case  IDC_BUTTON1:
                    // convert user command to binary and back to
                                //  verify proper entry.
                {
                //**                        extract all command strings
                        GetDlgItemTextA(hDlg, IDC_EDIT1, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_10_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_10_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT2, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_12_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_12_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT3, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_17_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_17_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT6, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Bold_ON.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Bold_ON.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT7, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Bold_OFF.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Bold_OFF.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT8, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Underline_ON.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Underline_ON.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT9, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Underline_OFF.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Underline_OFF.dwLen) ;

                        //  reinitialize edit boxes with binary translated strings.

                        if(BinaryToHexString(pMyStuff->Sel_10_cpi.strCmd, szString,
                                pMyStuff->Sel_10_cpi.dwLen,   MAX_CMD_LEN + 1))
                            SetDlgItemTextA(hDlg, IDC_EDIT1, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Sel_12_cpi.strCmd, szString,
                                pMyStuff->Sel_12_cpi.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT2, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Sel_17_cpi.strCmd, szString,
                                pMyStuff->Sel_17_cpi.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT3, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Bold_ON.strCmd, szString,
                                pMyStuff->Bold_ON.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT6, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Bold_OFF.strCmd, szString,
                                pMyStuff->Bold_OFF.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT7, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Underline_ON.strCmd, szString,
                                pMyStuff->Underline_ON.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT8, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Underline_OFF.strCmd, szString,
                                pMyStuff->Underline_OFF.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT9, (LPCSTR)szString);

                }
                break;

                case PSN_APPLY:
                    {
                        // set code page
                        vSetGetCodePage(hDlg, &pMyStuff->iCodePage, TRUE) ;

                       //**                        extract all command strings

                        GetDlgItemTextA(hDlg, IDC_EDIT1, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_10_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_10_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT2, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_12_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_12_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT3, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_17_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_17_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT6, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Bold_ON.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Bold_ON.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT7, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Bold_OFF.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Bold_OFF.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT8, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Underline_ON.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Underline_ON.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT9, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Underline_OFF.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Underline_OFF.dwLen) ;

                        //  reinitialize edit boxes with binary translated strings.

                        if(BinaryToHexString(pMyStuff->Sel_10_cpi.strCmd, szString,
                                pMyStuff->Sel_10_cpi.dwLen,   MAX_CMD_LEN + 1))
                            SetDlgItemTextA(hDlg, IDC_EDIT1, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Sel_12_cpi.strCmd, szString,
                                pMyStuff->Sel_12_cpi.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT2, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Sel_17_cpi.strCmd, szString,
                                pMyStuff->Sel_17_cpi.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT3, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Bold_ON.strCmd, szString,
                                pMyStuff->Bold_ON.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT6, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Bold_OFF.strCmd, szString,
                                pMyStuff->Bold_OFF.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT7, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Underline_ON.strCmd, szString,
                                pMyStuff->Underline_ON.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT8, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Underline_OFF.strCmd, szString,
                                pMyStuff->Underline_OFF.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT9, (LPCSTR)szString);


                        //   store MyStuff in registry.
                         VinitMyStuff(pGlobals,  TRUE) ;

                    }
                    break;


                case PSN_RESET:
                    break;
            }
            break;
        case  WM_COMMAND:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            if(!pGlobals)
                return FALSE ;

            pMyStuff = &pGlobals->regStruct ;

            if(HIWORD(wParam) == EN_CHANGE)
                // type of notification message
            {
                switch(LOWORD(wParam))
                {
                    case  IDC_EDIT1:
                    case  IDC_EDIT2:
                    case  IDC_EDIT3:
                    case  IDC_EDIT6:
                    case  IDC_EDIT7:
                    case  IDC_EDIT8:
                    case  IDC_EDIT9:
                        PropSheet_Changed(GetParent( hDlg ), hDlg);
                        break;
                    default:
                        break;
                }
            }

            if(HIWORD(wParam) == CBN_SELCHANGE  &&
                LOWORD(wParam) == IDC_COMBO1)
                    PropSheet_Changed(GetParent( hDlg ), hDlg);

            if(HIWORD(wParam) == BN_CLICKED   &&
                LOWORD(wParam) == IDC_CHKBOX1)
                    PropSheet_Changed(GetParent( hDlg ), hDlg);

            break;
        case WM_HELP:
        case WM_CONTEXTMENU:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            if(!pGlobals)
                return FALSE ;

            bStatus = PrintUIHelp(uiMsg,  hDlg,  wParam,  lParam, pGlobals) ;
            break;

    }

    return bStatus;
}



BOOL    InitHelpfileName(PGLOBALSTRUCT  pGlobals)
{
    DWORD  cbNeeded = 0;
    PDRIVER_INFO_3   pdrvInfo3 = NULL;

    GetPrinterDriver(pGlobals->hPrinter, NULL, 3,  NULL, 0,  &cbNeeded) ;

    if (! (pdrvInfo3 = (PDRIVER_INFO_3)HeapAlloc(pGlobals->hOEMHeap, HEAP_ZERO_MEMORY,cbNeeded)))
        return(FALSE);  // Alloc failed

    if(!GetPrinterDriver(pGlobals->hPrinter, NULL, 3,  (LPBYTE)pdrvInfo3,
        cbNeeded,  &cbNeeded)){
	
	if(NULL != pdrvInfo3 )
		HeapFree(pGlobals->hOEMHeap, HEAP_ZERO_MEMORY,pdrvInfo3);
	return(FALSE) ;   // failed to initialize path
    }

    pGlobals->pwHelpFile =  PwstrCreateQualifiedName(
        pGlobals->hOEMHeap,
        pdrvInfo3->pDriverPath,
        TEXT("ttyui.hlp")
        ) ;
    return(TRUE);
}



PWSTR
PwstrCreateQualifiedName(
    HANDLE  hHeap,
    PWSTR   pDir,
    PWSTR   pFile
    )
/*++

Routine Description:

    Create a fully qualified name for the directory and file name passed in.

Arguments:

    pDir - Points to the path
    pFile - Points to file name
    hHeap - Points to the heap to allocate the returned string from.

Return Value:

    Pointer to the fully qualified name.

--*/

{
    DWORD dwLen, dwLenQualName;
    PWSTR pBasename, pQualifiedName = NULL;
    HRESULT hr = S_FALSE;

    //
    // Figure out the len of the directory
    //

    if (pBasename = wcsrchr(pDir, TEXT(PATH_SEPARATOR)))
    {
        pBasename++;
    }
    else
    {
        WARNING(ERRORTEXT("PwstrCreateQualifiedName(): Invalid path name.\r\n"));
        return NULL;
    }


    dwLen = (DWORD)(pBasename - pDir) ;   //  number of WCHARS
    dwLenQualName = dwLen + wcslen(pFile) + 1;


    //
    // Concatenate the input directory with the base filename
    //

    if (! (pQualifiedName = (PWSTR)HeapAlloc(hHeap, HEAP_ZERO_MEMORY,sizeof(WCHAR) *
                                    dwLenQualName)))
    {
        WARNING(ERRORTEXT("PwstrCreateQualifiedName(): Memory allocation failed.\r\n"));
        return NULL;
    }

    wcsncpy(pQualifiedName, pDir, dwLen);

    hr = StringCchCatW(pQualifiedName, dwLenQualName, pFile);
    if ( SUCCEEDED (hr) )
    {
        return pQualifiedName;
    }

    //
    // If control reaches here, something went wrong while doing cat.
    //
    if ( pQualifiedName )
    {
        //
        // If HeapAlloc succeeded but StringCchCat failed.
        //
        HeapFree ( hHeap, 0, pQualifiedName );
        pQualifiedName = NULL;
    }
    return NULL;
}



/*++

Routine Name:

    PrintUIHlep

Routine Description:

    All dialogs and property sheets call this routine
    to handle help.  It is important that control ID's
    are unique to this project for this to work.

Arguments:

    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if help message was dislayed, FALSE if message not handled,

--*/
BOOL
PrintUIHelp(
    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam,
    PGLOBALSTRUCT  pGlobals   // points to private structure for static storage

    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_HELP:

        bStatus = WinHelp(
                    (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                    pGlobals->pwHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR) (LPTSTR)aHelpIDs );
        break;

    case WM_CONTEXTMENU:

        bStatus = WinHelp(
                    (HWND)wParam,
                    pGlobals->pwHelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR) (LPTSTR)aHelpIDs );
        break;

    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\ttyuihlp.h ===
// Copyright (c) 1997-2003  Microsoft Corporation
//Generic Text Printer Driver (new 10/97)

// ;Printer Commands dialog

#define IDH_TTYUI_BEGIN_PRINTJOB        1000 // IDC_EDIT10
#define IDH_TTYUI_END_PRINTJOB          1021 // IDC_EDIT11
#define IDH_TTYUI_PAPERSIZE_SELECT  1022 // IDC_EDIT12
#define IDH_TTYUI_PAPERFEED_SELECTION   1023 // IDC_EDIT13
#define IDH_TTYUI_CHECK_COMMANDS    1018 // IDC_BUTTON1
#define IDH_TTYUI_UNPRINTABLE_MARGINS_LEFT  1024 // IDC_EDIT14
#define IDH_TTYUI_UNPRINTABLE_MARGINS_TOP   1025 // IDC_EDIT15
#define IDH_TTYUI_UNPRINTABLE_MARGINS_RIGHT 1026 // IDC_EDIT16
#define IDH_TTYUI_UNPRINTABLE_MARGINS_BOTTOM    1027 // IDC_EDIT17
#define IDH_TTYUI_UNITS_10MM     1015 // IDC_RADIO1
#define IDH_TTYUI_UNITS_100INCH     1016 // IDC_RADIO2

// ;Font Selection dialog

#define IDH_TTYUI_SELECT_10CPI     1005 // IDC_EDIT1
#define IDH_TTYUI_SELECT_12CPI     1006 //IDC_EDIT2
#define IDH_TTYUI_SELECT_17CPI     1007 //IDC_EDIT3
#define IDH_TTYUI_DBLWIDE_ON     1008 //IDC_EDIT4
#define IDH_TTYUI_DBLWIDE_OFF     1009 // IDC_EDIT5
#define IDH_TTYUI_BOLD_ON     1011 // IDC_EDIT6
#define IDH_TTYUI_BOLD_OFF     1012 // IDC_EDIT7
#define IDH_TTYUI_UNDERLINE_ON     1013 // IDC_EDIT8
#define IDH_TTYUI_UNDERLINE_OFF     1014 // IDC_EDIT9
#define IDH_TTYUI_CODE_PAGE     1020 // IDC_COMBO1

// Next default values for new objects
//
// #define _APS_NEXT_RESOURCE_VALUE        106
// #define _APS_NEXT_COMMAND_VALUE         40001
// #define _APS_NEXT_CONTROL_VALUE         1028
// #define _APS_NEXT_SYMED_VALUE           101


const DWORD aHelpIDs[]=
{
    IDC_EDIT1,  IDH_TTYUI_SELECT_10CPI,
    IDC_EDIT2,  IDH_TTYUI_SELECT_12CPI,
    IDC_EDIT3,  IDH_TTYUI_SELECT_17CPI,
    IDC_EDIT4,  IDH_TTYUI_DBLWIDE_ON,
    IDC_EDIT5,  IDH_TTYUI_DBLWIDE_OFF,
    IDC_EDIT6,  IDH_TTYUI_BOLD_ON,
    IDC_EDIT7,  IDH_TTYUI_BOLD_OFF,
    IDC_EDIT8,  IDH_TTYUI_UNDERLINE_ON,
    IDC_EDIT9,  IDH_TTYUI_UNDERLINE_OFF,

 IDC_EDIT10,  IDH_TTYUI_BEGIN_PRINTJOB,
 IDC_EDIT11,  IDH_TTYUI_END_PRINTJOB,
 IDC_EDIT12,  IDH_TTYUI_PAPERSIZE_SELECT,
 IDC_EDIT13,  IDH_TTYUI_PAPERFEED_SELECTION,
 IDC_EDIT14,  IDH_TTYUI_UNPRINTABLE_MARGINS_LEFT,
 IDC_EDIT15,  IDH_TTYUI_UNPRINTABLE_MARGINS_TOP,
 IDC_EDIT16,  IDH_TTYUI_UNPRINTABLE_MARGINS_RIGHT,
 IDC_EDIT17,  IDH_TTYUI_UNPRINTABLE_MARGINS_BOTTOM,


    IDC_RADIO1, IDH_TTYUI_UNITS_10MM,
    IDC_BUTTON1,    IDH_TTYUI_CHECK_COMMANDS,
    IDC_COMBO1, IDH_TTYUI_CODE_PAGE,
    IDC_RADIO2, IDH_TTYUI_UNITS_100INCH,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998-2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\oemcom.cpp ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, , Windows XP, Windows Server 2003 Unidrv driver

Revision History:

              Created it.

--*/


#include "stddef.h"
#include "stdlib.h"
#include "objbase.h"
#include <windows.h>
#include <assert.h>
#include <prsht.h>
#include <compstui.h>
#include <winddiui.h>
#include <printoem.h>
#include <initguid.h>
#include <prcomoem.h>
#include "oemcomui.h"
#include "ttyui.h"
#include "debug.h"
#include "name.h"
#include <strsafe.h>


// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{
    VERBOSE(DLLTEXT("IOemCB:QueryInterface entry.\n\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        VERBOSE(DLLTEXT("IOemCB:Return pointer to IUnknown.\n\n"));
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemCB:Return pointer to IPrintOemUI.\n"));
    }
    else
    {
        *ppv = NULL ;
        WARNING(DLLTEXT("IOemCB:No Interface. Return NULL.\n"));
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE(DLLTEXT("IOemCB:AddRef entry.\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release()
{
   VERBOSE(DLLTEXT("IOemCB:Release entry.\n"));
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}


IOemCB::~IOemCB()
{
    //
    // Make sure that driver's helper function interface is released.
    //
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    //
    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    //
    assert (0 == m_cRef) ;
   
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

    //
    // Need to store pointer to Driver Helper functions, if we already haven't.
    //
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        //
        // Get Interface to Helper Functions.
        //
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            //
            // Make sure that interface pointer reflects interface query failure.
            //
            this->pOEMHelp = NULL;
        }
    }

    if (this->pOEMHelp)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
	VERBOSE(DLLTEXT("IOemCB:GetInfo entry.\n\n"));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{
	VERBOSE(DLLTEXT("IOemCB:DevMode entry.\n\n"));

    return E_NOTIMPL;

}


LONG __stdcall IOemCB::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
	VERBOSE(DLLTEXT("IOemCB:CommonUIProp entry.\n\n"));

    return E_NOTIMPL;

}


LONG __stdcall IOemCB::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
	VERBOSE(DLLTEXT("IOemCB:DocumentPropertySheets entry.\n\n"));

    return E_NOTIMPL;

}

LONG __stdcall IOemCB::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
	VERBOSE(DLLTEXT("IOemCB:DevicePropertySheets entry.\n\n"));

    if(OEMDevicePropertySheets(pPSUIInfo, lParam) == 1)
        return S_OK;
    return   S_FALSE;
}

LONG __stdcall IOemCB::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{

	VERBOSE(DLLTEXT("IOemCB:DeviceCapabilities entry.\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
	VERBOSE(DLLTEXT("IOemCB:DevQueryPrintEx entry.\n\n"));

    return E_NOTIMPL;

}

LONG __stdcall IOemCB::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
	VERBOSE(DLLTEXT("IOemCB:UpgradePrinter entry.\n\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
	VERBOSE(DLLTEXT("IOemCB:PrinterEvent entry.\n\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemCB:DriverEvent entry.\n"));
    
	return E_NOTIMPL;
};

LONG __stdcall IOemCB::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    VERBOSE(DLLTEXT("IOemCB:QueryColorProfile entry.\n"));
    
	return E_NOTIMPL;
};


    //
    // UpdateExternalFonts
    //

LONG __stdcall IOemCB::UpdateExternalFonts(
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges)
{
	VERBOSE(DLLTEXT("IOemCB:UpdateExternalFonts entry.\n\n"));
    
	return E_NOTIMPL;
};



HRESULT __stdcall IOemCB::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam
        )
{
    VERBOSE(DLLTEXT("IOemCB:FontInstallerDlgProc entry.\n"));
    
	return E_NOTIMPL;
};

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };

    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    VERBOSE(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////


//
// Registration functions
// Testing purpose
//

// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //  VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\constrnt.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  constrnt.c - processing keywords imposing constraints
    between 2 or more option selections.   */





#include    "gpdparse.h"


// ----  functions defined in constrnt.c ---- //


BOOL   BparseConstraint(
PABSARRAYREF   paarValue,
PDWORD         pdwExistingCList,  //  index of start of contraint list.
BOOL           bCreate,
PGLOBL         pglobl) ;

BOOL    BexchangeDataInFOATNode(
DWORD   dwFeature,
DWORD   dwOption,
DWORD   dwFieldOff,  // offset of field in FeatureOption struct
PDWORD  pdwOut,     // previous contents of attribute node
PDWORD  pdwIn,
BOOL    bSynthetic,  //  access synthetic features
PGLOBL  pglobl
) ;

BOOL    BparseInvalidCombination(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl) ;

BOOL    BparseInvalidInstallableCombination1(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl) ;


// ---------------------------------------------------- //



/*  if time and circumstances warrent may define a
feature keyword  *ExemptFromConstraints: <optionname>
so in addition to specifying a default option, you
may specify which option is exempt from wildcard constraints.

Now we may introduce the concept of wildcard constraints:

if a constraint statement appears at the Feature level it
is equivalent to that statement appearing withing every
option construct in that feature except the option
named in the *ExemptFromConstraints: <optionname>.

We may introduce a wildcard option for the target of a constraint
say '*'.  This is used in place of the option name in the
a constraint statement say:

*Constraint: <featurename>.*

this means every option in <featurename> is disabled
except for the option named in the  <featurename>'s
*ExemptFromConstraints: <optionname>

*/




BOOL   BparseConstraint(
PABSARRAYREF   paarValue,
PDWORD  pdwExistingCList,  //  index of start of contraint list.
BOOL    bCreate,   //  Create new constraint list vs. appending to existing one.
PGLOBL  pglobl)
{
    BOOL        bStatus  ;
    DWORD       dwNewCnstRoot,
        dwListRoot,  //  holds temp list of qualified names
            //  this list will never be used again.
        dwCNode, dwLNode ;
    PCONSTRAINTS     pcnstr ;  // start of CONSTRAINTS array.
    PLISTNODE    plstBase ;  // start of LIST array
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.


    pcnstr = (PCONSTRAINTS) gMasterTable[MTI_CONSTRAINTS].pubStruct ;
    plstBase = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    bStatus = BparseList(paarValue, &dwListRoot, BparseQualifiedName,
                VALUE_QUALIFIED_NAME, pglobl) ;


    if(bStatus == FALSE  ||   dwListRoot ==  END_OF_LIST)
        return(FALSE) ;

    //  create list of constraints

    if(bStatus)
        bStatus =
            BallocElementFromMasterTable(MTI_CONSTRAINTS, &dwNewCnstRoot, pglobl) ;

    dwCNode = dwNewCnstRoot ;
    dwLNode = dwListRoot ;


    while(bStatus)
    {
        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;
        pcnstr[dwCNode].dwFeature = pqn->wFeatureID ;
        pcnstr[dwCNode].dwOption = pqn->wOptionID ;
        if(plstBase[dwLNode].dwNextItem == END_OF_LIST)
            break ;
        dwLNode = plstBase[dwLNode].dwNextItem ;
        bStatus = BallocElementFromMasterTable(MTI_CONSTRAINTS,
                &pcnstr[dwCNode].dwNextCnstrnt, pglobl) ;
        dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
    }

    if(!bStatus)
        return(FALSE) ;

    //  tack existing list onto new list.

    if(bCreate)  // there is an existing constraint list
        pcnstr[dwCNode].dwNextCnstrnt = END_OF_LIST ;
    else
        pcnstr[dwCNode].dwNextCnstrnt = *pdwExistingCList ;

    *pdwExistingCList = dwNewCnstRoot ;

    return(bStatus) ;
}




/*  note:  InvalidCombos are
    the only fields where the index of a structure
    is stored directly into a the offset part of
    an attribute tree node.   But this is ok since
    the snapshot code never picks this data up.
    Indicies of Constraint structures are stored in
    heap like all other things.
*/



BOOL    BexchangeDataInFOATNode(
DWORD   dwFeature,
DWORD   dwOption,
DWORD   dwFieldOff,  // offset of field in FeatureOption struct
PDWORD  pdwOut,     // previous contents of attribute node
PDWORD  pdwIn,
BOOL    bSynthetic,  //  access synthetic features
PGLOBL  pglobl)     // new contents of attribute node.
/*  'FOAT'  means  FeatureOption AttributeTree.
this function swaps the specified dword value in the specified
attribute node.   (normally used to hold the heap offset,
but this function writes nothing to the heap.)
The parameters dwFeature, dwOption, dwFieldOffset specify
the structure, field, and branch of the attribute tree.
If the specified option branch does not exist, one will be created,
(if pdwIn is not NULL)
its value will be initialized to *pdwIn and the value
INVALID_INDEX will be returned in pdwOut.
Assumptions:   the value is dword sized - specifically holds
array index of an array of structures.
The tree being accessed is strictly one level deep.  That is the
node is fully specified by just Feature, Option.
*/
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF        patr ;
    ATREEREF     atrFound ;
    DWORD    dwFeaOffset  ; // Start numbering features from this
        // starting point.  This gives synthetic features a separate
        //  non-overlapping number space from normal features.


    PDFEATURE_OPTIONS   pfo ;

    if(bSynthetic)
    {
        pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_SYNTHESIZED_FEATURES].pubStruct +
            dwFeature  ;
        dwFeaOffset = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;
    }
    else
    {
        pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct +
            dwFeature ;
        dwFeaOffset = 0 ;
    }

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    patr = (PATREEREF)((PBYTE)pfo + dwFieldOff) ;

    if(*patr == ATTRIB_UNINITIALIZED)
    {
        if(pdwIn)
        {
            if(!BcreateEndNode(patr, dwFeature + dwFeaOffset , dwOption, pglobl) )
                return(FALSE) ;  // resource exhaustion
            patt[*patr].dwOffset = *pdwIn ;
            patt[*patr].eOffsetMeans = VALUE_AT_HEAP ;
        }
        if(pdwOut)
            *pdwOut = INVALID_INDEX ;
        return(TRUE) ;
    }

    if(*patr & ATTRIB_HEAP_VALUE)
    {
        ERR(("Internal parser error.  BexchangeDataInFOATNode should never create a branchless node.\n"));
        return(FALSE) ;
    }

    // offset field contains index to another node
    if(pdwIn)
    {
        if(!BfindOrCreateMatchingNode(*patr, &atrFound, dwFeature + dwFeaOffset , dwOption, pglobl))
            return(FALSE) ;  // Tree inconsistency error or resource exhaustion
        if(patt[atrFound].eOffsetMeans != VALUE_AT_HEAP)
        {
            //  just created a new node.
    #if 1
            patt[atrFound].dwOffset = *pdwIn ;
    #else
            //  the way it was
            if(!BwriteToHeap(&(patt[atrFound].dwOffset), (PBYTE)pdwIn,
                                                        sizeof(DWORD), 4) )
                return(FALSE) ;  // A fatal error.
    #endif
            patt[atrFound].eOffsetMeans = VALUE_AT_HEAP ;
            if(pdwOut)
                *pdwOut = INVALID_INDEX ;
            return(TRUE) ;
        }

        if(pdwOut)
            *pdwOut = patt[atrFound].dwOffset ;
        patt[atrFound].dwOffset = *pdwIn ;
    }
    else
    {
        if(!BfindMatchingNode(*patr, &atrFound, dwFeature + dwFeaOffset , dwOption, pglobl))
        {
            if(pdwOut)
                *pdwOut = INVALID_INDEX ;
            return(TRUE) ;
        }
        if(pdwOut)
            *pdwOut = patt[atrFound].dwOffset ;
    }
    return(TRUE) ;
}


BOOL    BparseInvalidCombination(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl)

/*   called by BProcessSpecialKeyword
    when parsing  *InvalidCombination
    (basically is a Non-relocatable Global.)
    After parsing paarValue into a List of qualified names,
    we convert the List into list of INVALIDCOMBO structures
    and prepend this list to any previously existing
    lists of INVALIDCOMBO structures.
*/
{
    BOOL        bStatus, bPrevsExists  ;
    DWORD    dwListRoot,  //  holds temp list of qualified names
            dwNewInvCRoot , // start of new list of INVALIDCOMBO structures
        dwICNode, dwLNode, dwNumNodes ;
    PLISTNODE    plstBase ;  // start of LIST array
    PINVALIDCOMBO   pinvc ;  //  start of InvalidCombo array
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.


    pinvc = (PINVALIDCOMBO) gMasterTable[MTI_INVALIDCOMBO].pubStruct ;
    plstBase = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    bStatus = BparseList(paarValue, &dwListRoot,
                BparseQualifiedName, VALUE_QUALIFIED_NAME, pglobl) ;

    if(!bStatus)
        return(FALSE) ;

    //  if there are more than 2 objects in the list, process
    //  as an InvalidCombo, else store as UIConstraint.


    dwLNode = dwListRoot ;

    for(dwNumNodes = 1 ; plstBase[dwLNode].dwNextItem != END_OF_LIST ;
        dwNumNodes++)      //  locate end of list
    {
        dwLNode = plstBase[dwLNode].dwNextItem ;
    }

    if(dwNumNodes == 1)
    {
        ERR(("Must have at least 2 objects to define an InvalidCombination.\n"));
        return(FALSE) ;
    }
    if(dwNumNodes == 2)
    {
        DWORD       dwNewCnst, dwNextCnstrnt;
        PCONSTRAINTS     pcnstr ;  // start of CONSTRAINTS array.

        bStatus = BallocElementFromMasterTable(
            MTI_CONSTRAINTS, &dwNewCnst, pglobl) ;
        if(!bStatus)
            return(FALSE) ;
        dwLNode = dwListRoot ;
        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;
        pcnstr = (PCONSTRAINTS) gMasterTable[MTI_CONSTRAINTS].pubStruct ;

        //  prepend new constraint node to list

        BexchangeArbDataInFOATNode(pqn->wFeatureID, pqn->wOptionID,
                offsetof(DFEATURE_OPTIONS, atrConstraints),
                sizeof(DWORD), (PBYTE)&dwNextCnstrnt, (PBYTE)&dwNewCnst,
                &bPrevsExists, FALSE, pglobl) ;

        if(bPrevsExists)
            pcnstr[dwNewCnst].dwNextCnstrnt = dwNextCnstrnt ;
        else
            pcnstr[dwNewCnst].dwNextCnstrnt = END_OF_LIST ;

        // copy contents of 2nd list node into first constraint node.
        dwLNode = plstBase[dwLNode].dwNextItem ;
        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;

        pcnstr[dwNewCnst].dwFeature = pqn->wFeatureID ;
        pcnstr[dwNewCnst].dwOption = pqn->wOptionID ;

        return(TRUE) ;
    }


    //  create list of InvalidCombos

    if(bStatus)
        bStatus =
            BallocElementFromMasterTable(MTI_INVALIDCOMBO, &dwNewInvCRoot, pglobl) ;

    dwLNode = dwListRoot ;  //  reset
    dwICNode = dwNewInvCRoot ;

    while(bStatus)
    {
        DWORD   dwPrevsNode ;

        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;

        if(pqn->wOptionID == (WORD)INVALID_SYMBOLID)  // treat partially qualified
            pqn->wOptionID = (WORD)DEFAULT_INIT ;   // name as default initializer

        pinvc[dwICNode].dwFeature = pqn->wFeatureID ;
        pinvc[dwICNode].dwOption = pqn->wOptionID ;

        BexchangeDataInFOATNode(pqn->wFeatureID, pqn->wOptionID,
            dwFieldOff, &dwPrevsNode, &dwNewInvCRoot, FALSE, pglobl) ;

        if(dwPrevsNode == INVALID_INDEX)
            pinvc[dwICNode].dwNewCombo = END_OF_LIST ;
        else
            pinvc[dwICNode].dwNewCombo = dwPrevsNode ;

        if(plstBase[dwLNode].dwNextItem == END_OF_LIST)
            break ;
        dwLNode = plstBase[dwLNode].dwNextItem ;
        bStatus = BallocElementFromMasterTable(MTI_INVALIDCOMBO,
                &pinvc[dwICNode].dwNextElement, pglobl) ;
        dwICNode = pinvc[dwICNode].dwNextElement ;
    }

    if(!bStatus)
        return(FALSE) ;

    pinvc[dwICNode].dwNextElement = END_OF_LIST ;

    return(bStatus) ;
}



BOOL    BparseInvalidInstallableCombination1(
PABSARRAYREF paarValue,
DWORD        dwFieldOff,
PGLOBL       pglobl)
/*   called by BProcessSpecialKeyword
    when parsing  *InvalidInstallableCombination
    (basically is a Non-relocatable Global.)
    After parsing paarValue into a List of qualified names,
    we convert the List into list of INVALIDCOMBO structures
    and prepend this list to any previously existing
    lists of INVALIDCOMBO structures.  The first node of each
    InvalidCombo list points to another new InvalidCombo list.
    The first InvalidCombo is stored in the Global atrInvldInstallCombo.
*/
{
    BOOL        bStatus, bPrevsExists  ;
    DWORD    dwListRoot,  //  holds temp list of qualified names
            dwNewInvCRoot , // start of new list of INVALIDCOMBO structures
        dwICNode, dwLNode, dwNumNodes ;
    PLISTNODE    plstBase ;  // start of LIST array
    PINVALIDCOMBO   pinvc ;  //  start of InvalidCombo array
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.
    PGLOBALATTRIB   pga ;
    PATREEREF        patr ;


    pga =  (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
    pinvc = (PINVALIDCOMBO) gMasterTable[MTI_INVALIDCOMBO].pubStruct ;
    plstBase = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    bStatus = BparseList(paarValue, &dwListRoot,
                BparsePartiallyQualifiedName, VALUE_QUALIFIED_NAME, pglobl) ;

    if(!bStatus)
        return(FALSE) ;

    // cannot convert to UIConstraint bacause the synthesized
    //  Feature does not yet exist.

    dwLNode = dwListRoot ;

    for(dwNumNodes = 1 ; plstBase[dwLNode].dwNextItem != END_OF_LIST ;
        dwNumNodes++)      //  locate end of list
    {
        dwLNode = plstBase[dwLNode].dwNextItem ;
    }

    if(dwNumNodes == 1)
    {
        ERR(("Must have at least 2 objects to define an InvalidInstallableCombination.\n"));
        return(FALSE) ;
    }

    //  create list of InvalidCombos

    if(bStatus)
        bStatus =
            BallocElementFromMasterTable(MTI_INVALIDCOMBO, &dwNewInvCRoot, pglobl) ;

    dwLNode = dwListRoot ;  //  reset
    dwICNode = dwNewInvCRoot ;

    //  link to atrInvldInstallCombo
    patr = (PATREEREF)((PBYTE)pga + dwFieldOff) ;

    if(*patr == ATTRIB_UNINITIALIZED)
        pinvc[dwICNode].dwNewCombo = END_OF_LIST ;
    else  //  interpret *patr as index to INVC node.
        pinvc[dwICNode].dwNewCombo = *patr ;

    *patr = dwICNode;

    while(bStatus)
    {
        DWORD   dwPrevsNode ;  // create next element links only

        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;

        if(pqn->wOptionID == (WORD)INVALID_SYMBOLID)  // treat partially qualified
            pqn->wOptionID = (WORD)DEFAULT_INIT ;   // name as default initializer
                                                    //  this lets us know this feature
                                                    //  is installable.

        pinvc[dwICNode].dwFeature = pqn->wFeatureID ;
        pinvc[dwICNode].dwOption = pqn->wOptionID ;

        if(plstBase[dwLNode].dwNextItem == END_OF_LIST)
            break ;
        dwLNode = plstBase[dwLNode].dwNextItem ;
        bStatus = BallocElementFromMasterTable(MTI_INVALIDCOMBO,
                &pinvc[dwICNode].dwNextElement, pglobl) ;
        dwICNode = pinvc[dwICNode].dwNextElement ;
    }

    if(!bStatus)
        return(FALSE) ;

    pinvc[dwICNode].dwNextElement = END_OF_LIST ;

    return(bStatus) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\command.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  command.c - processing command keywords.   */



#include    "gpdparse.h"


// ----  functions defined in  command.c ---- //

BOOL    BprocessParam(
IN      PABSARRAYREF paarValue,
IN      PARRAYREF    parStrValue,
IN  OUT PGLOBL       pglobl) ;

BOOL    BparseCommandString(
IN      PABSARRAYREF   paarValue,
IN      PARRAYREF      parStrValue,
IN  OUT PGLOBL         pglobl ) ;

BOOL    BconstructRPNtokenStream(
IN  OUT PABSARRAYREF  paarValue,
    OUT PARRAYREF     parRPNtokenStream,
IN  OUT PGLOBL        pglobl) ;

VOID    VinitOperPrecedence(
IN  OUT PGLOBL        pglobl) ;

BOOL    BparseArithmeticToken(
IN  OUT PABSARRAYREF  paarValue,
OUT PTOKENSTREAM      ptstr,
    PGLOBL            pglobl
) ;

BOOL    BparseDigits(
IN  OUT PABSARRAYREF   paarValue,
OUT PTOKENSTREAM  ptstr ) ;

BOOL    BparseParamKeyword(
IN  OUT PABSARRAYREF  paarValue,
OUT PTOKENSTREAM      ptstr,
    PGLOBL            pglobl ) ;

BOOL  BcmpAARtoStr(
PABSARRAYREF    paarStr1,
PBYTE       str2) ;

BOOL        bDivByZeroCheck(PTOKENSTREAM  ptstr) ;



// ---------------------------------------------------- //




BOOL    BprocessParam(
IN      PABSARRAYREF   paarValue,
IN      PARRAYREF      parStrValue,
IN  OUT PGLOBL         pglobl)
/*  notice this function will append the substring
"%dddd" (without the double quotes) onto the existing
parStrValue.   To allow the control module to unambiguously
parse out this substring, The GPD spec requires any occurance
of the character '%' within an Invocation String must be
preceeded by another '%'.  So the control module will find two
outcomes when encountering a % char in an invocation string:
it is followed by another % char  in which case only one % should
be emitted.  It is followed by exactly 4 decimal digits.  This
specifies the parameter index and specifies the parameter should be
emitted at this point instead of the "%dddd".  Additional digits
are part of the invocation string and should be emitted.
*/
{
    PSTR   pstrDelimiters = "dDcClmqgnvf" ;
    PPARAMETER  pparamRoot, pparam ;
    DWORD  dwParamIndex, dwDelIndex ;
    ABSARRAYREF    aarToken ;

    if(! BeatDelimiter(paarValue, "%"))
        return(FALSE) ;  // BUG_BUG  paranoid, inconsistency error.
    if(!BdelimitToken(paarValue, pstrDelimiters, &aarToken, &dwDelIndex) )
    {
        ERR(("Command parameter: Missing format character.\n")) ;

        return(FALSE) ;
    }
    pparamRoot = (PPARAMETER) gMasterTable[MTI_PARAMETER].pubStruct ;

    if(!BallocElementFromMasterTable(MTI_PARAMETER, &dwParamIndex, pglobl) )
        return(FALSE) ;  // try again with more resources.

    pparam = pparamRoot + dwParamIndex ;

    pparam->dwFlags = 0 ;
    pparam->dwFormat = (DWORD)(BYTE)pstrDelimiters[dwDelIndex] ;

    (VOID) BeatLeadingWhiteSpaces(&aarToken) ;

    if(aarToken.dw)
    {
        if(pstrDelimiters[dwDelIndex] == 'd' || pstrDelimiters[dwDelIndex] == 'D')
        {
            if(!BparseInteger(&aarToken, &pparam->dwDigits, VALUE_INTEGER, pglobl) )
            {
                ERR(("Command parameter: Syntax error in format width field.\n"));
                return(FALSE) ;
            }
            if(pparam->dwDigits != WILDCARD_VALUE)
                pparam->dwFlags |= PARAM_FLAG_FIELDWIDTH_USED ;
        }
        else
        {
            ERR(("Command parameter: Unexpected chars found preceeding format specifier: '%0.*s'.\n",
                aarToken.dw, aarToken.pub));
            return(FALSE) ;
        }
    }
    //  its ok to omit the fieldwidth specification
    //  now look for optional 'Limits' construct

    pstrDelimiters = "[{" ;
    if(!BdelimitToken(paarValue, pstrDelimiters, &aarToken, &dwDelIndex) )
    {
        ERR(("Command parameter: missing '{' in Value construct.\n"));

        return(FALSE) ;
    }
    (VOID) BeatLeadingWhiteSpaces(&aarToken) ;

    if(aarToken.dw)
    {
        ERR(("Command parameter: unexpected chars found preceeding Limits or Value construct: '%0.*s'.\n",
                aarToken.dw, aarToken.pub));
        return(FALSE) ;
    }
    if(pstrDelimiters[dwDelIndex] == '[')
    {
        if(!BdelimitToken(paarValue, ",", &aarToken, &dwDelIndex) )
        {
            ERR(("Command parameter: missing comma delimiter in Limits construct.\n"));

            return(FALSE) ;
        }
        if(!BparseInteger(&aarToken, &pparam->lMin, VALUE_INTEGER, pglobl) )
        {
            ERR(("Command parameter: syntax error in Min Limit field.\n"));
            return(FALSE) ;
        }
        if(pparam->lMin != WILDCARD_VALUE)
            pparam->dwFlags |= PARAM_FLAG_MIN_USED ;

        if(!BdelimitToken(paarValue, "]", &aarToken, &dwDelIndex) )
        {
            ERR(("Command parameter: missing closing bracket in Limits construct.\n"));

            return(FALSE) ;
        }
        if(!BparseInteger(&aarToken, &pparam->lMax, VALUE_INTEGER, pglobl) )
        {
            ERR(("Command parameter: syntax error in Max Limit field.\n"));
            return(FALSE) ;
        }
        if(pparam->lMax != WILDCARD_VALUE)
            pparam->dwFlags |= PARAM_FLAG_MAX_USED ;

        if(! BeatDelimiter(paarValue, "{"))
        {
            ERR(("Command parameter: missing required '{' in Value construct.\n"));

            return(FALSE) ;
        }
    }
    //  now back to parsing Value construct.

    if(!BconstructRPNtokenStream(paarValue, &pparam->arTokens, pglobl) )
        return(FALSE) ;


    //  convert dwParamIndex  to 4 digit ascii string of
    //  the form  "%dddd"
    {
        BYTE  aub[6] ;  // temp array of unsigned bytes
        DWORD  dwI, dwNdigits = 4 ;  // 4 is number of digits in string
        ARRAYREF      arTmpDest ;  // write result here first.

        // the most significant digit has the smaller byte address!

        aub[0] = '%' ;
        aub[dwNdigits + 1] = '\0' ;  // null terminate, but not needed.

        for(dwI = dwNdigits ; dwI ; dwI--)
        {
            aub[dwI] = (BYTE)('0' + dwParamIndex % 10) ;
            dwParamIndex /= 10 ;
        }

        //  write "%dddd" out to heap.  note if parStrValue->dwCount
        //  is zero, we must initialize parStrValue from
        //  scratch instead of appending.  Must use an Alignment of 1
        //  to avoid creating gaps in the command string.

        if(!BwriteToHeap(&arTmpDest.loOffset, aub, dwNdigits + 1, 1, pglobl))
            return(FALSE) ;
        //  append this run to existing string
        if(!parStrValue->dwCount)  // no prevs string exists
        {
            parStrValue->loOffset = arTmpDest.loOffset ;
        }
        else
        {
            // BUG_BUG paranoid:  may check that string is contiguous
            // parStrValue->loOffset + parStrValue->dwCount
            // should equal arTmpDest.loOffset
            ASSERT(parStrValue->loOffset + parStrValue->dwCount == arTmpDest.loOffset) ;
        }
        parStrValue->dwCount += dwNdigits + 1 ;
    }
    return(TRUE) ;
}



BOOL    BparseCommandString(
IN     PABSARRAYREF   paarValue,
IN     PARRAYREF      parStrValue,
IN OUT PGLOBL         pglobl
)
{
    ABSARRAYREF     aarToken ;  // points to individual string segment.
    DWORD       dwDelIndex, dwNumParams = 0 ;    //  dummy

    parStrValue->dwCount = 0 ;  // tells functions to create new string
        //  in heap.  Don't append to existing string.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    while(paarValue->dw)
    {
        if(paarValue->pub[0] == '%')
        {
            if(++dwNumParams > 14)
            {
                ERR(("CmdInvocation: Unidrv imposes a max limit of 14 parameters per command.\n"));
                return(FALSE) ;  // Black Death.
            }
            if(!BprocessParam(paarValue, parStrValue, pglobl) )
            //  deposits a little turd on the stringheap,
            //  modifies parStrValue accordingly and
            //  initializes one parameter array element.
            {
                return(FALSE) ;  // Black Death.
            }
        }
        else if(paarValue->pub[0] == '"')
        {
            paarValue->pub++ ;
            paarValue->dw-- ;  // skip the initial quote.
            if(!BdelimitToken(paarValue, "\"", &aarToken, &dwDelIndex) )
            {
                ERR(("CmdInvocation: missing terminating '\"'  in command string.\n"));

                return(FALSE) ;
            }
            if(!BparseStrSegment(&aarToken, parStrValue, pglobl))
            {
                return(FALSE) ;
            }
        }
        else
        {
            ERR(("CmdInvocation: command string segment must begin with '\"' or '%'.\n"));
            return(FALSE) ;
        }
        (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    }

    //  We don't want null terminations to occur between parameter
    //  portion of a string.  We just want to blindly add the NULL
    //  when parsing is really finished.

    {
        DWORD     dwDummy ;  // don't care about result

        if(!BwriteToHeap(&dwDummy, "\0", 1, 1, pglobl) )  //  add Null termination
            return(FALSE) ;
    }
    return(TRUE) ;
}

BOOL    BconstructRPNtokenStream(
IN  OUT PABSARRAYREF   paarValue,
    OUT PARRAYREF      parRPNtokenStream,
IN  OUT PGLOBL         pglobl)
/*   the input stream is parsed into tokens,
    each token is assigned an operator value  see OPERATOR
    enum.
    The Control module interprets the tokenstream just as
    Reverse Polish Notation.
    In the Control Module, each token is processed as follows:
    OP_INTEGER:  take dwValue and copy to stack
    OP_VARI_INDEX: dwValue is an index identifying the
        Unidrv Standard Variable whose current value
        should be placed on the stack.
    OP_MIN :
    OP_MAX :
        pop the top 2 values from the stack and push the
        smaller or larger value back onto the stack.
    OP_ADD :
    OP_SUB :
    OP_MULT :
    OP_DIV :
    OP_MOD :
        pop the top 2 values from the stack perform the
        indicated arithmetic operation, and push the
        result back onto the stack.  The topmost value in the stack
        should be used as the 2nd operand in the operation.
    OP_NEG :  pop the top value from the stack and push its
        negative back on the stack.
    OP_MAX_REPEAT :  this should always be the last command
        executed.  It means take the top value on the stack and
        if it exceeds the MaxValue specified in lMax, emit the
        command invocation multiple times with this parameter no
        larger than lMax so that the sum equals the value on
        the stack.
    OP_HALT:  If the value on the stack has not yet been emitted
        due to processing the OP_MAX_REPEAT operator,
        emit this value or the closest of lMin or lMax if specified.
        processing for this parameter is now complete.


    In the parser, each token is processed as follows:

    OP_INTEGER, OP_VARI_INDEX:  these values are
    placed directly into the RPNtokenStream in the order
    they were encountered.  They cause the valueToken count to
    be incremented.

    Then 2nd group of tokens from OP_MIN to OP_HALT
    are first placed into an operator queue (or is it a stack?)
    They are inserted into the queue in the order in which
    they are encountered, and when they leave the queue, they
    are inserted into the RPNtokenStream.  There are the rules
    governing when an operator token may leave the queue:

    a) each token is assigned a precedence level.
        here they are arranged from highest to lowest.
        OP_NEG    a unary operator
        OP_MULT, OP_DIV, OP_MOD  have the same level
        OP_ADD, OP_SUB  have the same level
        OP_MIN, OP_MAX, OP_MAX_REPEAT have the same level
            but are always preceeded by an OP_OPENPAR token.
        OP_HALT   has the lowest level.  (it is generated when
        the closing } is encountered.)
        OP_CLOSEPAR and OP_OPENPAR have even lower
        precedences for firewall purposes.

    b) no token may leave the queue unless a token with equal
        or lower precedence has just arrived.  At that point
        the token immediately adjacent to the new arrival
        leaves.  If the next token is also of higher or equal
        precedence than the new arrival, it too leaves.
        The tokens depart until this condition is false.

    c) the OP_HALT token is not only able to allow all other
        tokens to leave the queue, but after that, it too
        leaves the queue and enters the tokenStream.

    d)  the OP_OPENPAR and OP_CLOSEPAR  tokens are different.
        They will never be inserted into the RPNtokenStream, but
        only serve to modify the departure rules governing the
        queue.

    e)  OP_OPENPAR  acts to freeze all operators
        already in the queue.  Those operators cannot
        exit the queue until the OP_OPENPAR has been removed
        from the queue.   All subsequent operators entering
        the queue are unaffected by OP_OPENPAR already residing
        within the queue.

    f)  the OP_CLOSEPAR acts to flush all operators in the
        queue up to the first encountered OP_OPENPAR.
        Upon meeting its counterpart, both vanish from the
        queue never to be seen again.

    The max_repeat operator if used, must be first token parsed.
    Obviously it can appear only once in an expression.

    Token counting , unary operator detection and syntax
    error detection:

    for every binary operator parsed the operator count is
    incremented.  Immediately after incrementing, the operator count
    should always be equal to the valueToken count.  An excess in
    the operator count of one may indicate the operator is
    a unary operator.  Any deficit or excess greater than 2 indicates
    a syntax error.  Immediately after incrementing, the valueToken
    count should always be one greater than the operator count.

    For the purposes of the operator count, the following tokens
    qualify:
        OP_ADD, OP_SUB, OP_MULT,
        OP_DIV, OP_MOD, OP_COMMA

    Note:  for function operators the function name and opening
    parenthesis is parsed as one object.

*/

{
    TOKENSTREAM     tstrNode ;
    BOOL    bStatus ;

    DWORD  dwValueToken = 0 ,  //  number of value tokens parsed.
           dwOperatorToken = 0 ,  // number of binary operators parsed.
           dwQueuePtr = 0 , //  current position in the tmp operator queue.
           dwCurToken,      // index of curToken.
           dwQueueSize ;   //  num elements in array
    PDWORD  pdwQueueRoot ;  // Points to root of queue.
    PTOKENSTREAM  ptstr, ptstrRoot ;


    pdwQueueRoot = (PDWORD) gMasterTable[MTI_OP_QUEUE].pubStruct ;
    dwQueueSize = gMasterTable[MTI_OP_QUEUE].dwArraySize ;
    ptstrRoot = (PTOKENSTREAM) gMasterTable[MTI_TOKENSTREAM].pubStruct ;

    parRPNtokenStream->loOffset = gMasterTable[MTI_TOKENSTREAM].dwCurIndex ;
    parRPNtokenStream->dwCount = 0 ;

    while(bStatus = BparseArithmeticToken(paarValue, &tstrNode, pglobl))
    {
        switch(tstrNode.eType)
        {
            case OP_INTEGER :
            case OP_VARI_INDEX :
            {
                if(dwOperatorToken != dwValueToken)
                {
                    ERR(("Command parameter: arithmetic syntax error in value construct.\n"));

                    bStatus = FALSE ;
                }
                dwValueToken++ ;
                break ;
            }
            case OP_ADD :
            case OP_SUB :
            case OP_MULT :
            case OP_DIV :
            case OP_MOD :
            case OP_COMMA :
            {
                dwOperatorToken++ ;
                if(dwOperatorToken == dwValueToken)
                    break ;
                else if(dwOperatorToken == dwValueToken + 1)
                {
                    // maybe interpret operator as Unary.
                    if(tstrNode.eType == OP_SUB)
                    {
                        tstrNode.eType = OP_NEG ;
                        dwOperatorToken-- ;
                        break ;
                    }
                    else if(tstrNode.eType == OP_ADD)
                    {
                        tstrNode.eType = OP_NULL ;
                        dwOperatorToken-- ;
                        break ;
                    }
                }
                ERR(("Command parameter: arithmetic syntax error in value construct.\n"));

                bStatus = FALSE ;
                break ;
            }
            case OP_MIN :
            case OP_MAX :
            case OP_OPENPAR :
            {
                if(dwValueToken != dwOperatorToken)
                {
                    ERR(("Command parameter: arithmetic syntax error in value construct.\n"));

                    bStatus = FALSE ;
                }
                break ;
            }
            case OP_CLOSEPAR :
            case OP_HALT :
            {
                if(dwValueToken != dwOperatorToken + 1)
                {
                    ERR(("Command parameter: arithmetic syntax error in value construct.\n"));

                    bStatus = FALSE ;
                }
                break ;
            }
            case OP_MAX_REPEAT :
            {
                if(dwValueToken || dwOperatorToken  ||  dwQueuePtr)
                {
                    ERR(("Command parameter: syntax error in value construct.\n"));
                    ERR(("  OP_MAX_REPEAT must appear as the outermost operator only.\n"));

                    bStatus = FALSE ;
                }
                break ;
            }
            default:
            {
                break ;
            }
        }
        if(!bStatus )
            break ;
        switch(tstrNode.eType)
        {
            case OP_INTEGER :
            case OP_VARI_INDEX :
            {
                bStatus = BallocElementFromMasterTable(
                            MTI_TOKENSTREAM, &dwCurToken, pglobl) ;
                if(!bStatus )
                    break ;
                parRPNtokenStream->dwCount++ ;
                ptstr = ptstrRoot + dwCurToken ;
                ptstr->eType = tstrNode.eType ;
                ptstr->dwValue = tstrNode.dwValue ;
                break ;
            }
            case OP_ADD :
            case OP_SUB :
            case OP_MULT :
            case OP_DIV :
            case OP_MOD :
            case OP_NEG :
            {
                while (dwQueuePtr  &&
                    (gdwOperPrecedence[tstrNode.eType] <=
                    gdwOperPrecedence[*(pdwQueueRoot + dwQueuePtr - 1)]) )
                {
                    bStatus = BallocElementFromMasterTable(
                                MTI_TOKENSTREAM, &dwCurToken, pglobl) ;
                    if(!bStatus )
                        break ;
                    parRPNtokenStream->dwCount++ ;
                    ptstr = ptstrRoot + dwCurToken ;
                    ptstr->eType = *(pdwQueueRoot + dwQueuePtr - 1) ;
                    ptstr->dwValue = 0 ;  // undefined
                    dwQueuePtr-- ;  // pop off the Queue.
                    bDivByZeroCheck(ptstr);
                }
                if(dwQueuePtr >= dwQueueSize)
                    bStatus = FALSE ;   //  Queue overflow
                if(!bStatus )
                    break ;

                //add current Oper to Queue
                *(pdwQueueRoot + dwQueuePtr) = tstrNode.eType ;
                dwQueuePtr++ ;
                break ;
            }
            case OP_MIN :
            case OP_MAX :
            case OP_MAX_REPEAT :
            case OP_OPENPAR :
            {
                if(dwQueuePtr + 1 >= dwQueueSize)  // room for two?
                    bStatus = FALSE ;   //  Queue overflow
                if(!bStatus )
                    break ;

                //add OP_OPENPAR to Queue
                *(pdwQueueRoot + dwQueuePtr) = OP_OPENPAR ;
                dwQueuePtr++ ;
                //add current Oper to Queue
                if(tstrNode.eType != OP_OPENPAR)
                {
                    *(pdwQueueRoot + dwQueuePtr) = tstrNode.eType ;
                    dwQueuePtr++ ;
                }
                break ;
            }
            case OP_CLOSEPAR :
            case OP_COMMA :
            case OP_HALT :
            {
                while (dwQueuePtr  &&
                    (gdwOperPrecedence[tstrNode.eType] <=
                    gdwOperPrecedence[*(pdwQueueRoot + dwQueuePtr - 1)]) )
                {
                    bStatus = BallocElementFromMasterTable(
                                MTI_TOKENSTREAM, &dwCurToken, pglobl) ;
                    if(!bStatus )
                        break ;
                    parRPNtokenStream->dwCount++ ;
                    ptstr = ptstrRoot + dwCurToken ;
                    ptstr->eType = *(pdwQueueRoot + dwQueuePtr - 1) ;
                    ptstr->dwValue = 0 ;  // undefined
                    dwQueuePtr-- ;  // pop off the Queue.
                    bDivByZeroCheck(ptstr);
                }
                if(!bStatus )
                    break ;
                if(tstrNode.eType == OP_COMMA)
                {
                    //  comma clears all operators in queue up to the
                    //  function.  This completes processing of the
                    //  first argument.  The comma effectively converts
                    //  the syntax   funct(A + B, C * D)  into
                    //  ((A + B) funct (C * D))

                    //  check to see if function operator is now at
                    //  top of queue.
                    if(dwQueuePtr)
                    {
                        OPERATOR   eType ;

                        eType = *(pdwQueueRoot + dwQueuePtr - 1) ;
                        if(eType == OP_MIN  ||  eType == OP_MAX)
                            break ;
                    }
                    ERR(("Command parameter: syntax error in value construct.\n"));
                    ERR(("  comma used outside of function argument list.\n"));
                    bStatus = FALSE ;
                }
                else  if(tstrNode.eType == OP_HALT)
                {
                    if(dwQueuePtr)
                    {
                        ERR(("Command parameter: syntax error in value construct - unmatched  OP_OPENPAR.\n"));
                        bStatus = FALSE ;
                        break ;
                    }
                    //  now add halt operator to tokenStream
                    bStatus = BallocElementFromMasterTable(
                                MTI_TOKENSTREAM, &dwCurToken, pglobl) ;
                    if(!bStatus )
                        break ;
                    parRPNtokenStream->dwCount++ ;
                    ptstr = ptstrRoot + dwCurToken ;
                    ptstr->eType = OP_HALT ;
                    ptstr->dwValue = 0 ;  // undefined
                }
                else if(dwQueuePtr  &&
                    (*(pdwQueueRoot + dwQueuePtr - 1) == OP_OPENPAR))
                {
                    dwQueuePtr-- ;  // pop OP_OPENPAR off the Queue.
                    //  conjugate pairs meet and annihilate
                }
                else
                {
                    ERR(("Command parameter: syntax error in value construct - unmatched  OP_CLOSEPAR.\n"));
                    bStatus = FALSE ;
                }
                break ;
            }

            default:
                break ;
        }
        if(!bStatus  ||  tstrNode.eType == OP_HALT)
            break ;
    }
    if(!bStatus )
    {
        parRPNtokenStream->dwCount = 0 ;
        parRPNtokenStream->loOffset = 0 ;
    }
    return(bStatus);
}


VOID    VinitOperPrecedence(
    IN OUT PGLOBL pglobl)
{
    DWORD   dwP ;  // precedence level ;

    dwP = 0 ;  // lowest level.  fire wall.
    gdwOperPrecedence[OP_OPENPAR] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_CLOSEPAR] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_HALT] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_MIN] = gdwOperPrecedence[OP_MAX] =
        gdwOperPrecedence[OP_MAX_REPEAT] = dwP ;

    dwP++ ; //  comma must be next to function operators
    gdwOperPrecedence[OP_COMMA] = dwP ;   // in precedence level.

    dwP++ ;
    gdwOperPrecedence[OP_ADD] = gdwOperPrecedence[OP_SUB] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_MULT] = gdwOperPrecedence[OP_DIV] =
        gdwOperPrecedence[OP_MOD] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_NEG] = dwP ;
}

BOOL    BparseArithmeticToken(
IN  OUT PABSARRAYREF  paarValue,
OUT PTOKENSTREAM      ptstr,
    PGLOBL            pglobl
)
/*  objects to parse:
    OP_INTEGER : string of digits delimited by non-Keyword char
    OP_MIN :  "min" and adjacent '('
    OP_MAX :  "max" and adjacent '('
    OP_MAX_REPEAT :   "max_repeat"  and adjacent '('
    OP_MOD :  "MOD"
    OP_VARI_INDEX : string of Keyword chars deliniated by non Keyword
        chars, not starting with a digit.  and not one of the recognized
        operator keywords.
    Note all of the above string objects must be delinated by
        non-Keyword chars.
    OP_ADD :  '+'
    OP_SUB :  '-'
    OP_MULT : '*'
    OP_DIV :  '/'
    OP_HALT : '}'
    OP_OPENPAR :  '('
    OP_CLOSEPAR : ')'
    OP_COMMA :    ','
*/
{
    BYTE    ubSrc ;
    BOOL    bStatus ;

    if(!paarValue->dw)
        return(FALSE);  // nothing left!

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    switch(ubSrc = *paarValue->pub)
    {
        case '+':
        {
            ptstr->eType = OP_ADD ;
            break ;
        }
        case '-':
        {
            ptstr->eType = OP_SUB ;
            break ;
        }
        case '*':
        {
            ptstr->eType = OP_MULT ;
            break ;
        }
        case '/':
        {
            ptstr->eType = OP_DIV ;
            break ;
        }
        case '}':
        {
            ptstr->eType = OP_HALT ;
            break ;
        }
        case '(':
        {
            ptstr->eType = OP_OPENPAR ;
            break ;
        }
        case ')':
        {
            ptstr->eType = OP_CLOSEPAR ;
            break ;
        }
        case ',':
        {
            ptstr->eType = OP_COMMA ;
            break ;
        }
        default:
        {
            bStatus = FALSE ;  // till proven otherwise.

            if(ubSrc  >= '0' &&  ubSrc <= '9')
            {
                bStatus = BparseDigits(paarValue, ptstr) ;
            }
            else if( (ubSrc  >= 'a' &&  ubSrc <= 'z')  ||
                    (ubSrc  >= 'A' &&  ubSrc <= 'Z')  ||
                    ubSrc == '_'  ||  ubSrc == '?')
            {
                bStatus = BparseParamKeyword(paarValue, ptstr, pglobl) ;
            }

            return(bStatus);
        }
    }
    paarValue->pub++ ;
    paarValue->dw-- ;
    return(TRUE);
}



#define    pubM  (paarValue->pub)
#define    dwM   (paarValue->dw)

BOOL    BparseDigits(
IN  OUT PABSARRAYREF   paarValue,
OUT PTOKENSTREAM  ptstr )
/*  paarValue left pointing after last digit  upon exit.
    there may in fact be nothing left in paarValue  */
{
    DWORD   dwNumber  = 0 ;
    BOOL    bStatus = FALSE ;


    if(*pubM == '0')  //  leading zero indicates hexadecimal format
    {
        pubM++ ;
        dwM-- ;

        if(dwM  &&  (*pubM == 'x'  ||  *pubM == 'X'))
        {
            pubM++ ;
            dwM-- ;
        }
        else
        {
            bStatus = TRUE ;
            goto  EndNumber ;     // ignore leading zero and attempt to parse more digits.
        }
        if(!dwM)
        {
            ERR(("Command Param-BparseDigits: no digits found in Hex value.\n"));
            return(FALSE);
        }
        for(  ; dwM  ;  pubM++, dwM-- )
        {
            if(*pubM >= '0'  &&  *pubM <= '9')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - '0') ;
            }
            else if(*pubM >= 'a'  &&  *pubM <= 'f')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - 'a' + 0x0a) ;
            }
            else if(*pubM >= 'A'  &&  *pubM <= 'F')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - 'A' + 0x0a) ;
            }
            else
                break;

            bStatus = TRUE ;
        }
    }

EndNumber:

    for(  ; dwM  &&  *pubM >= '0'  &&  *pubM <= '9' ;  )
    {
        dwNumber *= 10 ;
        dwNumber += (*pubM - '0') ;
        pubM++ ;
        dwM-- ;
        bStatus = TRUE ;
    }
    if( dwM  &&  ((*pubM  >= 'a' &&  *pubM <= 'z')  ||
        (*pubM  >= 'A' &&  *pubM <= 'Z')  ||
        *pubM == '_'  ||  *pubM == '?'))
    {
        ERR(("Command parameter: syntax error in value construct.\n"));
        ERR(("  integer not clearly delimited using non Keyword characters.\n"));
        return(FALSE);
    }

    ptstr->eType = OP_INTEGER ;
    ptstr->dwValue = dwNumber ;
    return(bStatus);
}


BOOL    BparseParamKeyword(
IN  OUT PABSARRAYREF   paarValue,
OUT PTOKENSTREAM  ptstr,
    PGLOBL        pglobl )
/*  if the keyword happens to be a function operator,
    find and eat the opening '('.  If keyword is
    a Standard Variable, determine its index value
    and store in dwValue.
*/
{
    BOOL    bStatus = FALSE ;
    ABSARRAYREF aarKey ;


    aarKey.pub = pubM ;  // start of Keyword

    for(aarKey.dw = 0 ; dwM   ;  aarKey.dw++)
    {
        if( (*pubM  >= 'a' &&  *pubM <= 'z')  ||
            (*pubM  >= 'A' &&  *pubM <= 'Z')  ||
            (*pubM  >= '0' &&  *pubM <= '9')  ||
            *pubM == '_'  ||  *pubM == '?' )
        {
            pubM++ ;
            dwM-- ;
            bStatus = TRUE ;
        }
        else
            break ;
    }
    //  now identify this Keyword
    if(!bStatus)
        return(bStatus);

    if(BcmpAARtoStr(&aarKey, "min"))
    {
        ptstr->eType = OP_MIN ;
        bStatus = BeatDelimiter(paarValue, "(") ;
        if(!bStatus)
        {
            ERR(("Command parameter: '(' must follow 'min' operator.\n"));
        }
    }
    else if(BcmpAARtoStr(&aarKey, "max"))
    {
        ptstr->eType = OP_MAX  ;
        bStatus = BeatDelimiter(paarValue, "(") ;
        if(!bStatus)
        {
            ERR(("Command parameter: '(' must follow 'max' operator.\n"));
        }
    }
    else if(BcmpAARtoStr(&aarKey, "max_repeat"))
    {
        ptstr->eType = OP_MAX_REPEAT ;
        bStatus = BeatDelimiter(paarValue, "(") ;
        if(!bStatus)
        {
            ERR(("Command parameter: '(' must follow 'max_repeat' operator.\n"));
        }
    }
    else if(BcmpAARtoStr(&aarKey, "MOD"))
    {
        ptstr->eType = OP_MOD ;
        //  don't eat any delimiters
    }
    else  // must therefore be the name of a StandardValue
    {
        ptstr->eType = OP_VARI_INDEX ;
        bStatus = BparseConstant(&aarKey, &ptstr->dwValue,
            VALUE_CONSTANT_STANDARD_VARS, pglobl) ;
    }

    return(bStatus);
}

#undef    pubM
#undef    dwM


BOOL  BcmpAARtoStr(
PABSARRAYREF    paarStr1,
PBYTE       str2)
//  Compares two strings, one referenced by 'aar' the other
//  referenced by 'pub or str'.  Returns TRUE if they match, FALSE
//  otherwise.
{
    DWORD   dwCnt ;

    dwCnt = strlen(str2) ;
    if(dwCnt != paarStr1->dw)
        return(FALSE) ;  // Lengths don't even match!
    if(strncmp(paarStr1->pub, str2, dwCnt))
        return(FALSE) ;
    return(TRUE) ;
}



BOOL        bDivByZeroCheck(PTOKENSTREAM  ptstr)
{
    //  assumes ptstr is not pointing to start of tokenstream
    //  else  (ptstr - 1) is undefined.
    //  this assumption is valid because the syntax checking in
    //  BconstructRPNtokenStream  counts
    //  dwValueToken  ,  //  number of value tokens parsed.
    //      and  dwOperatorToken  and ensures that  dwValueToken
    //  is non-zero when OP_DIV is parsed.

    if (ptstr->eType == OP_DIV  &&  (ptstr - 1)->eType == OP_INTEGER  &&
        (ptstr - 1)->dwValue == 0)
    {
        ERR(("Command parameter: Explicit divide by zero detected.\n"));
        return(FALSE) ;
    }
    return(TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\gpdparse.h ===
/*++

  Copyright (c) 1996-1999  Microsoft Corporation


Module Name:

    gpdparse.h

Abstract:

    Header file for GPD parser

Environment:

    Windows NT Universal printer driver.

Revision History:

--*/

/*
    gpdparse.h - this holds structure definitions
    and other defines specific to the GPD parser
*/

#ifndef _GPDPARSE_H_
#define _GPDPARSE_H_

#include "lib.h"
#include "gpd.h"






#ifdef  GMACROS
#define     PRIVATE_PARSER_VERSION    0x0053
#else
#define     PRIVATE_PARSER_VERSION    0x0052
#endif

#define GPD_PARSER_VERSION      MAKELONG(PRIVATE_PARSER_VERSION, SHARED_PARSER_VERSION)


//  extra printrate units not defined in wingdi.h

#define   PRINTRATEUNIT_LPS     5
#define   PRINTRATEUNIT_IPS     6







// ----  General Section ---- //

typedef DWORD   DWFLAGS  ;


#define FIRST_NON_STANDARD_ID        257

#define  FOREVER  (1)

#define  BUD_FILENAME_EXT   TEXT(".BUD")
    //  "bud"  in unicode. GPD -> BUD.

//  a non-relocatable string reference, but unlike an ARRAYREF, can access
//  addresses outside of the memory buffer defined by the base reference
//  pointer used by an ARRAYREF.

//  note: for all arrayrefs containing Strings the dw field holds the number
//  of bytes which the string contains.  For Unicode strings this is TWICE
//  the number of Unicode characters.

#define LOCALE_KEYWORD  "Locale"

typedef struct
{
    PBYTE   pub ;
    DWORD   dw ;
} ABSARRAYREF ,  * PABSARRAYREF ;  //  assign this struct the type  'aar'

typedef  struct
{
    DWORD   loOffset ;
    DWORD   dwCount  ;
    DWORD   dwElementSiz ;
} ENHARRAYREF , * PENHARRAYREF ;  //  assign this struct the type  'ear'


// ----  End of General Section ---- //



// ---- Constant Classes  Section ---- //


typedef   enum
{
    //  -- Constant Classes -- //

    CL_BOOLEANTYPE,
    CL_PRINTERTYPE,
    CL_FEATURETYPE,
    CL_UITYPE,
    CL_PROMPTTIME,
    CL_PAPERFEED_ORIENT,
    CL_COLORPLANE,
    CL_SEQSECTION,
    CL_RASTERCAPS,
    CL_TEXTCAPS,
    CL_MEMORYUSAGE,
    CL_RESELECTFONT,
    CL_OEMPRINTINGCALLBACKS,
    CL_CURSORXAFTERCR,
    CL_BADCURSORMOVEINGRXMODE,
//    CL_SIMULATEXMOVE,
    CL_PALETTESCOPE,
    CL_OUTPUTDATAFORMAT,
    CL_STRIPBLANKS,
    CL_LANDSCAPEGRXROTATION,
    CL_CURSORXAFTERSENDBLOCKDATA,
    CL_CURSORYAFTERSENDBLOCKDATA,
    CL_CHARPOSITION,
    CL_FONTFORMAT,
    CL_QUERYDATATYPE,
    CL_YMOVEATTRIB,
    CL_DLSYMBOLSET,
    CL_CURXAFTER_RECTFILL,
    CL_CURYAFTER_RECTFILL,
    #ifndef WINNT_40
    CL_PRINTRATEUNIT,
    #endif
    CL_RASTERMODE,
    CL_QUALITYSETTING ,

    //  the following aren't true constant classes per se,
    //  but if the construct fits...


    CL_STANDARD_VARS, //  names of Unidrv Standard Variables
    CL_COMMAND_NAMES, //  Unidrv Command Names and index.

    CL_CONS_FEATURES, // reserved feature symbol names

    // reserved  option symbol names for these predefined features

    CL_CONS_PAPERSIZE,
    CL_CONS_MEDIATYPE,
    CL_CONS_INPUTSLOT,
    CL_CONS_DUPLEX,
    CL_CONS_ORIENTATION,
    CL_CONS_PAGEPROTECT,
    CL_CONS_COLLATE,
    CL_CONS_HALFTONE,

    CL_NUMCLASSES
}  CONSTANT_CLASSES ;  //  enumerate types of constant classes

typedef  struct   //  only used in static gConstantsTable.
{
    PBYTE   pubName ;
    DWORD   dwValue ;
}  CONSTANTDEF, * PCONSTANTDEF ;
//  this table associates ConstantNames with their defined values.
//  The table is divided into sections, one section per class.
//  the index table - gcieTable[] provides the index range
//  that each class occupies.  Note the similarity to the arrangement
//  of the MainKeywordTable.

extern  CONST CONSTANTDEF  gConstantsTable[] ;


typedef  struct
{
    DWORD   dwStart ;     //  index of first member of class
    DWORD   dwCount ;     //  number of members in this class.
} CLASSINDEXENTRY,  * PCLASSINDEXENTRY ;


// extern  CLASSINDEXENTRY  gcieTable[CL_NUMCLASSES] ;
// This is now in GLOBL structure.


// ---- End of Constant Classes  Section ---- //



// ---- MasterTable  Section ---- //

/*  The master table keeps track of all allocated memory buffers.
The buffers are typically used to store an array of structures.
The master table is an array of entries of the form:
*/

typedef  struct  _MASTER_TABLE_ENTRY
{
    PBYTE  pubStruct ;  // address of element zero of array
    DWORD  dwArraySize ;  // number of array elements requested
    DWORD   dwCurIndex ;  //  points to first uninitialized element
    DWORD   dwElementSiz ;  // size of each element in array.
    DWORD   dwMaxArraySize ;  //  This is the absolute max size
                        //  we allow this resource to grow.
}  MASTERTAB_ENTRY ;


//  the following Enums represent indicies in the master table
//  reserved for each of the following objects:

typedef enum
{
    MTI_STRINGHEAP,   //  Permanent heap for GPD strings and binary data.
    MTI_GLOBALATTRIB,   //   structure holding value of global attributes.
    MTI_COMMANDTABLE,   //  array of ATREEREF (or DWORD indicies to
                        //  COMMAND_ARRAY)
            // note:  the IDs used to index this table are the
            // Unidrv IDs.
    MTI_ATTRIBTREE, //  array of ATTRIB_TREE structures.
    MTI_COMMANDARRAY,   //  array of COMMAND structures.
            // size varies depending on number of commands and variants
            // defined in the GPD file.
    MTI_PARAMETER, //  parameters for command
    MTI_TOKENSTREAM,  //  contains value tokens to populate the value stack
                    //  and commands to operate on them. For command
                    //  parameters
    MTI_LISTNODES,  //   array of LISTNODEs.
    MTI_CONSTRAINTS,  //  array of CONSTRAINTS
    MTI_INVALIDCOMBO,  //  array of INVALIDCOMBO
    MTI_GPDFILEDATEINFO,   //  array of GPDFILEDATEINFO

    /*  buffers allocated on 2nd pass  */

    MTI_DFEATURE_OPTIONS, //  references a whole bunch of treeroots.
        //  should be initialized to ATTRIB_UNINITIALIZED values.
        //  SymbolID pointed to by dwFeatureSymbols contains largest
        //  array index appropriated.  We won't need to allocate
        //  more elements in the final array than this.
    MTI_SYNTHESIZED_FEATURES,  //  this holds synthesized
        // features.     an array of DFEATURE_OPTIONS
    MTI_PRIORITYARRAY,  //  array of feature indicies
    MTI_TTFONTSUBTABLE, //  array of arrayrefs and integers.
    MTI_FONTCART,   //   array of FontCartridge structures - one per
                //  construct.
    //  end of buffers allocated on 2nd pass

    //  gray area: do we need to save the following objects?
    MTI_SYMBOLROOT, //  index to root of symbol tree
    MTI_SYMBOLTREE, //  symbolTree Array

    MTI_NUM_SAVED_OBJECTS ,  // denotes end of list of objects to be saved
        //  to the GPD binary file.
    MTI_TMPHEAP = MTI_NUM_SAVED_OBJECTS ,
        //  store strings referenced in tokenmap.
    MTI_SOURCEBUFFER, //  Tracks Source file (GPD  input stream)
        //  gMasterTable[MTI_SOURCEBUFFER].dwCurIndex
        //  indexes the current SOURCEBUFFER.
    MTI_TOKENMAP, //  tokenMap   large enough to hold an old and New copy!
    MTI_NEWTOKENMAP, //  newtokenMap   (not a separate buffer from TOKENMAP -
        //  just points immediately after oldTokenMap).
    MTI_BLOCKMACROARRAY, // (one for Block and another for Value macros)
    MTI_VALUEMACROARRAY, //  an array of DWORDS holding a
                //  tokenindex where a valuemacro ID value is stored
    MTI_MACROLEVELSTACK,  //  is operated as a two dword stack that saves the
            //  values of curBlockMacroArray and curValueMacroArray ,
            //  each time a brace is encountered.
    MTI_STSENTRY,  // this is the StateStack
    MTI_OP_QUEUE,    // temp queue of operators (array of DWORDS)
    MTI_MAINKEYWORDTABLE,  //  the keyword dictionary!
    MTI_RNGDICTIONARY,   //   specifies the range of indicies in the
        // mainKeyword table which comprises the specified dictionary.
    MTI_FILENAMES,  // array of ptrs to buffers containing widestrings
                    // representing GPD filenames that were read in
                    // used for friendly error messages.
    MTI_PREPROCSTATE,  //  array of PPSTATESTACK structures
            //  which hold state of preprocessor.

    MTI_MAX_ENTRIES,    //  Last entry.

}  MT_INDICIES ;


// extern MASTERTAB_ENTRY   gMasterTable[MTI_MAX_ENTRIES] ;
// This is now in GLOBL structure.


// ---- End Of MasterTable  Section ---- //


// ---- SourceBuffer  Section ---- //

/*  array of structures to track the MemoryMapped src files.
multiple files may be open at the same time due to nesting
imposed by the *Include keyword.
The array of SOURCEBUFFERS is operated as a stack.
The  MasterTable[MTI_SOURCEBUFFER] field dwCurIndex
serves as the stack pointer.
*/

typedef  struct
{
    PBYTE  pubSrcBuf ;      //  start of file bytes.
    DWORD  dwCurIndex ;     //  stream ptr
    DWORD  dwArraySize ;    //  filesize
    DWORD   dwFileNameIndex ;  //  index into MTI_FILENAMES
    DWORD   dwLineNumber    ;  //  zero indexed
    HFILEMAP  hFile ;         //  used to access/close file.
} SOURCEBUFFER, * PSOURCEBUFFER ;
//  the tagname is 'sb'


//
//    define macros to access what were global variables but are now packed
//    in PGLOBL structure.
//

#define     gMasterTable            (pglobl->GMasterTable)
#define     gmrbd                   (pglobl->Gmrbd)
#define     gastAllowedTransitions  (pglobl->GastAllowedTransitions)
#define     gabAllowedAttributes    (pglobl->GabAllowedAttributes)
#define     gdwOperPrecedence       (pglobl->GdwOperPrecedence)
#define     gdwMasterTabIndex       (pglobl->GdwMasterTabIndex)
#define     geErrorSev              (pglobl->GeErrorSev)
#define     geErrorType             (pglobl->GeErrorType)
#define     gdwVerbosity            (pglobl->GdwVerbosity)
#define     gdwID_IgnoreBlock       (pglobl->GdwID_IgnoreBlock)
#define     gValueToSize            (pglobl->GValueToSize)
#define     gdwMemConfigKB          (pglobl->GdwMemConfigKB)
#define     gdwMemConfigMB          (pglobl->GdwMemConfigMB)
#define     gdwOptionConstruct      (pglobl->GdwOptionConstruct)
#define     gdwOpenBraceConstruct   (pglobl->GdwOpenBraceConstruct)
#define     gdwCloseBraceConstruct  (pglobl->GdwCloseBraceConstruct)
#define     gdwMemoryConfigMB       (pglobl->GdwMemoryConfigMB)
#define     gdwMemoryConfigKB       (pglobl->GdwMemoryConfigKB)
#define     gdwCommandConstruct     (pglobl->GdwCommandConstruct)
#define     gdwCommandCmd           (pglobl->GdwCommandCmd)
#define     gdwOptionName           (pglobl->GdwOptionName)
#define     gdwResDLL_ID            (pglobl->GdwResDLL_ID)
#define     gdwLastIndex            (pglobl->GdwLastIndex)
#define     gaarPPPrefix            (pglobl->GaarPPPrefix)
#define     gcieTable               (pglobl->GcieTable)



//    define  Local Macro to access info for current file:

#define     mCurFile   (gMasterTable[MTI_SOURCEBUFFER].dwCurIndex)
    //  which file are we currently accessing ?
#define     mMaxFiles   (gMasterTable[MTI_SOURCEBUFFER].dwArraySize)
    //  max number of files open at one time (nesting depth)

#define     mpSourcebuffer  ((PSOURCEBUFFER)(gMasterTable \
                            [MTI_SOURCEBUFFER].pubStruct))
    //  location of first SOURCEBUFFER element in array

#define    mpubSrcRef  (mpSourcebuffer[mCurFile - 1].pubSrcBuf)
        //  start of file bytes
#define    mdwSrcInd  (mpSourcebuffer[mCurFile - 1].dwCurIndex)
        //  current position in file bytes
#define    mdwSrcMax  (mpSourcebuffer[mCurFile - 1].dwArraySize)
        // filesize

// ---- End Of SourceBuffer  Section ---- //


//  -----  Preprocessor Section ---- //

    enum  IFSTATE  {IFS_ROOT, IFS_CONDITIONAL , IFS_LAST_CONDITIONAL } ;
        //  tracks correct syntatical use of #ifdef, #elseifdef, #else and #endif directives.
    enum  PERMSTATE  {PERM_ALLOW, PERM_DENY ,  PERM_LATCHED } ;
        //  tracks current state of preprocessing,
        //  PERM_ALLOW:  all statements in this section are passed to body gpdparser
        //  PERM_DENY:  statements in this section are discarded
        //  PERM_LATCHED:  all statements until the end of  this nesting level are discarded.
    enum  DIRECTIVE  {NOT_A_DIRECTIVE, DIRECTIVE_EOF, DIRECTIVE_DEFINE , DIRECTIVE_UNDEFINE ,
                       DIRECTIVE_INCLUDE , DIRECTIVE_SETPPPREFIX , DIRECTIVE_IFDEF ,
                       DIRECTIVE_ELSEIFDEF , DIRECTIVE_ELSE , DIRECTIVE_ENDIF } ;


typedef  struct
{
    enum  IFSTATE  ifState ;
    enum  PERMSTATE  permState ;
} PPSTATESTACK, * PPPSTATESTACK ;
//  the tagname is 'ppss'


#define     mppStack  ((PPPSTATESTACK)(gMasterTable \
                            [MTI_PREPROCSTATE].pubStruct))
    //  location of first SOURCEBUFFER element in array

#define     mdwNestingLevel   (gMasterTable[MTI_PREPROCSTATE].dwCurIndex)
    //  current preprocessor directive nesting level

#define     mMaxNestingLevel   (gMasterTable[MTI_PREPROCSTATE].dwArraySize)
    //  max preprocessor directive nesting depth


// ---- End Of Preprocessor  Section ---- //



// ----  Symbol Trees Section ---- //

/*  this structure is used to implement the symbol trees which
track all user defined symbol names  and associate with each name
a zero indexed integer.  */

typedef  struct
{
    ARRAYREF   arSymbolName;
    DWORD   dwSymbolID;    // has nothing to do with array of symbol structs.
            //  value begins at zero and is incremented to obtain
            //  next value.
    DWORD   dwNextSymbol;   // index to next element in this space.
    DWORD   dwSubSpaceIndex ;  // index to first element in new symbol space
            //  which exists within the catagory represented by this symbol.
            //  for example in the catagory represented by the
            //  symbol  PAPERSIZES:  we may have the subspace
            //  comprised of Letter, A4, Legal, etc.
}   SYMBOLNODE , * PSYMBOLNODE ;
//  assign this struct the type  'psn'



#define  INVALID_SYMBOLID  (0xffffffff)
    //  this value is returned instead of a valid SymbolID
    //  to indicate a failure condition - symbol not found, or
    //  unable to register symbol.
    //  Warning!  this value may be truncated to WORD to
    //  fit into a qualified name!
#define  INVALID_INDEX     (0xffffffff)
    //  used to denote the end of a chain of nodes.
    //  dwNextSymbol  may be assigned this value.


//  there is one symbol tree for each symbol class.
//  actually the options tree is a sublevel of the features
//  tree.   This enumeration is used to access the MTI_SYMBOLROOT
//  array.

typedef   enum
{
    SCL_FEATURES,  SCL_FONTCART, SCL_TTFONTNAMES,
    SCL_BLOCKMACRO,   SCL_VALUEMACRO,  SCL_OPTIONS,
    SCL_COMMANDNAMES,  SCL_PPDEFINES, SCL_NUMSYMCLASSES
}  SYMBOL_CLASSES ;

// ----  End of Symbol Trees Section ---- //


// ----  TokenMap Section ---- //


/*  the tokenMap contains an array entry for each logical statement
    in the GPD source file.  It identifies the token string
    representing the Keyword and its associated Value.
*/

typedef  struct _TOKENMAP
{
    DWORD  dwKeywordID ;  // index of entry in KeywordTable
    ABSARRAYREF  aarKeyword ; // points to keyword in the source file
    ABSARRAYREF  aarValue ;  // value associated with this keyword.
    DWORD   dwValue  ;  // interpretation of Value string - see flags.
         // maybe commandID, numerical value of constant, MacroID assigned
         // to MacroSymbol  ,  SymbolID  etc.
    DWORD   dwFileNameIndex ;  //  GPD filename
    DWORD   dwLineNumber    ;  //  zero indexed

    DWFLAGS    dwFlags ;  // bitfield with the following flags
        //  * TKMF_NOVALUE     no value was found
        //  TKMF_VALUE_SAVED     independently of the tokenmap.
        //  TKMF_COMMAND_SHORTCUT  only used when parsing commands.
        //  TKMF_INLINE_BLOCKMACROREF   need to know when resolving macros.
        //  *TKMF_COLON     additional token found in value - shortcut?
        //  *TKMF_MACROREF    indicates a value macro reference that must
        //                  be resolved
        //  TKMF_SYMBOLID  dwValue contains a symbolID.
        //  * TKMF_SYMBOL_KEYWORD   keyword is a symbol
        //  * TKMF_SYMBOL_REGISTERED  set when the symbolID is registered
        //          by ProcessSymbolKeyword  which also sets dwValue.
        //  * TKMF_EXTERN_GLOBAL  The extern Qualifier was prepended to the
        //  * TKMF_EXTERN_FEATURE    attribute keyword and has now been
        //                      truncated.
        //  *  indicates actually set by code.
        //  !  indicates actually read by code.

} TKMAP, *PTKMAP ;
//  assign this struct the type  'tkmap'


//  allowed flags for dwFlags  field:

#define     TKMF_NOVALUE                (0x00000001)
#define     TKMF_VALUE_SAVED            (0x00000002)
#define     TKMF_COMMAND_SHORTCUT       (0x00000004)
#define     TKMF_INLINE_BLOCKMACROREF   (0x00000008)
#define     TKMF_COLON                  (0x00000010)
#define     TKMF_MACROREF               (0x00000020)
#define     TKMF_SYMBOLID               (0x00000040)
#define     TKMF_SYMBOL_KEYWORD         (0x00000080)
#define     TKMF_SYMBOL_REGISTERED      (0x00000100)
#define     TKMF_EXTERN_GLOBAL          (0x00000200)
#define     TKMF_EXTERN_FEATURE         (0x00000400)


    // ---- special KeywordIDs for TokenMap ---- //
#define  ID_SPECIAL         0xff00      // larger than any KeywordTable index
#define  ID_NULLENTRY       (ID_SPECIAL + 0)
    //  ignore this, either expired code, parsing error etc.
#define  ID_UNRECOGNIZED    (ID_SPECIAL + 1)
    //  conforms to correct syntax, but not in my keyword table.
    //  could be a keyword defined in a newer spec or an attribute name
    //  or some other OEM defined stuff.
#define  ID_SYMBOL          (ID_SPECIAL + 2)
    //  this identifies a user-defined keyword like a fontname
    //  does not begin with * , but conforms to syntax for a symbol.
#define  ID_EOF             (ID_SPECIAL + 3)
    //  end of file - no more tokenMap entries


// ----  End of TokenMap Section ---- //


// ----  MainKeyword table Section ---- //

/*  the MainKeyword table contains static information that
describes each main keyword.  This table controls what action
the parser takes.  First define several enumerations used
in the table.  */

typedef  enum
{
    TY_CONSTRUCT, TY_ATTRIBUTE, TY_SPECIAL
}   KEYWORD_TYPE ;


typedef  enum
{
    ATT_GLOBAL_ONLY, ATT_GLOBAL_FREEFLOAT,
    ATT_LOCAL_FEATURE_ONLY,  ATT_LOCAL_FEATURE_FF ,
    ATT_LOCAL_OPTION_ONLY,  ATT_LOCAL_OPTION_FF ,
    ATT_LOCAL_COMMAND_ONLY,  ATT_LOCAL_FONTCART_ONLY,
    ATT_LOCAL_TTFONTSUBS_ONLY,  ATT_LOCAL_OEM_ONLY,
    ATT_LAST   // Must be last in list.
}   ATTRIBUTE ;  // subtype

typedef  enum
{
    CONSTRUCT_UIGROUP ,
    CONSTRUCT_FEATURE ,
    CONSTRUCT_OPTION ,
    CONSTRUCT_SWITCH,
    CONSTRUCT_CASE ,
    CONSTRUCT_DEFAULT ,
    CONSTRUCT_COMMAND ,
    CONSTRUCT_FONTCART ,
    CONSTRUCT_TTFONTSUBS ,
    CONSTRUCT_OEM ,
    CONSTRUCT_LAST,  // must end list of transition inducing constructs.
    // constructs below do not cause state transitions
    CONSTRUCT_BLOCKMACRO ,
    CONSTRUCT_MACROS,
    CONSTRUCT_OPENBRACE,
    CONSTRUCT_CLOSEBRACE,
    CONSTRUCT_PREPROCESSOR,
}  CONSTRUCT ;      //  SubType if Type = CONSTRUCT

typedef  enum
{
    SPEC_TTFS, SPEC_FONTSUB, SPEC_INVALID_COMBO,
    SPEC_COMMAND_SHORTCUT,
    SPEC_CONSTR, SPEC_INS_CONSTR,
    SPEC_NOT_INS_CONSTR, SPEC_INVALID_INS_COMBO,
    SPEC_MEM_CONFIG_KB, SPEC_MEM_CONFIG_MB,
    SPEC_INCLUDE, SPEC_INSERTBLOCK, SPEC_IGNOREBLOCK
}   SPECIAL ;



//  what value type does the parser expect after each keyword?

typedef  enum
{
    NO_VALUE ,  //  a linebreak OR  an effective linebreak:   ({)  or comment
        //  or optional value.
    VALUE_INTEGER,  //   integer
    VALUE_POINT,  //   point
    VALUE_RECT,  //   rectangle
    //  VALUE_BOOLEAN,  //   a subset of constants.
    VALUE_QUALIFIED_NAME,  //   Qualified name (two symbols separated by .
    VALUE_QUALIFIED_NAME_EX,  //    QualifiedName followed
                           //    by   an unsigned integer  with a  .  delimiter.
    VALUE_PARTIALLY_QUALIFIED_NAME ,  //  (just one symbol or two symbols
                        //  separated  by .)
    VALUE_CONSTRAINT,  //  list of qualified names but stored differently.
    VALUE_ORDERDEPENDENCY,
    VALUE_FONTSUB,   // "fontname" : <int>
//    VALUE_STRING,  //  Quoted String, hexstring, string MACROREF,
        //  parameterless invocation.
    VALUE_STRING_NO_CONVERT,  // string will not undergo unicode conversion
            // for example *GPDSpecVersion must remain an ascii string.
    VALUE_STRING_DEF_CONVERT,  //  string will be converted using the
                                //  system codepage  - filenames
    VALUE_STRING_CP_CONVERT,  // string will be converted using the
        // codepage specified by *CodePage

    VALUE_COMMAND_INVOC,  //   like VALUE_STRING but allowed to contain
        //  one or more parameter references.
    VALUE_COMMAND_SHORTCUT,  // Commandname:VALUE_COMMAND_INVOC
    VALUE_PARAMETER,  //  substring only containing a parameter reference.
    VALUE_SYMBOL_DEF,  //   * the value defines a symbol or value macro
        // { and } are not permitted.   Is this ever used ? yes

    VALUE_SYMBOL_FIRST,  //     base of user-defined symbol catagory
    VALUE_SYMBOL_FEATURES = VALUE_SYMBOL_FIRST + SCL_FEATURES ,  //
    VALUE_SYMBOL_FONTCART = VALUE_SYMBOL_FIRST + SCL_FONTCART ,  //
    VALUE_SYMBOL_TTFONTNAMES = VALUE_SYMBOL_FIRST + SCL_TTFONTNAMES ,  //
    VALUE_SYMBOL_BLOCKMACRO = VALUE_SYMBOL_FIRST + SCL_BLOCKMACRO ,  //
    VALUE_SYMBOL_VALUEMACRO = VALUE_SYMBOL_FIRST + SCL_VALUEMACRO ,  //
    VALUE_SYMBOL_OPTIONS = VALUE_SYMBOL_FIRST + SCL_OPTIONS ,  //
    //  SCL_COMMANDNAMES  intentionally omitted.
    VALUE_SYMBOL_LAST = VALUE_SYMBOL_FIRST + SCL_NUMSYMCLASSES - 1 ,  //

    VALUE_CONSTANT_FIRST,  //    base of enumeration catagory.
    VALUE_CONSTANT_BOOLEANTYPE = VALUE_CONSTANT_FIRST + CL_BOOLEANTYPE ,
    VALUE_CONSTANT_PRINTERTYPE = VALUE_CONSTANT_FIRST + CL_PRINTERTYPE ,
    VALUE_CONSTANT_FEATURETYPE = VALUE_CONSTANT_FIRST + CL_FEATURETYPE ,
    VALUE_CONSTANT_UITYPE = VALUE_CONSTANT_FIRST + CL_UITYPE ,
    VALUE_CONSTANT_PROMPTTIME = VALUE_CONSTANT_FIRST + CL_PROMPTTIME ,
    VALUE_CONSTANT_PAPERFEED_ORIENT = VALUE_CONSTANT_FIRST + CL_PAPERFEED_ORIENT ,
    VALUE_CONSTANT_COLORPLANE = VALUE_CONSTANT_FIRST + CL_COLORPLANE ,
    VALUE_CONSTANT_SEQSECTION = VALUE_CONSTANT_FIRST + CL_SEQSECTION ,

    VALUE_CONSTANT_RASTERCAPS = VALUE_CONSTANT_FIRST + CL_RASTERCAPS ,
    VALUE_CONSTANT_TEXTCAPS = VALUE_CONSTANT_FIRST + CL_TEXTCAPS ,
    VALUE_CONSTANT_MEMORYUSAGE = VALUE_CONSTANT_FIRST + CL_MEMORYUSAGE ,
    VALUE_CONSTANT_RESELECTFONT = VALUE_CONSTANT_FIRST + CL_RESELECTFONT ,
    VALUE_CONSTANT_OEMPRINTINGCALLBACKS = VALUE_CONSTANT_FIRST + CL_OEMPRINTINGCALLBACKS ,

    VALUE_CONSTANT_CURSORXAFTERCR = VALUE_CONSTANT_FIRST + CL_CURSORXAFTERCR ,
    VALUE_CONSTANT_BADCURSORMOVEINGRXMODE = VALUE_CONSTANT_FIRST + CL_BADCURSORMOVEINGRXMODE ,
//    VALUE_CONSTANT_SIMULATEXMOVE = VALUE_CONSTANT_FIRST + CL_SIMULATEXMOVE ,
    VALUE_CONSTANT_PALETTESCOPE = VALUE_CONSTANT_FIRST + CL_PALETTESCOPE ,
    VALUE_CONSTANT_OUTPUTDATAFORMAT = VALUE_CONSTANT_FIRST + CL_OUTPUTDATAFORMAT ,
    VALUE_CONSTANT_STRIPBLANKS = VALUE_CONSTANT_FIRST + CL_STRIPBLANKS ,
    VALUE_CONSTANT_LANDSCAPEGRXROTATION = VALUE_CONSTANT_FIRST + CL_LANDSCAPEGRXROTATION ,
    VALUE_CONSTANT_CURSORXAFTERSENDBLOCKDATA = VALUE_CONSTANT_FIRST + CL_CURSORXAFTERSENDBLOCKDATA ,
    VALUE_CONSTANT_CURSORYAFTERSENDBLOCKDATA = VALUE_CONSTANT_FIRST + CL_CURSORYAFTERSENDBLOCKDATA ,
    VALUE_CONSTANT_CHARPOSITION = VALUE_CONSTANT_FIRST + CL_CHARPOSITION ,
    VALUE_CONSTANT_FONTFORMAT = VALUE_CONSTANT_FIRST + CL_FONTFORMAT ,
    VALUE_CONSTANT_QUERYDATATYPE = VALUE_CONSTANT_FIRST + CL_QUERYDATATYPE ,
    VALUE_CONSTANT_YMOVEATTRIB = VALUE_CONSTANT_FIRST + CL_YMOVEATTRIB ,
    VALUE_CONSTANT_DLSYMBOLSET = VALUE_CONSTANT_FIRST + CL_DLSYMBOLSET ,
    VALUE_CONSTANT_CURXAFTER_RECTFILL = VALUE_CONSTANT_FIRST + CL_CURXAFTER_RECTFILL ,
    VALUE_CONSTANT_CURYAFTER_RECTFILL = VALUE_CONSTANT_FIRST + CL_CURYAFTER_RECTFILL ,
    #ifndef WINNT_40
    VALUE_CONSTANT_PRINTRATEUNIT = VALUE_CONSTANT_FIRST + CL_PRINTRATEUNIT ,
    #endif
    VALUE_CONSTANT_RASTERMODE = VALUE_CONSTANT_FIRST + CL_RASTERMODE,
    VALUE_CONSTANT_QUALITYSETTING = VALUE_CONSTANT_FIRST + CL_QUALITYSETTING,



    VALUE_CONSTANT_STANDARD_VARS = VALUE_CONSTANT_FIRST + CL_STANDARD_VARS ,
    VALUE_CONSTANT_COMMAND_NAMES = VALUE_CONSTANT_FIRST + CL_COMMAND_NAMES ,

    VALUE_CONSTANT_CONS_FEATURES = VALUE_CONSTANT_FIRST + CL_CONS_FEATURES ,
    VALUE_CONSTANT_CONS_PAPERSIZE = VALUE_CONSTANT_FIRST + CL_CONS_PAPERSIZE ,
    VALUE_CONSTANT_CONS_MEDIATYPE = VALUE_CONSTANT_FIRST + CL_CONS_MEDIATYPE ,
    VALUE_CONSTANT_CONS_INPUTSLOT = VALUE_CONSTANT_FIRST + CL_CONS_INPUTSLOT ,
    VALUE_CONSTANT_CONS_DUPLEX = VALUE_CONSTANT_FIRST + CL_CONS_DUPLEX ,
    VALUE_CONSTANT_CONS_ORIENTATION = VALUE_CONSTANT_FIRST + CL_CONS_ORIENTATION ,
    VALUE_CONSTANT_CONS_PAGEPROTECT = VALUE_CONSTANT_FIRST + CL_CONS_PAGEPROTECT ,
    VALUE_CONSTANT_CONS_COLLATE = VALUE_CONSTANT_FIRST + CL_CONS_COLLATE ,
    VALUE_CONSTANT_CONS_HALFTONE = VALUE_CONSTANT_FIRST + CL_CONS_HALFTONE ,

    VALUE_CONSTANT_LAST = VALUE_CONSTANT_FIRST + CL_NUMCLASSES - 1 ,

    VALUE_LIST,  //    no attribute actually is assigned this descriptor,
        // but used in the gValueToSize table.
    VALUE_LARGEST,  //   not a real descriptor, but this position in the
        //  gValueToSize table  holds the largest of the above values.
    VALUE_MAX, //  number of elements in gValueToSize table.
}  VALUE ;

//  --  allowed values for KEYWORDTABLE_ENTRY.flAgs:  --


#define   KWF_LIST  (0x00000001)
    //  the value may be a LIST containing one or more
    //  items of type AllowedValue.  The storage format
    //  must be of type LIST.  Only certain values may qualify
    //  for list format.
#define   KWF_ADDITIVE  (0x00000002)
    //  this flag implies KWF_LIST and also specifies the behavior
    //  that any redefinition of this keyword simply adds its items
    //  onto the existing list. (removal of redundant items is not
    //  performed.)
#define   KWF_MACROREF_ALLOWED  (0x00000004)
    //   since only a handful of keywords cannot accept
    //  macro references, it may be a waste of a flag, but reserve this
    //  to alert us that this special case must accounted for.
#define   KWF_SHORTCUT  (0x00000008)
    //    This keyword has multiple variants of syntax.

    //  one of the following 3 flags is set
    //  if the values in the nodes of the attribute tree
    //  refer to indicies of dedicated arrays, (which obviously
    //  contain data fields not ATREEREFs) AND
    //  gMainKeywordTable[].dwOffset  is an offset into
    //  this dedicated array, then set this flag.
    //  else dwOffset is used to select the treeroot.

#define   KWF_COMMAND       (0x00000010)
    //    This attribute is stored in a dedicated structure
#define   KWF_FONTCART      (0x00000020)
    //    This attribute is stored in a dedicated structure
#define   KWF_OEM           (0x00000040)
    //    This attribute is stored in a dedicated structure
#define   KWF_TTFONTSUBS    (0x00000080)
    //    This attribute is stored in a dedicated structure


#define   KWF_DEDICATED_FIELD   (KWF_COMMAND | KWF_FONTCART | \
            KWF_OEM | KWF_TTFONTSUBS)
    //  this flag is never set in the MainKeywordTable[].

#define   KWF_REQUIRED    (0x00000100)
    //  this keyword must appear in the GPD file

#ifdef  GMACROS
#define   KWF_CHAIN    (0x00000200)
    //  if more than one entry exists for a given treenode,
    //  subsequent entries are chained onto the first
    //  creating a parent list which holds in its values
    //  the actual inhabitants of the treenode.
#endif

//  The mainKeyword Table is an array of structures of the form:

typedef  struct
{
    PSTR        pstrKeyword ;  // keywordID is the index of this entry.
    DWORD       dwHashValue ;  // optional - implement as time permits.
    VALUE       eAllowedValue ;
    DWORD       flAgs ;
    KEYWORD_TYPE    eType;   // may replace Type/Subtype with a function
    DWORD       dwSubType ;  // if there is minimal code duplication.
    DWORD       dwOffset ;  //  into appropriate struct for attributes only.
    //  the size   (num bytes to copy) of an attribute is easily determined
    //   from the AllowedValue field.
} KEYWORDTABLE_ENTRY, * PKEYWORDTABLE_ENTRY;





// ----  End of MainKeyword table Section ---- //

// ----  MainKeyword Dictionary Section ---- //

/*  note the MainKeywordTable is subdivided into sections
with each section terminated by a NULL pstrKeyword.
this enumerates the sections.  The MTI_RNGDICTIONARY
provides the starting and ending indicies of the
the Keyword entries which each section spans.  */

typedef  enum {NON_ATTR, GLOBAL_ATTR, FEATURE_ATTR,
OPTION_ATTR, COMMAND_ATTR, FONTCART_ATTR, TTFONTSUBS_ATTR,
OEM_ATTR , END_ATTR
} KEYWORD_SECTS ;


typedef  struct
{
    DWORD  dwStart  ;  // index of first keyword in this section
    DWORD  dwEnd    ;
}  RANGE,  *PRANGE  ;   // tag shall be rng

// ----  End of MainKeyword Dictionary Section ---- //


// ----  Attribute Trees Section ---- //

/*  an Attribute Tree is comprised of a set of ATTRIB_TREE
    nodes linked together.  The root of the tree (the first node)
    may be a global default initializer.  */

typedef  enum
{
    NEXT_FEATURE,  // offset field contain index to another node
    VALUE_AT_HEAP,          //  offset is a heap offset
    UNINITIALIZED   //  offset has no meaning yet. (a transient state)
} ATTOFFMEANS ;

#define  DEFAULT_INIT  (0xffffffff)
    //  Warning!  this value may be truncated to WORD to
    //  fit into a qualified name!
//  #define  END_OF_LIST   (0xffffffff)
//  moved to gpd.h
    // may used where a node index is expected

typedef  struct
{
    DWORD   dwFeature ;  //  may also be set to DEFAULT_INIT
    DWORD   dwOption  ;  //  DEFAULT_INIT indicates this if set
    DWORD   dwNext    ;  // index to another node or END_OF_LIST
    DWORD   dwOffset  ;  // either offset in heap to value
                        //  or index to node containing another feature.
    ATTOFFMEANS  eOffsetMeans ;
}  ATTRIB_TREE,  * PATTRIB_TREE ;
//  the prefix tag shall be 'att'




//  these flags are used with ATREEREFS, this complication exists
//    because of the overloading of ATREEREFS.

#define  ATTRIB_HEAP_VALUE     (0x80000000)
    //  high bit set to indicate this value is an offset into
    //  the heap.
#define  ATTRIB_UNINITIALIZED  (ATTRIB_HEAP_VALUE - 1)
    //  this value indicates no memory location has been allocated
    //  to hold the value for this attribute.


typedef  DWORD  ATREEREF ;  //  hold the index to attribute array
//  that is the root of an attribute tree or if high bit is set
//  is an offset to the heap where the actual value lies.
//
//  the prefix tag shall be 'atr'
typedef  PDWORD  PATREEREF ;


// ----  End of Attribute Trees Section ---- //


// ----  UI Constraints Section ---- //

// slightly different from that defined in parser.h

typedef struct
{
    DWORD   dwNextCnstrnt ;
    DWORD   dwFeature ;
    DWORD   dwOption ;
}
CONSTRAINTS, *  PCONSTRAINTS ;
//  the prefix tag shall be 'cnstr'


// ----  End of UI Constraints Section ---- //

// ----  InvalidCombo Section ---- //
//  R.I.P. - moved to parser.h
//  typedef  struct
//  {
//      DWORD   dwFeature ;     //  the INVALIDCOMBO construct defines
//      DWORD   dwOption ;      //  a set of elements subject to the constraint
//      DWORD   dwNextElement ;  // that all elements of the set  cannot be
//      DWORD   dwNewCombo ;     // selected at the same time.
//  }
//  INVALIDCOMBO , * PINVALIDCOMBO ;
//  the prefix tag shall be 'invc'

//  Note:  both dwNextElement and dwNewCombo are terminated by END_OF_LIST.

// ----  End of InvalidCombo Section ---- //


// store timestamp of GPD files and included files here.

typedef struct _GPDFILEDATEINFO {

    ARRAYREF        arFileName;
    FILETIME        FileTime;

} GPDFILEDATEINFO, *PGPDFILEDATEINFO;


// ----  State Machine Section ---- //

/*  the state machine is used to define different parsing contexts
introduced by the construct keywords.  Each state recognizes a different
set of Construct and Attribute Keywords.  The 2 dimensional matricies
AllowedTransitions and AllowedAttributes define these.  The states
are nested, so a stack is a good way to track the complete state
of the system.  Each state is introduced by a construct keyword
with its optional symbol value which is stored in the stack for
subsequent use.   */

typedef  enum
{
    STATE_ROOT,
    STATE_UIGROUP,
    STATE_FEATURE,
    STATE_OPTIONS,
    STATE_SWITCH_ROOT,
    STATE_SWITCH_FEATURE,
    STATE_SWITCH_OPTION,
    STATE_CASE_ROOT,
    STATE_DEFAULT_ROOT,
    STATE_CASE_FEATURE,
    STATE_DEFAULT_FEATURE,
    STATE_CASE_OPTION,
    STATE_DEFAULT_OPTION,
    STATE_COMMAND,
    STATE_FONTCART,
    STATE_TTFONTSUBS,
    STATE_OEM,
    //  any other passive construct
    STATE_LAST,   //  must terminate list of valid states
    STATE_INVALID  //  must be after STATE_LAST
} STATE, * PSTATE ;   //  the prefix tag shall be 'st'


extern  CONST PBYTE   gpubStateNames[] ;

//  note if STATE enum changes, update the global gpubStateNames[]


typedef  struct
{
    STATE   stState ;
    DWORD   dwSymbolID ;
}  STSENTRY , * PSTSENTRY; //  StateStackEntry  the prefix tag shall be 'sts'


//  The AllowedTransitions Table determines/defines
//  the state changes produced by each construct keyword
//  Each entry in the table is a NewState and is indexed
//  by the OldState and a ConstructKeyword

// extern  STATE   gastAllowedTransitions[STATE_LAST][CONSTRUCT_LAST] ;
// This is now in GLOBL structure

//  the AllowedAttributes table defines which attributes are
//  allowed in each state.

//  extern  BOOL   gabAllowedAttributes[STATE_LAST][ATT_LAST] ;
// This is now in GLOBL structure


//  state of token parser (not to be confused with
//  state machine defined above.)
typedef   enum
{
    PARST_EXIT, PARST_EOF,  PARST_KEYWORD, PARST_COLON,
    PARST_VALUE,  PARST_INCLUDEFILE, PARST_ABORT
}  PARSTATE  ;  //  tag shall be  'parst'



// ----  End of State Machine Section ---- //


// ----  Value Structures Section ---- //

/*  the values from the attribute keywords are stored
in various structures.   Typically there is one type of
structure for each construct  and one instance of
a structure for each unique Symbol name.  The SymbolID
is normally used to index the instance of the structure
within the array of structures.   */





#if TODEL
typedef  struct
{
    ARRAYREF    arTTFontName ;
    ARRAYREF    arDevFontName ;
} TTFONTSUBTABLE, *PTTFONTSUBTABLE ;
//  tag  'ttft'


//
// Data structure used to represent the format of loOffset when indicating resource Ids
//

typedef  struct
{
    WORD    wResourceID ;   // ResourceID
    BYTE    bFeatureID ;    // Feature index for the resource DLL feature.
                            // If zero, we will use the name specified
                            // in ResourceDLL
    BYTE    bOptionID ;     // Option index for the qualified resource dll name.
}  QUALNAMEEX, * PQUALNAMEEX  ;



typedef  struct
{
    DWORD   dwRCCartNameID ;
    ARRAYREF   strCartName ;
    DWORD   dwFontLst ;  // Index to list of FontIDs
    DWORD   dwPortFontLst ;
    DWORD   dwLandFontLst ;
} FONTCART , * PFONTCART ;  // the prefix tag shall be  'fc'
#endif




typedef  struct   // for ease of processing shall contain only ATREEREFs
{
    ATREEREF     atrGPDSpecVersion ;    // "GPDSpecVersion"
    ATREEREF     atrMasterUnits ;       // "MasterUnits"
    ATREEREF     atrModelName ;         // "ModelName"
    ATREEREF     atrModelNameID ;         // "rcModelNameID"
    ATREEREF     atrGPDFileVersion ;         // "GPDFileVersion"
    ATREEREF     atrGPDFileName ;         // "GPDFileName"
    ATREEREF     atrOEMCustomData ;         // "OEMCustomData"

    //  next four fields used by Synthesized Features
    ATREEREF     atrNameInstalled ;         // "OptionNameInstalled"
    ATREEREF     atrNameIDInstalled ;         // "rcOptionNameInstalledID"

    ATREEREF     atrNameNotInstalled ;         // "OptionNameNotInstalled"
    ATREEREF     atrNameIDNotInstalled ;         // "rcOptionNameNotInstalledID"

    //   support for common UI macro controls

    ATREEREF     atrDraftQualitySettings;          // "DraftQualitySettings"
    ATREEREF     atrBetterQualitySettings;          // "BetterQualitySettings"
    ATREEREF     atrBestQualitySettings;          // "BestQualitySettings"
    ATREEREF     atrDefaultQuality ;                  //  "DefaultQuality"


    ATREEREF     atrPrinterType ;       // "PrinterType"
    ATREEREF     atrPersonality ;       // "Personality"
    ATREEREF     atrRcPersonalityID ;       // "rcPersonalityID"
//    ATREEREF     atrIncludeFiles;      // "Include"
    ATREEREF     atrResourceDLL;       // "ResourceDLL"
    ATREEREF     atrCodePage;           //   "CodePage"
    ATREEREF     atrMaxCopies;            // "MaxCopies"
    ATREEREF     atrFontCartSlots;        // "FontCartSlots"
    ATREEREF     atrPrinterIcon;       // "rcPrinterIconID"
    ATREEREF     atrHelpFile;       // "HelpFile"

    //  obsolete?
    ATREEREF     atrOutputDataFormat;     // "OutputDataFormat"
    ATREEREF     atrMaxPrintableArea;     // "MaxPrintableArea"

    //
    // Printer Capabilities related information
    //

    ATREEREF     atrRotateCoordinate;       // "RotateCoordinate?"
    ATREEREF     atrRasterCaps;       // "RasterCaps"
    ATREEREF     atrRotateRasterData;       // "RotateRaster?"
    ATREEREF     atrTextCaps;       // "TextCaps"
    ATREEREF     atrRotateFont;       // "RotateFont?"
    ATREEREF     atrMemoryUsage;       // "MemoryUsage"
    ATREEREF     atrReselectFont;       // "ReselectFont"
    ATREEREF     atrPrintRate;       // "PrintRate"
    ATREEREF     atrPrintRateUnit;       // "PrintRateUnit"
    ATREEREF     atrPrintRatePPM;       // "PrintRatePPM"
    ATREEREF     atrOutputOrderReversed;  //   "OutputOrderReversed?"
             // may change per snapshot.
    ATREEREF     atrReverseBandOrderForEvenPages;  //   "ReverseBandOrderForEvenPages?"
    ATREEREF     atrOEMPrintingCallbacks;       // "OEMPrintingCallbacks"
//    ATREEREF     atrDisabledFeatures ;  // "*DisabledFeatures"


    //
    // Cursor Control related information
    //

    ATREEREF     atrCursorXAfterCR;       // "CursorXAfterCR"
    ATREEREF     atrBadCursorMoveInGrxMode; // "BadCursorMoveInGrxMode"
    ATREEREF     atrSimulateXMove;        // "SimulateXMove"
    ATREEREF     atrEjectPageWithFF;       // "EjectPageWithFF?"
    ATREEREF     atrLookaheadRegion;       // "LookaheadRegion"
    ATREEREF     atrYMoveAttributes ;       // "YMoveAttributes"
    ATREEREF     atrMaxLineSpacing ;       // "MaxLineSpacing"
    ATREEREF     atrbUseSpaceForXMove ;     // "UseSpaceForXMove?"
    ATREEREF     atrbAbsXMovesRightOnly ;     // "AbsXMovesRightOnly?"


    ATREEREF     atrXMoveThreshold;        // "XMoveThreshold"
    ATREEREF     atrYMoveThreshold;        // "YMoveThreshold"
    ATREEREF     atrXMoveUnits;        // "XMoveUnits"
    ATREEREF     atrYMoveUnits;        // "YMoveUnits"
    ATREEREF     atrLineSpacingMoveUnit;        // "LineSpacingMoveUnit"

    //
    // Color related information
    //

    ATREEREF     atrChangeColorMode;       // "ChangeColorModeOnPage?"
    ATREEREF     atrChangeColorModeDoc;       // "ChangeColorModeOnDoc?"
    ATREEREF     atrMagentaInCyanDye;       // "MagentaInCyanDye"
    ATREEREF     atrYellowInCyanDye;       // "YellowInCyanDye"
    ATREEREF     atrCyanInMagentaDye;       // "CyanInMagentaDye"
    ATREEREF     atrYellowInMagentaDye;       // "YellowInMagentaDye"
    ATREEREF     atrCyanInYellowDye;       // "CyanInYellowDye"
    ATREEREF     atrMagentaInYellowDye;       // "MagentaInYellowDye"
    ATREEREF     atrUseColorSelectCmd;     // "UseExpColorSelectCmd?"
    ATREEREF     atrMoveToX0BeforeColor;   // "MoveToX0BeforeSetColor?"
    ATREEREF     atrEnableGDIColorMapping;   // "EnableGDIColorMapping?"


    // obsolete fields
    ATREEREF     atrMaxNumPalettes;        // "MaxNumPalettes"
//    ATREEREF     atrPaletteSizes;           // "PaletteSizes"
//    ATREEREF     atrPaletteScope;           // "PaletteScope"

    //
    // Overlay related information
    //

    ATREEREF     atrMinOverlayID;          // "MinOverlayID"
    ATREEREF     atrMaxOverlayID;          // "MaxOverlayID"

    //
    // Raster data related information
    //

    ATREEREF     atrOptimizeLeftBound;  //   "OptimizeLeftBound?"
    ATREEREF     atrStripBlanks;  //   "StripBlanks"
    ATREEREF     atrLandscapeGrxRotation;  //   "LandscapeGrxRotation"
    ATREEREF     atrRasterZeroFill;  //   "RasterZeroFill?"
    ATREEREF     atrRasterSendAllData;  //   "RasterSendAllData?"
    ATREEREF     atrSendMultipleRows;  //   "SendMultipleRows?"
    ATREEREF     atrMaxMultipleRowBytes;  //   "MaxMultipleRowBytes"
    ATREEREF     atrCursorXAfterSendBlockData;  //   "CursorXAfterSendBlockData"
    ATREEREF     atrCursorYAfterSendBlockData;  //   "CursorYAfterSendBlockData"
    ATREEREF     atrMirrorRasterByte;  //   "MirrorRasterByte?"
    ATREEREF     atrMirrorRasterPage;  //   "MirrorRasterPage?"

    //
    // Device Font related information
    //

    ATREEREF     atrDeviceFontsList ;   //  "DeviceFonts"
    ATREEREF     atrDefaultFont;  //   "DefaultFont"
    ATREEREF     atrTTFSEnabled ;  //   "TTFSEnabled?"
    ATREEREF     atrRestoreDefaultFont;  //   "RestoreDefaultFont?"
    ATREEREF     atrDefaultCTT;  //   "DefaultCTT"
    ATREEREF     atrMaxFontUsePerPage;  //   "MaxFontUsePerPage"
    ATREEREF     atrTextYOffset;  //   "TextYOffset"
    ATREEREF     atrCharPosition;  //   "CharPosition"
    ATREEREF     atrDiffFontsPerByteMode;  //   "DiffFontsPerByteMode?"

    //
    // Font Downloading related information
    //

    ATREEREF     atrMinFontID;  //   "MinFontID"
    ATREEREF     atrMaxFontID;  //   "MaxFontID"
    ATREEREF     atrMaxNumDownFonts;  //   "MaxNumDownFonts"
    ATREEREF     atrMinGlyphID;  //   "MinGlyphID"
    ATREEREF     atrMaxGlyphID;  //   "MaxGlyphID"
    ATREEREF     atrDLSymbolSet;  //   "DLSymbolSet"
    ATREEREF     atrIncrementalDownload;  //   "IncrementalDownload?"
    ATREEREF     atrFontFormat;  //   "FontFormat"
    ATREEREF     atrMemoryForFontsOnly;  //   "MemoryForFontsOnly?"

    //
    //  Rect Fill related information
    //

    ATREEREF     atrCursorXAfterRectFill;  //   "CursorXAfterRectFill"
    ATREEREF     atrCursorYAfterRectFill;  //   "CursorYAfterRectFill"
    ATREEREF     atrMinGrayFill;  //   "MinGrayFill"
    ATREEREF     atrMaxGrayFill;  //   "MaxGrayFill"
    ATREEREF     atrTextHalftoneThreshold;  //   "TextHalftoneThreshold"


    //  Internal Parser Use Only

    ATREEREF     atrInvldInstallCombo ;  //  holds all InvalidCombos
        // involving synthesized features.
    ATREEREF     atrLetterSizeExists ;
    ATREEREF     atrA4SizeExists ;

//    ATREEREF     atr;  //   ""  prototype

}  GLOBALATTRIB, * PGLOBALATTRIB ;  // the prefix tag shall be 'ga'


//  warning:  any non-attribtreeref added to
//  the GLOBALATTRIB structure will get stomped on in strange
//  ways by BinitPreAllocatedObjects.


//  note:  some fields in the snapshot won't be initialized.
//  they include orderdependencies and constraints.  The
//  helper functions will do all the grovelling.

//  there are two classes of fields in the FeatureOption structure,
//  those initialized by a corresponding field in the GPD file
//  and those the parser initializes at postprocessing time.
//  These fields have no associated GPD keyword.

//  For the fields that are keyword initialized, note also
//  the keyword may be a Feature attribute only, an Option attribute
//  only or both a Feature and Option attribute.

typedef  struct
{
    // -- Feature Level -- //

    ATREEREF     atrFeatureType;  //   "FeatureType"
    ATREEREF     atrUIType;  //   "UIType"  PickMany or PickOne?
    ATREEREF     atrDefaultOption;  //   "DefaultOption"
    ATREEREF     atrPriority ;
    ATREEREF     atrFeaInstallable;  //   "Installable?"
    ATREEREF     atrInstallableFeaDisplayName;   //  "InstallableFeatureName"
    ATREEREF     atrInstallableFeaRcNameID; //  "rcInstallableFeatureNameID"
    //  above 3 fields not used by snapshot.

    ATREEREF     atrFeaKeyWord ;   // symbol name
    ATREEREF     atrFeaDisplayName ;   //  "Name"
    ATREEREF     atrFeaRcNameID;  //   "rcNameID"
    ATREEREF     atrFeaRcIconID;  //   "rcIconID"
    ATREEREF     atrFeaRcHelpTextID;  //   "rcHelpTextID"
    ATREEREF     atrFeaRcPromptMsgID;  //   "rcPromptMsgID"
    ATREEREF     atrFeaRcPromptTime;  //   "rcPromptTime"
    ATREEREF     atrConcealFromUI; //   "ConcealFromUI?"
    ATREEREF     atrUpdateQualityMacro; //   "UpdateQualityMacro?"
    ATREEREF     atrFeaHelpIndex;  //   "HelpIndex"

    // Bi-Di Query related information

    ATREEREF     atrQueryOptionList;  //   "QueryOptionList"
    ATREEREF     atrQueryDataType;  //   "QueryDataType"
    ATREEREF     atrQueryDefaultOption;  //   "QueryDefaultOption"

    // scaffolding until Installable Features are synthesized.
//    ATREEREF     atrFeaInvldInstallCombo ;  //  // referenced from
                        //  "InvalidInstallableCombination"
    ATREEREF     atrFeaInstallConstraints ; //  "InstalledConstraints"
    ATREEREF     atrFeaNotInstallConstraints ;  // "NotInstalledConstraints"



    // -- Option Level -- //

    ATREEREF     atrOptInstallable;  //   "Installable?"
    ATREEREF     atrInstallableOptDisplayName ;   //  "InstallableFeatureName"
    ATREEREF     atrInstallableOptRcNameID; //  "rcInstallableFeatureNameID"
    //  above 3 fields not used by snapshot.

    ATREEREF     atrOptKeyWord ;   // symbol name
    ATREEREF     atrOptDisplayName ;   //  "Name"
    ATREEREF     atrOptRcNameID;  //   "rcNameID"
    ATREEREF     atrOptRcIconID;  //   "rcIconID"
    ATREEREF     atrOptRcHelpTextID;  //   "rcHelpTextID"
    ATREEREF     atrOptHelpIndex;  //   "HelpIndex"
    ATREEREF     atrOptRcPromptMsgID;  //   "rcPromptMsgID"
    ATREEREF     atrOptRcPromptTime;  //   "rcPromptTime"
    ATREEREF     atrCommandIndex ;
    //  these 2 fields are the only permanent types of constraints
    ATREEREF     atrConstraints ;
    ATREEREF     atrInvalidCombos ; // referenced from "InvalidCombination"
    //  all of these serve as scaffolding till the Installable
    //  features are synthesized!
//    ATREEREF     atrOptInvldInstallCombo ;  //  // referenced from
                        //  "InvalidInstallableCombination"
    ATREEREF     atrOptInstallConstraints ; //  "InstalledConstraints"
    ATREEREF     atrOptNotInstallConstraints ; //  "NotInstalledConstraints"
    ATREEREF     atrDisabledFeatures ;  // "*DisabledFeatures"

#ifdef  GMACROS

    ATREEREF     atrDependentSettings ;  // "*DependentSettings"
    ATREEREF     atrUIChangeTriggersMacro ;  // "*UIChangeTriggersMacro"

#endif

    //  -- Option specific fields -- //
    //  -- PaperSize option specific fields -- //

    ATREEREF     atrPrintableSize;  //   "PrintableSize"
    ATREEREF     atrPrintableOrigin;  //   "PrintableOrigin"
    ATREEREF     atrCursorOrigin;  //   "CursorOrigin"
    ATREEREF     atrVectorOffset;  //   "VectorOffset"
    ATREEREF     atrMinSize;  //   "MinSize"
    ATREEREF     atrMaxSize;  //   "MaxSize"
    ATREEREF     atrTopMargin;         // "TopMargin"
    ATREEREF     atrBottomMargin;         // "BottomMargin"
    ATREEREF     atrMaxPrintableWidth;     // "MaxPrintableWidth"
    ATREEREF     atrMinLeftMargin;         // "MinLeftMargin"
    ATREEREF     atrCenterPrintable;       // "CenterPrintable?"
    ATREEREF     atrPageDimensions;  //   "PageDimensions"
    ATREEREF     atrRotateSize;  //   "RotateSize?"
    ATREEREF     atrPortRotationAngle;  //   "PortRotationAngle"
    ATREEREF     atrPageProtectMem;  //   "PageProtectMem"

    ATREEREF     atrCustCursorOriginX ;  //  "CustCursorOriginX"
    ATREEREF     atrCustCursorOriginY ;  //  "CustCursorOriginY"
    ATREEREF     atrCustPrintableOriginX ;  //  "CustPrintableOriginX"
    ATREEREF     atrCustPrintableOriginY ;  //  "CustPrintableOriginY"
    ATREEREF     atrCustPrintableSizeX;  //   "CustPrintableSizeX"
    ATREEREF     atrCustPrintableSizeY;  //   "CustPrintableSizeY"


    //  -- InputBin option specific fields -- //

    ATREEREF     atrFeedMargins;  //   "FeedMargins"
    ATREEREF     atrPaperFeed;  //   "PaperFeed"

    //  -- OutputBin option specific fields -- //


    //  -- Resolution option specific fields -- //

    ATREEREF     atrDPI;  //   "DPI"
    ATREEREF     atrSpotDiameter;  //   "SpotDiameter"
    ATREEREF     atrTextDPI;  //   "TextDPI"
    ATREEREF     atrPinsPerPhysPass;  //   "PinsPerPhysPass"
    ATREEREF     atrPinsPerLogPass;  //   "PinsPerLogPass"
    ATREEREF     atrRequireUniDir;  //   "RequireUniDir?"
    ATREEREF     atrMinStripBlankPixels;  //   "MinStripBlankPixels"
    ATREEREF     atrRedDeviceGamma ;   // "RedDeviceGamma"
    ATREEREF     atrGreenDeviceGamma ;   // "GreenDeviceGamma"
    ATREEREF     atrBlueDeviceGamma ;   // "BlueDeviceGamma"

    //  -- ColorMode option specific fields -- //

    ATREEREF     atrColor;  //   "Color?"
    ATREEREF     atrDevNumOfPlanes;  //   "DevNumOfPlanes"
    ATREEREF     atrDevBPP;  //   "DevBPP"
    ATREEREF     atrColorPlaneOrder;  //   "ColorPlaneOrder"
    ATREEREF     atrDrvBPP;  //   "DrvBPP"
    ATREEREF     atrIPCallbackID;  //   "IPCallbackID"
    ATREEREF     atrColorSeparation;  //   "ColorSeparation?"

    ATREEREF     atrRasterMode;  //   "RasterMode"
    ATREEREF     atrPaletteSize;  //   "PaletteSize"
    ATREEREF     atrPaletteProgrammable;  //   "PaletteProgrammable?"

    //  -- Memory option specific fields -- //

    ATREEREF     atrMemoryConfigKB;  //   "MemoryConfigKB"
    ATREEREF     atrMemoryConfigMB;  //   "MemoryConfigMB"

    //  -- Halftone option specific fields -- //

    ATREEREF     atrRcHTPatternID;  //   "rcHTPatternID"
    ATREEREF     atrHTPatternSize;  //   "HTPatternSize"
    ATREEREF     atrHTNumPatterns;  //   "HTNumPatterns"
    ATREEREF     atrHTCallbackID;  //   "HTCallbackID"
    ATREEREF     atrLuminance;  //   "Luminance"

    //  --  OUTPUTBIN  option specific fields -- //

    ATREEREF     atrOutputOrderReversed ;  //  *OutputOrderReversed? (option level)

    //  -- fields synthesized at Post Processing time --  //

//    ATREEREF     atrGIDvalue;  //   GID value
    ATREEREF     atrOptIDvalue;  //   ID value

    ATREEREF     atrFeaFlags ;  //  invalid or not

    //  If this option is installable, this points to the index of the
    //  resulting synthesized feature.
    ATREEREF     atrOptionSpawnsFeature ;  // must support an attrib tree.


    //  warning:  any non-attribtreeref added to
    //  the DFEATURE_OPTIONS structure will get stomped on in strange
    //  and wonderful ways by BinitPreAllocatedObjects.

    //  if this is a synthesized feature:
    DWORD       dwInstallableFeatureIndex ; //  backlink to Feature/Option
    DWORD       dwInstallableOptionIndex ;  //  that prompted this feature.

    //  If this feature is installable, this points to the index of the
    //  resulting synthesized feature.
    DWORD       dwFeatureSpawnsFeature ;




    //  internal consistency checks.
    BOOL        bReferenced ;  // default is FALSE.
    DWORD       dwGID ,  //  GID tag
        dwNumOptions ;  // these are not read in from GPD file.

}DFEATURE_OPTIONS, * PDFEATURE_OPTIONS ;    //  the prefix tag shall be 'fo'


//  R.I.P. - moved to gpd.h
//  typedef  struct
//  {
//      SEQSECTION     eSection;    // Specifies the section
//      DWORD          dwOrder   ;  // order within each section.
//  }  ORDERDEPENDENCY  , * PORDERDEPENDENCY  ;
//  assign this struct the type  'ord'

// ----  End of Value Structures Section ---- //


// ---- Header  Section ---- //


typedef   struct
{
    PSTR        pstrKeyword ;  // keyword associated with this entry
    VALUE       dwDefaultValue ;  //  One DWORD that will be copied
                            // to the destination if nothing is found
                            // in the attribute tree.  If the field
                            //  requires more than one DWORD, this
                            //  value is repeatedly copied.
                            //
                            //  if the value being copied is actually
                            //  a bit flag, this member shall contain
                            //  the value of the bit flag to be set.
                            //  Setting the flag shall be accomplished by
                            //  OR-ing this value into the destination.

    DWORD       dwNbytes  ;  //  # bytes occupied by value or link
    DWORD       dwSrcOffset ;   //  location of ATREEREF
    DWORD       dwDestOffset ;   //  offset in snapshot (dest) Structure to
                                //  copy link to object or object itself.
    DWORD       dwFlags ;         //  is this a dedicated structure?
                                //  ideally to ensure consistency, should
                        //  copy flags directly from the mainkeyword table.
    DWORD       dwGIDflags ;  //  BitField indicating which GID this
        //  field is a member of.  Only one bit should be set.
}  SNAPSHOTTABLE , * PSNAPSHOTTABLE ;

// the snapshot table determines which fields in the
//  rawbinarydata are copied over to each structure in the
//  snapshot.  This table is initialized only when a
//  rawbinarydata block is read from file.


typedef struct  {

    RAWBINARYDATA   rbd ;  // may be accessed by UI and control module.

    DWORD   dwSpecVersion ;         //  store converted version number
    // ptrs to tables required to generate snapshot.
    //  these tables are allocated and initialized when
    //  the RawBinaryData is read from file.  They are not saved
    //  to file.

    //  max buffer size needed to store option array in keyword form:
    DWORD     dwMaxDocKeywordSize, // Doc-Sticky,not used now but might later.
              dwMaxPrnKeywordSize; // Printer-Sticky

#if 0
    PSNAPSHOTTABLE  snapShotTable ;
    PRANGE  ssTableIndex ;
    PDWORD   pdwSizeOption ;
    PDWORD   pdwSizeOptionEx ;
    DWORD   dwSSCmdSelectIndex ;  // SS index of atrCommandIndex in pfo
    DWORD   dwSSdefaultOptionIndex ;   // SSindex of atrDefaultOption in pfo
    DWORD   dwSSTableCmdIndex ;  // SSindex of MTI_COMMANDTABLE entry.
    DWORD   dwSSPaperSizeMinSizeIndex ;  //  index not actually used
    DWORD   dwSSPaperSizeMaxSizeIndex ;
    DWORD   dwSSPaperSizeMarginsIndex ;
    DWORD   dwSSPaperSizeCursorOriginIndex ;
    DWORD   dwSSFeatureTypeIndex ;
    DWORD   dwSSConstraintsIndex ;
    DWORD   dwSSInvalidCombosIndex ;
    //  add other special case indicies here.
#endif

} MINIRAWBINARYDATA, * PMINIRAWBINARYDATA;

//  assign this struct the type  'mrbd'
//  First 6 or so fields are same as RAWBINARYDATA.

// global !

// extern  MINIRAWBINARYDATA  gmrbd ;
// This is now in GLOBL structure.



typedef struct  {
    RAWBINARYDATA   rbd ;  // may be accessed by UI and control module.
        //  this must be the FIRST!  field, so Amanda's code will still function.
        //  so initialize with beginning of pubBUDData.
    HFILEMAP        hFileMap;  // handle to memory mapped  BUD file.
    PBYTE    pubBUDData ;  // ptr to image of BUD file.
                                        //  first structure is RAWBINARYDATA


    PSNAPSHOTTABLE  snapShotTable ;
    PRANGE  ssTableIndex ;
    PDWORD   pdwSizeOption ;
    PDWORD   pdwSizeOptionEx ;

    DWORD   dwSSFeatureTypeIndex ;
    DWORD   dwSSdefaultOptionIndex ;   // SSindex of atrDefaultOption in pfo
    DWORD   dwSSPaperSizeMinSizeIndex ;  //  index not actually used
    DWORD   dwSSPaperSizeMaxSizeIndex ;
    DWORD   dwSSTableCmdIndex ;  // SSindex of MTI_COMMANDTABLE entry.
    DWORD   dwSSCmdSelectIndex ;  // SS index of atrCommandIndex in pfo
    DWORD   dwSSPaperSizeCursorOriginIndex ;
    DWORD   dwSSConstraintsIndex ;
    DWORD   dwSSInvalidCombosIndex ;
#ifdef  GMACROS
    DWORD   dwSSDepSettingsIndex ;
    DWORD   dwSSUIChangeTriggersMacroIndex ;
#endif

#if 0  // Don't define unless necessary.
    DWORD   dwSSPaperSizeMarginsIndex ;
    //  add other special case indicies here.
#endif

}   STATICFIELDS, *PSTATICFIELDS ;   //  These are fields that contain static data that is used
//  to create the snapshot,  but would be repetitive and waste space if kept in the BUD file.




// ----  End of Header Section ---- //


// ---- CommandArray  Section ---- //


//  #define  NO_CALLBACK_ID   (0xffffffff)


#define   CMD_SELECT   (0xfffffffe)
    //  used in place of a symbolID resulting from
    //  registering a command name.


//  R.I.P. - moved to gpd.h
//  typedef  struct
//  {
//      ARRAYREF   strInvocation ; // use only if NOT a CmdCallback.
//      ORDERDEPENDENCY  ordOrder ;
//      DWORD  dwCmdCallbackID ;    // set to UNUSED if not a CmdCallback
//      DWORD   dwStandardVarsList ;  // use only if CmdCallback.  Points to
//                          //  root of list holding indicies of Standard Vars
//                          //  to be passed into the callback.
//  }  COMMAND, * PCOMMAND ;
//  assign this struct the type  'cmd'


//  typedef  struct
//  {
//      DWORD   dwFormat ;    //  first letter after the %
//      DWORD   dwDigits ;    //  used if wFormat = 'd' or 'D' and
//                          //  PARAM_FLAG_FIELDWIDTH_USED
//      DWORD   dwFlags ;   //  see param_flags
//      LONG   lMin   ;     //  optional lower limit
//      LONG   lMax   ;     //  optional upper limit
//  //    DWORD   dwMaxRepeat ;  //  optional max repeat count
//  //    doesn't really exist!
//      ARRAYREF    arTokens ;  //  tokens for RPN calculator
//  }  PARAMETER, * PPARAMETER ;
//  assign this struct the type  'param'


//  #define PARAM_FLAG_MIN_USED  0x00000001
//      //  lMin field is used
//  #define PARAM_FLAG_MAX_USED  0x00000002
//      //  lMax field is used
//  #define PARAM_FLAG_FIELDWIDTH_USED  0x00000004
//      //  if fieldwidth was specified for 'd' or 'D' format.
//  #define PARAM_FLAG_MAXREPEAT_USED  0x00000008  //  dead
//      //  dwMaxRepeat field is used


//  typedef  struct
//  {
//      DWORD  dwValue ;    // integer or Standard Variable index
//      OPERATOR eType;    // type of Value or operator
//  }  TOKENSTREAM, * PTOKENSTREAM ;
//  assign this struct the type  'tstr'




//  typedef  enum
//  {   OP_INTEGER,   //  dwValue contains an integer
//      OP_VARI_INDEX,
//          //  dwValue contains index to Standard Variable Table.
//
//      //  these operators will actually be inserted into the token
//      //  stream.
//      OP_MIN, OP_MAX, OP_ADD, OP_SUB, OP_MULT,
//      OP_DIV, OP_MOD, OP_MAX_REPEAT, OP_HALT
//
//      //  these operators are used only in the temporary stack
//      OP_OPENPAR, OP_CLOSEPAR, OP_NEG,
//
//      //  these operators are processed immediately by the
//      //  token parser and are not stored.
//      OP_COMMA, OP_NULL, OP_LAST
//  }  OPERATOR ;   // parameter operator.
//

// extern  DWORD   gdwOperPrecedence[OP_LAST] ;
// This is now in GLOBL structure.

// ---- End of CommandArray  Section ---- //


// ----  List Values Section ---- //


/*  this defines the nodes used to implement a singly-linked
    list of DWORD  items.  Some values are stored in Lists.  */


//  typedef  struct
//  {
//      DWORD       dwData ;
//      DWORD       dwNextItem ;  //  index of next listnode
//  }  LISTNODE, * PLISTNODE ;
//  assign this struct the type  'lst'

// ----  End of List Values Section ---- //

// ---- Macros Section ---- //


//  BLOCKMACRODICT  is an array of BLOCKMACRODICTENTRY structs
//  that allows the function to resolve references to BlockMacros.

typedef  struct
{
    DWORD  dwSymbolID;  //  macro name ID value (obtained by RegisterSymbol)
    DWORD  dwTKIndexOpen;  //   index of open brace (in newTokenMap)
    DWORD  dwTKIndexClose;  //  index of closing brace
} BLOCKMACRODICTENTRY, * PBLOCKMACRODICTENTRY ;


//  VALUEMACRODICT  is an array of VALUEMACRODICTENTRY structs
//  that allows the function to  resolve references to valueMacros.

typedef  struct
{
    DWORD  dwSymbolID;      //  macro name ID value
    DWORD  dwTKIndexValue;  //  token index of valueMacro defintion
} VALUEMACRODICTENTRY, * PVALUEMACRODICTENTRY ;


//  MACROLEVELSTACK:   is operated as a stack of MACROLEVELSTATE
//  structs that saves the values of curBlockMacroEntry
//  and curValueMacroEntry , each time a brace is encountered.

typedef  struct
{
    DWORD  dwCurBlockMacroEntry;
    DWORD  dwCurValueMacroEntry;
    BOOL    bMacroInProgress ;
} MACROLEVELSTATE, * PMACROLEVELSTATE  ;



// ---- End of Macros Section ---- //

// ---- Global and state Variables ---- //
// {

    // ---- Error handling variables ---- //


typedef   enum
    {ERRSEV_NONE, ERRSEV_CONTINUE, ERRSEV_RESTART, ERRSEV_FATAL} SEVERITY ;

typedef   enum
    {ERRTY_NONE, ERRTY_SYNTAX, ERRTY_MEMORY_ALLOCATION,
    ERRTY_FILE_OPEN, ERRTY_CODEBUG} ERRTYPE  ;



// All of the following are now in GLOBL structure.
// extern      DWORD   gdwMasterTabIndex ;  // which resource ran out
// extern      SEVERITY    geErrorSev ;    // how bad an error?
// extern      ERRTYPE     geErrorType ;   // what type of error?

// extern      DWORD   gdwVerbosity ;  //  0 = min verbosity 4 max verbosity.

// extern      DWORD   gdwID_IgnoreBlock  ;  //  index of *IgnoreBlock

// extern  DWORD   gdwMemConfigKB, gdwMemConfigMB, gdwOptionConstruct,
//    gdwOpenBraceConstruct, gdwCloseBraceConstruct,
//    gdwMemoryConfigMB,  gdwMemoryConfigKB,
//    gdwCommandConstruct, gdwCommandCmd,
//    gdwOptionName ;

// extern  DWORD   gdwResDLL_ID   ;   //  Feature index of feature holding
                                                       //  names of all resource DLLs.
    //  Table to convert allowed values to sizes:
//  extern      DWORD  gValueToSize[VALUE_MAX] ;   // size of various values in bytes



    // ---- track value of curBlockMacroArray and curValueMacroArray ---- //

//            BUG_BUG!!!!!    may be part of master table !
//      DWORD   gdwCurBlockMacroArray ;   // initially set to zero.  First
//      DWORD   gdwCurValueMacroArray ;   // writable slot in MacroArray.
//      DWORD   gdwMacroLevelStackPtr ;   // Push: write values into
            // MacroLevelStack[MacroLevelStackPtr++]
            //  Pop: read values from
            // MacroLevelStack[--MacroLevelStackPtr]

//  }


//  These commonly used entities will be MACROS.

#define  mMainKeywordTable   ((PKEYWORDTABLE_ENTRY)(gMasterTable[MTI_MAINKEYWORDTABLE].pubStruct))

#define  mpubOffRef     (gMasterTable[MTI_STRINGHEAP].pubStruct)
    //      All stringheap offsets are referenced from this pointer.
#define  mloCurHeap     (gMasterTable[MTI_STRINGHEAP].dwCurIndex)
    //      current writable position on heap.
#define  mdwMaxHeap     (gMasterTable[MTI_STRINGHEAP].dwArraySize)
    //      maximum size of heap.

#define  mpstsStateStack     ((PSTSENTRY)gMasterTable[MTI_STSENTRY].pubStruct)
    //      base of state stack
#define  mdwCurStsPtr     (gMasterTable[MTI_STSENTRY].dwCurIndex)
    //      current writable (uninitialized) position on stack.
#define  mdwMaxStackDepth     (gMasterTable[MTI_STSENTRY].dwArraySize)
    //      maximum size of heap.

    // ---- Index in SYMBOLNODE array to each type of tree ---- //
    // initially set to INVALID_INDEX

#define   mdwFeatureSymbols  (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_FEATURES))
#define   mdwFontCartSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_FONTCART))
#define   mdwTTFontSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_TTFONTNAMES))
#define   mdwBlockMacroSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_BLOCKMACRO))
#define   mdwValueMacroSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_VALUEMACRO))
#define   mdwCmdNameSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_COMMANDNAMES))
#define   mdwPreProcDefinesSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_PPDEFINES))


/*  -----  tables of constants ----- */




typedef enum {BT_FALSE, BT_TRUE} BOOLEANTYPE ;

typedef enum { UIT_PICKONE, UIT_PICKMANY }  UITYPE ;

typedef enum _QUERYDATATYPE {
    QDT_DWORD,  QDT_CONCATENATED_STRINGS
} QUERYDATATYPE;

//  typedef  enum
//  {ORIENT_PORTRAIT, ORIENT_CC90, ORIENT_CC270 }
//  ORIENTATION ;   //  decided to overload LANDSCAPEGRXROTATION
//                  //  instead of using a separate enum for orientation
//                  //  option keywords.


//  typedef  enum
//  {
//      SECT_UNINITIALIZED, JOB_SETUP, DOC_SETUP, PAGE_SETUP, PAGE_FINISH,
//      DOC_FINISH, JOB_FINISH
//  }  SECTION ;   replaced by SEQ_SECTION




typedef  struct
{
    DWORD  tIndexID;  //  tokenindex where a macro ID value is stored
    DWORD  tIndexOpen;  //  index of open brace
    DWORD  tIndexClose;  //  index of closing brace
} BLOCKMACROARRAY ;


//  snapshot and helper functions.

#define     OPTION_PENDING  (OPTION_INDEX_ANY - 1)

#define NUM_CONFIGURATION_CMDS (LAST_CONFIG_CMD - FIRST_CONFIG_CMD)
    // number of predefined commands that are emitted
    // at a fixed point in the job determined by order dependency.

#define     MAX_SNAPSHOT_ELEMENTS  (200)
    //  increase as more entries are added to the snapshot table.


typedef  enum
{
    TRI_UTTER_FAILURE, TRI_SUCCESS, TRI_AGAIN, TRI_UNINITIALIZED
}  TRISTATUS ;


typedef  enum
  { SSTI_GLOBALS,   SSTI_UPDATE_GLOBALS,
    SSTI_UIINFO,    SSTI_UPDATE_UIINFO,
    SSTI_FEATURES,  SSTI_UPDATE_FEATURES,
    SSTI_OPTIONS,   SSTI_UPDATE_OPTIONS,
    SSTI_OPTIONEX,  SSTI_UPDATE_OPTIONEX,
    SSTI_SPECIAL,   MAX_STRUCTURETYPES
  } SSTABLEINDEX ;



//  flags for snapshot table.

#define     SSF_REQUIRED        0x00000001
    //  fail if there is no value to copy
#define     SSF_DONT_USEDEFAULT 0x00000002
    //  if there is no value to copy leave dest
    //  undisturbed.  Do not copy the default value.
#define     SSF_OFFSETONLY      0x00000004
    // Copy only the loOffset of an arrayref.
#define     SSF_MAKE_STRINGPTR  0x00000008
    // Convert arrayref to stringptr
#define     SSF_SETRCID         0x00000010
    // set high bit after copying the value (if found)
#define     SSF_FAILIFZERO      0x00000020
    //  unlike SSF_REQUIRED, allow current copy
    //  to fail, then fail only if dest is zero.
#define     SSF_SECOND_DWORD    0x00000040
    //  treat src value object as array of DWORDS
    //  and copy the 2nd DWORD to the destination.
    //  used to transfer just the Y value of a point
    //  to the dest.
#define     SSF_KB_TO_BYTES    0x00000080
    //  treat dest as a dword and left shift by 10 bits.
#define     SSF_HEAPOFFSET    0x00000100
    //  instead of copying the bytes at pheap + heapoffset
    //  just copy heapoffset to the destination.
    //  this is used with dedicated structures where
    //  the heapoffset is actually the array index of a dedicated
    //  structure.
#define     SSF_RETURN_UNINITIALIZED        0x00000200
    //  if no value exists, cause EextractValueFromTree
    //  to return TRI_UNINITIALIZED, but don't complain
    //  to user.
#define     SSF_NON_LOCALIZABLE        0x00000400
    //  this keyword contains an explicit string and the resulting
    //  GPD file is not localizable.  The parser will emit a
    //  warning whenever such a keyword is parsed.

#define     SSF_MB_TO_BYTES    0x00000800
    //  treat dest as a dword and left shift by 20 bits.
#define     SSF_STRINGLEN    0x00001000
    //  just copy dwCount portion of arrayref to the destination.

//  the next 3 flags are to support the helper function
//  GetGPDResourceIDs() which is used only by Bob's MDT tool.
//  Note when any new entries are added to snaptbl.c
//  you should see if any of these flags need to be set.
//  otherwise  GetGPDResourceIDs will not report any
//  IDs used by the new entries.

#define     SSF_FONTID    0x00002000
    //  This entry is a Font resource ID.
#define     SSF_STRINGID    0x00004000
    //  This entry is a String resource ID.
#define     SSF_LIST    0x00008000
    //  This entry is a LIST (the index of a LISTNODE)
#define     SSF_ICONID    0x00010000
    //  This entry is an Icon  resource ID.
#define     SSF_OTHER_RESID    0x00020000
    //  This entry is an unclassified  resource ID.
    //   ie  CTT,  rcPromptMsgID, HelpIndex, rcHTPatternID


#define     SSF_BITFIELD_DEF_FALSE    (0x00040000)
    //  This entry is a Bitfield, which is CLEARED
    //   by default.
#define     SSF_BITFIELD_DEF_TRUE    (0x00080000)
    //  This entry is a Bitfield, which is SET
    //   by default.
    //   bitflags may be used with SSF_REQUIRED.

//   Bitfields are SET and CLEARED depending on the
//   value of the Boolean in the attribute tree.
//   the Bits to SET are defined by dwDefaultValue.


//  how do we verify proper initialization in the case when a dest
//  field must be initialized by at least one of several keywords?

//  The first keyword has a default initializer value of zero.
//  and has no flags set.  The last keyword has the
//  SSF_DONT_USEDEFAULT | SSF_FAILIFZERO   flags set.
//  The keywords in between has the SSF_DONT_USEDEFAULT flag set.




#define GIDF_RESOLUTION      (1 << GID_RESOLUTION)
#define GIDF_PAGESIZE        (1 << GID_PAGESIZE)
#define GIDF_PAGEREGION      (1 << GID_PAGEREGION)
#define GIDF_DUPLEX          (1 << GID_DUPLEX)
#define GIDF_INPUTSLOT       (1 << GID_INPUTSLOT)
#define GIDF_MEDIATYPE       (1 << GID_MEDIATYPE)
#define GIDF_MEMOPTION       (1 << GID_MEMOPTION)
#define GIDF_COLORMODE       (1 << GID_COLORMODE)
#define GIDF_ORIENTATION     (1 << GID_ORIENTATION)
#define GIDF_PAGEPROTECTION  (1 << GID_PAGEPROTECTION)
#define GIDF_COLLATE         (1 << GID_COLLATE)
#define GIDF_OUTPUTBIN       (1 << GID_OUTPUTBIN)
#define GIDF_HALFTONING      (1 << GID_HALFTONING)


//
// All the thread-unsafe data that was previously global has now
// been packed into this structure.
//

typedef struct {



    MASTERTAB_ENTRY     GMasterTable[MTI_MAX_ENTRIES] ;

    MINIRAWBINARYDATA   Gmrbd ;

        //  The AllowedTransitions Table determines/defines
        //  the state changes produced by each construct keyword
        //  Each entry in the table is a NewState and is indexed
        //  by the OldState and a ConstructKeyword
    STATE       GastAllowedTransitions[STATE_LAST][CONSTRUCT_LAST] ;

    BOOL        GabAllowedAttributes[STATE_LAST][ATT_LAST] ;

    DWORD       GdwOperPrecedence[OP_LAST] ;


    DWORD       GdwMasterTabIndex ;   // which resource ran out
    SEVERITY    GeErrorSev ;          // how bad an error?
    ERRTYPE     GeErrorType ;         // what type of error?

    DWORD       GdwVerbosity ;        //  0 = min verbosity 4 max verbosity.

    DWORD       GdwID_IgnoreBlock  ;  //  index of *IgnoreBlock

    DWORD       GValueToSize[VALUE_MAX] ;   // size of various values in bytes

        // MainKeywordTable ID values for  keywords
        // that will be synthesized or read by shortcuts code.
    DWORD       GdwMemConfigKB,         GdwMemConfigMB,     GdwOptionConstruct,
                GdwOpenBraceConstruct,  GdwCloseBraceConstruct,
                GdwMemoryConfigMB,      GdwMemoryConfigKB,
                GdwCommandConstruct,    GdwCommandCmd,
                GdwOptionName ;

    DWORD       GdwResDLL_ID  ;   //  Feature index of feature holding
                                  //  names of all resource DLLs.

    DWORD       GdwLastIndex;  // Used only in token1.c. Used to suppress
                               // BarchiveStrings() from doing redundant
                               // copying of the same strings in the event there
                               // are multiple parsing errors.
    ABSARRAYREF GaarPPPrefix;   // used only in preproc1.c

    CLASSINDEXENTRY  GcieTable[CL_NUMCLASSES] ;
} GLOBL, * PGLOBL;  // All the thread-unsafe data that was previously global has
                    // been packed into this structure.


//   function declarations.

#include "declares.h"

#if defined(DEVSTUDIO)

HANDLE MDSCreateFileW(LPCWSTR lpstrFile, DWORD dwDesiredAccess,
                      DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
                      DWORD dwCreateFlags, DWORD dwfAttributes,
                      HANDLE hTemplateFile);

#undef  CreateFile
#define CreateFile  MDSCreateFileW
#endif

#endif // _GPDPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\framwrk1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  framwrk.c - functions that tie different functions together.
    a supporting framework so to speak.

 History of Changes
  9/30/98 --hsingh--
          Added call to function BsetUQMFlag(). The function enables
          making the UpdateQualityMacro? keyword optional in
          .gpd file.

*/


#include    "gpdparse.h"
#include    "globals.h"


// ----  functions defined in  framwrk.c ---- //


BOOL   BcreateGPDbinary(
PWSTR   pwstrFileName,
DWORD   dwVerbosity)  ;

VOID      VinitMainKeywordTable(
PGLOBL  pglobl)  ;

DWORD        DWinitMainKeywordTable1(
        DWORD  dwI,
    PGLOBL pglobl) ;

DWORD        DWinitMainKeywordTable2(
        DWORD  dwI,
    PGLOBL pglobl) ;

DWORD        DWinitMainKeywordTable3(
        DWORD  dwI,
    PGLOBL pglobl) ;

DWORD        DWinitMainKeywordTable4(
        DWORD  dwI,
    PGLOBL pglobl) ;

DWORD        DWinitMainKeywordTable5(
        DWORD  dwI,
    PGLOBL pglobl) ;


VOID    VinitValueToSize(
PGLOBL  pglobl) ;

VOID  VinitGlobals(
DWORD   dwVerbosity,
PGLOBL  pglobl);

BOOL   BpreAllocateObjects(
PGLOBL  pglobl) ;

BOOL  BreturnBuffers(
PGLOBL  pglobl) ;

BOOL   BallocateCountableObjects(
PGLOBL  pglobl) ;

BOOL   BinitPreAllocatedObjects(
PGLOBL  pglobl) ;

BOOL   BinitCountableObjects(
PGLOBL  pglobl) ;

BOOL  BevaluateMacros(
PGLOBL  pglobl) ;

BOOL BpostProcess(
PWSTR   pwstrFileName,
PGLOBL  pglobl)  ;

BOOL    BconsolidateBuffers(
PWSTR   pwstrFileName,
PGLOBL  pglobl)  ;

BOOL    BexpandMemConfigShortcut(DWORD       dwSubType) ;

BOOL    BexpandCommandShortcut(DWORD       dwSubType) ;



// ---------------------------------------------------- //

BOOL   BcreateGPDbinary(
PWSTR   pwstrFileName,   // root GPD file
DWORD   dwVerbosity )  // Verbosity Level
{
    BOOL    bStatus ;
    GLOBL   globl;

    PGLOBL pglobl = &globl;

    // check. Temporary global.
    // check. pglobl = &globl;

    VinitGlobals(dwVerbosity, &globl) ;

    while(geErrorSev < ERRSEV_FATAL)
    {
        bStatus = BpreAllocateObjects(&globl) ;


        if(bStatus)
        {
            bStatus = BinitPreAllocatedObjects(&globl) ;
        }
        if(bStatus)
        {
            bStatus = BcreateTokenMap(pwstrFileName, &globl ) ;
        }
        if(bStatus)
        {
            bStatus = BexpandShortcuts(&globl) ;
        }
        if(bStatus)
        {
            bStatus = BevaluateMacros(&globl)  ;
        }
        if(bStatus)
        {
            bStatus = BInterpretTokens((PTKMAP)gMasterTable[MTI_NEWTOKENMAP].
                pubStruct,   TRUE, &globl ) ;  // is first pass
        }
        if(bStatus)
        {
            bStatus = BallocateCountableObjects(&globl) ;
        }
        if(bStatus)
        {
            bStatus = BinitCountableObjects(&globl) ;
        }
        if(bStatus)
        {
            bStatus = BInterpretTokens((PTKMAP)gMasterTable[MTI_NEWTOKENMAP].
                pubStruct,   FALSE, &globl ) ;  // second pass
        }
        if(bStatus)
        {
            bStatus = BpostProcess(pwstrFileName, &globl) ;
        }
        ;  // execution reaches here regardless
                    //  sets error code if needed.
        if(BreturnBuffers(&globl) )  // clears ERRSEV_RESTART but
        {                      // returns FALSE in this case.
            if(geErrorSev < ERRSEV_RESTART)
            {
                return(bStatus) ;  // escape
            }
        }
    }
    return(FALSE) ;  // died due to Fatal , unrecoverable error.
} // BcreateGPDbinary(...)


VOID      VinitMainKeywordTable(
    PGLOBL pglobl)
{
    DWORD  dwI = 0 ;  //  index to MainKeywordTable.

    dwI =   DWinitMainKeywordTable1(dwI,  pglobl) ;
    dwI =   DWinitMainKeywordTable2(dwI,  pglobl) ;
    dwI =   DWinitMainKeywordTable3(dwI,  pglobl) ;
    dwI =   DWinitMainKeywordTable4(dwI,  pglobl) ;
    dwI =   DWinitMainKeywordTable5(dwI,  pglobl) ;

    if(dwI >= gMasterTable[MTI_MAINKEYWORDTABLE].dwArraySize)
        RIP(("Too many entries to fit inside MainKeywordTable\n"));
}

DWORD        DWinitMainKeywordTable1(
        DWORD  dwI,
    PGLOBL pglobl)
/*
    note:
    VinitDictionaryIndex()  assumes the MainKeywordTable
    is divided into sections.  Each section is terminated by
    a NULL entry, that is an entry where pstrKeyword = NULL.
    The sections and their order in the KeywordTable are defined
    by the enum   KEYWORD_SECTS.   Make sure the MainKeywordTable
    has enough slots to hold all entries defined here.
*/
{
    /*  NON_ATTR  - constructs and special keywords. */

    //  *UIGroup:
    mMainKeywordTable[dwI].pstrKeyword  = "UIGroup" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_UIGROUP ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Feature:
    mMainKeywordTable[dwI].pstrKeyword  = "Feature" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_FEATURE ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Option:
    mMainKeywordTable[dwI].pstrKeyword  = "Option" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_OPTION ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwOptionConstruct = dwI ;
    dwI++ ;


    //  *switch:
    mMainKeywordTable[dwI].pstrKeyword  = "switch" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_SWITCH ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *case:
    mMainKeywordTable[dwI].pstrKeyword  = "case" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_CASE  ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Switch:
    mMainKeywordTable[dwI].pstrKeyword  = "Switch" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_SWITCH ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Case:
    mMainKeywordTable[dwI].pstrKeyword  = "Case" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_CASE  ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *default:
    mMainKeywordTable[dwI].pstrKeyword  = "default" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_DEFAULT ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Command:
    mMainKeywordTable[dwI].pstrKeyword  = "Command" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_COMMAND ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwCommandConstruct  = dwI ;
    dwI++ ;

    //  *FontCartridge:
    mMainKeywordTable[dwI].pstrKeyword  = "FontCartridge" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_FONTCART ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *TTFS:
    mMainKeywordTable[dwI].pstrKeyword  = "TTFS" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_TTFONTSUBS ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *OEM:
    mMainKeywordTable[dwI].pstrKeyword  = "OEM" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_OEM  ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;



    //  BlockMacro:
    mMainKeywordTable[dwI].pstrKeyword  = "BlockMacro" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_BLOCKMACRO ;
    mMainKeywordTable[dwI].dwOffset = 0 ;  // not used
    dwI++ ;

    //  Macros:
    mMainKeywordTable[dwI].pstrKeyword  = "Macros" ;
    mMainKeywordTable[dwI].eAllowedValue = NO_VALUE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_MACROS;
    mMainKeywordTable[dwI].dwOffset = 0 ;  // not used
    dwI++ ;

    //  {:
    mMainKeywordTable[dwI].pstrKeyword  = "{" ;
    mMainKeywordTable[dwI].eAllowedValue = NO_VALUE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_OPENBRACE ;
    mMainKeywordTable[dwI].dwOffset = 0 ;  // not used
    gdwOpenBraceConstruct  = dwI ;
    dwI++ ;

    //  }:
    mMainKeywordTable[dwI].pstrKeyword  = "}" ;
    mMainKeywordTable[dwI].eAllowedValue = NO_VALUE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_CLOSEBRACE ;
    mMainKeywordTable[dwI].dwOffset = 0 ;  // not used
    gdwCloseBraceConstruct = dwI ;
    dwI++ ;


    //  end of constructs.

    //  *Include:
    mMainKeywordTable[dwI].pstrKeyword  = "Include" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_DEF_CONVERT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_INCLUDE ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *InsertBlock:
    mMainKeywordTable[dwI].pstrKeyword  = "InsertBlock" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_BLOCKMACRO ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_INSERTBLOCK ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;


    //  *IgnoreBlock:
    mMainKeywordTable[dwI].pstrKeyword  = "IgnoreBlock" ;
    mMainKeywordTable[dwI].eAllowedValue = NO_VALUE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_IGNOREBLOCK ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwID_IgnoreBlock = dwI ;
    dwI++ ;


    //  *InvalidCombination:
    mMainKeywordTable[dwI].pstrKeyword  = "InvalidCombination" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_INVALID_COMBO ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                            atrInvalidCombos) ;
    dwI++ ;

    //  *InvalidInstallableCombination:
    mMainKeywordTable[dwI].pstrKeyword  = "InvalidInstallableCombination" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARTIALLY_QUALIFIED_NAME ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_INVALID_INS_COMBO ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrInvldInstallCombo) ;
    dwI++ ;

    //  *Cmd:
//    mMainKeywordTable[dwI].pstrKeyword  = "Cmd" ;
//    mMainKeywordTable[dwI].eAllowedValue = VALUE_COMMAND_SHORTCUT ;
//    mMainKeywordTable[dwI].flAgs = KWF_SHORTCUT  ;
//    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
//    mMainKeywordTable[dwI].dwSubType = SPEC_COMMAND_SHORTCUT ;
//    mMainKeywordTable[dwI].dwOffset = 0 ;
//    dwI++ ;



    //  *TTFS:
//    mMainKeywordTable[dwI].pstrKeyword  = "TTFS" ;
//    mMainKeywordTable[dwI].eAllowedValue = VALUE_FONTSUB ;
//    mMainKeywordTable[dwI].flAgs = KWF_SHORTCUT ;
//    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
//    mMainKeywordTable[dwI].dwSubType = SPEC_TTFS ;
//    mMainKeywordTable[dwI].dwOffset = 0 ;
//    dwI++ ;



    // these memconfig keywords must be expanded into
    // options.

    //  *MemConfigKB:
    mMainKeywordTable[dwI].pstrKeyword  = "MemConfigKB" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT ;
    mMainKeywordTable[dwI].flAgs = KWF_SHORTCUT ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_MEM_CONFIG_KB ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwMemConfigKB = dwI ;

    dwI++ ;

    //  *MemConfigMB:
    mMainKeywordTable[dwI].pstrKeyword  = "MemConfigMB" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT ;
    mMainKeywordTable[dwI].flAgs = KWF_SHORTCUT ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_MEM_CONFIG_MB ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwMemConfigMB = dwI ;
    dwI++ ;

    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;

    return  dwI ;
}

DWORD        DWinitMainKeywordTable2(
        DWORD  dwI,
    PGLOBL pglobl)
{


    /* ---- GLOBAL  Construct keywords: ----- */

    //  *GPDSpecVersion:
    mMainKeywordTable[dwI].pstrKeyword  = "GPDSpecVersion" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_NO_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrGPDSpecVersion) ;
    dwI++ ;

    //  *MasterUnits:
    mMainKeywordTable[dwI].pstrKeyword  = "MasterUnits" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMasterUnits) ;
    dwI++ ;


    //  *ModelName:
    mMainKeywordTable[dwI].pstrKeyword  = "ModelName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrModelName) ;
    dwI++ ;

    //  *rcModelNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcModelNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrModelNameID) ;
    dwI++ ;


    //  *GPDFileVersion:
    mMainKeywordTable[dwI].pstrKeyword  = "GPDFileVersion" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_NO_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrGPDFileVersion) ;
    dwI++ ;

    //  *GPDFileName:
    mMainKeywordTable[dwI].pstrKeyword  = "GPDFileName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_DEF_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrGPDFileName) ;
    dwI++ ;



    //  *InstalledOptionName:
    mMainKeywordTable[dwI].pstrKeyword  = "InstalledOptionName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrNameInstalled) ;
    dwI++ ;

    //  *rcInstalledOptionNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcInstalledOptionNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrNameIDInstalled) ;
    dwI++ ;


    //  *NotInstalledOptionName:
    mMainKeywordTable[dwI].pstrKeyword  = "NotInstalledOptionName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrNameNotInstalled) ;
    dwI++ ;

    //  *rcNotInstalledOptionNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcNotInstalledOptionNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrNameIDNotInstalled) ;
    dwI++ ;

    //  *DraftQualitySettings:
    mMainKeywordTable[dwI].pstrKeyword  = "DraftQualitySettings" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDraftQualitySettings) ;
    dwI++ ;

    //  *BetterQualitySettings:
    mMainKeywordTable[dwI].pstrKeyword  = "BetterQualitySettings" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrBetterQualitySettings) ;
    dwI++ ;

    //  *BestQualitySettings:
    mMainKeywordTable[dwI].pstrKeyword  = "BestQualitySettings" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrBestQualitySettings) ;
    dwI++ ;

    //  *DefaultQuality:
    mMainKeywordTable[dwI].pstrKeyword  = "DefaultQuality" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_QUALITYSETTING  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDefaultQuality) ;
    dwI++ ;

    //  *PrinterType:
    mMainKeywordTable[dwI].pstrKeyword  = "PrinterType" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PRINTERTYPE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrinterType) ;
    dwI++ ;

    //  *Personality:
    mMainKeywordTable[dwI].pstrKeyword  = "Personality" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPersonality) ;
    dwI++ ;

    //  *rcPersonalityID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPersonalityID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRcPersonalityID) ;
    dwI++ ;

    //  *ResourceDLL:
    mMainKeywordTable[dwI].pstrKeyword  = "ResourceDLL" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_DEF_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrResourceDLL) ;
    dwI++ ;

    //  *CodePage:
    mMainKeywordTable[dwI].pstrKeyword  = "CodePage" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCodePage) ;
    dwI++ ;

    //  *MaxCopies:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxCopies" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxCopies) ;
    dwI++ ;

    //  *FontCartSlots:
    mMainKeywordTable[dwI].pstrKeyword  = "FontCartSlots" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrFontCartSlots) ;
    dwI++ ;

    //  *MaxPrintableArea:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxPrintableArea" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT  ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxPrintableArea) ;
    dwI++ ;

    //  *OutputDataFormat:
    mMainKeywordTable[dwI].pstrKeyword  = "OutputDataFormat" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_OUTPUTDATAFORMAT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrOutputDataFormat) ;
    dwI++ ;

    //  *LookaheadRegion:
    mMainKeywordTable[dwI].pstrKeyword  = "LookAheadRegion" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrLookaheadRegion) ;
    dwI++ ;

    //  *rcPrinterIconID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPrinterIconID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrinterIcon) ;
    dwI++ ;

    //  *HelpFile:
    mMainKeywordTable[dwI].pstrKeyword  = "HelpFile" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_DEF_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrHelpFile) ;
    dwI++ ;

    //  *OEMCustomData:
    mMainKeywordTable[dwI].pstrKeyword  = "OEMCustomData" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_NO_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrOEMCustomData) ;
    dwI++ ;



    //
    // Printer Capabilities related information
    //

    //  *RotateCoordinate?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateCoordinate?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRotateCoordinate) ;
    dwI++ ;

    //  *RasterCaps:
    mMainKeywordTable[dwI].pstrKeyword  = "RasterCaps" ;
    mMainKeywordTable[dwI].eAllowedValue =  VALUE_CONSTANT_RASTERCAPS ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRasterCaps) ;
    dwI++ ;

    //  *RotateRaster?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateRaster?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRotateRasterData) ;
    dwI++ ;

    //  *TextCaps:
    mMainKeywordTable[dwI].pstrKeyword  = "TextCaps" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_TEXTCAPS ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrTextCaps) ;
    dwI++ ;

    //  *RotateFont?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateFont?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRotateFont) ;
    dwI++ ;

    //  *MemoryUsage:
    mMainKeywordTable[dwI].pstrKeyword  = "MemoryUsage" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_MEMORYUSAGE ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMemoryUsage) ;
    dwI++ ;

    //  *ReselectFont:
    mMainKeywordTable[dwI].pstrKeyword  = "ReselectFont" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_RESELECTFONT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrReselectFont) ;
    dwI++ ;

    //  *PrintRate:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintRate" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER   ;
    mMainKeywordTable[dwI].flAgs = 0  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrintRate) ;

    dwI++ ;

    #ifndef WINNT_40
    //  *PrintRateUnit:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintRateUnit" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PRINTRATEUNIT ;
    mMainKeywordTable[dwI].flAgs = 0  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrintRateUnit) ;
    dwI++ ;
    #endif

    //  *PrintRatePPM:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintRatePPM" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrintRatePPM) ;
    dwI++ ;


     //  *OutputOrderReversed?:
     //   note this keyword is also an option Keyword with type:
     //   ATT_LOCAL_OPTION_ONLY
     mMainKeywordTable[dwI].pstrKeyword  = "OutputOrderReversed?" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
     mMainKeywordTable[dwI].flAgs = 0 ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
     mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                         atrOutputOrderReversed) ;
     dwI++ ;


     //  *ReverseBandOrderForEvenPages?:
     //   special flag for HP970C  with AutoDuplexer
     //
     mMainKeywordTable[dwI].pstrKeyword  = "ReverseBandOrderForEvenPages?" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
     mMainKeywordTable[dwI].flAgs = 0 ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
     mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                         atrReverseBandOrderForEvenPages) ;
     dwI++ ;


     //  *OEMPrintingCallbacks:
     mMainKeywordTable[dwI].pstrKeyword  = "OEMPrintingCallbacks" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_OEMPRINTINGCALLBACKS ;
     mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
     mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                         atrOEMPrintingCallbacks) ;
     dwI++ ;


    //
    // Cursor Control related information
    //


    //  *CursorXAfterCR:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorXAfterCR" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURSORXAFTERCR  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterCR) ;
    dwI++ ;

    //  *BadCursorMoveInGrxMode:
    mMainKeywordTable[dwI].pstrKeyword  = "BadCursorMoveInGrxMode" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BADCURSORMOVEINGRXMODE ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrBadCursorMoveInGrxMode) ;
    dwI++ ;

    //  *YMoveAttributes:
    mMainKeywordTable[dwI].pstrKeyword  = "YMoveAttributes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_YMOVEATTRIB ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYMoveAttributes) ;
    dwI++ ;

    //  *MaxLineSpacing:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxLineSpacing" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxLineSpacing) ;
    dwI++ ;


    //  *UseSpaceForXMove?:
    mMainKeywordTable[dwI].pstrKeyword  = "UseSpaceForXMove?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrbUseSpaceForXMove) ;
    dwI++ ;

    //  *AbsXMovesRightOnly?:
    mMainKeywordTable[dwI].pstrKeyword  = "AbsXMovesRightOnly?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrbAbsXMovesRightOnly) ;
    dwI++ ;



#if 0
    //  *SimulateXMove:
    mMainKeywordTable[dwI].pstrKeyword  = "SimulateXMove" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_SIMULATEXMOVE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrSimulateXMove) ;
    dwI++ ;
#endif

    //  *EjectPageWithFF?:
    mMainKeywordTable[dwI].pstrKeyword  = "EjectPageWithFF?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrEjectPageWithFF) ;
    dwI++ ;

    //  *XMoveThreshold:
    mMainKeywordTable[dwI].pstrKeyword  = "XMoveThreshold" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrXMoveThreshold) ;
    dwI++ ;

    //  *YMoveThreshold:
    mMainKeywordTable[dwI].pstrKeyword  = "YMoveThreshold" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYMoveThreshold) ;
    dwI++ ;

    //  *XMoveUnit:
    mMainKeywordTable[dwI].pstrKeyword  = "XMoveUnit" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrXMoveUnits) ;
    dwI++ ;

    //  *YMoveUnit:
    mMainKeywordTable[dwI].pstrKeyword  = "YMoveUnit" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYMoveUnits) ;
    dwI++ ;


    //  *LineSpacingMoveUnit:
    mMainKeywordTable[dwI].pstrKeyword  = "LineSpacingMoveUnit" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrLineSpacingMoveUnit) ;
    dwI++ ;




    return  dwI ;
}

DWORD        DWinitMainKeywordTable3(
        DWORD  dwI,
    PGLOBL pglobl)
{



    //
    // Color related information
    //



    //  *ChangeColorModeOnPage?:
    mMainKeywordTable[dwI].pstrKeyword  = "ChangeColorModeOnPage?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrChangeColorMode) ;
    dwI++ ;

    //  *ChangeColorModeOnDoc?:
    mMainKeywordTable[dwI].pstrKeyword  = "ChangeColorModeOnDoc?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrChangeColorModeDoc) ;
    dwI++ ;

    //  *MagentaInCyanDye:
    mMainKeywordTable[dwI].pstrKeyword  = "MagentaInCyanDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMagentaInCyanDye) ;
    dwI++ ;

    //  *YellowInCyanDye:
    mMainKeywordTable[dwI].pstrKeyword  = "YellowInCyanDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYellowInCyanDye) ;
    dwI++ ;

    //  *CyanInMagentaDye:
    mMainKeywordTable[dwI].pstrKeyword  = "CyanInMagentaDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCyanInMagentaDye) ;
    dwI++ ;

    //  *YellowInMagentaDye:
    mMainKeywordTable[dwI].pstrKeyword  = "YellowInMagentaDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYellowInMagentaDye) ;
    dwI++ ;

    //  *CyanInYellowDye:
    mMainKeywordTable[dwI].pstrKeyword  = "CyanInYellowDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCyanInYellowDye) ;
    dwI++ ;

    //  *MagentaInYellowDye:
    mMainKeywordTable[dwI].pstrKeyword  = "MagentaInYellowDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMagentaInYellowDye) ;
    dwI++ ;

    //  *UseExpColorSelectCmd?:
    mMainKeywordTable[dwI].pstrKeyword  = "UseExpColorSelectCmd?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrUseColorSelectCmd) ;
    dwI++ ;

    //  *MoveToX0BeforeSetColor?:
    mMainKeywordTable[dwI].pstrKeyword  = "MoveToX0BeforeSetColor?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMoveToX0BeforeColor) ;
    dwI++ ;

    //  *EnableGDIColorMapping?:
    mMainKeywordTable[dwI].pstrKeyword  = "EnableGDIColorMapping?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrEnableGDIColorMapping) ;
    dwI++ ;

//    obsolete fields
    //  *MaxNumPalettes:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxNumPalettes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxNumPalettes) ;
    dwI++ ;

#if 0

    //  *PaletteSizes:
    mMainKeywordTable[dwI].pstrKeyword  = "PaletteSizes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPaletteSizes) ;
    dwI++ ;

    //  *PaletteScope:
    mMainKeywordTable[dwI].pstrKeyword  = "PaletteScope" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PALETTESCOPE ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPaletteScope) ;
    dwI++ ;

#endif

    //  *MinOverlayID:
    mMainKeywordTable[dwI].pstrKeyword  = "MinOverlayID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMinOverlayID) ;
    dwI++ ;

    //  *MaxOverlayID:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxOverlayID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxOverlayID) ;
    dwI++ ;

    //  *OptimizeLeftBound?:
    mMainKeywordTable[dwI].pstrKeyword  = "OptimizeLeftBound?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrOptimizeLeftBound) ;
    dwI++ ;

    //  *StripBlanks:
    mMainKeywordTable[dwI].pstrKeyword  = "StripBlanks" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_STRIPBLANKS ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrStripBlanks) ;
    dwI++ ;

    //  *LandscapeGrxRotation:
    mMainKeywordTable[dwI].pstrKeyword  = "LandscapeGrxRotation" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_LANDSCAPEGRXROTATION ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrLandscapeGrxRotation) ;
    dwI++ ;

    //  *RasterZeroFill?:
    mMainKeywordTable[dwI].pstrKeyword  = "RasterZeroFill?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRasterZeroFill) ;
    dwI++ ;

    //  *RasterSendAllData?:
    mMainKeywordTable[dwI].pstrKeyword  = "RasterSendAllData?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRasterSendAllData) ;
    dwI++ ;

    //  *SendMultipleRows?:
    mMainKeywordTable[dwI].pstrKeyword  = "SendMultipleRows?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrSendMultipleRows) ;
    dwI++ ;

    //  *MaxMultipleRowBytes:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxMultipleRowBytes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxMultipleRowBytes) ;
    dwI++ ;

    //  *CursorXAfterSendBlockData:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorXAfterSendBlockData" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURSORXAFTERSENDBLOCKDATA ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterSendBlockData) ;
    dwI++ ;

    //  *CursorYAfterSendBlockData:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorYAfterSendBlockData" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURSORYAFTERSENDBLOCKDATA ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorYAfterSendBlockData) ;
    dwI++ ;

    //  *MirrorRasterByte?:
    mMainKeywordTable[dwI].pstrKeyword  = "MirrorRasterByte?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMirrorRasterByte) ;
    dwI++ ;

    //  *MirrorRasterPage?
    mMainKeywordTable[dwI].pstrKeyword  = "MirrorRasterPage?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMirrorRasterPage) ;
    dwI++ ;


    //  *DeviceFonts:     formerly known as *Font:
    mMainKeywordTable[dwI].pstrKeyword  = "DeviceFonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_ADDITIVE ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT  ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDeviceFontsList ) ;
    dwI++ ;

    //  *DefaultFont:
    mMainKeywordTable[dwI].pstrKeyword  = "DefaultFont" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDefaultFont) ;
    dwI++ ;

    //  *TTFSEnabled?:
    mMainKeywordTable[dwI].pstrKeyword  = "TTFSEnabled?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrTTFSEnabled ) ;
    dwI++ ;

    //  *RestoreDefaultFont?:
    mMainKeywordTable[dwI].pstrKeyword  = "RestoreDefaultFont?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRestoreDefaultFont) ;
    dwI++ ;

    //  *DefaultCTT:
    mMainKeywordTable[dwI].pstrKeyword  = "DefaultCTT" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDefaultCTT) ;
    dwI++ ;

    //  *MaxFontUsePerPage:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxFontUsePerPage" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxFontUsePerPage) ;
    dwI++ ;

    //  *RotateFont?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateFont?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRotateFont) ;
    dwI++ ;

    //  *TextYOffset:
    mMainKeywordTable[dwI].pstrKeyword  = "TextYOffset" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrTextYOffset) ;
    dwI++ ;

    //  *CharPosition:
    mMainKeywordTable[dwI].pstrKeyword  = "CharPosition" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CHARPOSITION ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCharPosition) ;
    dwI++ ;

    // ------- Font Downloading

    //  *MinFontID:
    mMainKeywordTable[dwI].pstrKeyword  = "MinFontID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMinFontID) ;
    dwI++ ;

    //  *MaxFontID:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxFontID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxFontID) ;
    dwI++ ;

    //  *MaxNumDownFonts:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxNumDownFonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxNumDownFonts) ;
    dwI++ ;

    //  *DLSymbolSet:
    mMainKeywordTable[dwI].pstrKeyword  = "DLSymbolSet" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_DLSYMBOLSET  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDLSymbolSet) ;
    dwI++ ;

    //  *MinGlyphID:
    mMainKeywordTable[dwI].pstrKeyword  = "MinGlyphID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMinGlyphID) ;
    dwI++ ;

    //  *MaxGlyphID:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxGlyphID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxGlyphID) ;
    dwI++ ;

    //  *IncrementalDownload?:
    mMainKeywordTable[dwI].pstrKeyword  = "IncrementalDownload?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrIncrementalDownload) ;
    dwI++ ;

    //  *FontFormat:
    mMainKeywordTable[dwI].pstrKeyword  = "FontFormat" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_FONTFORMAT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrFontFormat) ;
    dwI++ ;

    //  *MemoryUsage:
    mMainKeywordTable[dwI].pstrKeyword  = "MemoryUsage" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMemoryForFontsOnly) ;
    dwI++ ;

    //  *DiffFontsPerByteMode?:
    mMainKeywordTable[dwI].pstrKeyword  = "DiffFontsPerByteMode?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDiffFontsPerByteMode) ;
    dwI++ ;

    // -----

    //  *CursorXAfterRectFill:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorXAfterRectFill" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURXAFTER_RECTFILL ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterRectFill) ;
    dwI++ ;

    //  *CursorYAfterRectFill:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorYAfterRectFill" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURYAFTER_RECTFILL ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorYAfterRectFill) ;
    dwI++ ;

    //  *MinGrayFill:
    mMainKeywordTable[dwI].pstrKeyword  = "MinGrayFill" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMinGrayFill) ;
    dwI++ ;

    //  *MaxGrayFill:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxGrayFill" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxGrayFill) ;
    dwI++ ;

    //  *TextHalftoneThreshold:
    mMainKeywordTable[dwI].pstrKeyword  = "TextHalftoneThreshold" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrTextHalftoneThreshold) ;
    dwI++ ;




    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    return  dwI ;
}

DWORD        DWinitMainKeywordTable4(
        DWORD  dwI,
    PGLOBL pglobl)
{



    /* ---- FEATURE  Construct keywords: ----- */

    //  *FeatureType:
    mMainKeywordTable[dwI].pstrKeyword  = "FeatureType" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_FEATURETYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeatureType) ;
    dwI++ ;

    //  *UIType:     aka  PickMany?
    mMainKeywordTable[dwI].pstrKeyword  = "UIType" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_UITYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrUIType) ;
    dwI++ ;

    //  *DefaultOption:
    mMainKeywordTable[dwI].pstrKeyword  = "DefaultOption" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_OPTIONS ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDefaultOption) ;
    dwI++ ;

    //  *ConflictPriority:
    mMainKeywordTable[dwI].pstrKeyword  = "ConflictPriority" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPriority ) ;
    dwI++ ;

    //  *Installable?:
    mMainKeywordTable[dwI].pstrKeyword  = "Installable?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaInstallable) ;
    dwI++ ;

    //  *InstallableFeatureName:
    mMainKeywordTable[dwI].pstrKeyword  = "InstallableFeatureName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrInstallableFeaDisplayName ) ;
    dwI++ ;

    //  *rcInstallableFeatureNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcInstallableFeatureNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrInstallableFeaRcNameID) ;
    dwI++ ;

    //  *Name:
    mMainKeywordTable[dwI].pstrKeyword  = "Name" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaDisplayName ) ;
    dwI++ ;

    //  *rcNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcNameID) ;
    dwI++ ;

    //  *rcIconID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcIconID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcIconID) ;
    dwI++ ;

    //  *rcHelpTextID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcHelpTextID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcHelpTextID) ;
    dwI++ ;

    //  *rcPromptMsgID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPromptMsgID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcPromptMsgID) ;
    dwI++ ;

    //  *rcPromptTime:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPromptTime" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PROMPTTIME ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcPromptTime) ;
    dwI++ ;

    //  *ConcealFromUI?:
    mMainKeywordTable[dwI].pstrKeyword  = "ConcealFromUI?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrConcealFromUI) ;
    dwI++ ;

    //  *UpdateQualityMacro?:
    mMainKeywordTable[dwI].pstrKeyword  = "UpdateQualityMacro?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrUpdateQualityMacro) ;
    dwI++ ;

    //  *HelpIndex:
    mMainKeywordTable[dwI].pstrKeyword  = "HelpIndex" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaHelpIndex) ;
    dwI++ ;

    //  *QueryOptionList:     BUG_BUG!  not supported in 5.0
    mMainKeywordTable[dwI].pstrKeyword  = "QueryOptionList" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrQueryOptionList) ;
    dwI++ ;

    //  *QueryDataType:
    mMainKeywordTable[dwI].pstrKeyword  = "QueryDataType" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_QUERYDATATYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrQueryDataType) ;
    dwI++ ;

    //  *QueryDefaultOption:     BUG_BUG!  not supported in 5.0
    mMainKeywordTable[dwI].pstrKeyword  = "QueryDefaultOption" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrQueryDefaultOption) ;
    dwI++ ;

    //  *InstalledConstraints:
    mMainKeywordTable[dwI].pstrKeyword  = "InstalledConstraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaInstallConstraints) ;
    dwI++ ;

    //  *NotInstalledConstraints:
    mMainKeywordTable[dwI].pstrKeyword  = "NotInstalledConstraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaNotInstallConstraints) ;
    dwI++ ;


    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    /* ---- OPTION  Construct keywords: ----- */

    //  *Installable?:
    mMainKeywordTable[dwI].pstrKeyword  = "Installable?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptInstallable) ;
    dwI++ ;

    //  *InstallableFeatureName:
    mMainKeywordTable[dwI].pstrKeyword  = "InstallableFeatureName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrInstallableOptDisplayName ) ;
    dwI++ ;

    //  *rcInstallableFeatureNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcInstallableFeatureNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrInstallableOptRcNameID) ;
    dwI++ ;

    //  *Name:
    mMainKeywordTable[dwI].pstrKeyword  = "Name" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptDisplayName ) ;
    gdwOptionName = dwI ;
    dwI++ ;

    //  *rcNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcNameID) ;
    dwI++ ;

    //  *rcIconID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcIconID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcIconID) ;
    dwI++ ;

    //  *rcHelpTextID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcHelpTextID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcHelpTextID) ;
    dwI++ ;

    //  *HelpIndex:
    mMainKeywordTable[dwI].pstrKeyword  = "HelpIndex" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptHelpIndex) ;
    dwI++ ;

    //  *rcPromptMsgID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPromptMsgID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcPromptMsgID) ;
    dwI++ ;

    //  *rcPromptTime:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPromptTime" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PROMPTTIME ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcPromptTime) ;
    dwI++ ;

    //  *Constraints:
    mMainKeywordTable[dwI].pstrKeyword  = "Constraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrConstraints) ;
    dwI++ ;

    //  *InstalledConstraints:
    mMainKeywordTable[dwI].pstrKeyword  = "InstalledConstraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptInstallConstraints) ;
    dwI++ ;

    //  *NotInstalledConstraints:
    mMainKeywordTable[dwI].pstrKeyword  = "NotInstalledConstraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptNotInstallConstraints) ;
    dwI++ ;

    //  *OptionID:
    mMainKeywordTable[dwI].pstrKeyword  = "OptionID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    dwI++ ;

         //  *DisabledFeatures:
     mMainKeywordTable[dwI].pstrKeyword  = "DisabledFeatures" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_PARTIALLY_QUALIFIED_NAME ;
     mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_ADDITIVE ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
     mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                         atrDisabledFeatures) ;
     dwI++ ;


#ifdef  GMACROS

         //  *DependentSettings:
     mMainKeywordTable[dwI].pstrKeyword  = "DependentSettings" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME ;
     mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_CHAIN ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
     mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                         atrDependentSettings) ;
     dwI++ ;

         //  *UIChangeTriggersMacro:
     mMainKeywordTable[dwI].pstrKeyword  = "UIChangeTriggersMacro" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME ;
     mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_CHAIN ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
     mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                         atrUIChangeTriggersMacro) ;
     dwI++ ;
#endif




    //  -- Option specific keywords -- //

    //  *PrintableArea:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintableArea" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPrintableSize) ;
    dwI++ ;

    //  *PrintableOrigin:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintableOrigin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPrintableOrigin) ;
    dwI++ ;

    //  *CursorOrigin:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorOrigin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCursorOrigin) ;
    dwI++ ;

    //  *VectorOffset:
    mMainKeywordTable[dwI].pstrKeyword  = "VectorOffset" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrVectorOffset) ;
    dwI++ ;

    //  *MinSize:
    mMainKeywordTable[dwI].pstrKeyword  = "MinSize" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMinSize) ;
    dwI++ ;

    //  *MaxSize:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxSize" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMaxSize) ;
    dwI++ ;

    //  *TopMargin:
    mMainKeywordTable[dwI].pstrKeyword  = "TopMargin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrTopMargin) ;
    dwI++ ;

    //  *BottomMargin:
    mMainKeywordTable[dwI].pstrKeyword  = "BottomMargin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrBottomMargin) ;
    dwI++ ;

    //  *MaxPrintableWidth:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxPrintableWidth" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMaxPrintableWidth) ;
    dwI++ ;

    //  *MinLeftMargin:
    mMainKeywordTable[dwI].pstrKeyword  = "MinLeftMargin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMinLeftMargin) ;
    dwI++ ;

    //  *CenterPrintable?:
    mMainKeywordTable[dwI].pstrKeyword  = "CenterPrintable?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCenterPrintable) ;
    dwI++ ;


    //  *PageDimensions:
    mMainKeywordTable[dwI].pstrKeyword  = "PageDimensions" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPageDimensions) ;
    dwI++ ;

    //  *RotateSize?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateSize?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRotateSize) ;
    dwI++ ;

    //  *PortRotationAngle:
    mMainKeywordTable[dwI].pstrKeyword  = "PortRotationAngle" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPortRotationAngle) ;
    dwI++ ;

    //  *PageProtectMem:
    mMainKeywordTable[dwI].pstrKeyword  = "PageProtectMem" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPageProtectMem) ;
    dwI++ ;


    //  *CustCursorOriginX:
    mMainKeywordTable[dwI].pstrKeyword  = "CustCursorOriginX" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustCursorOriginX) ;
    dwI++ ;


    //  *CustCursorOriginY:
    mMainKeywordTable[dwI].pstrKeyword  = "CustCursorOriginY" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustCursorOriginY) ;
    dwI++ ;


    //  *CustPrintableOriginX:
    mMainKeywordTable[dwI].pstrKeyword  = "CustPrintableOriginX" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableOriginX) ;
    dwI++ ;


    //  *CustPrintableOriginY:
    mMainKeywordTable[dwI].pstrKeyword  = "CustPrintableOriginY" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableOriginY) ;
    dwI++ ;


    //  *CustPrintableSizeX:
    mMainKeywordTable[dwI].pstrKeyword  = "CustPrintableSizeX" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableSizeX) ;
    dwI++ ;
    //  *CustPrintableSizeY:
    mMainKeywordTable[dwI].pstrKeyword  = "CustPrintableSizeY" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableSizeY) ;
    dwI++ ;




    //  *FeedMargins:
    mMainKeywordTable[dwI].pstrKeyword  = "FeedMargins" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeedMargins) ;
    dwI++ ;

    //  *PaperFeed:
    mMainKeywordTable[dwI].pstrKeyword  = "PaperFeed" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PAPERFEED_ORIENT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPaperFeed) ;
    dwI++ ;

    //  *DPI:
    mMainKeywordTable[dwI].pstrKeyword  = "DPI" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDPI) ;
    dwI++ ;

    //  *SpotDiameter:
    mMainKeywordTable[dwI].pstrKeyword  = "SpotDiameter" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrSpotDiameter) ;
    dwI++ ;

    //  *TextDPI:
    mMainKeywordTable[dwI].pstrKeyword  = "TextDPI" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrTextDPI) ;
    dwI++ ;

    //  *PinsPerPhysPass:
    mMainKeywordTable[dwI].pstrKeyword  = "PinsPerPhysPass" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPinsPerPhysPass) ;
    dwI++ ;

    //  *PinsPerLogPass:
    mMainKeywordTable[dwI].pstrKeyword  = "PinsPerLogPass" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPinsPerLogPass) ;
    dwI++ ;

    //  *RequireUniDir?:
    mMainKeywordTable[dwI].pstrKeyword  = "RequireUniDir?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRequireUniDir) ;
    dwI++ ;

    //  *MinStripBlankPixels:
    mMainKeywordTable[dwI].pstrKeyword  = "MinStripBlankPixels" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMinStripBlankPixels) ;
    dwI++ ;

    //  *RedDeviceGamma:
    mMainKeywordTable[dwI].pstrKeyword  = "RedDeviceGamma" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRedDeviceGamma) ;
    dwI++ ;

    //  *GreenDeviceGamma:
    mMainKeywordTable[dwI].pstrKeyword  = "GreenDeviceGamma" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrGreenDeviceGamma) ;
    dwI++ ;

    //  *BlueDeviceGamma:
    mMainKeywordTable[dwI].pstrKeyword  = "BlueDeviceGamma" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrBlueDeviceGamma) ;
    dwI++ ;

    //  *Color?:
    mMainKeywordTable[dwI].pstrKeyword  = "Color?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrColor) ;
    dwI++ ;

    //  *DevNumOfPlanes:
    mMainKeywordTable[dwI].pstrKeyword  = "DevNumOfPlanes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDevNumOfPlanes) ;
    dwI++ ;

    //  *DevBPP:
    mMainKeywordTable[dwI].pstrKeyword  = "DevBPP" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDevBPP) ;
    dwI++ ;

    //  *ColorPlaneOrder:
    mMainKeywordTable[dwI].pstrKeyword  = "ColorPlaneOrder" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_COLORPLANE ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrColorPlaneOrder) ;
    dwI++ ;

    //  *DrvBPP:
    mMainKeywordTable[dwI].pstrKeyword  = "DrvBPP" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDrvBPP) ;
    dwI++ ;

    //  *IPCallbackID:
    mMainKeywordTable[dwI].pstrKeyword  = "IPCallbackID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrIPCallbackID) ;
    dwI++ ;

    //  *ColorSeparation?:
    mMainKeywordTable[dwI].pstrKeyword  = "ColorSeparation?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrColorSeparation) ;
    dwI++ ;

    //  *RasterMode:
    mMainKeywordTable[dwI].pstrKeyword  = "RasterMode" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_RASTERMODE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRasterMode) ;
    dwI++ ;

    //  *PaletteSize:
    mMainKeywordTable[dwI].pstrKeyword  = "PaletteSize" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPaletteSize) ;
    dwI++ ;

    //  *PaletteProgrammable?:
    mMainKeywordTable[dwI].pstrKeyword  = "PaletteProgrammable?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPaletteProgrammable) ;
    dwI++ ;

    //  *rcHTPatternID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcHTPatternID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRcHTPatternID) ;
    dwI++ ;

    //  *HTPatternSize:
    mMainKeywordTable[dwI].pstrKeyword  = "HTPatternSize" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrHTPatternSize) ;
    dwI++ ;

    //  *HTNumPatterns:
    mMainKeywordTable[dwI].pstrKeyword  = "HTNumPatterns" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrHTNumPatterns) ;
    dwI++ ;

    //  *HTCallbackID:
    mMainKeywordTable[dwI].pstrKeyword  = "HTCallbackID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrHTCallbackID) ;
    dwI++ ;

    //  *Luminance:
    mMainKeywordTable[dwI].pstrKeyword  = "Luminance" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrLuminance) ;
    dwI++ ;


    //  *MemoryConfigKB:
    mMainKeywordTable[dwI].pstrKeyword  = "MemoryConfigKB" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigKB) ;
    gdwMemoryConfigKB  = dwI ;

    dwI++ ;


    //  *MemoryConfigMB:
    mMainKeywordTable[dwI].pstrKeyword  = "MemoryConfigMB" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigMB) ;
    gdwMemoryConfigMB  = dwI ;

    dwI++ ;


    //  *OutputOrderReversed?:
    mMainKeywordTable[dwI].pstrKeyword  = "OutputOrderReversed?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOutputOrderReversed) ;
    dwI++ ;





    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    return  dwI ;
}

DWORD        DWinitMainKeywordTable5(
        DWORD  dwI,
    PGLOBL pglobl)
{



    /* ---- COMMAND  Construct keywords: ----- */

    //  *Cmd:
    mMainKeywordTable[dwI].pstrKeyword  = "Cmd" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_COMMAND_INVOC ;
    mMainKeywordTable[dwI].flAgs = KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, strInvocation ) ;
    gdwCommandCmd = dwI ;
    dwI++ ;

    //  *CallbackID:
    mMainKeywordTable[dwI].pstrKeyword  = "CallbackID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs =  KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, dwCmdCallbackID ) ;
    dwI++ ;

    //  *Order:
    mMainKeywordTable[dwI].pstrKeyword  = "Order" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_ORDERDEPENDENCY;
    mMainKeywordTable[dwI].flAgs = KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, ordOrder ) ;
    dwI++ ;

    //  *Params:
    mMainKeywordTable[dwI].pstrKeyword  = "Params" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_STANDARD_VARS ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, dwStandardVarsList) ;
    dwI++ ;

    //  *NoPageEject?:
    mMainKeywordTable[dwI].pstrKeyword  = "NoPageEject?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, bNoPageEject) ;
    dwI++ ;


    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    /* ---- FONTCART  Construct keywords: ----- */



    //  *rcCartridgeNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcCartridgeNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , dwRCCartNameID ) ;
    dwI++ ;

    //  *CartridgeName:
    mMainKeywordTable[dwI].pstrKeyword  = "CartridgeName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT;
    mMainKeywordTable[dwI].flAgs = KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , strCartName  ) ;
    dwI++ ;

    //  *Fonts:
    mMainKeywordTable[dwI].pstrKeyword  = "Fonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , dwFontLst  ) ;
    dwI++ ;

    //  *PortraitFonts:
    mMainKeywordTable[dwI].pstrKeyword  = "PortraitFonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , dwPortFontLst  ) ;
    dwI++ ;

    //  *LandscapeFonts:
    mMainKeywordTable[dwI].pstrKeyword  = "LandscapeFonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , dwLandFontLst  ) ;
    dwI++ ;



    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;



    /* ---- TTFONTSUBS  Construct keywords: ----- */
    //  these keywords may be synthesized along with the construct
    //  *TTFontSub  from the shortcut:
    //  *TTFS: "font name" : <fontID>


    //  *TTFontName:
    mMainKeywordTable[dwI].pstrKeyword  = "TTFontName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE, arTTFontName) ;
    dwI++ ;

    //  *DevFontName:
    mMainKeywordTable[dwI].pstrKeyword  = "DevFontName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE, arDevFontName) ;
    dwI++ ;

    //  *rcTTFontNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcTTFontNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE,
                                        dwRcTTFontNameID) ;
    dwI++ ;

    //  *rcDevFontNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcDevFontNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE,
                                        dwRcDevFontNameID) ;
    dwI++ ;

    //  *DevFontID:
//    mMainKeywordTable[dwI].pstrKeyword  = "DevFontID" ;
//    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
//    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
//    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
//    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
//    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE, dwDevFontID) ;
//    dwI++ ;



    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;




    /* ---- OEM  Construct keywords: ----- */

    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    /* ---- END_ATTR  No more Construct keywords: ----- */

    return  dwI ;
}


VOID    VinitValueToSize(
            PGLOBL pglobl)
{
    DWORD   dwI ;

    // initialize to DWORD size as defaults.

    for(dwI = 0 ; dwI < VALUE_MAX ; dwI++)
        gValueToSize[dwI] = sizeof(DWORD) ;

    gValueToSize[NO_VALUE]                  =  0 ;
    gValueToSize[VALUE_LARGEST]             =  0 ;
    gValueToSize[VALUE_STRING_NO_CONVERT]   =  sizeof(ARRAYREF) ;
    gValueToSize[VALUE_STRING_DEF_CONVERT]  =  sizeof(ARRAYREF) ;
    gValueToSize[VALUE_STRING_CP_CONVERT]   =  sizeof(ARRAYREF) ;
    gValueToSize[VALUE_COMMAND_INVOC]       =  sizeof(ARRAYREF) ;
    gValueToSize[VALUE_PARAMETER]       =  sizeof(ARRAYREF) ;

    //  SYMBOLS and CONSTANTS are all DWORD sized.
    gValueToSize[VALUE_POINT]               =  sizeof(POINT) ; // etc
    gValueToSize[VALUE_RECT]                =  sizeof(RECT) ; // etc
    gValueToSize[VALUE_QUALIFIED_NAME]      =  sizeof(DWORD) ; // currently

    //  VALUE_CONSTRAINT,  VALUE_INVALID_INSTALL_COMBO
    //      are currently all accessed via DWORD indicies to nodes.

    gValueToSize[VALUE_ORDERDEPENDENCY]     =  sizeof(ORDERDEPENDENCY) ;
    gValueToSize[VALUE_FONTSUB]             =  sizeof(TTFONTSUBTABLE) ;
        // not really used since its a special keyword.

    gValueToSize[VALUE_LIST]                =  sizeof(DWORD) ; // etc
        // only the index of first listnode is stored.


    for(dwI = 0 ; dwI < VALUE_MAX ; dwI++)
    {
        if(gValueToSize[dwI] > gValueToSize[VALUE_LARGEST])
            gValueToSize[VALUE_LARGEST] = gValueToSize[dwI] ;
    }

}



VOID  VinitGlobals(
            DWORD dwVerbosity,
            PGLOBL pglobl)
{
    DWORD       dwIndex;
    CONST PBYTE pubStar = "*"; // Used for initializing  gaarPPPrefix

    if(MAX_GID > 32)
        RIP(("MAX_GID > 32 violates some GPD parser assumptions.\n"));

    memset(pglobl, 0, sizeof(GLOBL));


    //  initialize all globals to default state.

    geErrorType = ERRTY_NONE ;  // start with a clean slate
    geErrorSev = ERRSEV_NONE ;


// check. Adding initializations that were previously done when variables were global
    gdwResDLL_ID      =  0 ;  // no Feature yet defined to hold Resource DLLs.
    gdwVerbosity      =  dwVerbosity ;
                            //  0 = min verbosity, 4 max verbosity.

    //  set preprocessor prefix to '*'
    gaarPPPrefix.pub = pubStar;
    gaarPPPrefix.dw  = 1;

    VinitValueToSize(pglobl) ;    //  size of value links.

    VinitAllowedTransitions(pglobl) ;  //  AllowedTransitions and Attributes
    (VOID) BinitClassIndexTable(pglobl) ; //  gcieTable[]  constant classes.
    VinitOperPrecedence(pglobl) ;  // arithmetic operators used in command
                            // parameters.

    //  no memory buffers allocated.

    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        gMasterTable[dwIndex].pubStruct = NULL ;
    }

    gMasterTable[MTI_STRINGHEAP].dwArraySize =    0x010000  ;
    gMasterTable[MTI_STRINGHEAP].dwMaxArraySize = 0x200000  ;
    gMasterTable[MTI_STRINGHEAP].dwElementSiz = sizeof(BYTE) ;

    gMasterTable[MTI_GLOBALATTRIB].dwArraySize = 1  ;
    gMasterTable[MTI_GLOBALATTRIB].dwMaxArraySize = 1  ;
    gMasterTable[MTI_GLOBALATTRIB].dwElementSiz =  sizeof(GLOBALATTRIB) ;

    gMasterTable[MTI_COMMANDTABLE].dwArraySize = CMD_MAX  ;
    gMasterTable[MTI_COMMANDTABLE].dwMaxArraySize = CMD_MAX  ;
    gMasterTable[MTI_COMMANDTABLE].dwElementSiz =  sizeof(ATREEREF) ;

    gMasterTable[MTI_ATTRIBTREE].dwArraySize = 5000  ;
    gMasterTable[MTI_ATTRIBTREE].dwMaxArraySize = 50,000  ;
    gMasterTable[MTI_ATTRIBTREE].dwElementSiz =  sizeof(ATTRIB_TREE) ;

    gMasterTable[MTI_COMMANDARRAY].dwArraySize =  500 ;
    gMasterTable[MTI_COMMANDARRAY].dwMaxArraySize = 5000 ;
    gMasterTable[MTI_COMMANDARRAY].dwElementSiz = sizeof(COMMAND)  ;

    gMasterTable[MTI_PARAMETER].dwArraySize =  500 ;
    gMasterTable[MTI_PARAMETER].dwMaxArraySize = 5000 ;
    gMasterTable[MTI_PARAMETER].dwElementSiz = sizeof(PARAMETER)  ;

    gMasterTable[MTI_TOKENSTREAM].dwArraySize =  3000 ;
    gMasterTable[MTI_TOKENSTREAM].dwMaxArraySize = 30000 ;
    gMasterTable[MTI_TOKENSTREAM].dwElementSiz = sizeof(TOKENSTREAM)  ;

    gMasterTable[MTI_LISTNODES].dwArraySize =  3000 ;
    gMasterTable[MTI_LISTNODES].dwMaxArraySize = 50000 ;
    gMasterTable[MTI_LISTNODES].dwElementSiz = sizeof(LISTNODE)  ;

    gMasterTable[MTI_CONSTRAINTS].dwArraySize =  300 ;
    gMasterTable[MTI_CONSTRAINTS].dwMaxArraySize = 5000 ;
    gMasterTable[MTI_CONSTRAINTS].dwElementSiz = sizeof(CONSTRAINTS)  ;

    gMasterTable[MTI_INVALIDCOMBO].dwArraySize =  40 ;
    gMasterTable[MTI_INVALIDCOMBO].dwMaxArraySize = 500 ;
    gMasterTable[MTI_INVALIDCOMBO].dwElementSiz = sizeof(INVALIDCOMBO )  ;

    gMasterTable[MTI_GPDFILEDATEINFO].dwArraySize =  10 ;
    gMasterTable[MTI_GPDFILEDATEINFO].dwMaxArraySize = 100 ;
    gMasterTable[MTI_GPDFILEDATEINFO].dwElementSiz = sizeof(GPDFILEDATEINFO )  ;


    /*  set dwArraySize = 0 for objects that are allocated on 2nd pass  */

    gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize = 0  ;
    gMasterTable[MTI_DFEATURE_OPTIONS].dwMaxArraySize = 300  ;
    gMasterTable[MTI_DFEATURE_OPTIONS].dwElementSiz =
                                    sizeof(DFEATURE_OPTIONS) ;

    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize = 0  ;
    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwMaxArraySize = 100  ;
    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwElementSiz =
                                        sizeof(DFEATURE_OPTIONS) ;


    gMasterTable[MTI_PRIORITYARRAY].dwArraySize = 0  ;
    gMasterTable[MTI_PRIORITYARRAY].dwMaxArraySize =
        gMasterTable[MTI_DFEATURE_OPTIONS].dwMaxArraySize +
        gMasterTable[MTI_SYNTHESIZED_FEATURES].dwMaxArraySize  ;
    gMasterTable[MTI_PRIORITYARRAY].dwElementSiz =
                                        sizeof(DWORD) ;

    gMasterTable[MTI_TTFONTSUBTABLE].dwArraySize = 0  ;
    gMasterTable[MTI_TTFONTSUBTABLE].dwMaxArraySize = 1000  ;
    gMasterTable[MTI_TTFONTSUBTABLE].dwElementSiz =  sizeof(TTFONTSUBTABLE) ;

    gMasterTable[MTI_FONTCART].dwArraySize = 0  ;
    gMasterTable[MTI_FONTCART].dwMaxArraySize = 500  ;
    gMasterTable[MTI_FONTCART].dwElementSiz =  sizeof(FONTCART) ;

    gMasterTable[MTI_SYMBOLROOT].dwArraySize =  SCL_NUMSYMCLASSES ;
    gMasterTable[MTI_SYMBOLROOT].dwMaxArraySize =  SCL_NUMSYMCLASSES ;
    gMasterTable[MTI_SYMBOLROOT].dwElementSiz = sizeof(DWORD)  ;

    gMasterTable[MTI_SYMBOLTREE].dwArraySize =  1500 ;
    gMasterTable[MTI_SYMBOLTREE].dwMaxArraySize =  16000 ;
    gMasterTable[MTI_SYMBOLTREE].dwElementSiz = sizeof(SYMBOLNODE)  ;

    gMasterTable[MTI_TMPHEAP].dwArraySize =    0x010000  ;
    gMasterTable[MTI_TMPHEAP].dwMaxArraySize = 0x200000  ;
    gMasterTable[MTI_TMPHEAP].dwElementSiz = sizeof(BYTE) ;

    gMasterTable[MTI_SOURCEBUFFER].dwArraySize =  10 ;
    gMasterTable[MTI_SOURCEBUFFER].dwMaxArraySize = 100 ;
    gMasterTable[MTI_SOURCEBUFFER].dwElementSiz = sizeof(SOURCEBUFFER)  ;

    //  NEWTOKENMAP is created from unused entries in TOKENMAP.

    gMasterTable[MTI_TOKENMAP].dwArraySize = 0x3000  ;
    gMasterTable[MTI_TOKENMAP].dwMaxArraySize = 0x40000  ;
    gMasterTable[MTI_TOKENMAP].dwElementSiz =  sizeof(TKMAP) ;

    gMasterTable[MTI_NEWTOKENMAP].dwArraySize = 0x3000  ;
    gMasterTable[MTI_NEWTOKENMAP].dwMaxArraySize = 0x40000   ;
    gMasterTable[MTI_NEWTOKENMAP].dwElementSiz =  sizeof(TKMAP) ;

    gMasterTable[MTI_BLOCKMACROARRAY].dwArraySize =  200 ;
    gMasterTable[MTI_BLOCKMACROARRAY].dwMaxArraySize = 3000  ;
    gMasterTable[MTI_BLOCKMACROARRAY].dwElementSiz =  sizeof(BLOCKMACRODICTENTRY) ;

    gMasterTable[MTI_VALUEMACROARRAY].dwArraySize = 800  ;
    gMasterTable[MTI_VALUEMACROARRAY].dwMaxArraySize = 4000  ;
    gMasterTable[MTI_VALUEMACROARRAY].dwElementSiz = sizeof(VALUEMACRODICTENTRY) ;

    gMasterTable[MTI_MACROLEVELSTACK].dwArraySize = 20  ;
    gMasterTable[MTI_MACROLEVELSTACK].dwMaxArraySize = 60  ;
    gMasterTable[MTI_MACROLEVELSTACK].dwElementSiz = sizeof(MACROLEVELSTATE)  ;

    gMasterTable[MTI_STSENTRY].dwArraySize = 20  ;
    gMasterTable[MTI_STSENTRY].dwMaxArraySize = 60  ;
    gMasterTable[MTI_STSENTRY].dwElementSiz =  sizeof(STSENTRY) ;

    gMasterTable[MTI_OP_QUEUE].dwArraySize = 40 ;
    gMasterTable[MTI_OP_QUEUE].dwMaxArraySize = 150  ;
    gMasterTable[MTI_OP_QUEUE].dwElementSiz =  sizeof(DWORD) ;

    gMasterTable[MTI_MAINKEYWORDTABLE].dwArraySize =  400 ;
    gMasterTable[MTI_MAINKEYWORDTABLE].dwMaxArraySize =  3000 ;
    gMasterTable[MTI_MAINKEYWORDTABLE].dwElementSiz =
            sizeof(KEYWORDTABLE_ENTRY) ;

    gMasterTable[MTI_RNGDICTIONARY].dwArraySize =  END_ATTR ;
    gMasterTable[MTI_RNGDICTIONARY].dwMaxArraySize =  END_ATTR ;
    gMasterTable[MTI_RNGDICTIONARY].dwElementSiz =  sizeof(RANGE) ;

    gMasterTable[MTI_FILENAMES].dwArraySize =  40 ;
    gMasterTable[MTI_FILENAMES].dwMaxArraySize =  100 ;
    gMasterTable[MTI_FILENAMES].dwElementSiz =  sizeof(PWSTR) ;

    gMasterTable[MTI_PREPROCSTATE].dwArraySize =  20 ;
    gMasterTable[MTI_PREPROCSTATE].dwMaxArraySize =  100 ;
    gMasterTable[MTI_PREPROCSTATE].dwElementSiz =  sizeof(PPSTATESTACK) ;

}


BOOL   BpreAllocateObjects(
            PGLOBL pglobl)
{
    DWORD   dwIndex, dwBytes ;

    /*  set dwArraySize = 0 for objects that are allocated on 2nd pass  */

    gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize =  0 ;
    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize =  0 ;
    gMasterTable[MTI_PRIORITYARRAY].dwArraySize =  0 ;
        //  allocation occurs at PostProcessing time.
    gMasterTable[MTI_TTFONTSUBTABLE].dwArraySize =  0 ;
    gMasterTable[MTI_FONTCART].dwArraySize =  0 ;


    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        gMasterTable[dwIndex].dwCurIndex =  0 ;
        //  do initialization first:  bug 308404
    }

    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        if(gMasterTable[dwIndex].dwArraySize)
        {
            dwBytes = gMasterTable[dwIndex].dwArraySize *
                        gMasterTable[dwIndex].dwElementSiz ;
            if(!(gMasterTable[dwIndex].pubStruct = MemAllocZ(dwBytes) ))
            {
                ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
                    dwBytes));
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                geErrorSev = ERRSEV_FATAL ;
                gdwMasterTabIndex = dwIndex ;
                return(FALSE) ;   // This is unrecoverable
            }
        }
    }
    //  do not use heap offset zero because OFFSET_TO_POINTER()
    //  macro will consider this an invalid value!
    gMasterTable[MTI_STRINGHEAP].dwCurIndex =  1 ;

    return(TRUE) ;
}

BOOL  BreturnBuffers(
            PGLOBL pglobl)
/*  FALSE  return indicates a go-round
    is needed.  Otherwise you are
    free to exit caller's loop.
*/
{
    DWORD   dwIndex ;


    //  better close all the memory mapped files.

    while(mCurFile)
    {
        mCurFile-- ;  // pop stack
        MemFree(mpSourcebuffer[mCurFile].pubSrcBuf) ;
    }

    vFreeFileNames(pglobl) ;


    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        if(gMasterTable[dwIndex].pubStruct)
        {
            MemFree(gMasterTable[dwIndex].pubStruct) ;
            gMasterTable[dwIndex].pubStruct = NULL ;
        }
    }
    //  resize one array if needed.
    if((geErrorType ==  ERRTY_MEMORY_ALLOCATION)  &&
        (geErrorSev == ERRSEV_RESTART))
    {
        if( gMasterTable[gdwMasterTabIndex].dwArraySize <
            gMasterTable[gdwMasterTabIndex].dwMaxArraySize )
        {
            DWORD  dwInc ;

            dwInc = gMasterTable[gdwMasterTabIndex].dwArraySize / 2 ;

            gMasterTable[gdwMasterTabIndex].dwArraySize +=
                (dwInc) ? (dwInc) : 1 ;
            geErrorSev = ERRSEV_NONE ;  //  hopefully this fixes
                    //  the problem.
            return(FALSE) ;   // go round needed.
        }
        else
        {
            geErrorSev = ERRSEV_FATAL ;
            ERR(("Internal error: memory usage exceeded hardcoded limits.\n"));
            ERR((" %d bytes requested, %d bytes allowed.\n",
                gMasterTable[gdwMasterTabIndex].dwArraySize,
                gMasterTable[gdwMasterTabIndex].dwMaxArraySize));
        }
    }
    return(TRUE);  // due to success or utter failure, don't
        // try anymore.
}


BOOL   BallocateCountableObjects(
            PGLOBL pglobl)
/*
    The first pass of BinterpretTokens() has registered all
    the unique symbols for the various constructs.
    By querying the SymbolID value stored at the root of
    each symbol tree, we know how many structures of each
    type to allocate.
*/
{
    DWORD   dwIndex, dwBytes ;
    PDWORD  pdwSymbolClass ;
    PSYMBOLNODE     psn ;

    pdwSymbolClass = (PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    if(pdwSymbolClass[SCL_FEATURES] != INVALID_INDEX)
    {
        gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize =
            psn[pdwSymbolClass[SCL_FEATURES]].dwSymbolID + 1 ;
    }
    //  else  no symbols registered - leave dwArraySize = 0 ;
    if(pdwSymbolClass[SCL_TTFONTNAMES] != INVALID_INDEX)
    {
        gMasterTable[MTI_TTFONTSUBTABLE].dwArraySize =
            psn[pdwSymbolClass[SCL_TTFONTNAMES]].dwSymbolID + 1;
    }
    if(pdwSymbolClass[SCL_FONTCART] != INVALID_INDEX)
    {
        gMasterTable[MTI_FONTCART].dwArraySize =
            psn[pdwSymbolClass[SCL_FONTCART]].dwSymbolID + 1;
    }



    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        if(gMasterTable[dwIndex].dwArraySize  &&
            !gMasterTable[dwIndex].pubStruct)
        {
            dwBytes = gMasterTable[dwIndex].dwArraySize *
                        gMasterTable[dwIndex].dwElementSiz ;
            if(!(gMasterTable[dwIndex].pubStruct = MemAllocZ(dwBytes) ))
            {
                ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
                    dwBytes));
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                geErrorSev = ERRSEV_FATAL ;
                gdwMasterTabIndex = dwIndex ;
                return(FALSE) ;   // This is unrecoverable
            }
            else
            {
                gMasterTable[dwIndex].dwCurIndex =  0 ;
            }
        }
    }

    return(TRUE) ;   // success !
}

BOOL   BinitPreAllocatedObjects(
            PGLOBL pglobl)
{
    DWORD    dwI, dwJ ;

    VinitMainKeywordTable(pglobl) ;    //  contents of mMainKeywordTable[] itself
    VinitDictionaryIndex(pglobl) ;  // inits  MTI_RNGDICTIONARY

    /*  init roots of symbol trees */

    for(dwI = 0  ;  dwI < gMasterTable[MTI_SYMBOLROOT].dwArraySize ; dwI++)
    {
        ((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct)[dwI] =
            INVALID_INDEX ;
    }

    //  init preprocessor state stack

    mdwNestingLevel = 0 ;
    mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
    mppStack[mdwNestingLevel].ifState =  IFS_ROOT;


    for(dwI = 0  ;  dwI < gMasterTable[MTI_TOKENMAP].dwArraySize ; dwI++)
    {
        ((PTKMAP)gMasterTable[MTI_TOKENMAP].pubStruct)[dwI].dwFlags =
            0 ;     //  must start with this field cleared.
    }


    for(dwI = 0  ;  dwI < gMasterTable[MTI_GLOBALATTRIB].dwArraySize
                    ; dwI++)
    {
        for(dwJ = 0  ;  dwJ < gMasterTable[MTI_GLOBALATTRIB].dwElementSiz /
                        sizeof(ATREEREF)  ; dwJ++)
        {
            ((PATREEREF)( (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].
                    pubStruct + dwI))[dwJ] =
                ATTRIB_UNINITIALIZED ;  // the GLOBALATTRIB struct is
                // comprised entirely of ATREEREFs.
        }
    }

    for(dwI = 0  ;  dwI < gMasterTable[MTI_COMMANDARRAY].dwArraySize ; dwI++)
    {
        ((PCOMMAND)gMasterTable[MTI_COMMANDARRAY].pubStruct)[dwI].
            dwCmdCallbackID  = NO_CALLBACK_ID ;
        ((PCOMMAND)gMasterTable[MTI_COMMANDARRAY].pubStruct)[dwI].
            ordOrder.eSection = SS_UNINITIALIZED ;
        ((PCOMMAND)gMasterTable[MTI_COMMANDARRAY].pubStruct)[dwI].
            dwStandardVarsList = END_OF_LIST ;
        ((PCOMMAND)gMasterTable[MTI_COMMANDARRAY].pubStruct)[dwI].
            bNoPageEject = FALSE ;
    }
    return(TRUE);
}




BOOL   BinitCountableObjects(
            PGLOBL pglobl)
{
    DWORD    dwI, dwJ ;
    PFONTCART   pfc ;

    for(dwI = 0  ;  dwI < gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize
                    ; dwI++)
    {
        for(dwJ = 0  ;  dwJ < gMasterTable[MTI_DFEATURE_OPTIONS].dwElementSiz /
                        sizeof(ATREEREF)  ; dwJ++)
        {
            ((PATREEREF)( (PDFEATURE_OPTIONS)gMasterTable[MTI_DFEATURE_OPTIONS].
                    pubStruct + dwI))[dwJ] =
                ATTRIB_UNINITIALIZED ;  // the DFEATURE_OPTIONS struct is
                // comprised entirely of ATREEREFs.
        }
    }
    for(dwI = 0  ;  dwI < gMasterTable[MTI_COMMANDTABLE].dwArraySize ; dwI++)
    {
        ((PATREEREF)gMasterTable[MTI_COMMANDTABLE].pubStruct)[dwI] =
                ATTRIB_UNINITIALIZED ;  //  the command table is
                // comprised entirely of ATREEREFs.
    }

    pfc = (PFONTCART)gMasterTable[MTI_FONTCART].pubStruct ;

    for(dwI = 0  ;  dwI < gMasterTable[MTI_FONTCART].dwArraySize ; dwI++)
    {
        pfc[dwI].dwFontLst = pfc[dwI].dwPortFontLst = pfc[dwI].dwLandFontLst =
            END_OF_LIST ;
    }
    return(TRUE);
}

#if 0

BOOL  BevaluateMacros(
            PGLOBL pglobl)
//  and expand shortcuts
{
    //  placeholder code - use original tokenMap
    //  BUG_BUG!!!!!  just swap the two entries for now.

    DWORD   dwTmp ;
    PBYTE   pubTmp ;

    dwTmp = gMasterTable[MTI_NEWTOKENMAP].dwArraySize ;
    gMasterTable[MTI_NEWTOKENMAP].dwArraySize =
        gMasterTable[MTI_TOKENMAP].dwArraySize  ;
    gMasterTable[MTI_TOKENMAP].dwArraySize = dwTmp ;

    dwTmp = gMasterTable[MTI_NEWTOKENMAP].dwMaxArraySize ;
    gMasterTable[MTI_NEWTOKENMAP].dwMaxArraySize =
        gMasterTable[MTI_TOKENMAP].dwMaxArraySize ;
    gMasterTable[MTI_TOKENMAP].dwMaxArraySize = dwTmp ;

    pubTmp = gMasterTable[MTI_NEWTOKENMAP].pubStruct ;
    gMasterTable[MTI_NEWTOKENMAP].pubStruct =
        gMasterTable[MTI_TOKENMAP].pubStruct ;
    gMasterTable[MTI_TOKENMAP].pubStruct = pubTmp  ;

    return(TRUE);
}

#endif

BOOL BpostProcess(
PWSTR   pwstrFileName,   // root GPD file
PGLOBL  pglobl)
{
    BOOL    bStatus ;
    DWORD   dwIndex, dwBytes, dwCount ;
    PDWORD  pdwPriority ;

/*

    check to see that all manditory fields
    have been initialized, warn otherwise.
    Have no way to reject entries once allocated.
    verify that all features referenced in switch
    statements are pickone.
    FeatureOption[ptkmap->dwValue].bReferenced = TRUE ;
    check that these features marked true are
    always of type PICK_ONE.


    reflect all constraints in list: if A constrains B, then B constrains A.


    Of course feature only qualified names are not permitted.
    so check for this here since we were cheap and used
    the same parsing routine as for InvalidInstallableCombinations.

    perform checks like all lists being converted must be of
    type installable.   Lists may be rooted at the feature
    or option level.   the Feature/Options named in the
    InvalidInstallableCombinations lists must also be *Installable.

*/


    BappendCommonFontsToPortAndLandscape(pglobl) ;
    BinitSpecialFeatureOptionFields(pglobl) ;

    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize =
        DwCountSynthFeatures(NULL, pglobl) ;

    gMasterTable[MTI_PRIORITYARRAY].dwArraySize =
        gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize +
        gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize ;

    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        if(gMasterTable[dwIndex].dwArraySize  &&
            !gMasterTable[dwIndex].pubStruct)
        {
            dwBytes = gMasterTable[dwIndex].dwArraySize *
                        gMasterTable[dwIndex].dwElementSiz ;
            if(!(gMasterTable[dwIndex].pubStruct = MemAllocZ(dwBytes) ))
            {
                ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
                    dwBytes));
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                geErrorSev = ERRSEV_FATAL ;
                gdwMasterTabIndex = dwIndex ;
                return(FALSE) ;   // This is unrecoverable
            }
            else
            {
                gMasterTable[dwIndex].dwCurIndex =  0 ;
            }
        }
    }


    if ( !BsetUQMFlag(pglobl))
        return FALSE;   //There are 2 ways that this function will return false.
                        // 1) When space from the heap cannot be allocated.
                        //      Soln: restart.
                        // 2) An unexpected Condition is encountered.
                        //      Soln: Fatal. Stop Parsing.


    VCountPrinterDocStickyFeatures(pglobl) ;
    (VOID)BConvertSpecVersionToDWORD(pwstrFileName, pglobl) ;
    BinitMiniRawBinaryData(pglobl) ;

    DwCountSynthFeatures(BCreateSynthFeatures, pglobl) ;


    BInitPriorityArray(pglobl) ;


    // save selected buffers to file

    bStatus = BconsolidateBuffers(pwstrFileName, pglobl);
    return(bStatus) ;
}



BOOL    BconsolidateBuffers(
PWSTR   pwstrFileName,   // root GPD file
PGLOBL  pglobl)
{
    DWORD   dwCurOffset , dwI;
    ENHARRAYREF   earTableContents[MTI_NUM_SAVED_OBJECTS] ;
    PBYTE   pubDest  ;  // points to new destination buffer
    PWSTR   pwstrBinaryFileName ;
    HANDLE  hFile;
    DWORD   dwBytesWritten,
            dwAlign = 4;  // padding for DWORD alignment of all sub buffers.
    BOOL    bResult = FALSE;
    OPTSELECT   optsel[MAX_COMBINED_OPTIONS] ;   // assume is large enough
    WIN32_FILE_ATTRIBUTE_DATA   File_Attributes ;

    //  first update dwCurIndex  for fixed allocation buffers
    //  since dwCurIndex  does not indicate elements used in this
    //  case.

    dwI = MTI_GLOBALATTRIB ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_DFEATURE_OPTIONS ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_SYNTHESIZED_FEATURES ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_PRIORITYARRAY ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_TTFONTSUBTABLE ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_COMMANDTABLE ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_FONTCART ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_SYMBOLROOT ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;


    //  at offset zero is the MINIRAWBINARYDATA header.
    //  Immediately after this is the array of ENHARRAYREFS
    //  supplying offsets to all other objects
    //  comprising the GPD binary.

    //  use the MTI_ defines to automate the copying of selected
    //  buffers.  Just make sure the subset that is being copied
    //  occupies the lower MTI_ indicies and is terminated by
    //  MTI_NUM_SAVED_OBJECTS.  The enumeration value will
    //  determine the order in which the various MTI_ buffers
    //  appear in the new buffer.

    dwCurOffset = sizeof(MINIRAWBINARYDATA) ;
    dwCurOffset += sizeof(ENHARRAYREF) * MTI_NUM_SAVED_OBJECTS ;
    dwCurOffset = (dwCurOffset + dwAlign - 1) / dwAlign ;
    dwCurOffset *= dwAlign ;

    for(dwI = 0 ; dwI < MTI_NUM_SAVED_OBJECTS ; dwI++)
    {
        earTableContents[dwI].loOffset = dwCurOffset ;
        earTableContents[dwI].dwCount =
                gMasterTable[dwI].dwCurIndex ;
        earTableContents[dwI].dwElementSiz =
                gMasterTable[dwI].dwElementSiz ;
        dwCurOffset += gMasterTable[dwI].dwElementSiz  *
                gMasterTable[dwI].dwCurIndex ;
        dwCurOffset = (dwCurOffset + dwAlign - 1) / dwAlign ;
        dwCurOffset *= dwAlign ;
    }
    pubDest = MemAlloc(dwCurOffset) ;  //  new destination buffer.
    if(!pubDest)
    {
        ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
            dwCurOffset));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        return(FALSE) ;   // This is unrecoverable
    }

    //  Last minute initializations:

    gmrbd.rbd.dwFileSize = dwCurOffset ;

    // gmrbd.pvPrivateData is not required by the .bud. It is only initialized
    // at snapshot time. Therefore putting it to NULL.
    // gmrbd.FileDateInfo is not used by the parser at all.

    gmrbd.rbd.pvPrivateData           = (PVOID) NULL;
    gmrbd.rbd.FileDateInfo.dwCount    = 0x00000000;
    gmrbd.rbd.FileDateInfo.loOffset   = (PTRREF)0x00000000;

    //  copy table of contents to start of dest buffer.

    memcpy(pubDest, &gmrbd , sizeof(MINIRAWBINARYDATA) ) ;
    memcpy(pubDest + sizeof(MINIRAWBINARYDATA), earTableContents ,
        sizeof(ENHARRAYREF) * MTI_NUM_SAVED_OBJECTS ) ;

    for(dwI = 0 ; dwI < MTI_NUM_SAVED_OBJECTS ; dwI++)
    {
        memcpy(
            pubDest + earTableContents[dwI].loOffset,   // dest
            gMasterTable[dwI].pubStruct,                // src
            earTableContents[dwI].dwCount *             // count
            earTableContents[dwI].dwElementSiz ) ;
    }


//  priority array is modified at snapshot time
//    if(!BinitDefaultOptionArray(optsel, pubDest))
//  can't call this function from parser DLL.

    // Generate a binary file name based the original filename
    // Create a file and write data to it



    if ((pwstrBinaryFileName = pwstrGenerateGPDfilename(pwstrFileName)) == NULL)
    {
        goto  CLEANUP_BconsolidateBuffers ;
    }


    if(GetFileAttributesEx(   (LPCTSTR) pwstrBinaryFileName,        // assumes widestrings
                    GetFileExInfoStandard,
                    (LPVOID) &File_Attributes)  )
    {
        //  BUD exists - attempt to delete .

        if(! DeleteFile((LPCTSTR) pwstrBinaryFileName))
        {
            WCHAR           awchTmpName[MAX_PATH],
                                    awchPath[MAX_PATH];
            PWSTR           pwstrLastBackSlash ;
                // cannot delete, attempt to rename

                wcsncpy(awchPath, pwstrBinaryFileName , MAX_PATH -1);

                pwstrLastBackSlash = wcsrchr(awchPath,TEXT('\\')) ;
                if (!pwstrLastBackSlash)
                    goto  CLEANUP_BconsolidateBuffers ;

                *(pwstrLastBackSlash + 1) = NUL;

                if(!GetTempFileName(
                      (LPCTSTR) awchPath,
                      TEXT("BUD"),  // pointer to filename prefix
                      0,        // number used to create temporary filename
                      (LPTSTR) awchTmpName))
                        goto  CLEANUP_BconsolidateBuffers ;
                            // failed to make tmp filename

                if( !MoveFileEx(
                              (LPCTSTR) pwstrBinaryFileName,
                              (LPCTSTR) awchTmpName,
                              MOVEFILE_REPLACE_EXISTING))
                        goto  CLEANUP_BconsolidateBuffers ;

                //  Now cause temp file to disappear on reboot.

                MoveFileEx(
                                  (LPCTSTR) awchTmpName,
                                  NULL,
                                  MOVEFILE_DELAY_UNTIL_REBOOT) ;
                           //  not a big problem if temp file cannot be deleted.
        }
    }




     if((hFile = CreateFile(pwstrBinaryFileName,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                            NULL)) != INVALID_HANDLE_VALUE)
    {
        bResult = WriteFile(hFile,
                            pubDest,
                            dwCurOffset,
                            &dwBytesWritten,
                            NULL) &&
                  (dwCurOffset == dwBytesWritten);

        CloseHandle(hFile);
    }

CLEANUP_BconsolidateBuffers:

    if (! bResult)
    {
        // Fail fatally if file cannot be opened for writing. If somebody else
        // has opened the file, we do not wait for that guy to close the file.
        // We simply fail.
        geErrorSev  = ERRSEV_FATAL;
        geErrorType = ERRTY_FILE_OPEN;
        ERR(("Unable to save binary GPD data to file.\n"));
    }


    if(pwstrBinaryFileName)
        MemFree(pwstrBinaryFileName);
    if(pubDest)
        MemFree(pubDest);
    return bResult;
}


BOOL    BexpandMemConfigShortcut(DWORD       dwSubType)
{
    BOOL    bStatus = FALSE;
    return(bStatus) ;
}
//  create strings in tmpHeap.
//  checks to make sure there are
//  enough slots in the tokenmap before proceeding.

BOOL    BexpandCommandShortcut(DWORD       dwSubType)
{
    BOOL    bStatus = FALSE;
    return(bStatus) ;
}
//  add sensor to detect colons  within a value as
//  this indicates something extra was tacked on.
//      if(ptkmap[*pdwTKMindex].dwFlags & TKMF_COLON)



/*

BOOL    BinitRemainingFields()
{
    This function initializes synthesized fields
    like these in the FeatureOption array.

    ATREEREF     atrOptIDvalue;  //   ID value

    ATREEREF     atrFeaFlags ;  //  invalid or not
    ATREEREF     atrPriority ;



    //  warning:  any non-attribtreeref added to
    //  the DFEATURE_OPTIONS structure will get stomped on in strange
    //  and wonderful ways by BinitPreAllocatedObjects.

    //  internal consistency checks.
    BOOL        bReferenced ;  // default is FALSE.
    DWORD       dwGID ,  //  GID tag
        dwNumOptions ;  // these are not read in from GPD file.
    maybe also determine count of DocSticky and PrinterSticky
    or maybe that is only stored in the RawBinaryData block.
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\globals.h ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  globals.h - this file contains the
    definitions for all global variables
    used by the parser.  */


/*  note:  const PARSERPROCS gParserProcs = {
    has been moved to helper1.c since it is also
    used in kernel mode.
*/


CONST CONSTANTDEF  gConstantsTable[] =
{

    {NULL, CL_BOOLEANTYPE},
    {"CL_BOOLEANTYPE", 0},
    {"FALSE", BT_FALSE},
    {"TRUE",  BT_TRUE},


    {NULL, CL_PRINTERTYPE},   // Note each section starts with
    {"CL_PRINTERTYPE", 0},
    {"PAGE", PT_PAGE},          // Null ptr , class.  This allows
    {"SERIAL", PT_SERIAL},      //  indexing code to work.
    {"TTY", PT_TTY},      //  indexing code to work.


    {NULL, CL_FEATURETYPE},
    {"CL_FEATURETYPE", 0},
    {"DOC_PROPERTY", FT_DOCPROPERTY},
    {"JOB_PROPERTY", FT_JOBPROPERTY},
    {"PRINTER_PROPERTY", FT_PRINTERPROPERTY},

    {NULL, CL_UITYPE},
    {"CL_UITYPE", 0},
    {"PICKMANY", UIT_PICKMANY},
    {"PICKONE", UIT_PICKONE},


    {NULL, CL_PROMPTTIME},
    {"CL_PROMPTTIME", 0},
    {"UI_SETUP", PROMPT_UISETUP},
    {"PRT_STARTDOC", PROMPT_PRTSTARTDOC},


    {NULL, CL_PAPERFEED_ORIENT},   //  constants defined in print.h
    {"CL_PAPERFEED_ORIENT", 0},
    { "FACEUP_NONE", DCBA_FACEUPNONE },
    { "FACEUP_CENTER", DCBA_FACEUPCENTER },
    { "FACEUP_LEFT", DCBA_FACEUPLEFT },
    { "FACEUP_RIGHT", DCBA_FACEUPRIGHT },
    { "FACEDOWN_NONE", DCBA_FACEDOWNNONE },
    { "FACEDOWN_CENTER", DCBA_FACEDOWNCENTER },
    { "FACEDOWN_LEFT", DCBA_FACEDOWNLEFT },
    { "FACEDOWN_RIGHT", DCBA_FACEDOWNRIGHT },


    {NULL, CL_COLORPLANE},
    {"CL_COLORPLANE", 0},
    {"YELLOW", COLOR_YELLOW},
    {"MAGENTA", COLOR_MAGENTA},
    {"CYAN", COLOR_CYAN},
    {"BLACK", COLOR_BLACK},
    {"RED", COLOR_RED},
    {"GREEN", COLOR_GREEN},
    {"BLUE", COLOR_BLUE},

    {NULL, CL_SEQSECTION},
    {"CL_SEQSECTION", 0},
    {"JOB_SETUP", SS_JOBSETUP},
    {"DOC_SETUP", SS_DOCSETUP},
    {"PAGE_SETUP", SS_PAGESETUP},
    {"PAGE_FINISH", SS_PAGEFINISH},
    {"DOC_FINISH", SS_DOCFINISH},
    {"JOB_FINISH", SS_JOBFINISH},


    {NULL, CL_RASTERCAPS},  // BUG_BUG!!!!!  placeholders
    {"CL_RASTERCAPS", 0},
    {"AT_PRINTABLE_X_ORIGIN", CXCR_AT_PRINTABLE_X_ORIGIN},
    {"AT_GRXDATA_ORIGIN", CXCR_AT_CURSOR_X_ORIGIN},


    {NULL, CL_TEXTCAPS },
    {"CL_TEXTCAPS", 0},
    {"TC_OP_CHARACTER", TEXTCAPS_OP_CHARACTER},
    {"TC_OP_STROKE", TEXTCAPS_OP_STROKE},
    {"TC_CP_STROKE", TEXTCAPS_CP_STROKE},
    {"TC_CR_90", TEXTCAPS_CR_90},
    {"TC_CR_ANY", TEXTCAPS_CR_ANY},
    {"TC_SF_X_YINDEP", TEXTCAPS_SF_X_YINDEP},
    {"TC_SA_DOUBLE", TEXTCAPS_SA_DOUBLE},
    {"TC_SA_INTEGER", TEXTCAPS_SA_INTEGER},
    {"TC_SA_CONTIN", TEXTCAPS_SA_CONTIN},
    {"TC_EA_DOUBLE", TEXTCAPS_EA_DOUBLE},
    {"TC_IA_ABLE", TEXTCAPS_IA_ABLE},
    {"TC_UA_ABLE", TEXTCAPS_UA_ABLE},
    {"TC_SO_ABLE", TEXTCAPS_SO_ABLE},
    {"TC_RA_ABLE", TEXTCAPS_RA_ABLE},
    {"TC_VA_ABLE", TEXTCAPS_VA_ABLE},


    {NULL, CL_MEMORYUSAGE},
    {"CL_MEMORYUSAGE", 0},
    {"FONT", MEMORY_FONT},
    {"RASTER", MEMORY_RASTER},
    {"VECTOR", MEMORY_VECTOR},


    {NULL, CL_RESELECTFONT},
    {"CL_RESELECTFONT", 0},
    {"AFTER_GRXDATA", RESELECTFONT_AFTER_GRXDATA},
    {"AFTER_XMOVE", RESELECTFONT_AFTER_XMOVE},
    {"AFTER_FF", RESELECTFONT_AFTER_FF},


    {NULL, CL_OEMPRINTINGCALLBACKS},
    {"CL_OEMPRINTINGCALLBACKS", 0},
    {"OEMDownloadFontheader", OEMPC_OEMDownloadFontheader},
    {"OEMDownloadCharGlyph", OEMPC_OEMDownloadCharGlyph},
    {"OEMTTDownloadMethod", OEMPC_OEMTTDownloadMethod},
    {"OEMOutputCharStr", OEMPC_OEMOutputCharStr},
    {"OEMImageProcessing", OEMPC_OEMImageProcessing},
    {"OEMCompression", OEMPC_OEMCompression},
    {"OEMHalftonePattern", OEMPC_OEMHalftonePattern},
    {"OEMFilterGraphics", OEMPC_OEMFilterGraphics},


    {NULL, CL_CURSORXAFTERCR},
    {"CL_CURSORXAFTERCR", 0},
    {"AT_PRINTABLE_X_ORIGIN", CXCR_AT_PRINTABLE_X_ORIGIN},
    {"AT_CURSOR_X_ORIGIN", CXCR_AT_CURSOR_X_ORIGIN},


    {NULL, CL_BADCURSORMOVEINGRXMODE},
    {"CL_BADCURSORMOVEINGRXMODE", 0},
    {"X_PORTRAIT", NOCM_X_PORTRAIT},
    {"X_LANDSCAPE", NOCM_X_LANDSCAPE},
    {"Y_PORTRAIT", NOCM_Y_PORTRAIT},
    {"Y_LANDSCAPE", NOCM_Y_LANDSCAPE},


//    {NULL, CL_SIMULATEXMOVE },
//    {"CL_SIMULATEXMOVE", 0},
//    {"SPACE_CHAR", SIMXM_USE_SPACECHAR},
//    {"NULL_GRX", SIMXM_USE_NULLGRX},

    {NULL, CL_PALETTESCOPE},
    {"CL_PALETTESCOPE", 0},
    {"RASTER", PALS_FOR_RASTER},
    {"TEXT", PALS_FOR_TEXT},
    {"VECTOR", PALS_FOR_VECTOR},

    {NULL, CL_OUTPUTDATAFORMAT},
    {"CL_OUTPUTDATAFORMAT", 0},
    {"H_BYTE", ODF_H_BYTE},
    {"V_BYTE", ODF_V_BYTE},

    {NULL, CL_STRIPBLANKS },
    {"CL_STRIPBLANKS", 0},
    {"LEADING", SB_LEADING},
    {"ENCLOSED", SB_ENCLOSED},
    {"TRAILING", SB_TRAILING},

    // may be obsolete.  if you delete must
    // also delete enum from CONSTANT_CLASSES.
    {NULL, CL_LANDSCAPEGRXROTATION },
    {"CL_LANDSCAPEGRXROTATION", 0},
    {"NONE", ROTATE_NONE},
    {"CC_90", ROTATE_90},
    {"CC_270", ROTATE_270},


    {NULL, CL_CURSORXAFTERSENDBLOCKDATA },
    {"CL_CURSORXAFTERSENDBLOCKDATA", 0},
    {"AT_GRXDATA_END", CXSBD_AT_GRXDATA_END},
    {"AT_GRXDATA_ORIGIN", CXSBD_AT_GRXDATA_ORIGIN},
    {"AT_CURSOR_X_ORIGIN", CXSBD_AT_CURSOR_X_ORIGIN},
        // explicitly changed to match GPD spec.



    {NULL, CL_CURSORYAFTERSENDBLOCKDATA },
    {"CL_CURSORYAFTERSENDBLOCKDATA", 0},
    {"NO_MOVE", CYSBD_NO_MOVE},
    {"AUTO_INCREMENT", CYSBD_AUTO_INCREMENT},



    {NULL, CL_CHARPOSITION },
    {"CL_CHARPOSITION", 0},
    {"UPPERLEFT", CP_UPPERLEFT},
    {"BASELINE", CP_BASELINE},
//    {"LOWERLEFT", CP_LOWERLEFT},


    {NULL, CL_FONTFORMAT},
    {"CL_FONTFORMAT", 0},
    {"HPPCL", FF_HPPCL},
    {"HPPCL_RES", FF_HPPCL_RES},
    {"HPPCL_OUTLINE", FF_HPPCL_OUTLINE},
    {"OEM_CALLBACK", FF_OEM_CALLBACK},



    {NULL, CL_QUERYDATATYPE},
    {"CL_QUERYDATATYPE", 0},
    {"DWORD", QDT_DWORD},
    {"CONCATENATED_STRINGS", QDT_CONCATENATED_STRINGS},


    {NULL, CL_YMOVEATTRIB},
    {"CL_YMOVEATTRIB", 0},
//    {"FAVOR_ABS", YMOVE_FAVOR_ABS},  dead
    {"FAVOR_LF", YMOVE_FAVOR_LINEFEEDSPACING},
    {"SEND_CR_FIRST", YMOVE_SENDCR_FIRST},

    {NULL, CL_DLSYMBOLSET},
    {"CL_DLSYMBOLSET", 0},
    {"PC_8", DLSS_PC8},
    {"ROMAN_8", DLSS_ROMAN8},


    {NULL, CL_CURXAFTER_RECTFILL},
    {"CL_CURXAFTER_RECTFILL", 0},
    {"AT_RECT_X_ORIGIN", CXARF_AT_RECT_X_ORIGIN},
    {"AT_RECT_X_END", CXARF_AT_RECT_X_END},

    {NULL, CL_CURYAFTER_RECTFILL},
    {"CL_CURYAFTER_RECTFILL", 0},
    {"AT_RECT_Y_ORIGIN", CYARF_AT_RECT_Y_ORIGIN},
    {"AT_RECT_Y_END", CYARF_AT_RECT_Y_END},

#ifndef WINNT_40

    {NULL, CL_PRINTRATEUNIT},
    {"CL_PRINTRATEUNIT", 0},
    {"PPM", PRINTRATEUNIT_PPM},
    {"CPS", PRINTRATEUNIT_CPS},
    {"LPM", PRINTRATEUNIT_LPM},
    {"IPM", PRINTRATEUNIT_IPM},
    {"LPS", PRINTRATEUNIT_LPS},   // not supported in wingdi.h
    {"IPS", PRINTRATEUNIT_IPS},     //   not supported
#endif

    {NULL, CL_RASTERMODE},
    {"CL_RASTERMODE", 0},
    {"DIRECT", RASTMODE_DIRECT},
    {"INDEXED", RASTMODE_INDEXED},

    {NULL, CL_QUALITYSETTING},
    {"CL_QUALITYSETTING", 0},
    {"DRAFTQUALITY", QS_DRAFT},
    {"BETTERQUALITY", QS_BETTER},
    {"BESTQUALITY", QS_BEST},


    //  ---- Standard Variable Names Section ---- //



    {NULL, CL_STANDARD_VARS},
    {"CL_STANDARD_VARS", 0},
    {"NumOfDataBytes", SV_NUMDATABYTES},
    {"RasterDataWidthInBytes", SV_WIDTHINBYTES},
    {"RasterDataHeightInPixels", SV_HEIGHTINPIXELS},
    {"NumOfCopies", SV_COPIES},
    {"PrintDirInCCDegrees", SV_PRINTDIRECTION},
    {"DestX", SV_DESTX},
    {"DestY", SV_DESTY},
    {"DestXRel", SV_DESTXREL},
    {"DestYRel", SV_DESTYREL},
    {"LinefeedSpacing", SV_LINEFEEDSPACING},
    {"RectXSize", SV_RECTXSIZE},
    {"RectYSize", SV_RECTYSIZE},
    {"GrayPercentage", SV_GRAYPERCENT},
    {"NextFontID", SV_NEXTFONTID},
    {"NextGlyph", SV_NEXTGLYPH},
    {"PhysPaperLength", SV_PHYSPAPERLENGTH},
    {"PhysPaperWidth", SV_PHYSPAPERWIDTH},
    {"FontHeight", SV_FONTHEIGHT},
    {"FontWidth", SV_FONTWIDTH},
    {"FontMaxWidth", SV_FONTMAXWIDTH},
    {"FontBold", SV_FONTBOLD},
    {"FontItalic", SV_FONTITALIC},
    {"FontUnderline", SV_FONTUNDERLINE},
    {"FontStrikeThru", SV_FONTSTRIKETHRU},
    {"CurrentFontID", SV_CURRENTFONTID},
    {"TextYRes", SV_TEXTYRES},
    {"TextXRes", SV_TEXTXRES},
//  #ifdef  BETA2
    {"GraphicsYRes", SV_GRAPHICSYRES},
    {"GraphicsXRes", SV_GRAPHICSXRES},
//  #endif
    {"Rop3", SV_ROP3},
    {"RedValue", SV_REDVALUE},
    {"GreenValue", SV_GREENVALUE},
    {"BlueValue", SV_BLUEVALUE},
    {"PaletteIndexToProgram", SV_PALETTEINDEXTOPROGRAM},
    {"CurrentPaletteIndex", SV_CURRENTPALETTEINDEX},
    {"PatternBrushType", SV_PATTERNBRUSH_TYPE},
    {"PatternBrushID", SV_PATTERNBRUSH_ID},
    {"PatternBrushSize", SV_PATTERNBRUSH_SIZE},
    {"CursorOriginX", SV_CURSORORIGINX},
    {"CursorOriginY", SV_CURSORORIGINY},
    {"PageNumber",   SV_PAGENUMBER} ,


    //  ---- Unidrv Command Names Section ---- //


    {NULL, CL_COMMAND_NAMES},
    {"CL_COMMAND_NAMES", 0},
    {"CmdSelect", CMD_SELECT},
    {"CmdStartJob", CMD_STARTJOB},
    {"CmdStartDoc", CMD_STARTDOC},
    {"CmdStartPage", CMD_STARTPAGE},
    {"CmdEndPage", CMD_ENDPAGE},
    {"CmdEndDoc", CMD_ENDDOC},
    {"CmdEndJob", CMD_ENDJOB},
    {"CmdCopies", CMD_COPIES},
//    {"CmdCollate", CMD_COLLATE},
    {"CmdSleepTimeOut", CMD_SLEEPTIMEOUT},

    //
    //  GENERAL
    //

    //
    // CURSOR CONTROL
    //


    {"CmdXMoveAbsolute", CMD_XMOVEABSOLUTE},
    {"CmdXMoveRelLeft", CMD_XMOVERELLEFT},
    {"CmdXMoveRelRight", CMD_XMOVERELRIGHT},
    {"CmdYMoveAbsolute", CMD_YMOVEABSOLUTE},
    {"CmdYMoveRelUp", CMD_YMOVERELUP},
    {"CmdYMoveRelDown", CMD_YMOVERELDOWN},
//    {"CmdXYMoveAbsolute", CMD_XYMOVEABSOLUTE},

    {"CmdSetSimpleRotation", CMD_SETSIMPLEROTATION},
    {"CmdSetAnyRotation", CMD_SETANYROTATION},
    {"CmdUniDirectionOn", CMD_UNIDIRECTIONON},
    {"CmdUniDirectionOff", CMD_UNIDIRECTIONOFF},
    {"CmdSetLineSpacing", CMD_SETLINESPACING},
    {"CmdPushCursor", CMD_PUSHCURSOR},
    {"CmdPopCursor", CMD_POPCURSOR},
    {"CmdBackSpace", CMD_BACKSPACE},
    {"CmdFF", CMD_FORMFEED},
    {"CmdCR", CMD_CARRIAGERETURN},
    {"CmdLF", CMD_LINEFEED},


    //
    // COLOR
    //

    {"CmdSelectBlackColor", CMD_SELECTBLACKCOLOR},
    {"CmdSelectRedColor", CMD_SELECTREDCOLOR},
    {"CmdSelectGreenColor", CMD_SELECTGREENCOLOR},
    {"CmdSelectYellowColor", CMD_SELECTYELLOWCOLOR},
    {"CmdSelectBlueColor", CMD_SELECTBLUECOLOR},
    {"CmdSelectMagentaColor", CMD_SELECTMAGENTACOLOR},
    {"CmdSelectCyanColor", CMD_SELECTCYANCOLOR},
    {"CmdSelectWhiteColor", CMD_SELECTWHITECOLOR},
    {"CmdBeginPaletteDef", CMD_BEGINPALETTEDEF},
    {"CmdEndPaletteDef", CMD_ENDPALETTEDEF},
    {"CmdDefinePaletteEntry", CMD_DEFINEPALETTEENTRY},
    {"CmdBeginPaletteReDef", CMD_BEGINPALETTEREDEF},
    {"CmdEndPaletteReDef", CMD_ENDPALETTEREDEF},
    {"CmdReDefinePaletteEntry", CMD_REDEFINEPALETTEENTRY},
    {"CmdSelectPaletteEntry", CMD_SELECTPALETTEENTRY},
    {"CmdPushPalette", CMD_PUSHPALETTE},
    {"CmdPopPalette", CMD_POPPALETTE},

    //
    // BRUSH SELECTION
    //

    {"CmdDownloadPattern", CMD_DOWNLOAD_PATTERN},
    {"CmdSelectPattern", CMD_SELECT_PATTERN},
    {"CmdSelectWhiteBrush", CMD_SELECT_WHITEBRUSH},
    {"CmdSelectBlackBrush", CMD_SELECT_BLACKBRUSH},



    //
    // DATACOMPRESSION
    //

//    {"CmdOverlayRegStart", CMD_OVERLAYREGSTART},
//    {"CmdOverlayRegEnd", CMD_OVERLAYREGEND},
//    {"CmdEnableOverlay", CMD_ENABLEOVERLAY},
//    {"CmdDisableOverlay", CMD_DISABLEOVERLAY},
    {"CmdEnableTIFF4", CMD_ENABLETIFF4},
    {"CmdEnableDRC", CMD_ENABLEDRC},
    {"CmdEnableFE_RLE", CMD_ENABLEFERLE},
    {"CmdEnableOEMComp", CMD_ENABLEOEMCOMP},
    {"CmdDisableCompression", CMD_DISABLECOMPRESSION},

    //
    //  Raster Data Emission
    //

    {"CmdBeginRaster", CMD_BEGINRASTER},
    {"CmdEndRaster", CMD_ENDRASTER},
    {"CmdSetDestBmpWidth", CMD_SETDESTBMPWIDTH},
    {"CmdSetDestBmpHeight", CMD_SETDESTBMPHEIGHT},
    {"CmdSetSrcBmpWidth", CMD_SETSRCBMPWIDTH},
    {"CmdSetSrcBmpHeight", CMD_SETSRCBMPHEIGHT},
    {"CmdSendBlockData", CMD_SENDBLOCKDATA},
    {"CmdEndBlockData", CMD_ENDBLOCKDATA},
    {"CmdSendRedData", CMD_SENDREDDATA},
    {"CmdSendGreenData", CMD_SENDGREENDATA},
    {"CmdSendBlueData", CMD_SENDBLUEDATA},
    {"CmdSendCyanData", CMD_SENDCYANDATA},
    {"CmdSendMagentaData", CMD_SENDMAGENTADATA},
    {"CmdSendYellowData", CMD_SENDYELLOWDATA},
    {"CmdSendBlackData", CMD_SENDBLACKDATA},

    //
    //  Font Downloading
    //

    {"CmdSetFontID", CMD_SETFONTID},
    {"CmdSelectFontID", CMD_SELECTFONTID},
    {"CmdSetCharCode", CMD_SETCHARCODE},
//  #ifdef  BETA2
    {"CmdDeselectFontID", CMD_DESELECTFONTID},
    {"CmdSelectFontHeight", CMD_SELECTFONTHEIGHT},
    {"CmdSelectFontWidth", CMD_SELECTFONTWIDTH},
//  #endif
    {"CmdDeleteFont", CMD_DELETEFONT},

    //
    //  Font Simulation
    //

    {"CmdSetFontSim", CMD_SETFONTSIM},
    {"CmdBoldOn", CMD_BOLDON},
    {"CmdBoldOff", CMD_BOLDOFF},
    {"CmdItalicOn", CMD_ITALICON},
    {"CmdItalicOff", CMD_ITALICOFF},
    {"CmdUnderlineOn", CMD_UNDERLINEON},
    {"CmdUnderlineOff", CMD_UNDERLINEOFF},
    {"CmdStrikeThruOn", CMD_STRIKETHRUON},
    {"CmdStrikeThruOff", CMD_STRIKETHRUOFF},
    {"CmdWhiteTextOn", CMD_WHITETEXTON},
    {"CmdWhiteTextOff", CMD_WHITETEXTOFF},
    {"CmdSelectSingleByteMode", CMD_SELECTSINGLEBYTEMODE},
    {"CmdSelectDoubleByteMode", CMD_SELECTDOUBLEBYTEMODE},
    {"CmdVerticalPrintingOn", CMD_VERTICALPRINTINGON},
    {"CmdVerticalPrintingOff", CMD_VERTICALPRINTINGOFF},
    {"CmdClearAllFontAttribs", CMD_CLEARALLFONTATTRIBS},

    //
    // Misc
    //
    {"CmdSetTextHTAlgo",     CMD_SETTEXTHTALGO},
    {"CmdSetGraphicsHTAlgo", CMD_SETGRAPHICSHTALGO},
    {"CmdSetPhotoHTAlgo",    CMD_SETPHOTOHTALGO},

    //
    //  Vector Printing
    //

    {"CmdSetRectWidth", CMD_SETRECTWIDTH},
    {"CmdSetRectHeight", CMD_SETRECTHEIGHT},
    {"CmdSetRectSize", CMD_SETRECTSIZE},
    {"CmdRectGrayFill", CMD_RECTGRAYFILL},
    {"CmdRectWhiteFill", CMD_RECTWHITEFILL},
    {"CmdRectBlackFill", CMD_RECTBLACKFILL},

#if 0
    {"CmdSetTransparencyMode", CMD_SETTRANSPARENCYMODE},
    {"CmdSetOpaqueMode", CMD_SETOPAQUEMODE},
    {"CmdSetClipRect", CMD_SETCLIPRECT},
    {"CmdSetClipPath", CMD_SETCLIPPATH},
    {"CmdSetR3Blackness", CMD_SETR3BLACKNESS},
    {"CmdSetR3PatInvert", CMD_SETR3PATINVERT},
    {"CmdSetR3SrcInvert", CMD_SETR3SRCINVERT},
    {"CmdSetR3MergePaint", CMD_SETR3MERGEPAINT},
    {"CmdSetR3MergeCopy", CMD_SETR3MERGECOPY},
    {"CmdSetR3SrcCopy", CMD_SETR3SRCCOPY},
    {"CmdSetR3SrcPaint", CMD_SETR3SRCPAINT},
    {"CmdSetR3PatCopy", CMD_SETR3PATCOPY},
    {"CmdSetR3PatPaint", CMD_SETR3PATPAINT},
    {"CmdSetR3Whiteness", CMD_SETR3WHITENESS},
    {"CmdSetR3Code", CMD_SETR3CODE},
#endif



    //  ---- reserved symbol names  for each construct keyword ---- //

    {NULL, CL_CONS_FEATURES},
    {"CL_CONS_FEATURES", 0},
    {"PaperSize", GID_PAGESIZE},
    {"Resolution", GID_RESOLUTION},
    {"MediaType", GID_MEDIATYPE},
    {"InputBin", GID_INPUTSLOT},
    {"Duplex", GID_DUPLEX},
    {"Memory", GID_MEMOPTION},
    {"ColorMode", GID_COLORMODE},
    {"Orientation", GID_ORIENTATION},
    {"Halftone", GID_HALFTONING},
    {"PageProtect", GID_PAGEPROTECTION},
    {"Collate", GID_COLLATE},
    {"OutputBin", GID_OUTPUTBIN},
    // "Stapling"   is a special Feature string recognized by the UI
    //  though it is not associated with a GID value.

    // all other predefined GIDs are Pscript specific.


    {NULL, CL_CONS_PAPERSIZE},
    {"CL_CONS_PAPERSIZE", 0},

    {"LETTER", DMPAPER_LETTER},
    {"LETTERSMALL", DMPAPER_LETTERSMALL},
    {"TABLOID", DMPAPER_TABLOID},
    {"LEDGER", DMPAPER_LEDGER},
    {"LEGAL", DMPAPER_LEGAL},
    {"STATEMENT", DMPAPER_STATEMENT},
    {"EXECUTIVE", DMPAPER_EXECUTIVE},
    {"A3", DMPAPER_A3},
    {"A4", DMPAPER_A4},
    {"A4SMALL", DMPAPER_A4SMALL},
    {"A5", DMPAPER_A5},
    {"B4", DMPAPER_B4},
    {"B5", DMPAPER_B5},
    {"FOLIO", DMPAPER_FOLIO},
    {"QUARTO", DMPAPER_QUARTO},
    {"10X14", DMPAPER_10X14},
    {"11X17", DMPAPER_11X17},
    {"NOTE", DMPAPER_NOTE},
    {"ENV_9", DMPAPER_ENV_9},
    {"ENV_10", DMPAPER_ENV_10},
    {"ENV_11", DMPAPER_ENV_11},
    {"ENV_12", DMPAPER_ENV_12},
    {"ENV_14", DMPAPER_ENV_14},
    {"CSHEET", DMPAPER_CSHEET},
    {"DSHEET", DMPAPER_DSHEET},
    {"ESHEET", DMPAPER_ESHEET},
    {"ENV_DL", DMPAPER_ENV_DL},
    {"ENV_C5", DMPAPER_ENV_C5},
    {"ENV_C3", DMPAPER_ENV_C3},
    {"ENV_C4", DMPAPER_ENV_C4},
    {"ENV_C6", DMPAPER_ENV_C6},
    {"ENV_C65", DMPAPER_ENV_C65},
    {"ENV_B4", DMPAPER_ENV_B4},
    {"ENV_B5", DMPAPER_ENV_B5},
    {"ENV_B6", DMPAPER_ENV_B6},
    {"ENV_ITALY", DMPAPER_ENV_ITALY},
    {"ENV_MONARCH", DMPAPER_ENV_MONARCH},
    {"ENV_PERSONAL", DMPAPER_ENV_PERSONAL},
    {"FANFOLD_US", DMPAPER_FANFOLD_US},
    {"FANFOLD_STD_GERMAN", DMPAPER_FANFOLD_STD_GERMAN},
    {"FANFOLD_LGL_GERMAN", DMPAPER_FANFOLD_LGL_GERMAN},
    {"ISO_B4", DMPAPER_ISO_B4},
    {"JAPANESE_POSTCARD", DMPAPER_JAPANESE_POSTCARD},
    {"9X11", DMPAPER_9X11},
    {"10X11", DMPAPER_10X11},
    {"15X11", DMPAPER_15X11},
    {"ENV_INVITE", DMPAPER_ENV_INVITE},
    {"LETTER_EXTRA", DMPAPER_LETTER_EXTRA},
    {"LEGAL_EXTRA", DMPAPER_LEGAL_EXTRA},
    {"TABLOID_EXTRA", DMPAPER_TABLOID_EXTRA},
    {"A4_EXTRA", DMPAPER_A4_EXTRA},
    {"LETTER_TRANSVERSE", DMPAPER_LETTER_TRANSVERSE},
    {"A4_TRANSVERSE", DMPAPER_A4_TRANSVERSE},
    {"LETTER_EXTRA_TRANSVERSE", DMPAPER_LETTER_EXTRA_TRANSVERSE},
    {"A_PLUS", DMPAPER_A_PLUS},
    {"B_PLUS", DMPAPER_B_PLUS},
    {"LETTER_PLUS", DMPAPER_LETTER_PLUS},
    {"A4_PLUS", DMPAPER_A4_PLUS},
    {"A5_TRANSVERSE", DMPAPER_A5_TRANSVERSE},
    {"B5_TRANSVERSE", DMPAPER_B5_TRANSVERSE},
    {"A3_EXTRA", DMPAPER_A3_EXTRA},
    {"A5_EXTRA", DMPAPER_A5_EXTRA},
    {"B5_EXTRA", DMPAPER_B5_EXTRA},
    {"A2", DMPAPER_A2},
    {"A3_TRANSVERSE", DMPAPER_A3_TRANSVERSE},
    {"A3_EXTRA_TRANSVERSE", DMPAPER_A3_EXTRA_TRANSVERSE},
    #ifndef WINNT_40
    {"DBL_JAPANESE_POSTCARD", DMPAPER_DBL_JAPANESE_POSTCARD},
    {"A6", DMPAPER_A6},
    {"JENV_KAKU2", DMPAPER_JENV_KAKU2},
    {"JENV_KAKU3", DMPAPER_JENV_KAKU3},
    {"JENV_CHOU3", DMPAPER_JENV_CHOU3},
    {"JENV_CHOU4", DMPAPER_JENV_CHOU4},
    {"LETTER_ROTATED", DMPAPER_LETTER_ROTATED},
    {"A3_ROTATED", DMPAPER_A3_ROTATED},
    {"A4_ROTATED", DMPAPER_A4_ROTATED},
    {"A5_ROTATED", DMPAPER_A5_ROTATED},
    {"B4_JIS_ROTATED", DMPAPER_B4_JIS_ROTATED},
    {"B5_JIS_ROTATED", DMPAPER_B5_JIS_ROTATED},
    {"JAPANESE_POSTCARD_ROTATED", DMPAPER_JAPANESE_POSTCARD_ROTATED},
    {"DBL_JAPANESE_POSTCARD_ROTATED", DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED},
    {"A6_ROTATED", DMPAPER_A6_ROTATED},
    {"JENV_KAKU2_ROTATED", DMPAPER_JENV_KAKU2_ROTATED},
    {"JENV_KAKU3_ROTATED", DMPAPER_JENV_KAKU3_ROTATED},
    {"JENV_CHOU3_ROTATED", DMPAPER_JENV_CHOU3_ROTATED},
    {"JENV_CHOU4_ROTATED", DMPAPER_JENV_CHOU4_ROTATED},
    {"B6_JIS", DMPAPER_B6_JIS},
    {"B6_JIS_ROTATED", DMPAPER_B6_JIS_ROTATED},
    {"12X11", DMPAPER_12X11},
    {"JENV_YOU4", DMPAPER_JENV_YOU4},
    {"JENV_YOU4_ROTATED", DMPAPER_JENV_YOU4_ROTATED},
    {"P16K", DMPAPER_P16K},
    {"P32K", DMPAPER_P32K},
    {"P32KBIG", DMPAPER_P32KBIG},
    {"PENV_1", DMPAPER_PENV_1},
    {"PENV_2", DMPAPER_PENV_2},
    {"PENV_3", DMPAPER_PENV_3},
    {"PENV_4", DMPAPER_PENV_4 },
    {"PENV_5", DMPAPER_PENV_5 },
    {"PENV_6", DMPAPER_PENV_6 },
    {"PENV_7", DMPAPER_PENV_7 },
    {"PENV_8", DMPAPER_PENV_8 },
    {"PENV_9", DMPAPER_PENV_9 },
    {"PENV_10", DMPAPER_PENV_10},
    {"P16K_ROTATED", DMPAPER_P16K_ROTATED},
    {"P32K_ROTATED", DMPAPER_P32K_ROTATED},
    {"P32KBIG_ROTATED", DMPAPER_P32KBIG_ROTATED  },
    {"PENV_1_ROTATED", DMPAPER_PENV_1_ROTATED   },
    {"PENV_2_ROTATED", DMPAPER_PENV_2_ROTATED   },
    {"PENV_3_ROTATED", DMPAPER_PENV_3_ROTATED   },
    {"PENV_4_ROTATED", DMPAPER_PENV_4_ROTATED   },
    {"PENV_5_ROTATED", DMPAPER_PENV_5_ROTATED  },
    {"PENV_6_ROTATED", DMPAPER_PENV_6_ROTATED  },
    {"PENV_7_ROTATED", DMPAPER_PENV_7_ROTATED   },
    {"PENV_8_ROTATED", DMPAPER_PENV_8_ROTATED   },
    {"PENV_9_ROTATED", DMPAPER_PENV_9_ROTATED   },
    {"PENV_10_ROTATED", DMPAPER_PENV_10_ROTATED  },
    #endif
    {"CUSTOMSIZE", DMPAPER_USER  },
    //   DMPAPER_USER and beyond



    {NULL, CL_CONS_MEDIATYPE},
    {"CL_CONS_MEDIATYPE", 0},
    {"STANDARD", DMMEDIA_STANDARD},
    {"TRANSPARENCY", DMMEDIA_TRANSPARENCY},
    {"GLOSSY", DMMEDIA_GLOSSY},
    //   DMMEDIA_USER and beyond



    {NULL, CL_CONS_INPUTSLOT},
    {"CL_CONS_INPUTSLOT", 0},
    {"FORMSOURCE", DMBIN_FORMSOURCE },
    {"UPPER", DMBIN_UPPER},
    {"LOWER", DMBIN_LOWER},
    {"MIDDLE", DMBIN_MIDDLE},
    {"MANUAL", DMBIN_MANUAL},
    {"ENVFEED", DMBIN_ENVELOPE},
    {"ENVMANUAL", DMBIN_ENVMANUAL},
    {"AUTO", DMBIN_AUTO},
    {"TRACTOR", DMBIN_TRACTOR},
    {"SMALLFMT", DMBIN_SMALLFMT},
    {"LARGEFMT", DMBIN_LARGEFMT},
    {"LARGECAPACITY", DMBIN_LARGECAPACITY},
    {"CASSETTE", DMBIN_CASSETTE},

    //   DMBIN_USER and beyond


    {NULL, CL_CONS_DUPLEX},
    {"CL_CONS_DUPLEX", 0},
    {"NONE", DMDUP_SIMPLEX},
    {"VERTICAL", DMDUP_VERTICAL},
    {"HORIZONTAL", DMDUP_HORIZONTAL},

    //  No custom options.


    {NULL, CL_CONS_ORIENTATION},
    {"CL_CONS_ORIENTATION", 0},
    {"PORTRAIT", ROTATE_NONE},
    {"LANDSCAPE_CC90", ROTATE_90},
    {"LANDSCAPE_CC270", ROTATE_270},
    //  No custom options.


    {NULL, CL_CONS_PAGEPROTECT},
    {"CL_CONS_PAGEPROTECT", 0},
    {"ON",  PAGEPRO_ON},
    {"OFF",  PAGEPRO_OFF},
    //  No custom options.


    {NULL, CL_CONS_COLLATE},
    {"CL_CONS_COLLATE", 0},
    {"ON",  DMCOLLATE_TRUE},
    {"OFF",  DMCOLLATE_FALSE},
    //  No custom options.

    {NULL, CL_CONS_HALFTONE},
    {"CL_CONS_HALFTONE", 0},
    {"HT_PATSIZE_2x2",  HT_PATSIZE_2x2},
    {"HT_PATSIZE_2x2_M",  HT_PATSIZE_2x2_M},
    {"HT_PATSIZE_4x4",  HT_PATSIZE_4x4},
    {"HT_PATSIZE_4x4_M",  HT_PATSIZE_4x4_M},
    {"HT_PATSIZE_6x6",  HT_PATSIZE_6x6},
    {"HT_PATSIZE_6x6_M",  HT_PATSIZE_6x6_M},
    {"HT_PATSIZE_8x8",  HT_PATSIZE_8x8},
    {"HT_PATSIZE_8x8_M",  HT_PATSIZE_8x8_M},
    {"HT_PATSIZE_10x10",  HT_PATSIZE_10x10},
    {"HT_PATSIZE_10x10_M",  HT_PATSIZE_10x10_M},
    {"HT_PATSIZE_12x12",  HT_PATSIZE_12x12},
    {"HT_PATSIZE_12x12_M",  HT_PATSIZE_12x12_M},
    {"HT_PATSIZE_14x14",  HT_PATSIZE_14x14},
    {"HT_PATSIZE_14x14_M",  HT_PATSIZE_14x14_M},
    {"HT_PATSIZE_16x16",  HT_PATSIZE_16x16},
    {"HT_PATSIZE_16x16_M",  HT_PATSIZE_16x16_M},
    #ifndef WINNT_40
    {"HT_PATSIZE_SUPERCELL",  HT_PATSIZE_SUPERCELL},
    {"HT_PATSIZE_SUPERCELL_M",  HT_PATSIZE_SUPERCELL_M},
    #endif
    {"HT_PATSIZE_AUTO",  HT_PATSIZE_AUTO},


    {NULL, CL_NUMCLASSES}         //  signifies end of table.
}  ;

// This global is now in gpdparse.h in the structure GLOBL
// CLASSINDEXENTRY  gcieTable[CL_NUMCLASSES] ;
//

CONST PBYTE   gpubStateNames[] =
{
    "STATE_ROOT",
    "STATE_UIGROUP",
    "STATE_FEATURE",
    "STATE_OPTIONS",
    "STATE_SWITCH_ROOT",
    "STATE_SWITCH_FEATURE",
    "STATE_SWITCH_OPTION",
    "STATE_CASE_ROOT",
    "STATE_DEFAULT_ROOT",
    "STATE_CASE_FEATURE",
    "STATE_DEFAULT_FEATURE",
    "STATE_CASE_OPTION",
    "STATE_DEFAULT_OPTION",
    "STATE_COMMAND",
    "STATE_FONTCART",
    "STATE_TTFONTSUBS",
    "STATE_OEM",
    //  any other passive construct
    "STATE_LAST",   //  must terminate list of valid states
    "STATE_INVALID"  //  must be after STATE_LAST
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\declares.h ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  declares.h - functions declarations

 History of Changes
  9/30/98 --hsingh--
          Added delcaration of function BsetUQMFlag(). This function
          enables making the UpdateQualityMacro? keyword optional in
          .gpd file.
          Bug Report 225088

*/



// ----  functions defined in  command.c ---- //

BOOL    BprocessParam(
IN      PABSARRAYREF paarValue,
IN      PARRAYREF    parStrValue,
IN  OUT PGLOBL       pglobl) ;

BOOL    BparseCommandString(
IN      PABSARRAYREF   paarValue,
IN      PARRAYREF      parStrValue,
IN  OUT PGLOBL         pglobl
) ;

BOOL    BconstructRPNtokenStream(
IN  OUT PABSARRAYREF  paarValue,
    OUT PARRAYREF     parRPNtokenStream,
IN  OUT PGLOBL        pglobl) ;

VOID    VinitOperPrecedence(
IN  OUT PGLOBL        pglobl);

BOOL    BparseArithmeticToken(
IN  OUT PABSARRAYREF paarValue,
OUT PTOKENSTREAM     ptstr,
    PGLOBL           pglobl
) ;

BOOL    BparseDigits(
IN  OUT PABSARRAYREF   paarValue,
OUT PTOKENSTREAM  ptstr ) ;

BOOL    BparseParamKeyword(
IN  OUT PABSARRAYREF  paarValue,
OUT PTOKENSTREAM      ptstr,
    PGLOBL            pglobl ) ;

BOOL  BcmpAARtoStr(
PABSARRAYREF    paarStr1,
PBYTE       str2) ;


// ----  functions defined in constrnt.c ---- //


BOOL   BparseConstraint(
PABSARRAYREF   paarValue,
PDWORD  pdwExistingCList,  //  index of start of contraint list.
BOOL    bCreate,
PGLOBL  pglobl) ;

BOOL    BexchangeDataInFOATNode(
DWORD   dwFeature,
DWORD   dwOption,
DWORD   dwFieldOff,  // offset of field in FeatureOption struct
PDWORD  pdwOut,     // previous contents of attribute node
PDWORD  pdwIn,
BOOL    bSynthetic,  //  access synthetic features
PGLOBL  pglobl
) ;

BOOL    BparseInvalidCombination(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl) ;

BOOL    BparseInvalidInstallableCombination1(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl) ;


// ----  functions defined in  framwrk.c ---- //

VOID      VinitMainKeywordTable(
PGLOBL  pglobl)  ;

VOID    VinitValueToSize(
PGLOBL  pglobl) ;

VOID  VinitGlobals(
DWORD   dwVerbosity,
PGLOBL  pglobl);

BOOL   BpreAllocateObjects(
PGLOBL  pglobl) ;

BOOL  BreturnBuffers(
PGLOBL  pglobl) ;

BOOL   BallocateCountableObjects(
PGLOBL  pglobl) ;

BOOL   BinitPreAllocatedObjects(
PGLOBL  pglobl) ;

BOOL   BinitCountableObjects(
PGLOBL  pglobl) ;

BOOL   BcreateGPDbinary(
PWSTR   pwstrFileName,
DWORD   dwVerbosity )  ;


BOOL BpostProcess(
PWSTR   pwstrFileName ,
PGLOBL  pglobl)  ;

BOOL    BconsolidateBuffers(
PWSTR   pwstrFileName ,
PGLOBL  pglobl)  ;

BOOL    BexpandMemConfigShortcut(DWORD       dwSubType) ;

BOOL    BexpandCommandShortcut(DWORD       dwSubType) ;


// ----  functions defined in helper1.c ---- //



PTSTR  pwstrGenerateGPDfilename(
    PTSTR   ptstrSrcFilename
    ) ;


PCOMMAND
CommandPtr(
    IN  PGPDDRIVERINFO  pGPDDrvInfo,
    IN  DWORD           UniCmdID
    ) ;

BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      poptsel,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    ) ;

PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pnRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       poptsel
    ) ;

BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    ) ;

BOOL
ChangeOptionsViaID(
    IN PINFOHEADER  pInfoHdr ,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    ) ;

BOOL    BMapDmColorToOptIndex(
PINFOHEADER  pInfoHdr ,
IN  OUT     PDWORD       pdwOptIndex ,  //  is current setting ok?
                        //  if not return new index to caller
DWORD        dwDmColor  // what is requested in Devmode
) ;

BOOL    BMapOptIDtoOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwFeatureGID,
DWORD        dwOptID
) ;

BOOL    BMapPaperDimToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwWidth,   //  in Microns
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes
) ;

BOOL    BMapResToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwXres,
DWORD        dwYres
) ;

BOOL    BGIDtoFeaIndex(
PINFOHEADER  pInfoHdr ,
PDWORD       pdwFeaIndex ,
DWORD        dwFeatureGID ) ;

DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes
    ) ;

BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    ) ;

BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions ,
    IN INT              iMode
    ) ;


BOOL
EnumOptionsUnconstrainedByPrinterSticky(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT   pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions
    ) ;


BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    ) ;

BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    ) ;

BOOL
BIsFeaOptionCurSelected(
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex
    ) ;

BOOL
BSelectivelyEnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL           pbHonorConstraints,  // if non NULL
        // points to array of BOOL corresponding to each feature.
        //  if TRUE means constraint involving this feature is
        //  to be honored.  Otherwise ignore the constraint.
    OUT PBOOL           pbEnabledOptions,  // assume uninitialized
        //  if pConflictPair is NULL else contains current or proposed
        //  selections.  We will leave this array unchanged in this case.
    IN  DWORD   dwOptSel,  //  if pConflictPair exists but  pbEnabledOptions
        //  is NULL, assume pickone and dwOptSel holds that selection for
        //  the feature: dwFeatureIndex.
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
        //  actually lists the current selections.  Function then
        //  exits after encountering the first conflict.
        //  if a conflict exists, all fields in pConflictPair
        //  will be properly initialized  else dwFeatureIndex1 = -1
        //  the return value will be TRUE regardless.
    ) ;

BOOL
BEnumImposedConstraintsOnFeature
(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwTgtFeature,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2,
    OUT PBOOL           pbEnabledOptions,
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
    ) ;

DWORD    DwFindNodeInCurLevel(
PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
PATREEREF        patr ,  // index to a level in the attribute tree.
DWORD   dwOption   // search current level for this option
) ;

BOOL     BIsConstraintActive(
IN  PCONSTRAINTS    pcnstr ,   //  root of Constraint nodes
IN  DWORD   dwCNode,    //  first constraint node in list.
IN  PBOOL           pbHonorConstraints,  // if non NULL
IN  POPTSELECT       pOptions,
OUT PCONFLICTPAIR    pConflictPair   ) ;


// ----  functions defined in installb.c ---- //


DWORD    DwCountSynthFeatures(
IN     BOOL   (*fnBCreateFeature)(DWORD, DWORD, DWORD, PGLOBL ) ,  // callback
IN OUT PGLOBL pglobl
) ;

BOOL    BCreateSynthFeatures(
IN     DWORD   dwFea,  //  index of installable feature
IN     DWORD   dwOpt,  //  index of installable Option or set to INVALID_INDEX
IN     DWORD   dwSynFea,
IN OUT PGLOBL  pglobl) ;

BOOL    BEnableInvInstallableCombos(
PGLOBL pglobl);


// ----  functions defined in postproc.c ---- //

DWORD   dwFindLastNode(
DWORD  dwFirstNode,
PGLOBL pglobl) ;


BOOL    BappendCommonFontsToPortAndLandscape(
PGLOBL pglobl) ;

BOOL    BinitSpecialFeatureOptionFields(
PGLOBL pglobl) ;

BOOL    BIdentifyConstantString(
IN   PARRAYREF parString,
OUT  PDWORD    pdwDest,       //  write dword value here.
IN   DWORD     dwClassIndex,  // which class of constant is this?
     BOOL      bCustomOptOK,
IN   PGLOBL    pglobl
) ;

BOOL    BReadDataInGlobalNode(
PATREEREF   patr,  // address of field in GlobalAttrib struct
PDWORD      pdwHeapOffset,
PGLOBL      pglobl) ;

BOOL    BsetUQMFlag(
PGLOBL  pglobl);

VOID    VCountPrinterDocStickyFeatures(
PGLOBL pglobl) ;

BOOL    BConvertSpecVersionToDWORD(
    PWSTR   pwstrFileName ,
    PGLOBL  pglobl) ;


BOOL        BinitMiniRawBinaryData(
PGLOBL  pglobl) ;

BOOL    BexchangeArbDataInFOATNode(
    DWORD   dwFeature,
    DWORD   dwOption,
    DWORD   dwFieldOff,     // offset of field in FeatureOption struct
    DWORD   dwCount,        //  number bytes to copy.
OUT PBYTE   pubOut,         // previous contents of attribute node
IN  PBYTE   pubIn,          // new contents of attribute node.
    PBOOL   pbPrevsExists,  // previous contents existed.
    BOOL    bSynthetic,     //  access synthetic features
    PGLOBL  pglobl
)  ;

BOOL    BInitPriorityArray(
PGLOBL  pglobl) ;



// ----  functions defined in semanchk.c ---- //

BOOL
BCheckGPDSemantics(
    IN PINFOHEADER  pInfoHdr,
    POPTSELECT   poptsel   // assume fully initialized
    ) ;

// ----  functions defined in snapshot.c ---- //

PINFOHEADER   PINFOHDRcreateSnapshot(
PBYTE   pubnRaw,  //  raw binary data.    PSTATIC.   BETA2
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL  BinitOptionFields(
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,  // option extra structure if any.
PBYTE   pubnRaw,  //  raw binary data.
DWORD   dwFea,
DWORD   dwOpt,
POPTSELECT   poptsel ,  // assume fully initialized
PINFOHEADER  pInfoHdr,   // used to access global structure.
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitUIinfo(
PUIINFO     pUIinfo ,
PBYTE   pubnRaw,  //  PSTATIC.   BETA2
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitFeatures(
PFEATURE    pFeaturesDest,
PDFEATURE_OPTIONS  pfoSrc,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitGlobals(
PGLOBALS pGlobals,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitCommandTable(
PDWORD  pdwCmdTable,  //  dest array
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BinitRawData(
PRAWBINARYDATA   pRawData, // contained in INFOHEADER.
PBYTE   pubnRaw  //  Parser's raw binary data.
) ;

BOOL    BinitGPDdriverInfo(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BinitSequencedCmds(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BaddSequencedCmdToList(
DWORD   dwCmdIn,  // index of a command in CommandArray
PGPDDRIVERINFO  pGPDdriverInfo,
DWORD   dwNewListNode,  //  an unused listnode to add to the list.
PBYTE   pubnRaw  //  raw binary data.
) ;

BinitDefaultOptionArray(
POPTSELECT   poptsel,   // assume is large enough
PBYTE   pubnRaw) ;

TRISTATUS     EdetermineDefaultOption(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwFeature,   // determine the default for this feature
PDFEATURE_OPTIONS  pfo,
POPTSELECT   poptsel, // assume is large enough
PDWORD       pdwPriority) ;

VOID    VtileDefault(
PBYTE   pubDest,
DWORD   dwDefault,
DWORD   dwBytes) ;

VOID    VtransferValue(
OUT PBYTE   pubDest,
IN  PBYTE   pubSrc ,
IN  DWORD   dwBytes,
IN  DWORD   dwFlags,
IN  DWORD   dwDefaultValue,  // holds bit flag value.
IN  PBYTE   pubHeap ) ;  //  used to form ptr if SSF_MAKE_STRINGPTR

BOOL    BspecialProcessOption(
PBYTE   pubnRaw,  // start of Rawbinary data
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,
PDFEATURE_OPTIONS  pfo ,  // source data
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.
PINFOHEADER  pInfoHdr,   // used to access global structure.
DWORD   dwFea,   //  feature index
DWORD   dwOpt,
BOOL   bDefaultOpt
) ;

TRISTATUS     EextractValueFromTree(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwSSTableIndex,  // some info about this value.
OUT PBYTE    pubDest,  // write value or link here
OUT PDWORD  pdwUnresolvedFeature,  // if the attribute tree has
            //  a dependency on this feature and the current option
            //  for that feature is not defined  in poptsel, this
            //  function will write the index of the required
            //  feature in pdwUnresolvedFeature.
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.  may be filled with OPTION_INDEX_ANY
                //  if we are jumpstarting
IN  DWORD   dwFeature,
IN OUT  PDWORD   pdwNextOpt  //  if multiple options are selected
    //  for dwFeature, pdwNextOpt points to the Nth option to consider
    //  in the  poptsel list,  at return time, this value
    //  is incremented if there are remaining options selected,
    //  else is reset to zero.
    //  For the first call, or PICKONE features,
    //  this value must be set to zero.
) ;

BOOL   RaisePriority(
DWORD   dwFeature1,
DWORD   dwFeature2,
PBYTE   pubnRaw,
PDWORD  pdwPriority) ;

DWORD  dwNumOptionSelected(
IN  DWORD  dwNumFeatures,
IN  POPTSELECT       poptsel
) ;

BOOL  BinitSnapShotIndexTable(PBYTE  pubnRaw) ;

BOOL    BinitSizeOptionTables(PBYTE  pubnRaw) ;

PRAWBINARYDATA
LoadRawBinaryData (
    IN PTSTR    ptstrDataFilename
    ) ;

PRAWBINARYDATA
GpdLoadCachedBinaryData(
    PTSTR   ptstrGpdFilename
    ) ;

VOID
UnloadRawBinaryData (
    IN PRAWBINARYDATA   pnRawData
) ;

PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pnRawData,        // actually pStatic
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    ) ;

VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    ) ;

BOOL    BIsRawBinaryDataInDate(
IN  PBYTE   pubRaw) ;  // this is pointer to memory mapped file! BETA2

BOOL BgetLocFeaOptIndex(
    IN     PRAWBINARYDATA   pnRawData,
       OUT PDWORD           pdwFea,
       OUT PDWORD           pdwOptIndex
    );

BOOL BgetLocFeaIndex(
    IN  PRAWBINARYDATA   pnRawData,
    OUT PDWORD           pdwFea
    );

BOOL   BfindMatchingOrDefaultNode(
IN  PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
IN  OUT  PDWORD  pdwNodeIndex,  // Points to first node in chain
IN  DWORD   dwOptionID     //  may even take on the value DEFAULT_INIT
) ;


// ----  functions defined in snaptbl.c ---- //

DWORD   DwInitSnapShotTable1(
PBYTE   pubnRaw) ;

DWORD   DwInitSnapShotTable2(
PBYTE   pubnRaw,
DWORD   dwI) ;



// ----  functions defined in state1.c ---- //

BOOL   BInterpretTokens(
PTKMAP  ptkmap,      // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
) ;

BOOL  BprocessSpecialKeyword(
PTKMAP  ptkmap,      // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
) ;

BOOL  BprocessSymbolKeyword(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
PGLOBL  pglobl
) ;

VOID    VinitAllowedTransitions(
PGLOBL pglobl) ;

BOOL    BpushState(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
BOOL    bFirstPass,
PGLOBL  pglobl
) ;

BOOL   BchangeState(
PTKMAP      ptkmap,  // pointer to construct in tokenmap
CONSTRUCT   eConstruct,   //  this will induce a transition to NewState
STATE       stOldState,
BOOL        bSymbol,      //  should dwValue be saved as a SymbolID ?
BOOL        bFirstPass,
PGLOBL      pglobl
) ;

DWORD   DWregisterSymbol(
PABSARRAYREF  paarSymbol,   // the symbol string to register
CONSTRUCT     eConstruct ,  // type of construct determines class of symbol.
BOOL          bCopy,        //  shall we copy paarSymbol to heap?  May set
DWORD         dwFeatureID,   //  if you are registering an option symbol
PGLOBL        pglobl
) ;

BOOL  BaddAARtoHeap(
PABSARRAYREF    paarSrc,
PARRAYREF       parDest,
DWORD           dwAlign,
PGLOBL          pglobl) ;

BOOL     BwriteToHeap(
OUT  PDWORD  pdwDestOff,   //  heap offset of dest string
     PBYTE   pubSrc,       //  points to src string
     DWORD   dwCnt,        //  num bytes to copy from src to dest.
     DWORD   dwAlign,
     PGLOBL  pglobl) ;

DWORD   DWsearchSymbolListForAAR(
PABSARRAYREF    paarSymbol,
DWORD           dwNodeIndex,
PGLOBL          pglobl) ;

DWORD   DWsearchSymbolListForID(
DWORD       dwSymbolID,   // find node containing this ID.
DWORD       dwNodeIndex,
PGLOBL      pglobl) ;

BOOL  BCmpAARtoAR(
PABSARRAYREF    paarStr1,
PARRAYREF       parStr2,
PGLOBL          pglobl) ;

BOOL  BpopState(
PGLOBL    pglobl) ;

VOID   VinitDictionaryIndex(
PGLOBL    pglobl) ;

VOID    VcharSubstitution(
PABSARRAYREF   paarStr,
BYTE           ubTgt,
BYTE           ubReplcmnt,
PGLOBL         pglobl) ;


VOID   VIgnoreBlock(
PTKMAP      ptkmap,
BOOL        bIgnoreBlock,
PGLOBL      pglobl) ;


// ----  functions defined in state2.c ---- //


BOOL  BprocessAttribute(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreFontCartAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreTTFontSubAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;


BOOL   BstoreCommandAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreFeatureOptionAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL  BstoreGlobalAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL    BaddBranchToTree(
PTKMAP      ptkmap,         // pointer to tokenmap
PATREEREF   patrAttribRoot,  //   pointer to dword with index
PGLOBL      pglobl
) ;

BOOL   BcreateGlobalInitializerNode(
PDWORD  pdwNodeIndex,
DWORD   dwOffset,
PGLOBL  pglobl) ;

BOOL   BcreateEndNode(
PDWORD  pdwNodeIndex,
DWORD   dwFeature,
DWORD   dwOption,
PGLOBL  pglobl
) ;

BOOL   BfindOrCreateMatchingNode(
IN  DWORD   dwRootNodeIndex , //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,     // points to node in chain also matching option
    DWORD   dwFeatureID,      //
    DWORD   dwOptionID,       //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
) ;

BOOL   BfindMatchingNode(
IN   DWORD   dwRootNodeIndex ,  //  first node in chain matching feature
OUT  PDWORD  pdwNodeIndex,  // points to node in chain also matching option
     DWORD   dwFeatureID,
     DWORD   dwOptionID,    //  may even take on the value DEFAULT_INIT
     PGLOBL  pglobl
) ;

BOOL BallocElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
PDWORD       pdwNodeIndex,
PGLOBL       pglobl) ;

BOOL  BreturnElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
DWORD        dwNodeIndex,
PGLOBL       pglobl) ;

BOOL    BconvertSymCmdIDtoUnidrvID(
IN  DWORD   dwCommandID , //  from RegisterSymbol
OUT PDWORD  pdwUnidrvID,
    PGLOBL  pglobl
) ;


// ----  functions defined in token1.c ---- //


BOOL    BcreateTokenMap(
PWSTR   pwstrFileName,
PGLOBL  pglobl )  ;

PARSTATE  PARSTscanForKeyword(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PARSTATE  PARSTparseColon(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PARSTATE  PARSTparseValue(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

BOOL  BparseKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BisExternKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL  BisColonNext(
PGLOBL  pglobl) ;

BOOL    BeatArbitraryWhite(
PGLOBL  pglobl) ;

BOOL    BeatComment(
PGLOBL  pglobl) ;

BOOL    BscanStringSegment(
PGLOBL  pglobl) ;

BOOL    BscanDelimitedString(
BYTE  ubDelimiter,
PBOOL    pbMacroDetected,
PGLOBL  pglobl) ;


PARSTATE    PARSTrestorePrevsFile(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PWSTR
PwstrAnsiToUnicode(
    IN  PSTR    pstrAnsiString ,
        PGLOBL  pglobl) ;

PARSTATE    PARSTloadIncludeFile(
PDWORD   pdwTKMindex,
PWSTR   pwstrFileName,    // root GPD file
PGLOBL  pglobl);

BOOL    BloadFile(
PWSTR   pwstrFileName,
PGLOBL  pglobl ) ;

BOOL        BarchiveStrings(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

DWORD  DWidentifyKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BidentifyAttributeKeyword(
PTKMAP  ptkmap,  // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL    BcopyToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL  pglobl) ;

DWORD    dwStoreFileName(PWSTR    pwstrFileName,
PARRAYREF   parDest,
PGLOBL  pglobl) ;

VOID    vFreeFileNames(
PGLOBL  pglobl) ;

VOID    vIdentifySource(
    PTKMAP   ptkmap ,
    PGLOBL  pglobl) ;


// ----  functions defined in value1.c ---- //


BOOL   BaddValueToHeap(
IN  OUT  PDWORD  ploHeap,  // dest offset to value in binary form
IN   PTKMAP  ptkmap,   // pointer to tokenmap
IN   BOOL    bOverWrite,  // assume ploHeap contains a valid offset
        //  to a reserved region of the heap of the proper size
        //  and write binary value into this location instead of
        //  growing heap.  Note:  defer overwriting lpHeap
        //  until we are certain of success.
IN  OUT PGLOBL      pglobl
) ;

BOOL   BparseAndWrite(
IN      PBYTE   pubDest,       // write binary data or link to this address.
IN      PTKMAP  ptkmap,        // pointer to tokenmap
IN      BOOL    bAddToHeap,    // if true, write to curHeap not pubDest
OUT     PDWORD  pdwHeapOffset, // if (bAddToHeap)  heap offset where
IN  OUT PGLOBL  pglobl
) ;

BOOL    BparseInteger(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // dummy
IN  PGLOBL        pglobl
)  ;

BOOL    BparseList(
IN     PABSARRAYREF  paarValue,
IN     PDWORD        pdwDest,       //  location where index to start of list
                                    //  is saved
IN     BOOL          (*fnBparseValue)(PABSARRAYREF, PDWORD, VALUE, PGLOBL),   // callback
IN     VALUE         eAllowedValue,  // dummy
IN OUT PGLOBL
) ;

BOOL    BeatLeadingWhiteSpaces(
IN  OUT  PABSARRAYREF   paarSrc
) ;

BOOL    BeatDelimiter(
IN  OUT  PABSARRAYREF   paarSrc,
IN  PBYTE  pubDelStr        //  points to a string which paarSrc must match
) ;

BOOL    BdelimitToken(
IN  OUT  PABSARRAYREF   paarSrc,    //  source string
IN  PBYTE   pubDelimiters,          //  array of valid delimiters
OUT     PABSARRAYREF   paarToken,   //  token defined by delimiter
OUT     PDWORD      pdwDel      //  which delimiter was first encountered?
) ;

BOOL    BeatSurroundingWhiteSpaces(
IN  PABSARRAYREF   paarSrc
) ;

BOOL    BparseSymbol(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)  ;

BOOL    BparseQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)  ;

BOOL    BparsePartiallyQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
) ;

BOOL    BparseOptionSymbol(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // which class of symbol is this?
IN  PGLOBL        pglobl
) ;

BOOL    BparseConstant(
IN  OUT  PABSARRAYREF  paarValue,
OUT      PDWORD        pdwDest,       //  write dword value here.
IN       VALUE         eAllowedValue,  // which class of constant is this?
IN       PGLOBL        pglobl
) ;

BOOL  BinitClassIndexTable(
IN  OUT     PGLOBL    pglobl) ;

BOOL    BparseRect(
IN  PABSARRAYREF   paarValue,
IN  PRECT   prcDest,
    PGLOBL   pglobl
) ;

BOOL    BparsePoint(
IN  PABSARRAYREF   paarValue,
IN  PPOINT   pptDest,
    PGLOBL   pglobl
) ;

BOOL    BparseString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  OUT PGLOBL      pglobl
) ;

BOOL    BparseAndTerminateString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  VALUE          eAllowedValue,
IN  OUT PGLOBL     pglobl
) ;

BOOL     BwriteUnicodeToHeap(
IN   PARRAYREF      parSrcString,
OUT  PARRAYREF      parUnicodeString,
IN   INT            iCodepage,
IN  OUT PGLOBL      pglobl
) ;

BOOL    BparseStrSegment(
IN  PABSARRAYREF   paarStrSeg,      // source str segment
IN  PARRAYREF      parStrLiteral,   // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseStrLiteral(
IN  PABSARRAYREF   paarStrSeg,      // points to literal substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseHexStr(
IN  PABSARRAYREF   paarStrSeg,      // points to hex substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseOrderDep(
IN  PABSARRAYREF   paarValue,
IN  PORDERDEPENDENCY   pordDest,
    PGLOBL   pglobl
) ;

// ----  functions defined in  macros1.c ---- //

BOOL  BevaluateMacros(
PGLOBL pglobl) ;

BOOL    BDefineValueMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

BOOL    BResolveValueMacroReference(
PTKMAP  ptkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BdelimitName(
PABSARRAYREF    paarValue,   //  the remainder of the string without the Name
PABSARRAYREF    paarToken,   //  contains the Name
PBYTE  pubChar ) ;


BOOL    BCatToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl) ;

BOOL    BResolveBlockMacroReference(
PTKMAP   ptkmap,
DWORD    dwMacRefIndex,
PGLOBL   pglobl) ;

BOOL    BDefineBlockMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

BOOL    BIncreaseMacroLevel(
BOOL    bMacroInProgress,
PGLOBL  pglobl) ;

BOOL    BDecreaseMacroLevel(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

VOID    VEnumBlockMacro(
PTKMAP  pNewtkmap,
PBLOCKMACRODICTENTRY    pBlockMacroDictEntry,
PGLOBL  pglobl ) ;



// ----  functions defined in  shortcut.c ---- //


BOOL    BInitKeywordField(
PTKMAP  pNewtkmap,
PGLOBL  pglobl) ;

BOOL    BExpandMemConfig(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BExpandCommand(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL  BexpandShortcuts(
PGLOBL  pglobl) ;


BOOL  BSsyncTokenMap(
PTKMAP   ptkmap,
PTKMAP   pNewtkmap ,
PGLOBL  pglobl) ;



// ------- end function declarations ------- //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\helper1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  helper1.c - helper functions  */



#include    "gpdparse.h"





// ----  functions defined in helper1.c ---- //



PTSTR  pwstrGenerateGPDfilename(
    PTSTR   ptstrSrcFilename
    ) ;

#ifndef  PARSERDLL

PCOMMAND
CommandPtr(
    IN  PGPDDRIVERINFO  pGPDDrvInfo,
    IN  DWORD           UniCmdID
    ) ;

BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      poptsel,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    ) ;

PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pnRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       poptsel
    ) ;

BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    ) ;

BOOL
ChangeOptionsViaID(
    IN PINFOHEADER  pInfoHdr ,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    ) ;

BOOL    BMapDmColorToOptIndex(
PINFOHEADER  pInfoHdr ,
IN  OUT     PDWORD       pdwOptIndex ,  //  is current setting ok?
                        //  if not return new index to caller
DWORD        dwDmColor  // what is requested in Devmode
) ;

BOOL    BMapOptIDtoOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwFeatureGID,
DWORD        dwOptID
) ;

BOOL    BMapPaperDimToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwWidth,   //  in Microns
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes
) ;

BOOL    BMapResToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwXres,
DWORD        dwYres
) ;

BOOL    BGIDtoFeaIndex(
PINFOHEADER  pInfoHdr ,
PDWORD       pdwFeaIndex ,
DWORD        dwFeatureGID ) ;



DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes
    ) ;


DWORD
UniMapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes,       // used only for GID_PAGESIZE
    IN    PDWORD       pdwPaperID   //  optional paperID
    ) ;


DWORD   MapPaperAttribToOptIndex(
PINFOHEADER  pInfoHdr ,
IN     PDWORD       pdwPaperID ,  //  optional paperID
DWORD        dwWidth,   //  in Microns (set to zero to ignore)
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes  //  cannot be NULL
) ;


BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    ) ;

BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions ,
    IN INT              iMode
    ) ;


BOOL
EnumOptionsUnconstrainedByPrinterSticky(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT   pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions
    ) ;



BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    ) ;

BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    ) ;

BOOL
BIsFeaOptionCurSelected(
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex
    ) ;

BOOL
BSelectivelyEnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL           pbHonorConstraints,  // if non NULL
        // points to array of BOOL corresponding to each feature.
        //  if TRUE means constraint involving this feature is
        //  to be honored.  Otherwise ignore the constraint.
    OUT PBOOL           pbEnabledOptions,  // assume uninitialized
        //  if pConflictPair is NULL else contains current or proposed
        //  selections.  We will leave this array unchanged in this case.
    IN  DWORD   dwOptSel,  //  if pConflictPair exists but  pbEnabledOptions
        //  is NULL, assume pickone and dwOptSel holds that selection for
        //  the feature: dwFeatureIndex.
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
        //  actually lists the current selections.  Function then
        //  exits after encountering the first conflict.
        //  if a conflict exists, all fields in pConflictPair
        //  will be properly initialized  else dwFeatureIndex1 = -1
        //  the return value will be TRUE regardless.
    ) ;

BOOL
BEnumImposedConstraintsOnFeature
(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwTgtFeature,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2,
    OUT PBOOL           pbEnabledOptions,
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
    ) ;

DWORD    DwFindNodeInCurLevel(
PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
PATREEREF        patr ,  // index to a level in the attribute tree.
DWORD   dwOption   // search current level for this option
) ;

BOOL     BIsConstraintActive(
IN  PCONSTRAINTS    pcnstr ,   //  root of Constraint nodes
IN  DWORD   dwCNode,    //  first constraint node in list.
IN  PBOOL           pbHonorConstraints,  // if non NULL
IN  POPTSELECT       pOptions,
OUT PCONFLICTPAIR    pConflictPair   ) ;

#ifdef  GMACROS


BOOL
ResolveDependentSettings(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    ) ;


void  EnumSelectedOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeature,
    IN PBOOL            pbSelectedOptions) ;

BOOL
ExecuteMacro(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN    DWORD    dwFea,    //  what feature was selected in UI
    IN    DWORD    dwOpt ,   //  what option was selected in UI
    OUT PBOOL   pbFeaturesChanged  // tell Amanda what Features were changed.
    ) ;

#endif

#endif  PARSERDLL


// ------- end function declarations ------- //



PTSTR  pwstrGenerateGPDfilename(
    PTSTR   ptstrSrcFilename
    )

/*++

Routine Description:

    Generate a filename for the cached binary GPD data given a GPD filename

Arguments:

    ptstrSrcFilename - Specifies the GPD src filename

Return Value:

    Pointer to BPD filename string, NULL if there is an error

--*/

{
    PTSTR   ptstrBpdFilename, ptstrExtension;
    INT     iLength;

    //
    // If the GPD filename has .GPD extension, replace it with .BUD extension.
    // Otherwise, append .BUD extension at the end.
    //

    if(!ptstrSrcFilename)
        return NULL ;   // will never happen in reality, just to silence PREFIX

    iLength = _tcslen(ptstrSrcFilename);

    if ((ptstrExtension = _tcsrchr(ptstrSrcFilename, TEXT('.'))) == NULL ||
        _tcsicmp(ptstrExtension, GPD_FILENAME_EXT) != EQUAL_STRING)
    {
        WARNING(("Bad GPD filename extension: %ws\n", ptstrSrcFilename));

        ptstrExtension = ptstrSrcFilename + iLength;
        iLength += _tcslen(BUD_FILENAME_EXT);
    }

    //
    // Allocate memory and compose the BUD filename
    //

    if (ptstrBpdFilename = MemAlloc((iLength + 1) * sizeof(TCHAR)))
    {
//        _tcscpy(ptstrBpdFilename, ptstrSrcFilename);
//        _tcscpy(ptstrBpdFilename + (ptstrExtension - ptstrSrcFilename),
//                            BUD_FILENAME_EXT);

        StringCchCopy(ptstrBpdFilename, iLength + 1, ptstrSrcFilename) ;

        StringCchCopy(ptstrBpdFilename + (ptstrExtension - ptstrSrcFilename),
                             iLength + 1 - (ptstrExtension - ptstrSrcFilename) ,
                             BUD_FILENAME_EXT);


        VERBOSE(("BUD filename: %ws\n", ptstrBpdFilename));
    }
    else
    {
        ERR(("Fatal: pwstrGenerateGPDfilename - unable to alloc %d bytes.\n",
            (iLength + 1) * sizeof(TCHAR)));
    }

    return (ptstrBpdFilename);
}


#ifndef  PARSERDLL


PCOMMAND
CommandPtr(
    IN  PGPDDRIVERINFO  pGPDDrvInfo,
    IN  DWORD           UniCmdID
    )
{
    return ((((PDWORD)((PBYTE)(pGPDDrvInfo)->pInfoHeader +
              (pGPDDrvInfo)->DataType[DT_COMMANDTABLE].loOffset))
              [(UniCmdID)] == UNUSED_ITEM ) ? NULL :
              (PCOMMAND)((pGPDDrvInfo)->pubResourceData +
              (pGPDDrvInfo)->DataType[DT_COMMANDARRAY].loOffset)
              + ((PDWORD)((PBYTE)(pGPDDrvInfo)->pInfoHeader +
              (pGPDDrvInfo)->DataType[DT_COMMANDTABLE].loOffset))[(UniCmdID)]);
}


BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      poptsel,
    IN INT              iMaxOptions,
    IN INT              iMode
    )
{
    INT iOptionsNeeded ;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    if(iMode != MODE_DOCANDPRINTER_STICKY)
    {
        POPTSELECT      pOptions = NULL;
        BOOL    bStatus = TRUE ;

        if(iMode == MODE_DOCUMENT_STICKY)
            iOptionsNeeded = pRawData->dwDocumentFeatures ;
        else  //  MODE_PRINTER_STICKY
            iOptionsNeeded = pRawData->dwPrinterFeatures ;

        if(iOptionsNeeded > iMaxOptions)
            return(FALSE);

        pOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;
        if(!poptsel  ||  !pOptions  ||
            !BinitDefaultOptionArray(pOptions, (PBYTE)pnRawData))
        {
            bStatus = FALSE;
        }

        if(!bStatus   ||  !SeparateOptionArray(pnRawData,
                pOptions,   //  pCombinedOptions,
                poptsel,    //  dest array
                iMaxOptions, iMode))
        {
            bStatus = FALSE;
            ERR(("InitDefaultOptions: internal failure.\n"));
        }

        if(pOptions)
            MemFree(pOptions) ;

        return(bStatus);
    }
    else    //  MODE_DOCANDPRINTER_STICKY
    {
        iOptionsNeeded = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures ;
        if(iOptionsNeeded > iMaxOptions)
            return(FALSE);

        if(!poptsel  ||
            !BinitDefaultOptionArray(poptsel, (PBYTE)pnRawData))
        {
            return(FALSE);
        }
    }




    return(TRUE);
}


BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )
{
    DWORD   dwNumSrcFea, dwNumDestFea, dwStart, dwI, dwDestTail,
        dwDest, dwSrcTail;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubRaw ;  //  raw binary data.
    INT     iOptionsNeeded;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA


    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    dwStart = 0 ;  // starting src index

    if(iMode == MODE_DOCUMENT_STICKY)
    {
        dwNumSrcFea = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
            //  number of candidates - not same as num of doc sticky features.
        dwNumDestFea = pRawData->dwDocumentFeatures ;
    }
    else  //  MODE_PRINTER_STICKY
    {
        dwNumSrcFea = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount
                    + pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;
        dwNumDestFea = pRawData->dwPrinterFeatures ;
    }

    //  assume pCombinedOptions large enough to
    //  hold all Feature and any pickmany selections.

    dwDestTail = dwNumDestFea ; //  where pickmany selections are stored.
    dwDest = 0 ;  //  where to store first selection for each feature.

    //  first pass:
    //  Just count number of optselect elements needed.

    iOptionsNeeded  = 0 ;

    for(dwI = dwStart ; dwI < dwStart + dwNumSrcFea ; dwI++)
    {
        DWORD   dwNextOpt, dwFeatureType = FT_PRINTERPROPERTY, dwUnresolvedFeature ;
        PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

        //  is this a printer or doc sticky feature?


        patrRoot = &(pfo[dwI].atrFeatureType) ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
            (PBYTE)&dwFeatureType,
            &dwUnresolvedFeature,  *patrRoot, pCombinedOptions,
            0, // set to  any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("SeparateOptionArray: EextractValueFromTree failed.\n"));
            return(FALSE) ;
        }



        if(dwI < pearTableContents[MTI_DFEATURE_OPTIONS].dwCount)
        {
            if(dwFeatureType != FT_PRINTERPROPERTY)
            {
                if(iMode == MODE_PRINTER_STICKY)
                    continue ;
            }
            else
            {
                if(iMode == MODE_DOCUMENT_STICKY)
                    continue ;
            }

        }
        else
        {
            //  synthesized features are always printer sticky.
            if(iMode == MODE_DOCUMENT_STICKY)
                continue ;
        }

        iOptionsNeeded++ ;
        dwSrcTail = dwI ;

        while(dwSrcTail = pCombinedOptions[dwSrcTail].ubNext)
        {
            iOptionsNeeded++ ;
        }
    }

    if(iOptionsNeeded > iMaxOptions)
        return(FALSE);

    for(dwI = dwStart ; dwI < dwStart + dwNumSrcFea ; dwI++)
    {
        DWORD   dwNextOpt, dwFeatureType, dwUnresolvedFeature ;
        PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

        //  is this a printer or doc sticky feature?


        patrRoot = &(pfo[dwI].atrFeatureType) ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
            (PBYTE)&dwFeatureType,
            &dwUnresolvedFeature,  *patrRoot, pCombinedOptions,
            0, // set to  any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("SeparateOptionArray: EextractValueFromTree failed.\n"));
            return(FALSE) ;
        }



        if(dwI < pearTableContents[MTI_DFEATURE_OPTIONS].dwCount)
        {
            if(dwFeatureType != FT_PRINTERPROPERTY)
            {
                if(iMode == MODE_PRINTER_STICKY)
                    continue ;
            }
            else
            {
                if(iMode == MODE_DOCUMENT_STICKY)
                    continue ;
            }

        }
        else
        {
            //  synthesized features are always printer sticky.
            if(iMode == MODE_DOCUMENT_STICKY)
                continue ;
        }

        pOptions[dwDest].ubCurOptIndex = pCombinedOptions[dwI].ubCurOptIndex;
        if(!pCombinedOptions[dwI].ubNext)  //  end of list
            pOptions[dwDest].ubNext = 0 ;
        else
        {
            dwSrcTail = pCombinedOptions[dwI].ubNext ;
                //  this node holds another selection.
            pOptions[dwDest].ubNext = (BYTE)dwDestTail ;

            while(dwSrcTail)
            {
                pOptions[dwDestTail].ubCurOptIndex =
                        pCombinedOptions[dwSrcTail].ubCurOptIndex;
                pOptions[dwDestTail].ubNext = (BYTE)dwDestTail + 1 ;
                dwDestTail++ ;
                dwSrcTail = pCombinedOptions[dwSrcTail].ubNext ;
            }
            pOptions[dwDestTail - 1].ubNext = 0 ;
        }
        dwDest++ ;
    }

    return(TRUE);
}


BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    )
/*  Note:

    Either pDocOptions or pPrinterOptions could be NULL but not both. If pDocOptions
    is NULL, then in the combined option array, the options for document-sticky
    features will be OPTION_INDEX_ANY. Same is true when pPrinterOptions is NULL.
*/



{
    DWORD           dwNumSrcFea, dwNumDestFea, dwStart, dwI, dwDestTail,
                    dwSrcTail,   dwNDoc,
                    dwSrcPrnStickyIndex,  dwSrcDocStickyIndex ;
    PENHARRAYREF    pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE           pubRaw ;        //  raw binary data.
    INT             iOptionsNeeded;
    PRAWBINARYDATA  pRawData ;
    PSTATICFIELDS   pStatic ;
    DWORD           dwFea,          //Feature Index of Locale
                    dwOptIndex;     // Index of the Option that matches
                                    // the system locale.

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA


    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    dwStart = 0 ;  // starting src index


    dwNumDestFea = pRawData->dwDocumentFeatures +
                        pRawData->dwPrinterFeatures ;



    //  how many option nodes will be used in the combined array?

    iOptionsNeeded = pRawData->dwDocumentFeatures ;
    if(pDocOptions)
    {
        for(dwI = 0 ; dwI < pRawData->dwDocumentFeatures ; dwI++)
        {

            dwSrcTail = dwI ;

            while(dwSrcTail = pDocOptions[dwSrcTail].ubNext)
            {
                iOptionsNeeded++ ;
            }
        }
    }
    iOptionsNeeded += pRawData->dwPrinterFeatures ;
    if(pPrinterOptions)
    {
        for(dwI = 0 ; dwI < pRawData->dwPrinterFeatures ; dwI++)
        {

            dwSrcTail = dwI ;

            while(dwSrcTail = pPrinterOptions[dwSrcTail].ubNext)
            {
                iOptionsNeeded++ ;
            }
        }
    }

    if(iOptionsNeeded > iMaxOptions)
        return(FALSE);

    dwDestTail = dwNumDestFea ; //  start of pickmany selections

    dwSrcPrnStickyIndex = dwSrcDocStickyIndex = 0 ;
    // where to start reading from as we interleave the
    // two sources to form the combined array.

    for(dwI = 0 ; dwI < pearTableContents[MTI_DFEATURE_OPTIONS].dwCount +
                    pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount ;
                                    dwI++)
    {
        DWORD   dwNextOpt, dwFeatureType, dwUnresolvedFeature ;
        PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
        POPTSELECT      pSrcOptions ;
        PDWORD          pdwSrcIndex ;


        //  assume printer sticky until proven otherwise.

        pSrcOptions = pPrinterOptions ;  // may be null.
        pdwSrcIndex = &dwSrcPrnStickyIndex ;


        if(dwI < pearTableContents[MTI_DFEATURE_OPTIONS].dwCount)
        {
            //  GPD defined features may be Doc or Printer sticky.

            patrRoot = &(pfo[dwI].atrFeatureType) ;

            dwNextOpt = 0 ;  // extract info for first option selected for
                                //  this feature.

            //  note we give EextractValueFromTree a ptr to
            //  an uninitialized option array pCombinedOptions just
            //  in case it has the urge to access an option array.
            //  I point out that FeatureType is not multi-valued.

            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
                (PBYTE)&dwFeatureType,
                &dwUnresolvedFeature,  *patrRoot, pCombinedOptions,
                0, // set to  any value.  Doesn't matter.
                &dwNextOpt) != TRI_SUCCESS)
            {
                ERR(("CombineOptionArray: EextractValueFromTree failed.\n"));
                return(FALSE) ;
            }

            if(dwFeatureType != FT_PRINTERPROPERTY)
            {
                pSrcOptions = pDocOptions ;
                pdwSrcIndex = &dwSrcDocStickyIndex ;
            }
        }


        if(!pSrcOptions)  // no option array supplied.
        {
            pCombinedOptions[dwI].ubCurOptIndex = OPTION_INDEX_ANY ;
            pCombinedOptions[dwI].ubNext = 0 ;  // eol
        }
        else
        {
            dwSrcTail = *pdwSrcIndex ;

            pCombinedOptions[dwI].ubCurOptIndex =
                        pSrcOptions[*pdwSrcIndex].ubCurOptIndex ;
            if(pSrcOptions[*pdwSrcIndex].ubNext)
            {
                pCombinedOptions[dwI].ubNext = (BYTE)dwDestTail ;

                while(dwSrcTail = pSrcOptions[dwSrcTail].ubNext)
                {
                    pCombinedOptions[dwDestTail].ubCurOptIndex =
                        pSrcOptions[dwSrcTail].ubCurOptIndex ;
                    pCombinedOptions[dwDestTail].ubNext = (BYTE)dwDestTail + 1;
                    dwDestTail++ ;
                }
                pCombinedOptions[dwDestTail - 1].ubNext = 0 ;
            }
            else
                pCombinedOptions[dwI].ubNext = 0 ;

            (*pdwSrcIndex)++ ;
        }
    }

//  Special case processing for Locale. If there is a conflict between
//  locale as stored in the registry ( i.e. the printer feature option
//  related registry) and the System Locale, then give importance to
//  the option that matches the system locale.


    dwFea = dwOptIndex = (DWORD)-1;    // Safety sake initialization.
    if ( !BgetLocFeaOptIndex(pnRawData, &dwFea, &dwOptIndex) )
    {
        return FALSE;
    }
    if ( dwFea == -1 ) //Locale keyword not in gpd. Nothing to do.
    {
        return TRUE;
    }

    if (dwOptIndex == -1)  // Find the default option.
    {
        // Here we want to find the default option index.
        // The assumption here is that Locale option is not dependent
        // on any other feature. This is true cos Locale is only system
        // dependent and should not depend on any other feature. But
        // in the long run if some other dependency arises, we may have to
        // change the code.
        ATREEREF atrOptIDNode = pfo[dwFea].atrDefaultOption;
        PBYTE    pubHeap      = (PBYTE)(pubRaw +
                        pearTableContents[MTI_STRINGHEAP]. loOffset) ;

        if ( atrOptIDNode & ATTRIB_HEAP_VALUE)
        {
            dwOptIndex = *((PDWORD)(pubHeap +
                            (atrOptIDNode & ~ATTRIB_HEAP_VALUE))) ;
        }
        else {
            ERR(("Error in processing Default Option for Feature Locale. Continuing....\n"));
            return TRUE;    //Dont do any processing.
        }
        // i.e.
    }
    // Could have used ReconstructOptionArray() but prefered to go
    // with the constructs used in this function.
    // Another assumption is that multiple options cannot be selected.
    // Thats why pCombinedOptions[dwFea].ubNext = 0
    pCombinedOptions[dwFea].ubCurOptIndex = (BYTE)dwOptIndex;
    pCombinedOptions[dwFea].ubNext = 0;

    return(TRUE);
}



#ifndef KERNEL_MODE

PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pnRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       poptsel
    )
{

    DWORD               dwNumFeatures, loFeatures, dwFea, dwI, dwNumOptions ,
                        dwSizeOption ;
    PGPDDRIVERINFO      pGPDdriverInfo;
    PUIINFO             pUIinfo ;
    PFEATURE            pFeaturesDest ;
    PENHARRAYREF        pearTableContents ;
    PDFEATURE_OPTIONS   pfo ;
//  PMINIRAWBINARYDATA  pmrbd  ;
    PBYTE               pubRaw,           // raw binary data.
                        pubOptionsDest ,  // ptr to any of the several varieties
                        pubDestOptionEx ; // of option structures.
    PRAWBINARYDATA      pRawData ;
    PSTATICFIELDS       pStatic ;

    pStatic    = (PSTATICFIELDS)pnRawData ;   // transform pubRaw from PSTATIC
    pRawData   = (PRAWBINARYDATA)pStatic->pubBUDData ; //  to BUDDATA

    pubRaw     = (PBYTE)pRawData ;
//    pmrbd    = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    /*   also works ...
    dwNumFeatures =
        pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures ;
    */

    pGPDdriverInfo = (PGPDDRIVERINFO)((PBYTE)(pInfoHdr) +
                        pInfoHdr->loDriverOffset) ;
    if(!BinitGlobals(&pGPDdriverInfo->Globals, (PBYTE)pnRawData, poptsel, TRUE) )
    {
        return(NULL) ;
    }

    pUIinfo = (PUIINFO)((PBYTE)(pInfoHdr) +
                    pInfoHdr->loUIInfoOffset)  ;

     if(!BinitUIinfo(pUIinfo, (PBYTE)pnRawData, poptsel, TRUE) )
     {
         return(NULL) ;
     }


    loFeatures  = pUIinfo->loFeatureList ;  // from  pInfoHdr

    pFeaturesDest =  (PFEATURE)((PBYTE)(pInfoHdr) + loFeatures) ;
    //  always points to first Feature structure in array

    for( dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwSizeOption = (pFeaturesDest + dwFea)->dwOptionSize ;
        dwNumOptions = pFeaturesDest[dwFea].Options.dwCount  ;
        pubOptionsDest =  (PBYTE)(pInfoHdr) + pFeaturesDest[dwFea].Options.loOffset ;


        if(!BinitFeatures(pFeaturesDest + dwFea, pfo + dwFea,
                            (PBYTE)pnRawData, poptsel, TRUE))
        {
            return(NULL) ;
        }

        for(dwI = 0 ; dwI < dwNumOptions ; dwI++)
        {
            if(((POPTION)pubOptionsDest)->loRenderOffset)
            {
                pubDestOptionEx =  (PBYTE)(pInfoHdr) +
                                    ((POPTION)pubOptionsDest)->loRenderOffset ;
            }
            else
                pubDestOptionEx = NULL ;

            if(!BinitOptionFields(pubOptionsDest, pubDestOptionEx,
                        (PBYTE)pnRawData, dwFea, dwI, poptsel, pInfoHdr, TRUE) )
            {
                MemFree(pInfoHdr) ;
                return(NULL) ;
            }
            pubOptionsDest += dwSizeOption ;
        }
    }

    return(pInfoHdr);
}
#endif


BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    )

/*++

Routine Description:

    Modify an option array to change the selected options for the specified feature

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures to be modified
    iMaxOptions - Max number of entries in pOptions array
    dwFeatureIndex - Specifies the index of printer feature in question
    pbSelectedOptions - Which options of the specified feature is selected

Return Value:

    FALSE if the input option array is not large enough to hold
    all modified option values. TRUE otherwise.

Note:

    Number of BOOLs in pSelectedOptions must match the number of options
    for the specified feature.

    This function always leaves the option array in a compact format (i.e.
    all unused entries are left at the end of the array).

--*/

{
    BOOL    bStatus = TRUE ;
    DWORD   dwDestTail, dwSrcTail, dwNumFea , dwI ;
    //  POPTSELECT   pNewOptions ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PBYTE   pubRaw ;  //  raw binary data.
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    OPTSELECT  pNewOptions[MAX_COMBINED_OPTIONS] ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    if(!pOptions)
    {
        ERR(("ReconstructOptionArray: caller passed in invalid pOptions.\n"));
        return(FALSE);  // Missing array.
    }

    #if 0
    pNewOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;

    if( !pNewOptions )
    {
        ERR(("Fatal: ReconstructOptionArray - unable to alloc %d bytes.\n",
            sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS));
        return(FALSE);  // Missing array.
    }
    #endif


    dwDestTail = dwNumFea = pRawData->dwDocumentFeatures +
                        pRawData->dwPrinterFeatures ;



    for(dwI = 0 ; dwI < dwNumFea ; dwI++)
    {
        if(dwI == dwFeatureIndex)
        {
            DWORD  dwNumOptions, dwOpt ;

            dwNumOptions = pfo[dwI].dwNumOptions ;

            // determine first selected option, must have
            // at least one.

            for(dwOpt = 0 ; dwOpt < dwNumOptions  &&
                            !pbSelectedOptions[dwOpt]  ; dwOpt++)
            {
                ;  // null body
            }
            if(dwOpt >= dwNumOptions)
            {
                ERR(("ReconstructOptionArray: caller passed in invalid option selection.\n"));
                bStatus = FALSE ;
                break ;
            }
            pNewOptions[dwI].ubCurOptIndex = (BYTE)dwOpt ;
            for(++dwOpt  ; dwOpt < dwNumOptions  &&
                            !pbSelectedOptions[dwOpt]  ; dwOpt++)
            {
                ;  // null body
            }
            if(dwOpt == dwNumOptions)    //  no other options selected.
                pNewOptions[dwI].ubNext = 0 ;
            else
            {
                //  pbSelectedOptions holds another selection.
                pNewOptions[dwI].ubNext = (BYTE)dwDestTail ;

                while(dwOpt < dwNumOptions)
                {
                    pNewOptions[dwDestTail].ubCurOptIndex = (BYTE)dwOpt ;
                    pNewOptions[dwDestTail].ubNext = (BYTE)dwDestTail + 1 ;
                    dwDestTail++ ;
                    if(dwDestTail > MAX_COMBINED_OPTIONS)
                    {
                        ERR(("ReconstructOptionArray: exceeded limit of MAX_COMBINED_OPTIONS.\n"));
                        //  MemFree(pNewOptions) ;
                        return(FALSE);
                    }
                    for(++dwOpt  ; dwOpt < dwNumOptions  &&
                                    !pbSelectedOptions[dwOpt]  ; dwOpt++)
                    {
                        ;  // null body
                    }
                }
                pNewOptions[dwDestTail - 1].ubNext = 0 ;
            }

            continue ;
        }
        pNewOptions[dwI].ubCurOptIndex = pOptions[dwI].ubCurOptIndex;
        if(!(dwSrcTail = pOptions[dwI].ubNext))  //  end of list
            pNewOptions[dwI].ubNext = 0 ;
        else
        {
            //  dwSrcTail holds another selection.
            pNewOptions[dwI].ubNext = (BYTE)dwDestTail ;

            while(dwSrcTail)
            {
                pNewOptions[dwDestTail].ubCurOptIndex =
                        pOptions[dwSrcTail].ubCurOptIndex;
                pNewOptions[dwDestTail].ubNext = (BYTE)dwDestTail + 1 ;
                dwDestTail++ ;
                if(dwDestTail > MAX_COMBINED_OPTIONS)
                {
                    ERR(("ReconstructOptionArray: exceeded limit of MAX_COMBINED_OPTIONS.\n"));
                    //  MemFree(pNewOptions) ;
                    return(FALSE);
                }
                dwSrcTail = pOptions[dwSrcTail].ubNext ;
            }
            pNewOptions[dwDestTail - 1].ubNext = 0 ;
        }
    }

    if (dwDestTail > (DWORD)iMaxOptions)
    {
        ERR(("ReconstructOptionArray: exceeded size of array OPTSELECT.\n"));
        bStatus = FALSE;
    }
    if(bStatus)
    {
        for(dwI = 0 ; dwI < dwDestTail ; dwI++)
          pOptions[dwI] = pNewOptions[dwI] ;
    }
    //  MemFree(pNewOptions) ;
    return(bStatus);
}




BOOL
ChangeOptionsViaID(
    IN PINFOHEADER  pInfoHdr ,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    )

/*++

Routine Description:

    Modifies an option array using the information in public devmode fields

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to the option array to be modified
    dwFeatureID - Specifies which field(s) of the input devmode should be used
    pDevmode - Specifies the input devmode

Return Value:
    TRUE if successful, FALSE if the specified feature ID is not supported
    or there is an error

Note:

    We assume the input devmode fields have been validated by the caller.
 this GID:           is determined by this devmode field:       optID

GID_RESOLUTION      dmPrintQuality, dmYResolution
GID_PAGESIZE        dmPaperSize, dmPaperLength, dmPaperWidth    CL_CONS_PAPERSIZE
GID_PAGEREGION      N/A
GID_DUPLEX          dmDuplex                                    CL_CONS_DUPLEX
GID_INPUTSLOT       dmDefaultSource                             CL_CONS_INPUTSLOT
GID_MEDIATYPE       dmMediaType                                 CL_CONS_MEDIATYPE
GID_MEMOPTION       N/A
GID_COLORMODE       N/A   (hack something if needed.)
GID_ORIENTATION     dmOrientation                               CL_CONS_ORIENTATION
GID_PAGEPROTECTION  N/A
GID_COLLATE         dmCollate                                   CL_CONS_COLLATE
                        {DMCOLLATE_TRUE, DMCOLLATE_FALSE}
GID_OUTPUTBIN       N/A
GID_HALFTONING      N/A

see DEVMODE  in sdk\inc\wingdi.h

--*/

{

    BOOL    bStatus = FALSE ;
    DWORD   dwFeaIndex = 0, dwOptIndex, dwOptID ;


    switch(dwFeatureID)
    {
        case    GID_RESOLUTION:
        {
            DWORD   dwXres, dwYres ;
            //  we assume caller has initialized both dmPrintQuality and
            //  dmYResolution.

            dwXres = pDevmode->dmPrintQuality ;
            dwYres = pDevmode->dmYResolution ;

            bStatus = BMapResToOptIndex(pInfoHdr, &dwOptIndex, dwXres, dwYres) ;
            if(bStatus &&
                (bStatus = BGIDtoFeaIndex(pInfoHdr,
                &dwFeaIndex, dwFeatureID))  )
            {
                //  don't need to worry about truncating
                //  a list of options, these features
                //  are all PICKONE.
                pOptions[dwFeaIndex].ubCurOptIndex = (BYTE)dwOptIndex ;
                pOptions[dwFeaIndex].ubNext = 0 ;
            }
            return (bStatus);
        }
        case    GID_PAGESIZE:
        {
            if( pDevmode->dmFields & DM_PAPERLENGTH  &&
                   pDevmode->dmFields & DM_PAPERWIDTH  &&
                   pDevmode->dmPaperWidth  &&
                   pDevmode->dmPaperLength)
            {
                // must convert devmode's tenths of mm to microns
                // before calling.

                bStatus = BMapPaperDimToOptIndex(pInfoHdr, &dwOptIndex,
                        pDevmode->dmPaperWidth * 100L,
                        pDevmode->dmPaperLength * 100L, NULL) ;
            }
            else if(pDevmode->dmFields & DM_PAPERSIZE)
            {
                dwOptID = pDevmode->dmPaperSize ;
                bStatus = BMapOptIDtoOptIndex(pInfoHdr, &dwOptIndex,
                        dwFeatureID, dwOptID) ;
            }
            else
                bStatus = FALSE ;

            if(bStatus &&
                (bStatus = BGIDtoFeaIndex(pInfoHdr,
                &dwFeaIndex, dwFeatureID))  )
            {
                pOptions[dwFeaIndex].ubCurOptIndex = (BYTE)dwOptIndex ;
                pOptions[dwFeaIndex].ubNext = 0 ;
                return (bStatus);  // must exit now.
            }
            break ;
        }
        case    GID_DUPLEX:
        {
            if(pDevmode->dmFields & DM_DUPLEX)
            {
                dwOptID = pDevmode->dmDuplex ;
                bStatus = TRUE ;
            }
            break ;
        }
        case    GID_INPUTSLOT:
        {
            if(pDevmode->dmFields & DM_DEFAULTSOURCE)
            {
                dwOptID = pDevmode->dmDefaultSource ;
                bStatus = TRUE ;
            }
            break ;
        }
        case    GID_MEDIATYPE:
        {
            if(pDevmode->dmFields & DM_MEDIATYPE)
            {
                dwOptID = pDevmode->dmMediaType ;
                bStatus = TRUE ;
            }
            break ;
        }
        case    GID_COLORMODE:
        {
            if(pDevmode->dmFields & DM_COLOR)
            {
                //  special processing since devmode
                //  only specifies BW or color printing.

                bStatus = BGIDtoFeaIndex(pInfoHdr,
                                &dwFeaIndex, dwFeatureID) ;

                if(!bStatus)  //  dwFeaIndex could be invalid at this point.
                    return (bStatus);

                //  what is the current color setting?
                dwOptIndex = pOptions[dwFeaIndex].ubCurOptIndex ;

                if(bStatus &&
                    (bStatus = BMapDmColorToOptIndex(pInfoHdr, &dwOptIndex,
                    pDevmode->dmColor))  )
                {
                    pOptions[dwFeaIndex].ubCurOptIndex = (BYTE)dwOptIndex ;
                    pOptions[dwFeaIndex].ubNext = 0 ;
                }
            }
            return (bStatus);
        }
        case    GID_ORIENTATION:
        {
            if(pDevmode->dmFields & DM_ORIENTATION)
            {
                dwOptID = pDevmode->dmOrientation ;


                if(dwOptID == DMORIENT_PORTRAIT)
                    dwOptID = ROTATE_NONE ;
                else
                {
                    dwOptID = ROTATE_90 ;
                    bStatus = BMapOptIDtoOptIndex(pInfoHdr, &dwOptIndex,
                        dwFeatureID, dwOptID) ;
                    if(!bStatus)
                    {
                        dwOptID = ROTATE_270 ;
                    }
                }

                bStatus = TRUE ;
            }
            break ;
        }
        case    GID_COLLATE:
        {
            if(pDevmode->dmFields & DM_COLLATE)
            {
                dwOptID = pDevmode->dmCollate ;
                bStatus = TRUE ;
            }
            break ;
        }
        default:
        {
            break ;
        }
    }
    //  Complete processing for typical case.

    if(bStatus)
    {
        bStatus = BMapOptIDtoOptIndex(pInfoHdr, &dwOptIndex,
                        dwFeatureID, dwOptID) ;
    }
    if(bStatus &&
        (bStatus =  BGIDtoFeaIndex(pInfoHdr,
                &dwFeaIndex, dwFeatureID)  ))
    {
        //  don't need to worry about truncating
        //  a list of options, these features
        //  are all PICKONE.
        pOptions[dwFeaIndex].ubCurOptIndex = (BYTE)dwOptIndex ;
        pOptions[dwFeaIndex].ubNext = 0 ;
    }
    return (bStatus);
}

BOOL    BMapDmColorToOptIndex(
PINFOHEADER  pInfoHdr ,
IN  OUT     PDWORD       pdwOptIndex ,  //  is current setting ok?
                        //  if not return new index to caller
DWORD        dwDmColor  // what is requested in Devmode
)
{
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;
    DWORD       dwNumOpts, loOptOffset, dwI ;
    PCOLORMODE pColorModeOption ;
    BOOL    bColor  ;
    DWORD       loOptExOffset ;
    PCOLORMODEEX pColorModeOptionEx ;


    bColor = (dwDmColor == DMCOLOR_COLOR) ;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_COLORMODE) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD
    dwNumOpts = pFeature->Options.dwCount ;
    loOptOffset = pFeature->Options.loOffset ;

    if(*pdwOptIndex >= dwNumOpts)  //  option index out of range - fix for 185245
    {
        *pdwOptIndex = pFeature->dwDefaultOptIndex ;  //  use the default option
        return(FALSE) ;
    }

    pColorModeOption = OFFSET_TO_POINTER(pInfoHdr, loOptOffset) ;

    loOptExOffset = pColorModeOption[*pdwOptIndex].GenericOption.loRenderOffset ;
    pColorModeOptionEx = OFFSET_TO_POINTER(pInfoHdr, loOptExOffset) ;

    if(bColor == pColorModeOptionEx->bColor)
        return(TRUE) ;  // currently selected colormode
                        // matches devmode request.

    loOptExOffset = pColorModeOption[pFeature->dwDefaultOptIndex].
                                            GenericOption.loRenderOffset ;
    pColorModeOptionEx = OFFSET_TO_POINTER(pInfoHdr, loOptExOffset) ;

    if(bColor == pColorModeOptionEx->bColor)
    {
        *pdwOptIndex = pFeature->dwDefaultOptIndex ;
        return(TRUE) ;  // the default colormode option
    }                    // matches devmode request.


    //  last ditch effort - just find the first matching one.
    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        loOptExOffset = pColorModeOption[dwI].GenericOption.loRenderOffset ;
        pColorModeOptionEx = OFFSET_TO_POINTER(pInfoHdr, loOptExOffset) ;

        if(bColor == pColorModeOptionEx->bColor)
        {
            *pdwOptIndex = dwI ;
            return(TRUE) ;
        }
    }
    return(FALSE) ;  //  no matching colormode found.
}

BOOL    BMapOptIDtoOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwFeatureGID,
DWORD        dwOptID
)
{
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;
    DWORD       dwNumOpts, loOptOffset, dwI, dwIDOffset, dwOptSize, dwCurID ;
    POPTION pOption ;

    switch(dwFeatureGID)
    {
        case GID_HALFTONING:
            dwIDOffset = offsetof(HALFTONING, dwHTID ) ;
            break ;
        case GID_DUPLEX:
            dwIDOffset = offsetof(DUPLEX, dwDuplexID ) ;
            break ;
        case GID_ORIENTATION:
            dwIDOffset = offsetof(ORIENTATION, dwRotationAngle ) ;
            break ;
        case GID_PAGESIZE:
            dwIDOffset = offsetof(PAGESIZE, dwPaperSizeID ) ;
            break ;
        case GID_INPUTSLOT:
            dwIDOffset = offsetof(INPUTSLOT, dwPaperSourceID ) ;
            break ;
        case GID_MEDIATYPE:
            dwIDOffset = offsetof(MEDIATYPE, dwMediaTypeID ) ;
            break ;
        case    GID_COLLATE:
            dwIDOffset = offsetof(COLLATE, dwCollateID ) ;
            break ;
        default:
            return(FALSE);  // this feature has no ID value!
    }

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureGID) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD
    dwNumOpts = pFeature->Options.dwCount ;
    loOptOffset = pFeature->Options.loOffset ;
    dwOptSize =  pFeature->dwOptionSize ;

    pOption = OFFSET_TO_POINTER(pInfoHdr, loOptOffset) ;

    //  just find the first matching one.
    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        dwCurID = *(PDWORD)((PBYTE)pOption + dwI * dwOptSize + dwIDOffset) ;
        if(dwOptID  == dwCurID)
        {
            *pdwOptIndex = dwI ;
            return(TRUE) ;
        }
    }
    return(FALSE) ;  //  no matching ID found.
}


BOOL    BMapPaperDimToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwWidth,   //  in Microns
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes
)
/*++

Routine Description:

    Map logical values to PaperSize option index

Arguments:

    pdwOptIndex - if pdwOptionIndexs == NULL, this
        holds the option index of the first paper matching the
        requested dimensions.   Otherwise this holds the number
        of papers matching the requested dimensions.
    dwWidth , dwLength  - requested Paper Size in Microns
    pdwOptionIndexes - if Not NULL,  this array will be initialized
        with all option  indicies of papers which match the requested size.
        In this case the return value
        is the number of elements in the array initialized.   Currently
        we assume the array is large enough (256 elements).


Return Value:

TRUE:  found one or more papers of the size requested.

--*/

{
    PUIINFO     pUIInfo ;
    PGPDDRIVERINFO  pDrvInfo ;
    PFEATURE    pFeature ;
    DWORD       dwNumOpts, loOptOffset, dwI ,
                dwError, dwErrorY, dwCustomIndex,
                dwOptWidth , dwOptLength,
                dwMinWidth , dwMinLength,
                dwMaxWidth , dwMaxLength,
                dwOutArrayIndex = 0;
    PPAGESIZE pPaperOption ;
    BOOL    bFits = FALSE ;  // does custom size fit request?

    //  Convert from Microns to Master units.


    dwWidth /= 100 ;  // microns to tenths of mm
    dwLength /= 100 ;

    pDrvInfo = (PGPDDRIVERINFO) GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHdr) ;

    dwWidth *= pDrvInfo->Globals.ptMasterUnits.x ;
    dwLength *= pDrvInfo->Globals.ptMasterUnits.y ;

    dwWidth /= 254 ;
    dwLength /= 254 ;

    dwError = pDrvInfo->Globals.ptMasterUnits.x / 100 ;
    dwErrorY = pDrvInfo->Globals.ptMasterUnits.y / 100 ;

    dwError = (dwError > dwErrorY) ? dwError : dwErrorY ;
    dwError = (dwError > 3) ? dwError : 3 ;

    //  give leeway of 3 master units or 1/100 inch whichever
    //  is greater.

    dwMinWidth = (dwWidth < dwError) ? 0 : (dwWidth - dwError) ;
    dwMinLength = (dwLength < dwError) ? 0 : (dwLength - dwError) ;

    dwMaxWidth = dwWidth + dwError ;
    dwMaxLength = dwLength + dwError ;


    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD
    dwNumOpts = pFeature->Options.dwCount ;
    loOptOffset = pFeature->Options.loOffset ;

    pPaperOption = OFFSET_TO_POINTER(pInfoHdr, loOptOffset) ;



    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        if(pPaperOption[dwI].dwPaperSizeID != DMPAPER_USER)
        {
            dwOptWidth = pPaperOption[dwI].szPaperSize.cx  ;
            dwOptLength = pPaperOption[dwI].szPaperSize.cy ;
            if(dwOptWidth > dwMinWidth   &&  dwOptWidth < dwMaxWidth  &&
                dwOptLength > dwMinLength   &&  dwOptLength < dwMaxLength )
            {
                if(pdwOptionIndexes)
                    pdwOptionIndexes[dwOutArrayIndex++] = dwI ;
                else
                {
                    *pdwOptIndex = dwI ;
                    return(TRUE) ;
                }
            }
        }
        else // this is the custom size:
        {
            DWORD       loOptExOffset ;
            PPAGESIZEEX pPaperOptionEx ;

            loOptExOffset = pPaperOption[dwI].GenericOption.loRenderOffset ;
            pPaperOptionEx = OFFSET_TO_POINTER(pInfoHdr, loOptExOffset) ;

            //  does it fit the requested size?
            if(dwWidth <= (DWORD)pPaperOptionEx->ptMaxSize.x  &&
                dwWidth >= (DWORD)pPaperOptionEx->ptMinSize.x  &&
                dwLength <= (DWORD)pPaperOptionEx->ptMaxSize.y  &&
                dwLength >= (DWORD)pPaperOptionEx->ptMinSize.y  )
            {
                bFits = TRUE ;
                dwCustomIndex = dwI ;
            }
        }
    }

    if(pdwOptionIndexes)
    {
        if(bFits)
        {
            pdwOptionIndexes[dwOutArrayIndex++] = dwCustomIndex ;
        }
        *pdwOptIndex = dwOutArrayIndex ;
            //  cover the case where dwOutArrayIndex = 0.
        if(dwOutArrayIndex)
            return(TRUE) ;
        return(FALSE) ;
    }

    if(bFits)
    {
        *pdwOptIndex = dwCustomIndex ;
        return(TRUE) ;
    }
    return(FALSE) ;
}




BOOL    BMapResToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwXres,
DWORD        dwYres
)
{
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;
    DWORD       dwNumOpts, loOptOffset, dwI ;
    DWORD  dwHighRes, dwLowRes, dwMedRes, dwDefRes,  dwCurRes,
                   //  in pixels per square inch.
       dwHighIndex, dwLowIndex, dwMedIndex, dwDefIndex ;
    PRESOLUTION pResOption ;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_RESOLUTION) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD
    dwNumOpts = pFeature->Options.dwCount ;
    loOptOffset = pFeature->Options.loOffset ;

    pResOption = OFFSET_TO_POINTER(pInfoHdr, loOptOffset) ;


    if((signed)dwXres > 0)
    {

        dwDefIndex = pFeature->dwDefaultOptIndex ;
        if(dwXres == (DWORD)pResOption[dwDefIndex].iXdpi  &&
                           dwYres ==  (DWORD)pResOption[dwDefIndex].iYdpi)
        {
            *pdwOptIndex = dwDefIndex ;
            return(TRUE) ;
        }

        for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
        {
            if(dwXres == (DWORD)pResOption[dwI].iXdpi  &&
                   dwYres == (DWORD)pResOption[dwI].iYdpi)
            {
                *pdwOptIndex = dwI ;
                return(TRUE) ;
            }
        }
    }
    else if ((signed)dwXres  > RES_ID_IGNORE)  //  OEM defined ID
    {
        for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
        {
            if(dwXres == (DWORD)pResOption[dwI].dwResolutionID)
            {
                *pdwOptIndex = dwI ;
                return(TRUE) ;
            }
        }
    }

     //  if exact match fails, or predefined negative value or nonsense
     //     resort to fuzzy match.

     //  first determine the highest, lowest, 2nd highest and default resolutions.

    dwHighIndex = dwLowIndex = dwMedIndex = dwDefIndex =
            pFeature->dwDefaultOptIndex ;

    dwHighRes = dwLowRes = dwMedRes = dwDefRes =
                            (DWORD)pResOption[dwDefIndex].iXdpi  *
                            (DWORD)pResOption[dwDefIndex].iYdpi ;

     //  note overflow possible if resolution exceeds 64k dpi.

     for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
     {
         dwCurRes =  (DWORD)pResOption[dwI].iXdpi  *
                            (DWORD)pResOption[dwI].iYdpi ;

         if(dwCurRes > dwHighRes)
         {
             dwHighIndex = dwI ;
             dwHighRes = dwCurRes ;
         }
         else        if(dwCurRes < dwLowRes)
         {
             dwLowIndex = dwI ;
             dwLowRes = dwCurRes ;
         }
         else  if(dwCurRes < dwHighRes  &&  dwCurRes > dwLowRes  &&
             (dwMedRes == dwHighRes  ||  dwMedRes == dwLowRes  ||  dwCurRes > dwMedRes))
         {
             dwMedIndex = dwI ;         //  if more than one middle res possible
             dwMedRes = dwCurRes ;      //  choose the largest.
         }

     }

     //  if (default res is not the highest or lowest, make default res the middle resolution
      if(dwDefRes < dwHighRes  &&  dwDefRes > dwLowRes)
     {
          dwMedIndex = dwDefIndex ;
          dwMedRes = dwDefRes ;           //  unnecessary code, but just in case
                                                            //  like the last break in a switch statement.
     }

     switch(dwXres)
     {
         case(DMRES_DRAFT):
         case(DMRES_LOW):
             *pdwOptIndex = dwLowIndex ;
             break;
         case(DMRES_MEDIUM):
             *pdwOptIndex = dwMedIndex ;
             break;
         case(DMRES_HIGH):
             *pdwOptIndex = dwHighIndex ;
             break;
         default:
             *pdwOptIndex = dwDefIndex ;
             break;
     }
     return(TRUE) ;
}


BOOL    BGIDtoFeaIndex(
PINFOHEADER  pInfoHdr ,
PDWORD       pdwFeaIndex ,
DWORD        dwFeatureGID )
{
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureGID) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD

    *pdwFeaIndex  = (DWORD)GET_INDEX_FROM_FEATURE(pUIInfo, pFeature) ;
    return(TRUE) ;
}


DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes       // used only for GID_PAGESIZE
    )
{
    return (          UniMapToDeviceOptIndex(
                pInfoHdr , dwFeatureID,  lParam1,  lParam2,
                pdwOptionIndexes,       // used only for GID_PAGESIZE
                NULL) ) ;
}



DWORD
UniMapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes,       // used only for GID_PAGESIZE
    IN    PDWORD       pdwPaperID   //  optional paperID
    )
/*++

Routine Description:

    Map logical values to device feature option index

Arguments:

    pRawData - Points to raw binary printer description data
    dwFeatureID - Indicate which feature the logical values are related to
    lParam1, lParam2  - Parameters depending on dwFeatureID
    pdwOptionIndexes - if Not NULL, means fill this array with all indicies
        which match the search criteria.   In this case the return value
        is the number of elements in the array initialized.   Currently
        we assume the array is large enough (256 elements).

    dwFeatureID = GID_PAGESIZE:
        map logical paper specification to physical page size option

        lParam1 = paper width in microns
        lParam2 = paper height in microns

        IF lParam1 or 2 is set to zero, this function assumes
        pdwPaperID points to the OptionID of a paper.
        It will return the first paper found matching this ID.

    dwFeatureID = GID_RESOLUTION:
        map logical resolution to physical resolution option

        lParam1 = x-resolution in dpi
        lParam2 = y-resolution in dpi

Return Value:

    Index of the feature option corresponding to the specified logical values;
    OPTION_INDEX_ANY if the specified logical values cannot be mapped to
    any feature option.

    if pdwOptionIndexes  Not NULL, the return value is the number of elements
    written to.  Zero means  the specified logical values cannot be mapped to
    any feature option.


--*/

{

    DWORD   dwOptIndex;


    switch (dwFeatureID)
    {
        case    GID_PAGESIZE:
        {
            if(pdwOptionIndexes)
                return(   MapPaperAttribToOptIndex(
                    pInfoHdr ,
                    pdwPaperID ,  //  optional paperID
                    (DWORD)lParam1, (DWORD)lParam2,  //  in Microns
                    pdwOptionIndexes) ) ;

            if(BMapPaperDimToOptIndex(pInfoHdr, &dwOptIndex,
                (DWORD)lParam1, (DWORD)lParam2, NULL) )
                return(dwOptIndex) ;
            break ;
        }
        case    GID_RESOLUTION:
        {
            if( BMapResToOptIndex(pInfoHdr, &dwOptIndex,
                (DWORD)lParam1, (DWORD)lParam2) )
                return(dwOptIndex) ;
            break ;
        }
        default:
            break ;
    }
    return(OPTION_INDEX_ANY) ;
}

DWORD   MapPaperAttribToOptIndex(
PINFOHEADER  pInfoHdr ,
IN     PDWORD       pdwPaperID ,  //  optional paperID
DWORD        dwWidth,   //  in Microns (set to zero to ignore)
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes  //  cannot be NULL
)
{
    DWORD  dwNumFound;
    BOOL    bStatus ;

    if(dwWidth  &&  dwLength)
    {
        if( BMapPaperDimToOptIndex(pInfoHdr, &dwNumFound,
                dwWidth , dwLength, pdwOptionIndexes) )
              return(dwNumFound);
        return(0);
    }

    if(pdwPaperID)  // use paperID instead of dimensions
    {
        bStatus = BMapOptIDtoOptIndex(pInfoHdr, pdwOptionIndexes,
                GID_PAGESIZE, *pdwPaperID) ;
        return(bStatus ? 1 : 0) ;
    }
    return(0);  // if given nothing, return nothing
}


BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    )
{
#ifndef KERNEL_MODE

    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubHeap ,  // start of string heap.
            pubRaw ;  //  raw binary data.
    DWORD           dwNodeIndex ,
                    dwCNode ;  //  index to a Constraint node
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
//    PINVALIDCOMBO   pinvc ;    //  root of invalid combo nodes
    PCONSTRAINTS    pcnstr ;   //  root of Constraint nodes
    BOOL    bReflected = FALSE ;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    patt = (PATTRIB_TREE)(pubRaw +
            pearTableContents[MTI_ATTRIBTREE].loOffset) ;
//    pinvc = (PINVALIDCOMBO) (pubRaw +
//            pearTableContents[MTI_INVALIDCOMBO].loOffset) ;
    pcnstr = (PCONSTRAINTS) (pubRaw +
            pearTableContents[MTI_CONSTRAINTS].loOffset) ;
    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;

TRYAGAIN:

    patrRoot = &(pfo[dwFeature1].atrConstraints) ;

    dwNodeIndex = DwFindNodeInCurLevel(patt , patrRoot , dwOption1) ;

    if(dwNodeIndex == INVALID_INDEX)
        goto  REFLECTCONSTRAINT ;

    if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP)
    {
        ERR(("Internal error.  CheckFeatureOptionConflict - Unexpected Sublevel found for atrConstraints.\n"));
        goto  REFLECTCONSTRAINT ;
    }

    dwCNode = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

    while(1)
    {
        if(pcnstr[dwCNode].dwFeature == dwFeature2  &&
            pcnstr[dwCNode].dwOption == dwOption2)
            return(TRUE) ;  // a constraint does exist.

        dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
        if(dwCNode == END_OF_LIST)
            break ;
    }

REFLECTCONSTRAINT :

    if(!bReflected)
    {
        DWORD   dwSwap ;

        dwSwap = dwFeature2 ;
        dwFeature2 = dwFeature1 ;
        dwFeature1 = dwSwap ;

        dwSwap = dwOption2 ;
        dwOption2 = dwOption1 ;
        dwOption1 = dwSwap ;

        bReflected = TRUE ;
        goto    TRYAGAIN;
    }

//  else  continue on to FINDINVALIDCOMBOS

//  oops this function doesn't care about
//  InvalidCombos!  It only knows about
//  2 qualified objects.



#else
    RIP(("CheckFeatureOptionConflict not implemented in Kernel Mode")) ;
#endif
    return(FALSE);  //  no constraint found.
}




VOID
ValidateDocOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    )

/*++

Routine Description:

    Validate the devmode option array and correct any invalid option selections

Arguments:

    pnRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures that need validation
    iMaxOptions - Max number of entries in pOptions array

Return Value:

    None

--*/

{
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubRaw ;  //  raw binary data.
    INT     NumDocFea = 0;
    INT   iIndex = 0;
    DWORD  nFeatures = 0 ;  //  total number of Doc and Printer Features
    DWORD  FeaIndex = 0 ;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    POPTSELECT      pCombinedOptions = NULL;  //  holds result of merging pOptions with a NULL array
    POPTSELECT      pDefaultOptions = NULL;      //  holds a default option array.  Source of default values.
    BOOL  bStatus = TRUE ;
    DWORD  MaxIndex = (iMaxOptions < MAX_COMBINED_OPTIONS) ? iMaxOptions : MAX_COMBINED_OPTIONS ;


    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA
    NumDocFea = pRawData->dwDocumentFeatures ;

    if(!pOptions)
    {
        RIP(("ValidateDocOptions: NULL  Option array not permitted.\n"));
        return ;
    }

    if(iMaxOptions < NumDocFea)
    {
        RIP(("ValidateDocOptions: Option array too small: %d < %d\n", iMaxOptions, NumDocFea));
        goto Abort;
    }
    pubRaw = (PBYTE)pRawData ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;  //  location of Feature 0.

    //  allocate memory to hold combined option array
    //  allocate another one to hold initialized default option array

    pCombinedOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;
    pDefaultOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;

    if( !pCombinedOptions  || !pDefaultOptions )
        goto Abort;

    //  verify any pick many slots don't create overlapping or endless loops.
    //  use pCombinedOptions to track them.
    for(iIndex =  NumDocFea  ; iIndex < MAX_COMBINED_OPTIONS ; iIndex++)
    {
        pCombinedOptions[iIndex].ubCurOptIndex = 0 ; // these are available to hold pickmany selections
    }
    for(iIndex = 0 ; iIndex < NumDocFea ; iIndex++)
    {
        DWORD  NextArrayEle = pOptions[iIndex].ubNext ;

        for (   ; (NextArrayEle != NULL_OPTSELECT)  ; NextArrayEle = pOptions[NextArrayEle].ubNext)
        {
            if((NextArrayEle >= MaxIndex) || ((INT)NextArrayEle <  NumDocFea) ||
                        (pCombinedOptions[NextArrayEle].ubCurOptIndex) )
            {  //  NextArrayEle out of bounds or overwrites a previous slot.
                pOptions[iIndex].ubNext = NULL_OPTSELECT;
                break;  //  just terminate this pickmany list.
            }
            pCombinedOptions[NextArrayEle].ubCurOptIndex = 1 ; // reserve this slot.
        }
    }


    bStatus = InitDefaultOptions( pnRawData, pDefaultOptions, MAX_COMBINED_OPTIONS,
                                                    MODE_DOCANDPRINTER_STICKY) ;

    if(!bStatus)
        goto Abort;

    //  must merge input pOptions to create a combined option array.

    bStatus = CombineOptionArray( pnRawData,  pCombinedOptions,  iMaxOptions,
                pOptions,  NULL) ;

    if(!bStatus)
        goto Abort;


    nFeatures = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures ;

    if(nFeatures > MAX_COMBINED_OPTIONS)
        goto Abort;

    for(FeaIndex = 0 ; FeaIndex < nFeatures ; FeaIndex++)
    {
        DWORD  nOptions = 0 ;  //  number of options available for this Feature
        DWORD  NextArrayEle = 0 ;  //  index into option array esp for PickMany
        DWORD  cSelectedOptions = 0;  //  how many options have been selected for this feature?

        nOptions = pfo[FeaIndex].dwNumOptions ;
        NextArrayEle = FeaIndex;
        bStatus = TRUE;

        do
        {
            cSelectedOptions++;

            if ((NextArrayEle >= MAX_COMBINED_OPTIONS) ||       //  index out of range
                (pCombinedOptions[NextArrayEle].ubCurOptIndex >= nOptions) ||  //  selected option out of range
                (cSelectedOptions > nOptions))  //  too many options selected (for pick many)
            {
                //
                // either the option index is out of range,
                // or the current option selection is invalid,
                // or the number of selected options (for PICKMANY)
                // exceeds available options
                //

                bStatus = FALSE;
                break;
            }

            NextArrayEle = pCombinedOptions[NextArrayEle].ubNext;

        } while (NextArrayEle != NULL_OPTSELECT);
        if (!bStatus)
        {
            pCombinedOptions[FeaIndex].ubCurOptIndex =
                    pDefaultOptions[FeaIndex].ubCurOptIndex;

            pCombinedOptions[FeaIndex].ubNext = NULL_OPTSELECT;
        }
    }
    //  separate combined option array into doc sticky part and
    //  store that in pOptions.

    bStatus = SeparateOptionArray(pnRawData, pCombinedOptions,
              pOptions, iMaxOptions, MODE_DOCUMENT_STICKY ) ;

    if(!bStatus)
        goto Abort;


    if(pCombinedOptions)
        MemFree(pCombinedOptions) ;
    if(pDefaultOptions)
        MemFree(pDefaultOptions) ;
    return ;  //  Normal return path

Abort:                  // something has gone totally haywire.
    if(iMaxOptions > NumDocFea )
        iMaxOptions = NumDocFea ;

    for(iIndex = 0 ; iIndex < iMaxOptions ; iIndex++)
    {
        pOptions[iIndex].ubCurOptIndex = 0 ;
        pOptions[iIndex].ubNext = NULL_OPTSELECT;
    }
    if(pCombinedOptions)
        MemFree(pCombinedOptions) ;
    if(pDefaultOptions)
        MemFree(pDefaultOptions) ;
    return ;    // error return path.
}



BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )
{
    DWORD   dwNumFeatures, dwFea, dwStart, dwI, dwDestTail,
        dwDest, dwSrcTail, dwNumOpts, dwNEnabled, dwJ ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubRaw ;  //  raw binary data.
    PDWORD   pdwPriority ;
    BOOL   bStatus = FALSE, bUnresolvedConflict = FALSE ,
        bEnable = FALSE ;  //  feature will constrain others
    PBOOL   pbUseConstrnt, pbEnabledOptions, pbSelectedOptions ;
    INT     iOptionsNeeded;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;


#ifdef  GMACROS
    if(!ResolveDependentSettings( pnRawData,  pOptions, iMaxOptions) )
        return(FALSE);
#endif


    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    pdwPriority = (PDWORD)(pubRaw +
            pearTableContents[MTI_PRIORITYARRAY].loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    if(dwNumFeatures > (DWORD)iMaxOptions)
    {
        iOptionsNeeded = dwNumFeatures ;
        return(FALSE);  // too many to save in option array.
    }

#if 0
    pbUseConstrnt = (PBOOL)MemAlloc(dwNumFeatures * sizeof(BOOL) ) ;
    pbEnabledOptions = (PBOOL)MemAlloc(256 * sizeof(BOOL) ) ;
    pbSelectedOptions = (PBOOL)MemAlloc(256 * sizeof(BOOL) ) ;
#endif

    pbSelectedOptions = (PBOOL)MemAlloc((256*2 + dwNumFeatures) * sizeof(BOOL) ) ;
    //  this is the union of the allowable selections
    //  and what was actually selected in pOptions for this feature.
    //  BUG_BUG:  assumes we won't have more than 256 options

    pbEnabledOptions = pbSelectedOptions + 256  ;
    //  these are the allowable selections
    pbUseConstrnt = pbEnabledOptions + 256    ;

    if(!(pbUseConstrnt && pbEnabledOptions && pbSelectedOptions ))
    {
        ERR(("Fatal: ResolveUIConflicts - unable to alloc requested memory: %d bytes.\n",
                    dwNumFeatures * sizeof(BOOL)));
        goto    ABORTRESOLVEUICONFLICTS ;
    }

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
        pbUseConstrnt[dwI] = FALSE ;


    for(dwNEnabled = dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        //  The order of evaluation is determined
        //  by the priority array.

        dwFea = pdwPriority[dwI] ;

        bEnable = FALSE ;

        if(iMode == MODE_DOCANDPRINTER_STICKY)
            bEnable = TRUE ;
        else
        {
            DWORD   dwFeatureType = FT_PRINTERPROPERTY, dwNextOpt, dwUnresolvedFeature  ;
            PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

            //  is this a printer or doc sticky feature?


            patrRoot = &(pfo[dwFea].atrFeatureType) ;

            dwNextOpt = 0 ;  // extract info for first option selected for
                                //  this feature.

            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
                (PBYTE)&dwFeatureType,
                &dwUnresolvedFeature,  *patrRoot, pOptions,
                0, // set to  any value.  Doesn't matter.
                &dwNextOpt) != TRI_SUCCESS)
            {
                ERR(("ResolveUIConflicts: EextractValueFromTree failed.\n"));
                bUnresolvedConflict = TRUE ;
                goto    ABORTRESOLVEUICONFLICTS ;  // return(FALSE) ;
            }

            if(dwFeatureType != FT_PRINTERPROPERTY)
            {
                if(iMode == MODE_DOCUMENT_STICKY)
                    bEnable = TRUE ;
            }
            else
            {
                if(iMode == MODE_PRINTER_STICKY)
                    bEnable = TRUE ;
            }
        }

        if(bEnable)  //  Feature is to be applied as constraint
        {
            pbUseConstrnt[dwFea] = TRUE ;
            dwNEnabled++ ;
        }
        else
            continue ;  // not interested in this feature
        if(dwNEnabled < 2)
            continue ;  // not enough Features enabled
                    //  to constrain each other.

        bStatus = BSelectivelyEnumEnabledOptions(
            pnRawData,
            pOptions,
            dwFea,
            pbUseConstrnt,  // if non NULL
            pbEnabledOptions,
            0,
            NULL    //  pConflictPair
            ) ;


        dwNumOpts = pfo[dwFea].dwNumOptions ;

        for(dwJ = 0 ; dwJ < dwNumOpts ; dwJ++)
            pbSelectedOptions[dwJ] = FALSE ;

        if(!bStatus)
        {
            pbSelectedOptions[0] = TRUE ;
            // just set this to a harmless value.
        }
        else
        {
            DWORD   dwNext = dwFea ;
            while(1)
            {
                if(pbEnabledOptions[pOptions[dwNext].ubCurOptIndex])
                    pbSelectedOptions[pOptions[dwNext].ubCurOptIndex] = TRUE ;
                dwNext = pOptions[dwNext].ubNext ;
                if(!dwNext)
                    break ;  //  end of list of options.
            }
        }

        for(dwJ = 0 ; dwJ < dwNumOpts ; dwJ++)
        {
            if(pbSelectedOptions[dwJ])
                break ;  // is anything actually selected?
        }
        if(dwJ >= dwNumOpts)
        {
            DWORD  dwDefaultOption, dwNextOpt, dwUnresolvedFeature  ;
            PATREEREF    patrRoot ;    //  root of attribute tree to navigate.


            //  none of the original selections survived
            //  see if the default option can be used.
            //  first, determine the index of the default option.

            patrRoot = &(pfo[dwFea].atrDefaultOption) ;

            dwNextOpt = 0 ;  // extract info for first option selected for
                                //  this feature.

            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSdefaultOptionIndex,
               (PBYTE)&dwDefaultOption,
               &dwUnresolvedFeature,  *patrRoot, pOptions,
               0, // set to  any value.  Doesn't matter.
               &dwNextOpt) == TRI_SUCCESS  &&
               pbEnabledOptions[dwDefaultOption])
            {
                pbSelectedOptions[dwDefaultOption] = TRUE ;
            }
            else  //  randomly pick something that isn't constrained.
            {
                if(!dwFea)   // hack for synthesized Inputslot.
                    pbEnabledOptions[0] = FALSE ;   // never allow autoselect to be selected
                    // if it wasn't initially selected.        bug 100722

                for(dwJ = 0 ; dwJ < dwNumOpts ; dwJ++)
                {
                    if(pbEnabledOptions[dwJ])
                        break ;
                }
                if(dwJ >= dwNumOpts)
                {
                    ERR(("ResolveUIConflicts: Constraints prevent any option from being selected!\n"));
                    pbSelectedOptions[0] = TRUE ;  // ignoring constraint.
                    bUnresolvedConflict = TRUE ;
                }
                else
                    pbSelectedOptions[dwJ] = TRUE ;  // Picked one.
            }
        }

        bStatus = ReconstructOptionArray(
            pnRawData,
            pOptions,
            iMaxOptions,
            dwFea,
            pbSelectedOptions) ;
        if(!bStatus)
        {
            ERR(("ResolveUIConflicts: ReconstructOptionArray failed.\n"));
            bUnresolvedConflict = TRUE ;
        }
    }  // end of processing for this feature

ABORTRESOLVEUICONFLICTS:
#if 0
    if(pbUseConstrnt)
        MemFree(pbUseConstrnt) ;
    if(pbEnabledOptions)
        MemFree(pbEnabledOptions) ;
#endif
    if(pbSelectedOptions)
        MemFree(pbSelectedOptions) ;

    return(!bUnresolvedConflict);
}

BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions ,
    IN INT              iMode
    //  either  MODE_DOCANDPRINTER_STICKY  or  MODE_PRINTER_STICKY
    )
{
#ifndef KERNEL_MODE

    if(iMode  ==   MODE_PRINTER_STICKY)
    {
        return(EnumOptionsUnconstrainedByPrinterSticky(
            pnRawData,
            pOptions,
            dwFeatureIndex,
            pbEnabledOptions
            )      ) ;
    }
    else
    {
        return(BSelectivelyEnumEnabledOptions(
            pnRawData,
            pOptions,
            dwFeatureIndex,
            NULL,    // pbHonorConstraints
            pbEnabledOptions,
            0,  //  dwOptSel
            NULL) ) ;
    }
    #else
    RIP(("GpdEnumEnabledOptions not implemented in Kernel Mode")) ;
    return(FALSE);
#endif
}




BOOL
EnumOptionsUnconstrainedByPrinterSticky(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT   pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions
    )
{
    DWORD   dwNumFeatures, dwFea, dwI, dwNumOpts, dwNEnabled, dwJ ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubRaw ;  //  raw binary data.
    BOOL   bStatus = FALSE ;
    PBOOL   pbUseConstrnt ;

    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA
    pubRaw = (PBYTE)pRawData ;
    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    pbUseConstrnt = (PBOOL)MemAlloc(dwNumFeatures * sizeof(BOOL) ) ;

    if(!pbUseConstrnt)
    {
        ERR(("Fatal: EnumOptionsUnconstrainedByPrinterSticky - unable to alloc requested memory: %d bytes.\n",
                    dwNumFeatures * sizeof(BOOL)));
        goto    ABORTENUMOPTIONSUNCONSTRAINEDBYPRINTERSTICKY ;
    }

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
        pbUseConstrnt[dwI] = FALSE ;


    for(dwNEnabled = dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        DWORD   dwFeatureType = FT_PRINTERPROPERTY,
        dwNextOpt,  dwUnresolvedFeature ;
        PATREEREF    patrRoot ;    //  root of attribute tree to navigate.


        //  is this a printer or doc sticky feature?


        patrRoot = &(pfo[dwFea].atrFeatureType) ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
            (PBYTE)&dwFeatureType,
            &dwUnresolvedFeature,  *patrRoot, pOptions,
            0, // set to  any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("ResolveUIConflicts: EextractValueFromTree failed.\n"));
            bStatus = FALSE ;
            goto    ABORTENUMOPTIONSUNCONSTRAINEDBYPRINTERSTICKY ;
        }


         if(dwFeatureType == FT_PRINTERPROPERTY)
        {
            pbUseConstrnt[dwFea] = TRUE ;
            dwNEnabled++ ;
        }
    }


    if(!pbUseConstrnt[dwFeatureIndex])  // queried feature isn't PrinterSticky
    {
        pbUseConstrnt[dwFeatureIndex] = TRUE ;
        dwNEnabled++ ;
    }

    if(dwNEnabled < 2)
    {
        dwNumOpts = pfo[dwFeatureIndex].dwNumOptions ;

        for(dwJ = 0 ; dwJ < dwNumOpts ; dwJ++)
            pbEnabledOptions[dwJ] = TRUE ;

        bStatus = TRUE  ;  // not enough Features enabled
                //  to constrain each other.
    }
    else
    {
        bStatus = BSelectivelyEnumEnabledOptions(
            pnRawData,
            pOptions,
            dwFeatureIndex,
            pbUseConstrnt,  // if non NULL
            pbEnabledOptions,
            0,
            NULL    //  pConflictPair
            ) ;
    }

ABORTENUMOPTIONSUNCONSTRAINEDBYPRINTERSTICKY:
    if(pbUseConstrnt)
        MemFree(pbUseConstrnt) ;

    return(bStatus);
}







BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    )
{
#ifndef KERNEL_MODE


    BSelectivelyEnumEnabledOptions(
        pnRawData,
        pOptions,
        dwFeatureIndex,
        NULL,
        pbSelectedOptions,
        0,  //  dwOptSel
        pConflictPair   ) ;


    return (pConflictPair->dwFeatureIndex1 != 0xFFFFFFFF);
#else
    RIP(("GpdEnumNewUIConflict not implemented in Kernel Mode")) ;
    return(FALSE);
#endif
}

BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    )
{
#ifndef KERNEL_MODE

    BSelectivelyEnumEnabledOptions(
        pnRawData,
        pOptions,
        dwFeatureIndex,
        NULL,
        NULL,   //  pbSelectedOptions
        dwOptionIndex,
        pConflictPair   ) ;

    return (pConflictPair->dwFeatureIndex1 != 0xFFFFFFFF);
#else
    RIP(("GpdEnumNewPickOneUIConflict not implemented in Kernel Mode")) ;
    return(FALSE);
#endif
}





BOOL
BIsFeaOptionCurSelected(
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex
    )
/*
    returns TRUE  if the specified Feature/Option is
    currently selected in pOptions.  FALSE otherwise.
*/
{
    DWORD   dwSrcTail ;

    if(pOptions[dwFeatureIndex].ubCurOptIndex == dwOptionIndex)
        return(TRUE);

    dwSrcTail = pOptions[dwFeatureIndex].ubNext ;

    while(dwSrcTail)    //  PickMany options
    {
        if(pOptions[dwSrcTail].ubCurOptIndex == dwOptionIndex)
            return(TRUE);
        dwSrcTail = pOptions[dwSrcTail].ubNext ;
    }
    return(FALSE);
}




BOOL
BSelectivelyEnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL           pbHonorConstraints,  // if non NULL
        // points to array of BOOL corresponding to each feature.
        //  if TRUE means constraint involving this feature is
        //  to be honored.  Otherwise ignore the constraint.
    OUT PBOOL           pbEnabledOptions,  // assume uninitialized
        //  if pConflictPair is NULL else contains current or proposed
        //  selections.  We will leave this array unchanged in this case.
    IN  DWORD   dwOptSel,  //  if pConflictPair exists but  pbEnabledOptions
        //  is NULL, assume pickone and dwOptSel holds that selection for
        //  the feature: dwFeatureIndex.
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
        //  actually lists the current selections.  Function then
        //  exits after encountering the first conflict.
        //  if a conflict exists, all fields in pConflictPair
        //  will be properly initialized  else dwFeatureIndex1 = -1
        //  the return value will be TRUE regardless.
    )
/*
    return value is FALSE if every option for this
    feature is constrained or other abnormal condition
    was encountered.

*/
{
    PDFEATURE_OPTIONS  pfo ;
    PBYTE   pubHeap ,  // start of string heap.
            pubRaw ;  //  raw binary data.
    PENHARRAYREF   pearTableContents ;
    DWORD   dwI, dwNumFea , dwNumOpts, dwFea, dwSrcTail, dwNodeIndex,
        dwCFeature, dwCOption ,
        dwCNode, dwICNode, dwNextInvCombo;
    BOOL    bStatus, bConstrained, bNextLinkFound  ;
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    PCONSTRAINTS    pcnstr ;   //  root of Constraint nodes
    PINVALIDCOMBO   pinvc ;    //  root of invalid combo nodes
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    BOOL   pbNewEnabledOptions[MAX_COMBINED_OPTIONS] ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA



    pubRaw = (PBYTE)pRawData ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    patt = (PATTRIB_TREE)(pubRaw +
            pearTableContents[MTI_ATTRIBTREE].loOffset) ;
    pcnstr = (PCONSTRAINTS) (pubRaw +
            pearTableContents[MTI_CONSTRAINTS].loOffset) ;
    pinvc = (PINVALIDCOMBO) (pubRaw +
            pearTableContents[MTI_INVALIDCOMBO].loOffset) ;
    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;


    dwNumFea = pRawData->dwDocumentFeatures +
                        pRawData->dwPrinterFeatures ;

    dwNumOpts = pfo[dwFeatureIndex].dwNumOptions ;


    if(pConflictPair)
    {
        pConflictPair->dwFeatureIndex1 = dwFeatureIndex ;
        pConflictPair->dwFeatureIndex2 = 0xFFFFFFFF;
            // Gets set to indicate we have a constraint.
        //  leave  pbEnabledOptions  as is.  These are
        //  the options currently selected for this feature.

        #if 0
        if(!(pbNewEnabledOptions = (PBOOL)MemAlloc(dwNumOpts * sizeof(BOOL) ) ))
        {
            ERR(("Fatal: BSelectivelyEnumEnabledOptions - unable to alloc %d bytes.\n",
                dwNumOpts * sizeof(BOOL) ));
            return(FALSE) ;
        }
        #endif

        if(pbEnabledOptions)
        {
            for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
                pbNewEnabledOptions[dwI] = pbEnabledOptions[dwI] ;
        }
        else
        {
            for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
                pbNewEnabledOptions[dwI] = FALSE ;
            pbNewEnabledOptions[dwOptSel] = TRUE ;
        }

        pbEnabledOptions = pbNewEnabledOptions ;  // forget the original.
    }
    else
    {
        for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
            pbEnabledOptions[dwI] = TRUE ;
    }

    if(!pbEnabledOptions)
    {
        RIP(("BSelectivelyEnumEnabledOptions: pbEnabledOptions is NULL")) ;
        return(FALSE);
    }


    for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
    {
        if(dwFea == dwFeatureIndex)
            continue ;
        if(pbHonorConstraints  &&  !pbHonorConstraints[dwFea])
            continue ;

        bStatus = BEnumImposedConstraintsOnFeature(pnRawData, dwFeatureIndex,
            dwFea, pOptions[dwFea].ubCurOptIndex, pbEnabledOptions, pConflictPair) ;
        if(pConflictPair  &&  pConflictPair->dwFeatureIndex2 != 0xFFFFFFFF)
        {
            //  MemFree(pbEnabledOptions) ;
            return(TRUE) ;  // Meaningless return value.
        }

        dwSrcTail = pOptions[dwFea].ubNext ;

        while(dwSrcTail)    //  PickMany options
        {
            if(!BEnumImposedConstraintsOnFeature(pnRawData, dwFeatureIndex,
                dwFea, pOptions[dwSrcTail].ubCurOptIndex, pbEnabledOptions,
                pConflictPair) )
                bStatus = FALSE;
            if(pConflictPair  &&  pConflictPair->dwFeatureIndex2 != 0xFFFFFFFF)
            {
                //  MemFree(pbEnabledOptions) ;
                return(TRUE) ;  // Meaningless return value.
            }
            dwSrcTail = pOptions[dwSrcTail].ubNext ;
        }
    }

    patrRoot = &(pfo[dwFeatureIndex].atrConstraints) ;

    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        if(!pbEnabledOptions[dwI])
            continue ;
        dwNodeIndex = DwFindNodeInCurLevel(patt , patrRoot , dwI) ;

        if(dwNodeIndex == INVALID_INDEX)
            continue ;  // this option has no constraints
        if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP)
        {
            ERR(("Internal error.  BSelectivelyEnumEnabledOptions - Unexpected Sublevel found for atrConstraints.\n"));
            continue ;  // skip this anomaly
        }
        dwCNode = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

        if(BIsConstraintActive(pcnstr , dwCNode, pbHonorConstraints, pOptions, pConflictPair) )
        {
            pbEnabledOptions[dwI] = FALSE ;
            if(pConflictPair)
            {
                //  MemFree(pbEnabledOptions) ;
                pConflictPair->dwOptionIndex1 = dwI ;
                return(TRUE) ;  // Meaningless return value.
            }
        }
    }

    //  lastly must walk InvalidCombos for each option of dwFeatureIndex
    //  and mark   pbEnabledOptions accordingly.

    patrRoot = &(pfo[dwFeatureIndex].atrInvalidCombos) ;

    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        if(!pbEnabledOptions[dwI])
            continue ;

        dwNodeIndex = DwFindNodeInCurLevel(patt , patrRoot , dwI) ;

        if(dwNodeIndex == INVALID_INDEX)
            continue ;  // this option has no invalid combos
        if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP)
        {
            ERR(("Internal error.  BSelectivelyEnumEnabledOptions - Unexpected Sublevel found for atrInvalidCombos.\n"));
            continue ;  // skip this anomaly
        }
        dwICNode = patt[dwNodeIndex].dwOffset ;

        while(dwICNode != END_OF_LIST)
        //  search through each applicable invalid combo
        {
            dwNextInvCombo = END_OF_LIST ;  //  fail safe - stop
                // search in the event this invalid combo doesn't
                //  contain dwFeatureIndex/dwI
            bConstrained = TRUE ;  // Assume true initially
            bNextLinkFound = FALSE ;
            while(dwICNode != END_OF_LIST)
            //    for each element comprising the invalid combo
            {
                if(!bNextLinkFound  &&
                    pinvc[dwICNode].dwFeature == dwFeatureIndex  &&
                    (pinvc[dwICNode].dwOption == dwI ||
                    (WORD)pinvc[dwICNode].dwOption == (WORD)DEFAULT_INIT))
                {
                    dwNextInvCombo = pinvc[dwICNode].dwNewCombo ;
                    bNextLinkFound = TRUE ;
                    //  we are just asking if this option was selected
                    //  will it trigger an invalid combo?
                    //  this means currently this option is not selected
                    //  but we want to pretend for the purposes of
                    //  evaluating invalid combos that it is.
                    //  this is why an else if()  statement follows.
                }
                else if(bConstrained  &&  ((pbHonorConstraints  &&
                        !pbHonorConstraints[pinvc[dwICNode].dwFeature])
                        ||  !BIsFeaOptionCurSelected(pOptions,
                        pinvc[dwICNode].dwFeature,
                        pinvc[dwICNode].dwOption) ) )
                {
                    bConstrained = FALSE ;
                }
                else if(pConflictPair)
                {
                    //  need to remember one of the constrainers
                    //  so we can emit a warning message.
                    dwCFeature = pinvc[dwICNode].dwFeature ;
                    dwCOption = pinvc[dwICNode].dwOption ;
                }

                if(!bConstrained  &&  bNextLinkFound)
                    break ;  //  no need to keep traversing elements
                        //  in this invalid combo.
                dwICNode = pinvc[dwICNode].dwNextElement ;
            }
            if(bConstrained)
            {
                pbEnabledOptions[dwI] = FALSE ;

                if(pConflictPair)
                {
                    pConflictPair->dwOptionIndex1 = dwI ;
                    pConflictPair->dwFeatureIndex2 = dwCFeature ;
                    pConflictPair->dwOptionIndex2 = dwCOption ;

                    //  MemFree(pbEnabledOptions) ;
                    return(TRUE) ;  // Meaningless return value.
                }

                break ;     //  no need to see if any other invalid
                            //  combos apply.  One is enough.
            }
            dwICNode = dwNextInvCombo ;
        }
    }
    if(pConflictPair)
    {
        pConflictPair->dwFeatureIndex1 = 0xFFFFFFFF ;
        //  no constraints found.
        //  MemFree(pbEnabledOptions) ;
        return(TRUE) ;  // Meaningless return value.
    }
    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        if(pbEnabledOptions[dwI])
            break ;
    }
    if(dwI >= dwNumOpts)
        bStatus = FALSE ;  // Feature is disabled.
    return(bStatus) ;
}


BOOL
BEnumImposedConstraintsOnFeature
(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwTgtFeature,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2,
    OUT PBOOL           pbEnabledOptions,
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
    )
/*
    This function only searches for the unidirctional
    constraints found at dwFeature2, dwOption2 and
    records their effect on the options of feature1 by
    setting to FALSE the  BOOL element in pbEnabledOptions
    corresponding to the option disabled.
    (ANDing mask)
    Assumes:  pbEnabledOptions is properly initialized to all
    TRUE (or was that way at some point.)  This function never
    sets any elements TRUE.  Only sets some elements FALSE.
*/
{

    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubHeap ,  // start of string heap.
            pubRaw ;  //  raw binary data.
    DWORD           dwNodeIndex ,
                    dwCNode ;  //  index to a Constraint node
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
//    PINVALIDCOMBO   pinvc ;    //  root of invalid combo nodes
    PCONSTRAINTS    pcnstr ;   //  root of Constraint nodes
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA


    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    patt = (PATTRIB_TREE)(pubRaw +
            pearTableContents[MTI_ATTRIBTREE].loOffset) ;
//    pinvc = (PINVALIDCOMBO) (pubRaw +
//            pearTableContents[MTI_INVALIDCOMBO].loOffset) ;
    pcnstr = (PCONSTRAINTS) (pubRaw +
            pearTableContents[MTI_CONSTRAINTS].loOffset) ;
    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;



    patrRoot = &(pfo[dwFeature2].atrConstraints) ;

    dwNodeIndex = DwFindNodeInCurLevel(patt , patrRoot , dwOption2) ;

    if(dwNodeIndex == INVALID_INDEX)
        return(TRUE) ;  //  no imposed constraints found

    if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP)
    {
        ERR(("Internal error.  BEnumImposedConstraintsOnFeature - Unexpected Sublevel found for atrConstraints.\n"));
        return(FALSE) ;
    }

    dwCNode = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

    while(1)
    {
        if(pcnstr[dwCNode].dwFeature == dwTgtFeature  &&
            pbEnabledOptions[pcnstr[dwCNode].dwOption] == TRUE )
        {
            pbEnabledOptions[pcnstr[dwCNode].dwOption] = FALSE ;
            //  this option in dwTgtFeature is constrained.
            if(pConflictPair)
            {
                pConflictPair->dwOptionIndex1 = pcnstr[dwCNode].dwOption ;
                pConflictPair->dwFeatureIndex2 = dwFeature2 ;
                pConflictPair->dwOptionIndex2 = dwOption2 ;
                return(TRUE) ;  // Meaningless return value.
            }
        }

        dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
        if(dwCNode == END_OF_LIST)
            break ;
    }

    return(TRUE) ;  //  nothing bad happened.
}

DWORD    DwFindNodeInCurLevel(
PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
PATREEREF        patr ,  // index to a level in the attribute tree.
DWORD   dwOption   // search current level for this option
)

/*
this function returns the node index to the node containing
the specified dwOption in the selected level of the tree.
If the specified option branch does not exist,  the function returns
INVALID_INDEX.
Assumes caller has verified dwFeature matches.
*/
{
    DWORD           dwNodeIndex ;

    if(*patr == ATTRIB_UNINITIALIZED)
        return(INVALID_INDEX) ;

    if(*patr & ATTRIB_HEAP_VALUE)
    {
        ERR(("Internal error.  DwFindNodeInCurLevel - Unexpected branchless node found.\n"));
        return(INVALID_INDEX) ;
    }

    // search for matching option.

    dwNodeIndex = *patr  ;

    while(1)
    {
        if(patt[dwNodeIndex].dwOption == dwOption )
        {
            //  we found it!
            return(dwNodeIndex) ;
        }
        if(patt[dwNodeIndex].dwNext == END_OF_LIST)
            break ;
        dwNodeIndex = patt[dwNodeIndex].dwNext ;
    }
    return(INVALID_INDEX) ;
}


BOOL     BIsConstraintActive(
IN  PCONSTRAINTS    pcnstr ,   //  root of Constraint nodes
IN  DWORD   dwCNode,    //  first constraint node in list.
IN  PBOOL           pbHonorConstraints,  // if non NULL
IN  POPTSELECT       pOptions,
OUT PCONFLICTPAIR    pConflictPair   )
/*
    This function walks the list of constraint nodes
    starting at dwNodeIndex and checks to see if the
    Feature/Option specified within is in fact currently
    selected in pOptions.  If yes, immediately return true.
    If not, go to the next node in the list and repeat.
*/
{
    while(1)
    {
        if(!pbHonorConstraints  ||  pbHonorConstraints[pcnstr[dwCNode].dwFeature])
        {
            if(BIsFeaOptionCurSelected(pOptions,
                    pcnstr[dwCNode].dwFeature,
                    pcnstr[dwCNode].dwOption) )
            {
                if(pConflictPair)
                {
                    pConflictPair->dwFeatureIndex2 = pcnstr[dwCNode].dwFeature;
                    pConflictPair->dwOptionIndex2 = pcnstr[dwCNode].dwOption ;
                }
                return(TRUE) ;  // a constraint does exist.
            }
        }

        dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
        if(dwCNode == END_OF_LIST)
            break ;
    }
    return(FALSE);
}


#ifdef  GMACROS

//  note:  must precede calls  to ResolveUIConflict
//  with a call to ResolveDependentSettings

BOOL
ResolveDependentSettings(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    )
//  Note this function does  handle multiple selections
//  it will treat them as additional links in the chain.
{
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubRaw ;  //  raw binary data.
    PLISTNODE    plstRoot ;  // start of LIST array
    DWORD    dwListsRoot, dwListIndex;   //  Root of the chain
    DWORD   dwNumFeatures, dwI, dwJ, dwFea, dwNodeIndex,
        dwFeature, dwOption ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PDWORD   pdwPriority ;
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.
    INT     iOptionsNeeded;
    PBOOL   pbOneShotFlag, pbSelectedOptions ;
    BOOL    bMatchFound ;  //  a DependentSettings matches the current config.
    POPTSELECT   pDestOptions ;
    BOOL   bStatus = TRUE ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;



    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    pdwPriority = (PDWORD)(pubRaw +
            pearTableContents[MTI_PRIORITYARRAY].loOffset) ;

    plstRoot = (PLISTNODE)(pubRaw + pearTableContents[MTI_LISTNODES].
                            loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    if(dwNumFeatures > (DWORD)iMaxOptions)
    {
        iOptionsNeeded = dwNumFeatures ;
        return(FALSE);  // too many to save in option array.
    }

    pbOneShotFlag = (PBOOL)MemAlloc(dwNumFeatures * sizeof(BOOL) ) ;
    pbSelectedOptions = (PBOOL)MemAlloc(iMaxOptions * sizeof(BOOL) ) ;
    //  iMaxOptions must be greater than the max number of options availible for
    //  any feature.


    //  to extend to pickmany, have a dest optionarray.
    //  each time the source optionarray completely contains
    //  a  DependentSettings  list (in that each Fea.Option
    //  listed as a DependentSetting  is also selected in the
    //  source option array) we turn on those Fea.Options
    //  in the dest option array.  After all DependentSettings
    //  lists for that feature have been processed, we set
    //  the OneShotFlag for each Feature that has been affected
    //  in the dest option array.  For each such feature we will
    //  let the dest option array determine the setting of the
    //  source option array.
    //  this code does not verify that a Feature is pickmany
    //  before treating it as pickmany.  If the source option
    //  array has more than one option selected for a feature,
    //  that feature is automatically treated as a pickmany.


    pDestOptions = (POPTSELECT)MemAlloc(iMaxOptions * sizeof(OPTSELECT) ) ;
        //  'or' all acceptable DependentSettings here.

    if(!(pbOneShotFlag && pDestOptions  &&  pbSelectedOptions))
    {
        ERR(("Fatal: ResolveDependentSettings - unable to alloc requested memory: %d bytes.\n",
                    dwNumFeatures * sizeof(BOOL)));
        bStatus = FALSE ;
        goto    ABORTRESOLVEDEPENDENTSETTINGS ;
    }

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
        pbOneShotFlag[dwI] = FALSE ;
    //  this boolean array tracks if the feature has been
    // referenced in a DependentSettings entry.
    //  If a feature is referenced again in DependentSettings
    //  entry belonging to another feature, the subsequent
    //  references will be ignored.  This ensures only the
    //  highest priority Feature's request shall have precedence.


    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        DWORD   dwNextOpt, dwListsRootOpt1 ;
        //  The order of evaluation is determined
        //  by the priority array.


        dwFea = pdwPriority[dwI] ;
        pbOneShotFlag[dwFea] = TRUE ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.
        dwListsRootOpt1 = END_OF_LIST ;   // list for the 1st selected
        // option of a pickmany feature.

        for( dwJ = 0 ; dwJ < dwNumFeatures ; dwJ++)
        {
            pDestOptions[dwJ].ubCurOptIndex = OPTION_INDEX_ANY ;
            pDestOptions[dwJ].ubNext = 0 ;  // eol
            //  DestOptions is now blank.
        }

        bMatchFound = FALSE ;


        do
         {   //  for each option selected in a pick many feature
             //  treat associated DepSettings same as more than
             //  one DepSettings entry defined for one feature.

        {
            DWORD   dwUnresolvedFeature  ;
            PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

            patrRoot = &(pfo[dwFea].atrDependentSettings) ;


            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSDepSettingsIndex,
                (PBYTE)&dwListsRoot,
                &dwUnresolvedFeature,  *patrRoot, pOptions,
                dwFea,
                &dwNextOpt) != TRI_SUCCESS)
            {
                goto  END_OF_FOR_LOOP ;  //  no DependentSettings to apply.
            }
            if(dwListsRoot == END_OF_LIST)
                continue;  // maybe another option does have a list.

        }

        if(dwListsRootOpt1 == END_OF_LIST)  // first time thru do loop?
            dwListsRootOpt1 = dwListsRoot ;

        //  now we need to see if the current pOption matches any
        //  of the lists accessed using dwListsRoot.

        for(dwListIndex = dwListsRoot  ;
                dwListIndex != END_OF_LIST   ;
                dwListIndex = plstRoot[dwListIndex].dwNextItem  )
        {
            //  for each DepSettings list....
            //  now walk that DepSettings list at dwListIndex and compare
            //  to current settings at pOptions.   If there is a match, use
            //  depSettings list to OR on options in pDestOptions.
            //   Note:  Features with their one-shot flag set cannot be
            //  considered.  They will be ignored.
            BOOL     bActiveMatch = FALSE,  // requires an actual match
                bOptionArrayMatchesDepSettings = TRUE ;  // assume true
                //  until proven otherwise.
            for(dwNodeIndex = plstRoot[dwListIndex].dwData ; dwNodeIndex != END_OF_LIST ;
                       dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
            {
                pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                dwFeature = pqn->wFeatureID ;
                dwOption = pqn->wOptionID ;
                if(pbOneShotFlag[dwFeature] == TRUE)
                    continue;
                if(!BIsFeaOptionCurSelected(pOptions,  dwFeature, dwOption) )
                {
                    bOptionArrayMatchesDepSettings = FALSE ;
                    break;
                }
                else
                    bActiveMatch  = TRUE;
            }

            if(bOptionArrayMatchesDepSettings  &&  bActiveMatch)
                //   at least one DepSetting was honored.
           {
                //  'or' DepSettings into DestOptions
                for(dwNodeIndex = plstRoot[dwListIndex].dwData ; dwNodeIndex != END_OF_LIST ;
                           dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
                {
                    pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                    dwFeature = pqn->wFeatureID ;
                    dwOption = pqn->wOptionID ;
                    if(pbOneShotFlag[dwFeature] == TRUE)
                        continue;
                    //  select dwOption in DestOptions in addition to any other options
                    //  already selected.
                    EnumSelectedOptions(pnRawData, pDestOptions, dwFeature,
                                                         pbSelectedOptions) ;
                    if(!pbSelectedOptions[dwOption])   //  the option that should be selected isn't.
                    {                                                        //  so let's turn it on.
                        pbSelectedOptions[dwOption] = TRUE ;   //  This is the ORing process.
                        ReconstructOptionArray( pnRawData, pDestOptions, iMaxOptions,
                            dwFeature, pbSelectedOptions ) ;
                        bMatchFound = TRUE ;  // there really is something to set.
                    }
                }
           }
        }

         } while (dwNextOpt);

        if (dwListsRootOpt1 == END_OF_LIST)
            continue;   // you cannot set anything if there is no list to use.

        if (!bMatchFound)
        {
            //  set dest Option array  according to depSettings(dwListsRoot)
            for(dwNodeIndex = plstRoot[dwListsRootOpt1].dwData ; dwNodeIndex != END_OF_LIST ;
                       dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
            {
                pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                dwFeature = pqn->wFeatureID ;
                dwOption = pqn->wOptionID ;
                if(pbOneShotFlag[dwFeature] == TRUE)
                    continue;
                pDestOptions[dwFeature].ubCurOptIndex  = (BYTE)dwOption ;
            }
        }

        //  propagate Dest option array settings to pOptions
        //  note which features got set and set their one-shot
        //  flag.


        for( dwFeature = 0 ; dwFeature < dwNumFeatures ; dwFeature++)
        {
            if(pDestOptions[dwFeature].ubCurOptIndex == OPTION_INDEX_ANY)
                continue;
            EnumSelectedOptions( pnRawData,  pDestOptions,
                                                    dwFeature,  pbSelectedOptions) ;

            ReconstructOptionArray( pnRawData, pOptions, iMaxOptions,
                    dwFeature, pbSelectedOptions ) ;
            pbOneShotFlag[dwFeature] = TRUE ;
        }

END_OF_FOR_LOOP:
          ;   //  dummy statement after every label.
    }   // end for loop.  for each Feature in order of priority.

ABORTRESOLVEDEPENDENTSETTINGS:
    if(pbOneShotFlag)
        MemFree(pbOneShotFlag);
    if(pDestOptions)
        MemFree(pDestOptions);
    if(pbSelectedOptions)
        MemFree(pbSelectedOptions);
    return(bStatus);
}


void  EnumSelectedOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeature,
    IN PBOOL            pbSelectedOptions)
{
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PBYTE   pubRaw ;  //  raw binary data.
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    DWORD  dwNumOptions, dwI, dwOption, dwNextOpt ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;


    dwNumOptions = pfo[dwFeature].dwNumOptions ;

    for( dwI = 0 ; dwI < dwNumOptions ; dwI++)
        pbSelectedOptions[dwI] = FALSE ;


    if((dwOption = pOptions[dwFeature].ubCurOptIndex) == OPTION_INDEX_ANY)
        return;

    pbSelectedOptions[dwOption] = TRUE ;
    dwNextOpt = dwFeature ;  // case of pick many
    while(dwNextOpt = pOptions[dwNextOpt].ubNext)
    {
        pbSelectedOptions[pOptions[dwNextOpt].ubCurOptIndex] = TRUE ;
    }
    return;
}


BOOL
ExecuteMacro(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN    DWORD    dwFea,    //  what feature was selected in UI
    IN    DWORD    dwOpt ,   //  what option was selected in UI
    OUT PBOOL   pbFeaturesChanged  // tell Amanda what Features were changed.
    )
//  does this for one feature and one option  only!
{
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubRaw ;  //  raw binary data.
    PLISTNODE    plstRoot ;  // start of LIST array
    DWORD    dwListsRoot, dwListIndex;   //  Root of the chain
    DWORD   dwNumFeatures, dwI, dwJ,  dwNodeIndex,
        dwFeature, dwOption ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PDWORD   pdwPriority ;
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.
    INT     iOptionsNeeded;
    PBOOL   pbOneShotFlag, pbSelectedOptions ;
    BOOL    bHigherPri,   //  divides features into two groups those with higher priority
                                    // than dwFea, and those with lower priority.
                                    //  the Macro cannot change Features with higher priority.
            bMatchFound ;  //  a DependentSettings matches the current config.
    POPTSELECT   pDestOptions ;
    BOOL   bStatus = TRUE ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;



    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    pdwPriority = (PDWORD)(pubRaw +
            pearTableContents[MTI_PRIORITYARRAY].loOffset) ;

    plstRoot = (PLISTNODE)(pubRaw + pearTableContents[MTI_LISTNODES].
                            loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    if(dwNumFeatures > (DWORD)iMaxOptions)
    {
        iOptionsNeeded = dwNumFeatures ;
        return(FALSE);  // too many to save in option array.
    }

    pbOneShotFlag = (PBOOL)MemAlloc(dwNumFeatures * sizeof(BOOL) ) ;
    pbSelectedOptions = (PBOOL)MemAlloc(iMaxOptions * sizeof(BOOL) ) ;
    //  iMaxOptions must be greater than the max number of options availible for
    //  any feature.


    //  to extend to pickmany, have a dest optionarray.
    //  each time the source optionarray completely contains
    //  a  DependentSettings  list (in that each Fea.Option
    //  listed as a DependentSetting  is also selected in the
    //  source option array) we turn on those Fea.Options
    //  in the dest option array.  After all DependentSettings
    //  lists for that feature have been processed, we set
    //  the OneShotFlag for each Feature that has been affected
    //  in the dest option array.  For each such feature we will
    //  let the dest option array determine the setting of the
    //  source option array.
    //  this code does not verify that a Feature is pickmany
    //  before treating it as pickmany.  If the source option
    //  array has more than one option selected for a feature,
    //  that feature is automatically treated as a pickmany.


    pDestOptions = (POPTSELECT)MemAlloc(iMaxOptions * sizeof(OPTSELECT) ) ;
        //  'or' all acceptable DependentSettings here.

    if(!(pbOneShotFlag && pDestOptions  &&  pbSelectedOptions))
    {
        ERR(("Fatal: ResolveDependentSettings - unable to alloc requested memory: %d bytes.\n",
                    dwNumFeatures * sizeof(BOOL)));
        bStatus = FALSE ;
        goto    ABORTEXECUTEMACROS ;
    }


    for(bHigherPri = TRUE, dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        pbFeaturesChanged[dwI] = FALSE ;   //  start with no Features changed
        pbOneShotFlag[pdwPriority[dwI]] = bHigherPri ;
        if(pdwPriority[dwI] == dwFea)
             bHigherPri = FALSE ;   //  all remaining features are of lower priority
                                        //  and therefore susceptible to getting changed by the macro.
    }
    //  this boolean array tracks if the feature has been
    // referenced in a DependentSettings entry.
    //  If a feature is referenced again in DependentSettings
    //  entry belonging to another feature, the subsequent
    //  references will be ignored.  This ensures only the
    //  highest priority Feature's request shall have precedence.


    {
        DWORD   dwNextOpt ;
        //  The order of evaluation is determined
        //  by the priority array.


        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        for( dwJ = 0 ; dwJ < dwNumFeatures ; dwJ++)
        {
            pDestOptions[dwJ].ubCurOptIndex = OPTION_INDEX_ANY ;
            pDestOptions[dwJ].ubNext = 0 ;  // eol
            //  DestOptions is now blank.
        }

        bMatchFound = FALSE ;



        {
            DWORD   dwUnresolvedFeature, dwOldOpt  ;
            PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

            patrRoot = &(pfo[dwFea].atrUIChangeTriggersMacro) ;

            //   if dwFea is a pickmany, we must force selection of
            //   the Macro associated with just dwOpt.  We do this by
            //   changing the optionarray temporarily.

            dwOldOpt = pOptions[dwFea].ubCurOptIndex ;
            pOptions[dwFea].ubCurOptIndex = (BYTE)dwOpt ;

            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSUIChangeTriggersMacroIndex,
                (PBYTE)&dwListsRoot,
                &dwUnresolvedFeature,  *patrRoot, pOptions,
                dwFea,
                &dwNextOpt) != TRI_SUCCESS)
            {
                pOptions[dwFea].ubCurOptIndex = (BYTE)dwOldOpt ;   // restore
                goto  ABORTEXECUTEMACROS ;  //  no UIChangeTriggersMacro to apply.
            }
            pOptions[dwFea].ubCurOptIndex = (BYTE)dwOldOpt ;    // restore
            if(dwListsRoot == END_OF_LIST)
                goto  ABORTEXECUTEMACROS ;  //  no UIChangeTriggersMacro to apply.
        }


        //  now we need to see if the current pOption matches any
        //  of the lists accessed using dwListsRoot.

        for(dwListIndex = dwListsRoot  ;
                dwListIndex != END_OF_LIST   ;
                dwListIndex = plstRoot[dwListIndex].dwNextItem  )
        {
            //  for each DepSettings list....
            //  now walk that DepSettings list at dwListIndex and compare
            //  to current settings at pOptions.   If there is a match, use
            //  depSettings list to OR on options in pDestOptions.
            //   Note:  Features with their one-shot flag set cannot be
            //  considered.  They will be ignored.
            BOOL     bActiveMatch = FALSE,  // requires an actual match
                bOptionArrayMatchesDepSettings = TRUE ;  // assume true
                //  until proven otherwise.
            for(dwNodeIndex = plstRoot[dwListIndex].dwData ; dwNodeIndex != END_OF_LIST ;
                       dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
            {
                pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                dwFeature = pqn->wFeatureID ;
                dwOption = pqn->wOptionID ;
                if(pbOneShotFlag[dwFeature] == TRUE)
                    continue;
                if(!BIsFeaOptionCurSelected(pOptions,  dwFeature, dwOption) )
                {
                    bOptionArrayMatchesDepSettings = FALSE ;
                    break;
                }
                else
                    bActiveMatch  = TRUE;
            }

            if(bOptionArrayMatchesDepSettings  &&  bActiveMatch)
                //   at least one DepSetting was honored.
           {
                //  'or' DepSettings into DestOptions
                for(dwNodeIndex = plstRoot[dwListIndex].dwData ; dwNodeIndex != END_OF_LIST ;
                           dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
                {
                    pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                    dwFeature = pqn->wFeatureID ;
                    dwOption = pqn->wOptionID ;
                    if(pbOneShotFlag[dwFeature] == TRUE)
                        continue;
                    //  select dwOption in DestOptions in addition to any other options
                    //  already selected.
                    EnumSelectedOptions(pnRawData, pDestOptions, dwFeature,
                                                         pbSelectedOptions) ;
                    if(!pbSelectedOptions[dwOption])   //  the option that should be selected isn't.
                    {                                                        //  so let's turn it on.
                        pbSelectedOptions[dwOption] = TRUE ;   //  This is the ORing process.
                        ReconstructOptionArray( pnRawData, pDestOptions, iMaxOptions,
                            dwFeature, pbSelectedOptions ) ;
                        bMatchFound = TRUE ;  // there really is something to set.
                    }
                }
           }
        }


        if (!bMatchFound)
        {
            //  set dest Option array  according to depSettings(dwListsRoot)
            for(dwNodeIndex = plstRoot[dwListsRoot].dwData ; dwNodeIndex != END_OF_LIST ;
                       dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
            {
                pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                dwFeature = pqn->wFeatureID ;
                dwOption = pqn->wOptionID ;
                if(pbOneShotFlag[dwFeature] == TRUE)
                    continue;
                pDestOptions[dwFeature].ubCurOptIndex  = (BYTE)dwOption ;
            }
        }

        //  propagate Dest option array settings to pOptions
        //  note which features got set and set their one-shot
        //  flag.


        for( dwFeature = 0 ; dwFeature < dwNumFeatures ; dwFeature++)
        {
            if(pDestOptions[dwFeature].ubCurOptIndex == OPTION_INDEX_ANY)
                continue;
            EnumSelectedOptions( pnRawData,  pDestOptions,
                                                    dwFeature,  pbSelectedOptions) ;

            ReconstructOptionArray( pnRawData, pOptions, iMaxOptions,
                    dwFeature, pbSelectedOptions ) ;
            pbOneShotFlag[dwFeature] = TRUE ;
            pbFeaturesChanged[dwFeature] = TRUE ;   //  this Feature may have changed
        }

    }   // end non-existent for loop.

ABORTEXECUTEMACROS:
    if(pbOneShotFlag)
        MemFree(pbOneShotFlag);
    if(pDestOptions)
        MemFree(pDestOptions);
    if(pbSelectedOptions)
        MemFree(pbSelectedOptions);
    return(bStatus);
}
#endif

#endif PARSERDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\installb.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*
 *  installb.c - creates synthesized features and options and
 *          associated constraints and links to the installable
 *          feature or options.
 */


#include    "gpdparse.h"


// ----  functions defined in installb.c ---- //


DWORD    DwCountSynthFeatures(
IN     BOOL   (*fnBCreateFeature)(DWORD, DWORD, DWORD, PGLOBL ),   // callback
IN OUT PGLOBL pglobl
) ;

BOOL    BCreateSynthFeatures(
IN     DWORD   dwFea,  //  index of installable feature
IN     DWORD   dwOpt,  //  index of installable Option or set to INVALID_INDEX
IN     DWORD   dwSynFea,
IN OUT PGLOBL  pglobl) ;

BOOL    BEnableInvInstallableCombos(
PGLOBL pglobl) ;



// ---------------------------------------------------- //



DWORD    DwCountSynthFeatures(
IN     BOOL   (*fnBCreateFeature)(DWORD, DWORD, DWORD, PGLOBL ),   // callback
IN OUT PGLOBL pglobl
)
/*
    This function is called twice by PostProcess().

    the first pass sets fnBCreateFeature = NULL
    we just need to find out how many installable features and options
    exist.   Then we allocate this many synthesized features (outside of
    this function)
    In the second pass, we actually initialize the synthesized features
    and all the constraints applicable to that feature.  This is the
    job of fnBCreateFeature.
*/
{
    DWORD   dwOpt , dwHeapOffset, dwNodeIndex,
        dwFea, dwNumFea, dwNumOpt, dwNumSynFea ;
    PDFEATURE_OPTIONS   pfo ;
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF   patr ;

    if(fnBCreateFeature  &&
        !gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize)
        return(0) ;   //    May skip 2nd pass if  dwNumSynFea == 0

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;
    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
    dwNumFea = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;
    dwNumSynFea = 0 ;


    for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
    {
        if(!fnBCreateFeature)
        {   //  first pass clear all links to synthesiszed features.
            //  this will catch errors if gpd writer attempts to
            //  reference non-installable feature/options in
            //  InstalledConstraints and invalidInstallableCombinations.

            pfo[dwFea].dwInstallableFeatureIndex = //  backlink to Feature/Option
            pfo[dwFea].dwInstallableOptionIndex =  //  that prompted this feature.
            pfo[dwFea].dwFeatureSpawnsFeature = INVALID_INDEX;
                //  If this feature is installable, this points to the
                //  index of the resulting synthesized feature.
        }

        if(BReadDataInGlobalNode(&pfo[dwFea].atrFeaInstallable,
                &dwHeapOffset, pglobl)   &&
                *(PDWORD)(mpubOffRef + dwHeapOffset) == BT_TRUE)
        {
            if(fnBCreateFeature)
            {
                if(!fnBCreateFeature(dwFea, INVALID_INDEX, dwNumSynFea, pglobl) )
                //  featureIndex, optionIndex, index of SynFea
                {
                    ERR(("DwCountSynthFeatures: Unable to create synthesized feature for installable Feature index %d.\n",
                        dwFea));
                    pfo[dwFea].dwFeatureSpawnsFeature = INVALID_INDEX;
                }

            }

            dwNumSynFea++ ;
        }
        dwNumOpt = pfo[dwFea].dwNumOptions ;
        patr = &pfo[dwFea].atrOptInstallable ;
        if(*patr == ATTRIB_UNINITIALIZED)
            continue ;
        if(*patr & ATTRIB_HEAP_VALUE)
        {
            ERR(("Internal error:  DwCountSynthFeatures - atrOptInstallable should never be branchless.\n"));
            continue ;
        }

        for(dwOpt = 0 ; dwOpt < dwNumOpt  ; dwOpt++)
        {
            DWORD   dwNodeIndex  ;

            dwNodeIndex = *patr ;  // to avoid overwriting
                // the attribute tree.
            if(BfindMatchingOrDefaultNode(
                patt ,  // start of ATTRIBUTE tree array.
                &dwNodeIndex,  // Points to first node in chain
                dwOpt     //  may even take on the value DEFAULT_INIT
                ) )
            {
                if((patt[dwNodeIndex].eOffsetMeans == VALUE_AT_HEAP)  &&
                    *(PDWORD)(mpubOffRef + patt[dwNodeIndex].dwOffset) == BT_TRUE )
                {
                    if(fnBCreateFeature)
                    {
                        if(!fnBCreateFeature(dwFea, dwOpt, dwNumSynFea, pglobl) )
                        //  featureIndex, optionIndex, index of SynFea
                        {
                            ERR(("DwCountSynthFeatures: Unable to create synthesized feature for installable option: fea=%d, opt=%d.\n",
                                dwFea, dwOpt));
                            pfo[dwFea].atrOptionSpawnsFeature = ATTRIB_UNINITIALIZED ;
                            //  destroys the entire attribute tree for this feature,
                            //  but what choice do we have?  Something has gone terribly
                            //  wrong.
                        }
                    }
                    dwNumSynFea++ ;
                }
            }
        }
    }
    if(fnBCreateFeature)
        BEnableInvInstallableCombos(pglobl) ;

    return(dwNumSynFea) ;
}



BOOL    BCreateSynthFeatures(
IN     DWORD   dwFea,  //  index of installable feature
IN     DWORD   dwOpt,  //  index of installable Option or set to INVALID_INDEX
IN     DWORD   dwSynFea,  //  index of synthesized feature
IN OUT PGLOBL  pglobl)
{
    DWORD   dwOptI , dwHeapOffset, dwNodeIndex, dwValue,
        dwPrevsNode, dwNewCnstRoot, dwJ, dwCNode ,
        dwNumFea, dwNumOpt, dwOut, dwIn ;
    BOOL    bPrevsExists, bStatus = TRUE ;
    PDFEATURE_OPTIONS   pfo, pfoSyn ;
    PGLOBALATTRIB   pga ;
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF   patr ;
    PCONSTRAINTS     pcnstr ;  // start of CONSTRAINTS array.

    pcnstr = (PCONSTRAINTS) gMasterTable[MTI_CONSTRAINTS].pubStruct ;
    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;
    pga =  (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
    pfoSyn = (PDFEATURE_OPTIONS) gMasterTable[MTI_SYNTHESIZED_FEATURES].pubStruct ;

    dwNumFea = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;

    //  initialize all fields with UNINITIALIZED just like normal fea/opt;

    for(dwJ = 0  ;  dwJ < gMasterTable[MTI_SYNTHESIZED_FEATURES].dwElementSiz /
                    sizeof(ATREEREF)  ; dwJ++)
    {
        ((PATREEREF)( (PDFEATURE_OPTIONS)gMasterTable[MTI_SYNTHESIZED_FEATURES].
                pubStruct + dwSynFea))[dwJ] =
            ATTRIB_UNINITIALIZED ;  // the DFEATURE_OPTIONS struct is
            // comprised entirely of ATREEREFs.
    }

    //  create links between installable feature/option and
    //  the synthesized feature.

    if(dwOpt != INVALID_INDEX)
    {
        if(!BexchangeDataInFOATNode(
        dwFea,
        dwOpt,
        offsetof(DFEATURE_OPTIONS, atrOptionSpawnsFeature),
        &dwOut,     // previous contents of attribute node
        &dwSynFea, FALSE, pglobl))       // new contents of attribute node.
            return(FALSE);

        //  If this option is installable, this points to the
        //  index of the resulting synthesized feature.
    }
    else
        pfo[dwFea].dwFeatureSpawnsFeature = dwSynFea;
        //  If this feature is installable, this points to the
        //  index of the resulting synthesized feature.
        //  note because this is temporary information,
        //  the index is stored directly into the atr node without
        //  even a HEAP_OFFSET flag.



    //  backlink to Feature/Option that created this syn feature.
    //  note dwOpt always initializes properly even if invalid.
    pfoSyn[dwSynFea].dwInstallableFeatureIndex = dwFea ;
    pfoSyn[dwSynFea].dwInstallableOptionIndex = dwOpt ;

    //  now initialize all other fields needed to establish
    //  a legitimate feature with 2 options!


    // -------- Synthesize a Feature name. ------ //



    if(dwOpt == INVALID_INDEX)
    {   //  installable Feature
        pfoSyn[dwSynFea].atrFeaDisplayName =
            pfo[dwFea].atrInstallableFeaDisplayName ;
        pfoSyn[dwSynFea].atrFeaRcNameID =
            pfo[dwFea].atrInstallableFeaRcNameID ;
    }
    else    //  installable Option
    {
        if(!BexchangeDataInFOATNode(
            dwFea,
            dwOpt,
            offsetof(DFEATURE_OPTIONS, atrInstallableOptDisplayName ) ,
            &dwHeapOffset,     // previous contents of attribute node
            NULL, FALSE, pglobl))       // NULL means Don't overwrite.
            return(FALSE) ;
        if(dwHeapOffset != INVALID_INDEX)
        {
            pfoSyn[dwSynFea].atrFeaDisplayName =
                    dwHeapOffset | ATTRIB_HEAP_VALUE ;
        }
        if(!BexchangeDataInFOATNode(
            dwFea,
            dwOpt,
            offsetof(DFEATURE_OPTIONS, atrInstallableOptRcNameID ) ,
            &dwHeapOffset,     // previous contents of attribute node
            NULL, FALSE, pglobl))       // NULL means Don't overwrite.
            return(FALSE) ;
        if(dwHeapOffset != INVALID_INDEX)
        {
            pfoSyn[dwSynFea].atrFeaRcNameID =
                    dwHeapOffset | ATTRIB_HEAP_VALUE ;
        }
    }


{   //   !!! new stuff
    PBYTE  pubBaseKeyword = "SynthesizedFea_";
    BYTE    aubNum[4] ;
    DWORD  dwBaselen, dwDummy , dwI, dwNum = dwSynFea;
    ARRAYREF      arSymbolName ;

    //  compose featurekeyword string  incorporating  dwSynFea
    //  convert dwSynFea into 3 digit number.
    for(dwI = 0 ; dwI < 3 ; dwI++)
    {
        aubNum[2 - dwI] =  '0' + (BYTE)(dwNum % 10);
        dwNum /= 10 ;
    }
    aubNum[3] = '\0' ;   // null terminate

    dwBaselen = strlen(pubBaseKeyword);

    if(!BwriteToHeap(&arSymbolName.loOffset,
        pubBaseKeyword, dwBaselen, 1, pglobl))
        return(FALSE);

    if(!BwriteToHeap(&dwDummy,
        aubNum, 4, 1, pglobl))   //  append 3 digit number to base + null terminator
        return(FALSE);

    arSymbolName.dwCount = dwBaselen + 3 ;

    gmrbd.dwMaxPrnKeywordSize += arSymbolName.dwCount + 2 ;
        // add 2 bytes for every feature

    if(!BwriteToHeap(&(pfoSyn[dwSynFea].atrFeaKeyWord),
        (PBYTE)&arSymbolName, sizeof(ARRAYREF), 4, pglobl))
        return(FALSE);

    pfoSyn[dwSynFea].atrFeaKeyWord |= ATTRIB_HEAP_VALUE ;
}  //   !!! end new stuff

    #if 0
    pfoSyn[dwSynFea].atrFeaKeyWord =
        pfo[dwFea].atrFeaKeyWord ;  // just to fill something in.
    #endif


    //  grab offsets to "Installed" and  "Not Installed"
    //  option name templates:

    if(BReadDataInGlobalNode(&pga->atrNameInstalled, &dwHeapOffset, pglobl) )
    {
        if(!BexchangeDataInFOATNode(
            dwSynFea,
            1,
            offsetof(DFEATURE_OPTIONS, atrOptDisplayName) ,
            &dwOut,     // previous contents of attribute node
            &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.
            return(FALSE) ;
    }
    if(BReadDataInGlobalNode(&pga->atrNameNotInstalled, &dwHeapOffset, pglobl) )
    {
        if(!BexchangeDataInFOATNode(
            dwSynFea,
            0,
            offsetof(DFEATURE_OPTIONS, atrOptDisplayName) ,
            &dwOut,     // previous contents of attribute node
            &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.

            return(FALSE) ;
    }
    if(BReadDataInGlobalNode(&pga->atrNameIDInstalled, &dwHeapOffset, pglobl) )
    {
        if(!BexchangeDataInFOATNode(
            dwSynFea,
            1,
            offsetof(DFEATURE_OPTIONS, atrOptRcNameID) ,
            &dwOut,     // previous contents of attribute node
            &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.

            return(FALSE) ;
    }
    if(BReadDataInGlobalNode(&pga->atrNameIDNotInstalled, &dwHeapOffset, pglobl) )
    {
        if(!BexchangeDataInFOATNode(
            dwSynFea,
            0,
            offsetof(DFEATURE_OPTIONS, atrOptRcNameID) ,
            &dwOut,     // previous contents of attribute node
            &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.
            return(FALSE) ;
    }


    pfoSyn[dwSynFea].dwGID = GID_UNKNOWN ;
    pfoSyn[dwSynFea].dwNumOptions = 2 ;


    //  label this FeatureType as PrinterSticky
    dwValue = FT_PRINTERPROPERTY ;
    patr  = &pfoSyn[dwSynFea].atrFeatureType ;

    if(!BwriteToHeap(patr, (PBYTE)&dwValue ,
        sizeof(DWORD), 4, pglobl) )
    {
        bStatus = FALSE ;  // heap overflow start over.
    }
    *patr  |= ATTRIB_HEAP_VALUE ;


    //  leave optionID, atrFeaKeyWord, atrOptKeyWord uninitialized.


{   //   !!! new stuff     init atrOptKeyWord , hardcode to ON and OFF
    ARRAYREF      arSymbolName ;

    if(!BwriteToHeap(&arSymbolName.loOffset,
        "OFF", 4, 1, pglobl))
        return(FALSE);

    arSymbolName.dwCount = 3 ;

    if(!BwriteToHeap(&dwHeapOffset,
        (PBYTE)&arSymbolName, sizeof(ARRAYREF), 4, pglobl))
        return(FALSE);

    if(!BexchangeDataInFOATNode(
        dwSynFea,
        0,
        offsetof(DFEATURE_OPTIONS, atrOptKeyWord) ,
        &dwOut,     // previous contents of attribute node
        &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.

        return(FALSE) ;

// -----   init "ON"  -----


    if(!BwriteToHeap(&arSymbolName.loOffset,
        "ON", 3, 1, pglobl))
        return(FALSE);

    arSymbolName.dwCount = 2 ;

    if(!BwriteToHeap(&dwHeapOffset,
        (PBYTE)&arSymbolName, sizeof(ARRAYREF), 4, pglobl))
        return(FALSE);

    if(!BexchangeDataInFOATNode(
        dwSynFea,
        1,
        offsetof(DFEATURE_OPTIONS, atrOptKeyWord) ,
        &dwOut,     // previous contents of attribute node
        &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.
        return(FALSE) ;

    gmrbd.dwMaxPrnKeywordSize += 4 ;  //   sufficient to hold "OFF\0".
            //  note synthesized features are always pick_one.
}

    //  transfer atrOptInstallConstraints etc to atrConstraints.

    if(dwOpt != INVALID_INDEX)
    {
        if(!BexchangeDataInFOATNode(
        dwFea,
        dwOpt,
        offsetof(DFEATURE_OPTIONS, atrOptInstallConstraints ),
        &dwOut,     // previous contents of attribute node
        NULL,              // don't change contents of attribute node.
        FALSE , pglobl) )   // not synthetic feature
            return(FALSE);

        dwIn = dwOut ;
        if(dwIn != INVALID_INDEX)
            BexchangeDataInFOATNode(
                dwSynFea,
                1,  //  "Installed"
                offsetof(DFEATURE_OPTIONS, atrConstraints) ,
                &dwOut,     // previous contents of attribute node
                &dwIn,     // new contents of attribute node.
                TRUE , pglobl) ;

        if(!BexchangeDataInFOATNode(
        dwFea,
        dwOpt,
        offsetof(DFEATURE_OPTIONS, atrOptNotInstallConstraints ),
        &dwOut,     // previous contents of attribute node
        NULL,              // don't change contents of attribute node.
        FALSE , pglobl) )   // not synthetic feature
            return(FALSE);

        dwIn = dwOut ;

        if(dwIn != INVALID_INDEX)
            BexchangeDataInFOATNode(
                dwSynFea,
                0,  //  "Not Installed"
                offsetof(DFEATURE_OPTIONS, atrConstraints) ,
                &dwOut,     // previous contents of attribute node
                &dwIn,       // new contents of attribute node.
                TRUE , pglobl) ;
    }
    else
    {
        if(BReadDataInGlobalNode(&pfo[dwFea].atrFeaInstallConstraints, &dwHeapOffset, pglobl) )
            BexchangeDataInFOATNode(
                dwSynFea,
                1,  //  "Installed"
                offsetof(DFEATURE_OPTIONS, atrConstraints) ,
                &dwOut,     // previous contents of attribute node
                &dwHeapOffset,       // new contents of attribute node.
                TRUE , pglobl) ;

        if(BReadDataInGlobalNode(&pfo[dwFea].atrFeaNotInstallConstraints , &dwHeapOffset, pglobl) )
            BexchangeDataInFOATNode(
                dwSynFea,
                0,  //  "Not Installed"
                offsetof(DFEATURE_OPTIONS, atrConstraints) ,
                &dwOut,     // previous contents of attribute node
                &dwHeapOffset,       // new contents of attribute node.
                TRUE , pglobl) ;
    }


    //  now synthesize:  selecting option 0 constrains all
    //  options of an Installable feature except option 0.
    //  Selecting option 0 constrains an installable option.

    if(bStatus)
        bStatus = BallocElementFromMasterTable(MTI_CONSTRAINTS, &dwNewCnstRoot, pglobl) ;

    if(!bStatus)
        return(FALSE);

    dwCNode = dwNewCnstRoot ;

    if(dwOpt != INVALID_INDEX)
    {                           //  installable option
        pcnstr[dwCNode].dwFeature = dwFea ;
        pcnstr[dwCNode].dwOption = dwOpt ;
    }
    else    //  installable feature
    {
        dwNumOpt = pfo[dwFea].dwNumOptions ;

        for(dwOptI = 1 ; bStatus  &&  dwOptI < dwNumOpt ; dwOptI++)
        {
            pcnstr[dwCNode].dwFeature = dwFea ;
            pcnstr[dwCNode].dwOption = dwOptI ;
            if(dwOptI + 1 < dwNumOpt)
            {
                bStatus = BallocElementFromMasterTable(MTI_CONSTRAINTS,
                        &pcnstr[dwCNode].dwNextCnstrnt, pglobl) ;
                dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
            }
        }
    }

    //  get existing list and prepend new list to it.


    bStatus = BexchangeArbDataInFOATNode(
            dwSynFea,
            0,  //  "Not Installed"
            offsetof(DFEATURE_OPTIONS, atrConstraints) ,
            sizeof(DWORD) ,    //  number bytes to copy.
            (PBYTE)&dwPrevsNode,     //  pubOut
            (PBYTE)&dwNewCnstRoot,   //  pubIn
            &bPrevsExists,  // previous contents existed?
            TRUE,     // access the synthetic features.
            pglobl
    ) ;
    if(bPrevsExists)
    {        //  tack existing list onto new list.
        pcnstr[dwCNode].dwNextCnstrnt = dwPrevsNode ;
    }
    else
    {
        pcnstr[dwCNode].dwNextCnstrnt = END_OF_LIST ;
    }

    return(bStatus) ;
}


BOOL    BEnableInvInstallableCombos(
PGLOBL pglobl)
{
    DWORD   dwPrevsNode, dwRootNode, dwNewCombo , dwCurNode,
        dwFeaInstallable, dwOpt, dwSynFea, dwFeaOffset  ;
    PDFEATURE_OPTIONS   pfo;
    PGLOBALATTRIB   pga ;
    PINVALIDCOMBO   pinvc ;  //  start of InvalidCombo array


    pga =  (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
    pinvc = (PINVALIDCOMBO) gMasterTable[MTI_INVALIDCOMBO].pubStruct ;
    dwFeaOffset = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;




    dwRootNode = pga->atrInvldInstallCombo ;
    if(dwRootNode == ATTRIB_UNINITIALIZED)
        return(TRUE) ;  //  no InvalidInstallableCombos found.

    while(dwRootNode != END_OF_LIST)
    {
        dwNewCombo = pinvc[dwRootNode].dwNewCombo ;
        dwCurNode = dwRootNode ;
        while(dwCurNode != END_OF_LIST)
        {
            dwFeaInstallable = pinvc[dwCurNode].dwFeature ;

            dwOpt = pinvc[dwCurNode].dwOption ;

            if(dwOpt != (WORD)DEFAULT_INIT)
            {       //  this option is installable
                if(!BexchangeDataInFOATNode(
                dwFeaInstallable,
                dwOpt,
                offsetof(DFEATURE_OPTIONS, atrOptionSpawnsFeature),
                &dwSynFea,     // previous contents of attribute node
                NULL, FALSE, pglobl))       // new contents of attribute node.
                    return(FALSE);

            }
            else
                dwSynFea = pfo[dwFeaInstallable].dwFeatureSpawnsFeature ;


            pinvc[dwCurNode].dwFeature = dwSynFea + dwFeaOffset ;
                //  dwSynFea is the index of the resulting
                //  synthesized feature.
            pinvc[dwCurNode].dwOption = 1 ; //  can't tolerate
                //  all these things installed at the same time.

            if(!BexchangeDataInFOATNode(dwSynFea , 1,
                offsetof(DFEATURE_OPTIONS, atrInvalidCombos),
                &dwPrevsNode, &dwRootNode, TRUE, pglobl))
            return(FALSE);

            if(dwPrevsNode == INVALID_INDEX)
                pinvc[dwCurNode].dwNewCombo = END_OF_LIST ;
            else
                pinvc[dwCurNode].dwNewCombo = dwPrevsNode ;

            dwCurNode = pinvc[dwCurNode].dwNextElement ;  //    last line
        }
        dwRootNode = dwNewCombo ;  //    last line
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\initdll.c ===
/*++

 Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    intidll.c

Abstract:

    This file handles the DLLInitialize spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    07/17/96 -amandan-
        Created it.

--*/


#include "gpdparse.h"

//
// Global instance handle and critical section
//


BOOL
DllMain(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    This function is called when the system loads/unloads the DriverUI module.
    At DLL_PROCESS_ATTACH, InitializeCriticalSection is called to initialize
    the critical section objects.
    At DLL_PROCESS_DETACH, DeleteCriticalSection is called to release the
    critical section objects.

Arguments:

    hModule     handle to DLL module
    ulReason    reason for the call
    pContext    pointer to context (not used by us)


Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\memtrack.h ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  memtrack.h - debug memory allocation functions   */

#if 0

#ifndef KERNEL_MODE

#undef  MemAllocZ
#undef  MemAlloc
#undef  MemFree

PVOID   MemAllocZ(DWORD) ;
PVOID   MemAlloc(DWORD) ;
VOID    MemFree(PVOID) ;

#define  MEMTRACK   1

#endif

#endif


//  insert into one source function:
/*  comment out here to prevent re-definition

#ifdef  MEMTRACK

PVOID   MemAllocZ(DWORD dwSize)
{
    PVOID   pv ;

    pv = (PVOID) LocalAlloc(LPTR, dwSize) ;
    ERR(("allocated %d zeroed bytes at address %X\n", dwSize, pv)) ;
    return(pv);
}

PVOID   MemAlloc(DWORD dwSize) ;
{
    PVOID   pv ;

    pv = (PVOID) LocalAlloc(LMEM_FIXED, dwSize) ;
    ERR(("allocated %d bytes at address %X\n", dwSize, pv)) ;
    return(pv);
}

VOID    MemFree(PVOID   pv) ;
{
    ERR(("Freeing memory at address %X\n", pv)) ;
    if(pv)
        LocalFree((HLOCAL) pv) ;
    return ;
}

#endif

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\macros1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  macros1.c - functions that implement macros  */


#include    "gpdparse.h"



// ----  functions defined in  macros1.c ---- //

BOOL  BevaluateMacros(
PGLOBL  pglobl) ;

BOOL    BDefineValueMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

BOOL    BResolveValueMacroReference(
PTKMAP  ptkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BdelimitName(
PABSARRAYREF    paarValue,   //  the remainder of the string without the Name
PABSARRAYREF    paarToken,   //  contains the Name
PBYTE  pubChar ) ;


BOOL    BCatToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl) ;

BOOL    BResolveBlockMacroReference(
PTKMAP  ptkmap,
DWORD   dwMacRefIndex,
PGLOBL  pglobl) ;

BOOL    BDefineBlockMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

BOOL    BIncreaseMacroLevel(
BOOL    bMacroInProgress,
PGLOBL  pglobl) ;

BOOL    BDecreaseMacroLevel(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

VOID    VEnumBlockMacro(
PTKMAP  pNewtkmap,
PBLOCKMACRODICTENTRY    pBlockMacroDictEntry,
PGLOBL  pglobl ) ;


// ---------------------------------------------------- //




BOOL  BevaluateMacros(
PGLOBL pglobl)
//  and expand shortcuts
//    this function scans through the tokenMap
//    making a copy of the tokenMap without
//    the macrodefinitions or references.  All references
//    are replaced by the definitions inserted in-line!
//    This function assumes the temp heap is availible for
//    storage of expanded macros.
{
    PTKMAP   ptkmap, pNewtkmap ;   // start of tokenmap
    DWORD   dwNewTKMindex, dwEntry, dwKeywordID ;
    CONSTRUCT   eConstruct ;
    KEYWORD_TYPE    eType ;
    BOOL    bStatus = TRUE ,
        bValueMacroState = FALSE ;   // set to TRUE when
        //  we parse into a *Macros  construct.


    gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex =
    gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex =
    gMasterTable[MTI_MACROLEVELSTACK].dwCurIndex = 0 ;
    //  to push new values onto stack:  write then increment stackptr
    //  to pop values off the stack:  decrement stackptr then read from stack


    pNewtkmap = (PTKMAP)gMasterTable[MTI_NEWTOKENMAP].pubStruct ;
    ptkmap = (PTKMAP)gMasterTable[MTI_TOKENMAP].pubStruct  ;


    for(dwEntry = 0 ; geErrorSev < ERRSEV_RESTART ; dwEntry++)
    {
        //  These ID's must be processed separately
        //  because they do not index into the mainKeyword table.
        //  The code for generic ID's will fail.

        dwKeywordID = ptkmap[dwEntry].dwKeywordID ;


        if (dwKeywordID == gdwID_IgnoreBlock)
        {
            VIgnoreBlock(ptkmap + dwEntry, TRUE, pglobl) ;
            continue ;
        }

        switch(dwKeywordID)
        {
            case (ID_EOF):
            {
                {
                    DWORD   dwEntry, dwTKMindex, dwTKIndexOpen, dwTKIndexClose ;
                    PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;
                    PVALUEMACRODICTENTRY    pValueMacroDictEntry ;


                    //  remove all traces of expired block and value macro definitions

                    pBlockMacroDictEntry =
                        (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;
                    pValueMacroDictEntry =
                        (PVALUEMACRODICTENTRY)gMasterTable[MTI_VALUEMACROARRAY].pubStruct ;

                    for(dwEntry = 0 ;
                        dwEntry < gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex ;
                        dwEntry++)
                    {
                        dwTKMindex = pValueMacroDictEntry[dwEntry].dwTKIndexValue ;
                        pNewtkmap[dwTKMindex].dwKeywordID = ID_NULLENTRY ;
                    }

                    for(dwEntry = 0 ;
                        dwEntry < gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex ;
                        dwEntry++)
                    {
                        dwTKIndexOpen = pBlockMacroDictEntry[dwEntry].dwTKIndexOpen ;
                        dwTKIndexClose = pBlockMacroDictEntry[dwEntry].dwTKIndexClose ;
                        for(dwTKMindex = dwTKIndexOpen ; dwTKMindex <= dwTKIndexClose ;
                            dwTKMindex++)
                            pNewtkmap[dwTKMindex].dwKeywordID = ID_NULLENTRY ;
                    }
                }

                if(gMasterTable[MTI_MACROLEVELSTACK].dwCurIndex)
                {
                    ERR(("Too few closing braces.  Fatal syntax error.\n"));
                    geErrorSev = ERRSEV_FATAL ;
                    geErrorType = ERRTY_SYNTAX  ;
                    return(FALSE);
                }

                //  transfer all tokenmap fields to newTokenMap
                if(!BallocElementFromMasterTable(
                        MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                {
                    geErrorSev = ERRSEV_RESTART ;
                    geErrorType = ERRTY_MEMORY_ALLOCATION ;
                    gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                    return(FALSE);
                }
                pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;

                bStatus = (mdwCurStsPtr) ? (FALSE) : (TRUE);
                if(geErrorSev >= ERRSEV_RESTART)
                    bStatus = FALSE ;
                return(bStatus) ;
            }
            case (ID_NULLENTRY):
            {
                continue ;  //  skip to next entry.
            }
            default :
                break ;
        }


        if(bValueMacroState)
        {
            if(dwKeywordID == ID_UNRECOGNIZED)
            {
                vIdentifySource(ptkmap + dwEntry, pglobl) ;
                ERR(("Only valueMacroDefinitions permitted within *Macros  constructs.\n"));
            }
            else if(dwKeywordID == ID_SYMBOL)
            {
                //  transfer all tokenmap fields to newTokenMap
                if(!BallocElementFromMasterTable(
                        MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                {
                    geErrorSev = ERRSEV_RESTART ;
                    geErrorType = ERRTY_MEMORY_ALLOCATION ;
                    gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                    continue ;
                }
                pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;
                if(!BDefineValueMacroName(pNewtkmap, dwNewTKMindex, pglobl) )
                {
                    pNewtkmap[dwNewTKMindex].dwKeywordID = ID_NULLENTRY ;
                    vIdentifySource(ptkmap + dwEntry, pglobl) ;
                    ERR(("Internal Error: valueMacro name registration failed.\n"));
                }
                else if(ptkmap[dwEntry].dwFlags & TKMF_MACROREF)
                {
                    if(!BResolveValueMacroReference(pNewtkmap , dwNewTKMindex, pglobl))
                    {
                        pNewtkmap[dwNewTKMindex].dwKeywordID = ID_NULLENTRY ;
                        gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex-- ;
                        //  remove macrodef from dictionary.
                    }
                }
            }
            else //  keywords that should be defined in the MainKeywordTable
            {
                eType = mMainKeywordTable[dwKeywordID].eType ;
                eConstruct = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

                if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_CLOSEBRACE)
                {
                    bValueMacroState = FALSE ;  //  just don't copy it.
                }
                else
                {
                    vIdentifySource(ptkmap + dwEntry, pglobl) ;
                    ERR(("Only valueMacroDefinitions permitted within *Macros  constructs.\n"));
                }
            }
            continue ;   //  end of processing for this statement
        }

        //  the remainder of the block handles the case
        //   bValueMacroState = FALSE ;

        if(dwKeywordID == ID_UNRECOGNIZED  ||  dwKeywordID == ID_SYMBOL)
        {
            //  Note:  currently SYMBOLs only occur within ValueMacro
            //  constructs so they could be flagged as an error here.  But
            //  let it slide here since one day the parser may allow them
            //  to be used elsewhere.

            //  do nothing in this block, just use it to skip to code at the
            //  bottom after all the else if statements.
            ; // empty statement.
        }
        else  // only valid KeywordIDs enter this block.
        {
            eType = mMainKeywordTable[dwKeywordID].eType ;
            eConstruct = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

            if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_BLOCKMACRO)
            {
                if(!BDefineBlockMacroName(ptkmap, dwEntry, pglobl))
                {
                    vIdentifySource(ptkmap + dwEntry, pglobl) ;
                    ERR(("Internal Error: blockMacro name registration failed.\n"));
                    continue ;
                }

                //  skip NULL_ENTRIES
                for( dwEntry++ ; ptkmap[dwEntry].dwKeywordID == ID_NULLENTRY ; dwEntry++)
                    ;

                dwKeywordID = ptkmap[dwEntry].dwKeywordID ;

                if(dwKeywordID  <  ID_SPECIAL)
                {
                    eType = mMainKeywordTable[dwKeywordID].eType ;
                    eConstruct = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

                    if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_OPENBRACE)
                    {
                        PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;

                        if(!BallocElementFromMasterTable(
                                MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                        {
                            geErrorSev = ERRSEV_RESTART ;
                            geErrorType = ERRTY_MEMORY_ALLOCATION ;
                            gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                            continue ;
                        }
                        pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;

                        pBlockMacroDictEntry =
                            (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;

                        pBlockMacroDictEntry[gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex - 1].dwTKIndexOpen =
                            dwNewTKMindex ;

                        BIncreaseMacroLevel(TRUE, pglobl) ;
                        continue ;   //  end of processing for this statement
                    }
                }
                vIdentifySource(ptkmap + dwEntry, pglobl) ;
                ERR(("expected openbrace to follow *BlockMacros keyword.\n"));
                geErrorType = ERRTY_SYNTAX ;
                geErrorSev = ERRSEV_FATAL ;
                continue ;   //  end of processing for this statement
            }
            else if(eType == TY_SPECIAL   &&  eConstruct == SPEC_INSERTBLOCK)
            {
                if(ptkmap[dwEntry].dwFlags & TKMF_MACROREF)
                {
                    if(!BResolveBlockMacroReference(ptkmap, dwEntry, pglobl))
                    {
                        vIdentifySource(ptkmap + dwEntry, pglobl) ;
                        ERR(("   *InsertBlockMacro Construct ignored.\n"));
                        VIgnoreBlock(ptkmap + dwEntry, TRUE, pglobl) ;
                    }
                }
                else
                {
                    vIdentifySource(ptkmap + dwEntry, pglobl) ;
                    ERR(("expected a =MacroName as the value of *InsertBlockMacro keyword.\n"));
                    ERR(("   *InsertBlockMacro Construct ignored.\n"));
                    VIgnoreBlock(ptkmap + dwEntry, TRUE, pglobl) ;
                }
                continue ;   //  end of processing for this statement
            }
            else if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_MACROS)
            {   //  *Macros  definition
                dwEntry++;   // don't copy *Macros statement
                while(ptkmap[dwEntry].dwKeywordID == ID_NULLENTRY)
                     dwEntry++;     //  skip NULL_ENTRIES

                dwKeywordID = ptkmap[dwEntry].dwKeywordID  ;

                if(dwKeywordID  <  ID_SPECIAL)
                {
                    eType = mMainKeywordTable[dwKeywordID].eType ;
                    eConstruct = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

                    if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_OPENBRACE)
                    {
                        // don't copy openbrace
                        bValueMacroState = TRUE ;
                        continue ;   //  end of processing for this statement
                    }
                }
                vIdentifySource(ptkmap + dwEntry, pglobl) ;
                ERR(("expected openbrace to follow *Macros keyword.\n"));
                geErrorType = ERRTY_SYNTAX ;
                geErrorSev = ERRSEV_FATAL ;
                continue ;   //  end of processing for this statement
            }
            else if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_OPENBRACE)
            {
                if(!BallocElementFromMasterTable(
                        MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                {
                    geErrorSev = ERRSEV_RESTART ;
                    geErrorType = ERRTY_MEMORY_ALLOCATION ;
                    gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                }
                pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;
                BIncreaseMacroLevel(FALSE, pglobl) ;
                continue ;   //  end of processing for this statement
            }
            else if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_CLOSEBRACE)
            {
                if(!BallocElementFromMasterTable(
                        MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                {
                    geErrorSev = ERRSEV_RESTART ;
                    geErrorType = ERRTY_MEMORY_ALLOCATION ;
                    gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                }
                pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;
                BDecreaseMacroLevel(pNewtkmap, dwNewTKMindex, pglobl) ;
                continue ;   //  end of processing for this statement
            }
        }
        //  execution path for ID_UNRECOGNIZED  and ID_SYMBOL
        //  rejoins here.   This code is executed only if
        //  keyword was not processed in the special cases above.

        //  transfer all tokenmap fields to newTokenMap
        if(!BallocElementFromMasterTable(
                MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_NEWTOKENMAP ;
            continue ;
        }
        pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;

        if(ptkmap[dwEntry].dwFlags & TKMF_MACROREF)
        {
            if(!BResolveValueMacroReference(pNewtkmap , dwNewTKMindex, pglobl))
            {
                pNewtkmap[dwNewTKMindex].dwKeywordID = ID_NULLENTRY ;
            }
            if(gdwVerbosity >= 4)
            {
                ERR(("\nEnumerate ValueMacro Reference at:\n")) ;
                vIdentifySource(pNewtkmap + dwNewTKMindex, pglobl) ;

                ERR(("    %0.*s : %0.*s\n",
                    pNewtkmap[dwNewTKMindex].aarKeyword.dw,
                    pNewtkmap[dwNewTKMindex].aarKeyword.pub,
                    pNewtkmap[dwNewTKMindex].aarValue.dw,
                    pNewtkmap[dwNewTKMindex].aarValue.pub
                    ));
            }


        }
    }  //  end of for each tkmap entry loop

    if(geErrorSev >= ERRSEV_RESTART)
        bStatus = FALSE ;
    return(bStatus) ;
}




BOOL    BDefineValueMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl)
{
    DWORD   dwValueMacroEntry, dwSymbolID ;
    PVALUEMACRODICTENTRY    pValueMacroDictEntry ;

    if(!BeatSurroundingWhiteSpaces(&pNewtkmap[dwNewTKMindex].aarKeyword) )
    {
        vIdentifySource(pNewtkmap + dwNewTKMindex, pglobl) ;
        ERR(("syntax error in ValueMacro name.\n"));
        return(FALSE);
    }

    dwSymbolID = DWregisterSymbol(&pNewtkmap[dwNewTKMindex].aarKeyword,
                               CONSTRUCT_MACROS, TRUE, INVALID_SYMBOLID, pglobl ) ;
    if(dwSymbolID == INVALID_SYMBOLID)
        return(FALSE);

    if(!BallocElementFromMasterTable(
            MTI_VALUEMACROARRAY, &dwValueMacroEntry, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_VALUEMACROARRAY ;
        return(FALSE);
    }

    pValueMacroDictEntry = (PVALUEMACRODICTENTRY)gMasterTable[MTI_VALUEMACROARRAY].pubStruct ;

    pValueMacroDictEntry[dwValueMacroEntry].dwSymbolID = dwSymbolID ;
    pValueMacroDictEntry[dwValueMacroEntry].dwTKIndexValue = dwNewTKMindex ;

    return(TRUE);
}






BOOL    BResolveValueMacroReference(
 PTKMAP  ptkmap,
 DWORD   dwTKMindex,
 PGLOBL  pglobl)
{
    BYTE  ubChar ;
    PVALUEMACRODICTENTRY    pValueMacroDictEntry ;
    ABSARRAYREF    aarNewValue, aarValue, aarToken  ;
    PBYTE   pubDelimiters  = "=\"%" ;      //  array of valid delimiters
    DWORD   dwEntry, dwDelim ;  // index to pubDelimiters

    // ------ original strict interpretation ------
    //  because the value contains a =MacroRef, we assume
    //  the value is comprised purely of =MacroRef, "substrings" and
    //  %{params}  mixed up in any order.  A new value string
    //  without the =MacroRefs will replace the original.
    // ------ lenient interpretation --------
    //  if the GPD writer only uses the reserved characters
    //  = to indicate a MacroRef and as part of a string literal
    //      or comment,
    //  " to delimit a string literal, or as part of a string literal
    //      or comment,
    //  % to begin a parameter construct , or as part of a string literal
    //      or comment, or as the escape character within a string literal
    //
    //  then the parser can allow 1 or more valuemacro references to be
    //  embedded in any arbitrary value string subject to
    //  these conditions:
    //  a)  "string literals" and %{param constructs}  may not
    //      contain =MacroRefs
    //  b)  the value associated with each *Macro:  must be
    //      a syntatically valid value object.
    //      ie   an INT, PAIR(,) , ENUM_CONSTANT, SUBSTRING, PARAM etc.
    //  c)  when all macro references are expanded, the resulting value
    //      must itself satisfy b)  for every keyword and macrodefinition
    //      which contains one or more =Macroref.



    aarNewValue.dw = 0 ;  // initialize so BCatToTmpHeap
                            //  will overwrite instead of append

    pValueMacroDictEntry = (PVALUEMACRODICTENTRY)gMasterTable[MTI_VALUEMACROARRAY].pubStruct ;

    aarValue = ptkmap[dwTKMindex].aarValue ;

    if(!BeatLeadingWhiteSpaces( &aarValue) )
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Internal error: =MacroRef expected, but No value found.\n"));
        return(FALSE) ;
    }


    ubChar = *aarValue.pub ;  // first char in value string
    aarValue.dw-- ;
    aarValue.pub++ ;    //  clip off the first char to simulate
                        //  effect of BdelimitToken()

    while(1)
    {

        switch(ubChar)
        {
            case  '=':  // macroname indicator
            {
                DWORD   dwRefSymbolID,  //  ID of MacroReference.
                        dwNewTKMindex,  //  tokenmap index containing valueMacro.
                        dwMaxIndex ;    // one past last valMacro dictionary entry


                if(!BdelimitName(&aarValue, &aarToken, &ubChar ) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("No MacroName detected after '='.\n"));
                    return(FALSE) ;
                }
                if(aarValue.dw)
                {
                    aarValue.dw-- ;
                    aarValue.pub++ ;    //  clip off the first char to simulate
                }

                if(!BparseSymbol(&aarToken,
                    &dwRefSymbolID,
                    VALUE_SYMBOL_VALUEMACRO, pglobl) )
                {
                    return(FALSE) ;
                }

                //  search ValueMacro Dict starting from most recent entry

                dwMaxIndex = gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex ;

                for(dwEntry = 0 ; dwEntry < dwMaxIndex ; dwEntry++)
                {
                    if(pValueMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwSymbolID
                            == dwRefSymbolID)
                        break ;
                }
                if(dwEntry >= dwMaxIndex)
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("=MacroRef not resolved. Not defined or out of scope.\n"));
                    return(FALSE) ;
                }
                dwNewTKMindex =
                    pValueMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwTKIndexValue ;


                if(dwNewTKMindex >= dwTKMindex )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("ValueMacro cannot reference itself.\n"));
                    return(FALSE) ;
                }

                //  concat valuestring onto tmpHeap.
                if(!BCatToTmpHeap(&aarNewValue, &ptkmap[dwNewTKMindex].aarValue, pglobl) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Concatenation to produce expanded macro value failed.\n"));
                    return(FALSE) ;
                }
                break ;
            }
            case  '%':  // command parameter
            {
                if(!BdelimitToken(&aarValue, "}", &aarToken, &dwDelim) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("missing terminating '}'  in command parameter.\n"));
                    return(FALSE) ;
                }

                //  when concatenating you must restore the delimiters
                //  % and } that were stripped by DelimitToken.

                aarToken.dw += 2 ;
                aarToken.pub--  ;

                if(!BCatToTmpHeap(&aarNewValue, &aarToken, pglobl) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Concatenation to produce expanded macro value failed.\n"));
                    return(FALSE) ;
                }

                if(aarValue.dw)
                {
                    ubChar = *aarValue.pub;
                    aarValue.dw-- ;
                    aarValue.pub++ ;    //  clip off the first char to simulate
                }
                else
                    ubChar = '\0' ;    // no more objects

                break ;
            }
            case  '"' :   // this is a string construct
            {
                if(!BdelimitToken(&aarValue, "\"", &aarToken, &dwDelim) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("missing terminating '\"'  in substring.\n"));
                    return(FALSE) ;
                }

                //  when concatenating you must restore the delimiters
                //  " and " that were stripped by DelimitToken.

                aarToken.dw += 2 ;
                aarToken.pub--  ;

                if(!BCatToTmpHeap(&aarNewValue, &aarToken, pglobl) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Concatenation to produce expanded macro value failed.\n"));
                    return(FALSE) ;
                }

                if(aarValue.dw)
                {
                    ubChar = *aarValue.pub;
                    aarValue.dw-- ;
                    aarValue.pub++ ;    //  clip off the first char to simulate
                }
                else
                    ubChar = '\0' ;    // no more objects

                break ;
            }
            case  '\0': //  end of value string
            {
                (VOID) BeatLeadingWhiteSpaces(&aarValue) ;
                if(aarValue.dw)   //  is stuff remaining?
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Error parsing value containing =MacroRef: %0.*s.\n",
                        ptkmap[dwTKMindex].aarValue.dw,
                        ptkmap[dwTKMindex].aarValue.pub));
                    ERR(("    only %{parameter} or \"substrings\" may coexist with =MacroRefs.\n"));
                    return(FALSE);
                }
                ptkmap[dwTKMindex].aarValue = aarNewValue ;
                return(TRUE);
            }
            default:
            {
                aarValue.dw++ ;
                aarValue.pub-- ;    //  restore the first char

                if(!BdelimitToken(&aarValue, pubDelimiters,
                    &aarToken, &dwDelim ) )
                {
                    aarToken = aarValue ;
                    ubChar = '\0' ;    // no more objects
                    aarValue.dw = 0 ;
                }
                else
                    ubChar = pubDelimiters[dwDelim];

                //  concat valuestring onto tmpHeap.
                if(!BCatToTmpHeap(&aarNewValue, &aarToken, pglobl) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Concatenation to produce expanded macro value failed.\n"));
                    return(FALSE) ;
                }
                break ;
            }
        }   //  end switch
    }       //  end while
    return(TRUE);  //  unreachable statement.
}


BOOL    BdelimitName(
PABSARRAYREF    paarValue,   //  the remainder of the string without the Name
PABSARRAYREF    paarToken,   //  contains the Name
PBYTE  pubChar )  //  first char after Name  - NULL is returned if nothing
                    //      remains.
{
    BYTE    ubSrc ;
    DWORD   dwI ;

    for(dwI = 0 ; dwI < paarValue->dw ; dwI++)
    {
        ubSrc = paarValue->pub[dwI] ;

        if( (ubSrc  < 'a' ||  ubSrc > 'z')  &&
            (ubSrc  < 'A' ||  ubSrc > 'Z')  &&
            (ubSrc  < '0' ||  ubSrc > '9')  &&
            (ubSrc  != '_')  )
        {
            break ;  // end of keyword token.
        }
    }
    paarToken->pub = paarValue->pub ;
    paarToken->dw = dwI ;
    paarValue->pub += dwI;
    paarValue->dw -= dwI ;

    if(paarValue->dw)
        *pubChar = ubSrc ;
    else
        *pubChar = '\0' ;

    return(paarToken->dw != 0) ;
}


BOOL    BCatToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl)
/*  if paarDest->dw is zero, copy paarSrc to the temp heap
    else append paarSrc to existing Heap.
    Note:  assumes existing string in parrDest is the most
    recent item on the Heap.
    does not create null terminated strings!  */
{
    ABSARRAYREF    aarTmpDest ;

    if(!BcopyToTmpHeap(&aarTmpDest, paarSrc, pglobl))
        return(FALSE) ;
    //  append this run to existing string
    if(!paarDest->dw)  // no prevs string exists
    {
        paarDest->pub = aarTmpDest.pub ;
    }
    else
    {
        // BUG_BUG paranoid:  may check that string is contiguous
        ASSERT(paarDest->pub + paarDest->dw ==  aarTmpDest.pub) ;
    }
    paarDest->dw += aarTmpDest.dw ;

    return(TRUE);
}


BOOL    BResolveBlockMacroReference(
PTKMAP   ptkmap,
DWORD    dwMacRefIndex,
PGLOBL   pglobl)
{
    DWORD   dwRefSymbolID, dwTKIndexOpen, dwTKIndexClose,
        dwEntry, //  note used to index MacroDict and later TKmap
        dwNewTKMindex, dwMaxIndex;
    ABSARRAYREF    aarValue  ;
    PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;
    PTKMAP   pNewtkmap ;


    aarValue = ptkmap[dwMacRefIndex].aarValue ;

    if(!BeatDelimiter(&aarValue, "=") )
    {
        ERR(("expected a =MacroName as the only value of *InsertBlockMacro keyword.\n"));
        return(FALSE);
    }

    if(!BparseSymbol(&aarValue,
        &dwRefSymbolID,
        VALUE_SYMBOL_BLOCKMACRO, pglobl) )
    {
        return(FALSE) ;
    }

    //  search BlockMacro Dict starting from most recent entry

    pBlockMacroDictEntry =
        (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;

    dwMaxIndex = gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex ;

    for(dwEntry = 0 ; dwEntry < dwMaxIndex ; dwEntry++)
    {
        if(pBlockMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwSymbolID
                == dwRefSymbolID)
            break ;
    }
    if(dwEntry >= dwMaxIndex)
    {
        ERR(("=MacroRef not resolved. Not defined or out of scope.\n"));
        return(FALSE) ;
    }

    dwTKIndexOpen =
        pBlockMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwTKIndexOpen ;

    dwTKIndexClose =
        pBlockMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwTKIndexClose ;

    if(dwTKIndexOpen == INVALID_INDEX  ||   dwTKIndexClose == INVALID_INDEX )
    {
        ERR(("Macro cannot be referenced until it has been fully defined.\n"));
        return(FALSE);
    }

    pNewtkmap = (PTKMAP)gMasterTable[MTI_NEWTOKENMAP].pubStruct ;

    for(dwEntry = dwTKIndexOpen + 1 ; dwEntry < dwTKIndexClose ; dwEntry++)
    {
        //  transfer all tokenmap fields to newTokenMap
        //  except NULL entries.

        if(pNewtkmap[dwEntry].dwKeywordID == ID_NULLENTRY)
            continue ;
        if(!BallocElementFromMasterTable(
                MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_NEWTOKENMAP ;
            return(FALSE);
        }
        pNewtkmap[dwNewTKMindex] = pNewtkmap[dwEntry] ;
    }
    return(TRUE);
}


BOOL    BDefineBlockMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl)
{
    DWORD   dwBlockMacroEntry, dwSymbolID ;
    PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;

    if(!BeatSurroundingWhiteSpaces(&pNewtkmap[dwNewTKMindex].aarValue) )
    {
        vIdentifySource(pNewtkmap + dwNewTKMindex, pglobl) ;
        ERR(("syntax error in BlockMacro name.\n"));
        return(FALSE);
    }

    dwSymbolID = DWregisterSymbol(&pNewtkmap[dwNewTKMindex].aarValue,
                               CONSTRUCT_BLOCKMACRO, TRUE, INVALID_SYMBOLID, pglobl ) ;
    if(dwSymbolID == INVALID_SYMBOLID)
        return(FALSE);


    if(!BallocElementFromMasterTable(
            MTI_BLOCKMACROARRAY, &dwBlockMacroEntry, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_BLOCKMACROARRAY ;
        return(FALSE);
    }

    pBlockMacroDictEntry = (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;

    pBlockMacroDictEntry[dwBlockMacroEntry].dwSymbolID = dwSymbolID ;
    pBlockMacroDictEntry[dwBlockMacroEntry].dwTKIndexOpen = INVALID_INDEX ;
    pBlockMacroDictEntry[dwBlockMacroEntry].dwTKIndexClose = INVALID_INDEX ;

    return(TRUE);
}



BOOL    BIncreaseMacroLevel(
BOOL    bMacroInProgress,
PGLOBL  pglobl)
//  called in response to parsing open brace.
{
    DWORD   dwMacroLevel ;
    PMACROLEVELSTATE    pMacroLevelStack ;

    if(!BallocElementFromMasterTable(
            MTI_MACROLEVELSTACK, &dwMacroLevel, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_MACROLEVELSTACK ;
        return(FALSE);
    }

    pMacroLevelStack = (PMACROLEVELSTATE)gMasterTable[MTI_MACROLEVELSTACK].pubStruct ;

    pMacroLevelStack[dwMacroLevel].dwCurBlockMacroEntry =
        gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex ;
    pMacroLevelStack[dwMacroLevel].dwCurValueMacroEntry =
        gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex;
    pMacroLevelStack[dwMacroLevel].bMacroInProgress =
        bMacroInProgress  ;

    return(TRUE);
}

BOOL    BDecreaseMacroLevel(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl)
//  called in response to parsing close brace.
{
    DWORD   dwMacroLevel, dwCurBlockMacroEntry, dwCurValueMacroEntry ,
        dwTKIndexOpen, dwTKIndexClose,
        dwTKMindex,  //  location of expired macros.
        dwEntry;  // index value and block macro dicts
    BOOL    bMacroInProgress ;
    PMACROLEVELSTATE    pMacroLevelStack ;
    PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;
    PVALUEMACRODICTENTRY    pValueMacroDictEntry ;

    if(!gMasterTable[MTI_MACROLEVELSTACK].dwCurIndex)
    {
        ERR(("Too many closing braces.  Fatal syntax error.\n"));
        geErrorSev = ERRSEV_FATAL ;
        geErrorType = ERRTY_SYNTAX  ;
        return(FALSE);
    }


    pBlockMacroDictEntry = (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;
    pValueMacroDictEntry = (PVALUEMACRODICTENTRY)gMasterTable[MTI_VALUEMACROARRAY].pubStruct ;
    pMacroLevelStack = (PMACROLEVELSTATE)gMasterTable[MTI_MACROLEVELSTACK].pubStruct ;
    dwMacroLevel = --gMasterTable[MTI_MACROLEVELSTACK].dwCurIndex;
    dwCurBlockMacroEntry = pMacroLevelStack[dwMacroLevel].dwCurBlockMacroEntry ;
    dwCurValueMacroEntry = pMacroLevelStack[dwMacroLevel].dwCurValueMacroEntry ;
    bMacroInProgress = pMacroLevelStack[dwMacroLevel].bMacroInProgress ;


    //  Does this closing brace end a macro definition?

    if(bMacroInProgress)
    {
        if(pBlockMacroDictEntry[dwCurBlockMacroEntry - 1].dwTKIndexClose
                != INVALID_INDEX)
        {
            ERR(("Internal Error: macro nesting level inconsistency.\n"));
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_CODEBUG ;
            return(FALSE);
        }
        pBlockMacroDictEntry[dwCurBlockMacroEntry - 1].dwTKIndexClose =
            dwNewTKMindex ;  // location of } in newtokenArray;
    }

    //  remove all traces of expired block and value macro definitions

    for(dwEntry = dwCurValueMacroEntry ;
        dwEntry < gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex ;
        dwEntry++)
    {
        dwTKMindex = pValueMacroDictEntry[dwEntry].dwTKIndexValue ;
        pNewtkmap[dwTKMindex].dwKeywordID = ID_NULLENTRY ;
    }

    for(dwEntry = dwCurBlockMacroEntry ;
        dwEntry < gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex ;
        dwEntry++)
    {
        dwTKIndexOpen = pBlockMacroDictEntry[dwEntry].dwTKIndexOpen ;
        dwTKIndexClose = pBlockMacroDictEntry[dwEntry].dwTKIndexClose ;
        for(dwTKMindex = dwTKIndexOpen ; dwTKMindex <= dwTKIndexClose ;
            dwTKMindex++)
            pNewtkmap[dwTKMindex].dwKeywordID = ID_NULLENTRY ;
    }

    if(bMacroInProgress  &&  gdwVerbosity >= 4)
    {
        VEnumBlockMacro(pNewtkmap,
                pBlockMacroDictEntry + dwCurBlockMacroEntry - 1, pglobl) ;
    }

    //  must ensure these values are restored even in the event
    //  of premature return;
    gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex = dwCurBlockMacroEntry;
    gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex = dwCurValueMacroEntry;

    return(TRUE);
}


VOID    VEnumBlockMacro(
PTKMAP  pNewtkmap,
PBLOCKMACRODICTENTRY    pBlockMacroDictEntry,
PGLOBL  pglobl )
{
    DWORD   dwTKIndexOpen, dwTKIndexClose, dwTKMindex ;

    dwTKIndexOpen = pBlockMacroDictEntry->dwTKIndexOpen ;
    dwTKIndexClose = pBlockMacroDictEntry->dwTKIndexClose ;

    ERR(("\nContents of Block Macro ID value: %d at:\n",
        pBlockMacroDictEntry->dwSymbolID)) ;
    vIdentifySource(pNewtkmap + dwTKIndexOpen, pglobl) ;

    for(dwTKMindex = dwTKIndexOpen + 1 ; dwTKMindex < dwTKIndexClose ;
        dwTKMindex++)
    {
        if(pNewtkmap[dwTKMindex].dwKeywordID == ID_NULLENTRY)
            continue ;

        ERR(("    %0.*s : %0.*s\n",
            pNewtkmap[dwTKMindex].aarKeyword.dw,
            pNewtkmap[dwTKMindex].aarKeyword.pub,
            pNewtkmap[dwTKMindex].aarValue.dw,
            pNewtkmap[dwTKMindex].aarValue.pub
            ));
    }
}


//  ----   scrap pile - may find some useful odds and ends here -----

//                gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex-- ;
                //  remove macrodef from dictionary.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\notes.c ===
#if 0

now:

rip out code that sets RulesAble flag.
Maybe recognize hex integers.
UIGroups

rip out check for cursor origin same as printable origin.






update docs with *IgnoreBlock and *Macros constructs.
note we require =Macroname not to have a space between.

new rule:  the value of any ValueMacro must be a syntatically valid
value all by itself.
for example
    parenthesis: (
is not a legal macro value since '(' is not a valid value by itself.

ValueMacro references may not appear within "quoted strings"
or %{param constructs}.







update declares.h


if you need to fudge *Color?  go to snapshot.c  and look for

    if(dwGID == GID_COLORMODE   &&
        ((PCOLORMODEEX)pubDestOptionEx)->bColor )
    {
        pUIinfo->dwFlags |= FLAG_COLOR_DEVICE ;
    }


eventually maybe add function callbacks to the snapshot table
which will provide different defaults depending on the
value of other structures in the bud file.

think about this:
zhanw wants multiple *case to refer to one block.
just like in 'C'.




classify errors into Errors and Warnings
assign each message a verbosity threshold.



more intentional errors for sample file.

complete warning of NON_LOCALIZEABLE keywords
add DisableMultipleCompression?  keyword for alvin.

flag a warning if any *name keyword is
present.





remove hardcoded globals from parser.





could delete 4 unnecessary indicies in mrbd structure.




should parser synthesize an extra %
if a literal % is found in a command
invocation?





code review of command:  move initoperPrecedence to
framwrk1.c
move list of delimiters to gpd.h




------

-----


---- Sanity checks as time permits ----

verify a movement and resolution units are multiples
of the masterunits.

verify there is no switch dependence on pickmany types of
features.

check that number of features and number of options
in each feature does not exceed 255.

if any parameter in a command uses MAXLIMIT(),  it must
be the ONLY parameter in the command.

during BInterpretTokens()  if a syntax error occurs, the
return value is set to false, but it is completely ignored.
No error condition is raised or anything!
examples:  mismatched closing braces


are all required fields for each GID type
present?  if not are there acceptable
defaults?   if not warn user.

check all papersizes against
*MinSize and *MaxSize defined for
a custom papersize to make sure they are
in range.   warn user if not.
If no cust size defined skip the check.



----  far in the future: -----



countrycode  as an implicit feature.
The current value is set at snapshot time.



state1.c : initAllowedTransitions
change FEATURE_FF so its only valid for states:
STATE_FEATURE, STATE_CASE_FEATURE and  STATE_OPTION_FEATURE









BUG_BUG !!!!!

check that all cases are terminated by break.

flags being set by |=  not just =.

always check to see dwKeywordID is a valid value before
using it to access any table.
ensure any failure clears tokenmap.flags.

are copies of aarValue being used when tkmap->aarValue
is required?  and vice versa?

Search through all uses of enumeration constants to verify
code does not need updating due to fact I added more
items to the list.

also symbol tree roots.  gdwTTFontSymbols
    with prefix m  since they are actually macros.

update each module header with correct function declarations.

not implemented:   factor out first part of qualified
    name outside of LIST construct.


be sure to clarify what structures are referenced from
UIInfo and which must be referenced from the offset pointer.


provide an overview of the attribute storing processing
use handwritten notes as a guide.


are tkmap flags like TKMF_COLON set when they should not be?


probably give shorthand version of *Command a
different name so there is no confusion .

features to implement:
---------------------


go through and fix the highest priority BUG_BUG!!!!! s.

implement shortcut converter and rip out hack code.






Testing hints:
------

must test all code in constrnts.c  and the
constraints code in helper1.c   I have changed
BexchangeDataInFOATNode().



an acid test of determinedefault option
is to make each default option multivalued
and use dependencies which conflict with
the default priority array.

make some features printer sticky, like interleave them.

VOID    VinitAllowedTransitions() ;   throwaway bp.
BOOL   BInterpretTokens( see keyword - value strings.
BOOL    BparseAndTerminateString(  unicode Xlation
BOOL BpostProcess(




create some defaultoptions with an upside down
dependence, forcing the priority array to be re initialized.

note looking at BarchiveStrings or BcopyToTmpHeap  is
a great way to see what is being parsed as a keyword and value!

test symbol registry by creating multiple features each
with multiple options.  Also by defining more features for
the same option in a separate section.
In fact alternate two or more feature definitions
to cause searches through several layers.

maybe nested switch constructs too.

BscanStringSegment().
try strings containing %"  or %< chars  or real
hex substrings.

prepend whitechars  and other forms of
arbitrary whitespace to keywords and insert between
tokens.  Try continuation lines etc.

try various types of constructs terminated immediately
by eof.

try some include files (nested includes too!)

make some symbol keywords.


{, }


keywords without : or values.

keywords or statements terminating with { or }.


try some fully invalid keywords.
try some structure or non-attribute keywords.
preface keyword with the EXTERN_GLOBAL or EXTERN_FEATURE
tag.  (BidentifyAttributeKeyword)

try some improper syntaxes.


test every type of value.
Lists etc.


attribute trees:

global initializer

then add switch conditionals.

do this both outside and within a feature/option construct.

remember to write down at allocation time
the address of the heap.

force propagation of lower level values as default initializers
by causing the tree to branch out more.

----- done ----

at high verbosity level, emit
keyword and value strings of all block macros
when fully defined.   And all keywords that reference
value macros.



force an error by defining this valuemacro:
MacroName: =MacroName "stuff"


note that all error messages need to be check to see
that
            vIdentifySource(ptkmap + dwTKMindex) ;
and other ERR messages that reference ptkmap
don't suffer from cut and paste syndrome.


note: when passing values to register symbol or whatever, you
must first strip the leading '=' since this is not automatically done.
need to fix for ?




debug   BdelimitName and BResolveValueMacroReference
must modify token1.c so it allows scanning for tokenRefs
within ().

ganesh wants invocation.dwcount to be initialized with
CommandIndex.

if a construct keyword is not recognized,
ignore everything up to matching closing brace.

If an error occurs parsing a construct , say missing a
required symbol, the entire body of the construct
enclosed by braces should be deleted.


implement by creating an IGNORE_STATE ?
could define a specific keyword that
can serve to ifdef out large chunks of code.


init  MINIRAWBINARYDATA  gmrbd ;


maybe add an new entry to the constants table
just after the {NULL, BOOLEANTYPE}
separator:  this will contain {"Boolean class", 0}

and the indexing code will skip this when constructing
the index.  However, we can find it by subtracting 1
from the start index.

also modify BOOL    BparseConstant(  in value1.c

postproc.c

let    BIdentifyConstantString(&arSymbolName,
                    &dwDevmodeID, dwConsClass)
    take a fourth param:  bCustomOptOK
    if true, then a much less severe warning is emitted.

also modify so it emits the class string instead
of a number.


add global to control warning level.
elaborate enumeration class messages, is such
a message fatal (ie SERIAL, PAGE)  or is it
tolerable (Option3) ?   give a friendly
explaination.   Enum Class 31  - what's that?


re-enabled *MaxNumPalettes for alvin to use.
default value is now 0.

add RIP if MAX_GID exceeds 32.


remove if DBCS from postproc.c

abort and retry if number of entries exceeds
dictionary size in framwrk1.c
also implement in sanpshot.c   see DwInitSnapShotTable2

new standard var:  rop3
another keyword:  *MirrorRasterByte?   in globals.

add to semantics check:
    *Helpindex value must be non-zero.


update constants for printingrate
move private defines out of gpdparse.h



Synthesize installable features for *Installable keyword.


Initialize missing fields with defaults.
sanity checks, features with zero options etc.
emit warning messages if needed.

set the priority array using *DefaultOption
(if needed) what other structures need to be saved?

reflect UIConstraints after parsing keywords.

convert Installation constraints list to UIConstraints
reflect as needed.

(from Zhanw: gpd changes)
I added two entries for custom help support:
- one global entry: *HelpFile which specifies the custom help file name.
- a generic entry for any feature/option: *HelpIndex which specifies the specific help index for that item.
CmdFF and CmdCR.

ganesh wants to split parser into DLL + lib.

modify Halftone processing in Postproc.c
to conform to alvins mail.



Alvin wants new keyword: count of halftone matricies

implement TTFontSub construct processing code.



Later a codepage keyword will let the parser know
whether to interpret such strings as single or double byte.

modify macro in gpd.h so a non-existent command
will cause a NULL to be returned , ganesh wants same for
fontlist.

Notes:  UNUSED_ITEM  will be used whenever a dword value, ResourceID
    has not been explicitly specified in the GPD file.
an empty list of items will be denoted by the value END_OF_LIST
instead of a valid index to the first listnode.



    warning GPD keywords missing from snapshot:
    ATREEREF     atrOptimizeLeftBound;  //   "OptimizeLeftBound?"
    ATREEREF     atrStripBlanks;  //   "StripBlanks"
    ATREEREF     atrRasterZeroFill;  //   "RasterZeroFill?"
    ATREEREF     atrRasterSendAllData;  //   "RasterSendAllData?"
    ATREEREF     atrCursorXAfterSendBlockData;  //   "CursorXAfterSendBlockData"
          Option Attribute:  *PromptTime
    ATREEREF     atrIPCallbackID;  //   "IPCallbackID"
    ATREEREF     atrColorSeparation;  //   "ColorSeparation?"
                atrMinStripBlankPixels  // a resolution option
    ATREEREF     atrColor;  //   "Color?"
    ATREEREF     atrDrvBPP;  //   "DrvBPP"
    ATREEREF     atrRotateSize;  //   "RotateSize?"





    /*   UIINFO fields not initialized in Snapshot :

    loNickName
    ARRAYREF        UIConstraints;              // array of UICONSTRAINTs
    ARRAYREF        UpdateRequiredItems;        //
    ARRAYREF        InvalidCombinations;        // array of INVALIDCOMBOs
    DWORD           dwMinScale;                 // mimimum scale factor (percent)
    DWORD           dwMaxScale;                 // maximum scale factor (percent)
    DWORD           dwLangEncoding;             // translation string language encoding
    DWORD           dwLangLevel;                // page description langauge level
    INVOCATION      Password;                   // password invocation string
    INVOCATION      ExitServer;                 // exitserver invocation string
    DWORD           dwProtocols;                // supported comm protocols
    DWORD           dwJobTimeout;               // default job timeout value
    DWORD           dwWaitTimeout;              // default wait timeout value
    DWORD           dwTTRasterizer;             // TrueType rasterizer option
    FIX_24_8        fxScreenAngle;              // screen angle - global default
    FIX_24_8        fxScreenFreq;               // screen angle - global default
    PTRREF          loFontInstallerName;        //
                                        dwFreeMem) ;

    /*   FEATURE fields not initialized in Snapshot :

    DWORD           dwNoneFalseOptIndex;        // None or False option index
    INVOCATION      QueryInvocation;            // query invocation string
    DWORD           dwFirstOrderIndex;          //
    DWORD           dwEnumID;                   //
    DWORD           dwEnumFormat;               //
    DWORD           dwCurrentID;                //
    DWORD           dwCurrentFormat;            //
        dwInstallableFeatureIndex) ;  not needed by snapshot.
        dwInstallableOptionIndex) ;
        dwUIConstraintList) ;

    /*   OPTION fields not initialized in Snapshot :

    INVOCATION      Invocation;                 // invocation string
        use sequenced command list instead.
    DWORD           dwUIConstraintList;         // index to the list of UIConstraints
    DWORD           dwOrderIndexNext;           //
    DWORD           dwInvalidComboIndex;        //
    DWORD           dwInstallableOptionIndex;   //


How do I initialize the various
    DWORD       dwFlags;                        // flag bits
    for various options from the GPD information?


!    DWORD           dwTechnology;               // see TECHNOLOGY enumeration
    what should this be set to?

There is no GPD keyword corresponding to
    uiinfo.loPrinterIcon.
        szMaxExtent) ;
        szMinExtent) ;

    papersizeoption.rcMaxExtent) ;
                rcMinExtent


    MemoryOption.dwFreeFontMem

    resolution.wDefaultDithering) ;



wFlags is mispelled in COLORMODEEX.

change to be a string!     dwSpecVersion) ;

ARRAYREF        CartridgeSlot;              // array of font cartridges names
    will now be
ARRAYREF        FontCartridges;              // array of font cartridge structures
    holds same arrayref as  GPDDrvInfo.DataType[DT_FONTSCART]


deleted from GPD spec:

    ATREEREF     atrSimulateXMove;        // "SimulateXMove"
    VectorOffset, ColorSeparation


MemoryForFontsOnly is now MemoryUsage?
add *Min/MaxGrayFill



CRC checksum
Date and time stamping
Bug preventing enumeration of UserDefined
    papersizes.

implement sematchk.c

lots of work to make sure we can handle option = FF
in all helper functions, and disabled features.



fix BInterpretTokens to elaborate error message:
which keyword is bad?

Do lines starting with a comment cause warnings? (no!)
maybe should run eat white spaces first!

test partially qualified name.
Test InvalidCon with just 2 items.

new pallete entries in colormode option find old e-mail.
(delete global entries find BUG_BUG!)


First InputSlot should be left uninitialized
and say "Use Form To Tray assignment"
paperbin = DMBIN_FORMSOURCE  I have no such bin!



implement *ConflictPriority, and 2 new keywords. see Zhanw's mail.

Also modify priority array code to assign higher priority
to printer sticky options.  In order they will be
Highest : Synthesized options
Higher  : printer sticky
Lowest  : doc sticky

Also implement a new keyword which allows user to
set relative priorities of doc and printer sticky
options.  (but keeps lists separate)



cannon wants to be able to specify the priority of
each feature.  but all synthesized options will have a
higher priority than non-synthesized.


update framwrk1.c to use new Installable keywords.


    copy master units to UIinfo when amanda updates parser.h
    verify bug and fix value1.c page 16.
    add PT_TTY to printertype.
At this time update
    instructions for adding new keywords to snapshot.c


    Postprocessing.
    must grovel through symbol tree and initialize
    atrFeaKeyWord and atrOptKeyWord for each feature and option.
    and translate from ansi to unicode

    set flags field in UIinfo.

newkeywords:  replace with actual defs in gpd.h
    ATREEREF     atrYMoveAttributes;        // "YMoveAttributes"
    ATREEREF     atrMaxLineSpacing;        // "MaxLineSpacing"
        do we special case its default?
    ATREEREF     atrMinGlyphID;        // "MinGlyphID"
    ATREEREF     atrMaxGlyphID;        // "MaxGlyphID"
    ATREEREF     atrDLSymbolSet;        // "DLSymbolSet"
        need to add its constants class
    ATREEREF     atrHelpFile;        // "HelpFile"
                atrCodePage     //"CodePage"
    ATREEREF     atrOptHelpIndex;        // "HelpIndex"
    ATREEREF     atrFeaHelpIndex;        // "HelpIndex"
        both Features and Options keyword.

    finish updating snapshot once gpd is updated.

    *PromptTime should be a Option only keyword.

    also init GID and option count for each feature.
    assume a normal dwGID and dwNumOptions field exists in DFEATURE_OPTION
    and it has been initialized as part of postprocessing.


    priority field is properly initialized at postprocessing?

    When assigning paperIDs to various papersize options,
    fill in paper dimensions if not already explicitly initialized
    note assign the custom paper DMPAPER_USER, and any
    driver defined paper sizes values larger than that.

    determine these by counting # setting for FeatureType keyword.
    pmrbd->dwDocumentFeatures;
    pmrbd->dwPrinterFeatures;

    search for all occurances of VALUE_STRING and
    replace by one of the 3 variants.

    use AP_APC to map filenames
    use *CodePage to map display strings and fontnames
    ParserVersion, symbolnames leave in ansi.
    define subvalues to control string translation.
    and key the unicode Xlation accordingly.
    Note: The *CodePage keyword affect the parsing of
    all applicable strings encountered after the *CodePage keyword.
    The *CodePage keyword my be subsequently re-defined.

    add dwSpecVersion field to MINIRAWBINARYDATA, convert string version
    stored in global attributes atrGPDSpecVersion to 2 words
    and store here during postprocessing.

    replace points with pairs

add single and double byte to unicode converter.
where should this be placed?  Note name of include file
uses a string, but should not be converted make this flag
controllable or define a new value, TO_UNICODE?.
remember:  Davidx says store Unicode strings on Word boundary.

line duplicated: postproc.c line 209.
        arSymbolName = psn[dwFeatureIndex].arSymbolName ;
remove before flight in value1.c

ExchangeDataInFOATNode needs changing: specifically,
it exchanges the dword at the heapoffset not the heapoffset
itself.   Need to change it so it can handle arbitrary sized
data.


replace rawbinary data by pinfo hdr for 2 functions:

GpdChangeOptionsViaID(
    IN PINFOHEADER  pInfoHdr ,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    )

GpdMapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2
    )



    collation and page protect use the predefined options
    ON/OFF, should assign these options optionID values of
    1/0 respectively.   need to modify  BinitSpecialFeatureOptionFields()
    in postproc.c


    when amanda adds collate to Parser.h, remove my private
    def from gpdparse.h

    also transfer my defs in snapshot.h to gpd.h

RotateRasterData? is now RotateRaster?
*YMoveUnits is now *YMoveUnit   (same for X)


GPDSpecVersion string not set.
snapshot.c : 400,000   is invalid syntax.

Last line of gpdloadrawbinarydata - snapshot.c
should be return(NULL);

atrPageDimensions) ; Is not required for custom papers.

Why are all except 2 items in the GID array NULL ?
and one is -1 ?   not repro.

prepare for reading resources from dll.  copy pcl5ems.dll
to printers directory.  check that RC values are correctly
initialized.

has the enum constant for the keyword
CursorXafterCR been changed from AT_GRXDATA_ORIGIN
to AT_CURSOR_X_ORIGIN ?  if so change spec and parser.

cause entire number string to be printed as an error
value1.c  -  line 552.


change GpdChangeOptionsViaID so
if paperID doesn't match, fall back to paper dimensions.
This is because the Spooler assigns new papers
IDs on a first come first serve basis.

why is test.gpd locked?
bug fix for uninitialized *CursorOrigin

snapshot.c 1467
        if(dwFlags & SSF_RETURN_UNINITIALIZED)
            return(TRI_UNINITIALIZED) ;

gpdparse.h     1448

#define     SSF_RETURN_UNINITIALIZED        0x00000200
    //  if no value exists, cause EextractValueFromTree
    //  to return TRI_UNINITIALIZED, but don't complain
    //  to user.

snaptbl.c  1849
    pmrbd->snapShotTable[dwI].dwFlags = SSF_RETURN_UNINITIALIZED ;

suppress the no integer found message by
not calling parseinteger if LIST code detects
nothing is there (dwCount = 0).


major bugs found in installable feature code!

Why did BparseInvalidInstallableCombination mess up
unable to recognize the option name?

Currently ExchangeDataInFOATNode
stores dwSynFea into dwFeature of patt.
Yet to the rest of the Snapshot code
this isn't SynFea 0 or 1, its Feature 8 or 9!

Verify no one in the snapshot accesses anything via
SynFea, then modify the two Exchange functions
when SynFea = TRUE.



note:  features must be synthesized after most postprocessing
    has occured so that constraints and things have been
    processed, but just before priority array is initialized.

new function:
 if(!BfindMatchingNode(&atrCur, dwFeature, dwOption))


BexchangeDataInFOATNode  and  BexchangeArbDataInFOATNode
    2 changes:  add new boolean bSynFeature
    dwIn is now pdwIn,  if this is NULL,
    this means we don't want to alter the attribute tree.


Handling of special keywords during the 2nd pass:

*InvalidInstallableCombination:
    parse into links of INVC nodes, with the
    new invalidcombo field of the first node
    pointing down to another invalid combo.
    A new field in the GlobalAttributes structure
    will point to the first (most recently created)
    INVC list.

    See state1.c  SPEC_INVALID_INS_COMBO
     currently calls BparseInvalidCombination()



*NotInstalledConstraints:
*InstalledConstraints:
    parse just like a normal constraint except the root
    is placed in the appropriate field.  Note there are two
    types:  LocalFeature and LocalOption.  Will the single
    function handle both?  Apparently yes.



*Installable:  treat just like another non-relocatable attribute.

after the 2nd pass, can FeaOpt array to see how many
Installable fields are set to TRUE.  (count both Fea and Opts)

Allocate this many synthesized features.

Scan FeaOpt array and link the Installable Feature/Option
with its synthesized feature using the links.

create a default list of Constraints that says SynFea/Not Installed
constrains  all options of the associated InstallableFeature/All
except option zero.   or if an installable option was specified
only one constraint constraining that one Fea/Option is synthesized.


copy the links for
*NotInstalledConstraints:
*InstalledConstraints:
to the associated Synthesized Feature/Installed
                            Feature/Not Installed
                                options.

look at each InvalidInstallableCombination
dereference each Qualified name , replace by associated
Synthesized Feature/Installed, and link to each SyntheFea.
No wildcards needed here.

must set breakpt in KM and see why GpdMapToDeviceOptIndex
keeps getting hit.


    return value is FALSE if every option for this
    feature is constrained (as may well be the case for
    an installable feature.)  Note, setup of sequenced
    commands may want to call these functions to determine
    if a command should be sent.
    How would init default option array work?  (just see if
    feature is constrained and automatically set option = FF)

make sure
          (WORD)pinvc[dwICNode].dwOption == (WORD)DEFAULT_INIT))
is handled properly everywhere!
if we define DEFAULT_INIT appearing in a constraint as matching
all options except index 0, then features don't have to be disabled,
and no special case code need be written!  to take care of FF
etc.

What about installable features?
if a feature is declared installable,
and the feature is specified to be NOT installed,
the option value for that feature must be set to
Don't care.   All the Constraints helper functions will
interpret a DON'T_CARE value as an anti wildcard that
doesn't match any option.
Must also modify code to make sequenced commands and
any code to expect an option may be don't care.

complete and test UI constraints helper functions.

check out latest GPD converted files and resources.
attempt to eliminate all warning messages during parsing.

what is needed to fully sync to latest stuff?

should an empty list be permitted?  YES.

this is called twice if first is successful!  memory leak!
in snapshot.c  line 3438
    if (!(pRawData = GpdLoadCachedBinaryData(ptstrDataFilename)))


    add new keywords for rectangle fills.  see alvin's
    mail.

    need to implement both helpstring and help index.
    revise gpd spec.

    fix CL_CONS_PAPERSIZE   DMPAPER_USER
    so it compares dwDevmodeID not FeatureID.



    initialize fields in minirawdata so when test.bud is
    loaded, it won't get rejected by the parser.

    debug all remaining code.


    verify all keywords are enumerated in snapshot.c


    don't restore DFEATURE_OPTIONS.atrGIDvalue - leave as dwGID

    test BwriteUnicodeToHeap.


    The split and combine helper function must recognize
    *FeatureType.

    decide what fields need to be updated as a result of
    the user changing a feature selection.
    Write this helper function.  Add optimization to return quickly
    if no update is required.

more special processing:
to save time do this only if atrModelName is not
initialized.  must load resource file and extract
Unicode string at atrModelNameID
and add to stringheap then place offset
in atrModelName.


    wait for constants to be defined for *DLSymbolSet
    and for ROMAN-8 .  and for Halftone options.



         ---  obsolete -----
no need to implement wildcards.
if the attribute tree for invalidcombinations
is allowed to contain the node  dwOpt = (WORD)DEFAULT_INIT
then the helper function accessing any InvalidCombo tree must
check for option = (WORD)DEFAULT_INIT as well as for dwOpt
if dwOpt != 0.   If an InvalidCombo node is encountered
containing [dwFea1, (WORD)DEFAULT_INIT]  this matches dwFea1, any
non-zero dwOpt.  So why (WORD) truncation?  Why not store as
dword?

should eventually remove the fully qualified pathname hack
I made since this is better implemented in
resource caching of dll.  (binary file should not be
installation dependent.  If GPD defines multiple
dlls, this hack will fail.




Locality stuff.


change from arrayref to dword:
iMin and MaxOverlayID in Globals.  ?




* if open brace is missing after a construct keyword, must
flag this as a fatal error.

* When consolidating data, add DWORD padding between each block of data.
Also need to free dest block of memory!

* BparseConstant()
should first check to see if strlen matches before
doing string compare.

* BstoreCommandAttrib()  note must compare string(dwCommandID)
with string associated with commandID.

* must change eOffsetMeans to VALUE_AT_HEAP after we write
something there.

* state1.c  BUG_BUG:   openbrace encountered
make this a fatal syntax error.


* mismatched braces should be considered a fatal error.
see PopStack().

* error parsing a construct should be considered a fatal error
due to messing up the stack.



* BidentifyAttributeKeyword  currently fails to identify any
keyword with TKMF_EXTERN_ flag set.

* Register symbol doesn't even check for NULL symbol
(aar.dw = 0)  or TKMF_NOVALUE !



give newtokenmap its own memory buffer else this buffer
will get freed twice.  But leave as is for now since the
GP fault allows me to set breakpts.


add comment saying all string refs use resourceptr.

look for MemAlloc  , if fails, make sure
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
are set.

also look for BUG_BUG comments of the type paranoid
or internal cons error.  also make this a fatal error.




When modifying DWregisterSymbol()   update
all references to this by doing fgrep in *.c *.h
and declarations too!

        eConstruct = CONSTRUCT_OPTION, CONSTRUCT_FEATURE  :



------  notes for amanda: -----

defaults if keyword is missing from GPD file:

pwstrResourceDLL:  0 or NULL  (strings)
iMaxNumPalettes:  NO_LIMIT_NUM means unlimited.  (int, dwords)
dwBadCursorMoveInGrxMode:  END_OF_LIST  means empty list.
dwDefaultCTT: NO_RC_CTT_ID
 0 normally indicates no resource.

ptMaxPrintableArea: (0, 0) means unlimited.
dwMaxLineSpacing:  UNUSED_ITEM    driver must compute the correct value
dwSymbolSetID: UNUSED_ITEM
iHelpIndex:  UNUSED_ITEM
dwIPCallbackID: 0 indicates no callback.
ptPrinterCursorOrig: WILDCARD_VALUE   assume cursor origin is same
    as printable origin.



typedef enum _UIDATATYPE {
    UIDT_FEATURE,
    UIDT_OPTION,
    UIDT_OPTIONEX,
    UIDT_CONSTRAINT,
    UIDT_GROUPS,
    UIDT_LISTNODE,                        // holds a LIST of dword values
    UIDT_FONTSCART,                       // list of FontCartridges
    UIDT_FONTSUBST,                       // Font Substitution table.

    UIDT_LAST
} UIDATATYPE;


add this to UIINFO:

DWORD   dwWhichBasePtr[UIDT_LAST] ;


#define     BASE_USE_RESOURCE_DATA  0x0001

Determine which BasePtr to use as follows:

if(uiinfo.dwWhichBasePtr[UIDT_GROUPS] & BASE_USE_RESOURCE_DATA)
    ptr = pubResourceData + loOffset ;
else
    ptr = (PBYTE)pInfoHeader + loOffset ;


PaletteSizes and PaletteScope should not be arrayrefs.
They are lists.



------ modification of zhanw's gpd files: ----

replace =Macroname with "Macroname"

comment out *Include:

must remove all uses of the shortcut *Command: name: "invocation"

EXTERN_GLOBAL:  must have the colon.

Add *CodePage: 1252  near front of file.


Add
        *SpotDiameter:100
to each resolution option.

Add
    *ModelName: "HP LazyJet 5Si"
    to replace *rcModelNameID

remove  Memory feature if it only
contains the shortcut
    *MemConfigKB: PAIR(9216, 7650)

    qualifiy path name as shown:
*ResourceDLL: "c:\tmp\pcl5ems.dll"

---- GPD file errors: ----

not a keyword:  EjectPageWithFF  missing ?



---  debugging process ------

build debug binary:

a) run chkbld
b) run ssync -r in \inc \unidrv \parsers  \libs  \driverui
c) run  build -c
    in \libs  \parsers  \driverui
d) prepare test.gpd  in \parsers\gpd
e) delete c:\winnt35\system32\spool\drivers\w32x86\2\test.bud
    whenever test.gpd  or parsercode is altered.

e) on the test machine run newdrvr.bat  then
    windbg notepad
f)  type

bp vinitglobals

    at the command window.
    type g  then hit <cr> everytime the "Unresolved Breakpoint"
    dialog box appears.
g) when notepad comes up click on file, page setup
h) when DRIVERUI.DLL (symbols loaded)  appears
    don't hit <cr>, instead click on set breakpoint
    and enter the actual break points you want set.
    Press Add, don't hit return until all breakpoints have
    been set.
    examples:
    BcreateGPDbinary,
    BisExternKeyword,
    BexchangeArbDataInFOATNode,
    GPDLOADCACHEDBINARYDATA
    gpdinitbinarydata
    gpdfreebinarydata
    gpdloadrawbinarydata
    gpdunloadrawbinarydata
    GpdInitDefaultOptions(
GpdSeparateOptionArray(
GpdCombineOptionArray(
GpdUpdateBinaryData(
GpdReconstructOptionArray(
GpdChangeOptionsViaID(
GpdMapToDeviceOptIndex(
BinitDefaultOptionArray


to restart debugging, clear all breakpoints,
click run / stop debugging.

return to step f)

i)  the string heap is the first element in gMasterTable.
    its address may be 147a68 no 1cd130


some parser warning messages and their source.

Warning, unrecognized keyword.
    Issued by  BInterpretTokens()  in state1.c when
    BidentifyAttributeKeyword()  returns failure.

constant value not a member of enumeration class:  nn
    Issued by BparseConstant() in value1.c

unrecognized Unidrv command name
    Issued by BstoreCommandAttrib() in state2.c

user supplied constant not a member of enumeration class nn
    Issued by BIdentifyConstantString()  in postproc.c

    enum classes:   26: standard values
                    27: Command names
                    28: feature names
                    31: Paper Source names

-------
error messages notes:

line numbers count \n and \r separately.  If
a program is using linenumbers, it should interpret
the count appropriately.

Not all errors will pinpoint a file and line number.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\preproc1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*
 *  preproc1.c - syntax generic preprocessor for parser
 */



#include    "gpdparse.h"




//check.  static   ABSARRAYREF  gaarPPPrefix = {"*", 1} ;
    //  set preprocessor prefix to '*'
// Now moved to GLOBL structure.

// ----  functions defined in preproc1.c ---- //

BOOL  DefineSymbol(PBYTE   symbol, PGLOBL pglobl) ;


BOOL       SetPPPrefix(PABSARRAYREF   parrPrefix, PGLOBL pglobl) ;

BOOL  BPreProcess(PGLOBL pglobl) ;  //  from current file position, use file macros to access.

enum  DIRECTIVE  ParseDirective(
PABSARRAYREF   paarCurPos,
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl) ;

BOOL   bSkipAnyWhite(PABSARRAYREF   paarCurPos) ;

BOOL   bSkipWhiteSpace(PABSARRAYREF   paarCurPos) ;

BOOL   bmatch(PABSARRAYREF   paarCurPos,  ABSARRAYREF aarReference) ;

BOOL   extractSymbol(PABSARRAYREF   paarSymbol, PABSARRAYREF   paarCurPos) ;

BOOL   strmatch(PABSARRAYREF   paarCurPos,   PCHAR  pref ) ;

BOOL   ExtractColon(PABSARRAYREF   paarCurPos) ;

enum  DIRECTIVE   IsThisPPDirective(
IN  OUT  PABSARRAYREF  paarFile ,    //  current pos in GPD file
         PABSARRAYREF  paarSymbol,   // return reference to heap copy of directive symbol
         PGLOBL        pglobl);

void  deleteToEOL(PABSARRAYREF   paarCurPos) ;

int  BytesToEOL(PABSARRAYREF   paarCurPos) ;

BOOL  SymbolTableAdd(
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl) ;

BOOL  SymbolTableRemove(
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl) ;

BOOL  SymbolTableExists(
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl) ;



// ---------------------------------------------------- //

 //       ERR(("%*s\n",  BytesToEOL(paarCurPos), paarCurPos->pub ));


BOOL  DefineSymbol(
PBYTE   symbol,
PGLOBL  pglobl)
{
    ABSARRAYREF   aarSymbol ;
    ARRAYREF        arSymbolName ;

    aarSymbol.pub = symbol ;
    aarSymbol.dw = strlen(symbol);

    #if 0

    this is not needed because SymbolTableAdd now always
       makes a copy of the aarSymbol.

    if(!BaddAARtoHeap(&aarSymbol, &arSymbolName, 1, pglobl))
    {
        ERR(("Internal error, unable to define %s!\n", symbol));
        return FALSE ;
    }

    aarSymbol.pub = arSymbolName.loOffset + mpubOffRef ;
    aarSymbol.dw = arSymbolName.dwCount  ;

    #endif

    if(!  SymbolTableAdd(&aarSymbol, pglobl) )
    {
        ERR(("Internal error, unable to define %s!\n", symbol));
        return FALSE ;
    }
    return  TRUE ;
}



BOOL       SetPPPrefix(
PABSARRAYREF   parrPrefix,
PGLOBL         pglobl)
{
    if(!parrPrefix->dw)
    {
        ERR(("#SetPPPrefix: syntax error - preprocessor prefix cannot be NULL !\n"));
        //  optional:  report filename and line number
        geErrorType = ERRTY_SYNTAX ;
        geErrorSev = ERRSEV_FATAL ;

        return  FALSE ;
    }
    gaarPPPrefix = *parrPrefix ;
    return  TRUE ;
}


//  GPD preprocessor:  implements the following preprocessor directives:
//      #Define: symbol
//      #Undefine: symbol
//      #Include:  filename     Note: this uses the exact syntax used by
//          The GPD *Include:  keyword except * is replaced by #
//      #Ifdef:      symbol
//      #Elseifdef:      symbol
//      #Else:
//      #Endif:
//      #SetPPPrefix:      symbol
//
//    notes:   when #Include:  is found, just  replace prefix with '*'.
//    instead of compressing file when #ifdefs are processed, just 'erase' unwanted
//    sections with space chars.  (leaving \n and \r  unchanged to preserve line #'s)
//    Need to store some  global state information.   like how many nesting levels
//    what are we currently doing, what symbols are defined etc.
//    Definitions:
//      Section:  these directives act as section delimiters:
//      #Ifdef:      symbol
//      #Elseifdef:      symbol
//      #Else:
//      #Endif:
//      Nesting level:  the number of unmatched  #ifdefs at the current position
//      determines the  nesting level at that position.
//     Note in these source code comments '#' represents the current preprocessor prefix.
//      This is set to '*' by default, but is changed using the  #SetPPPrefix:  directive.

BOOL  BPreProcess(
PGLOBL pglobl)
//  from current file position, use file macros to access.
{
    BOOL   bStatus = FALSE ;

    ABSARRAYREF   arrSymbol ,   //  holds symbol portion of directive.
                aarCurPos ;  //  holds current position in source file buffer.
    enum  DIRECTIVE    directive ;
    enum  IFSTATE    prevsIFState ;
    enum  PERMSTATE  prevsPermState ;

    aarCurPos.pub    = mpubSrcRef + mdwSrcInd ;
    aarCurPos.dw     =   mdwSrcMax -  mdwSrcInd ;


    while((directive = ParseDirective(&aarCurPos, &arrSymbol, pglobl)) != DIRECTIVE_EOF)
    {
        switch(directive)
        {
            case  DIRECTIVE_DEFINE:
                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                {
                    if(!SymbolTableAdd(&arrSymbol, pglobl) )
                        return(FALSE);  // error!
                }
                break;
            case  DIRECTIVE_UNDEFINE:
                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                {
                    if(!SymbolTableRemove(&arrSymbol, pglobl) )
                    {
                        if(geErrorSev != ERRSEV_FATAL )
                        {
                            ERR(("syntax error - attempting to undefine a symbol that isn't defined !\n"));
                            ERR(("%.*s\n",  BytesToEOL(&arrSymbol), arrSymbol.pub ));
                            geErrorType = ERRTY_SYNTAX ;
                            geErrorSev = ERRSEV_FATAL ;
                            goto  PREPROCESS_FAILURE;
                        }
                    }
                }
                break;
            case  DIRECTIVE_INCLUDE:
                if(mppStack[mdwNestingLevel].permState != PERM_ALLOW)
                {
                    deleteToEOL(&aarCurPos) ;
                    break;   //  it never happened.
                }
                goto   PREPROCESS_SUCCESS ;
                break;
            case  DIRECTIVE_SETPPPREFIX :
                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                    SetPPPrefix(&arrSymbol, pglobl);
                break;
            case  DIRECTIVE_IFDEF:
                //  state-invariant behavior
                prevsPermState =  mppStack[mdwNestingLevel].permState ;
                mdwNestingLevel++ ;
                if(mdwNestingLevel >= mMaxNestingLevel)
                {
                    if(ERRSEV_RESTART > geErrorSev)
                    {
                        geErrorType = ERRTY_MEMORY_ALLOCATION ;
                        geErrorSev = ERRSEV_RESTART ;
                        gdwMasterTabIndex = MTI_PREPROCSTATE ;
                    }
                    goto  PREPROCESS_FAILURE;
                }

                if(SymbolTableExists(&arrSymbol, pglobl))
                    mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
                else
                    mppStack[mdwNestingLevel].permState = PERM_DENY ;

                if(prevsPermState != PERM_ALLOW)
                    mppStack[mdwNestingLevel].permState = PERM_LATCHED ;

                mppStack[mdwNestingLevel].ifState =  IFS_CONDITIONAL;

                break;
            case  DIRECTIVE_ELSEIFDEF:
                if(mppStack[mdwNestingLevel].ifState ==  IFS_ROOT)
                {
                    ERR(("syntax error - #Elseifdef directive must be preceeded by #Ifdef !\n"));
                    //  optional:  report filename and line number
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }
                if(mppStack[mdwNestingLevel].ifState ==  IFS_LAST_CONDITIONAL)
                {
                    ERR(("syntax error - #Elseifdef directive cannot follow #Else !\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }

                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                    mppStack[mdwNestingLevel].permState = PERM_LATCHED ;
                else if(mppStack[mdwNestingLevel].permState == PERM_DENY)
                {
                    if(SymbolTableExists(&arrSymbol, pglobl))
                        mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
                }


                break;
            case  DIRECTIVE_ELSE :
                if(mppStack[mdwNestingLevel].ifState ==  IFS_ROOT)
                {
                    ERR(("syntax error - #Else directive must be preceeded by #Ifdef or #Elseifdef !\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }
                if(mppStack[mdwNestingLevel].ifState ==  IFS_LAST_CONDITIONAL)
                {
                    ERR(("syntax error - #Else directive cannot follow #Else !\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }
                mppStack[mdwNestingLevel].ifState =  IFS_LAST_CONDITIONAL ;


                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                    mppStack[mdwNestingLevel].permState = PERM_LATCHED ;
                else if(mppStack[mdwNestingLevel].permState == PERM_DENY)
                {
                    mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
                }

                break;
            case  DIRECTIVE_ENDIF :
                if(mppStack[mdwNestingLevel].ifState ==  IFS_ROOT)
                {
                    ERR(("syntax error - #Endif directive must be preceeded by #Ifdef or #Elseifdef or #Else !\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }
                mdwNestingLevel-- ;   //  restore previous nesting level.
                break;
            default:
                ERR(("internal consistency error - no such preprocessor directive!\n"));
                ERR(("%.*s\n",  BytesToEOL(&aarCurPos), aarCurPos.pub ));
                geErrorType = ERRTY_CODEBUG ;
                geErrorSev = ERRSEV_FATAL ;
                goto  PREPROCESS_FAILURE;

                break;
        }
    }




    PREPROCESS_SUCCESS:
    return  TRUE  ;

    PREPROCESS_FAILURE:
    return  FALSE ;
}





enum  DIRECTIVE  ParseDirective(PABSARRAYREF   paarCurPos,
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl)
{
    //  this function parses from the 'current' position:  mdwSrcInd
    //  for any recognized directive and returns that directive.

    //  if (mppStack[mdwNestingLevel].permState != PERM_ALLOW)
    //      all characters   != \n  or \r encountered while looking for the directive
    //      will be replaced by space characters.
    //
    //  the entire line containing the directive is replaced by spaces.
    //  (except for the Include directive - only the prefix is replaced by '*'
    //   with leftpadded spaces if needed.)
    //  cur pos is set to the line following the one containing the directive.
    //  before the directive is destroyed, a copy is made of the symbol argument
    //  and a reference parrSymbol is initialized to point to this copy.
    //  this copy is stored on the heap so it's lifetime is effectively 'forever'.

    //  syntax of directive:
    //  a directive token must  be immediately preceeded by the current preprocessor
    //  prefix.  The prefix must be preceeded by a line delimiter (unless its the
    //  first line in the file).   Optional whitespace characters (space or tab) may reside between
    //  the line delimiter and the prefix.
    //  the actual DIRECTIVE  Token may be followed by Optional whitespace, then must
    //  be followed by the Colon delimiter, the next non-whitespace token is interpreted
    //  as the symbol.   Any characters following the symbol token to the line delimiter
    //   will be ignored.   A Directive cannot occupy more than one line.

    //   this function assumes cur pos points to start of line when it is called.

    enum  DIRECTIVE  directive ;
    BOOL    bStartOfNewLine  = TRUE ;
    BYTE     ubSrc ;


    while(  paarCurPos->dw  )   //  EOF detector
    {
        if(bStartOfNewLine  &&         //  directives must start at newline or
            //  have only whitespace intervening
            (directive = IsThisPPDirective( paarCurPos, parrSymbol, pglobl)) !=  NOT_A_DIRECTIVE )
        {
            return  directive;
        }

        ubSrc = *paarCurPos->pub ;
            //extract current character
        if(ubSrc != '\n'  &&  ubSrc != '\r')
        {
            bStartOfNewLine = FALSE ;
            if(mppStack[mdwNestingLevel].permState != PERM_ALLOW)
            {
                *paarCurPos->pub = ' ' ;   //  replace with harmless space.
            }
        }
        else
            bStartOfNewLine = TRUE ;

        (paarCurPos->pub)++ ;   // advance to next character.
        (paarCurPos->dw)-- ;
    }
    return  DIRECTIVE_EOF ;
}


BOOL   bSkipAnyWhite(PABSARRAYREF   paarCurPos)
//  checks for EOF
{
    while(  paarCurPos->dw  )   //  EOF detector
    {
        BYTE  ubSrc = *paarCurPos->pub ;
            //extract current character
        if(ubSrc != ' '  &&  ubSrc != '\t'  &&  ubSrc != '\n'  &&  ubSrc != '\r')
        {
            return  TRUE ;   //  Non-white char encountered
        }
        (paarCurPos->pub)++ ;   // advance to next character.
        (paarCurPos->dw)-- ;
    }
    return  FALSE ;  //  reached  eof
}


BOOL   bSkipWhiteSpace(PABSARRAYREF   paarCurPos)
{
//  checks for EOF
    while(  paarCurPos->dw  )   //  EOF detector
    {
        BYTE  ubSrc = *paarCurPos->pub ;
            //extract current character
        if(ubSrc != ' '  &&  ubSrc != '\t' )
        {
            return  TRUE ;   //  Non-white char encountered
        }
        (paarCurPos->pub)++ ;   // advance to next character.
        (paarCurPos->dw)-- ;
    }
    return  FALSE ;  //  reached  eof
}

BOOL   bmatch(PABSARRAYREF   paarCurPos,  ABSARRAYREF aarReference)
//  checks for EOF
{
    if(!paarCurPos->dw)
        return  FALSE ;  //  reached  eof
    if(paarCurPos->dw < aarReference.dw)
        return  FALSE ;  //  not enough chars in buffer to match reference.
    if(strncmp(paarCurPos->pub, aarReference.pub, aarReference.dw))
        return  FALSE ;
    paarCurPos->pub += aarReference.dw ;   //  otherwise we match the reference!!
    paarCurPos->dw -=  aarReference.dw ;    //  advance pointer past matching substring
    return  TRUE ;
}

BOOL   extractSymbol(PABSARRAYREF   paarSymbol, PABSARRAYREF   paarCurPos)
//  checks for EOF
{
    paarSymbol->pub = paarCurPos->pub ;

    for(paarSymbol->dw = 0 ; paarCurPos->dw  ; paarSymbol->dw++,
             (paarCurPos->pub)++ , paarCurPos->dw--)
    {
        BYTE  ubSrc = *paarCurPos->pub ;
            //extract current character
        if(ubSrc == ' '  ||  ubSrc == '\t'  ||  ubSrc == '\n'  ||  ubSrc == '\r')
        {
            break;
        }
    }

    if(!paarSymbol->dw)
        return  FALSE ;     //  nothing?

    return  TRUE ;   // this is our preprocessor symbol.
}

BOOL   strmatch(PABSARRAYREF   paarCurPos,   PCHAR  pref )
//  checks for EOF  - means dw cannot go neg.
{
    DWORD   dwRefLen ;

    if(!paarCurPos->dw)
        return  FALSE ;  //  reached  eof

    dwRefLen = strlen(pref);

    if(paarCurPos->dw < dwRefLen)
        return  FALSE ;  //  not enough chars in buffer to match reference.
    if(strncmp(paarCurPos->pub, pref, dwRefLen))
        return  FALSE ;     //  no match
    paarCurPos->pub += dwRefLen ;   //  otherwise we match the reference!!
    paarCurPos->dw -=  dwRefLen ;    //  advance pointer past matching substring
    return  TRUE ;   // match!
}

BOOL   ExtractColon(PABSARRAYREF   paarCurPos)
//  checks for EOF  - means dw cannot go neg.
{
    if(! bSkipWhiteSpace( paarCurPos) )
        return  FALSE ;     //  reached EOF
    if(!strmatch(paarCurPos,   ":" ) )
        return  FALSE ;     //  no match
    if(! bSkipWhiteSpace( paarCurPos) )
        return  FALSE ;     //  reached EOF
    return  TRUE ;   // match!
}

enum  DIRECTIVE   IsThisPPDirective(
IN  OUT  PABSARRAYREF  paarFile ,   //  current pos in GPD file
      PABSARRAYREF   paarSymbol,    // return reference to heap copy of directive symbol
      PGLOBL         pglobl)
//  This function only processes the current line and determines if
//  the current line is a valid preprocessor directive.
//  This function assumes paarFile initially points to start of the line
//  if this is a directive, advances paarFile->pub  to EOL  and replaces the
//    line with spaces.
//  if not a directive,  advances paarFile->pub  past initial whitespace padding.
//  to reduce repeat processing.
{
    ABSARRAYREF     aarPrefix,   // points to first non-white char found
    aarDirective;   // points right after prefix.
    enum  DIRECTIVE   directive ;
//    PBYTE  pBuff = paarFile->pub ;

    //  there can only be whitespace padding or linebreaks preceeding prefix:
    if(!bSkipAnyWhite(paarFile ))   //  skip any combination of spaces , tabs  and linebreaks
        return  DIRECTIVE_EOF ;
         //   EOF overflow has occured or some bizzare failure!


    aarPrefix =  *paarFile;   //  remember location of the prefix or first non-white char

    if(!bmatch(paarFile, gaarPPPrefix))   //  advances paarFile
    {
        *paarFile = aarPrefix ;    //  restore to just beyond white padding
        return  NOT_A_DIRECTIVE ;
    }

    aarDirective = *paarFile ;

    if(strmatch(paarFile, "Define")  )
            directive =  DIRECTIVE_DEFINE;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Undefine")  )
            directive =  DIRECTIVE_UNDEFINE;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Include")  )
            directive =   DIRECTIVE_INCLUDE;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Ifdef")  )
            directive =   DIRECTIVE_IFDEF;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Elseifdef")  )
            directive =   DIRECTIVE_ELSEIFDEF;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Else")  )
            directive =   DIRECTIVE_ELSE;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Endif")  )
            directive =   DIRECTIVE_ENDIF;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "SetPPPrefix")  )
            directive =  DIRECTIVE_SETPPPREFIX ;
    else
    {               //   (directive ==  NOT_A_DIRECTIVE)
        *paarFile = aarPrefix ;    //  restore to just beyond white padding
        return  NOT_A_DIRECTIVE ;
    }


    if(directive == DIRECTIVE_INCLUDE)
    {
        //  replace prefix with  leftpadded   '*' ;
        DWORD  dwI ;
        for(dwI = 0 ; dwI < gaarPPPrefix.dw ; dwI++)
            (aarPrefix.pub)[dwI] = ' ' ;   // replace prefix with all spaces
        (aarPrefix.pub)[ gaarPPPrefix.dw - 1] = '*' ;   //  last char becomes '*'.

        *paarFile = aarPrefix ;    //   this allows *Include: entry to be deleted if != PERM_ALLOW
        return  directive;
    }

    if(!ExtractColon(paarFile))   //  parse surrounding spaces also.
    {
        ERR(("syntax error - colon delimiter required after preprocessor directive !\n"));
        ERR(("%.*s\n",  BytesToEOL(&aarPrefix), aarPrefix.pub ));
        if(geErrorSev < ERRSEV_CONTINUE)
        {
            geErrorType = ERRTY_SYNTAX ;
            geErrorSev = ERRSEV_CONTINUE ;
        }
        *paarFile = aarPrefix ;    //  restore to just beyond white padding
        return  NOT_A_DIRECTIVE ;
    }
    if(directive ==  DIRECTIVE_SETPPPREFIX  ||
        directive ==   DIRECTIVE_ELSEIFDEF  ||
        directive ==   DIRECTIVE_IFDEF  ||
        directive ==  DIRECTIVE_UNDEFINE  ||
        directive ==  DIRECTIVE_DEFINE)
    {
        ARRAYREF        arSymbolName ;

        if(!extractSymbol(paarSymbol, paarFile))   //  identifies substring of paarFile
        {
            ERR(("syntax error - symbol required after this  preprocessor directive !\n"));
            ERR(("%.*s\n",  BytesToEOL(&aarPrefix), aarPrefix.pub ));
            if(geErrorSev < ERRSEV_CONTINUE)
            {
                geErrorType = ERRTY_SYNTAX ;
                geErrorSev = ERRSEV_CONTINUE ;
            }
            *paarFile = aarPrefix ;    //  restore to just beyond white padding
            return  NOT_A_DIRECTIVE ;
        }

        /*  I would  use
        BOOL    BcopyToTmpHeap()             (token1.c)
        except this will confuse the
        heck out of Register symbol, which is expecting all strings to
        be stored in the regular heap!     */


        if(!BaddAARtoHeap(paarSymbol, &arSymbolName, 1, pglobl))
            return(DIRECTIVE_EOF );  //  cause a swift abort


        paarSymbol->pub = arSymbolName.loOffset + mpubOffRef ;
        paarSymbol->dw = arSymbolName.dwCount  ;
        //  permanent location of symbol in Heap.
    }

    //  replace all non-white chars on the line to EOL or EOF  with spaces ;
    *paarFile = aarPrefix  ;
    deleteToEOL(paarFile) ;
    return  directive;
}


void  deleteToEOL(PABSARRAYREF   paarCurPos)
//   actually replace with space chars
{
    for( ; paarCurPos->dw  ;  paarCurPos->pub++, paarCurPos->dw--)
    {
        BYTE  ubSrc = *(paarCurPos->pub) ;
        if(ubSrc != '\n'  &&  ubSrc != '\r')
            *(paarCurPos->pub) = ' ' ;   //  replace with harmless space.
        else
            break;  //  reached EOL.  paarFile points to EOL.
    }
}


int  BytesToEOL(PABSARRAYREF   paarCurPos)
{
    int     iCount ;

    for(iCount = 0 ; paarCurPos->dw > (DWORD)iCount  ;  iCount++)
    {
        BYTE  ubSrc = paarCurPos->pub[iCount] ;
        if(ubSrc == '\n'  ||  ubSrc == '\r')
            break;  //  reached EOL.
    }
    return(iCount) ;
}



BOOL  SymbolTableAdd(
PABSARRAYREF   paarSymbol,
PGLOBL         pglobl)
{
    DWORD   dwSymbolID ;

    dwSymbolID = DWregisterSymbol(paarSymbol, CONSTRUCT_PREPROCESSOR,
                    TRUE, INVALID_SYMBOLID, pglobl) ;
    if(dwSymbolID == INVALID_SYMBOLID)
    {
        return(FALSE );
    }
    return  TRUE ;
}


BOOL  SymbolTableRemove(
PABSARRAYREF   paarSymbol,
PGLOBL         pglobl)
{
    DWORD   dwSymbolID , dwCurNode;
    PSYMBOLNODE     psn ;

    dwSymbolID =   DWsearchSymbolListForAAR(paarSymbol,  mdwPreProcDefinesSymbols, pglobl) ;
    if(dwSymbolID == INVALID_SYMBOLID)
    {
        return(FALSE );
    }

    dwCurNode = DWsearchSymbolListForID(dwSymbolID,
        mdwPreProcDefinesSymbols, pglobl) ;
    if(dwCurNode == INVALID_INDEX)
    {
        ERR(("Parser error - can't find symbol node !\n"));
         geErrorType = ERRTY_CODEBUG ;
         geErrorSev = ERRSEV_FATAL ;
         return(FALSE );  //  cause a swift abort
    }


    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;


    //  how do you remove this node from the symbol tree?
    psn[dwCurNode].arSymbolName.dwCount = 0 ;
    //  can't navigate backwards along tree so just truncate string!
    return  TRUE ;
}

BOOL  SymbolTableExists(
PABSARRAYREF   paarSymbol,
PGLOBL         pglobl)
{
    DWORD   dwSymbolID ;

    dwSymbolID =   DWsearchSymbolListForAAR(paarSymbol,  mdwPreProcDefinesSymbols, pglobl) ;
    if(dwSymbolID == INVALID_SYMBOLID)
    {
        return(FALSE );
    }
    return  TRUE ;
}



#if 0
>>>>


    DWORD   dwCurNode, dwSymbolID ;
    PSYMBOLNODE     psn ;

    dwSymbolID = DWregisterSymbol(paarSymbol, CONSTRUCT_PREPROCESSOR,
                    FALSE, INVALID_SYMBOLID) ;
    if(dwSymbolID == INVALID_SYMBOLID)
    {
        return(DIRECTIVE_EOF );  //  cause a swift abort
    }

    dwCurNode = DWsearchSymbolListForID(dwSymbolID,
        mdwPreProcDefinesSymbols) ;
    if(dwCurNode == INVALID_INDEX);
    {
        ERR(("Parser error - can't find symbol node !\n"));
         geErrorType = ERRTY_CODEBUG ;
         geErrorSev = ERRSEV_FATAL ;
         return(DIRECTIVE_EOF );  //  cause a swift abort
    }


    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    paarSymbol->pub = psn[dwCurNode].arSymbolName.loOffset + mpubOffRef ;
    paarSymbol->dw = psn[dwCurNode].arSymbolName.dwCount  ;


    SymbolTableAdd(&aarSymbol);

    may use  from state1.c

DWORD   DWregisterSymbol(
PABSARRAYREF  paarSymbol,  // the symbol string to register
CONSTRUCT eConstruct ,  // type of construct determines class of symbol.
BOOL    bCopy,   //  shall we copy paarSymbol to heap?  May set
DWORD   dwFeatureID   //  if you are registering an option symbol
                //   and you already know the feature , pass it in
                //  here.  Otherwise set to INVALID_SYMBOLID
)
/*  this function registers the entire string specified
    in paarSymbol.  The caller must isolate the string.
*/
{
    //  returns SymbolID, a zero indexed ordinal
    //    for extra speed we may hash string


but what do we define for symbol class?
            if(eConstruct == CONSTRUCT_FONTCART)
                pdwSymbolClass += SCL_FONTCART ;
            else if(eConstruct == CONSTRUCT_TTFONTSUBS)
                pdwSymbolClass += SCL_TTFONTNAMES ;
            else if(eConstruct == CONSTRUCT_COMMAND)
                pdwSymbolClass += SCL_COMMANDNAMES ;
            else if(eConstruct == CONSTRUCT_BLOCKMACRO)
                pdwSymbolClass +=  SCL_BLOCKMACRO;
            else if(eConstruct == CONSTRUCT_MACROS)
                pdwSymbolClass +=  SCL_VALUEMACRO;
            else if(eConstruct == CONSTRUCT_PREPROCESSOR)
                pdwSymbolClass +=  SCL_PPDEFINES;
            else
                pdwSymbolClass += SCL_FEATURES ;



DWORD   DWsearchSymbolListForAAR(
PABSARRAYREF    paarSymbol,
DWORD           dwNodeIndex) ;
//  given a 'aar' to a string representing a symbol, search
//  the SymbolList beginning at dwNodeIndex for this symbol.
//  Return its symbolID  if found, else return the INVALID_SYMBOLID.
{
    PSYMBOLNODE     psn ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    for( ; dwNodeIndex != INVALID_INDEX ;
        dwNodeIndex = psn[dwNodeIndex].dwNextSymbol)
    {
        if(BCmpAARtoAR(paarSymbol,  &(psn[dwNodeIndex].arSymbolName)) )
            return(psn[dwNodeIndex].dwSymbolID);  // string matches !
    }
    return(INVALID_SYMBOLID);
}



fragments for future use:

from framwrk1.c:

VOID  VinitGlobals()
    gMasterTable[MTI_SYMBOLROOT].dwArraySize =  SCL_NUMSYMCLASSES ;
    gMasterTable[MTI_SYMBOLROOT].dwMaxArraySize =  SCL_NUMSYMCLASSES ;
    gMasterTable[MTI_SYMBOLROOT].dwElementSiz = sizeof(DWORD)  ;

    gMasterTable[MTI_STSENTRY].dwArraySize = 20  ;
    gMasterTable[MTI_STSENTRY].dwMaxArraySize = 60  ;
    gMasterTable[MTI_STSENTRY].dwElementSiz =  sizeof(STSENTRY) ;
    modify to serve as the preprocessor state Stack
    need also macros to access the stack.




//  -----  Preprocessor Section ---- //               from gpdparse.h

    enum  IFSTATE  {IFS_ROOT, IFS_CONDITIONAL , IFS_LAST_CONDITIONAL } ;
        //  tracks correct syntatical use of #ifdef, #elseifdef, #else and #endif directives.
    enum  PERMSTATE  {PERM_ALLOW, PERM_DENY ,  PERM_LATCHED } ;
        //  tracks current state of preprocessing,
        //  PERM_ALLOW:  all statements in this section are passed to body gpdparser
        //  PERM_DENY:  statements in this section are discarded
        //  PERM_LATCHED:  all statements until the end of  this nesting level are discarded.
    enum  DIRECTIVE  {NOT_A_DIRECTIVE, DIRECTIVE_EOF, DIRECTIVE_DEFINE , DIRECTIVE_UNDEFINE ,
                       DIRECTIVE_INCLUDE , DIRECTIVE_SETPPPREFIX , DIRECTIVE_IFDEF ,
                       DIRECTIVE_ELSEIFDEF , DIRECTIVE_ELSE , DIRECTIVE_ENDIF }


typedef  struct
{
    enum  IFSTATE  ifState ;
    enum  PERMSTATE  permState ;
} PPSTATESTACK, * PPPSTATESTACK ;
//  the tagname is 'ppss'


    MTI_PREPROCSTATE,  //  array of PPSTATESTACK structures
            //  which hold state of preprocessor.
    gMasterTable[MTI_PREPROCSTATE].dwArraySize =  20 ;
    gMasterTable[MTI_PREPROCSTATE].dwMaxArraySize =  100 ;
    gMasterTable[MTI_PREPROCSTATE].dwElementSiz =  sizeof(PPSTATESTACK) ;


#define     mppStack  ((PPPSTATESTACK)(gMasterTable \
                            [MTI_PREPROCSTATE].pubStruct))
    //  location of first SOURCEBUFFER element in array

#define     mdwNestingLevel   (gMasterTable[MTI_PREPROCSTATE].dwCurIndex)
    //  current preprocessor directive nesting level

#define     mMaxNestingLevel   (gMasterTable[MTI_PREPROCSTATE].dwArraySize)
    //  max preprocessor directive nesting depth





    //  init preprocessor state stack

    mdwNestingLevel = 0 ;
    mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
    mppStack[mdwNestingLevel].ifState =  IFS_ROOT;

#endif

// ---- End Of Preprocessor  Section ---- //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\postproc.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*
 *  postproc.c - postprocessing functions



 History of Changes
  9/30/98 --hsingh--
          Added three functions BsetUQMFlag(), BRecurseNodes(), BsetUQMTrue()
          to enable making the UpdateQualityMacro? keyword optional in
          .gpd file.
          Bug Report 225088
*/


#include    "gpdparse.h"


// ----  functions defined in postproc.c ---- //


DWORD   dwFindLastNode(
            DWORD  dwFirstNode,
            PGLOBL pglobl) ;

BOOL    BappendCommonFontsToPortAndLandscape(
            PGLOBL pglobl) ;

BOOL    BinitSpecialFeatureOptionFields(
            PGLOBL pglobl) ;

BOOL    BIdentifyConstantString(
            IN  PARRAYREF   parString,
            OUT PDWORD      pdwDest,        //  write dword value here.
            IN  DWORD       dwClassIndex,   // which class of constant is this?
                BOOL        bCustomOptOK,
                PGLOBL      pglobl
) ;



BOOL    BReadDataInGlobalNode(
            PATREEREF   patr,     // address of field in GlobalAttrib struct
            PDWORD      pdwHeapOffset,
            PGLOBL      pglobl
) ;


BOOL    BsetUQMFlag(PGLOBL pglobl);
BOOL    BRecurseNodes(
            IN DWORD  dwNodeIndex,
            PGLOBL pglobl);
BOOL    BsetUQMTrue(
            IN DWORD dwFeature,
            PGLOBL pglobl);


VOID    VCountPrinterDocStickyFeatures(
            PGLOBL pglobl) ;

BOOL    BConvertSpecVersionToDWORD (
            PWSTR   pwstrFileName ,
            PGLOBL  pglobl) ;





BOOL    BinitMiniRawBinaryData(
            PGLOBL pglobl) ;

BOOL    BexchangeArbDataInFOATNode(
                DWORD   dwFeature,
                DWORD   dwOption,
                DWORD   dwFieldOff,   // offset of field in FeatureOption struct
                DWORD   dwCount,       //  number bytes to copy.
            OUT PBYTE   pubOut,        // previous contents of attribute node
            IN  PBYTE   pubIn,         // new contents of attribute node.
                PBOOL   pbPrevsExists, // previous contents existed.
                BOOL    bSynthetic,     //  access synthetic features
                PGLOBL  pglobl
)  ;

BOOL    BInitPriorityArray(
            PGLOBL pglobl) ;



// ---------------------------------------------------- //



typedef struct
{
    DWORD   paperID ;
    DWORD   x ;
    DWORD   y ;
}  PAPERDIM ;

CONST   PAPERDIM aPaperDimensions[] = {
    DMPAPER_LETTER,                          215900, 279400,
    DMPAPER_LETTERSMALL,                     215900, 279400,
    DMPAPER_TABLOID,                         279400, 431800,
    DMPAPER_LEDGER,                          431800, 279400,
    DMPAPER_LEGAL,                           215900, 355600,
    DMPAPER_STATEMENT,                       139700, 215900,
    DMPAPER_EXECUTIVE,                       184150, 266700,
    DMPAPER_A3,                              297000, 420000,
    DMPAPER_A4,                              210000, 297000,
    DMPAPER_A4SMALL,                         210000, 297000,
    DMPAPER_A5,                              148000, 210000,
    DMPAPER_B4,                              257000, 364000,
    DMPAPER_B5,                              182000, 257000,
    DMPAPER_FOLIO,                           215900, 330200,
    DMPAPER_QUARTO,                          215000, 275000,
    DMPAPER_10X14,                           254000, 355600,
    DMPAPER_11X17,                           279400, 431800,
    DMPAPER_NOTE,                            215900, 279400,
    DMPAPER_ENV_9,                            98425, 225425,
    DMPAPER_ENV_10,                          104775, 241300,
    DMPAPER_ENV_11,                          114300, 263525,
    DMPAPER_ENV_12,                          120650, 279400,
    DMPAPER_ENV_14,                          127000, 292100,
    DMPAPER_CSHEET,                          431800, 558800,
    DMPAPER_DSHEET,                          558800, 863600,
    DMPAPER_ESHEET,                          863600,1117600,
    DMPAPER_ENV_DL,                          110000, 220000,
    DMPAPER_ENV_C5,                          162000, 229000,
    DMPAPER_ENV_C3,                          324000, 458000,
    DMPAPER_ENV_C4,                          229000, 324000,
    DMPAPER_ENV_C6,                          114000, 162000,
    DMPAPER_ENV_C65,                         114000, 229000,
    DMPAPER_ENV_B4,                          250000, 353000,
    DMPAPER_ENV_B5,                          176000, 250000,
    DMPAPER_ENV_B6,                          176000, 125000,
    DMPAPER_ENV_ITALY,                       110000, 230000,
    DMPAPER_ENV_MONARCH,                     98425, 190500,
    DMPAPER_ENV_PERSONAL,                    92075, 165100,
    DMPAPER_FANFOLD_US,                      377825, 279400,
    DMPAPER_FANFOLD_STD_GERMAN,              215900, 304800,
    DMPAPER_FANFOLD_LGL_GERMAN,              215900, 330200,

    DMPAPER_ISO_B4,                          250000, 353000,
    DMPAPER_JAPANESE_POSTCARD,               100000, 148000,
    DMPAPER_9X11,                            228600, 279400,
    DMPAPER_10X11,                           254000, 279400,
    DMPAPER_15X11,                           381000, 279400,
    DMPAPER_ENV_INVITE,                      220000, 220000,
    DMPAPER_LETTER_EXTRA,                    241300, 304800,

    DMPAPER_LEGAL_EXTRA,                     241300, 381000,
    DMPAPER_TABLOID_EXTRA,                   296926, 457200,
    DMPAPER_A4_EXTRA,                        235458, 322326,
    DMPAPER_LETTER_TRANSVERSE,               215900, 279400,
    DMPAPER_A4_TRANSVERSE,                   210000, 297000,
    DMPAPER_LETTER_EXTRA_TRANSVERSE,         241300, 304800,
    DMPAPER_A_PLUS,                          227000, 356000,
    DMPAPER_B_PLUS,                          305000, 487000,
    DMPAPER_LETTER_PLUS,                     215900, 322326,
    DMPAPER_A4_PLUS,                         210000, 330000,
    DMPAPER_A5_TRANSVERSE,                   148000, 210000,
    DMPAPER_B5_TRANSVERSE,                   182000, 257000,
    DMPAPER_A3_EXTRA,                        322000, 445000,
    DMPAPER_A5_EXTRA,                        174000, 235000,
    DMPAPER_B5_EXTRA,                        201000, 276000,
    DMPAPER_A2,                              420000, 594000,
    DMPAPER_A3_TRANSVERSE,                   297000, 420000,
    DMPAPER_A3_EXTRA_TRANSVERSE,             322000, 445000,

    // Predefined forms currently availble only in Win95.  Included here
    // for compatibility.

    // FE-only predefined forms.
    #ifndef WINNT_40
    DMPAPER_DBL_JAPANESE_POSTCARD,           200000, 148000,
    DMPAPER_A6,                              105000, 148000,
    DMPAPER_JENV_KAKU2,                      240000, 332000,
    DMPAPER_JENV_KAKU3,                      216000, 277000,
    DMPAPER_JENV_CHOU3,                      120000, 235000,
    DMPAPER_JENV_CHOU4,                       90000, 205000,
    DMPAPER_LETTER_ROTATED,                  279400, 215900,
    DMPAPER_A3_ROTATED,                      420000, 297000,
    DMPAPER_A4_ROTATED,                      297000, 210000,
    DMPAPER_A5_ROTATED,                      210000, 148000,
    DMPAPER_B4_JIS_ROTATED,                  364000, 257000,
    DMPAPER_B5_JIS_ROTATED,                  257000, 182000,
    DMPAPER_JAPANESE_POSTCARD_ROTATED,       148000, 100000,
    DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED,   148000, 200000,
    DMPAPER_A6_ROTATED,                      148000, 105000,
    DMPAPER_JENV_KAKU2_ROTATED,              332000, 240000,
    DMPAPER_JENV_KAKU3_ROTATED,              277000, 216000,
    DMPAPER_JENV_CHOU3_ROTATED,              235000, 120000,
    DMPAPER_JENV_CHOU4_ROTATED,              205000,  90000,
    DMPAPER_B6_JIS,                          128000, 182000,
    DMPAPER_B6_JIS_ROTATED,                  182000, 128000,
    DMPAPER_12X11,                           304932, 279521,
    DMPAPER_JENV_YOU4,                       105000, 235000,
    DMPAPER_JENV_YOU4_ROTATED,               235000, 105000,
    DMPAPER_P16K,                            146000, 215000,
    DMPAPER_P32K,                            970000, 151000,
    DMPAPER_P32KBIG,                         101000, 160000,
    DMPAPER_PENV_1,                          102000, 165000,
    DMPAPER_PENV_2,                          110000, 176000,
    DMPAPER_PENV_3,                          125000, 176000,
    DMPAPER_PENV_4,                          110000, 208000,
    DMPAPER_PENV_5,                          110000, 220000,
    DMPAPER_PENV_6,                          120000, 230000,
    DMPAPER_PENV_7,                          160000, 230000,
    DMPAPER_PENV_8,                          120000, 309000,
    DMPAPER_PENV_9,                          229000, 324000,
    DMPAPER_PENV_10,                         324000, 458000,
    DMPAPER_P16K_ROTATED,                    215000, 146000,
    DMPAPER_P32K_ROTATED,                    151000, 970000,
    DMPAPER_P32KBIG_ROTATED,                 160000, 101000,
    DMPAPER_PENV_1_ROTATED,                  165000, 102000,
    DMPAPER_PENV_2_ROTATED,                  176000, 110000,
    DMPAPER_PENV_3_ROTATED,                  176000, 125000,
    DMPAPER_PENV_4_ROTATED,                  208000, 110000,
    DMPAPER_PENV_5_ROTATED,                  220000, 110000,
    DMPAPER_PENV_6_ROTATED,                  230000, 120000,
    DMPAPER_PENV_7_ROTATED,                  230000, 160000,
    DMPAPER_PENV_8_ROTATED,                  309000, 120000,
    DMPAPER_PENV_9_ROTATED,                  324000, 229000,
    DMPAPER_PENV_10_ROTATED,                 458000, 324000,
    #endif
    0,                                       0,      0
};




DWORD   dwFindLastNode(
DWORD  dwFirstNode,
PGLOBL pglobl)
//  assume dwFirstNode  != END_OF_LIST
{
    PLISTNODE    plstRoot ;  // start of LIST array

    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    while(plstRoot[dwFirstNode].dwNextItem != END_OF_LIST)
        dwFirstNode = plstRoot[dwFirstNode].dwNextItem ;
    return(dwFirstNode);
} // dwFindLastNode(...)


BOOL    BappendCommonFontsToPortAndLandscape(
PGLOBL pglobl)
//   append dwFontLst to dwPortFontLst and dwLandFontLst
//   in the FontCart  structure.
{
    DWORD       dwNumFontCarts , dwI, dwNodeIndex;
    PFONTCART   pfc ;
    PLISTNODE   plstRoot ;  // start of LIST array

    dwNumFontCarts = gMasterTable[MTI_FONTCART].dwArraySize ;

    if(!dwNumFontCarts)
        return (TRUE);   // no fontcart structs to process.

    pfc      = (PFONTCART)gMasterTable[MTI_FONTCART].pubStruct ;
    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    for(dwI = 0 ; dwI < dwNumFontCarts ; dwI++)
    {
        if(pfc[dwI].dwFontLst == END_OF_LIST)
            continue;   // nothing to append.

        if(pfc[dwI].dwPortFontLst == END_OF_LIST)
            pfc[dwI].dwPortFontLst = pfc[dwI].dwFontLst ;
        else
        {
            dwNodeIndex = dwFindLastNode(pfc[dwI].dwPortFontLst, pglobl) ;
            plstRoot[dwNodeIndex].dwNextItem = pfc[dwI].dwFontLst ;
        }
        if(pfc[dwI].dwLandFontLst == END_OF_LIST)
            pfc[dwI].dwLandFontLst = pfc[dwI].dwFontLst ;
        else
        {
            dwNodeIndex = dwFindLastNode(pfc[dwI].dwLandFontLst, pglobl) ;
            plstRoot[dwNodeIndex].dwNextItem = pfc[dwI].dwFontLst ;
        }
    } //for dwI
    return (TRUE);   //
} //BappendCommonFontsToPortAndLandscape()


BOOL    BinitSpecialFeatureOptionFields(
PGLOBL pglobl)
//  determine num options and Unicode names for feature and
//  option keywords.
{
    DWORD   dwOptionID , dwOptionIndex , dwHeapOffset,
            dwFeatureIndex, dwFeatureID,  dwLargestString ,
            dwAccumulator ;  // tracks amount of buffer needed to store
                             //  Feature/Option keyword strings in devmode.

    PSYMBOLNODE         psn ;
    PDFEATURE_OPTIONS   pfo ;
    ARRAYREF            arSymbolName, arUnicodeName;

    BOOL        bPickMany,  // can user select multiple options?
                bExists ;   // dummy

    PBYTE       pubFeaDelim = " NewFeature " ,
                pubTrue     = " TRUE ",
                pubFalse    = " FALSE ";

    //  do this just for non-synthesized features.
    //  write atrFeaKeyWord directly as heap offset.
    //  write atrOptKeyWord as single level tree
    //  using BexchangeArbDataInFOATNode().

    gmrbd.dwMaxPrnKeywordSize = gmrbd.dwMaxDocKeywordSize = 0 ;
    // tell amanda how much room to reserve in devmode or registry
    //  to store feature/option keywords.
    gmrbd.rbd.dwChecksum32 =   0 ;  // seed


    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwFeatureIndex = mdwFeatureSymbols ;

    while(dwFeatureIndex != INVALID_INDEX)
    {
        DWORD   dwRootOptions ,
            dwNonStandardSizeID = FIRST_NON_STANDARD_ID ;

        dwFeatureID  = psn[dwFeatureIndex].dwSymbolID ;
        arSymbolName = psn[dwFeatureIndex].arSymbolName ;

        //  -----  special checks for Feature describing multiple Resource DLLs.

        if(dwFeatureID   &&  (dwFeatureID  ==  gdwResDLL_ID) )
        {
            //   does feature have correct symbolname?
            PBYTE  pubResName = "RESDLL" ;
            DWORD   dwLen ;

            dwLen = strlen(pubResName);

            if((dwLen != arSymbolName.dwCount)  ||
                strncmp(mpubOffRef + arSymbolName.loOffset,
                            pubResName,  dwLen) )
            {
                ERR(("References to ResourceDLLs must be placed in the feature with symbolname: %s.\n", pubResName));
                return(FALSE);
            }

            //   has   atrOptRcNameID  been defined?

            if(pfo[dwFeatureID].atrOptRcNameID !=  ATTRIB_UNINITIALIZED)
            {
                ERR(("ResourceDLL names must be declared explicitly using *Name not *rcNameID.\n"));
                return(FALSE);
            }
        }



        // -----  compute BUD checksum

        gmrbd.rbd.dwChecksum32 = ComputeCrc32Checksum (
                                    pubFeaDelim,
                                    strlen(pubFeaDelim),
                                    gmrbd.rbd.dwChecksum32 ) ;

        //  perform checksum on arSymbolName

        gmrbd.rbd.dwChecksum32 = ComputeCrc32Checksum(
                                    mpubOffRef + arSymbolName.loOffset,
                                    arSymbolName.dwCount,
                                    gmrbd.rbd.dwChecksum32 ) ;


        //    extract value for atrFeaInstallable using
            if(!BReadDataInGlobalNode(&pfo[dwFeatureID].atrFeaInstallable , &dwHeapOffset, pglobl)
                ||   *(PDWORD)(mpubOffRef + dwHeapOffset)  !=  BT_TRUE)
                    gmrbd.rbd.dwChecksum32 =        //  no synthesized feature associated
                        ComputeCrc32Checksum(
                            pubFalse,
                            strlen(pubFalse),
                            gmrbd.rbd.dwChecksum32      ) ;
            else
                gmrbd.rbd.dwChecksum32 =        //   associated with synthesized feature
                    ComputeCrc32Checksum(
                        pubTrue,
                        strlen(pubTrue),
                        gmrbd.rbd.dwChecksum32      ) ;

        // -----    end part I  compute BUD checksum

        dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;

        pfo[dwFeatureID].dwNumOptions =
            psn[dwRootOptions].dwSymbolID + 1 ;



#if 0
        Don't convert symbol values to Unicode.
        if(!BwriteUnicodeToHeap(&arSymbolName, &arUnicodeName,
                iCodepage = 0))
            return(FALSE) ;
#endif
        if(!BwriteToHeap(&(pfo[dwFeatureID].atrFeaKeyWord),
            (PBYTE)&arSymbolName, sizeof(ARRAYREF), 4, pglobl))
            return(FALSE);

        dwAccumulator = arSymbolName.dwCount + 2 ;


        pfo[dwFeatureID].atrFeaKeyWord |= ATTRIB_HEAP_VALUE ;

        {  //  !!! new stuff
            DWORD   dwHeapOffset  ;

            dwLargestString = 0 ;  //  track the largest option string

            if(!BReadDataInGlobalNode(&pfo[dwFeatureID].atrUIType , &dwHeapOffset, pglobl)
                ||   *(PDWORD)(mpubOffRef + dwHeapOffset)  !=  UIT_PICKMANY)
                bPickMany = FALSE ;
                 //  accumulator += the largest option string;
            else
                bPickMany = TRUE ;
                //   accumulator = sum of all option strings;
        }


        if(!BIdentifyConstantString(&arSymbolName,
            &(pfo[dwFeatureID].dwGID), CL_CONS_FEATURES, TRUE, pglobl) )
        {
            pfo[dwFeatureID].dwGID = GID_UNKNOWN ;
        }

        if((pfo[dwFeatureID].dwGID == GID_MEMOPTION)  ||
            (pfo[dwFeatureID].dwGID == GID_PAGEPROTECTION))
        {
            DWORD   dwHeapOffset, dwValue  ;
            PATREEREF   patr ;

            //  set only if not explictly initialized in GPD file.

            if(!BReadDataInGlobalNode(&pfo[dwFeatureID].atrFeatureType , &dwHeapOffset, pglobl) )
            {
                //  label this FeatureType as PrinterSticky
                dwValue = FT_PRINTERPROPERTY ;
                patr  = &pfo[dwFeatureID].atrFeatureType ;

                if(!BwriteToHeap(patr, (PBYTE)&dwValue ,
                    sizeof(DWORD), 4, pglobl) )
                {
                    return(FALSE) ;  // heap overflow start over.
                }
                *patr  |= ATTRIB_HEAP_VALUE ;
            }
        }

        dwOptionIndex = dwRootOptions ;

        while(dwOptionIndex != INVALID_INDEX)
        {
            DWORD   dwDevmodeID, dwConsClass, dwInstallable ;
            BOOL    bCustomOptOK ;

            dwOptionID = psn[dwOptionIndex].dwSymbolID ;
            arSymbolName = psn[dwOptionIndex].arSymbolName ;



        // -----    part II  compute BUD checksum
            //  perform checksum on arSymbolName

            gmrbd.rbd.dwChecksum32 =
                ComputeCrc32Checksum(
                    mpubOffRef + arSymbolName.loOffset,
                    arSymbolName.dwCount,
                    gmrbd.rbd.dwChecksum32      ) ;


            //    extract value for atrOptInstallable using
            if( BexchangeArbDataInFOATNode(dwFeatureID,  dwOptionID,
                    offsetof(DFEATURE_OPTIONS, atrOptInstallable) ,
                    sizeof(DWORD),
                    (PBYTE)&dwInstallable, NULL, &bExists, FALSE , pglobl)  &&
                bExists  &&  dwInstallable ==  BT_TRUE)
                    gmrbd.rbd.dwChecksum32 =        //   associated with synthesized feature
                        ComputeCrc32Checksum(
                            pubTrue,
                            strlen(pubTrue),
                            gmrbd.rbd.dwChecksum32      ) ;
            else
                    gmrbd.rbd.dwChecksum32 =        //  no synthesized feature associated
                        ComputeCrc32Checksum(
                            pubFalse,
                            strlen(pubFalse),
                            gmrbd.rbd.dwChecksum32 ) ;
        // -----    end part II  compute BUD checksum


#if 0
            if(!BwriteUnicodeToHeap(&arSymbolName, &arUnicodeName,
                    iCodepage = 0))
                return(FALSE) ;
            //  if this is ever used, must use &arUnicodeName
            //  as the 2nd argument to BwriteToHeap.
#endif

            if(! BexchangeArbDataInFOATNode(
                dwFeatureID,  dwOptionID,
                offsetof(DFEATURE_OPTIONS, atrOptKeyWord),
                sizeof(ARRAYREF),
                NULL, (PBYTE)&arSymbolName, &bExists, FALSE , pglobl))
                return(FALSE);   //  this is a fatal error.

            if(bPickMany)
                dwAccumulator += arSymbolName.dwCount + 1 ;
            else
            {
                //  track largest option string
                if(dwLargestString < arSymbolName.dwCount + 1 )
                    dwLargestString = arSymbolName.dwCount + 1 ;
            }


            switch(pfo[dwFeatureID].dwGID)
            {
                case GID_PAGESIZE:
                    dwConsClass = CL_CONS_PAPERSIZE ;
                    bCustomOptOK = TRUE ;
                    break ;
                case GID_MEDIATYPE:
                    dwConsClass = CL_CONS_MEDIATYPE ;
                    bCustomOptOK = TRUE ;
                    break ;
                case GID_INPUTSLOT:
                    dwConsClass = CL_CONS_INPUTSLOT ;
                    bCustomOptOK = TRUE ;
                    break ;
                case GID_HALFTONING:
                    dwConsClass = CL_CONS_HALFTONE ;
                    bCustomOptOK = TRUE ;
                    break ;
                case GID_DUPLEX:
                    dwConsClass = CL_CONS_DUPLEX ;
                    bCustomOptOK = FALSE ;
                    break ;
                case GID_ORIENTATION:
                    dwConsClass = CL_CONS_ORIENTATION ;
                    bCustomOptOK = FALSE ;
                    break ;
                case GID_PAGEPROTECTION:
                    dwConsClass = CL_CONS_PAGEPROTECT ;
                    bCustomOptOK = FALSE ;
                    break ;
                case GID_COLLATE:
                    dwConsClass = CL_CONS_COLLATE ;
                    bCustomOptOK = FALSE ;
                    break ;

                default:
                    dwConsClass = CL_NUMCLASSES ;
                    bCustomOptOK = TRUE ;  // Irrelavent.
                    break ;
            } //switch

            if(dwConsClass != CL_NUMCLASSES)
            {
                if(BIdentifyConstantString(&arSymbolName,
                    &dwDevmodeID, dwConsClass, bCustomOptOK, pglobl) )
                {
                    if(! BexchangeArbDataInFOATNode(
                        dwFeatureID,  dwOptionID,
                        offsetof(DFEATURE_OPTIONS, atrOptIDvalue),
                        sizeof(DWORD),
                        NULL, (PBYTE)&dwDevmodeID, &bExists, FALSE , pglobl))
                        return(FALSE);   //  this is a fatal error.


                    if(dwConsClass == CL_CONS_PAPERSIZE  &&
                        dwDevmodeID < DMPAPER_USER)
                    {
                        //  fill in the page dimensions.
                        POINT   ptDim ;
                        DWORD   dwI ;
                        PGLOBALATTRIB   pga ;
                        BOOL    bTRUE = TRUE ;
                        PBYTE  pub ;

                        if(dwDevmodeID == DMPAPER_LETTER)
                        {
                            //   pointer to dword containing heapoffset
                            PATREEREF      patrAttribRoot ;

                            pub =  gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
                            patrAttribRoot = &(((PGLOBALATTRIB)pub)->atrLetterSizeExists) ;
                            BwriteToHeap((PDWORD)  patrAttribRoot, (PBYTE)&bTRUE,  4 , 4 , pglobl);
                            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
                        }
                        else if(dwDevmodeID == DMPAPER_A4)
                        {
                            PATREEREF      patrAttribRoot ;  //   pointer to dword containing heapoffset

                            pub =  gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
                            patrAttribRoot = &(((PGLOBALATTRIB)pub)->atrA4SizeExists) ;
                            BwriteToHeap((PDWORD)  patrAttribRoot, (PBYTE)&bTRUE,  4 , 4 , pglobl);
                            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
                        }

                        for(dwI = 0 ; aPaperDimensions[dwI].x ; dwI++)
                        {
                            if(aPaperDimensions[dwI].paperID == dwDevmodeID)
                                break ;
                        }
                        //  worst case causes (0,0) to be assigned.

                        ptDim.x = aPaperDimensions[dwI].x ;
                        ptDim.y = aPaperDimensions[dwI].y ;

                        //  convert from microns to master units

                        ptDim.x /= 100 ;  // microns to tenths of mm
                        ptDim.y /= 100 ;

                        pga =  (PGLOBALATTRIB)gMasterTable[
                                    MTI_GLOBALATTRIB].pubStruct ;

                        if(!BReadDataInGlobalNode(&pga->atrMasterUnits,
                                &dwHeapOffset, pglobl) )
                            return(FALSE);

                        ptDim.x *= ((PPOINT)(mpubOffRef + dwHeapOffset))->x ;
                        ptDim.y *= ((PPOINT)(mpubOffRef + dwHeapOffset))->y ;

                        ptDim.x /= 254 ;
                        ptDim.y /= 254 ;


                        if(! BexchangeArbDataInFOATNode(
                            dwFeatureID,  dwOptionID,
                            offsetof(DFEATURE_OPTIONS, atrPageDimensions),
                            sizeof(POINT),
                            NULL, (PBYTE)&ptDim, &bExists, FALSE , pglobl))
                            return(FALSE);   //  this is a fatal error.
                    }
                }
                else if(bCustomOptOK)
                //  feature permits GPD defined options
                {
                    DWORD   dwID ,  // pattern size ID used by GDI
                        dwOldID,  // user specified ID value if any.
                        dwRcPatID;
                    POINT   ptSize ;

                    //  Option Symbolvalue not found in tables.
                    //  assume its a user-defined value.

                    #ifndef WINNT_40
                    if((pfo[dwFeatureID].dwGID == GID_HALFTONING)  &&
                        BexchangeArbDataInFOATNode(
                            dwFeatureID,  dwOptionID,
                            offsetof(DFEATURE_OPTIONS, atrRcHTPatternID),
                            sizeof(DWORD),
                            (PBYTE)&dwRcPatID, NULL, &bExists, FALSE , pglobl)  &&
                        bExists  &&  dwRcPatID  &&
                        BexchangeArbDataInFOATNode(
                            dwFeatureID,  dwOptionID,
                            offsetof(DFEATURE_OPTIONS, atrHTPatternSize),
                            sizeof(POINT),
                            (PBYTE)&ptSize, NULL, &bExists, FALSE, pglobl )  &&
                        bExists &&
                        (ptSize.x >= HT_USERPAT_CX_MIN)  &&
                        (ptSize.x <= HT_USERPAT_CX_MAX)  &&
                        (ptSize.y >= HT_USERPAT_CY_MIN)  &&
                        (ptSize.y <= HT_USERPAT_CY_MAX)
                        )
                    {
                        dwID = HT_PATSIZE_USER ;
                        //  GID halftone code is to use
                        //  the user defined halftone matrix.
                    }
                    else
                    #endif
                    {
                        dwID = dwNonStandardSizeID ;
                        dwNonStandardSizeID++ ;
                        //  OEM will supply a halftone function.
                    }

                    if(! BexchangeArbDataInFOATNode(
                        dwFeatureID,  dwOptionID,
                        offsetof(DFEATURE_OPTIONS, atrOptIDvalue),
                        sizeof(DWORD),
                        (PBYTE)&dwOldID, (PBYTE)NULL, &bExists, FALSE , pglobl ))
                        return(FALSE);   //  this is a fatal error.

                    if(!bExists  &&  ! BexchangeArbDataInFOATNode(
                        dwFeatureID,  dwOptionID,
                        offsetof(DFEATURE_OPTIONS, atrOptIDvalue),
                        sizeof(DWORD),
                        NULL, (PBYTE)&dwID, &bExists, FALSE  , pglobl))
                        return(FALSE);   //  this is a fatal error.
                }
            } // if(dwConsClass != CL_NUMCLASSES)

            //  otherwise leave optionID uninitialized.

            dwOptionIndex = psn[dwOptionIndex].dwNextSymbol ;

        } //while




        {  //  !!! new stuff
            DWORD   dwHeapOffset  ;

            dwAccumulator += dwLargestString ;   //  is zero if not needed.

            if(!BReadDataInGlobalNode(&pfo[dwFeatureID].atrFeatureType , &dwHeapOffset, pglobl)
                ||   *(PDWORD)(mpubOffRef + dwHeapOffset)  !=  FT_PRINTERPROPERTY)
                gmrbd.dwMaxDocKeywordSize += dwAccumulator;
            else
                gmrbd.dwMaxPrnKeywordSize += dwAccumulator;

        }


        dwFeatureIndex = psn[dwFeatureIndex].dwNextSymbol ;
    }
    return(TRUE) ;
} // BinitSpecialFeatureOptionFields()




BOOL    BIdentifyConstantString(
    IN      PARRAYREF   parString,
    OUT     PDWORD      pdwDest,      //  write dword value here.
    IN      DWORD       dwClassIndex, // which class of constant is this?
            BOOL        bCustomOptOK,
    IN      PGLOBL      pglobl
)
{
    DWORD   dwI, dwCount, dwStart , dwLen;

    dwStart = gcieTable[dwClassIndex].dwStart ;
    dwCount = gcieTable[dwClassIndex].dwCount ;


    for(dwI = 0 ; dwI < dwCount ; dwI++)
    {
        dwLen = strlen(gConstantsTable[dwStart + dwI].pubName);

        if((dwLen == parString->dwCount)  &&
            !strncmp(mpubOffRef + parString->loOffset,
                        gConstantsTable[dwStart + dwI].pubName,
                        dwLen) )
        {
            *pdwDest = gConstantsTable[dwStart + dwI].dwValue ;
            return(TRUE);
        }
    }

    if(bCustomOptOK)
    {
        if(gdwVerbosity >= 4)
        {
#if defined(DEVSTUDIO)  //  This needs to be a one-liner
            ERR(("Note: '%0.*s' is not a predefined member of enumeration class %s\n",
                parString->dwCount , mpubOffRef + parString->loOffset,
                gConstantsTable[dwStart - 1]));
#else
            ERR(("Note: Feature/Option name not a predefined member of enumeration class %s\n",
                    gConstantsTable[dwStart - 1]));
            ERR(("\t%0.*s\n", parString->dwCount , mpubOffRef + parString->loOffset )) ;
#endif
        }
    }
    else
    {
#if defined(DEVSTUDIO)  //  Same with this one...
        ERR(("Error: '%0.*s'- user defined Option names not permitted for enumeration class %s\n",
            parString->dwCount , mpubOffRef + parString->loOffset, gConstantsTable[dwStart - 1]));
#else
        ERR(("Error: user defined Option names not permitted for enumeration class %s\n",
                gConstantsTable[dwStart - 1]));
        ERR(("\t%0.*s\n", parString->dwCount , mpubOffRef + parString->loOffset )) ;
#endif
    }
    return(FALSE);
}



BOOL    BReadDataInGlobalNode(
    PATREEREF   patr,           // address of field in GlobalAttrib struct
    PDWORD      pdwHeapOffset,   // contents of attribute node.
    PGLOBL      pglobl
  )

/*
this function will grab the first heap offset value it
encounters from the specified attribute tree root.
If the tree is multivalued, it selects the first
option of each level.
The high bit (if set) is cleared before the value is returned.
If root is uninitialized, returns FALSE,  not an error condition
since GPD file is not required to initialize all fields.
*/

{
    PATTRIB_TREE    patt ;      // start of ATTRIBUTE tree array.
    DWORD           dwNodeIndex ;

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    if(*patr == ATTRIB_UNINITIALIZED)
        return(FALSE);

    if(*patr & ATTRIB_HEAP_VALUE)
    {
        *pdwHeapOffset = *patr & ~ATTRIB_HEAP_VALUE ;
        return(TRUE) ;
    }

    dwNodeIndex = *patr ;
    if(patt[dwNodeIndex].dwFeature == DEFAULT_INIT)
    {
        *pdwHeapOffset = patt[dwNodeIndex].dwOffset ;
        return(TRUE) ;
    }
    while(patt[dwNodeIndex].eOffsetMeans == NEXT_FEATURE)
    {
        // Down to the next level we go.
        dwNodeIndex = patt[dwNodeIndex].dwOffset ;
    }
    if(patt[dwNodeIndex].eOffsetMeans == VALUE_AT_HEAP)
    {
        *pdwHeapOffset = patt[dwNodeIndex].dwOffset ;
        return(TRUE) ;
    }
    else
        return(FALSE) ;
} // BReadDataInGlobalNode(...)


//    Following three functions
//    Added on 9/30/98 in response to bug report 225088

// BsetUQMFlag() goes through the attrib trees rooted at
// atrDraftQualitySettings, atrBetterQualitySettings, atrBestQualitySettings,
// & atrDefaultQuality and checks for a feature dependency. If found,
// it updates the UpdateQualityMacro flag for that feature to TRUE.

BOOL    BsetUQMFlag(
PGLOBL pglobl)
{
    DWORD           i;  // Loop Counter.
    PATTRIB_TREE  patt;
    ATREEREF      atrAttribRoot;
    BOOL          bStatus   = TRUE;

    PGLOBALATTRIB pga       =
                    (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;

    // List of features whose UQM flag needs to be updated.
    ATREEREF patr[] = {  pga->atrDraftQualitySettings,
                         pga->atrBetterQualitySettings,
                         pga->atrBestQualitySettings,
                         pga->atrDefaultQuality,
                      };

    DWORD dwNumAttrib = sizeof(patr)/sizeof(ATREEREF);

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;


    // for the four quality settings
    for ( i = 0; bStatus && (i < dwNumAttrib); i++)
    {
        atrAttribRoot = patr[i] ;

        // It may be possible that only some of the four settings
        // may occur. In that case, atrAttribRoot == ATTRIB_UNINITIALIZED
        // only for those that dont occur.
        if(atrAttribRoot == ATTRIB_UNINITIALIZED)
        {
            // Occurs probably  because patr[i] e.g. DraftQualityMacro keyword
            // appears no where in the .gpd. Continue and check whether other
            // patr[i] occur.
            continue;

        }

        else if (atrAttribRoot & ATTRIB_HEAP_VALUE)
        {
            // Indicates there is no dependency
            // of any feature. So we can safely
            // ignore and continue with the
            // next attribute.
            continue;
        }


        // If the above two are not true, it means atrAttribRoot points
        // to a valid node (in the attrib tree).

        // In the tree, at most
        // the first node can be the global default initializer:
        // (as stated (in treewalk.c line 351) and interpreted (from
        // state2.c  function - BaddBranchToTree (...)  ) )
        // Therefore it is safe check for this condition only once,
        // just before we start
        // recursing down the tree. No need to check once within the tree.


        // In a global default initializer!
        // it may be assumed dwOffset contains heap offset.
        // But we are concerned not with the heap value, but
        // the next Node.

        if(patt[atrAttribRoot].dwFeature == DEFAULT_INIT)
        {
            if ( patt[atrAttribRoot].dwNext == END_OF_LIST)
                continue;

            atrAttribRoot = patt[atrAttribRoot].dwNext ;  // to the next node.
        } //if


        // Walk thru the tree and retrieve the features that are children
        // of the tree rooted at atrAttribRoot.

        bStatus = BRecurseNodes(atrAttribRoot, pglobl);

    } //for

    return bStatus;
} //BsetUQMFlag


//    Recurse down the attribute tree. When we reach a feature we
//    set its UQM flag to true by calling the function BsetUQMTrue(..)
//    It is reasonable to assume that the dwFeature attribute in the
//    structure pointed to by atrAttribNode contains a valid feature ID.
//    The other special cases are handled in the previous function -
//    BsetUQMFlag()

BOOL BRecurseNodes(
    IN      ATREEREF atrAttribNode,
    IN OUT  PGLOBL pglobl
)
{
    PATTRIB_TREE patt;
    BOOL bStatus = TRUE;

    PDFEATURE_OPTIONS pfo =
        (PDFEATURE_OPTIONS) (gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct);

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    // Is it safe to assume that a new feature is encountered only
    // when we go one level down the tree.
    // Yes. Because the nodes at the same level have the SAME feature
    // but DIFFERENT options.


    // Hack. Since ColorMode is handled in a special way in the UI, the
    // Quality Macro should not be executed for Color Mode.
    if ((*(pfo + patt[atrAttribNode].dwFeature)).dwGID !=  GID_COLORMODE)
    {
        bStatus = BsetUQMTrue(patt[atrAttribNode].dwFeature, pglobl);
    }

    // Even though the trees of some gpd's (e.g. cnb5500.gpd) appear very
    // uniform (i.e. most of the branches look similar), we cannot assume it
    // to be true for all .gpd Therefore we have to go through
    // all the branches of the tree.

    for(; bStatus && atrAttribNode != END_OF_LIST;
                        atrAttribNode = patt[atrAttribNode].dwNext)
    {

        // This is what we are really interested in.
        // Check if the node has a sublevel. Yes means another feature.

        if( patt[atrAttribNode].eOffsetMeans == NEXT_FEATURE)
        {
                bStatus = BRecurseNodes(patt[atrAttribNode].dwOffset, pglobl);

        }
    } // for

    return bStatus;
} // End of function BRecurseNodes(...)



BOOL BsetUQMTrue(
    IN     DWORD   dwFeature,
    IN OUT PGLOBL  pglobl)

// For the feature dwFeature
// Set the UpdateQualityMacro Flag to true;

{

    BOOL    bStatus = TRUE;
    DWORD   dwTrue  = BT_TRUE;

    PDFEATURE_OPTIONS pfo =
        (PDFEATURE_OPTIONS) (gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct);


    PATREEREF patrAttribRoot  =  &((*(pfo + dwFeature)).atrUpdateQualityMacro);


    // The tree rooted at atrAttribRoot can either be uninitilized or
    // have a pointer to a heap value.
    // Any other case is a violation of the semantics.


    if(*patrAttribRoot == ATTRIB_UNINITIALIZED)
    {
        // Put BT_TRUE in the heap and make *patrAttribRoot point to it.
        // i.e. have *patrAttribRoot hold a dword that is an offset into
        // the heap. It is then ORed with  ATTRIB_HEAP_VALUE(which has
        // MSB set to 1). The MSB indicates that the DWORD is a
        // Heap Offset and not a ATTRIB_UNINITIALIZED, node index or any
        // other value.

        if((bStatus = BwriteToHeap((PDWORD)patrAttribRoot, (PBYTE)&dwTrue,
                        gValueToSize[VALUE_CONSTANT_BOOLEANTYPE], 4, pglobl) ) )
        {
            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
        }
        else {
            *patrAttribRoot = ATTRIB_UNINITIALIZED ;

            // The global Error variables have been set in BwriteToHeap().
        }


        return bStatus;
    } //if(*patrAttribRoot == ATTRIB_UNINITIALIZED)


    /*
      Now comes the case when the user has specified the value of
      UpdateQualityMacro to be TRUE or FALSE. If the value is TRUE
      we still overwrite it with TRUE. If FALSE, we update it according
      to the dependencies in the .gpd file.
      Since we have reached here in the program, the dependencies
      indicate that the UQM needs to be set to TRUE.
    */

    else if (*patrAttribRoot & ATTRIB_HEAP_VALUE)
    {
        // The value should be a DWORD because UpdateQualityMacro's
        // mMainKeywordTable[dwI].flAgs = 0 ;  (file framwrk1.c line 1566)
        // Therefore not checking for a list.

        PDWORD pdwValue = (PDWORD) ( (PBYTE) mpubOffRef +
                                (*patrAttribRoot & ~ATTRIB_HEAP_VALUE) );

        //Change to TRUE irrespective of its previous value.
        *pdwValue = BT_TRUE;  //Value in the heap changed to TRUE
    }

    // Since UpdateQualityMacro's
    //    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY
    //      (file framwrk1.c line 1574)
    // (i.e. it is not a free-float type), it cannot have a
    // sub-tree. So it should not point to another node.
    //
    // The following condition should never be true because UQM cannot
    // have a DEFAULT_INIT
    //      if(patt[*patrAttribRoot].dwFeature == DEFAULT_INIT)
    // Reason : It cannot form a tree (reason as explained above).
    //
    //Thus control should never reach here.
    else {
        PATTRIB_TREE patt =
                (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

        if(patt[*patrAttribRoot].dwFeature == DEFAULT_INIT) {
            ERR(("Warning: unexpected value atrUpdateQualityMacro ATREEREF\n"));
        }
        else {
            ERR(("Warning: atrUpdateQualityMacro ATREEREF points to a tree. \
                    Unexpected Condition\n"));
        }
        ERR(("Unexpected condition encountered while processing Quality Macros\n "));

        geErrorType = ERRTY_SYNTAX ;
        geErrorSev  = ERRSEV_FATAL ;
        bStatus     = FALSE;
    }

    return bStatus;
} //BsetUQMTrue(...)

//  End of 3 functions added on 9/30/98 in response to
//  bug report no. 225088





VOID    VCountPrinterDocStickyFeatures(
    PGLOBL  pglobl)
{
    PDFEATURE_OPTIONS   pfo ;
    DWORD               dwHeapOffset, dwCount, dwI ;

//  extern  MINIRAWBINARYDATA  gmrbd ;
//  Not required now as it is part of the PGLOBL structure.


    pfo     = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
    dwCount = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;

    gmrbd.rbd.dwDocumentFeatures = 0 ;
    gmrbd.rbd.dwPrinterFeatures  =
        gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize ;

    for(dwI = 0 ; dwI < dwCount ; dwI++)
    {
        if(BReadDataInGlobalNode(&pfo[dwI].atrFeatureType,
                &dwHeapOffset, pglobl)  &&
                *(PDWORD)(mpubOffRef + dwHeapOffset) == FT_PRINTERPROPERTY)
            gmrbd.rbd.dwPrinterFeatures++ ;
        else
            gmrbd.rbd.dwDocumentFeatures++ ;
    }
} // VCountPrinterDocStickyFeatures()


BOOL    BConvertSpecVersionToDWORD(
    PWSTR   pwstrFileName,
    PGLOBL  pglobl
  )
//  also used to prepend absolute path to resource Dll name.
{
    BOOL          bStatus ;
    DWORD         dwMajor, dwMinor, dwHeapOffset, dwDelim, dwDummy, dwByteCount;
    //  WCHAR         awchDLLQualifiedName[MAX_PATH];
    PWSTR         pwstrLastBackSlash, pwstrDLLName,
                  pwstrDataFileName = NULL;
    ABSARRAYREF   aarValue, aarToken ;
    PGLOBALATTRIB pga ;
    DWORD  pathlen = 0 ;
    DWORD  namelen =  0 ;
    WCHAR * pwDLLQualifiedName = NULL ;

//  extern  MINIRAWBINARYDATA  gmrbd ;
//  Not required now as it is part of the PGLOBL structure.


    pga =  (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;


    if(!BReadDataInGlobalNode(&pga->atrGPDSpecVersion ,
            &dwHeapOffset, pglobl) )
    {
        ERR(("Missing required keyword: *GPDSpecVersion.\n"));
        return(FALSE);
    }

    aarValue.dw = ((PARRAYREF)(mpubOffRef + dwHeapOffset))->dwCount ;
    aarValue.pub = mpubOffRef +
                ((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset ;

    bStatus = BdelimitToken(&aarValue, ".", &aarToken, &dwDelim)  ;

    if(bStatus)
        bStatus = BparseInteger(&aarToken, &dwMajor, VALUE_INTEGER, pglobl) ;

    if(bStatus)
        bStatus = BparseInteger(&aarValue, &dwMinor, VALUE_INTEGER, pglobl) ;

    if(bStatus)
    {
        gmrbd.dwSpecVersion = dwMajor << 16;  // place in HiWord
        gmrbd.dwSpecVersion |= dwMinor & 0xffff;  // place in LoWord
    }
    else
    {
        ERR(("BConvertSpecVersionToDWORD: syntax error in *GPDSpecVersion value. unknown version.\n"));
    }


    // -------- now to fix up the helpfile name. ------ //

    if(!BReadDataInGlobalNode(&pga->atrHelpFile ,
            &dwHeapOffset, pglobl) )
    {
        goto  FIX_RESDLLNAME;  // GPD doesn't have this keyword
    }

    pwstrDLLName = (PWSTR)(mpubOffRef +
                ((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset) ;


    //  how large should pwDLLQualifiedName be???

    pathlen = wcslen(pwstrFileName) ;
    namelen =  pathlen + wcslen(pwstrDLLName)  + 1;

    if(!(pwDLLQualifiedName = (PWSTR)MemAllocZ(namelen * sizeof(WCHAR)) ))
    {
        ERR(("Fatal: unable to alloc memory for pwDLLQualifiedName: %d WCHARs.\n",
            namelen));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        return(FALSE) ;   // This is unrecoverable
    }


    wcsncpy(pwDLLQualifiedName, pwstrFileName , namelen);

    if (pwstrLastBackSlash = wcsrchr(pwDLLQualifiedName,TEXT('\\')))
    {
        *(pwstrLastBackSlash + 1) = NUL;

        //Find a BackSlash in the Source DLL Name.
        pwstrDataFileName = wcsrchr( pwstrDLLName, TEXT('\\') );

        //Increment the pointer to first char of the DLL Name.
        if (pwstrDataFileName)
            pwstrDataFileName++;
        else
            pwstrDataFileName = pwstrDLLName;

        // wcscat(pwDLLQualifiedName, pwstrDataFileName) ;
        StringCchCatW(pwDLLQualifiedName, namelen, pwstrDataFileName);

        ((PARRAYREF)(mpubOffRef + dwHeapOffset))->dwCount =
                dwByteCount =
                wcslen(pwDLLQualifiedName) * sizeof(WCHAR) ;


        if(BwriteToHeap(&((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset,
            //  Store heap offset of dest string here.
                (PBYTE) pwDLLQualifiedName, dwByteCount, 2, pglobl) )
        {
            // add NUL terminator.
            BwriteToHeap(&dwDummy, "\0\0", 2, 1, pglobl) ;
            goto  FIX_RESDLLNAME;
        }

        bStatus = FALSE ;
    }




    // -------- now to fix up the resource Dll name. ------ //

FIX_RESDLLNAME:

    if(pwDLLQualifiedName)
        MemFree(pwDLLQualifiedName) ;

#if 0     //  fix for bug 34042
    if(!BReadDataInGlobalNode(&pga->atrResourceDLL ,
            &dwHeapOffset, pglobl) )
    {
        //  return(bStatus);  // GPD doesn't have this keyword
        //   create a dummy filename!

        PATREEREF   patr ;
        ARRAYREF    arDummyName ;

        arDummyName.dwCount =  wcslen(TEXT("No_Res")) * sizeof(WCHAR) ;
        if(!BwriteToHeap(&arDummyName.loOffset,
               (PBYTE)TEXT("No_Res\0"), arDummyName.dwCount + sizeof(WCHAR), 2, pglobl) )
                //   note:  add null terminator or strcat will derail.
        {
              bStatus = FALSE ;  // heap overflow start over.
        }

        patr  = &pga->atrResourceDLL ;
        if(!BwriteToHeap(patr,  (PBYTE)(&arDummyName) , sizeof(ARRAYREF), 4, pglobl) )
        {
              bStatus = FALSE ;  // heap overflow start over.
        }
        dwHeapOffset = *patr ;
        *patr  |= ATTRIB_HEAP_VALUE ;
    }
//  #if 0  move this to new location 25 lines up.   fix for bug 34042
    //   ganesh's winres lib will take care of prepending fully qualified path...

    pwstrDLLName = (PWSTR)(mpubOffRef +
                ((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset) ;


    wcsncpy(awchDLLQualifiedName, pwstrFileName , MAX_PATH -1);

    if (pwstrLastBackSlash = wcsrchr(awchDLLQualifiedName,TEXT('\\')))
    {
        *(pwstrLastBackSlash + 1) = NUL;

        //Find a BackSlash in the Source DLL Name.
        pwstrDataFileName = wcsrchr( pwstrDLLName, TEXT('\\') );

        //Increment the pointer to first char of the DLL Name.
        if (pwstrDataFileName)
            pwstrDataFileName++;
        else
            pwstrDataFileName = pwstrDLLName;

        wcscat(awchDLLQualifiedName, pwstrDataFileName) ;

        ((PARRAYREF)(mpubOffRef + dwHeapOffset))->dwCount =
                dwByteCount =
                wcslen(awchDLLQualifiedName) * sizeof(WCHAR) ;


        if(BwriteToHeap(&((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset,
            //  Store heap offset of dest string here.
                (PBYTE) awchDLLQualifiedName, dwByteCount, 2, pglobl) )
        {
            // add NUL terminator.
            BwriteToHeap(&dwDummy, "\0\0", 2, 1, pglobl) ;
            return(bStatus) ;
        }

        return(FALSE) ;
    }
#endif
    return(bStatus) ;
} // BConvertSpecVersionToDWORD(...)


BOOL   BinitMiniRawBinaryData(
    PGLOBL  pglobl)
{
    gmrbd.rbd.dwParserSignature = GPD_PARSER_SIGNATURE ;
    gmrbd.rbd.dwParserVersion   = GPD_PARSER_VERSION ;
    gmrbd.rbd.pvReserved        = NULL;
    return(TRUE) ;
} //BinitMiniRawBinaryData()


BOOL    BexchangeArbDataInFOATNode(
        DWORD   dwFeature,
        DWORD   dwOption,
        DWORD   dwFieldOff,     // offset of field in FeatureOption struct
        DWORD   dwCount,        //  number bytes to copy.
    OUT PBYTE   pubOut,         // previous contents of attribute node
    IN  PBYTE   pubIn,          // new contents of attribute node.
        PBOOL   pbPrevsExists,  // previous contents existed.
        BOOL    bSynthetic,      //  access synthetic features
        PGLOBL  pglobl
)
/*
  'FOAT'  means  FeatureOption AttributeTree.
  this function writes or overwrites the byte string specified by
  pubIn into the heap at the location indicated by the attribute tree
  HeapOffset field.  The previous contents at HeapOffset is saved to
  pubOut and pbPrevsExists is set to TRUE.  If pubIn is NULL,
  the current attribute tree is not altered.

  The parameters dwFeature, dwOption, dwFieldOffset specify
  the structure, field, and branch of the attribute tree.
  If the specified option branch does not exist, one will be created,
  pubOut may be set to NULL if the previous content is unimportant.
Assumptions:
  The tree being accessed is strictly one level deep.  That is the
  node is fully specified by just Feature, Option.  No default initializers.
*/
{
    PATTRIB_TREE  patt ;    // start of ATTRIBUTE tree array.
    PATREEREF     patr ;
    ATREEREF      atrCur ;  // contains index of currently  used attribute node.

    DWORD         dwFeaOffset ;  // Start numbering features from this
                                 // starting point.  This gives synthetic
                                 // features a separate non-overlapping number
                                 // space from normal features.

    PDFEATURE_OPTIONS   pfo ;


    if(bSynthetic)
    {
        pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_SYNTHESIZED_FEATURES].pubStruct +
            dwFeature  ;
        dwFeaOffset = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;
    }
    else
    {
        pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct +
            dwFeature ;
        dwFeaOffset = 0 ;
    }

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    patr = (PATREEREF)((PBYTE)pfo + dwFieldOff) ;
    atrCur = *patr ;

    if(atrCur == ATTRIB_UNINITIALIZED)
    {
        if(pubIn)
        {
            if(!BcreateEndNode(patr, dwFeature + dwFeaOffset , dwOption, pglobl) )
                return(FALSE) ;  // resource exhaustion
            if(!BwriteToHeap(&(patt[*patr].dwOffset), pubIn,
                                                    dwCount, 4, pglobl) )
                return(FALSE) ;  // A fatal error.
            patt[*patr].eOffsetMeans = VALUE_AT_HEAP ;
        }
        *pbPrevsExists = FALSE ;
        return(TRUE) ;
    }

    if(atrCur & ATTRIB_HEAP_VALUE)
    {
        ERR(("Internal error.  BexchangeArbDataInFOATNode should never create a branchless node.\n"));
        return(FALSE) ;
    }

    // offset field contains index to another node
    // but we will tack the new node (if any) after
    // the existing node.  Don't change patr.

    if(pubIn)
    {
        if(!BfindOrCreateMatchingNode(atrCur, &atrCur, dwFeature + dwFeaOffset , dwOption, pglobl))
            return(FALSE) ;  // Tree inconsistency error or resource exhaustion

        if(patt[atrCur].eOffsetMeans != VALUE_AT_HEAP)
        {
            //  just created a new node.
            if(!BwriteToHeap(&(patt[atrCur].dwOffset), pubIn, dwCount, 4, pglobl) )
                return(FALSE) ;  // A fatal error.
            patt[atrCur].eOffsetMeans = VALUE_AT_HEAP ;
            *pbPrevsExists = FALSE ;
            return(TRUE) ;
        }

        if(pubOut)
            memcpy(pubOut, mpubOffRef + patt[atrCur].dwOffset, dwCount) ;
        memcpy(mpubOffRef + patt[atrCur].dwOffset, pubIn, dwCount) ;
    }
    else
    {
        if(!BfindMatchingNode(atrCur, &atrCur, dwFeature + dwFeaOffset , dwOption, pglobl))
        {
            *pbPrevsExists = FALSE ;  // nothing found, don't create.
            return(TRUE) ;
        }
        if(pubOut)
            memcpy(pubOut, mpubOffRef + patt[atrCur].dwOffset, dwCount) ;
    }
    *pbPrevsExists = TRUE ;
    return(TRUE) ;
} // BexchangeArbDataInFOATNode(...)




typedef  struct
{
    DWORD   dwUserPriority ;
    DWORD   dwNext ;  // index of feature with a equal or greater
                      //  numerical value for dwUserPriority .
}  PRIORITY_NODE, *PPRIORITY_NODE ;     // the prefix tag shall be 'pn'


BOOL    BInitPriorityArray(
    PGLOBL pglobl)
{

    DWORD   dwNumFea, dwFea, dwPrnStickyroot, dwDocStickyroot,
            dwPrevsNode, dwCurNode, dwNumSyn, dwIndex, dwHeapOffset,
            adwDefaultPriority[MAX_GID];
    PDWORD  pdwRoot, pdwPriority  ;

    PDFEATURE_OPTIONS   pfo ;
    PPRIORITY_NODE      pnPri ;
    BOOL                bPrinterSticky ;



    // init  adwDefaultPriority[], the default priorities
    // are very low compared to any value a user may
    // explicitly assign.
    // The last term is the priority starting from 0 = highest.

    for(dwIndex = 0 ; dwIndex < MAX_GID ; dwIndex++)
    {
        adwDefaultPriority[dwIndex] =  0xffffffff ;    // default if not enum below.
    }

    adwDefaultPriority[GID_PAGESIZE]    =  0xffffffff -  MAX_GID + 0 ;
    adwDefaultPriority[GID_INPUTSLOT]   =  0xffffffff -  MAX_GID + 1 ;
    adwDefaultPriority[GID_ORIENTATION] =  0xffffffff -  MAX_GID + 2 ;
    adwDefaultPriority[GID_COLORMODE]   =  0xffffffff -  MAX_GID + 3 ;
    adwDefaultPriority[GID_DUPLEX]      =  0xffffffff -  MAX_GID + 4 ;
    adwDefaultPriority[GID_MEDIATYPE]   =  0xffffffff -  MAX_GID + 5 ;
    adwDefaultPriority[GID_RESOLUTION]  =  0xffffffff -  MAX_GID + 6 ;
    adwDefaultPriority[GID_HALFTONING]  =  0xffffffff -  MAX_GID + 7 ;

    dwPrnStickyroot = dwDocStickyroot = INVALID_INDEX ;

    pfo      = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct;
    dwNumFea = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;

    if(!(pnPri = MemAllocZ(dwNumFea * sizeof(PRIORITY_NODE)) ))
    {
        ERR(("Fatal: BInitPriorityArray - unable to alloc %d bytes.\n",
            dwNumFea * sizeof(PRIORITY_NODE)));

        geErrorType       = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev        = ERRSEV_FATAL ;
        gdwMasterTabIndex = 0xffff ;

        return(FALSE) ;   // This is unrecoverable
    }

    for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
    {
        if(BReadDataInGlobalNode(&pfo[dwFea].atrFeatureType , &dwHeapOffset, pglobl)
          &&  *(PDWORD)(mpubOffRef + dwHeapOffset) == FT_PRINTERPROPERTY)
            bPrinterSticky = TRUE ;
        else
            bPrinterSticky = FALSE ;

        if(BReadDataInGlobalNode(&pfo[dwFea].atrPriority , &dwHeapOffset, pglobl))
        {
            pnPri[dwFea].dwUserPriority =
                *(PDWORD)(mpubOffRef + dwHeapOffset) ;
        }
        else
        {
            pnPri[dwFea].dwUserPriority = 0xffffffff;   // lowest priority
            if(pfo[dwFea].dwGID != GID_UNKNOWN)
            {
                pnPri[dwFea].dwUserPriority = adwDefaultPriority[pfo[dwFea].dwGID] ;
            }
        }

        pdwRoot = (bPrinterSticky ) ? &dwPrnStickyroot : &dwDocStickyroot ;

        dwCurNode   = *pdwRoot ;
        dwPrevsNode = INVALID_INDEX ;
        while(dwCurNode !=  INVALID_INDEX)
        {
            if(pnPri[dwFea].dwUserPriority  <= pnPri[dwCurNode].dwUserPriority)
                break ;
            dwPrevsNode  = dwCurNode ;
            dwCurNode = pnPri[dwCurNode].dwNext ;
        }

        if(dwPrevsNode == INVALID_INDEX)
            *pdwRoot = dwFea ;  //  first on the list.
        else
            pnPri[dwPrevsNode].dwNext = dwFea ;

        pnPri[dwFea].dwNext = dwCurNode ;
    }

    //  pdwPriority  array holds index of all features
    //  including synthesized - which are assigned indicies
    //  dwFea >= dwNumFea.  The feature indicies are ordered
    //  with the highest priority feature index occupying
    //  pdwPriority[0].

    dwNumSyn = gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize ;

    pdwPriority = (PDWORD)gMasterTable[MTI_PRIORITYARRAY].pubStruct ;

    for(dwIndex = 0 ; dwIndex < dwNumSyn  ; dwIndex++)
    {
        pdwPriority[dwIndex] = dwIndex + dwNumFea ;
        //  take all synthesized features and assign them
        //  the highest pri.
    }

    for(dwCurNode = dwPrnStickyroot ; dwCurNode != INVALID_INDEX ;
            dwIndex++ )
    {
        pdwPriority[dwIndex] = dwCurNode ;
        dwCurNode = pnPri[dwCurNode].dwNext ;
    }

    for(dwCurNode = dwDocStickyroot  ; dwCurNode != INVALID_INDEX ;
            dwIndex++ )
    {
        pdwPriority[dwIndex] = dwCurNode ;
        dwCurNode = pnPri[dwCurNode].dwNext ;
    }

    ASSERT(dwIndex == gMasterTable[MTI_PRIORITYARRAY].dwArraySize) ;

    MemFree(pnPri) ;
    return(TRUE);

} //BInitPriorityArray ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\shortcut.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  shortcut.c - functions that expand shortcuts  */


#include    "gpdparse.h"



// ----  functions defined in  shortcut.c ---- //


BOOL    BInitKeywordField(
PTKMAP  pNewtkmap,
PGLOBL  pglobl) ;

BOOL    BExpandMemConfig(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BExpandCommand(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL  BexpandShortcuts(
PGLOBL  pglobl) ;


BOOL  BSsyncTokenMap(
PTKMAP   ptkmap,
PTKMAP   pNewtkmap,
PGLOBL  pglobl) ;


// ---------------------------------------------------- //


BOOL    BInitKeywordField(
PTKMAP  pNewtkmap,
PGLOBL  pglobl)
/*  all synthesized entries must have aarKeyword initialized
    via mainkeyword table since ERR code may want to print
    it out if a parsing error occurs further downstream.  */
{
    ABSARRAYREF    aarKeywordName ;
    DWORD   dwKeyID ;

    dwKeyID = pNewtkmap->dwKeywordID ;

    aarKeywordName.pub = mMainKeywordTable[dwKeyID].pstrKeyword ;
    aarKeywordName.dw = strlen(aarKeywordName.pub) ;


    pNewtkmap->aarKeyword.dw = 0 ;  // copy mode

    if(!BCatToTmpHeap( &pNewtkmap->aarKeyword,
            &aarKeywordName, pglobl) )
    {
        vIdentifySource(pNewtkmap, pglobl) ;
        ERR(("Internal error - unable to store keyword name.\n"));
        return(FALSE) ;
    }
    return(TRUE) ;
}


BOOL    BExpandMemConfig(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*   this function is pretty lax about syntax checking.
    It just assumes the existence of some non trivial string
    between open parent  and a comma.  It assumes this is the
    amount of installed memory.   The value parser will rigorously
    determine if the syntax is conforming.
*/
{
    DWORD   dwNewTKMindex, dwDelim ;
    BOOL    bMB = FALSE ;  //  KB otherwise
    ABSARRAYREF    aarTmpValue, aarToken, aarNewValue, aarUnits, aarDQuote;

    aarUnits.pub = "KB" ;  // hardcode strings
    aarUnits.dw = 2 ;
    aarDQuote.pub = "\"" ;
    aarDQuote.dw = 1 ;

    if(ptkmap[dwTKMindex].dwKeywordID == gdwMemConfigMB)
    {
        aarUnits.pub = "MB" ;
        bMB = TRUE ;
    }

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }

    //  parse out the amount of installed memory

    aarTmpValue = ptkmap[dwTKMindex].aarValue ;
    if(!BdelimitToken(&aarTmpValue, "(", &aarToken, &dwDelim ) ||
        dwDelim  ||
        !BdelimitToken(&aarTmpValue, ",", &aarToken, &dwDelim ) ||
        dwDelim  ||  !BeatSurroundingWhiteSpaces(&aarToken) )
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Syntax error in value of *MemConfig shortcut: %0.*s.\n",
            ptkmap[dwTKMindex].aarValue.dw ,
            ptkmap[dwTKMindex].aarValue.pub   ));
        return(FALSE);
    }

    aarNewValue.dw = 0 ;  // initialize so BCatToTmpHeap
                            //  will overwrite instead of append

    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwOptionConstruct ;


    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl)  ||
        !BCatToTmpHeap(&aarNewValue, &aarToken, pglobl) ||
        !BCatToTmpHeap(&aarNewValue, &aarUnits, pglobl))
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Concatenation to synthesize Memory option name failed.\n"));
        return(FALSE) ;
    }

    pNewtkmap[dwNewTKMindex].aarValue = aarNewValue ;
    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    //  --  synthesize entry for open brace

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwOpenBraceConstruct ;
    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;

    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);
    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;




    //  --  synthesize *Name entry

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwOptionName ;

    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;   // initialize so
                      //  BCatToTmpHeap will overwrite instead of append
    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl)  ||
        !BCatToTmpHeap(&pNewtkmap[dwNewTKMindex].aarValue, &aarDQuote, pglobl) ||
        !BCatToTmpHeap(&pNewtkmap[dwNewTKMindex].aarValue, &aarNewValue, pglobl) ||
        !BCatToTmpHeap(&pNewtkmap[dwNewTKMindex].aarValue, &aarDQuote, pglobl) )
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Concatenation to synthesize Memory option name failed.\n"));
        return(FALSE) ;
    }
    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    //  --  synthesize *MemoryConfigX entry

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID =
        (bMB) ? gdwMemoryConfigMB : gdwMemoryConfigKB ;

    pNewtkmap[dwNewTKMindex].aarValue = ptkmap[dwTKMindex].aarValue ;

    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    //  --  synthesize entry for close brace

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwCloseBraceConstruct ;
    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;
    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    return(TRUE) ;
}




BOOL    BExpandCommand(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*   this function is pretty lax about syntax checking.
    It just assumes the existence of some non trivial string
    between the two colons.  It assumes this is the
    name of the command. The portion after the 2nd colon is
    the actual command invocation.  The value parser will rigorously
    determine if the syntax is conforming.
*/
{
    DWORD   dwNewTKMindex, dwDelim ;
    ABSARRAYREF    aarTmpValue, aarToken, aarNewValue, aarUnits ;


    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }

    pNewtkmap[dwNewTKMindex] = ptkmap[dwTKMindex] ;
    //  parse out the command name

    aarTmpValue = ptkmap[dwTKMindex].aarValue ;
    if(!BdelimitToken(&aarTmpValue, ":", &aarToken, &dwDelim ) ||
        dwDelim  )
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Syntax error in *Command shortcut: %0.*s.\n",
            ptkmap[dwTKMindex].aarValue.dw ,
            ptkmap[dwTKMindex].aarValue.pub   ));
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].aarValue = aarToken ;



    //  --  synthesize entry for open brace

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwOpenBraceConstruct ;
    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;
    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;


    //  --  synthesize *Cmd entry

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwCommandCmd ;

    pNewtkmap[dwNewTKMindex].aarValue = aarTmpValue ;

    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;


    //  --  synthesize entry for close brace

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwCloseBraceConstruct ;
    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;
    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    return(TRUE) ;
}




BOOL  BexpandShortcuts(
PGLOBL  pglobl)
//    this function scans through the TokenMap
//    making a copy to NewTokenMap without
//    the shortcuts.  At the end transfers
//  all NewTokenMap entries back to TokenMap so
//  subsequent passes can work.
//    This function assumes the temp heap is availible for
//    storage of strings.
{
    PTKMAP   ptkmap, pNewtkmap ;   // start of tokenmap
    DWORD   dwNewTKMindex, dwEntry, dwKeywordID ;
    BOOL    bStatus = TRUE ;

    //  this function is called before resolveMacros.
    //  it will leave the result on ptkmap.

    //  source
    ptkmap = (PTKMAP)gMasterTable[MTI_TOKENMAP].pubStruct ;
    //  dest
    pNewtkmap = (PTKMAP)gMasterTable[MTI_NEWTOKENMAP].pubStruct  ;

    for(dwEntry = 0 ; geErrorSev < ERRSEV_RESTART ; dwEntry++)
    {
        //  These ID's must be processed separately
        //  because they do not index into the mainKeyword table.
        //  The code for generic ID's will fail.

        dwKeywordID = ptkmap[dwEntry].dwKeywordID ;


        if (dwKeywordID == gdwID_IgnoreBlock)
        {
            VIgnoreBlock(ptkmap + dwEntry, TRUE, pglobl) ;
            continue ;
        }
        if (dwKeywordID == ID_EOF)
        {

            //  transfer all tokenmap fields to newTokenMap
            if(!BallocElementFromMasterTable(
                    MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
            {
                geErrorSev = ERRSEV_RESTART ;
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                return(FALSE);
            }
            pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;
            //  must reset tokenmap so it can be reused.
            gMasterTable[MTI_TOKENMAP].dwCurIndex = 0 ;

            if(bStatus)
                bStatus = BSsyncTokenMap(ptkmap, pNewtkmap , pglobl) ;

            return(bStatus) ;
        }
        if (dwKeywordID == ID_NULLENTRY)
        {
            continue ;  //  skip to next entry.
        }
        else if (dwKeywordID == gdwMemConfigMB  ||
                dwKeywordID == gdwMemConfigKB)
        {
            if(!BExpandMemConfig(ptkmap, pNewtkmap, dwEntry, pglobl))
                return(FALSE);
        }
        else if (dwKeywordID == gdwCommandConstruct  &&
            ptkmap[dwEntry].dwFlags & TKMF_COLON)
        {
            if(!BExpandCommand(ptkmap, pNewtkmap, dwEntry, pglobl))
                return(FALSE);
        }
        else
        {
            //  transfer all tokenmap fields to newTokenMap
            if(!BallocElementFromMasterTable(
                    MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
            {
                geErrorSev = ERRSEV_RESTART ;
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                return(FALSE);
            }
            pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;

        }
    }
    return(FALSE);  // failsafe derail.
}



BOOL  BSsyncTokenMap(
PTKMAP   ptkmap,
PTKMAP   pNewtkmap,
PGLOBL   pglobl )
{
    DWORD   dwTKMindex, dwEntry, dwKeywordID ;

    for(dwEntry = 0 ; geErrorSev < ERRSEV_RESTART ; dwEntry++)
    {
        //  transfer all newTokenMap fields back to tokenmap
        if(!BallocElementFromMasterTable(
                MTI_TOKENMAP, &dwTKMindex, pglobl) )
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_TOKENMAP ;
            return(FALSE);  // failsafe derail.
        }
        ptkmap[dwTKMindex] = pNewtkmap[dwEntry]  ;
        if (pNewtkmap[dwEntry].dwKeywordID == ID_EOF)
        {
            gMasterTable[MTI_NEWTOKENMAP].dwCurIndex = 0 ;
            return(TRUE) ;
        }
    }
    return(FALSE);  // failsafe derail.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\snapshot.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  snapshot.c - functions to produce a snapshot from
the multivalued GPD binary data.

History of Changes
 10/28/98 --hsingh--
         Added functions BgetLocFeaIndex() and BgetLocFeaOptIndex()
         to support special processing for Feauture Locale if present
         in the gpd.
         Bug Report 231798
*/




#include    "gpdparse.h"


#ifndef  PARSERDLL



// ----  functions defined in snapshot.c ---- //

PINFOHEADER   PINFOHDRcreateSnapshot(
PBYTE   pubnRaw,  //  raw binary data.    PSTATIC.   BETA2
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL  BinitOptionFields(
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,  // option extra structure if any.
PBYTE   pubnRaw,  //  raw binary data.
DWORD   dwFea,
DWORD   dwOpt,
POPTSELECT   poptsel ,  // assume fully initialized
PINFOHEADER  pInfoHdr,   // used to access global structure.
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitUIinfo(
PUIINFO     pUIinfo ,
PBYTE   pubnRaw,  //  PSTATIC.   BETA2
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitFeatures(
PFEATURE    pFeaturesDest,
PDFEATURE_OPTIONS  pfoSrc,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitGlobals(
PGLOBALS pGlobals,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitCommandTable(
PDWORD  pdwCmdTable,  //  dest array
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BinitRawData(
PRAWBINARYDATA   pRawData, // contained in INFOHEADER.
PBYTE   pubnRaw  //  Parser's raw binary data.
) ;

BOOL    BinitGPDdriverInfo(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BinitSequencedCmds(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BaddSequencedCmdToList(
DWORD   dwCmdIn,  // index of a command in CommandArray
PGPDDRIVERINFO  pGPDdriverInfo,
DWORD   dwNewListNode,  //  an unused listnode to add to the list.
PBYTE   pubnRaw  //  raw binary data.
) ;

BinitDefaultOptionArray(
POPTSELECT   poptsel,   // assume is large enough
PBYTE   pubnRaw) ;

TRISTATUS     EdetermineDefaultOption(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwFeature,   // determine the default for this feature
PDFEATURE_OPTIONS  pfo,
POPTSELECT   poptsel,   // assume is large enough
PDWORD      pdwPriority) ;

VOID    VtileDefault(
PBYTE   pubDest,
DWORD   dwDefault,
DWORD   dwBytes) ;

VOID    VtransferValue(
OUT PBYTE   pubDest,
IN  PBYTE   pubSrc ,
IN  DWORD   dwBytes,
IN  DWORD   dwFlags,
IN  DWORD   dwDefaultValue,  // holds bit flag value.
IN  PBYTE   pubHeap ) ;  //  used to form ptr if SSF_MAKE_STRINGPTR

BOOL    BspecialProcessOption(
PBYTE   pubnRaw,  // start of Rawbinary data
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,
PDFEATURE_OPTIONS  pfo ,  // source data
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.
PINFOHEADER  pInfoHdr,   // used to access global structure.
DWORD   dwFea,   //  feature index
DWORD   dwOpt,
BOOL   bDefaultOpt
) ;

TRISTATUS     EextractValueFromTree(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwSSTableIndex,  // some info about this value.
OUT PBYTE    pubDest,  // write value or link here
OUT PDWORD  pdwUnresolvedFeature,  // if the attribute tree has
            //  a dependency on this feature and the current option
            //  for that feature is not defined  in poptsel, this
            //  function will write the index of the required
            //  feature in pdwUnresolvedFeature.
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.  may be filled with OPTION_INDEX_ANY
                //  if we are jumpstarting
IN  DWORD   dwFeature,
IN OUT  PDWORD   pdwNextOpt  //  if multiple options are selected
    //  for dwFeature, pdwNextOpt points to the Nth option to consider
    //  in the  poptsel list,  at return time, this value
    //  is incremented if there are remaining options selected,
    //  else is reset to zero.
    //  For the first call, or PICKONE features,
    //  this value must be set to zero.
) ;

BOOL   RaisePriority(
DWORD   dwFeature1,
DWORD   dwFeature2,
PBYTE   pubnRaw,
PDWORD  pdwPriority) ;

DWORD  dwNumOptionSelected(
IN  DWORD  dwNumFeatures,
IN  POPTSELECT       poptsel
) ;

BOOL  BinitSnapShotIndexTable(PBYTE  pubnRaw) ;

BOOL    BinitSizeOptionTables(PBYTE  pubnRaw) ;

PRAWBINARYDATA
LoadRawBinaryData (
    IN PTSTR    ptstrDataFilename
    ) ;

PRAWBINARYDATA
GpdLoadCachedBinaryData(
    PTSTR   ptstrGpdFilename
    ) ;

VOID
UnloadRawBinaryData (
    IN PRAWBINARYDATA   pnRawData
) ;

PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pnRawData,        // actually pStatic
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    ) ;

VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    ) ;

BOOL    BIsRawBinaryDataInDate(
IN  PBYTE   pubRaw) ;  // this is pointer to memory mapped file! BETA2

BOOL BgetLocFeaIndex(
  IN  PRAWBINARYDATA pnRawData,     // raw binary data.
  OUT PDWORD         pdwFea     // Index of the Locale Feature (if present)
  ) ;

BOOL BgetLocFeaOptIndex(
    IN     PRAWBINARYDATA   pnRawData,
       OUT PDWORD           pdwFea,
       OUT PDWORD           pdwOptIndex
    );


#endif  PARSERDLL



BOOL   BfindMatchingOrDefaultNode(
IN  PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
IN  OUT  PDWORD  pdwNodeIndex,  // Points to first node in chain
IN  DWORD   dwOptionID     //  may even take on the value DEFAULT_INIT
) ;


// ------- end function declarations ------- //


#ifndef  PARSERDLL


/*  ---- Memory Map ---- /*


INFOHEADER {RAWBINARYDATA}  <= reference pt for local offsets.
UIINFO
GPDDRIVERINFO  (aka DRIVERINFO)
CMD_TABLE    of DWORDS
LOCALLIST (to support sequenced commands)
FEATURES
OPTIONS and OPTIONEXTRAS


/*  ---- end Memory Map ---- */



PINFOHEADER   PINFOHDRcreateSnapshot(
PBYTE   pubnRaw,  //  raw binary data.    PSTATIC.   BETA2
POPTSELECT   poptsel   // assume fully initialized
)
/*  this function allocates the single memoryblock
that contains the entire snapshot.  */
{
    DWORD   dwCurOffset = 0, loGPDdriverInfo, loInfoHeader,
        loUIinfo, loCmdTable, loListArray, loFeatures, dwSize,
        dwNumFeatures, dwNumListNodes, dwTotSize, loOptions,
        dwSizeOption, dwSizeOptionEx, dwFea, dwGID , dwNumOptions,
        dwI , dwCmd;
    PDWORD   pdwSymbolRoots  ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PINFOHEADER  pInfoHdr ;
    PUIINFO     pUIinfo ;
    PSTATICFIELDS   pStatic ;
    //  PMINIRAWBINARYDATA pmrbd  = NULL ;
    PGPDDRIVERINFO  pGPDdriverInfo ;
    PBYTE   pubRaw,  //  ptr to BUD data.
            pubOptionsDest ,  // ptr to any of the several varieties
           pubDestOptionEx ;  // of option structures.
    BOOL    bStatus ;
    PFEATURE    pFeaturesDest ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    loInfoHeader = dwCurOffset ;
    dwCurOffset += sizeof(INFOHEADER) ;
    loUIinfo = dwCurOffset ;
    dwCurOffset += sizeof(UIINFO) ;
    loGPDdriverInfo = dwCurOffset ;
    dwCurOffset += sizeof(GPDDRIVERINFO) ;
    loCmdTable = dwCurOffset ;
    dwCurOffset += sizeof(DWORD) * CMD_MAX ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    dwNumListNodes = dwNumOptionSelected(dwNumFeatures, poptsel) ;
    // if there are pickmany, we could have more than dwNumFeatures.

    dwNumListNodes += NUM_CONFIGURATION_CMDS ;

    loListArray = dwCurOffset ;
    dwCurOffset += dwNumListNodes * sizeof(LISTNODE) ;

    loFeatures = dwCurOffset ;
    dwCurOffset += dwNumFeatures * sizeof(FEATURE) ;

    loOptions =  dwCurOffset ;
    //  There are too many options and optionextra structures
    //  for me to track all the offsets, so just track the
    //  amount of memory consumed.

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;

//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    for(dwTotSize = dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwGID = pfo[dwFea].dwGID ;
        dwNumOptions = pfo[dwFea].dwNumOptions ;

        if(dwGID != GID_UNKNOWN)
        {
            dwSize = pStatic->pdwSizeOption[dwGID] +
                    pStatic->pdwSizeOptionEx[dwGID] ;
        }
        else
        {
            dwSize = sizeof(OPTION);
        }

        dwTotSize += dwSize * dwNumOptions ;  // of all options
    }
    dwCurOffset += dwTotSize ;  // total size of local snapshot.

    //  now allocate memory and partition this block into structures.

    if(!(pInfoHdr = (PINFOHEADER)MemAllocZ(dwCurOffset) ))
    {
        ERR(("Fatal: PINFOHDRcreateSnapshot - unable to alloc %d bytes.\n",
            dwCurOffset));
        //  cannot use globals outside of parser.
        //  use error num to relay failure.
        return(NULL) ;   // This is unrecoverable
    }
    pUIinfo = (PUIINFO)((PBYTE)(pInfoHdr) + loUIinfo) ;
    pGPDdriverInfo = (PGPDDRIVERINFO)((PBYTE)(pInfoHdr) + loGPDdriverInfo) ;


    if(!BinitCommandTable((PDWORD)((PBYTE)(pInfoHdr) + loCmdTable),
        pubnRaw, poptsel) )
    {
        MemFree(pInfoHdr) ;
        return(NULL) ;
    }

    // init GPDDRIVERINFO
    // note all offsets in DataTable are relative to pubResourceData
    //  the StringHeap.  Except these :

    pGPDdriverInfo->pInfoHeader =  pInfoHdr ;
    pGPDdriverInfo->DataType[DT_COMMANDTABLE].loOffset = loCmdTable ;
    pGPDdriverInfo->DataType[DT_COMMANDTABLE].dwCount =  CMD_MAX ;
    pGPDdriverInfo->DataType[DT_LOCALLISTNODE].loOffset =  loListArray ;
    pGPDdriverInfo->DataType[DT_LOCALLISTNODE].dwCount =  dwNumListNodes ;


    if(!BinitGPDdriverInfo(pGPDdriverInfo, pubnRaw, poptsel) )
    {
        MemFree(pInfoHdr) ;
        return(NULL) ;
    }

    //  init  InfoHeader

    pInfoHdr->loUIInfoOffset = loUIinfo ;
    pInfoHdr->loDriverOffset = loGPDdriverInfo ;

    if(!BinitRawData(&pInfoHdr->RawData, pubnRaw) )
    {
        MemFree(pInfoHdr) ;
        return(NULL) ;
    }

    //  init  UIInfo

    pUIinfo->pInfoHeader = pInfoHdr ;
    pUIinfo->loFeatureList = loFeatures ;  // from  pInfoHdr
    pUIinfo->loFontSubstTable =
        pGPDdriverInfo->DataType[DT_FONTSUBST].loOffset ;  // in pubRaw
    pUIinfo->dwFontSubCount =
        pGPDdriverInfo->DataType[DT_FONTSUBST].dwCount ;
    pUIinfo->UIGroups.dwCount = 0 ;  // in pubRaw
    pUIinfo->CartridgeSlot.loOffset =  // in pubRaw
        pGPDdriverInfo->DataType[DT_FONTSCART].loOffset ;
    pUIinfo->CartridgeSlot.dwCount =
        pGPDdriverInfo->DataType[DT_FONTSCART].dwCount ;
//    pUIinfo->dwFlags =  FLAG_RULESABLE ;
        // start with just this
        // and turn on/off more flags as needed.  ROTATE_90
        // and  ORIENT_SUPPORT are never  set.  This is now obsolete.
    if(pGPDdriverInfo->Globals.fontformat != UNUSED_ITEM)
        pUIinfo->dwFlags |= FLAG_FONT_DOWNLOADABLE ;
    if(pGPDdriverInfo->Globals.liDeviceFontList != END_OF_LIST)
        pUIinfo->dwFlags |= FLAG_FONT_DEVICE ;

#if 0
    Alvins code never looks at this flag anyway.
    for(dwCmd = CMD_FIRST_RULES ; dwCmd < CMD_LAST_RULES + 1 ; dwCmd++ )
    {
        if( ((PDWORD)((PBYTE)(pInfoHdr) + loCmdTable))[dwCmd] ==
                UNUSED_ITEM)
            pUIinfo->dwFlags &= ~FLAG_RULESABLE ; // clear flag
    }                       //  if requisite command is missing.
#endif


    if(!BinitUIinfo(pUIinfo, pubnRaw, poptsel, FALSE) )
    {
        MemFree(pInfoHdr) ;
        return(NULL) ;
    }

    //  init  features and options

    pFeaturesDest =  (PFEATURE)((PBYTE)(pInfoHdr) + loFeatures) ;

    for( dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwGID = pfo[dwFea].dwGID ;
        dwNumOptions = pfo[dwFea].dwNumOptions ;


        pFeaturesDest[dwFea].Options.loOffset = loOptions ;
        pFeaturesDest[dwFea].Options.dwCount = dwNumOptions ;

        if(!BinitFeatures(pFeaturesDest + dwFea, pfo + dwFea,
                            pubnRaw, poptsel, FALSE))
        {
            MemFree(pInfoHdr) ;
            return(NULL) ;
        }

        if(dwGID != GID_UNKNOWN)
        {
            dwSizeOption = pStatic->pdwSizeOption[dwGID] ;
            dwSizeOptionEx = pStatic->pdwSizeOptionEx[dwGID] ;

            pUIinfo->aloPredefinedFeatures[dwGID] =
                loFeatures + dwFea * sizeof(FEATURE) ;
                // all fields initially set to zeros.
        }
        else
        {
            dwSizeOption = sizeof(OPTION);
            dwSizeOptionEx = 0 ;
        }

        //  special non-atreeref fields
        (pFeaturesDest + dwFea)->dwFeatureID = dwGID ;
        (pFeaturesDest + dwFea)->dwOptionSize = dwSizeOption ;

        loOptions += dwSizeOption * dwNumOptions ;
        pubOptionsDest =  (PBYTE)(pInfoHdr) + pFeaturesDest[dwFea].Options.loOffset ;
        for(dwI = 0 ; dwI < dwNumOptions ; dwI++)
        {
            if(dwSizeOptionEx)
            {
                ((POPTION)pubOptionsDest)->loRenderOffset = loOptions ;
                pubDestOptionEx =  (PBYTE)(pInfoHdr) + loOptions ;
                loOptions += dwSizeOptionEx ;
            }
            else
            {
                ((POPTION)pubOptionsDest)->loRenderOffset = 0 ;
                pubDestOptionEx = NULL ;
            }

            if(!BinitOptionFields(pubOptionsDest, pubDestOptionEx,
                        pubnRaw, dwFea, dwI, poptsel, pInfoHdr, FALSE) )
            {
                MemFree(pInfoHdr) ;
                return(NULL) ;
            }
            pubOptionsDest += dwSizeOption ;
        }
    }

#ifndef KERNEL_MODE
    if(!BCheckGPDSemantics(pInfoHdr, poptsel) )
    {
        MemFree(pInfoHdr) ;
        pInfoHdr = NULL ;
    }
#endif

    return(pInfoHdr) ;
}

BOOL  BinitOptionFields(
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,  // option extra structure if any.
PBYTE   pubnRaw,  //  raw binary data.
DWORD   dwFea,
DWORD   dwOpt,
POPTSELECT   poptsel ,  // assume fully initialized
PINFOHEADER  pInfoHdr,   // used to access global structure.
BOOL    bUpdate  //  if true only update selected fields.
)
{
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwI, dwStart , dwEnd, dwNextOpt, dwGID   ;
    OPTSELECT  optsPrevs ;
    PBYTE   pubDest ;
    BOOL    bStatus = TRUE ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;

    pfo += dwFea  ;  //  index pfo to the proper feature.
    dwGID = pfo->dwGID ;

    //  save previous option selection for this feature.

    optsPrevs = poptsel[dwFea] ;  // save setting since we will sweep it.

    poptsel[dwFea].ubNext = NULL_OPTSELECT ;
    poptsel[dwFea].ubCurOptIndex = (BYTE)dwOpt ;

    if(bUpdate)  //  assume update comes after main group.
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONS].dwStart ;  // starting Index
    else
        dwStart = pStatic->ssTableIndex[SSTI_OPTIONS].dwStart ;  // starting Index

    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONS].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.
        if(dwGID >= MAX_GID)
        {
            if(pStatic->snapShotTable[dwI].dwGIDflags != 0xffffffff)
                continue ;  // this field not used for generic GID.
        }
        else if(!(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID)))
            continue ;  // this field not used for this GID.


        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = pubDestOption + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("BinitOptionFields: Failed to extract value for attribute in Fea: %d, Opt: %d\n", dwFea, dwOpt));
            bStatus = FALSE ;
        }
    }

    if(bUpdate)  //  assume update comes after main group.
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONEX].dwStart ;  // starting Index
    else
        dwStart = pStatic->ssTableIndex[SSTI_OPTIONEX].dwStart ;  // starting Index

    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONEX].dwEnd ;  // Ending Index


    for(dwI = dwStart ; bStatus  &&  pubDestOptionEx  &&  (dwI < dwEnd)
            ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.
        if(!(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID)))
            continue ;  // this field not used for this GID.


        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = pubDestOptionEx + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0,
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("BinitOptionFields: Failed to extract value for attribute in Fea: %d, Opt: %d\n", dwFea, dwOpt));
            bStatus = FALSE ;
        }
    }

    if(!bUpdate  &&  !BspecialProcessOption(pubnRaw, pubDestOption,
        pubDestOptionEx,
        pfo , poptsel, pInfoHdr, dwFea, dwOpt,
        optsPrevs.ubCurOptIndex == dwOpt) )
            //  dwOpt is the default option for dwFea!
    {
        bStatus = FALSE ;
    }

    poptsel[dwFea] = optsPrevs ;  // restore previous setting.
    return(bStatus) ;
}

BOOL    BinitUIinfo(
PUIINFO     pUIinfo ,
PBYTE   pubnRaw,  //  PSTATIC.   BETA2
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
)
{
    PENHARRAYREF   pearTableContents ;
    PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwI, dwStart , dwEnd, dwNextOpt ;
    BOOL    bStatus = TRUE ;
    PGLOBALATTRIB  pga ;
    PBYTE   pubDest, pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pga = (PGLOBALATTRIB)(pubRaw + pearTableContents[MTI_GLOBALATTRIB].
                            loOffset) ;

    if(bUpdate)  //  assume update comes after main group.
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_UIINFO].dwStart ;  // starting Index
    else
        dwStart = pStatic->ssTableIndex[SSTI_UIINFO].dwStart ;  // starting Index
    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_UIINFO].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.

        patrRoot = (PATREEREF)((PBYTE)pga +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)pUIinfo + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.
        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0,
                &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

    pUIinfo->pubResourceData =
        pubRaw + pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pUIinfo->dwSpecVersion = pmrbd->dwSpecVersion ;    //  don't change!
    pUIinfo->dwSize = sizeof(UIINFO);
    pUIinfo->dwTechnology = DT_RASPRINTER ;
    pUIinfo->dwDocumentFeatures = pmrbd->rbd.dwDocumentFeatures;
    pUIinfo->dwPrinterFeatures = pmrbd->rbd.dwPrinterFeatures;
    pUIinfo->dwCustomSizeOptIndex = UNUSED_ITEM;  // until found later
    pUIinfo->dwFreeMem = 400000 ;  //  default just in case
                    //  there are no GID_MEMOPTION features.
     pUIinfo->dwMaxDocKeywordSize = pmrbd->dwMaxDocKeywordSize + KEYWORD_SIZE_EXTRA;
     pUIinfo->dwMaxPrnKeywordSize = pmrbd->dwMaxPrnKeywordSize + KEYWORD_SIZE_EXTRA;

    //  dead:  replace with macros

//    pUIinfo->dwWhichBasePtr[UIDT_FEATURE] = 0 ;
//    pUIinfo->dwWhichBasePtr[UIDT_OPTION] = 0 ;
//    pUIinfo->dwWhichBasePtr[UIDT_OPTIONEX] = 0 ;
//    pUIinfo->dwWhichBasePtr[UIDT_CONSTRAINT] = BASE_USE_RESOURCE_DATA ;
//    pUIinfo->dwWhichBasePtr[UIDT_GROUPS] = BASE_USE_RESOURCE_DATA ;
//    pUIinfo->dwWhichBasePtr[UIDT_LISTNODE] = BASE_USE_RESOURCE_DATA ;
//    pUIinfo->dwWhichBasePtr[UIDT_FONTSCART] = BASE_USE_RESOURCE_DATA ;
//    pUIinfo->dwWhichBasePtr[UIDT_FONTSUBST] = BASE_USE_RESOURCE_DATA ;


    return(bStatus) ;
}



BOOL    BinitFeatures(
PFEATURE    pFeaturesDest,
PDFEATURE_OPTIONS  pfoSrc,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
)
{
    PENHARRAYREF   pearTableContents ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwI, dwStart , dwEnd , dwNextOpt ;
    BOOL    bStatus = TRUE ;
    PBYTE   pubDest ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;


    if(bUpdate)  //  assume update comes after main group.
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_FEATURES].dwStart ;  // starting Index
    else
        dwStart = pStatic->ssTableIndex[SSTI_FEATURES].dwStart ;  // starting Index


    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_FEATURES].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!pStatic->snapShotTable[dwI].dwNbytes)
            continue ;  // ignore section delimiter.

        patrRoot = (PATREEREF)((PBYTE)pfoSrc +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)pFeaturesDest + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0,
                &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

    return(bStatus) ;
}


BOOL    BinitGlobals(
PGLOBALS pGlobals,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
)
{
    PENHARRAYREF   pearTableContents ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwI, dwStart , dwEnd, dwNextOpt  ;
    BOOL    bStatus = TRUE ;
    PGLOBALATTRIB  pga ;
    PBYTE   pubDest ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pga = (PGLOBALATTRIB)(pubRaw + pearTableContents[MTI_GLOBALATTRIB].
                            loOffset) ;

    if (bUpdate)
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_GLOBALS].dwStart ;
    else
        dwStart = pStatic->ssTableIndex[SSTI_GLOBALS].dwStart ;  // starting Index

    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_GLOBALS].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.

        patrRoot = (PATREEREF)((PBYTE)pga +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)pGlobals + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0,
                &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

    return(bStatus) ;
}


BOOL    BinitCommandTable(
PDWORD  pdwCmdTable,  //  dest array
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
)
{
    PENHARRAYREF   pearTableContents ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwNextOpt , dwI;  //  index to the commandTable
                // describing how to transfer the Command data type.
    BOOL    bStatus = TRUE ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    patrRoot = (PATREEREF)(pubRaw + pearTableContents[MTI_COMMANDTABLE].
                            loOffset) ;


    //  loop for every PATREEREF in the MTI_COMMANDTABLE !
    //  not looping through each entry in the section.

    for(dwI = 0 ; bStatus  &&  (dwI < CMD_MAX) ; dwI++)
    {
        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, pStatic->dwSSTableCmdIndex,
            (PBYTE)(pdwCmdTable + dwI),
            &dwUnresolvedFeature,  patrRoot[dwI], poptsel, 0,
                &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }
    return(bStatus) ;
}


BOOL    BinitRawData(
PRAWBINARYDATA   pRawData, // contained in INFOHEADER.
PBYTE   pubnRaw  //  Parser's raw binary data.
)
{
    PMINIRAWBINARYDATA  pmrbd ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pRawData->dwFileSize = pmrbd->rbd.dwFileSize;
    pRawData->dwParserSignature = pmrbd->rbd.dwParserSignature;
    pRawData->dwParserVersion = pmrbd->rbd.dwParserVersion;
    pRawData->dwChecksum32 = pmrbd->rbd.dwChecksum32;
    pRawData->dwSrcFileChecksum32 = pmrbd->rbd.dwSrcFileChecksum32;


    //  this not the count of synthesized vs.
    //  explicitly defined features

    pRawData->dwDocumentFeatures = pmrbd->rbd.dwDocumentFeatures;
    pRawData->dwPrinterFeatures = pmrbd->rbd.dwPrinterFeatures;
    pRawData->pvPrivateData = pubnRaw ;   //  BETA2

    pRawData->pvReserved = NULL;


    return(TRUE) ;
}


BOOL    BinitGPDdriverInfo(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
)
{
    PENHARRAYREF   pearTableContents ;
    BOOL   bStatus ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pGPDdriverInfo->dwSize =  sizeof(GPDDRIVERINFO) ;
    pGPDdriverInfo->pubResourceData =
        pubRaw + pearTableContents[MTI_STRINGHEAP].loOffset  ;

    pGPDdriverInfo->DataType[DT_COMMANDARRAY].loOffset =
        pearTableContents[MTI_COMMANDARRAY].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_COMMANDARRAY].dwCount =
        pearTableContents[MTI_COMMANDARRAY].dwCount  ;

    pGPDdriverInfo->DataType[DT_PARAMETERS].loOffset =
        pearTableContents[MTI_PARAMETER].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_PARAMETERS].dwCount =
        pearTableContents[MTI_PARAMETER].dwCount  ;

    pGPDdriverInfo->DataType[DT_TOKENSTREAM].loOffset =
        pearTableContents[MTI_TOKENSTREAM].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_TOKENSTREAM].dwCount =
        pearTableContents[MTI_TOKENSTREAM].dwCount  ;

    pGPDdriverInfo->DataType[DT_LISTNODE].loOffset =
        pearTableContents[MTI_LISTNODES].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_LISTNODE].dwCount =
        pearTableContents[MTI_LISTNODES].dwCount  ;

    pGPDdriverInfo->DataType[DT_FONTSCART].loOffset =
        pearTableContents[MTI_FONTCART].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_FONTSCART].dwCount =
        pearTableContents[MTI_FONTCART].dwCount  ;

    pGPDdriverInfo->DataType[DT_FONTSUBST].loOffset =
        pearTableContents[MTI_TTFONTSUBTABLE].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_FONTSUBST].dwCount =
        pearTableContents[MTI_TTFONTSUBTABLE].dwCount  ;

    bStatus = BinitSequencedCmds(pGPDdriverInfo, pubnRaw, poptsel) ;
    if(bStatus)
        bStatus = BinitGlobals(&pGPDdriverInfo->Globals, pubnRaw,  poptsel, FALSE ) ;

    return(bStatus) ;
}


BOOL    BinitSequencedCmds(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
)
{
    PINFOHEADER  pInfoHdr ;
    PDWORD      pdwCmdTable ;   // start of local CommandTable
    PENHARRAYREF   pearTableContents ;
    DWORD       dwCmdIn ,  //  command table index.
                            //  or commandArray index.
                dwNextOpt, dwFea, dwNumFeatures ,
                dwUnresolvedFeature,
                dwNewListNode = 0 ;  //  an unused listnode to
                        //  add to the list.  initially none are used.
    PDFEATURE_OPTIONS  pfo ;
    ATREEREF    atrRoot ;    //  root of attribute tree
    //  PMINIRAWBINARYDATA  pmrbd ;
    OPTSELECT  optsPrevs ;
    BOOL    bStatus = TRUE ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pInfoHdr  = pGPDdriverInfo->pInfoHeader ;
    pdwCmdTable = (PDWORD)((PBYTE)(pInfoHdr) +
            pGPDdriverInfo->DataType[DT_COMMANDTABLE].loOffset) ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pGPDdriverInfo->dwJobSetupIndex = END_OF_LIST ;
    pGPDdriverInfo->dwDocSetupIndex = END_OF_LIST ;
    pGPDdriverInfo->dwPageSetupIndex = END_OF_LIST ;
    pGPDdriverInfo->dwPageFinishIndex = END_OF_LIST ;
    pGPDdriverInfo->dwDocFinishIndex = END_OF_LIST ;
    pGPDdriverInfo->dwJobFinishIndex = END_OF_LIST ;

    //  first add the configuration commands to the list.
    //  get them from the commandtable.   Assume they are all
    //  contiguous

    for(dwCmdIn = FIRST_CONFIG_CMD ; dwCmdIn < LAST_CONFIG_CMD  ; dwCmdIn++)
    {
        if((pdwCmdTable[dwCmdIn] != UNUSED_ITEM)  &&
            BaddSequencedCmdToList(pdwCmdTable[dwCmdIn],  pGPDdriverInfo,
                dwNewListNode, pubnRaw  ) )
            dwNewListNode++ ;
    }

    //  now wander through all the features, seeing what
    //  command is needed.

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;
    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;


    for(dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        atrRoot = pfo[dwFea].atrCommandIndex ;
        if(EextractValueFromTree(pubnRaw, pStatic->dwSSCmdSelectIndex,
            (PBYTE)&dwCmdIn, // CmdArray index  - dest
            &dwUnresolvedFeature,  atrRoot, poptsel, dwFea,
            &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
            continue ;
        }
        if( (dwCmdIn != UNUSED_ITEM)  &&
            BaddSequencedCmdToList(dwCmdIn,  pGPDdriverInfo,
                dwNewListNode, pubnRaw  ) )
            dwNewListNode++ ;

        while(dwNextOpt)   // multiple options selected.
        {
            if(EextractValueFromTree(pubnRaw, pStatic->dwSSCmdSelectIndex,
                (PBYTE)&dwCmdIn, // CmdArray index  - dest
                &dwUnresolvedFeature,  atrRoot, poptsel, dwFea,
                &dwNextOpt) != TRI_SUCCESS)
            {
                bStatus = FALSE ;
                continue ;
            }
            if((dwCmdIn != UNUSED_ITEM)  &&
                BaddSequencedCmdToList(dwCmdIn,  pGPDdriverInfo,
                    dwNewListNode, pubnRaw  ) )
                dwNewListNode++ ;
        }
    }
    return(bStatus);
}


BOOL    BaddSequencedCmdToList(
DWORD   dwCmdIn,  // index of a command in CommandArray
PGPDDRIVERINFO  pGPDdriverInfo,
DWORD   dwNewListNode,  //  an unused listnode to add to the list.
PBYTE   pubnRaw  //  raw binary data.
)
/*  remember:
    the pdwSeqCmdRoot points to the first node in a list.
    There is a list for each SEQSECTION.
    Each node contains the index to a command in the command array
    and an index to the next node in the list.
*/
{
    PCOMMAND    pcmdArray ;  // the Command Array
    SEQSECTION     eSection;
    PDWORD      pdwSeqCmdRoot ; // points to a list root.
    DWORD       dwOrder,  // order value of a command.
                dwCurListNode,  // node index as we traverse the list.
                dwPrevsListNode ;  // the prevs node in the list.
    PINFOHEADER  pInfoHdr ;
    PLISTNODE   plstNodes ;  //  start of local listnodes array
    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pInfoHdr  = pGPDdriverInfo->pInfoHeader ;
    plstNodes = (PLISTNODE)((PBYTE)pInfoHdr +
            pGPDdriverInfo->DataType[DT_LOCALLISTNODE].loOffset) ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pcmdArray = (PCOMMAND)(pubRaw +
                pearTableContents[MTI_COMMANDARRAY].loOffset) ;

    eSection = pcmdArray[dwCmdIn].ordOrder.eSection ;
    switch(eSection)
    {
        case (SS_JOBSETUP):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwJobSetupIndex;
            break ;
        }
        case (SS_DOCSETUP):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwDocSetupIndex;
            break ;
        }
        case (SS_PAGESETUP):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwPageSetupIndex;
            break ;
        }
        case (SS_PAGEFINISH):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwPageFinishIndex;
            break ;
        }
        case (SS_DOCFINISH):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwDocFinishIndex;
            break ;
        }
        case (SS_JOBFINISH):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwJobFinishIndex;
            break ;
        }
        default:
        {
            ERR(("BaddSequencedCmdToList: Invalid or non-existent *Order value specified.\n"));
            return(FALSE);  // command not added to linked list.
        }
    }
    //  Insert a new node in the list pointed to by pdwSeqCmdRoot

    dwOrder = pcmdArray[dwCmdIn].ordOrder.dwOrder ;

    // walk the list until you find an order larger than yours.

    dwPrevsListNode = END_OF_LIST ;
    dwCurListNode = *pdwSeqCmdRoot ;

    while((dwCurListNode != END_OF_LIST)  &&
        (pcmdArray[plstNodes[dwCurListNode].dwData].ordOrder.dwOrder
        < dwOrder)  )
    {
        dwPrevsListNode = dwCurListNode ;
        dwCurListNode = plstNodes[dwCurListNode].dwNextItem ;
    }

    plstNodes[dwNewListNode].dwData = dwCmdIn ;
    plstNodes[dwNewListNode].dwNextItem = dwCurListNode ;
    if(dwPrevsListNode == END_OF_LIST)
        *pdwSeqCmdRoot = dwNewListNode ;
    else
        plstNodes[dwPrevsListNode].dwNextItem = dwNewListNode ;

    return(TRUE) ;
}

/*++
    The default Option array (as determined from the gpd) is initialized.
    Since the options or attributues of features may be dependent on the
    some other features, the order of initialization of feature assumes
    importance. The priority array therefore tries to order the
    initialization so that when a feature has to be initialised, all the
    features on which it is dependent on have already been initialised.
    If, inspite of the priority array, a feature's option cannot be
    determined until some other feature's option has been determined,
    the RaisePriority Function is used (This is called by
    EdetermineDefaultOption() ).
    A quirky code here is the pdwPriorityCopy which is initialised
    to pdwPriority. The latter is in read only space and therefore
    prevents change of priority in the RaisePriority Function.
    Therefore pdwPriorityCopy is passed to that function.

    Some special case processing is required for the *Feature:Locale
    keyword if it occurs in the .gpd. The default option for this
    feature is to be set to the SystemDefaultLocale.

--*/

BinitDefaultOptionArray(
POPTSELECT   poptsel,   // assume is large enough
PBYTE   pubnRaw)
{
    PENHARRAYREF        pearTableContents ;
//  PMINIRAWBINARYDATA  pmrbd  ;
    PDFEATURE_OPTIONS   pfo ;
    PDWORD              pdwPriority,     // Array of feature indices arranged
                                         // according to priority.
                        pdwPriorityCopy; // pdwPriority is in read only space.
                                         // We might have to change the
                                         // priorities temporarily to allow
                                         // Default option array to be
                                         // constructed. This change is done in
                                         // pdwPriorityCopy

    DWORD               dwNumFeatures,   // Total number of features
                        dwI ,
                        dwFea,           // Index of Feature Locale
                        dwOptIndex;      // Index of Option of Locale that
                                         // matches System Locale
    PBYTE               pubRaw ;
    PSTATICFIELDS       pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA



    //  obtain pointers to structures:
    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;
    //  both explicit and synthesized features are contiguous.
    if(dwNumFeatures > MAX_COMBINED_OPTIONS)
        return(FALSE);  // too many to save



    dwFea = dwOptIndex = (DWORD)-1; // For safety sake only. Should be initialized
                             // in the function BgetLocFeaOptIndex().

    // returns TRUE if everything OK. if return is TRUE and dwFea is -1
    // Locale is not present and no special processing is required.
    // If dwFea != -1 and dwOptIndex == -1 means none of the options in
    // the .gpd match the system default. Again no special processing
    // for locale is required.

    // Assuming that only a single matching option is possible for
    // Locale.
    if ( !BgetLocFeaOptIndex(
                (PRAWBINARYDATA)pubnRaw, &dwFea, &dwOptIndex) )
    {
        return FALSE;
    }



    pdwPriority = (PDWORD)(pubRaw + pearTableContents[MTI_PRIORITYARRAY].
                                loOffset) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;

    if ( ! (pdwPriorityCopy = (PDWORD) MemAlloc (
                        pearTableContents[MTI_PRIORITYARRAY].dwCount *
                        pearTableContents[MTI_PRIORITYARRAY].dwElementSiz ) ) )
    {
        // Set error codes and
        ERR(("Fatal: BinitDefaultOptionArray - unable to allocate memory\n" ));
        return FALSE;
    }

    memcpy(pdwPriorityCopy, pdwPriority,
                pearTableContents[MTI_PRIORITYARRAY].dwCount *
                pearTableContents[MTI_PRIORITYARRAY].dwElementSiz );




    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        poptsel[dwI].ubCurOptIndex = OPTION_INDEX_ANY ;
        poptsel[dwI].ubNext = NULL_OPTSELECT ;
    }

    // Initialize the option array for Feature Locale.
    // Or should we call ReconstructOptionArray.????
    if ( dwFea != -1 && dwOptIndex != -1)
    {
        poptsel[dwFea].ubCurOptIndex  = (BYTE)dwOptIndex;
        poptsel[dwFea].ubNext         = NULL_OPTSELECT ;
    }

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        //  The order of evaluation is determined
        //  by the priority array.

        if(poptsel[pdwPriorityCopy[dwI]].ubCurOptIndex == OPTION_INDEX_ANY)
        {
            if(EdetermineDefaultOption(pubnRaw , pdwPriorityCopy[dwI],
                    pfo, poptsel, pdwPriorityCopy) != TRI_SUCCESS)
            {
                ERR(("BinitDefaultOptionArray: failed to determine consistent \
                      default options.\n"));

                if ( pdwPriorityCopy )
                    MemFree(pdwPriorityCopy);

                return(FALSE);
            }
        }
    }
    //  BUG_BUG!!!! now verify the set options thus determined is
    //  fully self consistent.  is not precluded by UIConstraints.
    //  warn user and fail otherwise .
    //  successful execution of EdetermineDefaultOption basically
    //  assures this.

    if ( pdwPriorityCopy )
        MemFree(pdwPriorityCopy);

    return(TRUE);
}


TRISTATUS     EdetermineDefaultOption(
PBYTE   pubnRaw,         // start of Rawbinary data
DWORD   dwFeature,       // determine the default for this feature
PDFEATURE_OPTIONS  pfo,
POPTSELECT   poptsel,    // assume is large enough
PDWORD      pdwPriority) // Priority array indicating the priority of various
                         // features.
{
    //  PMINIRAWBINARYDATA pmrbd  ;
    TRISTATUS  eStatus   ;
    DWORD   dwUnresolvedFeature , // no option has been determined
            dwNextOpt ,           // for this feature
            dwOption ;  //  for   BextractValueFromTree
                        //  to write into.
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  This function will modify the priority array
    //  each time the tree walk fails so that each feature
    //  evaluated depends only on default options that have
    //  previously evaluated .

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    dwNextOpt = 0 ;  // extract info for first option selected for
                        //  this feature.

    while((eStatus = EextractValueFromTree(
                    pubnRaw, pStatic->dwSSdefaultOptionIndex,
                    (PBYTE )&dwOption,
                    &dwUnresolvedFeature,
                    pfo[dwFeature].atrDefaultOption,
                    poptsel, 0,
                    &dwNextOpt)) == TRI_AGAIN)
    {
        //  recursion handles depth, while loop handles breadth

        if(poptsel[dwUnresolvedFeature].ubCurOptIndex == OPTION_PENDING)
        {
            ERR(("Fatal syntax error: EdetermineDefaultOption - circular dependency in default options.\n"));
            return(TRI_UTTER_FAILURE) ;
        }
        poptsel[dwFeature].ubCurOptIndex = OPTION_PENDING ;
        // marks entry in option array so we can detect infinite loops.

        if(!RaisePriority(dwFeature, dwUnresolvedFeature, pubnRaw, pdwPriority))
            return(FALSE) ;  // modify Priority array to reflect
                            //  reality.

        eStatus = EdetermineDefaultOption(pubnRaw, dwUnresolvedFeature,
                  pfo, poptsel, pdwPriority) ;
        if(eStatus == TRI_UTTER_FAILURE)
            return(TRI_UTTER_FAILURE) ;
    }
    if(eStatus == TRI_SUCCESS)
        poptsel[dwFeature].ubCurOptIndex = (BYTE)dwOption ;

    return(eStatus);
}


VOID    VtileDefault(
PBYTE   pubDest,
DWORD   dwDefault,
DWORD   dwBytes)
{
    DWORD  dwRemain ;

    // This function will copy the same DWORD
    //  repeatedly into the dest until dwBytes have
    //  been written.

    for (dwRemain = dwBytes ; dwRemain > sizeof(DWORD)  ;
            dwRemain -= sizeof(DWORD) )
    {
        memcpy(pubDest , &dwDefault, sizeof(DWORD)) ;
        pubDest += sizeof(DWORD) ;
    }
    memcpy(pubDest, &dwDefault, dwRemain) ;
}




VOID    VtransferValue(
OUT PBYTE   pubDest,
IN  PBYTE   pubSrc ,
IN  DWORD   dwBytes,
IN  DWORD   dwFlags,
IN  DWORD   dwDefaultValue,  // holds bit flag value.
IN  PBYTE   pubHeap )   //  used to form ptr if SSF_MAKE_STRINGPTR
/*  this  wrapper implements:
    SSF_OFFSETONLY, SSF_MAKE_STRINGPTR,
    SSF_SECOND_DWORD, SSF_SETRCID, SSF_STRINGLEN,
    SSF_BITFIELD_ xxx
    notice all of these flags are basically
    mutually exclusive. But this function only
    enforces this for the first three flags.
*/
{
    if(dwFlags & SSF_SECOND_DWORD)
    {
        memcpy(pubDest, pubSrc + sizeof(DWORD) , dwBytes) ;
    }
    else if(dwFlags & SSF_MAKE_STRINGPTR)
    {
        PBYTE   pubStr ;

        pubStr = pubHeap + ((PARRAYREF)pubSrc)->loOffset  ;

        memcpy(pubDest, (PBYTE)&pubStr , sizeof(PBYTE)) ;
    }
    else if(dwFlags & SSF_OFFSETONLY)
    {
        memcpy(pubDest, (PBYTE)&(((PARRAYREF)pubSrc)->loOffset) , dwBytes) ;
    }
    else if(dwFlags & SSF_STRINGLEN)
    {
        memcpy(pubDest, (PBYTE)&(((PARRAYREF)pubSrc)->dwCount) , dwBytes) ;
    }
    else if(dwFlags & SSF_BITFIELD_DEF_FALSE  ||
                dwFlags & SSF_BITFIELD_DEF_TRUE)
    {
        if(*(PDWORD)pubSrc)   // assume fields are zero initialized
            *(PDWORD)pubDest |= dwDefaultValue ;
        else
            *(PDWORD)pubDest &= ~dwDefaultValue ;
    }
    else
    {
        memcpy(pubDest, pubSrc , dwBytes) ;
    }

    if(dwBytes == sizeof(DWORD) )
    {
        if(dwFlags & SSF_KB_TO_BYTES)
            *(PDWORD)pubDest <<=  10 ;  // convert Kbytes to bytes
        else if(dwFlags & SSF_MB_TO_BYTES)
            *(PDWORD)pubDest <<=  20 ;  // convert Mbytes to bytes

        if(dwFlags & SSF_SETRCID)
            *(PDWORD)pubDest |=  GET_RESOURCE_FROM_DLL ;
    }
}


BOOL    BspecialProcessOption(
PBYTE   pubnRaw,  // start of Rawbinary data
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,
PDFEATURE_OPTIONS  pfo ,  // source data
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.
PINFOHEADER  pInfoHdr,   // used to access global structure.
DWORD   dwFea,   //  feature index
DWORD   dwOpt,
BOOL   bDefaultOpt
)
{
    PGPDDRIVERINFO  pGPDdriverInfo ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    DWORD  dwGID, dwNextOpt, dwUnresolvedFeature, dwI ;
    PBYTE  pubDest ;
    PATREEREF   patrRoot ;
    PUIINFO     pUIinfo ;
    BOOL    bStatus = TRUE ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pGPDdriverInfo = (PGPDDRIVERINFO)((PBYTE)(pInfoHdr) +
                    pInfoHdr->loDriverOffset) ;

    pUIinfo = (PUIINFO)((PBYTE)(pInfoHdr) +
                    pInfoHdr->loUIInfoOffset)  ;

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    dwGID = pfo->dwGID ;

#if  0
    //  dead code for now.
    //  Extract atrMargins convert to ImageableArea, place in rcImgArea.

    dwI = pStatic->dwSSPaperSizeMarginsIndex;

    if(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID))
    {
        RECT    rcMargins ;
        PRECT   prcImageArea ;
        SIZE    szPaperSize ;

        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)&rcMargins ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
        szPaperSize = ((PPAGESIZE)pubDestOption)->szPaperSize ;
        prcImageArea = &((PPAGESIZE)pubDestOption)->rcImgAreaP ;

        prcImageArea->left = rcMargins.left ;
        prcImageArea->top = rcMargins.top ;
        prcImageArea->right = szPaperSize.x - rcMargins.right ;
        prcImageArea->bottom = szPaperSize.y - rcMargins.bottom ;
    }


    //  Extract atrMin/MaxSize place in ptMin/MaxSize in GLOBALS.

    dwI = pStatic->dwSSPaperSizeMinSizeIndex;

    if(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID)  &&
        ((PPAGESIZE)pubDestOption)->dwPaperSizeID == DMPAPER_USER )
    {
        pUIinfo->dwCustomSizeOptIndex = dwOpt ;
        pUIinfo->dwFlags |= FLAG_CUSTOMSIZE_SUPPORT ;

        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)(&pGPDdriverInfo->Globals) +
                    pStatic->snapShotTable[dwI].dwDestOffset;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

    dwI = pStatic->dwSSPaperSizeMaxSizeIndex;

    if(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID)  &&
        ((PPAGESIZE)pubDestOption)->dwPaperSizeID == DMPAPER_USER )
    {

        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)(&pGPDdriverInfo->Globals) +
                    pStatic->snapShotTable[dwI].dwDestOffset;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

#endif


    dwI = pStatic->dwSSPaperSizeCursorOriginIndex ;

    if(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID) )
    {
        TRISTATUS  triStatus ;

        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;

        pubDest = pubDestOptionEx +
                    pStatic->snapShotTable[dwI].dwDestOffset;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if((triStatus  = EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt)) != TRI_SUCCESS)
        {
            if(triStatus == TRI_UNINITIALIZED)
            {
                ((PPAGESIZEEX)pubDestOptionEx)->ptPrinterCursorOrig =
                    ((PPAGESIZEEX)pubDestOptionEx)->ptImageOrigin ;
            }
            else
                bStatus = FALSE ;
        }
    }


    if(dwGID == GID_MEMOPTION  &&
        bDefaultOpt)
    {
        pUIinfo->dwFreeMem = ((PMEMOPTION)pubDestOption)->dwFreeMem ;
    }

    if(dwGID == GID_COLORMODE   &&
        ((PCOLORMODEEX)pubDestOptionEx)->bColor )
    {
        pUIinfo->dwFlags |= FLAG_COLOR_DEVICE ;
    }


    return(bStatus);
}




TRISTATUS     EextractValueFromTree(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwSSTableIndex,  // some info about this value.
OUT PBYTE    pubDest,  // write value or link here
OUT PDWORD  pdwUnresolvedFeature,  // if the attribute tree has
            //  a dependency on this feature and the current option
            //  for that feature is not defined  in poptsel, this
            //  function will write the index of the required
            //  feature in pdwUnresolvedFeature.
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.  may be filled with OPTION_INDEX_ANY
                //  if we are jumpstarting
IN  DWORD   dwFeature,
IN OUT  PDWORD   pdwNextOpt  //  if multiple options are selected
    //  for dwFeature, pdwNextOpt points to the Nth option to consider
    //  in the  poptsel list,  at return time, this value
    //  is incremented if there are remaining options selected,
    //  else is reset to zero.
    //  For the first call, or PICKONE features,
    //  this value must be set to zero.
)
{
    BOOL    bMissingDependency = FALSE;
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PENHARRAYREF   pearTableContents ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    DWORD   dwBytes ,  // size of value in bytes
        dwValueNodeIndex , dwNodeIndex, dwFea, dwI ,
        dwDefault ,  // value to copy or tile to dest.
        dwOption, dwFlags ;
    PBYTE   pubHeap ,  // ptr to start of heap.
        pubSrc ;  //  ptr to value bytes
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  obtain pointers to structures:

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    patt = (PATTRIB_TREE)(pubRaw + pearTableContents[MTI_ATTRIBTREE].
                            loOffset) ;

    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    dwBytes = pStatic->snapShotTable[dwSSTableIndex].dwNbytes ;
    dwFlags = pStatic->snapShotTable[dwSSTableIndex].dwFlags ;

    dwDefault = pStatic->snapShotTable[dwSSTableIndex].dwDefaultValue ;
    //  now attempt to navigate the attributeTree.

    if(atrRoot == ATTRIB_UNINITIALIZED)
    {
        DWORD   dwRemain ;  // bytes remaining to copy.

UNINITIALIZED_BRANCH:

        if(dwFlags & SSF_BITFIELD_DEF_FALSE)
        {
            *(PDWORD)pubDest &= ~dwDefault ;  //  clear bitflag
        }
        else if(dwFlags & SSF_BITFIELD_DEF_TRUE)
        {
            *(PDWORD)pubDest |= dwDefault ;  // set bitflag
        }
        else if(!(dwFlags & SSF_DONT_USEDEFAULT))
        {
            if (dwBytes == sizeof(DWORD))
                memcpy (pubDest, &dwDefault, sizeof(DWORD));
            else if (dwBytes == (sizeof(DWORD)*2))
            {
                memcpy (pubDest, &dwDefault, sizeof(DWORD));
                memcpy (pubDest+sizeof(DWORD), &dwDefault, sizeof(DWORD));
            }
            else
                VtileDefault(pubDest, dwDefault, dwBytes) ;
        }

        if(dwFlags & SSF_REQUIRED)
        {
            ERR(("EextractValueFromTree: a required keyword is missing from the GPD file. %s\n",
                pStatic->snapShotTable[dwSSTableIndex].pstrKeyword ));
            return(TRI_UNINITIALIZED) ;
        }
        if(dwFlags & SSF_FAILIFZERO)
        {   //  see if dest is completely zeroed. Fail if it is.
            for(dwI = 0 ; (dwI < dwBytes) && !pubDest[dwI] ; dwI++)
                ;
            if(dwI == dwBytes)
            {
                ERR(("EextractValueFromTree: None of several initializers found.  %s\n",
                    pStatic->snapShotTable[dwSSTableIndex].pstrKeyword ));
                return(TRI_UNINITIALIZED) ;  //  of the two or more
                //  keywords that could have initialized this field,
                //  none were found.
            }

        }
        if(dwFlags & SSF_RETURN_UNINITIALIZED)
            return(TRI_UNINITIALIZED) ;

        return(TRI_SUCCESS) ;   // no value defined.
    }
    else if(atrRoot & ATTRIB_HEAP_VALUE)
    {
        DWORD   dwTmp ;

        if(dwFlags & SSF_HEAPOFFSET)
        {
            dwTmp = atrRoot & ~ATTRIB_HEAP_VALUE ;
            pubSrc = (PBYTE)&dwTmp ;
        }
        else
            pubSrc = pubHeap + (atrRoot & ~ATTRIB_HEAP_VALUE) ;

        if (dwBytes == sizeof(DWORD) && !(dwFlags &
                (SSF_SECOND_DWORD |
                SSF_MAKE_STRINGPTR |
                SSF_OFFSETONLY |
                SSF_STRINGLEN |
                SSF_BITFIELD_DEF_FALSE |
                SSF_BITFIELD_DEF_TRUE |
                SSF_KB_TO_BYTES |
                SSF_MB_TO_BYTES |
                SSF_SETRCID)))
        {
            memcpy (pubDest,pubSrc,sizeof(DWORD));
        }
        else
        {
            VtransferValue(pubDest, pubSrc , dwBytes, dwFlags, dwDefault, pubHeap ) ;
        }

        if(dwFlags & SSF_NON_LOCALIZABLE)
//            pmrbd->bContainsNames = TRUE ;
            ; //  set a flag here.
        return(TRI_SUCCESS) ;
    }
    //  atrRoot specifies a node index
    dwNodeIndex = atrRoot ;
    dwValueNodeIndex = END_OF_LIST ;

    if(patt[dwNodeIndex].dwFeature == DEFAULT_INIT )
    {
        dwValueNodeIndex = dwNodeIndex  ;
        dwNodeIndex = patt[dwNodeIndex].dwNext ;
    }

    while (dwNodeIndex != END_OF_LIST)
    {

        if((dwFea = patt[dwNodeIndex].dwFeature) == dwFeature)
        //  for this feature, I may want to examine not the first
        //  selected option, but other selections. (PICKMANY)
        //  walk the PICKMANY list.
        {
            for(dwI = 0 ; dwI < *pdwNextOpt ; dwI++)
            {
                if(poptsel[dwFea].ubNext != NULL_OPTSELECT)
                    dwFea = poptsel[dwFea].ubNext ;
                else
                    break ;
            }
            if(poptsel[dwFea].ubNext != NULL_OPTSELECT)
                (*pdwNextOpt)++ ;
            else
                *pdwNextOpt = 0 ;  // reset to indicate end of list.
        }

        dwOption =
            (DWORD)poptsel[dwFea].ubCurOptIndex  ;

        if(dwOption == OPTION_PENDING)
        {
            ERR(("EextractValueFromTree: Fatal syntax error, circular dependency in default options.\n"));
            return(TRI_UTTER_FAILURE) ;
        }
        if(dwOption == OPTION_INDEX_ANY)
        {
            *pdwUnresolvedFeature = patt[dwNodeIndex].dwFeature ;
            return(TRI_AGAIN) ;  // option array not fully defined.
        }
        //  valid option for this feature, see if a matching
        //  node exists.
#ifndef OLDWAY
        while (patt[dwNodeIndex].dwOption != dwOption &&
               patt[dwNodeIndex].dwNext != END_OF_LIST)
        {
            dwNodeIndex = patt[dwNodeIndex].dwNext;
        }
        if(patt[dwNodeIndex].dwOption != dwOption &&
           patt[dwNodeIndex].dwOption != DEFAULT_INIT)
        {
            break;
        }
#else
        if(!BfindMatchingOrDefaultNode(patt , &dwNodeIndex, dwOption))
        {
            //  attribute tree does not contain the specified
            //  branch.  Use the Global Default Initializer if exists.
            break ;
        }
#endif
        if(patt[dwNodeIndex].eOffsetMeans == VALUE_AT_HEAP)
        {
            dwValueNodeIndex = dwNodeIndex ;  // Eureka !
            break ;
        }
        //  does this node contain a sublevel?
        if(patt[dwNodeIndex].eOffsetMeans == NEXT_FEATURE)
        {
            // Down to the next level we go.
            dwNodeIndex = patt[dwNodeIndex ].dwOffset ;
        }
        else
             break;   //  tree corruption has occurred.  exit.
    }
    if(dwValueNodeIndex != END_OF_LIST  &&
        patt[dwValueNodeIndex].eOffsetMeans == VALUE_AT_HEAP )
    {
        if(dwFlags & SSF_HEAPOFFSET)
            pubSrc = (PBYTE)&(patt[dwValueNodeIndex].dwOffset) ;
        else
            pubSrc = pubHeap + patt[dwValueNodeIndex].dwOffset ;

        if (dwBytes == sizeof(DWORD) && !(dwFlags &
                (SSF_SECOND_DWORD |
                SSF_MAKE_STRINGPTR |
                SSF_OFFSETONLY |
                SSF_STRINGLEN |
                SSF_BITFIELD_DEF_FALSE |
                SSF_BITFIELD_DEF_TRUE |
                SSF_KB_TO_BYTES |
                SSF_MB_TO_BYTES |
                SSF_SETRCID)))
        {
            memcpy (pubDest,pubSrc,sizeof(DWORD));
        }
        else
        {
            VtransferValue(pubDest, pubSrc , dwBytes, dwFlags, dwDefault, pubHeap ) ;
        }

        if(dwFlags & SSF_NON_LOCALIZABLE)
//            pmrbd->bContainsNames = TRUE ;
            ;  // set a flag here
        return(TRI_SUCCESS) ;
    }
    //  attribute tree does not contain the specified
    //  branch.  This is not necessarily an error since
    //  the attribute tree is allowed to be sparsely populated.
    goto  UNINITIALIZED_BRANCH ;
}



BOOL   RaisePriority(
DWORD   dwFeature1,
DWORD   dwFeature2,
PBYTE   pubnRaw,
PDWORD  pdwPriority)
{
    // takes to lower priority feature and assigns
    // it the priority of the other feature.
    //  The priority of all features between feature1
    //  and feature2 including the higher priority feature
    //  are demoted one level.
    PENHARRAYREF   pearTableContents ;
//    PDWORD   pdwPriority ;
    DWORD   dwHigherP, dwLowerP, dwFeature, dwI, dwEntries  ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

/**
    pdwPriority = (PDWORD)(pubRaw + pearTableContents[MTI_PRIORITYARRAY].
                                loOffset) ;
**/

    dwEntries = pearTableContents[MTI_PRIORITYARRAY].dwCount ;

    dwHigherP = dwLowerP = dwEntries ;  // init to invalid value.

    //  a Priority 1 is considered
    //  a 'higher' priority than a priority 2, but arithmetically its
    //  the other way around.

    for(dwI = 0 ; dwI < dwEntries ; dwI++)
    {
        if(pdwPriority[dwI] == dwFeature1)
        {
            if(dwHigherP == dwEntries)
                dwHigherP = dwI ;
            else
            {
                dwLowerP = dwI ;
                break ;
            }
        }
        else if(pdwPriority[dwI] == dwFeature2)
        {
            if(dwHigherP == dwEntries)
                dwHigherP = dwI ;
            else
            {
                dwLowerP = dwI ;
                break ;
            }
        }
    }
    //  BUG_BUG paranoid:  could verify
    //  if( dwHigherP ==  dwEntries  ||  dwLowerP == dwEntries )
    //        return(FALSE);  priority array or arg values
    //      are corrupted .
    ASSERT(dwHigherP != dwEntries  &&  dwLowerP != dwEntries);

    dwFeature = pdwPriority[dwLowerP] ;  // this feature will be promoted.

    for(dwI = dwLowerP  ; dwI > dwHigherP ; dwI--)
    {
        pdwPriority[dwI] = pdwPriority[dwI - 1] ;
    }
    pdwPriority[dwHigherP] = dwFeature ;
    return(TRUE) ;
}


DWORD  dwNumOptionSelected(
IN  DWORD  dwNumFeatures,
IN  POPTSELECT       poptsel
)
/*  reports number of options actually selected in
option select array.  The caller supplies dwNumFeatures -
the number of Doc and Printer sticky features, and this
function does the rest.  The actual number of options
selected may be larger than dwNumFeatures if there are
PICKMANY features.  */
{
    DWORD       dwCount, dwI, // feature Index
        dwNext ;  // if pick many, next option selection for this feature.

    dwCount = dwNumFeatures ;

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        for(dwNext = dwI ;
            poptsel[dwNext].ubNext != NULL_OPTSELECT ;
            dwNext = poptsel[dwNext].ubNext )
        {
            dwCount++ ;
        }
    }
    return(dwCount) ;
}


//  assume a pointer to this table is stored in the RAWbinary data.




BOOL  BinitSnapShotIndexTable(PBYTE  pubnRaw)
/*
    snapShotTable[]  is assumed to be divided into sections
    with an entry with dwNbytes = 0 dividing the sections.
    The end of the table is also terminated by an entry
    with dwNbytes = 0.
    This function initializes pmrbd->ssTableIndex
    which serves as an index into pmrbd->snapShotTable.

*/
{
    PSTATICFIELDS   pStatic ;
//    PMINIRAWBINARYDATA pmrbd  ;
    DWORD dwI,  // snapShotTable Index
        dwSect ;  //  SSTABLEINDEX  Index
    PRANGE   prng ;

    pStatic = (PSTATICFIELDS)pubnRaw ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pStatic->ssTableIndex = (PRANGE)
        MemAlloc(sizeof(RANGE) * MAX_STRUCTURETYPES) ;
    if(!pStatic->ssTableIndex)
        return(FALSE) ;


    prng  = pStatic->ssTableIndex ;

    for(dwI = dwSect = 0 ; dwSect < MAX_STRUCTURETYPES ; dwSect++, dwI++)
    {
        prng[dwSect].dwStart = dwI ;

        for(  ; pStatic->snapShotTable[dwI].dwNbytes ; dwI++ )
            ;

        prng[dwSect].dwEnd = dwI ;  // one past the last entry
    }
    return(TRUE);
}




BOOL    BinitSizeOptionTables(PBYTE  pubnRaw)
{
//    PMINIRAWBINARYDATA pmrbd  ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pStatic->pdwSizeOption = (PDWORD)
        MemAlloc(sizeof(DWORD) * MAX_GID * 2) ;
    if(!pStatic->pdwSizeOption)
        return(FALSE) ;

    pStatic->pdwSizeOptionEx = pStatic->pdwSizeOption + MAX_GID ;


    pStatic->pdwSizeOption[GID_RESOLUTION] = sizeof(RESOLUTION);
    pStatic->pdwSizeOptionEx[GID_RESOLUTION] = sizeof(RESOLUTIONEX);

    pStatic->pdwSizeOption[GID_PAGESIZE] = sizeof(PAGESIZE);
    pStatic->pdwSizeOptionEx[GID_PAGESIZE] = sizeof(PAGESIZEEX);

    pStatic->pdwSizeOption[GID_PAGEREGION] = sizeof(OPTION);
    pStatic->pdwSizeOptionEx[GID_PAGEREGION] = 0 ;

    pStatic->pdwSizeOption[GID_DUPLEX] = sizeof(DUPLEX);
    pStatic->pdwSizeOptionEx[GID_DUPLEX] = 0 ;

    pStatic->pdwSizeOption[GID_INPUTSLOT] = sizeof(INPUTSLOT);
    pStatic->pdwSizeOptionEx[GID_INPUTSLOT] = 0 ;  //  sizeof(INPUTSLOTEX);

    pStatic->pdwSizeOption[GID_MEDIATYPE] = sizeof(MEDIATYPE);
    pStatic->pdwSizeOptionEx[GID_MEDIATYPE] = 0 ;

    pStatic->pdwSizeOption[GID_MEMOPTION] = sizeof(MEMOPTION);
    pStatic->pdwSizeOptionEx[GID_MEMOPTION] = 0 ;

    pStatic->pdwSizeOption[GID_COLORMODE] = sizeof(COLORMODE);
    pStatic->pdwSizeOptionEx[GID_COLORMODE] = sizeof(COLORMODEEX);

    pStatic->pdwSizeOption[GID_ORIENTATION] = sizeof(ORIENTATION);
    pStatic->pdwSizeOptionEx[GID_ORIENTATION] = 0 ;

    pStatic->pdwSizeOption[GID_PAGEPROTECTION] = sizeof(PAGEPROTECT);
    pStatic->pdwSizeOptionEx[GID_PAGEPROTECTION] = 0 ;

    pStatic->pdwSizeOption[GID_COLLATE] = sizeof(COLLATE);
    pStatic->pdwSizeOptionEx[GID_COLLATE] = 0 ;

    pStatic->pdwSizeOption[GID_OUTPUTBIN] = sizeof(OUTPUTBIN);
    pStatic->pdwSizeOptionEx[GID_OUTPUTBIN] = 0 ;

    pStatic->pdwSizeOption[GID_HALFTONING] = sizeof(HALFTONING);
    pStatic->pdwSizeOptionEx[GID_HALFTONING] = 0 ;



    // outside array bounds.
//    pmrbd->pdwSizeOption[GID_UNKNOWN] = sizeof(OPTION);
//    pmrbd->pdwSizeOptionEx[GID_UNKNOWN] = 0 ;

    return(TRUE) ;
}


PRAWBINARYDATA
LoadRawBinaryData (
    IN PTSTR    ptstrDataFilename
    )

/*++

Routine Description:

    Load raw binary printer description data.

Arguments:

    ptstrDataFilename - Specifies the name of the original printer description file

Return Value:

    Pointer to raw binary printer description data
    NULL if there is an error

--*/

{
    //  PMINIRAWBINARYDATA pmrbd  ;
    PSTATICFIELDS   pStatic ;

    PRAWBINARYDATA  pnRawData;   //  actually points to pStatic structure
    DWORD   dwI ;
//    extern  int  giDebugLevel  ;

//    giDebugLevel = 5 ;

    //
    // Sanity check
    //


    if (ptstrDataFilename == NULL) {

        ERR(("GPD filename is NULL.\n"));
        return NULL;
    }

    //
    // Attempt to load cached binary printer description data first
    //

    if (!(pnRawData = GpdLoadCachedBinaryData(ptstrDataFilename)))
    {
        #ifndef KERNEL_MODE

        #ifdef  PARSERLIB

        (VOID) BcreateGPDbinary(ptstrDataFilename, 0) ;
                // 0 = min Verbosity Level

        pnRawData = GpdLoadCachedBinaryData(ptstrDataFilename) ;

        #else  PARSERLIB

        //
        // If there is no cached binary data or it's out-of-date, we'll parse
        // the ASCII text file and cache the resulting binary data.
        //

        DWORD  pathlen = 0 ;
        DWORD  namelen =  0 ;
        WCHAR * pwDLLQualifiedName = NULL ;

        //  WCHAR           awchDLLpath[MAX_PATH];
        PWSTR   pwstrDLLname = TEXT("gpdparse.dll") ;

        typedef BOOL    (*PFBCREATEGPDBINARY)(PWSTR, DWORD) ;
        PFBCREATEGPDBINARY  pfBcreateGPDbinary = NULL ;
        PWSTR   pwstrLastBackSlash ;
        HINSTANCE   hParser = NULL ;

        //  how large should pwDLLQualifiedName be???

        pathlen = wcslen(ptstrDataFilename) ;
        namelen =  pathlen + wcslen(pwstrDLLname)  + 1;

        if(!(pwDLLQualifiedName = (PWSTR)MemAllocZ(namelen * sizeof(WCHAR)) ))
        {
            ERR(("Fatal: unable to alloc memory for pwDLLQualifiedName: %d WCHARs.\n",
                namelen));
            return(NULL) ;   // This is unrecoverable
        }



        wcsncpy(pwDLLQualifiedName, ptstrDataFilename , namelen);

        if (pwstrLastBackSlash = wcsrchr(pwDLLQualifiedName, TEXT('\\')))
        {
            *(pwstrLastBackSlash + 1) = NUL;


            //  wcscat(pwDLLQualifiedName, pwstrDLLname) ;
            StringCchCatW(pwDLLQualifiedName, namelen, pwstrDLLname);

            hParser = LoadLibrary(pwDLLQualifiedName) ;
            if(hParser)
                pfBcreateGPDbinary = (PFBCREATEGPDBINARY)GetProcAddress(hParser, "BcreateGPDbinary") ;
            else
                ERR(("Couldn't load gpdparse.dll: %S\n", pwDLLQualifiedName)) ;

            if(pfBcreateGPDbinary)
                (VOID) pfBcreateGPDbinary(ptstrDataFilename, 0) ;
                        // 0 = min Verbosity Level

            if(hParser)
                FreeLibrary(hParser) ;

            pnRawData = GpdLoadCachedBinaryData(ptstrDataFilename) ;
        }

        if(pwDLLQualifiedName)
            MemFree(pwDLLQualifiedName) ;

        #endif  PARSERLIB
        #endif  KERNEL_MODE
    }
    if(!pnRawData)
    {
        //  there is nothing I can do about this now.
        ERR(("Unable to locate or create Binary data.\n"));
        SetLastError(ERROR_FILE_CORRUPT);
        return NULL;
    }

    pStatic = (PSTATICFIELDS)pnRawData ;

    /*  BETA2  */
//    pmrbd->rbd.pvReserved = NULL;  Do when creating BUD file.
    pStatic->pdwSizeOption = NULL ;
    pStatic->ssTableIndex  = NULL ;
    pStatic->snapShotTable = NULL ;

    //  Call initialization functions to setup a few tables
    //  needed to create snapshots.

    if(BinitSizeOptionTables((PBYTE)pnRawData)  &&
        (dwI = DwInitSnapShotTable1((PBYTE)pnRawData) )  &&
        (dwI = DwInitSnapShotTable2((PBYTE)pnRawData, dwI) )  &&
        (dwI < MAX_SNAPSHOT_ELEMENTS)  &&
        BinitSnapShotIndexTable((PBYTE)pnRawData)  )
    {
        return (pnRawData);
    }
    if(dwI >= MAX_SNAPSHOT_ELEMENTS)
        RIP(("Too many entries to fit inside SnapShotTable\n"));

    UnloadRawBinaryData (pnRawData) ;
    return (NULL);  // failure
}

PRAWBINARYDATA
GpdLoadCachedBinaryData(
    PTSTR   ptstrGpdFilename
    )

/*++

Routine Description:

    Load cached binary GPD data file into memory

Arguments:

    ptstrGpdFilename - Specifies the GPD filename

Return Value:

    Pointer to Binary GPD data if successful, NULL if there is an error
    BETA2  returns pointer to pStatic.

--*/

{
    HFILEMAP        hFileMap;
    DWORD           dwSize;
    PVOID           pvData;
    PTSTR           ptstrBpdFilename;
    PRAWBINARYDATA  pRawData ;
    PSTATICFIELDS   pstaticData = NULL;
//    PMINIRAWBINARYDATA pmrbd  ;


    //
    // Generate BPD filename from the specified PPD filename
    //

    if (! (ptstrBpdFilename = pwstrGenerateGPDfilename(ptstrGpdFilename)))
        return NULL;

    //
    // First map the data file into memory
    //

    if (! (hFileMap = MapFileIntoMemory(ptstrBpdFilename, &pvData, &dwSize)))
    {
        //  ERR(("Couldn't map file '%ws' into memory: %d\n", ptstrBpdFilename, GetLastError()));
        MemFree(ptstrBpdFilename);
        return NULL;
    }

    //
    // Verify size, parser version number, and signature.
    // Allocate a memory buffer and copy data into it.
    //

    pRawData = pvData;
//    pmrbd = (PMINIRAWBINARYDATA)pRawData ;
    pstaticData = NULL;

    if ((dwSize > sizeof(PMINIRAWBINARYDATA) +
        sizeof(ENHARRAYREF) * MTI_NUM_SAVED_OBJECTS) &&
        (dwSize >= pRawData->dwFileSize) &&
        (pRawData->dwParserVersion == GPD_PARSER_VERSION) &&
        (pRawData->dwParserSignature == GPD_PARSER_SIGNATURE) &&
        (BIsRawBinaryDataInDate((PBYTE)pRawData)) &&
        (pstaticData = MemAlloc(sizeof(STATICFIELDS))))
    {
        CopyMemory(&(pstaticData->rbd), pRawData, sizeof(RAWBINARYDATA));
            // copy only the first structure of the BUD file.
        pstaticData->hFileMap = hFileMap ;
        pstaticData->pubBUDData = (PBYTE)pRawData ;            //  BETA2
            //  this points to the entire BUD file.
    }
    else
    {
        ERR(("Invalid binary GPD data\n"));   // warning
        SetLastError(ERROR_INVALID_DATA);
        UnmapFileFromMemory(hFileMap);          //  BETA2
        MemFree(ptstrBpdFilename);
        return(NULL) ;  //  fatal error.
    }

    MemFree(ptstrBpdFilename);

    return &(pstaticData->rbd);   //  BETA2
}



VOID
UnloadRawBinaryData (
    IN PRAWBINARYDATA   pnRawData
)
{
    PSTATICFIELDS   pStatic ;
//    PMINIRAWBINARYDATA pmrbd  ;

//    pmrbd = (PMINIRAWBINARYDATA)pRawData ;
    pStatic = (PSTATICFIELDS)pnRawData ;

    if(!pnRawData)
    {
        ERR(("GpdUnloadRawBinaryData given Null ptr.\n"));
        return ;
    }

    if(pStatic->pdwSizeOption)
        MemFree(pStatic->pdwSizeOption);
    if(pStatic->ssTableIndex)
        MemFree(pStatic->ssTableIndex);
    if(pStatic->snapShotTable)
        MemFree(pStatic->snapShotTable);
    UnmapFileFromMemory(pStatic->hFileMap);          //  BETA2

    MemFree(pnRawData);
}


PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pnRawData,        // actually pStatic
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    )
{
    BOOL   bDeleteOptArray = FALSE ;

    if(pInfoHdr)
    {
        FreeBinaryData(pInfoHdr) ;
        //  there's no advantage to keeping the block
        //  if we are going to reinitialize everything.
        //  eventually we can optimize.
    }
    if(!pOptions) // if not passed from UI
    {
        bDeleteOptArray = TRUE ;

        pOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;
        if(!pOptions  ||
            !BinitDefaultOptionArray(pOptions, (PBYTE)pnRawData))
        {
            if(pOptions)
                MemFree(pOptions);
            return(NULL);  // Bummer, you lose any pInfoHdr you passed in.
        }
    }

    pInfoHdr = PINFOHDRcreateSnapshot((PBYTE)pnRawData, pOptions) ;

    if(bDeleteOptArray  &&  pOptions)
        MemFree(pOptions);

    return( pInfoHdr );
}


VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    )
{
    if(pInfoHdr)
        MemFree(pInfoHdr);
}


BOOL    BIsRawBinaryDataInDate(
IN  PBYTE   pubRaw)   // this is pointer to memory mapped file! BETA2
{
#ifdef  KERNEL_MODE

    return(TRUE);

#else   // !KERNEL_MODE

    PENHARRAYREF   pearTableContents ;
    PGPDFILEDATEINFO    pfdi ;
    DWORD   dwNumFiles, dwI ;
    BOOL    bInDate ;
    PBYTE   pubHeap ;
    PWSTR   pwstrFileName ;
    FILETIME        FileTime;
    HANDLE          hFile;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pubHeap  = pubRaw + pearTableContents[MTI_STRINGHEAP].loOffset  ;

    dwNumFiles = pearTableContents[MTI_GPDFILEDATEINFO].dwCount  ;

    pfdi = (PGPDFILEDATEINFO)(pubRaw + pearTableContents[MTI_GPDFILEDATEINFO].
                                loOffset) ;

    for(dwI = 0 ; dwI < dwNumFiles ; dwI++)
    {
        pwstrFileName = OFFSET_TO_POINTER(pubHeap, pfdi[dwI].arFileName.loOffset);
        bInDate = FALSE ;

        hFile  = CreateFile(pwstrFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                    NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (GetFileTime(hFile, NULL, NULL, &FileTime))
                bInDate = (CompareFileTime(&FileTime, &pfdi[dwI].FileTime) == 0 ) ;
            else
                ERR(("GetFileTime '%S' failed.\n", pwstrFileName));

            CloseHandle(hFile);
        }
        else {
            ERR(("CreateFile '%S' failed.\n", pwstrFileName));
        }

        if(!bInDate)
        {
            ERR(("Raw binary data file is out-of-date.\n"));
            return(FALSE) ;
        }
    }
    return(TRUE);

#endif  // !KERNEL_MODE
}



// Puts the Index of Feature Locale(if present) in *pdwFea and returns TRUE.
// If Locale not present returns TRUE and puts -1 in *pdwFea.
// Any other processing error, returns FALSE.

BOOL BgetLocFeaIndex (
    IN PRAWBINARYDATA   pnRawData,
    OUT PDWORD          pdwFea  // The index of the Locale feature
 )
{

    DWORD               dwNumFeatures,        // Total Number of features
                        dwHeapOffset;
    BOOL                bStatus = TRUE; // Warning!!!!!!.
                                        // Dont remove initialization.
    PBYTE               pubSrc,
                        pubRaw,
                        pubResourceData;

    ATREEREF            atrLocKW;
    PDFEATURE_OPTIONS   pfoSrc;
    PENHARRAYREF        pearTableContents;


    // At this point we only have the raw data which is a big structure
    // with arrays, trees etc. Function PINFOHDRcreateSnapshota()
    // goes through all the Raw Data and extracts info into well defined
    // structures from where it is easy to get the required information.
    // Unfortunately when this function is called, PINFOHDRcreateSnapshot()
    // has not been called earlier, so we are left with getting our hands
    // dirty with the raw data.
    // Since it does make sense to go through the entire raw data just to
    // get the small info that we want, we will attempt to navigate only
    // certain areas.

    pubRaw  = ((PSTATICFIELDS)pnRawData)->pubBUDData;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pubResourceData   = pubRaw + pearTableContents[MTI_STRINGHEAP].loOffset;

    pfoSrc            = (PDFEATURE_OPTIONS)(pubRaw +
                            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset);

    dwNumFeatures     = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
//    dwNumFeatures    += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    if(dwNumFeatures > MAX_COMBINED_OPTIONS)
        return FALSE;  // too many


    for ( *pdwFea = 0; bStatus && (*pdwFea < dwNumFeatures); (*pdwFea)++)
    {
        atrLocKW  = pfoSrc[*pdwFea].atrFeaKeyWord;

        if ( atrLocKW & ATTRIB_HEAP_VALUE)
        {
            // Get a pointer to the ARRAYREF structure that holds the
            // heap offset of the real string.
            pubSrc = (pubResourceData + (atrLocKW & ~ATTRIB_HEAP_VALUE));
            dwHeapOffset = *((PDWORD)&(((PARRAYREF)pubSrc)->loOffset));

        }
        else
        {

            // It can come here either
            // if (atrRoot == ATTRIB_UNINITIALIZED
            //      For a *Feature: <symbolname> to appear
            //      without <symbolname> is a syntactic error.
            //      Has to be caught earlier.
            // or if
            //     patt[dwNodeIndex].dwFeature == DEFAULT_INIT)
            // or if it points to another node.
            // These should never happen.


            // Feature keyword not initialized. Serious Problem.
            // Should have been caught in the parsing stage. Cannot continue.

            ERR(("Feature Symbol Name cannot be determined\n"));
            bStatus = FALSE;
        }
        if ( bStatus && !strncmp(LOCALE_KEYWORD,
              (LPSTR)OFFSET_TO_POINTER(pubResourceData, dwHeapOffset),
              strlen(LOCALE_KEYWORD) ) )
        {
            // FOUND.... Locale.
            break;
        }

    }  //for *pdwFea

    if (bStatus && *pdwFea == dwNumFeatures)
    {
        //Feature Locale does not appear in the GPD. Nothing to do.
       *pdwFea = (DWORD)-1;
    }

    return bStatus;

} //BgetLocFeaIndex(...)


/*++

    Returns FALSE if some processing error occurs.
    If TRUE is returned then
        i)   if dwFea = -1  --> *Feature:Locale not found.
        ii)  if dwFea != -1 but dwOptIndex = -1,  --> None of the options
             match system locale. OR for some reason we have not been
             able to determine default option. The calling function may
             handle whatever way it wants.
        iii) if neither dwFea nor dwOptIndex is -1 --> Locale feature and
             matching option index found.

    1) Check if Locale keyword appears in the .gpd. If no, return. No action is
        required. This process also gets the Index of the Locale feature
        if present,
    2) query the SystemDefaultLCID. Reason: We want to see which Locale
        option in .gpd matches the SystemLCID.
    3) Go through the option array of the Locale feature and get the Index of
        the option that has OptionId = SystemDefaultCodePage.
        IMPORTANT assumption here is that only one Option will match
        the system LCID. Multiple matching option will result in
        great ambiguity.
    4) If option not present in GPD, do nothing. return quietly.
--*/
BOOL BgetLocFeaOptIndex(
    IN     PRAWBINARYDATA   pnRawData,
       OUT PDWORD           pdwFea,      // Assuming space already allocated.
       OUT PDWORD           pdwOptIndex  // Assuming space already allocated.
    )

{
    DWORD           dwNumFeatures,  // Total features
                    dwNumOptions,   // Total number of options for a feature.
                                    // dwOptionID
                    dwValue;        //

    ATREEREF        atrOptIDRoot,   // Root of OptionID attrib tree.
                                    // The OptionID (which is = the LCID)
                                    // is determined by following tree rooted
                                    // at atrOptIDRoot
                    atrOptIDNode;   // The heap pointer ( leaf of the tree).
    LCID            lcidSystemLocale; // The System locale


    PENHARRAYREF        pearTableContents;
    PBYTE               pubnRaw,
                        pubRaw;
    PDFEATURE_OPTIONS   pfo;
    PBYTE               pubHeap;
    PATTRIB_TREE        patt;

    pubRaw  = ((PSTATICFIELDS)pnRawData)->pubBUDData;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;


    pfo = (PDFEATURE_OPTIONS) (pubRaw +
                        pearTableContents[MTI_DFEATURE_OPTIONS].loOffset);

    // 1. Extract index of feature locale from raw data
    if ( !BgetLocFeaIndex(pnRawData, pdwFea))
        return FALSE; //Big Time Error.

    if (*pdwFea == -1) {
        return TRUE; //indicates nothing to do. For reasons go into the
                     // function dwGetLocFeaIndex
    }

    lcidSystemLocale = LOCALE_SYSTEM_DEFAULT;

    #ifndef WINNT_40
    // 2) Determine the locale(LCID) and put it in lcidSystemLocale
    if ( ! (lcidSystemLocale = GetSystemDefaultLCID() ) )
    {
        ERR(("Cannot determine System locale\n") );

        *pdwOptIndex = (DWORD)-1; //No matching option found.
        return TRUE;
    }
    #endif //ifndef WINNT_40

    // 3. Get Index (dwOptIndex) of Option whose OptionID = lcidSystemLocale


    patt = (PATTRIB_TREE)(pubRaw + pearTableContents[MTI_ATTRIBTREE].
                        loOffset) ;

    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                        loOffset) ;

    // Pointer to root of atrOptIdvalue tree (or list)
    atrOptIDRoot = pfo[*pdwFea].atrOptIDvalue;
    if(atrOptIDRoot == ATTRIB_UNINITIALIZED)
    {
        // GPD is coded incorrectly though it may be correct syntactically.
        // The reason for the error is :
        // Every option for the Locale Feature
        // has to have an OptionID that matches the LCID values as
        // specified in Win32. If *OptionID field does not appear in
        // the Option construct, it is an inexcusable error.
        // Instead of failing, let us just indicate that we have not been
        // able to determine the default option i.e. *pdwOptIndex = -1.

        *pdwOptIndex = (DWORD)-1;
        return TRUE; // or should it be FALSE

    }

    else if (atrOptIDRoot & ATTRIB_HEAP_VALUE)
    {
        // It cannot appear here.
        // Because *OptionID is ATT_LOCAL_OPTION_ONLY
        // Instead of failing, let us prefer to continue
        ERR(("OptionID for Feature Locale cannot be determined\n"));
        *pdwOptIndex = (DWORD)-1;
        return TRUE;
    }

    else if (patt[atrOptIDRoot].dwFeature == DEFAULT_INIT)
    {
        if ( patt[atrOptIDRoot].dwNext == END_OF_LIST)
        {
            *pdwOptIndex = (DWORD)-1;
            return TRUE;
        }

        atrOptIDRoot = patt[atrOptIDRoot].dwNext ;  // to the next node.
    }

    for(; atrOptIDRoot != END_OF_LIST;
                     atrOptIDRoot = patt[atrOptIDRoot].dwNext)
    {
        // Should not be anything else.
        if( patt[atrOptIDRoot].eOffsetMeans == VALUE_AT_HEAP)
        {
            atrOptIDNode = patt[atrOptIDRoot].dwOffset;
            dwValue = *(PDWORD)(pubHeap + atrOptIDNode );
            if (dwValue == (DWORD)lcidSystemLocale)
               // Found the option with matching LCID
            {
                *pdwOptIndex = patt[atrOptIDRoot].dwOption;
                break;
            }

        } //if
        else
        {
            ERR(("OptionID for Feature Locale cannot be determined\n"));
            *pdwOptIndex = (DWORD)-1;
            return TRUE;
        }
    } // for

    // 4. Option not present in GPD i.e. Matching locale not found
    //    Let the default as specified in GPD continue as default.

    if ( atrOptIDRoot == END_OF_LIST)
    {
        *pdwOptIndex = (DWORD)-1;

    }

    return TRUE;

} //BgetLocFeaOptIndex


#endif  PARSERDLL

BOOL   BfindMatchingOrDefaultNode(
IN  PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
IN  OUT  PDWORD  pdwNodeIndex,  // Points to first node in chain
IN  DWORD   dwOptionID     //  may even take on the value DEFAULT_INIT
)
/*  caller passes a NodeIndex that points to the first node in
    a horizontal (option) chain.  Caller finds via optionarray
    the corresponding dwOption that is associated with this
    feature.
    search horizontally along the tree searching for a matching
    option.  If found, return the index of that node, else see
    if there is a default initializer node at the end of the chain.
*/
{
    for(   ; FOREVER ; )
    {
        if(patt[*pdwNodeIndex].dwOption == dwOptionID )
        {
            //  we found it!
            return(TRUE) ;
        }
        if(patt[*pdwNodeIndex].dwNext == END_OF_LIST)
        {
            if(patt[*pdwNodeIndex].dwOption == DEFAULT_INIT )
                return(TRUE) ;
            return(FALSE) ;
        }
        *pdwNodeIndex = patt[*pdwNodeIndex].dwNext ;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\semanchk.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    semanchk.c

Abstract:

    function for checking GPD semantics which involves dependency between
    entries.

Environment:

    user-mode only.

Revision History:

    02/15/97 -zhanw-
        Created it.

--*/

#ifndef KERNEL_MODE

#include "gpdparse.h"


// ----  functions defined in semanchk.c ---- //

BOOL
BCheckGPDSemantics(
    IN PINFOHEADER  pInfoHdr,
    POPTSELECT   poptsel   // assume fully initialized
    ) ;

// ------- end function declarations ------- //


BOOL
BCheckGPDSemantics(
    IN PINFOHEADER  pInfoHdr,
    POPTSELECT   poptsel   // assume fully initialized
    )
/*++
Routine Description:
    This function checks if the given snapshot makes sense. It covers only
    conditionally required entries and printing commands since other
    statically required entries are already covered by snapshot functions.

Arguments:
    pInfoHdr: pointer to INFOHEADER structure.

Return Value:
    TRUE if the semantics is correct. Otherwise, FALSE.

--*/
{
    DWORD   dwFeaIndex, dwI, dwNumOpts, dwListIndex ,
            dwMoveUnitsX, dwMoveUnitsY, dwResX, dwResY ;
    BOOL    bStatus = TRUE ;  // until fails.
    PGPDDRIVERINFO  pDrvInfo ;
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;


    if(!pInfoHdr)
        return  FALSE ;
    pDrvInfo = (PGPDDRIVERINFO) GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHdr) ;
    if(!pDrvInfo)
        return  FALSE ;
    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    if(!pUIInfo)
        return  FALSE ;


//  Fix for bug 6774

    if(pUIInfo->dwPrintRate  &&  (pUIInfo->dwPrintRateUnit == INVALID_INDEX))
    {
        ERR(("*PrintRateUnit must be present if *PrintRate exists.\n")) ;
        bStatus = FALSE ;
    }
//  end fix for bug 6774

    //
    // 1. global printing entries
    //
    // - *MemoryUsage cannot be an empty list if *Memory feature exists.
    //
    // - *XMoveUnit (*YMoveUnit) must be non-trivial (greater than 1) if
    //   there is any x-move (y-move) command.
    //
    // - *DefaultFont cannot be 0 if *DeviceFonts is not an empty list.
    //
    // - CmdCR, CmdLF, and CmdFF are always required.
    //



    if(BGIDtoFeaIndex(pInfoHdr , &dwFeaIndex , GID_MEMOPTION )  &&
            (pDrvInfo->Globals.liMemoryUsage == END_OF_LIST) )
    {
        ERR(("*MemoryUsage cannot be an empty list if *Memory feature exists.\n")) ;
#ifdef  STRICT_CHECKS
        bStatus = FALSE ;
#endif
    }


    if((COMMANDPTR(pDrvInfo , CMD_XMOVEABSOLUTE ) ||
        COMMANDPTR(pDrvInfo , CMD_XMOVERELLEFT ) ||
        COMMANDPTR(pDrvInfo , CMD_XMOVERELRIGHT ))  &&
        pDrvInfo->Globals.ptDeviceUnits.x <= 1)
    {
        ERR(("*XMoveUnit must be > 1 if any x-move command exists.\n")) ;
        bStatus = FALSE ;
    }

    if((COMMANDPTR(pDrvInfo , CMD_YMOVEABSOLUTE ) ||
        COMMANDPTR(pDrvInfo , CMD_YMOVERELUP ) ||
        COMMANDPTR(pDrvInfo , CMD_YMOVERELDOWN ))  &&
        pDrvInfo->Globals.ptDeviceUnits.y <= 1)
    {
        ERR(("*YMoveUnit must be > 1 if any y-move command exists.\n")) ;
        bStatus = FALSE ;
    }

    if((pDrvInfo->Globals.liDeviceFontList != END_OF_LIST)  &&
            (pDrvInfo->Globals.dwDefaultFont == 0) )
    {
        ERR(("*DefaultFont cannot be 0 if *DeviceFonts is not an empty list.\n")) ;
#ifdef  STRICT_CHECKS
        bStatus = FALSE ;
#endif
    }

    if (!COMMANDPTR(pDrvInfo , CMD_FORMFEED ) ||
        !COMMANDPTR(pDrvInfo , CMD_CARRIAGERETURN ) ||
        !COMMANDPTR(pDrvInfo , CMD_LINEFEED )  )
    {
        ERR(("CmdCR, CmdLF, and CmdFF are always required.\n")) ;
        bStatus = FALSE ;
    }

    //  are there an integral number of master units per
    //  moveunit?

    if( pDrvInfo->Globals.ptMasterUnits.x %
        pDrvInfo->Globals.ptDeviceUnits.x )
    {
        ERR(("Must be whole number of master units per x move unit.\n")) ;
        bStatus = FALSE ;
    }
    if( pDrvInfo->Globals.ptMasterUnits.y %
        pDrvInfo->Globals.ptDeviceUnits.y )
    {
        ERR(("Must be whole number of master units per y move unit.\n")) ;
        bStatus = FALSE ;
    }

    if(pDrvInfo->Globals.ptDeviceUnits.x > 1)
    {
        dwMoveUnitsX = pDrvInfo->Globals.ptMasterUnits.x /
            pDrvInfo->Globals.ptDeviceUnits.x ;
    }
    else
        dwMoveUnitsX = 1 ;

    if(pDrvInfo->Globals.ptDeviceUnits.y > 1)
    {
        dwMoveUnitsY = pDrvInfo->Globals.ptMasterUnits.y /
            pDrvInfo->Globals.ptDeviceUnits.y ;
    }
    else
        dwMoveUnitsY = 1 ;

    if(!dwMoveUnitsX  ||  !dwMoveUnitsY)
    {
        ERR(("master units cannot be coarser than  X or Y MoveUnit.\n")) ;
        return  FALSE ;
    }


    //
    // 2. printing commands
    //
    // - if *XMoveThreshold (*YMoveThreshold) is 0, then CmdXMoveAbsolute
    //   (CmdYMoveAbsolute) must exist. Similarly, if *XMoveThreshold
    //   (*YMoveThreshold) is *, then CmdXMoveRelRight (CmdYMoveRelDown and
    //   (CmdYMoveRelUp) must exist.
    //

#if 0
    //  if Threshold is omitted by user, its set to 0 by default
    //  by the snapshot code.  So this check will fail when
    //  everything is ok.


    if((pDrvInfo->Globals.dwXMoveThreshold == 0)  &&
        !COMMANDPTR(pDrvInfo , CMD_XMOVEABSOLUTE ))
    {
        ERR(("*CmdXMoveAbsolute must exist if *XMoveThreshold is 0.\n")) ;
        bStatus = FALSE ;
    }

    if((pDrvInfo->Globals.dwYMoveThreshold == 0)  &&
        !COMMANDPTR(pDrvInfo , CMD_YMOVEABSOLUTE ))
    {
        ERR(("*CmdYMoveAbsolute must exist if *YMoveThreshold is 0.\n")) ;
        bStatus = FALSE ;
    }
#endif


    if((pDrvInfo->Globals.dwXMoveThreshold == WILDCARD_VALUE)  &&
        !COMMANDPTR(pDrvInfo , CMD_XMOVERELRIGHT ) )
    {
        ERR(("XMoveRelativeRight must exist if *XMoveThreshold is *.\n")) ;
        bStatus = FALSE ;
    }

    if((pDrvInfo->Globals.dwYMoveThreshold == WILDCARD_VALUE)  &&
        !COMMANDPTR(pDrvInfo , CMD_YMOVERELDOWN ))
    {
        ERR(("YMoveRelativeDown must exist if *YMoveThreshold is *.\n")) ;
        bStatus = FALSE ;
    }

    // - CmdSendBlockData must exist if *PrinterType is not TTY.

    if((pDrvInfo->Globals.printertype != PT_TTY)  &&
        !COMMANDPTR(pDrvInfo , CMD_SENDBLOCKDATA ))
    {
        ERR(("*CmdSendBlockData must exist if *PrinterType is not TTY.\n")) ;
        bStatus = FALSE ;
    }


    //
    // - CmdSetFontID, CmdSelectFontID, CmdSetCharCode must be consistent
    //   in their presence (i.e. all or none). Furthermore, if
    //   CmdSetFontID/CmdSelectFontID/CmdSetCharCode all exist, then
    //   *FontFormat must be one of the pre-defined constants.
    //
    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_SETFONTID ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_SELECTFONTID ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_SETCHARCODE ) )
        dwI++ ;

    if(dwI  &&  dwI != 3)
    {
        ERR(("CmdSetFontID, CmdSelectFontID, CmdSetCharCode must be present or absent together.\n")) ;
        bStatus = FALSE ;
    }

    if((dwI == 3)  && (pDrvInfo->Globals.fontformat == UNUSED_ITEM) )
    {
        ERR(("if font cmds exist, then *FontFormat must be defined\n")) ;
        bStatus = FALSE ;
    }


    // - CmdBoldOn and CmdBoldOff must be paired (i.e. both or none). The
    //   same goes for:
    //      CmdItalicOn & CmdItalicOff,
    //      CmdUnderlineOn & CmdUnderlineOff,
    //      CmdStrikeThruOn & CmdStrikeThruOff,
    //      CmdWhiteTextOn & CmdWhiteTextOff,
    //      CmdSelectSingleByteMode & CmdSelectDoubleByteMode,
    //      CmdVerticalPrintingOn/CmdVerticalPrintingOff.
    //
    // - CmdSetRectWidth and CmdSetRectHeight must be paired.
    //

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_BOLDON ) )
        dwI++ ;
    if(dwI  &&  (COMMANDPTR(pDrvInfo , CMD_BOLDOFF ) ||
            COMMANDPTR(pDrvInfo , CMD_CLEARALLFONTATTRIBS )) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdBoldOn and CmdBoldOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_ITALICON) )
        dwI++ ;
    if(dwI  &&  (COMMANDPTR(pDrvInfo , CMD_ITALICOFF ) ||
                COMMANDPTR(pDrvInfo , CMD_CLEARALLFONTATTRIBS )) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdItalicOn & CmdItalicOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_UNDERLINEON ) )
        dwI++ ;
    if(dwI  &&  (COMMANDPTR(pDrvInfo , CMD_UNDERLINEOFF ) ||
                COMMANDPTR(pDrvInfo , CMD_CLEARALLFONTATTRIBS )) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdUnderlineOn & CmdUnderlineOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_STRIKETHRUON ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_STRIKETHRUOFF ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdStrikeThruOn & CmdStrikeThruOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_WHITETEXTON ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_WHITETEXTOFF ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdWhiteTextOn & CmdWhiteTextOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_SELECTSINGLEBYTEMODE ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_SELECTDOUBLEBYTEMODE ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdSelectSingleByteMode & CmdSelectDoubleByteMode must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_VERTICALPRINTINGON ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_VERTICALPRINTINGOFF ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdVerticalPrintingOn/CmdVerticalPrintingOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_SETRECTWIDTH ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_SETRECTHEIGHT ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdSetRectWidth and CmdSetRectHeight must be paired.\n")) ;
        bStatus = FALSE ;
    }



    //  Note because this check involves looking at the command table
    //  which is snapshot specific, we cannot perform this for every
    //  option as Zhanw requested.  Only the current option.
    //
    // 3. special entries in various types of *Option constructs
    //
    // - For each ColorMode option whose *DevNumOfPlanes is greater than 1,
    //   *ColorPlaneOrder cannot be an empty list.
    //
    // - For each ColorMode option whose *DevNumOfPlanes is greater than 1,
    //   and *DevBPP is 1, search through its *ColorPlaneOrder list:
    //   if YELLOW is in the list, then CmdSendYellowData must exist. The
    //   same goes for other colors: MAGENTA, CYAN, BLACK, RED, GREEN, BLUE.

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;

    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_COLORMODE) ;
    if(pFeature)
    {
        PCOLORMODE      pColorMode ;
        PCOLORMODEEX    pCMex ;
        PLISTNODE       pLNode ;
        DWORD           dwOptIndex ;


        dwNumOpts = pFeature->Options.dwCount ;

        pColorMode = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset ) ;

        if(BGIDtoFeaIndex(pInfoHdr , &dwFeaIndex , GID_COLORMODE ) )
        {
            dwOptIndex = poptsel[dwFeaIndex].ubCurOptIndex ;


            pCMex = OFFSET_TO_POINTER(pInfoHdr,
                    pColorMode[dwOptIndex].GenericOption.loRenderOffset) ;

            if((pCMex->dwPrinterNumOfPlanes > 1)  &&
                (pCMex->liColorPlaneOrder == END_OF_LIST) )
            {
                ERR(("*ColorPlaneOrder must be specified if *DevNumOfPlanes > 1.\n")) ;
                bStatus = FALSE ;
            }
            if((pCMex->dwPrinterNumOfPlanes > 1)  &&
                (pCMex->dwPrinterBPP == 1) )
            {
                for(dwListIndex = pCMex->liColorPlaneOrder ;
                    pLNode = LISTNODEPTR(pDrvInfo  , dwListIndex ) ;
                    dwListIndex = pLNode->dwNextItem)
                {
                    switch(pLNode->dwData)
                    {
                        case COLOR_YELLOW:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDYELLOWDATA))
                            {
                                ERR(("*CmdSendYellowData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_MAGENTA:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDMAGENTADATA))
                            {
                                ERR(("*CmdSendMagentaData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_CYAN:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDCYANDATA))
                            {
                                ERR(("*CmdSendCyanData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_BLACK:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDBLACKDATA))
                            {
                                ERR(("*CmdSendBlackData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_RED:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDREDDATA))
                            {
                                ERR(("*CmdSendRedData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_GREEN:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDGREENDATA))
                            {
                                ERR(("*CmdSendGreenData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_BLUE:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDBLUEDATA))
                            {
                                ERR(("*CmdSendBlueData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        default:
                        {
                            ERR(("Unrecogized color.\n")) ;
                            bStatus = FALSE ;
                            break ;
                        }
                    }
                }
            }
        }
    }

    dwResX = dwResY = 1 ;  // default in case something goes wrong.

    if(BGIDtoFeaIndex(pInfoHdr , &dwFeaIndex , GID_RESOLUTION ) )
    {
        pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_RESOLUTION) ;
        if(pFeature)
        {
            PRESOLUTION      pRes ;
            DWORD           dwOptIndex ;

            dwOptIndex = poptsel[dwFeaIndex].ubCurOptIndex ;
            dwNumOpts = pFeature->Options.dwCount ;


            pRes = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset ) ;

            for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
            {

                if( pDrvInfo->Globals.ptMasterUnits.x < pRes[dwI].iXdpi )
                {
                    ERR(("master units  cannot be coarser than  x res unit.\n")) ;
                    return FALSE ;        //  fatal error
                }
                if( pDrvInfo->Globals.ptMasterUnits.x % pRes[dwI].iXdpi )
                {
                    ERR(("Must be whole number of master units per x res unit.\n")) ;
                    bStatus = FALSE ;
                }

                if( pDrvInfo->Globals.ptMasterUnits.y < pRes[dwI].iYdpi )
                {
                    ERR(("master units  cannot be coarser than  y res unit.\n")) ;
                    return FALSE ;
                }
                if ( pDrvInfo->Globals.ptMasterUnits.y %  pRes[dwI].iYdpi )
                {
                    ERR(("Must be whole number of master units per y res unit.\n")) ;
                    bStatus = FALSE ;
                }
            }

            //  number of master units per resolution unit.

            dwResX = pDrvInfo->Globals.ptMasterUnits.x /
                        pRes[dwOptIndex].iXdpi ;
            dwResY = pDrvInfo->Globals.ptMasterUnits.y /
                        pRes[dwOptIndex].iYdpi ;
        }
    }
    else
    {
        ERR(("Resolution is a required feature.\n")) ;
    }




    //
    // - For each non-standard Halftone option, *rcHPPatternID must be
    //   greater than 0 and *HTPatternSize must be a pair of postive integers.
    //   NOTE: check with DanielC --- should we enforce that xSize==ySize?
    //

    //  Halftone check is performed in BinitSpecialFeatureOptionFields
    //  see postproc.c

    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE) ;
    if(pFeature)
    {
        PPAGESIZE      pPagesize ;
        PPAGESIZEEX    pPageSzEx ;

        dwNumOpts = pFeature->Options.dwCount ;

        pPagesize = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset ) ;

        for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
        {
            if(GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGEPROTECTION)  &&
                    !pPagesize[dwI].dwPageProtectionMemory)
            {
                ERR(("*PageProtectMem must be greater than 0 if PageProtect feature exists.\n")) ;
#ifdef  STRICT_CHECKS
                bStatus = FALSE ;
#endif
                break ;
            }
            pPageSzEx = OFFSET_TO_POINTER(pInfoHdr,
                    pPagesize[dwI].GenericOption.loRenderOffset) ;
            if(pPagesize[dwI].dwPaperSizeID != DMPAPER_USER)
            {
                INT   iPDx, iPDy ;  // holds page dimensions
                    // in same coordinate system as ImageableArea

                if(pPageSzEx->bRotateSize)
                {
                    iPDx = (INT)pPagesize[dwI].szPaperSize.cy ;
                    iPDy = (INT)pPagesize[dwI].szPaperSize.cx ;
                }
                else
                {
                    iPDx = (INT)pPagesize[dwI].szPaperSize.cx ;
                    iPDy = (INT)pPagesize[dwI].szPaperSize.cy ;
                }

                if((iPDx  <=  0)  ||  (iPDy  <=  0))
                {
                    ERR(("*PageDimensions is required for non-standard sizes.\n")) ;
                    bStatus = FALSE ;
                    break ;
                }
                if(((INT)pPageSzEx->szImageArea.cx  <=  0)  ||
                    ((INT)pPageSzEx->szImageArea.cy  <=  0) )
                {
                    ERR(("*PrintableArea is required and must be positive.\n")) ;
                    bStatus = FALSE ;
                    break ;
                }
                if(((INT)pPageSzEx->ptImageOrigin.x  <  0)  ||
                    ((INT)pPageSzEx->ptImageOrigin.y  <  0) )

                {
                    ERR(("*PrintableOrigin is required and cannot be negative.\n")) ;
                    bStatus = FALSE ;
                    break ;
                }

                if((pPageSzEx->szImageArea.cx % dwResX)  ||
                    (pPageSzEx->szImageArea.cy % dwResY) )
                {
                    ERR(("*PrintableArea must be a integral number of ResolutionUnits.\n")) ;
#ifdef  STRICT_CHECKS
                    bStatus = FALSE ;
#endif
                    break ;
                }
                if((pPageSzEx->ptImageOrigin.x % dwResX)  ||
                    (pPageSzEx->ptImageOrigin.y % dwResY) )
                {
                    ERR(("*PrintableOrigin must be a integral number of ResolutionUnits.\n")) ;
#ifdef  STRICT_CHECKS
                    bStatus = FALSE ;
#endif
                    break ;
                }


                if(pDrvInfo->Globals.bRotateCoordinate)
                {   //  zhanw assumes printing offset is zero otherwise
                    if((pPageSzEx->ptImageOrigin.x % dwMoveUnitsX)  ||
                        (pPageSzEx->ptImageOrigin.y % dwMoveUnitsY) )

                    {
                        ERR(("*PrintableOrigin must be a integral number of MoveUnits.\n")) ;
#ifdef  STRICT_CHECKS
                        bStatus = FALSE ;
#endif
                        break ;
                    }
                    if((pPageSzEx->ptPrinterCursorOrig.x % dwMoveUnitsX)  ||
                        (pPageSzEx->ptPrinterCursorOrig.y % dwMoveUnitsY) )

                    {
                        ERR(("*CursorOrigin must be a integral number of MoveUnits.\n")) ;
#ifdef  STRICT_CHECKS
                        bStatus = FALSE ;
#endif
                        break ;
                    }
                }
                else if((pPageSzEx->ptImageOrigin.x != pPageSzEx->ptPrinterCursorOrig.x)  ||
                        (pPageSzEx->ptImageOrigin.y != pPageSzEx->ptPrinterCursorOrig.y) )

                {
                    ;  // this may be unnecessary.
//                    ERR(("For non-rotating printers, *PrintableOrigin should be same as *CursorOrigin.\n")) ;
                }

                if((iPDx + iPDx/100 <  pPageSzEx->szImageArea.cx + pPageSzEx->ptImageOrigin.x)   ||
                    (iPDy + iPDy/100 <  pPageSzEx->szImageArea.cy + pPageSzEx->ptImageOrigin.y) )
                {
                    //  I give up to 1 percent leeway
                    ERR(("*PrintableArea must be contained within *PageDimensions.\n")) ;
                    bStatus = FALSE ;
                    break ;
                }
            }
            else    //  (dwPaperSizeID == DMPAPER_USER)
            {
                if(((INT)pPageSzEx->ptMinSize.x  <=  0)  ||
                    ((INT)pPageSzEx->ptMinSize.y  <=  0) )
                {
                    ERR(("If User Defined papersize exists *MinSize is required and must be positive.\n")) ;
#ifdef  STRICT_CHECKS
                    bStatus = FALSE ;
#endif
                }
                if(((INT)pPageSzEx->ptMaxSize.x  <=  0)  ||
                    ((INT)pPageSzEx->ptMaxSize.y  <=  0) )
                {
                    ERR(("If User Defined papersize exists *MaxSize is required and must be positive.\n")) ;
                    bStatus = FALSE ;
                }
                if((INT)pPageSzEx->dwMaxPrintableWidth  <=  0)
                {
                    ERR(("If User Defined papersize exists *MaxPrintableWidth is required and must be positive.\n")) ;
                    bStatus = FALSE ;
                }
            }
        }
    }



    // - For each PaperSize option, *PageProtectMem must be greater than 0
    //   if PageProtect feature exists.
    //
    // - For all non-CUSTOMSIZE PaperSize options, *PrintableArea and
    //   *PrintableOrigin must be explicitly defined. Specifically,
    //   *PrintableArea must be a pair of positive integers, and
    //   *PrintableOrigin must be a pair of non-negative integers.
    //   note:  BInitSnapshotTable function assigns
    //   UNUSED_ITEM (-1) as the default value for *PrintableOrigin.
    //
    // - For CUSTOMSIZE option, *MinSize, *MaxSize, and *MaxPrintableWidth
    //   must be explicitly defined. Specifically, both *MinSize and *MaxSize
    //   must be a pair of positive integers. *MaxPrintableWidth must be a
    //   positive integer.
    //   BInitSnapshotTable function assigns 0 (instead of NO_LIMIT_NUM)
    //   as the default value for *MaxPrintableWidth.
    //
    // - For all non-standard non-CUSTOMSIZE PaperSize options, *PageDimensions
    //   must be explicitly defined. Specifically, it must be a pair of positive
    //   integers.
    //
    // - For any feature or option, if *Installable entry is TRUE, then
    //   either *InstallableFeatureName or *rcInstallableFeatureNameID must
    //   be present in that particular feature or option construct.
    //
    // - If any feature or option has *Installable being TRUE, then
    //   either *InstalledOptionName/*NotInstalledOptionName or
    //   *rcInstalledOptionNameID/*rcNotInstalledOptionNameID must be
    //   defined at the root level.
    //

    //   once synthetic features are created by BCreateSynthFeatures()
    //  they undergo the same checks at createsnapshot time as
    //  other features, triggering a warning if the Names of the feature and
    //  its options are absent.
#if 1
    {
        DWORD   dwNumFea, dwFea, dwNumOpt, dwOpt, dwOptSize ;
        PENHARRAYREF   pearTableContents ;
        PBYTE   pubRaw ;  //  raw binary data.
        PBYTE   pubOptions ;    // points to start of array of OPTIONS
        PFEATURE    pFea ;
        PBYTE   pubnRaw ; //  Parser's raw binary data.
        PSTATICFIELDS   pStatic ;

        pubnRaw = pInfoHdr->RawData.pvPrivateData ;
        pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
        pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

        pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

        dwNumFea = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;

        pFea = (PFEATURE)((PBYTE)pInfoHdr + pUIInfo->loFeatureList) ;

        for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
        {
            if(!pFea[dwFea].iHelpIndex)
            {
                ERR(("*HelpIndex must be positive.\n")) ;
                bStatus = FALSE ;
            }

            dwNumOpt = pFea[dwFea].Options.dwCount ;
            pubOptions = (PBYTE)pInfoHdr + pFea[dwFea].Options.loOffset ;
            dwOptSize = pFea[dwFea].dwOptionSize ;

            for(dwOpt = 0 ; dwOpt < dwNumOpt ; dwOpt++)
            {
                if(!((POPTION)(pubOptions + dwOptSize * dwOpt))->iHelpIndex )
                {
                    ERR(("*HelpIndex must be positive.\n")) ;
                    bStatus = FALSE ;
                }
            }
        }
    }
#else
    {
        DWORD   dwNumFea, dwFea, dwNumOpt, dwOpt;
        PENHARRAYREF   pearTableContents ;
        PBYTE   pubRaw ;  //  raw binary data.
        PBYTE   pubOptions ;    // points to start of array of OPTIONS
        PFEATURE    pFea ;

        pubRaw = pInfoHdr->RawData.pvPrivateData ;

        pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

        dwNumFea = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;

        for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
        {
            pFea = PGetIndexedFeature(pUIInfo, dwFea) ;

            if(!pFea->iHelpIndex)
            {
                ERR(("*HelpIndex must be positive.\n")) ;
                bStatus = FALSE ;
            }

            dwNumOpt = pFea->Options.dwCount ;

            for(dwOpt = 0 ; dwOpt < dwNumOpt ; dwOpt++)
            {
                pubOptions = PGetIndexedOption(pUIInfo, pFea, dwOpt);

                if(!((POPTION)pubOptions))->iHelpIndex )
                {
                    ERR(("*HelpIndex must be positive.\n")) ;
                    bStatus = FALSE ;
                }
            }
        }
    }

#endif
    return (bStatus);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\sources.inc ===
!IF 0

Copyright (c) 1996 - 1999  Microsoft Corporation

Common sources shared by both um and km directory


!ENDIF

SOURCES=..\gpd.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\parser.c ===
notes:

identify functions that can be used in both
user mode and km  to perform
   memory mapped file read, write
   memory allocation
      what is memory scheme used by NT?
      how do you realloc memory and still retain
      the same starting address if all memory segments share
      the linear address space?

      use HeapAlloc?  Cannot use virtualalloc()

      just so I can start writing code assume:

      base_pointer = VirtualAlloc(NULL, max_size_in_bytes, MEM_RESERVE,
         PAGE_NOACCESS) ;
      pointer = VirtualAlloc(base_pointer, size_needed_in_bytes, MEM_COMMIT,
         PAGE_READWRITE) ;
      as you need more memory, just commit more and more until
         max_size is reached.
      VirtualFree(pointer)

Set up build env to create dll, make file, dependencies
etc.

----
typedef  struct
{
}  GPD, *PGPD;  // structure containing raw GPD data

/* ----
 *  new prefixes:
 *      gpd: a GPD structure
 *      pgpd:  ptr to GPD structure
 */


allocate memory for all scaffold structures.
Allocate more memory than the structure will need since
reallocation may be impossible.  All structures may be
carved from one gigantic block of memory.

Initialize a master table to keep track of all structures.
The master table is an array of entries of the form:

struct  _MASTER_TABLE_ENTRY
{
    PBYTE  pubStruct ;  // address of element zero of array
    DWORD  dwArraySize ;  // number of elements that can fit into memory
                //  set to MAX_SYMBOLNODES for [SYMBOLTREE]
    DWORD   dwCurIndex ;  //  points to first uninitialized element
    DWORD   dwElementSiz ;  // size of each element in array.
}  MASTERTABENTRY ;

all offsets are to each individual array.  There is no
master offset.

MASTERTAB_ENTRY   gMasterTable[MTI_MAX_ENTRIES] ;

Bufffers needed for:

typedef enum
{
    MTI_SOURCEBUFFER:  Source file (GPD  input stream)
        not sure how memory mapped files and recursive includes
        will alter this.
    MTI_STRINGHEAP:  String heap
    MTI_TOKENMAP:  tokenMap   large enough to hold an old and New copy!
    MTI_NEWTOKENMAP:  newtokenMap   (not a separate buffer from TOKENMAP -
        just points immediately after oldTokenMap).
    MTI_SYMBOLTREE:  symbolTree Array
    MTI_BLOCKMACROARRAY (one for Block and another for Value macros)
    MTI_DFEATURE_OPTIONS:  references a whole bunch of treeroots.
        should be initialized to ATTRIB_UNINITIALIZED values.
        SymbolID pointed to by dwFeatureSymbols contains largest
        array index appropriated.  We won't need to allocate
        more elements in the final array than this.
    MTI_TTFONTSUBTABLE:  array of arrayrefs and integers.
    MTI_GLOBALATTRIB:   structure holding value of global attributes.
    MTI_ATTRIBTREE:  array of ATTRIB_TREE structures.
    MTI_COMMANDTABLE:  array of PATREEREF (or DWORD indicies to COMMAND_ARRAY)
            // the size of this table is set by the number of
            // predefined Unidrv commands.
    MTI_COMMANDARRAY:  array of COMMAND structures.
            // size varies depending on number of commands and variants
            // defined in the GPD file.
    MTI_FONTCART:   array of FontCartridge structures - one per construct.
    MTI_LISTNODES:   array of LISTNODEs.
    MTI_MAX_ENTRIES:  Last entry.
}  MT_INDICIES ;


Note:  the prefix  MTI_ stands for MasterTableIndex, the
base portion of the name is the structure typedef.

BLOCKMACROARRAY  is an array of structs temporarily carved into
a buffer:
typedef  struct
{
    DWORD  tIndexID;  tokenindex where a macro ID value is stored
    DWORD  tIndexOpen;  index of open brace
    DWORD  tIndexClose;  index of closing brace
} BLOCKMACROARRAY ;



each dword contains the tokenIndex where a macro ID value is stored.
curBlockMacroArray points to the smallest index of the macroArray currently
uninitialized.   (initially  curBlockMacroArray = 0)

VALUEMACROARRAY  is an array of DWORDS holding a
    tokenindex where a valuemacro ID value is stored

MACROLEVELSTACK:   is operated as a two dword stack that saves the
values of curBlockMacroArray and curValueMacroArray , each time
a brace is encountered.

-------

increaseMacroLevel():   called in response to parsing open brace.
    Copy this entry to the newtokenarray .
    save the value of curBlockMacroArray and curValueMacroArray in the
    macrolevelstack.  we will use this later.
    check if this brace begins the definition of a blockmacro,
    this is easy to do.
    if( curBlockMacroArray  &&
        (BlockMacroArray[curBlockMacroArray - 1].tIndexOpen == -1))
    {
        yes, we are beginning a BlockMacro definition.
        record newtokenArray index of open brace entry in tIndexOpen.
        check to see tIndexOpen is one higher than tIndexID, else
        a syntax error needs to be flagged for this blockMacro.
    }

decreaseMacroLevel:  called in response to parsing close brace.
    temporarily save curBlockMacroArray and curValueMacroArray
    into temp vars largerBlockIndex and largerValueIndex.

    now pop the value of curBlockMacroArray and curValueMacroArray from the
    stack.
    locate all macros referenced in the macroarray (less than largerIndex,
    and greater than or equal to curMacroArray retrieved from stack)
    that are expired due to the change in level.  Delete their entries
    in the tokenmap by replacing their  tkKeyID by NULLKEY.  This
    will break the endless chain resulting when a macro defines another
    macro.

    Does this closing brace end a macro definition?
    if(MacroArray[curMacroArray - 1].tIndexClose == -1)   //yes
    {
        MacroArray[curMacroArray - 1].tIndexClose =
            location of } in newtokenArray;
    }
    Copy this entry to the newtokenarray .

----





The symbol tree is comprised of these nodes.  The symbol tree
organizes the symbol space into a hierarchy.  For each feature
symbol, there is a set of option symbols particular to that feature.
All symbol nodes are stored in one array.  Multiple trees may
exist in one array.   When the symboltree is frozen, it can be
optimized by restoring the tree as an array of (STRREFs+subSpaceIndex.
Where the symbolID serves as the index to the arrayref.
(+ symboltype offset)  The end of each symbol list may be signified by
a NULL arrayref.


typedef  struct
{
    ARRAYREF   arSymbolName;
    DWORD   dwSymbolID;    // has nothing to do with array of symbol structs.
            //  value begins at zero and is incremented to obtain
            //  next value.
    DWORD   dwNextSymbol;   // index to next element in this space.
    DWORD   dwSubSpaceIndex ;  // index to first element in new symbol space
            which exists within the catagory represented by this symbol.
            for example in the catagory represented by the
            symbol  PAPERSIZES:  we may have the subspace
            comprised of Letter, A4, Legal, etc.
}   SYMBOLNODE , * PSYMBOLNODE ;
//  assign this struct the type  'psn'


// ---- Global and state Variables ---- //
{
    // ---- Index in SYMBOLNODE array to each type of tree ---- //

    DWORD   gdwFeatureSymbols ;    // initially set to INVALID_INDEX
    DWORD   gdwFontCartSymbols ;
    DWORD   gdwTTFontSymbols ;
    DWORD   gdwBlockMacroSymbols ;
    DWORD   gdwValueMacroSymbols ;

    // ---- track value of curBlockMacroArray and curValueMacroArray ---- //

    DWORD   gdwCurBlockMacroArray ;   // initially set to zero.  First
    DWORD   gdwCurValueMacroArray ;   // writable slot in MacroArray.
    DWORD   gdwMacroLevelStackPtr ;   // Push: write values into
            // MacroLevelStack[MacroLevelStackPtr++]
            //  Pop: read values from
            // MacroLevelStack[--MacroLevelStackPtr]

}



typedef  struct _TOKENMAP
{
    DWORD  dwKeywordID ;  // index of entry in KeywordTable
    ABSARRAYREF  aarKeyword ; // points to keyword in the source file
    ABSARRAYREF  aarValue ;  // value associated with this keyword.
                        // an arrayref is needed if we store
                        // the value in the heap.
                        //  It also makes copying the string
                        // to another place easier.  No need to
                        // search for a linebreak char.  Just
                        // Copyn()  will do.
    DWORD   dwValue  ;  // interpretation of Value string - see flags.
         // maybe commandID, numerical value of constant, MacroID assigned
         // to MacroSymbol  ,  SymbolID  etc.

    DWFLAGS    dwFlags ;  // bitfield with the following flags
        //  TKMF_VALUE_SAVED     independently of the tokenmap.
        //  TKMF_COMMAND_SHORTCUT  only used when parsing commands.
        //  TKMF_INLINE_BLOCKMACROREF   need to know when resolving macros.
        //  TKMF_MACROREF    indicates a value macro reference that must be resolved
        //  TKMF_SYMBOLID  dwValue contains a symbolID.
        //  TKMF_SYMBOL_REGISTERED  set when the symbolID is registered.
        //  TKMF_EXTERN:  The extern Qualifier was prepended to the keyword
        //  and has now been truncated.

} TKMAP, *PTKMAP

special keywordIDs:

ID_NULLENTRY:  ignore this, either expired code, parsing error etc.
ID_UNRECOGNIZED:  conforms to correct syntax, but not in my keyword table.
    could be a keyword defined in a newer spec or name of valuemacro.
    other other OEM defined stuff.
ID_SYMBOL:  does not begin with * , but conforms to syntax
    for a symbol.
ID_EOF:  end of file - no more tokenMap entries

    -----------------------------------

During the parsing to create the token map we
a) replace all comments with spaces
b) replace consecutive linebreaks with spaces.
c) parse all mainkeywords and replace with keywordIDs
d) init pointers to keywords and arrayref to values
e) set appropriate flags.
f) register symbols.


// ---- note ---- //
    all functions parsing the input stream may indicate
    reaching EOB by returning NULL.   caller should check for
    NULL return value after calling these functions and
    react accordingly.
// -------------- //

BUG_BUG:  CreateTokenMap should note if
*Command is the short version.   If so
then 2nd pass (macroresolution) should
expand it so special case code is not needed.

PTKMAP  CreateTokenMap(
IN OUT  PBYTE  pubCur  // location within source to start parsing
)
{
    PBYTE  pubNewPos ;  // transient data.

    //  assume we are at parsing level 0  - outside of any
    //  contexts requiring a change of parsing rules.

    pubCur = PubEatWhite(pubCur) ;

    this function will move forward until the first non-whitespace
    or non-linebreak character is encountered.   Convert first
    occurances of consecutive linebreak chars to whitespace.
    (should this be done here?: convert linebreak+continuation
    to whitespace.)

    /*  PubEatComments(pubCur)  */

    if pubCur points to start of a valid comment, this function
    will advance until linebreak character is encountered.
    it will also completely consume the comment by replacing
    all the characters  with spaces.

    while((pubNewPos = PubEatComments(pubCur)) != pubCur)
    {
        pubCur = pubNewPos ;
        pubCur = PubEatWhite(pubCur) ;
    }

    at this point pubCur points to first non-WHITE char that
    is also not a comment.

    we expect to see {, } (braces)  or a valid keyword at this
    point.

    while(pubCur)
    {
        pubCur = dwIdentifyKeyword(pubCur, tkmap+i) ;


            this function does several things:
            'brackets' keyword to see if it is properly terminated with :
            and begins with * (if it is not a brace).
            performs table lookup to obtain the keywordID which is written
            to tkmap[i].dwKeywordID .
            Determines based on the keyword ID if next token represents
            another keyword (as is the case if keyword is a brace)
            or if it represents a value.  If its a keyword, assigns NULL
            to  arValue, else arValue points to first nonwhite char
            in value after the : delimiter.    This function treats
            the value as a black box.
            If the keyword happens to be a brace,  dwValue
            will hold the nesting level of the brace.
            This will allow very fast identification of scope.

            If the state machine is used at this point we can
            resolve attribute names.  Otherwise we scan only
            for non-attribute keywords and mark all other legally
            constructed keywords as UNRECOGNIZED.  However attributes
            prefaced with EXTERN_FEATURE or EXTERN_GLOBAL may be
            identified at this time.

            A second pass using the state machine then applies the
            proper attribute namespace and resolves all UNRECOGNIZED
            keywords.   All remaining unrecognized keywords produce
            a warning message.

            Returns pubCur, which points to first char in the value or
            first char of next keyword if no value exists.

            Error handling:  calls a function WriteErrorMsg() to
            record any errors that it encounters.  may set dwKeywordID
            to ERROR, and set pubValue pointing to offending keyword,
            and return this value in pubCur.

        pubCur = scanOverValue(pubCur) ;
            init arValue, set dwFlags.
            Note:  lets parse the value only to reach the next
            keyword, not with the intent of saving the value
            somewhere.  This is because at this point we have
            no clue as to where the value should be
            saved to.  Wait for a subsequent pass to avoid
            cluttering the heap with data that will eventually
            be cubbyholed elsewhere.  There are a few execptions
            that will cause things to happen.  One is if the shortcut
            version of another construct is encountered, then
            we must expand this in the tokenMap so it looks like
            the full fledged version. On the other hand we may
            choose to defer the expansion till later, but we
            may flag this now.
            See *command  for an example.

            Also replace any occurances of linebreak + continuation
            char with spaces.

            Eat comments and white spaces until we reach beginning of
            a non-Null statement.
    }

    things that need to be done at some point
    in this function:

    lazy way to guard against useage of command shortcuts:
    when ever encountering a command keyword, leave
    the following entry unused. (mark it as NULL keyword)

    the Command name (the value portion)
    needs to be parsed and converted to a unidrv ID
    this may be placed in tokenmap.dwValue.
    set the flag TKMF_SYMBOL_REGISTERED.  This will
    prevent the value string from getting registered in a
    symbol table.
}


defineAndResolveMacros()
    this function scans through the tokenMap
    making a copy of the tokenMap without
    the macrodefinitions or references.  All references
    are replaced by the definitions inserted in-line!


{
    Can't store ValueMacro Definitions in scratch memory, they
    will actually be referenced directly if the value is not
    a string!

    initialize NEWTOKENMAP to refer to unused entries
    in TOKENMAP buffer.  We will create a new copy of
    the tokenmap here!

    1st pass:
    defineBlockMacroSymbols()
        search for all *BlockMacro keywords
        add macro symbol definitions
        to the symbol tree.  assign them
        an ordinal ID value 1, 2, 3, ...
        in this case, we may use the tree
        as a pure array of StringRefs.  with
        in index to the first uninitialized entry.
        write the macroID value into the tokenMap.dwValue.

    ScanForMacroReferences();

    walk through the old tokenMap one entry at a time.

    for (every entry in the tokenMap)
    {
        switch()
        {
            case (entry begins a block macrodef)
                copy token entry into new tokenMap
                record the new tokenIndex into
                BlockMacroArray[curBlockMacroArray]
                set  tIndexOpen and close to -1 to indicate
                not yet initialized.
                increment curBlockMacroArray.
                (all lines of macrodef are automatically copied over!)
            case (entry contains a block macroref)
                convert the symbolname to a macroID via
                the symboltree.  Search the BlockMacroArray entries
                from index curBlockMacroArray - 1 to zero
                using the first macroID that matches.

                copy all the valid tokenMap entries
                between BlockMacroArray[index].tIndexOpen
                and tIndexClose defined for the block macro
                referenced.   Avoid circular reference by ensuring
                tIndexClose != -1 for the selected macro.

            case (entry begins a value macrodef: *Macros)
                defineValueMacros()

            case (entry references a valuemacro)
                know by checking tokenMap.dwFlags = MACROREF.
                    dereferenceValueMacro()
            // sorry, cannot defer this since value macros
            // have a limited scope.  We must access the
            //  valueMacroArray at the time we see the reference
            // since valueMacroArray dynamically changes as we
            // encounter braces.

            case ({)  increment macro nesting level
                any macro defined within a macro  is undefined
                outside of that macro!

            case (})  decrease macro nesting level.

            default;  // all other entries
                copy to new tokenMap
        }
    }
    old tokenMap is now useless, its memory now lies fallow.
}

ScanForMacroReferences()
{
    may want to factor out common stuff.

    for (each entry in oldTokenMap)
    {
        if(entry does not define an macro nor is a brace char)
        {
            must scan all values for macroReference.
            if a non string value is expected, the = macroname
            must be the first and only entity comprising the value.
            If its a string, we must parse each construct!
            set flag in oldTokenMap.
            can share code used in defineValueMacros().
        }
    }
}

//  note:  all continuation chars have been replaced by spaces
//  previously at    scanOverValue()  time.

defineValueMacros(old, newtokenindex)
{
    this function is called upon encountering
    a *Macros: groupname   construct

    check to see there is an opening brace

    while(tokenArray[tokenindex].keywordID != closingBrace)
    {
        each entry up to the closing brace defines a
        value macro.

        register macroname in ValueMacroSymbols tree
        Store index to tokenArray in
        valueMacroArray

        maybe also valueMacroArray should
        have an arrayref


        1) we have no idea what value is being defined or how
            to properly parse for it.
            the value may reference another macro(s)

        so the only time we attempt parsing the value is
        if the value appears to be a string macro.   If at any time
        the parsing fails, the entire value is treated as a black box.

        Copy the entire value string (everything up to but NOT including the
        first linebreak char ) into the heap.  initialize an arrayref
        to access this string.

        the following portion is also common to   dereferenceValueMacro().
        and partly common to ScanForMacroReferences()

        Attempt to determine if the value in the heap is a string.
        If so
        {
            parse along the string until macro reference is found
            then lookup macroname in the valueMacroArray,
            see how many bytes the macro contains and shift
            the remainder of the referencing macrostring to make
            room to insert the referenced macrostring.
            Copy the referenced macrostring in the space provided.
            Update the length of the referencing macrostring.
            repeat until no other macro references are found.
        }
        else
            do nothing special.

        store ref to string in heap inside tokenArray.arValue
    }
}


dereferenceValueMacro(index)
{
    may want to factor out common stuff.

    there is a macro reference in this statement since
    it is flagged in the tokenMap.


    if(valuetype for keywordID in the master keyword table != VALUE_COMMAND_INVOC
        or VALUE_STRING)
    {
        expect macroref to be the first and only thing you
        encounter.

        convert macroref to macroID.
        lookup macroID in valueMacroArray.
        for(i = curValueMacroIndex  ; i ; i--)
        {
            if(tokenMap[valueMacroArray[i - 1]].dwValue == macroID)
                break;  // p
        }
        If found, copy arrayref to value field which references Macro.

        tokenMap[index].arValue = tokenMap[valueMacroArray[i - 1]].arValue
    }
    else //  valueMacro occurs in a string.
    {
        Copy the entire value string (everything up to but NOT including the
        first linebreak char ) into the heap.
        parse along the string until macro reference is found
        then lookup macroname in the valueMacroArray,
        see how many bytes the macro contains and shift
        the remainder of the referencing macrostring to make
        room to insert the referenced macrostring.
        Copy the referenced macrostring in the space provided.
        Update the length of the referencing macrostring.
        repeat until no other macro references are found.
        Copy updated arrayref to value field in tokenMap.
    }
}


defineSymbols(tokenMap)       ???
{
    Note:  All Macro symbols have been processed
    by the time this function is called.

    Scans down tokenMap looking for
    Feature:,   Font:   keywordIDs
    and adding their symbol definitions to
    the symbol tree.    This portion may be common to
     register macroname in ValueMacroSymbols tree
     part of   defineValueMacros()  and defineBlockMacroSymbols()



    then rescans (or in the same pass)
    the tokenMap keeping track of
    which Feature we are in, so when an Option
    keyword is encountered, we know which Feature symbol
    to associate the option symbol with.   If an option
    construct occurs outside of a Feature construct, we
    will know and can flag this as an error.

}


at this point only symbols defined by    Feature:,  BlockMacros:, Font:
are stored in the symbol tree.

processSymbolRefs(tokenMap)
{
    exactly which circustances may symbols appear outside of
    a value?   if they occur:  keywordID should indicate
    exactly what catagory of symbol and the symbolID.
    in the high and low word.

    replaces ptr to symbol values in source file
    with SymbolID value  or index to QualifiedName construct
    or index to List construct which contains SymbolID value
    or index to QualifiedName construct.   tokenMap will
    clearly identify which of the 4 cases applies.

    At this point identify long or short version of command.
    for short version,  dwKeyWordID = SHORTCMD | <COMMANDID> ;
    for long version :  dwKeywordID = LONGCMD ;
        and  Cmd  keyword  dwKeywordID = CMD
                            dwValue = <COMMANDID> ;
    Find and register dwKeywordID = SYMBOL in the appropriate
    symbol Tree.  Change dwKeywordID to (for example)
    TTFONTNAME | FONTNAMEID.

    At this point NO keywords should remain unrecognized.
}


main()
{
    PTKMAP  CreateTokenMap(
        at what point do we distinguish between
        shortcuts and non shortcut keywords?  do this
        soon, before BInterpretTokens()  is called.

    defineAndResolveMacros()
    defineSymbols(tokenMap) ;
        registers symbols for TTFontSubs?
    processSymbolRefs(tokenMap) ;??? not needed at this time?

    initStructures()  with default or failsafe values ;
        //  this is done after first pass and we know
        //  how many DFEATURE_OPTION structures to allocate.
        //  we will initialize all dword values to ATTRIB_UNINITIALIZED.
        //  this is essential!
        //  the GlobalAttribute structure.
    BInterpretTokens() ;
    checkStructures() to ensure failsafe values have
        been replaced - otherwise GPD file failed to
        initialize some mandatory field.

        verify that features that are referenced in switch
        statements are indeed PICKONE.  May force it to be
        and warn or fail.

        go through all allocated data structures ensuring
        that they all contain at least the minimum required
        fields.  Supply defaults for any omitted but required
        values.  raise warnings.  If a structure is fatally flawed,
        you may have to fatally error out.
    ConstructSeqCommandsArray() !
}


OpenIssues:

How to deal with TTFontSubs

*TTFontSubs: <On/Off>
{
    symbolKeyname1: <integer>
    symbolKeyname2: <integer>
    symbolKeyname3: <integer>
    ...
}

the On/Off part is handled by
                VsetbTTFontSubs(ptkmap->aarValue) ;

who handles the symbolKeywords?  what if some are repeated?
                ProcessSymbolKeyword(ptkmap + wEntry) ;

    Both are called from within   BInterpretTokens


// ---- tables of static data ---- //

// ---- The mainKeyword table ---- //

The mainKeyword Table is an array of
structures of the form:

typedef  struct
{
    PSTR        pstrKeyword ;  // keywordID is the index of this entry.
    DWORD       dwHashValue ;  // optional - implement as time permits.
    VALUE       eAllowedValue ;
    DWORD       flAgs ;
    TYPE        eType;   // may replace Type/Subtype with a function
    DWORD       dwSubType ;  // if there is minimal code duplication.
    DWORD       dwOffset ;  //  into appropriate struct for attributes only.
    //  the size   (num bytes to copy) of an attribute is easily determined
    //   from the AllowedValue field.
} KEYWORDTABLE_ENTRY;


global  KEYWORDTABLE_ENTRY  gMainKeywordTable[] =
{
    static initializers
}

typedef  enum
{
    TY_CONSTRUCT, TY_ATTRIBUTE, TY_SPECIAL
}   TYPE ;

typedef  enum
{
    SPCL_MEMCONFIGKB, SPCL_MEMCONFIGMB,
} SPECIAL ;  // special subtypes

typedef  enum
{
    ATT_GLOBAL_ONLY, ATT_GLOBAL_FREEFLOAT,
    ATT_LOCAL_FEATURE_ONLY,  ATT_LOCAL_FEATURE_FF ,
    ATT_LOCAL_OPTION_ONLY,  ATT_LOCAL_OPTION_FF ,
    ATT_LOCAL_COMMAND_ONLY,  ATT_LOCAL_FONTCART_ONLY,
    ATT_LOCAL_TTFONTSUBS_ONLY,  ATT_LOCAL_OEM_ONLY,
    ATT_LAST   // Must be last in list.
}   ATTRIBUTE ;  // subtype

typedef  enum
{
    CONSTRUCT_UIGROUP ,
    CONSTRUCT_FEATURE ,
    CONSTRUCT_OPTION ,
    CONSTRUCT_SWITCH,
    CONSTRUCT_CASE ,
    CONSTRUCT_DEFAULT ,
    CONSTRUCT_COMMAND ,
    CONSTRUCT_FONTCART ,
    CONSTRUCT_TTFONTSUBS ,
    CONSTRUCT_OEM ,
    CONSTRUCT_LAST,  // must end list of transition inducing constructs.
    // constructs below do not cause state transitions
    CONSTRUCT_BLOCKMACRO ,
    CONSTRUCT_MACROS,
    CONSTRUCT_OPENBRACE,
    CONSTRUCT_CLOSEBRACE,
}  CONSTRUCT ;      //  SubType if Type = CONSTRUCT

typedef  enum
{
    SPEC_CONSTR, SPEC_INS_CONSTR,
    SPEC_NOT_INS_CONSTR, SPEC_INVALID_COMBO, SPEC_INVALID_INS_COMBO,
    SPEC_MEM_CONFIG_KB, SPEC_MEM_CONFIG_MB, SPEC_FONT,
    SPEC_, SPEC_, SPEC_,
}   SPECIAL ;


typedef  enum
{
    NO_VALUE, VALUE_STRING, VALUE_COMMAND_INVOC,
    VALUE_SYMBOL_DEF,
    VALUE_SYMBOL_REF, VALUE_CONSTANT_catagory,
    VALUE_INTEGER, VALUE_POINT, VALUE_RECT,
    VALUE_BOOLEAN, VALUE_QUALIFIED_NAME,
    VALUE_MAX
}  VALUE ;

what does the parser expect after a keyword?

NO_VALUE : a linebreak OR  an effective linebreak:   ({)  or comment
VALUE_STRING: Quoted String, hexstring, string MACROREF,
    parameterless invocation.
VALUE_COMMAND_INVOC:  like VALUE_STRING but allowed to contain
    one or more parameter references.
VALUE_SYMBOL_DEF:  Symbol  definition - any value allowed

VALUE_SYMBOL_FIRST:    base of user-defined symbol catagory
VALUE_SYMBOL_FEATURES = VALUE_SYMBOL_FIRST + SCL_FEATURES :
VALUE_SYMBOL_FONTCART = VALUE_SYMBOL_FIRST + SCL_FONTCART :
VALUE_SYMBOL_BLOCKMACRO = VALUE_SYMBOL_FIRST + SCL_BLOCKMACRO :
VALUE_SYMBOL_VALUEMACRO = VALUE_SYMBOL_FIRST + SCL_VALUEMACRO :
VALUE_SYMBOL_OPTIONS = VALUE_SYMBOL_FIRST + SCL_OPTIONS :
VALUE_SYMBOL_LAST = VALUE_SYMBOL_FIRST + SCL_NUMSYMCLASSES - 1 :

VALUE_CONSTANT_FIRST:   base of enumeration catagory.
VALUE_CONSTANT_PRINTERTYPE = VALUE_CONSTANT_FIRST + CL_PRINTERTYPE ;
VALUE_CONSTANT_FEATURETYPE = VALUE_CONSTANT_FIRST + CL_FEATURETYPE ;
    lots of class types listed here
    ..........
VALUE_CONSTANT_LAST = VALUE_CONSTANT_FIRST + CL_NUMCLASSES - 1 ;
VALUE_INTEGER:  integer
VALUE_POINT:  point
VALUE_RECT:  rectangle
VALUE_BOOLEAN:  boolean.
VALUE_QUALIFIED_NAME:  Qualified name (one or more symbols separated by .)
VALUE_LIST:   no attribute actually is assigned this descriptor,
    // but used in the gValueToSize table.
VALUE_LARGEST:  not a real descriptor, but this position in the
    gValueToSize table  holds the largest of the above values.
VALUE_MAX:  number of elements in gValueToSize table.

-----
allowed values for KEYWORDTABLE_ENTRY.flAgs:

KWF_LIST:  the value may be a LIST containing one or more
    items of type AllowedValue.  The storage format
    must be of type LIST.  Only certain values may qualify
    for list format.
KWF_MACROREF_ALLOWED: since only a handful of keywords cannot accept
    macro references, it may be a waste of a flag, but reserve this
    to alert us that this special case must accounted for.
KWF_COMMAND:  This attribute is stored in a dedicated structure

KWF_FONTCART:  This attribute is stored in a dedicated structure
KWF_TTFONTSUBS:  This attribute is stored in a dedicated structure
KWF_OEM:  This attribute is stored in a dedicated structure


--------- special flag constructs ----

KWF_DEDICATED_FIELD = KWF_COMMAND | KWF_FONTCART |
    KWF_TTFONTSUBS | KWF_OEM

:  this indicates this attribute is stored
    in a dedicated structure, not in the heap.  As a result,
    the dwOffset field is  interpreted differently from attributes
    without this flag set.

-----

Notes:

the KeywordTable is partitioned into sections:
non-attribute Keywords
GlobalAttributes
FeatureAttributes
OptionAttributes
CommandAttributes
etc.
A range of indicies (min-max)
may be provided or a special flag
may denote the last entry in each section.
The separation exists because the same keyword may
exist in two different sections.
-----

command array:

just a list of command names and #defines giving the unidrv
value.  Use this table to assign each commandname a value.
CmdSelect is a special value -1!


typedef struct
{
    ARRAYREF  CommandName ;
    DWORD     UnidrvIndex ;  // #define  value assigned to command.
} CMD_TABLE ;

global  CommandTable[NUM_UNIDRV_CMDS] ;


------

Table to convert allowed values to sizes:

DWORD  gValueToSize[VALUE_MAX] ;   // size of various values in bytes

VinitValueToSize()
{
    // BUG_BUG!  assume array is zero initialized

    gValueToSize[VALUE_LARGEST] = 0 ;
    gValueToSize[NO_VALUE] = 0 ;
    gValueToSize[VALUE_BOOLEAN] = sizeof(BOOL) ; // etc
    gValueToSize[VALUE_RECT] = sizeof(RECT) ; // etc
    gValueToSize[VALUE_LIST] = sizeof(DWORD) ; // etc
        // only the index of first listnode is stored.


    for(i = 0 ; i < CL_NUMCLASSES ; i++)
        gValueToSize[VALUE_CONSTANT_FIRST + i] = sizeof(DWORD) ;

    for(i = 0 ; i < VALUE_MAX ; i++)
    {
        if (!gValueToSize[i])
            assert! ;  //  ensure table is fully initialized .
        if(gValueToSize[i] > gValueToSize[VALUE_LARGEST])
            gValueToSize[VALUE_LARGEST] = gValueToSize[i] ;
    }
}


-----

ensure all whitespaces are stripped before allowing token
to be registered, compared with etc.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\snaptbl.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  snaptbl.c - function to initialize the snapshot table  */


#include    "gpdparse.h"


// ----  functions defined in snaptbl.c ---- //

DWORD   DwInitSnapShotTable1(
PBYTE   pubnRaw) ;

DWORD   DwInitSnapShotTable2(
PBYTE   pubnRaw,
DWORD   dwI) ;




// ------- end function declarations ------- //

//  assume a pointer to this table is stored in the RAWbinary data.


DWORD   DwInitSnapShotTable1(
PBYTE   pubnRaw)
/* this function is to be called once
immediately after the raw binary data is read from
the file, this memory is to be freed immediately prior
to freeing pubRaw.
The entries belonging to different structures are
separated by an entry with    dwNbytes = 0.
*/
{
    PSTATICFIELDS   pStatic ;
//    PMINIRAWBINARYDATA pmrbd  ;
    DWORD   dwI = 0;

    pStatic = (PSTATICFIELDS)pubnRaw ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pStatic->snapShotTable = (PSNAPSHOTTABLE)
        MemAlloc(sizeof(SNAPSHOTTABLE) * MAX_SNAPSHOT_ELEMENTS) ;

    if(!pStatic->snapShotTable)
        return(FALSE) ;

    //   SSTI_GLOBALS  section

    //
    // General
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*GPDSpecVersion" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrGPDSpecVersion) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrGPDSpecVersion) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED  | SSF_MAKE_STRINGPTR ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*GPDFileVersion" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrGPDFileVersion) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrGPDFileVersion) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
#if defined(DEVSTUDIO) || defined(GPDCHECKER)
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED  | SSF_MAKE_STRINGPTR ;
#else
    pStatic->snapShotTable[dwI].dwFlags =  SSF_MAKE_STRINGPTR ;
#endif
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*GPDFileName" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrGPDFileName) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrGPDFileName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
#if defined(DEVSTUDIO) || defined(GPDCHECKER)
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED  | SSF_MAKE_STRINGPTR ;
#else
    pStatic->snapShotTable[dwI].dwFlags = SSF_MAKE_STRINGPTR ;
#endif
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*MasterUnits" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMasterUnits) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptMasterUnits) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    //  Amanda cannot have RC IDs here.
    //  so no atrModelNameID ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*ModelName" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrModelName) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrModelName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED  | SSF_MAKE_STRINGPTR ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrinterType" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPrinterType) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        printertype) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PRINTERTYPE) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    // "Include"  would be here if it weren't processed
    // at GetToken time.


    pStatic->snapShotTable[dwI].pstrKeyword  = "*ResourceDLL" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrResourceDLL) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrResourceDLL) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_MAKE_STRINGPTR  ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxCopies" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxCopies) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxCopies) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*FontCartSlots" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrFontCartSlots) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwFontCartSlots) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OEMCustomData" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOEMCustomData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pOEMCustomData) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PBYTE) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_MAKE_STRINGPTR ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*OEMCustomData" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOEMCustomData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwOEMCustomData) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_STRINGLEN ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*RotateCoordinate?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRotateCoordinate) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRotateCoordinate) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RotateRaster?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRotateRasterData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRotateRasterData) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*TextCaps" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrTextCaps) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liTextCaps) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RotateFont?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRotateFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRotateFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryUsage" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMemoryUsage) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liMemoryUsage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*ReselectFont" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrReselectFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liReselectFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OEMPrintingCallbacks" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOEMPrintingCallbacks) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liOEMPrintingCallbacks) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


#if 0
    dead keyword
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMinSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptMinSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  only SSF_REQUIRED for custompage;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
//    pmrbd->dwSSPaperSizeMinSizeIndex = dwI ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMaxSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptMaxSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
//    pmrbd->dwSSPaperSizeMaxSizeIndex = dwI ;
    dwI++ ;


    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxPrintableArea) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptMaxPrintableArea) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    dead keyword
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRasterCaps) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMinOverlayID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        iMinOverlayID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxOverlayID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        iMaxOverlayID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = NO_LIMIT_NUM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    dead keyword
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrLandscapeGrxRotation) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwLandscapeGrxRotation) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = LGR_NONE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrIncrementalDownload) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bIncrementalDownload) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMemoryForFontsOnly) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bMemoryForFontsOnly) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRotateFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRotateFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


//-----


    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRasterZeroFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRasterZeroFill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    dead keyword
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRestoreDefaultFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRestoreDefaultFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



#endif

    //
    // Cursor Control related information
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorXAfterCR" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterCR) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cxaftercr) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORXAFTERCR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CXCR_AT_CURSOR_X_ORIGIN ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BadCursorMoveInGrxMode" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrBadCursorMoveInGrxMode) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liBadCursorMoveInGrxMode) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*YMoveAttributes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYMoveAttributes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liYMoveAttributes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxLineSpacing" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxLineSpacing) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxLineSpacing) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = NO_LIMIT_NUM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*UseSpaceForXMove?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrbUseSpaceForXMove) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bUseSpaceForXMove) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*AbsXMovesRightOnly?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrbAbsXMovesRightOnly) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bAbsXMovesRightOnly) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue =  FALSE;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*EjectPageWithFF?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrEjectPageWithFF) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bEjectPageWithFF) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*XMoveThreshold" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrXMoveThreshold) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwXMoveThreshold) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*YMoveThreshold" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYMoveThreshold) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwYMoveThreshold) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*XMoveUnit" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrXMoveUnits) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptDeviceUnits.x) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ; // Required if
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*YMoveUnit" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYMoveUnits) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptDeviceUnits.y) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ; // Required if
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*LineSpacingMoveUnit" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrLineSpacingMoveUnit) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwLineSpacingMoveUnit) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ; // unidrv will assume a default value.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    //
    // Color related information
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*ChangeColorModeOnPage?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrChangeColorMode) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bChangeColorMode) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MagentaInCyanDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMagentaInCyanDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMagentaInCyanDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*YellowInCyanDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYellowInCyanDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwYellowInCyanDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CyanInMagentaDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCyanInMagentaDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwCyanInMagentaDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*YellowInMagentaDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYellowInMagentaDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwYellowInMagentaDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CyanInYellowDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCyanInYellowDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwCyanInYellowDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MagentaInYellowDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMagentaInYellowDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMagentaInYellowDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


// BUG_BUG!   to be deleted: following 3 pallete entries.
//  but Alvin uses this entry as a secret testing mechanism
//  see ifdef TESTBAND  for example.
    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxNumPalettes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxNumPalettes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxNumPalettes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

#if 0
    pStatic->snapShotTable[dwI].pstrKeyword  = "*PaletteSizes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPaletteSizes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liPaletteSizes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;  //  conditionally req.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PaletteScope" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPaletteScope) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liPaletteScope) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

#endif


    //
    // Raster related information
    //




    pStatic->snapShotTable[dwI].pstrKeyword  = "*OutputDataFormat" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOutputDataFormat) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        outputdataformat) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(OUTPUTDATAFORMAT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = ODF_H_BYTE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*OptimizeLeftBound?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOptimizeLeftBound) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bOptimizeLeftBound) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*StripBlanks" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrStripBlanks) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liStripBlanks) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RasterSendAllData?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRasterSendAllData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRasterSendAllData) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorXAfterSendBlockData" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterSendBlockData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cxafterblock) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORXAFTERSENDBLOCKDATA) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CXSBD_AT_GRXDATA_END ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorYAfterSendBlockData" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorYAfterSendBlockData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cyafterblock) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORYAFTERSENDBLOCKDATA) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CYSBD_NO_MOVE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MirrorRasterByte?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMirrorRasterByte) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bMirrorRasterByte) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MirrorRasterPage?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMirrorRasterPage) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bMirrorRasterPage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*UseExpColorSelectCmd?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrUseColorSelectCmd) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bUseCmdSendBlockDataForColor) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MoveToX0BeforeSetColor?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMoveToX0BeforeColor) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bMoveToX0BeforeColor) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE   ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*EnableGDIColorMapping?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrEnableGDIColorMapping) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bEnableGDIColorMapping) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE   ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*SendMultipleRows?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrSendMultipleRows) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bSendMultipleRows) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    //
    //Font Information
    //Device Font Specific.
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*DeviceFonts" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDeviceFontsList ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liDeviceFontList) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_LIST | SSF_FONTID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DefaultFont" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDefaultFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwDefaultFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_FONTID ;  // required if device fonts
                                            //  are supported.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxFontUsePerPage" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxFontUsePerPage) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxFontUsePerPage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = NO_LIMIT_NUM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DefaultCTT" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDefaultCTT) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwDefaultCTT) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*LookaheadRegion" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrLookaheadRegion) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwLookaheadRegion) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*TextYOffset" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrTextYOffset) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        iTextYOffset) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CharPosition" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCharPosition) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        charpos) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CHARPOSITION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CP_UPPERLEFT ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    //
    //Font Substitution.
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*TTFSEnabled?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrTTFSEnabled ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bTTFSEnabled) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    //
    //Font Download
    //




    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinFontID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMinFontID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMinFontID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxFontID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxFontID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxFontID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 65535 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxNumDownFonts" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxNumDownFonts) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxNumDownFonts) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = NO_LIMIT_NUM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DLSymbolSet" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDLSymbolSet) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dlsymbolset) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DLSYMBOLSET) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinGlyphID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMinGlyphID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMinGlyphID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 32 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxGlyphID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxGlyphID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxGlyphID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 255 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    /****
      *  Moved to SSTI_UPDATE_GLOBALS section
      *
    pStatic->snapShotTable[dwI].pstrKeyword  = "*FontFormat" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrFontFormat) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        fontformat) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(FONTFORMAT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
        //  UNUSED_ITEM  must be used as default - used by other code.
    pStatic->snapShotTable[dwI].dwFlags = 0 ;  // required if the printer
    // supports font downloading.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;
     *
    ***/


    //
    // font simulation
    //


    pStatic->snapShotTable[dwI].pstrKeyword  = "*DiffFontsPerByteMode?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDiffFontsPerByteMode) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bDiffFontsPerByteMode) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    //
    // rectangle area fill
    //




    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorXAfterRectFill" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterRectFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cxafterfill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORXAFTERRECTFILL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CXARF_AT_RECT_X_ORIGIN ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorYAfterRectFill" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorYAfterRectFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cyafterfill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORYAFTERRECTFILL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CYARF_AT_RECT_Y_ORIGIN ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinGrayFill" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMinGrayFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMinGrayFill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxGrayFill" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxGrayFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxGrayFill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 100 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    //  end of SSTI_GLOBALS  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;


    // beginning of SSTI_UPDATE_GLOBALS section

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxMultipleRowBytes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxMultipleRowBytes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxMultipleRowBytes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*TextHalftoneThreshold" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrTextHalftoneThreshold) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwTextHalftoneThreshold) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*FontFormat" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrFontFormat) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        fontformat) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(FONTFORMAT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
        //  UNUSED_ITEM  must be used as default - used by other code.
    pStatic->snapShotTable[dwI].dwFlags = 0 ;  // required if the printer
                                               // supports font downloading.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    //  end of SSTI_UPDATE_GLOBALS  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;

    //  beginning of SSTI_UIINFO  section


    pStatic->snapShotTable[dwI].pstrKeyword  = "*ResourceDLL" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrResourceDLL) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loResourceName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OFFSETONLY  ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPersonalityID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRcPersonalityID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loPersonality) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_SETRCID | SSF_STRINGID;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Personality" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPersonality) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loPersonality) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_DONT_USEDEFAULT |
                   SSF_OFFSETONLY | SSF_NON_LOCALIZABLE;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    //  special processing dwSpecVersion - done.


    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxCopies" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxCopies) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwMaxCopies) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPrinterIconID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                    atrPrinterIcon) ;  //  new keyword.
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loPrinterIcon) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_ICONID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*FontCartSlots" ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrFontCartSlots) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwCartridgeSlotCount) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HelpFile" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrHelpFile) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loHelpFileName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OFFSETONLY ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MasterUnits" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMasterUnits) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        ptMasterUnits) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintRate" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPrintRate) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwPrintRate) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintRateUnit" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPrintRateUnit) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwPrintRateUnit) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = INVALID_INDEX ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintRatePPM" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPrintRatePPM) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwPrintRatePPM) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*LETTER_SIZE_EXISTS?  synthesized" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrLetterSizeExists) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FLAG_LETTER_SIZE_EXISTS ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*A4_SIZE_EXISTS?  synthesized" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrA4SizeExists) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FLAG_A4_SIZE_EXISTS ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;




    //  end of SSTI_UIINFO  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;


    //  beginning of SSTI_UPDATE_UIINFO  section

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OutputOrderReversed? (global)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOutputOrderReversed) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FLAG_REVERSE_PRINT ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*ReverseBandOrderForEvenPages?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrReverseBandOrderForEvenPages) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FLAG_REVERSE_BAND_ORDER ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DraftQualitySettings" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDraftQualitySettings) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        liDraftQualitySettings) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BetterQualitySettings" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrBetterQualitySettings) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        liBetterQualitySettings) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BestQualitySettings" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrBestQualitySettings) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        liBestQualitySettings) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DefaultQuality" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDefaultQuality) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        defaultQuality) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(QUALITYSETTING) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = QS_BEST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*ChangeColorModeOnDoc?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrChangeColorModeDoc) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        bChangeColorModeOnDoc) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;




    //  end of SSTI_UPDATE_UIINFO  section



    return(dwI) ;
}



DWORD   DwInitSnapShotTable2(
PBYTE   pubnRaw,
DWORD   dwI)
{
    PSTATICFIELDS   pStatic ;
//    PMINIRAWBINARYDATA pmrbd  ;

    pStatic = (PSTATICFIELDS)pubnRaw ;
    if(!pStatic->snapShotTable)
        return(0) ;  //  should already be initialized!



    //  end of SSTI_UPDATE_UIINFO  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;

    //  beginning of SSTI_FEATURES  section

    //  note:  dwGID and dwOptionSize are handled directly.


    pStatic->snapShotTable[dwI].pstrKeyword  = "*Priority - synthesized" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPriority) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwPriority) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*FeatureType" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeatureType) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwFeatureType) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FT_DOCPROPERTY ;
        // actually is required, but is optional for predefined GIDs.
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSFeatureTypeIndex  = dwI ;         //  DO NOT CUT AND PASTE !!!!
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*ConcealFromUI?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrConcealFromUI) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FEATURE_FLAG_NOUI ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*UpdateQualityMacro?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrUpdateQualityMacro) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FEATURE_FLAG_UPDATESNAPSHOT ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;




    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcNameID (Fea)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcNameID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loDisplayName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;  // Use this if not found
    pStatic->snapShotTable[dwI].dwFlags =  SSF_SETRCID | SSF_STRINGID;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Name (Fea)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaDisplayName) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loDisplayName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_DONT_USEDEFAULT |
                  SSF_FAILIFZERO | SSF_OFFSETONLY | SSF_NON_LOCALIZABLE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HelpIndex (Fea)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaHelpIndex) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        iHelpIndex) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*FeaKeyWord - Synthesized" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaKeyWord) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loKeywordName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED | SSF_OFFSETONLY ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*UIType" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrUIType) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwUIType) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UIT_PICKONE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;





    //  end of SSTI_FEATURES  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;

    //  beginning of SSTI_UPDATE_FEATURES  section



    pStatic->snapShotTable[dwI].pstrKeyword  = "*DefaultOption" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDefaultOption) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwDefaultOptIndex) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSdefaultOptionIndex = dwI ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcIconID (Fea)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcIconID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loResourceIcon) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_ICONID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPromptMsgID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcPromptMsgID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loPromptMessage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    //  end of SSTI_UPDATE_FEATURES  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;




    //  beginning of SSTI_OPTIONS  section




    pStatic->snapShotTable[dwI].pstrKeyword  = "*OptKeyWord - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptKeyWord ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loKeywordName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags =  SSF_OFFSETONLY;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcNameID (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcNameID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loDisplayName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;  // Use this if not found
    pStatic->snapShotTable[dwI].dwFlags =  SSF_SETRCID | SSF_STRINGID;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Name (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptDisplayName) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loDisplayName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_DONT_USEDEFAULT |
                  SSF_FAILIFZERO | SSF_OFFSETONLY | SSF_NON_LOCALIZABLE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*HelpIndex (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptHelpIndex) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        iHelpIndex) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPromptTime (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcPromptTime) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        dwPromptTime) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = PROMPT_UISETUP ;
        // Required if rcPromptMsgID exists.
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DisabledFeatures" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDisabledFeatures) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        liDisabledFeatures) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;




    // write the CommandIndex into pOption->dwCmdIndex
    //  the Invocation field is not used.
    pStatic->snapShotTable[dwI].pstrKeyword  = "*Command (CmdSelect)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCommandIndex) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                    dwCmdIndex) ;
                     //  Invocation) + offsetof(INVOCATION, dwCount) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_HEAPOFFSET ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;


    //  --- option specific entries ----



    pStatic->snapShotTable[dwI].pstrKeyword  = "*DPI" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDPI) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTION,
                                        iXdpi) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*DPI" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDPI);
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTION,
                                        iYdpi) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED | SSF_SECOND_DWORD ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OptionID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTION,
                                        dwResolutionID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = RES_ID_IGNORE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;



    //  -----

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcHTPatternID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRcHTPatternID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        dwRCpatternID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    //  SSF_REQUIRED for OEM defined patterns.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HTPatternSize" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrHTPatternSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        HalftonePatternSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  SSF_REQUIRED for OEM defined patterns.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HTNumPatterns" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrHTNumPatterns) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        dwHTNumPatterns) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HTCallbackID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrHTCallbackID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        dwHTCallbackID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Luminance" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrLuminance) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        iLuminance) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 100 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwHalftoneID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        dwHTID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    //  ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwDuplexID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(DUPLEX,
                                        dwDuplexID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_DUPLEX ;
    dwI++ ;

    //  ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwRotationAngle - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(ORIENTATION,
                                        dwRotationAngle) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = ROTATE_NONE ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_ORIENTATION ;
    dwI++ ;

    //  ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwPageProtectID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGEPROTECT,
                                        dwPageProtectID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = PAGEPRO_OFF ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGEPROTECTION ;
    dwI++ ;

    //  -----


    pStatic->snapShotTable[dwI].pstrKeyword  = "*PageDimensions" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPageDimensions) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZE,
                                        szPaperSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(SIZE) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  not required for userdefined pagesize.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwPaperSizeID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZE,
                                        dwPaperSizeID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    //  ------- special case INPUTSLOT



    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwPaperSourceID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(INPUTSLOT,
                                        dwPaperSourceID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_INPUTSLOT ;
    dwI++ ;

#if 0
    dead keyword

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPaperFeed) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(INPUTSLOT,
                                        dwBinAdjust) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = DCBA_FACEUPNONE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_INPUTSLOT ;
    dwI++ ;
#endif

    //  ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwMediaTypeID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEDIATYPE,
                                        dwMediaTypeID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEDIATYPE ;
    dwI++ ;


    // -----

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwCollateID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLLATE,
                                        dwCollateID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLLATE ;
    dwI++ ;



    //  -----



    //  -----

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryConfigMB" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigMB) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEMOPTION,
                                        dwInstalledMem) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_MB_TO_BYTES ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEMOPTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryConfigMB" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigMB) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEMOPTION,
                                        dwFreeMem) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_SECOND_DWORD | SSF_MB_TO_BYTES ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEMOPTION ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryConfigKB" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigKB) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEMOPTION,
                                        dwInstalledMem) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_KB_TO_BYTES |
    SSF_DONT_USEDEFAULT | SSF_FAILIFZERO ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEMOPTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryConfigKB" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigKB) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEMOPTION,
                                        dwFreeMem) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_SECOND_DWORD |
        SSF_KB_TO_BYTES | SSF_DONT_USEDEFAULT | SSF_FAILIFZERO ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEMOPTION ;
    dwI++ ;

// ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OutputOrderReversed? (option level)"  ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOutputOrderReversed) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OUTPUTBIN,
                                        bOutputOrderReversed) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_OUTPUTBIN ;
    dwI++ ;



    //  end of SSTI_OPTIONS  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;

    //  beginning of SSTI_UPDATE_OPTIONS  section


    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcIconID (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcIconID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loResourceIcon) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_ICONID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPromptMsgID (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcPromptMsgID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loPromptMessage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*PageProtectMem (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPageProtectMem) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZE,
                                        dwPageProtectionMemory) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
        // required if there is a page protect feature
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;





    //  end of SSTI_UPDATE_OPTIONS  section


    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;




    //  beginning of SSTI_OPTIONEX  section




    pStatic->snapShotTable[dwI].pstrKeyword  = "*DPI" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDPI) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        ptGrxDPI) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*TextDPI" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrTextDPI) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        ptTextDPI) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinStripBlankPixels" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMinStripBlankPixels) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwMinStripBlankPixels) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    // required if *StripBlanks is not NONE.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RedDeviceGamma" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRedDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwRedDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    // required if *StripBlanks is not NONE.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*GreenDeviceGamma" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrGreenDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwGreenDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    // required if *StripBlanks is not NONE.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BlueDeviceGamma" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrBlueDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwBlueDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    // required if *StripBlanks is not NONE.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PinsPerPhysPass" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPinsPerPhysPass) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwPinsPerPhysPass) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PinsPerLogPass" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPinsPerLogPass) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwPinsPerLogPass) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*SpotDiameter" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrSpotDiameter) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwSpotDiameter) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RequireUniDir?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRequireUniDir) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        bRequireUniDir) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;



    //  ---- _COLORMODEEX


    pStatic->snapShotTable[dwI].pstrKeyword  = "*Color?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrColor) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        bColor) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*DevNumOfPlanes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDevNumOfPlanes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwPrinterNumOfPlanes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*DevBPP" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDevBPP) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwPrinterBPP) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*ColorPlaneOrder" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrColorPlaneOrder) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        liColorPlaneOrder) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  SSF_REQUIRED only if NumPlanes > 1.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DrvBPP" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDrvBPP) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwDrvBPP) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;




    pStatic->snapShotTable[dwI].pstrKeyword  = "*IPCallbackID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrIPCallbackID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwIPCallbackID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RasterMode" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRasterMode) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwRasterMode) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = RASTMODE_INDEXED ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PaletteSize" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPaletteSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwPaletteSize ) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 2 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PaletteProgrammable?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPaletteProgrammable) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        bPaletteProgrammable) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = BT_FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;


    //  -----  _PAGESIZEEX


    // note if set to 0,0 assume is same as papersize subject
    // to margin restrictions.

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintableArea" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPrintableSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        szImageArea) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(SIZEL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintableOrigin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPrintableOrigin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        ptImageOrigin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    // *CursorOrigin        see  BspecialProcessOption

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinSize" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMinSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        ptMinSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  only SSF_REQUIRED for custompage;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    pStatic->dwSSPaperSizeMinSizeIndex = dwI ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxSize" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMaxSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        ptMaxSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    pStatic->dwSSPaperSizeMaxSizeIndex = dwI ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*TopMargin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrTopMargin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwTopMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BottomMargin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrBottomMargin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwBottomMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxPrintableWidth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMaxPrintableWidth) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwMaxPrintableWidth) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinLeftMargin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMinLeftMargin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwMinLeftMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CenterPrintable?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCenterPrintable) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        bCenterPrintArea) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*RotateSize?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRotateSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        bRotateSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*PortRotationAngle" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPortRotationAngle) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwPortRotationAngle) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustCursorOriginX" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustCursorOriginX) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustCursorOriginX) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustCursorOriginY" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustCursorOriginY) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustCursorOriginY) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustPrintableOriginX" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableOriginX) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustPrintableOriginX) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustPrintableOriginY" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableOriginY) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustPrintableOriginY) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustPrintableSizeX" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableSizeX) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustPrintableSizeX) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustPrintableSizeY" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableSizeY) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustPrintableSizeY) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;




    //  -----

#if 0
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeedMargins) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(INPUTSLOTEX,
                                        sTopMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_INPUTSLOT ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeedMargins) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(INPUTSLOTEX,
                                        sBottomMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_SECOND_DWORD ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_INPUTSLOT ;
    dwI++ ;

#endif


    //  end of SSTI_OPTIONEX  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;


    //  beginning of SSTI_UPDATE_OPTIONEX  section


    //  end of SSTI_UPDATE_OPTIONEX  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;



    //  beginning of SSTI_SPECIAL  section
    //  contains entries requiring special processing.


    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwSSTableCmdIndex - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = 0 ;
        // not needed.
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
        // not needed.
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_HEAPOFFSET ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSTableCmdIndex = dwI ;
    dwI++ ;

    //  this entry is actually used to guide the copy into the
    //  sequenced command list.

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwSSCmdSelectIndex - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCommandIndex ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_HEAPOFFSET ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSCmdSelectIndex = dwI ;
    dwI++ ;

#if 0
    don't initialize this field, leave for amanda's personal use.

    //  Extract atrMargins convert to ImageableArea, place in rcImgArea.
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMargins ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZE,
                                        rcImgArea ) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RECT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
//    pmrbd->dwSSPaperSizeMarginsIndex = dwI ;
    dwI++ ;
#endif



// special check needed: if missing set to same as
//  printable origin.   see  BspecialProcessOption

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorOrigin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCursorOrigin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        ptPrinterCursorOrig) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_RETURN_UNINITIALIZED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    pStatic->dwSSPaperSizeCursorOriginIndex = dwI ;
    dwI++ ;


    //  constraints info is not copied into the snapshot.

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Constraints" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrConstraints) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSConstraintsIndex = dwI ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*InvalidCombination" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrInvalidCombos) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSInvalidCombosIndex = dwI ;
    dwI++ ;

#ifdef  GMACROS

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DependentSettings" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDependentSettings) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSDepSettingsIndex = dwI ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*UIChangeTriggersMacro" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrUIChangeTriggersMacro) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags =  0 ;
    pStatic->dwSSUIChangeTriggersMacroIndex = dwI ;
    dwI++ ;

#endif


    //  end of SSTI_SPECIAL  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;


    return(dwI) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\state1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*
 *  state1.c - implements the state machine to track constructs
 */



#include    "gpdparse.h"


// ----  functions defined in state1.c ---- //

BOOL   BInterpretTokens(
PTKMAP  ptkmap,   // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
) ;

BOOL  BprocessSpecialKeyword(
PTKMAP  ptkmap,   // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
) ;

BOOL  BprocessSymbolKeyword(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
PGLOBL  pglobl
) ;

VOID    VinitAllowedTransitions(
PGLOBL  pglobl
);

BOOL    BpushState(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
BOOL    bFirstPass,
PGLOBL  pglobl
) ;

BOOL   BchangeState(
PTKMAP  ptkmap,  // pointer to construct in tokenmap
CONSTRUCT   eConstruct,   //  this will induce a transition to NewState
STATE       stOldState,
BOOL        bSymbol,      //  should dwValue be saved as a SymbolID ?
BOOL        bFirstPass,
PGLOBL      pglobl
) ;

DWORD   DWregisterSymbol(
PABSARRAYREF  paarSymbol,  // the symbol string to register
CONSTRUCT eConstruct ,  // type of construct determines class of symbol.
BOOL    bCopy,   //  shall we copy paarSymbol to heap?  May set
DWORD   dwFeatureID,   //  if you are registering an option symbol
PGLOBL  pglobl
) ;

BOOL  BaddAARtoHeap(
PABSARRAYREF    paarSrc,
PARRAYREF       parDest,
DWORD           dwAlign,
PGLOBL          pglobl) ;

BOOL     BwriteToHeap(
OUT  PDWORD  pdwDestOff,  //  heap offset of dest string
     PBYTE   pubSrc,       //  points to src string
     DWORD   dwCnt,        //  num bytes to copy from src to dest.
     DWORD   dwAlign,
     PGLOBL  pglobl) ;

DWORD   DWsearchSymbolListForAAR(
PABSARRAYREF    paarSymbol,
DWORD           dwNodeIndex,
PGLOBL          pglobl) ;

DWORD   DWsearchSymbolListForID(
DWORD       dwSymbolID,   // find node containing this ID.
DWORD       dwNodeIndex,
PGLOBL      pglobl
) ;

BOOL  BCmpAARtoAR(
PABSARRAYREF    paarStr1,
PARRAYREF       parStr2,
PGLOBL          pglobl
) ;

BOOL  BpopState(
PGLOBL      pglobl
) ;

VOID   VinitDictionaryIndex(
PGLOBL      pglobl
) ;

VOID    VcharSubstitution(
PABSARRAYREF   paarStr,
BYTE           ubTgt,
BYTE           ubReplcmnt,
PGLOBL         pglobl
) ;


VOID   VIgnoreBlock(
    PTKMAP  ptkmap,
    BOOL    bIgnoreBlock,
    PGLOBL  pglobl
) ;



// ---------------------------------------------------- //




BOOL   BInterpretTokens(
PTKMAP  ptkmap,     // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
)
{
    DWORD       dwKeywordID ;
    KEYWORD_TYPE    eType;
    WORD        wEntry ;
    BOOL        bStatus = FALSE ;



    if(bFirstPass)
    {
        //  This bit of code creates a synthesized inputslot
        //  which the UI code will interpret as the UseFormToTrayTable

        //  BUG_BUG!!!:  should be replaced by preprocessing
        //  shortcuts etc.  Or by an option in stdnames.gpd

        ABSARRAYREF    aarSymbol ;
        DWORD       dwFeaID ;

        aarSymbol.pub = "InputBin" ; // no way to keep this in ssync
                //  with the global table.
        aarSymbol.dw = strlen(aarSymbol.pub) ;


        dwFeaID = DWregisterSymbol(&aarSymbol, CONSTRUCT_FEATURE,
                    TRUE, INVALID_SYMBOLID, pglobl) ;

        if(dwFeaID != INVALID_SYMBOLID)
        {
            aarSymbol.pub = "FORMSOURCE" ; // no way to keep this in ssync
                    //  with the global table.
            aarSymbol.dw = strlen(aarSymbol.pub) ;

            dwFeaID = DWregisterSymbol(&aarSymbol, CONSTRUCT_OPTION,
                        TRUE, dwFeaID, pglobl) ;
            ASSERT(dwFeaID == 0);  //  this option must be first.
        }
    }
    else
    {
        ARRAYREF       arStrValue ;
        BOOL        bPrevsExists ;


        if(!BwriteToHeap(&arStrValue.loOffset, "\0\0", 2, 4, pglobl) )
        {
            bStatus = FALSE ;  // heap overflow start over.
        }
        arStrValue.dwCount = 0 ;  // create a NULL unicode string.

        BexchangeArbDataInFOATNode(
                0 ,  //  dwFea
                0,  //  dwOption,
                offsetof(DFEATURE_OPTIONS, atrOptDisplayName ),
                sizeof(ARRAYREF),
                NULL,     // previous contents of attribute node
                (PBYTE)&arStrValue,  // new contents of attribute node.
                &bPrevsExists,   // previous contents existed.
                FALSE,     //  access synthetic features
                pglobl
            )   ;
    }


    for(wEntry = 0 ; geErrorSev < ERRSEV_RESTART ; wEntry++)
    {
        //  These ID's must be processed separately
        //  because they do not index into the mainKeyword table.
        //  The code for generic ID's will fail.

        dwKeywordID = ptkmap[wEntry].dwKeywordID ;

        if (dwKeywordID == gdwID_IgnoreBlock)
        {
            VIgnoreBlock(ptkmap + wEntry, TRUE, pglobl) ;
            continue ;
        }

        switch(dwKeywordID)
        {
            case (ID_EOF):
            {
                //  BUG_BUG!!!  Cleanup code here
                //  integrity checking code:
                //  check to see mdwCurStsPtr == 0
                //  and any other loose ends are tied.

                bStatus = (mdwCurStsPtr) ? (FALSE) : (TRUE);
                return(bStatus) ;
            }
            case (ID_NULLENTRY):
            {
                continue ;  // does this work?
                    // should drop to bottom of FOREVER for loop.
            }
            case (ID_SYMBOL):
            {
                bStatus = BprocessSymbolKeyword(ptkmap + wEntry, pglobl) ;
                continue ;  //  uses TKMF_SYMBOL_REGISTERED to track passes
            }
            case (ID_UNRECOGNIZED):
            {    //  if identified on first pass, won't pass this way again!
                if(bStatus = BidentifyAttributeKeyword(ptkmap + wEntry, pglobl) )
                {
                    dwKeywordID = ptkmap[wEntry].dwKeywordID ;
                    break ;  // fall out of switch statement
                    //  and into next switch.
                }

                if(bFirstPass)
                {
                    vIdentifySource(ptkmap + wEntry, pglobl) ;
                    ERR(("Warning, unrecognized keyword: %0.*s\n", \
                            ptkmap[wEntry].aarKeyword.dw, \
                            ptkmap[wEntry].aarKeyword.pub));

                    VIgnoreBlock(ptkmap + wEntry, FALSE, pglobl) ;

                    //  if this keyword is immediately
                    //  followed by open brace, ignore all
                    //  statements from there until the matching closing
                    //  brace.
                }

                continue ;
            }
            default :
                break ;
        }

        eType = mMainKeywordTable[dwKeywordID].eType ;

        switch (eType)
        {
            case  (TY_CONSTRUCT):
            {
                if( CONSTRUCT_CLOSEBRACE ==
                    (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType))
                {
                    bStatus = BpopState(pglobl) ;
                    if(!bStatus)
                    {
                        vIdentifySource(ptkmap + wEntry, pglobl) ;
                        ERR(("Unmatched closing brace!\n"));
                    }
                }
                else
                {
                    bStatus = BpushState(ptkmap + wEntry, bFirstPass, pglobl) ;
                    if(!bStatus)
                    {
                        vIdentifySource(ptkmap + wEntry, pglobl) ;
                        //  ERR(("Fatal error parsing construct.\n"));
                        //  stack is now invalid.
                        //  in the future make parser smarter -
                        //  eject contents between braces.
                        //  geErrorType = ERRTY_SYNTAX ;
                        //  geErrorSev = ERRSEV_FATAL ;
                    }
                }
                break ;
            }
            case  (TY_ATTRIBUTE) :
            {
                if(!bFirstPass)  // must wait till all attribute
                {              //  buffers are allocated.
                    bStatus = BprocessAttribute(ptkmap + wEntry, pglobl) ;
                    if(!bStatus)
                    {
                        vIdentifySource(ptkmap + wEntry, pglobl) ;
                    }
                }
                break ;
            }
            case  (TY_SPECIAL) :
            {
                bStatus = BprocessSpecialKeyword(ptkmap + wEntry,
                    bFirstPass, pglobl) ;  // don't really know if 2 passes
                {                //  are needed.
                    if(!bStatus)
                    {
                        vIdentifySource(ptkmap + wEntry, pglobl) ;
                    }
                }
                break ;
            }
            default:
            {
                vIdentifySource(ptkmap + wEntry, pglobl) ;
                ERR(("Internal Error: unrecognized keyword type! %0.*s.\n",
                    ptkmap[wEntry].aarKeyword.dw,
                    ptkmap[wEntry].aarKeyword.pub));
                geErrorSev = ERRSEV_FATAL ;
                geErrorType = ERRTY_CODEBUG ;
                break ;
            }
        }
    }
    if(geErrorSev >= ERRSEV_RESTART)
        bStatus = FALSE ;
    return(bStatus) ;
}


BOOL  BprocessSpecialKeyword(
PTKMAP  ptkmap,     // pointer to tokenmap
BOOL    bFirstPass,   //  is this the first or 2nd time around?
PGLOBL  pglobl
)
{
    DWORD       dwKeywordID, dwOffset ;
    CONSTRUCT   eSubType ;
    BOOL        bStatus = FALSE ;
    STATE       stState ;

    dwKeywordID = ptkmap->dwKeywordID ;

    eSubType = (SPECIAL)(mMainKeywordTable[dwKeywordID].dwSubType) ;
    dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

    if(mdwCurStsPtr)
        stState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
    else
        stState = STATE_ROOT ;

    switch(eSubType)
    {
        //  note: for the record I despise special casing these
        //  shortcuts.  Ideally I could preprocess them
        //  to convert
        //  *TTFS: "font name" : <fontID>
        //  into
        //  *TTFontSub: <unique value symbol>
        //  {
        //      *TTFontName: "font name"
        //      *DevFontID:  <fontID>
        //  }
        //  the only glitch with this is if the same font is listed
        //  multiple times in the GPD file, it will appear
        //  in the TTFontSubTable multiple times.

#if 0
        case  SPEC_FONTSUB :
        {
            ARRAYREF   arFontname ;
            ABSARRAYREF    aarFontname ;

            if(stState != STATE_ROOT)
            {
                vIdentifySource(ptkmap, pglobl) ;
                ERR(("The *TTFS  keyword must reside at the root level.\n"));
                return(FALSE) ;
            }

            if(bFirstPass)
            {
                //  parse string value and register as a symbol.
                if((ptkmap->dwFlags & TKMF_NOVALUE )  ||
                    !BparseString(&ptkmap->aarValue, &arFontname) )
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    ERR(("*TTFS fontname is not a valid string value.\n"));
                    return(FALSE) ;
                }

                if(ptkmap->aarValue.pub[0] != ':')
                {
                    ERR(("Colon delimiter expected after  parsing fontname string  for *TTFontSub.\n")) ;
                    return(FALSE) ;
                }
                //  a keyword with a composite value
                (VOID)BeatDelimiter(&ptkmap->aarValue, ":") ;
                //  I know this will succeed!
                // paarValue should now contain the integer
                // fontID.  Leave this for the 2nd pass.

                // convert arFontname to aar suitable for
                // Font registration.

                aarFontname.dw = arFontname.dwCount ;
                aarFontname.pub = arFontname.loOffset + mpubOffRef;

                //  New version of DWregisterSymbol registers the entire
                //  string - whitespaces and all.
                //
                //  Note suppress copying symbol into Heap since
                //  ParseString has already done that.

                ptkmap->dwValue = DWregisterSymbol(&aarFontname,
                    CONSTRUCT_TTFONTSUBS, FALSE, pglobl ) ;
                if(ptkmap->dwValue != INVALID_SYMBOLID)
                {
                    ptkmap->dwFlags |= TKMF_SYMBOL_REGISTERED ;
                }
                else
                {
                    return(FALSE) ;
                }
            }
            else if(ptkmap->dwFlags & TKMF_SYMBOL_REGISTERED)
            // second pass, TTFONTSUBTABLE arrays allocated
            // for all successfully registered entrants.
            {
                PSYMBOLNODE     psn ;
                DWORD           dwDevFontID ;
                PTTFONTSUBTABLE  pttft ;
                DWORD       dwTTFontNameIndex  ;

                psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

                pttft = (PTTFONTSUBTABLE)
                    gMasterTable[MTI_TTFONTSUBTABLE].pubStruct;
                pttft += ptkmap->dwValue ;  // index correct element.

                dwTTFontNameIndex = DWsearchSymbolListForID(ptkmap->dwValue,
                    mdwTTFontSymbols, pglobl) ;

                ASSERT(dwTTFontNameIndex  != INVALID_INDEX) ;

                pttft->arTTFontName = psn[dwTTFontNameIndex].arSymbolName ;
                //  if structure assignment is supported.

                bStatus = BparseInteger(&ptkmap->aarValue, &dwDevFontID,
                                    VALUE_INTEGER) ;
                if(bStatus)
                    pttft->dwDevFontID = dwDevFontID ;
                else
                {
                    //  BUG_BUG!  : Error parsing TTFontSub table entry
                    //  syntax error in devID.  Dead codepath who cares?
                    pttft->dwDevFontID = 0 ;  //  is this a good fallback?
                }
            }
            break;
        }
#endif
        case SPEC_INVALID_COMBO:
        {
            if(bFirstPass)
            {
                bStatus = TRUE ;
                break;    //  do nothing on the FirstPass
            }

            bStatus = BparseInvalidCombination(&ptkmap->aarValue, dwOffset, pglobl) ;
            break;
        }
        case SPEC_INVALID_INS_COMBO:
        {
            if(bFirstPass)
            {
                bStatus = TRUE ;
                break;    //  do nothing on the FirstPass
            }

            bStatus = BparseInvalidInstallableCombination1(&ptkmap->aarValue,
                            dwOffset, pglobl) ;
            break;
        }
        case SPEC_MEM_CONFIG_KB:  // should already be replaced
        case SPEC_MEM_CONFIG_MB:  //  at parseKeyword
        default:
        {
            break ;
        }
    }
    return(bStatus) ;
}



BOOL  BprocessSymbolKeyword(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
PGLOBL  pglobl
)
{
    //  registering the TTFontNames as symbols allows
    //  me to count the number of unique names and reserve
    //  the proper amount of TTFONTSUBTABLE elements and
    //  eliminates multiple instances of the same name.

    BOOL        bStatus = FALSE ;
    STATE       stState ;

    if(mdwCurStsPtr)
        stState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
    else
        stState = STATE_ROOT ;

    switch (stState)
    {
        //  note TTFontSubs now has its own keyword.
        //  and is handled as a Special Keyword.
        default:
        {
            // assume its just VALUEMACRO state
            // or user-defined symbols from an undefined
            // keyword.
            // ignore these.
            bStatus = TRUE ;
            break ;
        }
    }
    return(bStatus);
}





VOID    VinitAllowedTransitions(
PGLOBL pglobl)
{
    PSTATE      pst ;
    PBOOL       pb ;
    WORD        wS, wC, wA ;

    //  default initializer  is  STATE_INVALID
    for(wS = 0 ; wS < STATE_LAST ; wS++)
    {
        for(wC = 0 ; wC < CONSTRUCT_LAST ; wC++)
            gastAllowedTransitions[wS][wC] = STATE_INVALID ;
    }

    pst = gastAllowedTransitions[STATE_ROOT] ;

    pst[CONSTRUCT_UIGROUP] = STATE_UIGROUP;
    pst[CONSTRUCT_FEATURE] = STATE_FEATURE;
    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_FONTCART] = STATE_FONTCART;
    pst[CONSTRUCT_TTFONTSUBS] = STATE_TTFONTSUBS;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_UIGROUP] ;

    pst[CONSTRUCT_UIGROUP] = STATE_UIGROUP;
    pst[CONSTRUCT_FEATURE] = STATE_FEATURE;

    pst = gastAllowedTransitions[STATE_FEATURE] ;

    pst[CONSTRUCT_OPTION] = STATE_OPTIONS;
    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;

    pst = gastAllowedTransitions[STATE_OPTIONS] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_SWITCH_ROOT] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_ROOT;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_ROOT;

    pst = gastAllowedTransitions[STATE_SWITCH_FEATURE] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_FEATURE;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_FEATURE;

    pst = gastAllowedTransitions[STATE_SWITCH_OPTION] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_OPTION;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_OPTION;

    pst = gastAllowedTransitions[STATE_CASE_ROOT] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_DEFAULT_ROOT] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_CASE_FEATURE] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_DEFAULT_FEATURE] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_CASE_OPTION] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_DEFAULT_OPTION] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;


    //  ------------------------------------------------------  //
    //  now initialize allowed attributes table:
    //  which attributes are allowed in each state.

    //  default initializer  is  FALSE -- No attributes are allowed
    //  in any state.

    for(wS = 0 ; wS < STATE_LAST ; wS++)
    {
        for(wA = 0 ; wA < ATT_LAST ; wA++)
        {
            gabAllowedAttributes[wS][wA] = FALSE ;
        }
    }


    pb = gabAllowedAttributes[STATE_ROOT] ;
    pb[ATT_GLOBAL_ONLY] = TRUE ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;

    pb = gabAllowedAttributes[STATE_CASE_ROOT] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;

    pb = gabAllowedAttributes[STATE_DEFAULT_ROOT] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;

    pb = gabAllowedAttributes[STATE_OPTIONS] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;
    pb[ATT_LOCAL_FEATURE_FF] = TRUE ;
    pb[ATT_LOCAL_OPTION_ONLY] = TRUE ;
    pb[ATT_LOCAL_OPTION_FF] = TRUE ;

    pb = gabAllowedAttributes[STATE_CASE_OPTION] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;
    pb[ATT_LOCAL_FEATURE_FF] = TRUE ;
    pb[ATT_LOCAL_OPTION_FF] = TRUE ;

    pb = gabAllowedAttributes[STATE_DEFAULT_OPTION] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;
    pb[ATT_LOCAL_FEATURE_FF] = TRUE ;
    pb[ATT_LOCAL_OPTION_FF] = TRUE ;

    pb = gabAllowedAttributes[STATE_FEATURE] ;

    pb[ATT_LOCAL_FEATURE_ONLY] = TRUE ;
    pb[ATT_LOCAL_FEATURE_FF]  = TRUE ;

    pb = gabAllowedAttributes[STATE_CASE_FEATURE] ;
    pb[ATT_LOCAL_FEATURE_FF]  = TRUE ;

    pb = gabAllowedAttributes[STATE_DEFAULT_FEATURE] ;
    pb[ATT_LOCAL_FEATURE_FF]  = TRUE ;

    pb = gabAllowedAttributes[STATE_COMMAND] ;
    pb[ATT_LOCAL_COMMAND_ONLY] = TRUE ;

    pb = gabAllowedAttributes[STATE_FONTCART] ;
    pb[ATT_LOCAL_FONTCART_ONLY] = TRUE ;

    pb = gabAllowedAttributes[STATE_TTFONTSUBS] ;
    pb[ATT_LOCAL_TTFONTSUBS_ONLY] = TRUE ;

    pb = gabAllowedAttributes[STATE_OEM] ;
    pb[ATT_LOCAL_OEM_ONLY] = TRUE ;
}



BOOL    BpushState(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
BOOL    bFirstPass,
PGLOBL  pglobl
)
{
    // this function assumes (eType == TY_CONSTRUCT)

    DWORD       dwKeywordID ;
    CONSTRUCT   eSubType ;
    BOOL        bStatus = FALSE ;
    STATE       stOldState, stNewState ;

    if(mdwCurStsPtr >= mdwMaxStackDepth)
    {
        if(ERRSEV_RESTART > geErrorSev)
        {
            ERR(("Exceeded max state stack depth.  Restarting\n"));
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STSENTRY ;
        }
        return(FALSE);
    }
    dwKeywordID = ptkmap->dwKeywordID ;

    eSubType = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

    if(mdwCurStsPtr)
        stOldState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
    else
        stOldState = STATE_ROOT ;

    switch (eSubType)
    {
        //  note  CONSTRUCT_CLOSEBRACE already processed
        //  by PopState().
        case (CONSTRUCT_OPENBRACE):
        {
            vIdentifySource(ptkmap, pglobl) ;
            ERR(("OpenBrace encountered without accompanying construct keyword.\n"));
            geErrorType = ERRTY_SYNTAX ;
            geErrorSev = ERRSEV_FATAL ;
            break ;
        }
        case (CONSTRUCT_FEATURE):
        case (CONSTRUCT_OPTION):
        case (CONSTRUCT_SWITCH):
        case (CONSTRUCT_COMMAND):   //  commandID's already registered.
        case (CONSTRUCT_CASE):
        case (CONSTRUCT_FONTCART):
        case (CONSTRUCT_TTFONTSUBS):
        {
            bStatus = BchangeState(ptkmap, eSubType, stOldState, TRUE,
                bFirstPass, pglobl) ;

            break ;
        }
        case (CONSTRUCT_UIGROUP):
        {
            //  BUG_BUG!!!!!  incomplete.  no reqest for this.
        }
        case (CONSTRUCT_DEFAULT):
        case (CONSTRUCT_OEM):
        {
            bStatus = BchangeState(ptkmap, eSubType, stOldState, FALSE,
                bFirstPass, pglobl) ;

            break ;
        }
        default:
        {
            bStatus = TRUE ;  // its ok to ignore some keywords.
            break ;
        }
    }
    return(bStatus) ;
}


/*

dead code.
VOID  VsetbTTFontSubs(
IN   PABSARRAYREF   paarValue)
{
    // BUG_BUG!!!!!:
    // exactly what is supposed to happen ?  register
    //  synthesized symbol ?
    gbTTFontSubs = FALSE ;

    if( BeatSurroundingWhiteSpaces(paarValue) )
    {
        if(paarValue->dw == 2  &&  ! strncmp(paarValue->pub,  "ON",  2))
            gbTTFontSubs = TRUE ;
        else if(paarValue->dw != 3 ||  strncmp(paarValue->pub,  "OFF",  3))
        {
            BUG_BUG!: value must be either "ON" or "OFF".
        }
    }
}
*/

BOOL   BchangeState(
PTKMAP      ptkmap,      // pointer to construct in tokenmap
CONSTRUCT   eConstruct,  //  this will induce a transition to NewState
STATE       stOldState,
BOOL        bSymbol,     //  should dwValue be saved as a SymbolID ?
BOOL        bFirstPass,
PGLOBL      pglobl
)
{
    BOOL        bStatus = FALSE ;
    STATE       stNewState ;

    //  was checked in PushState, but never hurts to check
    //  in the same function that consumes the resource.
    if(mdwCurStsPtr >= mdwMaxStackDepth)
    {
        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STSENTRY ;
        }
        return(FALSE);
    }

    stNewState = gastAllowedTransitions[stOldState][eConstruct] ;
    if(stNewState == STATE_INVALID)
    {
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("the Construct %0.*s is not allowed within the state: %s\n",
            ptkmap->aarKeyword.dw, ptkmap->aarKeyword.pub,
            gpubStateNames[stOldState]));
        //  (convert stOldState
        //  and  eConstruct  to meaningful string)
        //  This is a fatal error since parser cannot second
        //  guess the problem.  The parser's job is to report
        //  as many legitemate problems as possible not to
        //  create as useable binary in spite of all the syntax
        //  errors.

        if(ERRSEV_FATAL > geErrorSev)
        {
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_SYNTAX ;
        }
        return(FALSE);
    }
    else
    {
        if(bFirstPass)
        {   //  verify open brace follows construct and discard it.
            DWORD       dwKeywordID ;
            PTKMAP  ptkmapTmp = ptkmap + 1 ;

            dwKeywordID = ptkmapTmp->dwKeywordID ;
            while(dwKeywordID == ID_NULLENTRY)  // skip nulls, comments etc.
            {
                dwKeywordID = (++ptkmapTmp)->dwKeywordID ;
            }
            if(dwKeywordID < ID_SPECIAL  &&
                mMainKeywordTable[dwKeywordID].eType == TY_CONSTRUCT  &&
                mMainKeywordTable[dwKeywordID].dwSubType ==
                CONSTRUCT_OPENBRACE )
            {
                ptkmapTmp->dwKeywordID = ID_NULLENTRY ;
            }
            else
            {
                vIdentifySource(ptkmap, pglobl) ;
                ERR(("open brace expected after construct: %0.*s but was not found\n",
                    ptkmap->aarKeyword.dw , ptkmap->aarKeyword.pub )) ;
                geErrorType = ERRTY_SYNTAX ;
                geErrorSev = ERRSEV_FATAL ;
                return(FALSE);
            }
        }
        if(bSymbol)
        {
            //  BUG_BUG:  verify tokenmap.dwFlags set to SYMBOLID before
            //  assuming dwValue is a symbol.  An error here
            //  is a parser bug.
            //  dwValue is initialized when dwFlag is set.
            //  further assert is pointless.

            //  perform multiple passes.  The first pass
            //  registers symbols and counts number of arrays
            //  to allocate, 2nd pass fills arrays.  SymbolID
            //  now serves as array index.

            if(!(ptkmap->dwFlags & TKMF_SYMBOL_REGISTERED))
            {
                if(!bFirstPass)
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    ERR(("symbol registration failed twice for: *%0.*s.\n",
                        ptkmap->aarValue.dw,
                        ptkmap->aarValue.pub));
                    return(FALSE) ;  // retry
                }

                if((ptkmap->dwFlags & TKMF_NOVALUE )  ||
                ! BeatSurroundingWhiteSpaces(&ptkmap->aarValue) )
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    ERR(("syntax error in symbol name.\n"));
                    ptkmap->dwValue = INVALID_SYMBOLID ;
                    return(FALSE) ;
                }

                ptkmap->dwValue = DWregisterSymbol(&ptkmap->aarValue,
                                    eConstruct, TRUE,  INVALID_SYMBOLID, pglobl) ;
                if(ptkmap->dwValue != INVALID_SYMBOLID)
                {
                    ptkmap->dwFlags |= TKMF_SYMBOL_REGISTERED ;
                }
                else
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    ERR(("symbol registration failed: *%0.*s.\n",
                        ptkmap->aarValue.dw,
                        ptkmap->aarValue.pub));
                    return(FALSE) ;  // retry
                }
            }
            else   // second pass, DFEATURE_OPTION arrays allocated.
            {
                if(eConstruct == CONSTRUCT_SWITCH)
                {
                    PDFEATURE_OPTIONS   pfo ;

                    pfo = (PDFEATURE_OPTIONS)
                        gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
                    pfo[ptkmap->dwValue].bReferenced = TRUE ;
                    //  this tells me this Feature is being referenced
                    //  by switch statement, hence the feature had better
                    //  be PICKONE.  Sanity checks will later verify
                    //  this assumption.
                }
                if(eConstruct == CONSTRUCT_FEATURE  ||
                    eConstruct == CONSTRUCT_SWITCH)
                {
                    //  BUG_BUG!!!!!:  (DCR 454049)
                    //  Note, the same Feature symbol cannot appear
                    //  twice in the stack for any reason.
                    //  A sanity check is needed.
                    //  if duplicate symbol found in stack,
                    //  "a Nested Switch Construct refers to the
                    //  same feature as an enclosing switch or Feature
                    //  construct.  This makes no sense."
                }
            }

            bStatus = TRUE ;
            mpstsStateStack[mdwCurStsPtr].dwSymbolID = ptkmap->dwValue ;
        }
        else
            bStatus = TRUE ;

        if(bStatus)
        {
            mpstsStateStack[mdwCurStsPtr].stState = stNewState ;
            mdwCurStsPtr++ ;
        }
    }
    return(bStatus) ;
}

DWORD   DWregisterSymbol(
PABSARRAYREF  paarSymbol,   // the symbol string to register
CONSTRUCT     eConstruct ,  // type of construct determines class of symbol.
BOOL          bCopy,        //  shall we copy paarSymbol to heap?  May set
                            // to FALSE only if paarSymbol already points
                            // to a heap object!
DWORD         dwFeatureID,   //  if you are registering an option symbol
                            //   and you already know the feature , pass it in
                            //  here.  Otherwise set to INVALID_SYMBOLID
PGLOBL        pglobl
)
/*  this function registers the entire string specified
    in paarSymbol.  The caller must isolate the string.
*/
{
    //  returns SymbolID, a zero indexed ordinal
    //    for extra speed we may hash string

    PSYMBOLNODE     psn ;
    DWORD   dwCurNode, dwSymbolID = INVALID_SYMBOLID;

//    bCopy = TRUE;   //check. Force BUDs to be the same.

    if(!paarSymbol->dw)
    {
        ERR(("DWregisterSymbol: No symbol value supplied.\n"));
        return(INVALID_SYMBOLID);  // report failure.
    }

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;


    switch(eConstruct)
    {
        case CONSTRUCT_FEATURE :    // since forward references are allowed
        case CONSTRUCT_SWITCH :     // it cannot be assumed that references
        case CONSTRUCT_FONTCART:    // will be to registered symbols .
        case CONSTRUCT_COMMAND:
        case CONSTRUCT_TTFONTSUBS:
        case CONSTRUCT_BLOCKMACRO:
        case CONSTRUCT_MACROS:
        case CONSTRUCT_PREPROCESSOR:
        {
            PDWORD  pdwSymbolClass ;

            pdwSymbolClass = (PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct ;

            if(eConstruct == CONSTRUCT_FONTCART)
                pdwSymbolClass += SCL_FONTCART ;
            else if(eConstruct == CONSTRUCT_TTFONTSUBS)
                pdwSymbolClass += SCL_TTFONTNAMES ;
            else if(eConstruct == CONSTRUCT_COMMAND)
                pdwSymbolClass += SCL_COMMANDNAMES ;
            else if(eConstruct == CONSTRUCT_BLOCKMACRO)
                pdwSymbolClass +=  SCL_BLOCKMACRO;
            else if(eConstruct == CONSTRUCT_MACROS)
                pdwSymbolClass +=  SCL_VALUEMACRO;
            else if(eConstruct == CONSTRUCT_PREPROCESSOR)
                pdwSymbolClass +=  SCL_PPDEFINES;
            else
                pdwSymbolClass += SCL_FEATURES ;
            if(*pdwSymbolClass == INVALID_INDEX)
            {
                //  register this symbol now.
                if(!BallocElementFromMasterTable(MTI_SYMBOLTREE, &dwCurNode, pglobl))
                {
                    //  we have run out of symbol nodes!
                    return(INVALID_SYMBOLID);  // report failure.
                }
                if(bCopy)
                {
                    if(!BaddAARtoHeap(paarSymbol,
                                    &(psn[dwCurNode].arSymbolName), 1, pglobl))
                        return(INVALID_SYMBOLID);  // report failure.
                }
                else
                {
                    //  derive one from the other.
                    psn[dwCurNode].arSymbolName.dwCount = paarSymbol->dw ;
                    psn[dwCurNode].arSymbolName.loOffset  =
                                            (DWORD)(paarSymbol->pub - mpubOffRef);
                }
                dwSymbolID = psn[dwCurNode].dwSymbolID = 0 ;  // first symbol
                                                            // in list.
                psn[dwCurNode].dwNextSymbol = INVALID_INDEX ;   // no previous
                                                        // symbols exist.
                psn[dwCurNode].dwSubSpaceIndex = INVALID_INDEX ;  // no
                        // option symbols exist.
                *pdwSymbolClass = dwCurNode ;  // now we have a registered
                                                //  symbol
            }
            else
            {
                //  search list for matching symbol.
                dwSymbolID = DWsearchSymbolListForAAR(paarSymbol, *pdwSymbolClass, pglobl) ;
                if(dwSymbolID != INVALID_SYMBOLID)  // found
                    ;  // nothing else is needed, just return.
                else   // not found, must register.
                {
                    if(!BallocElementFromMasterTable(MTI_SYMBOLTREE,
                        &dwCurNode, pglobl))
                    {
                        return(INVALID_SYMBOLID);  // report failure.
                    }
                    // tack new symbol onto head of list.
                    if(bCopy)
                    {
                        if(!BaddAARtoHeap(paarSymbol,
                                     &(psn[dwCurNode].arSymbolName), 1, pglobl) )
                            return(INVALID_SYMBOLID);  // report failure.
                    }
                    else
                    {
                        //  derive one from the other.
                        psn[dwCurNode].arSymbolName.dwCount = paarSymbol->dw ;
                        psn[dwCurNode].arSymbolName.loOffset  =
                                                (DWORD)(paarSymbol->pub - mpubOffRef);
                    }
                    dwSymbolID = psn[dwCurNode].dwSymbolID =
                    psn[*pdwSymbolClass].dwSymbolID + 1;
                            // increment last ID
                    psn[dwCurNode].dwNextSymbol = *pdwSymbolClass ;
                        // link to previous symbols.
                    psn[dwCurNode].dwSubSpaceIndex = INVALID_INDEX ;  // no
                            // option symbols exist.
                    *pdwSymbolClass = dwCurNode ;  // points to most recent
                                                    //  symbol
                }
            }
            break;
        }
        case CONSTRUCT_OPTION :
        case CONSTRUCT_CASE :
        {
            DWORD
                dwFeatureIndex, // node containing this symbolID.
                dwRootOptions ; //  root of option symbols.


#if PARANOID
            if(mdwCurStsPtr)
            {

                //  this safety check almost superfluous.

                stPrevsState = mpstsStateStack[mdwCurStsPtr - 1].State ;

                if(eConstruct == CONSTRUCT_OPTION  &&
                    stPrevsState != STATE_FEATURE)
                {
                    ERR(("DWregisterSymbol: option or case construct is not enclosed within feature or switch !\n"));
                    return(INVALID_SYMBOLID);  // report failure.
                }
                if(eConstruct == CONSTRUCT_CASE  &&
                    (stPrevsState != STATE_SWITCH_ROOT  ||
                    (stPrevsState != STATE_SWITCH_FEATURE  ||
                    (stPrevsState != STATE_SWITCH_OPTION )  )
                {
                    ERR(("DWregisterSymbol: case construct is not enclosed within  switch !\n"));
                    return(INVALID_SYMBOLID);  // report failure.
                }
#endif
            //  Boldly assume top of stack contains a featureID.
            //  see paranoid code for all assumptions made.

            if(dwFeatureID == INVALID_SYMBOLID)
                dwFeatureID = mpstsStateStack[mdwCurStsPtr - 1].dwSymbolID  ;

            dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
                mdwFeatureSymbols, pglobl) ;
            //  PARANOID  BUG_BUG: coding error if symbolID isn't found!
            ASSERT(dwFeatureIndex  != INVALID_INDEX) ;

            dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;

            //  found root of option symbols!

            if(dwRootOptions == INVALID_INDEX)
            {
                if(!BallocElementFromMasterTable(MTI_SYMBOLTREE, &dwCurNode, pglobl))
                {
                    return(INVALID_SYMBOLID);  // report failure.
                }
                //  register this symbol now.
                if(bCopy)
                {
                    if(!BaddAARtoHeap(paarSymbol, &(psn[dwCurNode].arSymbolName), 1, pglobl) )
                        return(INVALID_SYMBOLID);  // report failure.
                }
                else
                {
                    //  derive one from the other.
                    psn[dwCurNode].arSymbolName.dwCount = paarSymbol->dw ;
                    psn[dwCurNode].arSymbolName.loOffset  =
                                            (DWORD)(paarSymbol->pub - mpubOffRef);
                }
                dwSymbolID = psn[dwCurNode].dwSymbolID = 0 ;
                    // first symbol in list.
                psn[dwCurNode].dwNextSymbol = INVALID_INDEX ;
                    // no previous symbols exist.
                psn[dwCurNode].dwSubSpaceIndex = INVALID_INDEX ;

                    // option symbols have no subspace.

                psn[dwFeatureIndex].dwSubSpaceIndex = dwRootOptions =
                    dwCurNode ;  // now we have a registered symbol
            }
            else
            {
                //  search list for matching symbol.
                dwSymbolID = DWsearchSymbolListForAAR(paarSymbol,
                                                    dwRootOptions, pglobl) ;
                if(dwSymbolID != INVALID_SYMBOLID)  // found
                    ;  // nothing else is needed, just return.
                else   // not found, must register.
                {
                    if(!BallocElementFromMasterTable(MTI_SYMBOLTREE,
                        &dwCurNode, pglobl))
                    {
                        return(INVALID_SYMBOLID);  // report failure.
                    }
                    // tack new symbol onto head of list.
                    if(bCopy)
                    {
                        if(!BaddAARtoHeap(paarSymbol,
                                   &(psn[dwCurNode].arSymbolName), 1, pglobl) )
                            return(INVALID_SYMBOLID);  // report failure.
                    }
                    else
                    {
                        //  derive one from the other.
                        psn[dwCurNode].arSymbolName.dwCount =
                                                paarSymbol->dw ;
                        psn[dwCurNode].arSymbolName.loOffset  =
                                                (DWORD)(paarSymbol->pub - mpubOffRef);
                    }
                    dwSymbolID = psn[dwCurNode].dwSymbolID =
                    psn[dwRootOptions].dwSymbolID + 1;  // increment last ID
                    psn[dwCurNode].dwNextSymbol = dwRootOptions ;
                        // link to previous symbols.
                    psn[dwCurNode].dwSubSpaceIndex = INVALID_INDEX ;
                        // option symbols have no subspace.
                    psn[dwFeatureIndex].dwSubSpaceIndex = dwRootOptions =
                        dwCurNode ;  // points to most recent symbol
                }
            }
#if PARANOID
            }
            else
            {
                //  BUG_BUG:
                ERR(("DWregisterSymbol: option or case construct is not enclosed within feature or switch !\n"));
                return(INVALID_SYMBOLID);  // report failure.
            }
#endif
            break;
        }
        default:
        {
            //  PARANOID  BUG_BUG:
            ERR(("DWregisterSymbol: construct has no symbol class.\n"));
            return(INVALID_SYMBOLID);  // report failure.
        }
    }
    return(dwSymbolID) ;
}





BOOL  BaddAARtoHeap(
PABSARRAYREF    paarSrc,
PARRAYREF       parDest,
DWORD           dwAlign,   //  write data to address that is a multiple of dwAlign
PGLOBL          pglobl)
//  this function copies a non NULL terminated string fragment
//  referenced by an 'aar'
//  into the communal STRINGHEAP  and returns an 'ar'
//  which describes the location of the copy.
{
    PBYTE  pubSrc, pubDest ;
    DWORD  dwCnt ;  // num bytes to copy.

    // legal values for dwAlign are 1 and 4.

    mloCurHeap = (mloCurHeap + dwAlign - 1) / dwAlign ;
    mloCurHeap *= dwAlign ;

    pubSrc = paarSrc->pub ;
    dwCnt = paarSrc->dw ;
    pubDest = mpubOffRef + mloCurHeap ;


    //  is there enough room in the heap ?
    //  don't forget the NULL.
    if(mloCurHeap + dwCnt + 1 >  mdwMaxHeap)
    {
        //   log error to debug output.
        //  register error so appropriate action is taken.
        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STRINGHEAP ;
        }
        return(FALSE);
    }

    parDest->dwCount = dwCnt ;
    parDest->loOffset =  mloCurHeap;  // offset only!
    memcpy(pubDest, pubSrc, dwCnt);
    //   the copy may also fail for random reasons!
    pubDest[dwCnt] = '\0' ;  //  Add Null termination.
    mloCurHeap += (dwCnt + 1);   // update heap ptr.

    return(TRUE) ;
}



BOOL     BwriteToHeap(
OUT  PDWORD  pdwDestOff,  //  heap offset of dest string
     PBYTE   pubSrc,       //  points to src string
     DWORD   dwCnt,        //  num bytes to copy from src to dest.
     DWORD   dwAlign,   //  write data to address that is a multiple of dwAlign
     PGLOBL  pglobl)
//  this function copies dwCnt bytes from pubSrc to
//  top of heap and writes the offset of the destination string
//  to pdwDestOff.   Nothing is changed if FAILS.
//  Warning!  No Null termination is added to string.
{
    PBYTE  pubDest ;

    // legal values for dwAlign are 1 and 4.

    mloCurHeap = (mloCurHeap + dwAlign - 1) / dwAlign ;
    mloCurHeap *= dwAlign ;

    pubDest = mpubOffRef + mloCurHeap ;

    //  is there enough room in the heap ?
    if(mloCurHeap + dwCnt  >  mdwMaxHeap)
    {
        //  log error to debug output.
        //  register error so appropriate action is taken.
        ERR(("BwriteToHeap: out of heap - restarting.\n"));
        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STRINGHEAP ;
        }
        return(FALSE);
    }

    memcpy(pubDest, pubSrc, dwCnt);
    //  the copy may also fail for random reasons!
    *pdwDestOff = mloCurHeap ;
    mloCurHeap += (dwCnt);   // update heap ptr.

    return(TRUE) ;
}


DWORD   DWsearchSymbolListForAAR(
PABSARRAYREF    paarSymbol,
DWORD           dwNodeIndex,
PGLOBL          pglobl)
//  given a 'aar' to a string representing a symbol, search
//  the SymbolList beginning at dwNodeIndex for this symbol.
//  Return its symbolID  if found, else return the INVALID_SYMBOLID.
{
    PSYMBOLNODE     psn ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    for( ; dwNodeIndex != INVALID_INDEX ;
        dwNodeIndex = psn[dwNodeIndex].dwNextSymbol)
    {
        if(BCmpAARtoAR(paarSymbol,  &(psn[dwNodeIndex].arSymbolName), pglobl) )
            return(psn[dwNodeIndex].dwSymbolID);  // string matches !
    }
    return(INVALID_SYMBOLID);
}


DWORD   DWsearchSymbolListForID(
DWORD       dwSymbolID,   // find node containing this ID.
DWORD       dwNodeIndex, // start search here.
PGLOBL      pglobl)
//  given a  symbolID, search the SymbolList beginning at dwNodeIndex
//  for this symbol.
//  If found return the node index which contains the requested symbolID,
//  else return INVALID_INDEX.
{
    PSYMBOLNODE     psn ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    for( ; dwNodeIndex != INVALID_INDEX ;
        dwNodeIndex = psn[dwNodeIndex].dwNextSymbol)
    {
        if(psn[dwNodeIndex].dwSymbolID == dwSymbolID)
            return(dwNodeIndex);  // ID matches !
    }
    return(INVALID_INDEX);
}


BOOL  BCmpAARtoAR(
PABSARRAYREF    paarStr1,
PARRAYREF       parStr2,
PGLOBL          pglobl)
//  Compares two strings, one referenced by 'aar' the other
//  referenced by 'ar'.  Returns TRUE if they match, FALSE
//  otherwise.
{
    if(paarStr1->dw != parStr2->dwCount)
        return(FALSE) ;  // Lengths don't even match!
    if(strncmp(paarStr1->pub, mpubOffRef + parStr2->loOffset ,  paarStr1->dw))
        return(FALSE) ;
    return(TRUE) ;
}


BOOL  BpopState(
PGLOBL          pglobl)
{
    if(mdwCurStsPtr)
    {
        mdwCurStsPtr-- ;
        return(TRUE);
    }
    else
    {
        //  ERR(("Unmatched closing brace!\n"));
        //  message moved to caller.
        //  in the future make parser smarter.
        geErrorType = ERRTY_SYNTAX ;
        geErrorSev = ERRSEV_FATAL ;
        return(FALSE);
    }
}





VOID   VinitDictionaryIndex(
PGLOBL          pglobl)
/*
    MainKeywordTable[]  is assumed to be divided into
    a NonAttributes section and several Attributes sections
    with pstrKeyword = NULL dividing the sections.
    The end of the table is also terminated by a NULL entry.
    This function initializes the grngDictionary[]
    which serves as an index into the main keyword Table.

*/
{
    DWORD dwI,  // keywordTable Index
        dwSect ;  //  RNGDICTIONARY Index
    PRANGE   prng ;

    prng  = (PRANGE)(gMasterTable[MTI_RNGDICTIONARY].pubStruct) ;


    for(dwI = dwSect = 0 ; dwSect < END_ATTR ; dwSect++, dwI++)
    {
        prng[dwSect].dwStart = dwI ;

        for(  ; mMainKeywordTable[dwI].pstrKeyword ; dwI++ )
            ;

        prng[dwSect].dwEnd = dwI ;  // one past the last entry
    }
}

VOID    VcharSubstitution(
PABSARRAYREF   paarStr,
BYTE           ubTgt,
BYTE           ubReplcmnt,
PGLOBL         pglobl)
{
    DWORD   dwI ;

    for(dwI = 0 ; dwI < paarStr->dw ; dwI++)
    {
        if(paarStr->pub[dwI] == ubTgt)
            paarStr->pub[dwI] = ubReplcmnt ;
    }
}


VOID   VIgnoreBlock(
PTKMAP  ptkmap,
BOOL    bIgnoreBlock,
PGLOBL  pglobl)
//  This boolean determines the message that will be issued.
{
    /*  Should we ignore?  check that first non-NULL entry
        after wCurEntry  is open brace if so
        ignore all entries up to EOF or matching closing
        brace.  */

    DWORD       dwKeywordID, dwDepth ; // depth relative to *IgnoreBlock


    ptkmap->dwKeywordID = ID_NULLENTRY ;  // neutralize keyword regardless.
    ptkmap++ ;
    dwKeywordID = ptkmap->dwKeywordID ;
    while(dwKeywordID == ID_NULLENTRY)  // skip nulls, comments etc.
    {
        dwKeywordID = (++ptkmap)->dwKeywordID ;
    }
    if(dwKeywordID < ID_SPECIAL  &&
        mMainKeywordTable[dwKeywordID].eType == TY_CONSTRUCT  &&
        mMainKeywordTable[dwKeywordID].dwSubType ==
        CONSTRUCT_OPENBRACE )
    {
        ptkmap->dwKeywordID = ID_NULLENTRY ;
        dwDepth = 1 ;
        ptkmap++ ;
        if(bIgnoreBlock)
        {
            if(gdwVerbosity >= 4)
                ERR(("Note: Ignoring block following *IgnoreBlock.\n"));
        }
        else
            ERR(("Ignoring block following unrecognized keyword.\n"));
    }
    else
    {
        if(bIgnoreBlock  &&  gdwVerbosity >= 2)
            ERR(("Note:  Brace delimited block not found after *IgnoreBlock.\n"));
        return ;  // do nothing.
    }
    while(dwDepth)
    {
        dwKeywordID = ptkmap->dwKeywordID ;
        if(dwKeywordID == ID_EOF)
        {
            ERR(("Ignoring Block: EOF encountered before closing brace.\n"));
            return ;    //  stop regardless!
        }
        if(dwKeywordID < ID_SPECIAL)
        {
            KEYWORD_TYPE    eType;
            CONSTRUCT       eSubType ;

            eType = mMainKeywordTable[dwKeywordID].eType ;
            if(eType  ==  TY_CONSTRUCT)
            {
                eSubType = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;
                if(eSubType == CONSTRUCT_OPENBRACE)
                    dwDepth++ ;
                else if( eSubType == CONSTRUCT_CLOSEBRACE)
                    dwDepth-- ;
            }
        }
        ptkmap->dwKeywordID = ID_NULLENTRY ;
        ptkmap++ ;
    }

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\parspec.c ===
Definitions:

statement delimiter:
    a new statement will always follow a linebreak
    character:
    a) unless the following character is the continuation character
    b) if the following character is another linebreak character,
        it is a null statement.
    c) statements consisting entirely of whitespace characters,
        comments or combinations are considered null statements.
    d) the parser ignores null statements.
    e) parser eats everything up to linebreak character and each
        subsequent line that begins with the continuation char
        in the event of a parsing error.
    The Construct delimiters are a statement in and of themselves
    and they also serve to terminate the previous statement
    and delimit the start of the following statement.
    you may think of a <construct_delimiter>  as equivalent to
    <linebreak><construct_delimiter><linebreak>


Whitespace characters:   space, TAB
Linebreak  characters:   <CR>, <LF> if both occur consecutively
    the pair is treated as one linebreak.
White characters:  either Whitespace or Linebreak characters.
continuation character: +
    NEW DEF:  when used as a continuation char
    the '+' must appear as the first char in a line.
    The parser will interpret the preceeding linebreak
    as whitespace.
Logical linebreak: a linebreak character that is NOT followed by a
    continuation character.
Continuation linebreak:  a linebreak character followed by a
    continuation character.
Arbitrary whitespace:  Whitespace chars or comments or
    Continuation Linebreak
Construct delimiters:  curly braces { }
    A linebreak character is not required to preceed or proceed
    a construct delimiter.
    You may think of a <construct_delimiter>  as logically equivalent
    to      <linebreak><construct_delimiter><linebreak>
    Construct delimiters also delimit the scope of macro
    definitions.  If a macro was defined within a nesting level
    created by a pair of construct delimiters, it remains defined
    only within that nesting level.
Nesting level:  the logical set of statements enclosed by
    a matching pair of construct delimiters.
Statement delimiter: Logical linebreak or Construct delimiter.
Keyword - value separator:  colon :
string delimiter:  double quotes ""
macro invocation:  equals =
comment indicator: *%
    Comments may be inserted immediately preceeding any logical
    or continuation linebreak.  They may contain
    any characters except linebreak characters.
    The linebreak character terminates the comment.
    The comment indicator must be preceeded by a White Character.
    (unless the comment indicator is the first byte in the source file.)
Grouping operator: ()  used in certain value constructs.
Hex substring delimiter: <>
Escape character :  %  used in string and parameter constructs.



The above characters have reserved meanings
and may not be used in any keyword, symbol name
or any user defined name.

Name spaces:

If attributes keyword are used within other constructs
say feature or global keyword inside an option,
that keyword must be declared using the EXTERN_FEATURE:
or EXTERN_GLOBAL:  modifier.  Otherwise the attribute type
expected (dictionary used) will be defined by the state.

the namespaces of the attribute keywords for various constructs
may overlap each other, since we rely on the above rules to
assign the namespace, but they cannot overlap non-attribute
keywords.


Keywords:  predefined keywords must begin with '*'
the remainder of the keyword may be comprised of
'A' to 'Z', 'a' to 'z', '0' - '9', '_'  and  may
be terminated by an optional '?'.

Symbol Keywords  do not begin with '*' and may be any
name defined by the user, they must be comprised of the same
characters as normal keywords.  Symbol Keywords are used
as the name of Value macros and Font names in certain constructs.


Parsing rules:

Values:  on some Keywords the Value is
ignored by the parser.  In these cases
the Value (and the : delimiter) may be omitted
for example:
*Macros
*Macros: PaperNames
are both valid.


Block Macro definitions:
if the definition (body of a BlockMacro)
contains braces, the braces must appear in pairs
and the correct order.  ie {  must appear before }.
braces may be nested within the body.


Parsing Level 0:  this is the outermost level of parsing.
At this level  the characters {, } are interpreted
as construct delimiters,  *% begins a comment etc.
This is contrasted to the parsing rules applied to
higher level objects like strings  where these charcters
have no special meaning.

Linebreak characters may only appear in parsing level 0.
Their appearance at any time terminates parsing of the current statement.

parser eats everything up to linebreak character
in the event of a parsing error.

Statements begin with either a *<keyword> or a <symbol keyword>
where the keyword is a parser recognized keyword token and
where <symbol keyword> is a parser unrecognized token
which may represent a ValueMacroName or a TTFontName.
such tokens must not begin with '*'.  and will be marked
as SYMBOL in the TokenMap.

In general arbitary Whitespaces may appear between
any entities recognized at Parsing level 0.
If Whitespaces are permitted within such entities
it will noted.

For added robustness, macro strings will not be
expanded to their binary equivalents.  This prevents the
insertion of random Linebreak characters in the stream.

Rule for GPD authors:  for maximum robustness and error
recovery, place level 0 braces (Construct delimiters) on a
separate line.  Do not place Construct delimiters on the same
line where questionable keywords and constructs are used.


Heap useage:

the heap will be divided into several sections, each large enough
to hold whatever may come.  Growth of the heap sections
is not allowed.

Strings, composite objects like RECTS:   holds all strings, offsets referenced
from beginning of string section.

Arrays of various types:   each type of array is assigned its own dedicated
memory buffer.  A master table contains pointers to each array,
its size and current entry.  Once data is entered into the array,
the keeper of the data need only remember the index of the array
the data was written into.

After all parsing operations are complete, we will consolidate the
arrays into one memory space and update the master table accordingly.


Some composite values require an indefinite amount of storage
or reside in dedicated structures.
(for example strings, lists and UIconstraints).
Such values are stored in 2 parts, a fixed sized link, and
and the part the link refers to.  This part may be variable
sized and may occupy heap space or one or more dedicated
structures or some combination thereof.
Since the link is always of a known size, it may be stored
in a field in a structure etc.

The following table lists the values supported by the parser
and how they are structured:

value type: Strings
link:       ARRAYREF
                dwOffset field specifies heap offset of start of string
                dwCount  field specifies string length excluding
                    terminating NULL.
body:       Null terminated array of bytes stored in heap.

value type: LIST
value type: QualifiedName




Shortcuts that cause headaches:

*Command:   2 forms exist.


Macros:

    a macroDefinition cannot be self-referencing
    macroDefintions cannot be forward referenced.
    ie only a previously defined and fully resolved macro can be
    referenced.

    scope:  an Macro is defined (referenceable) only after parsing the
    closing brace of its definition and until encoutering a closing
    brace that signifies the termination of the level the macro
    was defined in.

    namespaces:  since macro definitions are stored in a stack,
    defining a second macro with the same name does not necessarily
    destroy the first definition.  If The first macro was defined
    outside of the scope of the 2nd, it will be visible once
    the parser leaves the scope of the 2nd Macro.

    ValueMacros:
    Only string ValueMacros may be nested.
    That if any valueMacro definition references
        another valueMacro, the parser will assume
        the definition is a stringMacro, and the
        macro being referenced is also a stringvalue.

    BlockMacros:
        a blockMacro may contain other Macrodefinitions
        but those definitions can only be referenced inside
        the block macro.  They will not appear
        when the blockmacro is actually referenced.
        A BlockMacroName may NOT be substituted
        by a ValueMacro either in a *BlockMacro or
        *InsertBlock  statement.



----- more parsing rules ------

the first non-null line of the root GPD sourcefile
must be:
*GPDSpecVersion:


arbitary whitespace is allowed between tokens
comprising a command parameter.
arbitary whitespace is allowed anywhere within
a hex substring.
--------------------------------------------------------------


Currently, these are the known types of keywords:

CONSTRUCTS:  introduces a construct (causes a parser context change)
    usually followed by open brace in next statement.
    construct is terminated by matching close brace.

    *UIGroup, *Switch, *Case, *Default, *Command
    *FontCartridge, *TTFontSubs, *Feature, *Option
    *OEM, *BlockMacro, *Macros
    a construct may be thought of as a type of structure
    initialization.   ONly certain keywords are may be used
    inside of a construct.  Some of these keywords may only be
    using within their associated construct and no where else.

LOCAL ATTRIBUTES:  initializes a value in a construct.
GLOBAL ATTRIBUTES:  initializes a value in the global structure.

local and global attributes may be subdivided into
freefloating and fixed.  A fixed attribute must be used
in the same nesting level as the construct it is associated
with.  A freefloating attribute may be used within another
construct as long as that construct is contained within the
construct associated attribute.


SPECIAL ATTRIBUTE:  initializes and adds another item to a dedicated
    or global list or a list in construct.  or has side effects
    requiring special processing.
    examples:

    *Installable?, - Causes an installable feature
    to be synthesized.  but parser may deal with this after all
    Feature/Options have been parsed.  So not really.

    Adds link to special  tree structure:
    *Constraints, *InvalidCombination, *InvalidInstallableCombination,
    *InstalledConstraints, *NotInstalledConstraints

    The values introduced by these keywords are additive
    (like using a LIST):
    *Font


    *Command:<commandName>:<invocation>    a shorthand

    *MemConfigKB    a shorthand way of creating an entire
        memory option.

    LIST(<QualifiedName>,<QualifiedName>,<QualifiedName>)
    may be written as:
    <FeatureName>.LIST(<OptionName>,<OptionName>,<OptionName>)


if there are other types of keywords let me know.

Special Parsing contexts:
in which User defines new keywords simply by
referencing them.

*TTFontSubs:
{
    <TTFontFaceName>: <DeviceFontID>
    ....  not actually a symbol, but adds a string, number pair
    to a list.  May be implemented during construction as a symbol.
}
*Macros:
{
    <ValueMacroName>:<macrovalue>
}

*FontCart:  note the FontCart construct is ROOT_ONLY and
is not multivalued.  Each construct with a unique SymbolName
corresponds to a dedicated FONTCART structure.

If  we want to make FontCarts multivalued,
we introduce a new keyword *AvailFontCarts: LIST(symbol1, symbol2, symbol3)
which is a FreeFloating Global.


MacroProcessing:
=<ValueMacroName>    where a value  or component of a string is expected
=<BlockMacroName>  following a symbolname following a construct Keyword.
*InsertBlock: <BlockMacroName>

recognized value types:
    ORDER :== <section>.<number>


SYMBOLS: Any user defined (not recognized by the parser) token used
to identify a statement or construct or value.
<CommandNames> are not symbols because the parser has a list
of recognized Valid Unidrv commands.   Non Macro Symbols may be
forward referenced:  ie  *DefaultOption or *Constraints may reference
a symbol that is defined later.

where defined:

Associated Keyword: <symbol type>
*Macros: <ValueMacroNames>     not the Group Name!
*BlockMacro: <BlockMacroNames>
*Feature: <featureSymbol>
*Option: <optionSymbol>
*OEM: <OEM group name>   saved in symbol tree for possible future use.
*TTFontSubs:   TTFontnames may be stored as symbols, but
    are not symbols in the strictest sense.

constructs not using symbols:
*TTFontSubs: <ON | OFF>             predefined.
*UIGroup: <Group name>   optional - not used by parser.
*Default: <optional tag>   optional - not used by parser.
*Command:  <Unidrv Command Name>   predefined.  CmdSelect
    is a special name which triggers special processing.
*FontCartridge: <optional tag>  optional - not used by parser.
    Implementation hint: use macros to keep all definitions in one place.
    or introduce *AvailFontCart: LIST(<FontCartSymbol>, <FontCartSymbol>)
    inside constructs.

where referenced:
*InsertMacro: <BlockMacroNames>
*<ConstructKeyword>: <symboldef> =<BlockMacroName>

*<anykeyword>: =<ValueMacroName>
    except *BlockMacro, *InsertMacro, *Include
*Switch: <FeatureName>
*Case: <OptionName>


Currently the parser saves symbols defined in *Feature and *Option
keywords and remembers symbol references made in *Switch and *Case
keywords.

The include keyword:

    must not appear within a macrodefinition
    must not reference a macrovalue
    must be terminated by a linebreak  not {  or } construct.

--- state machine ----

The parser treates construct keywords as operators
which change the state of the parser. (create state
transitions.)

the set of allowed transitions is
defined in the table AllowedTransitions
this table enforces several rules:

the construct _TTFONTSUBS can only
appear at the root level.

no constructs may appear within
OEM, FONTCART, TTFONTSUBS, COMMAND  constructs.


The following code fragment is a comprehensive list
of the allowed state transitions:


    pst = astAllowedTransitions[STATE_ROOT] ;

    pst[CONSTRUCT_UIGROUP] = STATE_UIGROUP;
    pst[CONSTRUCT_FEATURE] = STATE_FEATURE;
    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_FONTCART] = STATE_FONTCART;
    pst[CONSTRUCT_TTFONTSUBS] = STATE_TTFONTSUBS;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_UIGROUP] ;

    pst[CONSTRUCT_UIGROUP] = STATE_UIGROUP;
    pst[CONSTRUCT_FEATURE] = STATE_FEATURE;

    pst = astAllowedTransitions[STATE_FEATURE] ;

    pst[CONSTRUCT_OPTION] = STATE_OPTIONS;
    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;

    pst = astAllowedTransitions[STATE_OPTIONS] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_SWITCH_ROOT] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_ROOT;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_ROOT;

    pst = astAllowedTransitions[STATE_SWITCH_FEATURE] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_FEATURE;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_FEATURE;

    pst = astAllowedTransitions[STATE_SWITCH_OPTION] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_OPTION;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_OPTION;

    pst = astAllowedTransitions[STATE_CASE_ROOT] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_DEFAULT_ROOT] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_CASE_FEATURE] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_DEFAULT_FEATURE] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_CASE_OPTION] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_DEFAULT_OPTION] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;




--- multiple statements and redefinitions: ------

for standard attributes,  if two statements containing
that attribute  with different values appears in the
same construct, the attribute takes the latter occuring value.

If the attribute is defined to be FreeFloating, it may appear
multiple times in different *Option or *Case constructs.
In this case if the effect of the multiple occurances is to
add new branches which are compatible with the existing tree,
or to reinitialize the value of a node in the existing tree
that is an accepted use of multiple occuring attributes.
However if the effect is to define a new branch which is
incompatible with the existing tree, that is an error, and
the latter initialization of the attribute is ignored.

There is one exception to the rule of adding conflicting branches
to the attribute tree.  That exception allows default initializers
to be created.  If an attribute is assigned a value which is
subsequently made multivalued, the initial value becomes the
default initializer  unless the GPD author explicitly specified
a 'default' case when making the attribute multivalued.

Note the order cannot be reversed.
An attribute which is already defined to be multivalued
cannot subsequently be defined to be fewer valued.

--- state machine ----

the set of allowed transitions is
defined in the table AllowedTransitions
this table enforces several rules:

the construct _TTFONTSUBS can only
appear at the root level.

no constructs may appear within
OEM, FONTCART, TTFONTSUBS, COMMAND  constructs.


---- use of switch/case constructs -----

The same feature must not be referenced in nested constructs.
This will produce an attribute tree that contains the same
feature at two different levels.   similarly...
an attribute tree  should not be constructed
piecemeal.  It is an error if the tree is subsequently
redefined/elaborated using a different feature nesting
order.
-----
Severity of errors:

!!!!!:  parser is non-compilable/non-functional unless
    this is resolved.
!!!!:  unfinished functionality.  Some legal GPD files
    will cause corruption.
!!!:   integrity check omitted - a corrupt file may be inadvertantly
    generated if resource limitations are encountered.
!!:  syntax error in GPD may cause widespread corruption
!:  emit useful message for user.
BUG_BUG:  wish item - user friendlier error message etc.
    parser self-consistency check, self diagnostics.
    more general, elegant, faster, more complex code etc.


Note:  PARANOID BUG_BUGs indicate error conditions that are
the result of coding errors (mistaken assumptions, incomplete
code paths etc)  and are not the result of improper GPD syntax,
or resource constraints (overflow of fixed length buffers etc).

All originating error messages should report the name of
the function, name of variable or system call that is
out of range or invalid.

Later, if a caller function sees a failure return value,
it may want to tack on an extra message say
keyword or line number where error occured.

A if a function returns with a failure condition, the caller
may at its discretion increase the severity of the error.
For example if the caller passed a string to be parsed
and it failed, the string parsing function may raise a tiny
error condition.  But if the caller was going to use the
string to open a GPD or resource file, then this suddenly
becomes a major problem.

A function may
never reduce the severity of an error unless code was just
executed which will migitate the source of the problem.
Don't select  ERRSEV_RESTART  unless there is a handler
on the next go round to solve the initial problem.
An endless loop may result otherwise.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\state2.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  state2.c - create, manage the attribute tree   */


#include    "gpdparse.h"


// ----  functions defined in state2.c ---- //

BOOL  BprocessAttribute(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreFontCartAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreTTFontSubAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;


BOOL   BstoreCommandAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreFeatureOptionAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL  BstoreGlobalAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL    BaddBranchToTree(
PTKMAP      ptkmap,         // pointer to tokenmap
PATREEREF   patrAttribRoot,  //   pointer to dword with index
PGLOBL      pglobl
) ;

BOOL   BcreateGlobalInitializerNode(
PDWORD  pdwNodeIndex,
DWORD   dwOffset,
PGLOBL  pglobl) ;

BOOL   BcreateEndNode(
PDWORD  pdwNodeIndex,
DWORD   dwFeature,
DWORD   dwOption,
PGLOBL  pglobl
) ;

BOOL   BfindOrCreateMatchingNode(
IN  DWORD   dwRootNodeIndex , //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,     // points to node in chain also matching option
    DWORD   dwFeatureID,      //
    DWORD   dwOptionID,       //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
) ;

BOOL   BfindMatchingNode(
IN  DWORD   dwRootNodeIndex ,  //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,  // points to node in chain also matching option
    DWORD   dwFeatureID,
    DWORD   dwOptionID,     //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
) ;

BOOL BallocElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
PDWORD       pdwNodeIndex,
PGLOBL       pglobl) ;

BOOL  BreturnElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
DWORD        dwNodeIndex,
PGLOBL       pglobl) ;

BOOL    BconvertSymCmdIDtoUnidrvID(
IN  DWORD   dwCommandID , //  from RegisterSymbol
OUT PDWORD  pdwUnidrvID,
    PGLOBL  pglobl
) ;


// ---------------------------------------------------- //


BOOL  BprocessAttribute(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
{
    DWORD       dwKeywordID ;
    CONSTRUCT   eSubType ;
    BOOL        bStatus = FALSE ;
    STATE       stState;

    dwKeywordID = ptkmap->dwKeywordID ;

    eSubType = (ATTRIBUTE)(mMainKeywordTable[dwKeywordID].dwSubType) ;

    if(mdwCurStsPtr)
        stState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
    else
        stState = STATE_ROOT ;

    if(!(gabAllowedAttributes[stState][eSubType]))
    {
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("the Keyword %0.*s is not allowed within the state: %s\n",
            ptkmap->aarKeyword.dw, ptkmap->aarKeyword.pub,
            gpubStateNames[stState]));
        return(FALSE) ;
    }

    switch(eSubType)
    {
        case  ATT_GLOBAL_ONLY:
        case  ATT_GLOBAL_FREEFLOAT:
        {
            bStatus = BstoreGlobalAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_FEATURE_ONLY:
        case  ATT_LOCAL_FEATURE_FF:
        case  ATT_LOCAL_OPTION_ONLY:
        case  ATT_LOCAL_OPTION_FF:
        {
            bStatus = BstoreFeatureOptionAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_COMMAND_ONLY:
        {
            bStatus = BstoreCommandAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_FONTCART_ONLY:
        {
            bStatus = BstoreFontCartAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_TTFONTSUBS_ONLY:
        {
            bStatus = BstoreTTFontSubAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_OEM_ONLY:
        default:
        {
            //  currently there are no dedicated keywords
            //  for these states.
            //  see  ProcessSymbolKeyword()  which is called elsewhere.
            break ;
        }
    }
    return(bStatus) ;
}





BOOL   BstoreFontCartAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
/*    assume the FontCartID is stored in the state stack
    whenever a FontCart construct is encountered.
    FontCart info is not multivalued.  Thus all binary
    info is stored directly into an array of fontcart
    structures indexed by FontCartID.
*/
{
    DWORD   dwFontCartID = INVALID_SYMBOLID ;
    DWORD    dwTstsInd, dwTstsInd2 ;
    STATE   stState ;

    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        dwTstsInd2 = mdwCurStsPtr - (1 + dwTstsInd) ;
            //  this is the safe way of decrementing an unsigned index

        stState = mpstsStateStack[dwTstsInd2].stState ;

        if(stState == STATE_FONTCART)
        {
            dwFontCartID = mpstsStateStack[dwTstsInd2].dwSymbolID  ;
            break ;
            //  parser can't even recognize a fontcart attribute
            //  outside of STATE_FONTCART so this path is 100% certain
        }
    }
    if(dwFontCartID == INVALID_SYMBOLID)
    {
        //  BUG_BUG!  - what does this imply?  how could
        //  this situation occur?
        return(FALSE) ;
    }

    if (!BaddValueToHeap(&dwFontCartID,
        ptkmap, TRUE, pglobl))
    {
        return(FALSE) ;
    }
    return(TRUE) ;
}


BOOL   BstoreTTFontSubAttrib(
PTKMAP  ptkmap,  // pointer to tokenmap
PGLOBL  pglobl
)
/*    assume the TTFontSubID is stored in the state stack
    whenever a TTFontSub construct is encountered.
    TTFontSub info is not multivalued.  Thus all binary
    info is stored directly into an array of TTFontSub
    structures indexed by TTFontSubID.
*/
{
    DWORD   dwTTFSID = INVALID_SYMBOLID ;
    DWORD    dwTstsInd, dwTstsInd2 ;
    STATE   stState ;

    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        dwTstsInd2 = mdwCurStsPtr - (1 + dwTstsInd) ;
            //  this is the safe way of decrementing an unsigned index

        stState = mpstsStateStack[dwTstsInd2].stState ;

        if(stState == STATE_TTFONTSUBS)
        {
            dwTTFSID = mpstsStateStack[dwTstsInd2].dwSymbolID  ;
            break ;
            //  parser can't even recognize a TTfontsub attribute
            //  outside of STATE_TTFONTSUBS so this path is 100% certain
        }
    }
    if(dwTTFSID == INVALID_SYMBOLID)
    {
        //  BUG_BUG!  - what does this imply?  how could
        //  this situation occur?
        return(FALSE) ;
    }

    if (!BaddValueToHeap(&dwTTFSID,
        ptkmap, TRUE, pglobl))
    {
        return(FALSE) ;
    }
    return(TRUE) ;
}





BOOL   BstoreCommandAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
/*   assume CreateTokenMap has parsed the CommandName
    (the value after the *Command keyword.) and converted
    it to a CommandID storing it in dwValue.

    further assume the CommandID is stored in the state stack
    whenever a COMMAND construct is encountered.
*/
{
    BOOL    bStatus = FALSE ;
    DWORD   dwCommandID = INVALID_SYMBOLID, dwUnidrvID  ;
            //  remember the CommandID is issued by the parser
            //  on a first come first served basis, the dwUnidrvID
            //  is predefined.
    DWORD    dwTstsInd, dwTstsInd2 ;  // temp state stack index
    STATE   stState ;
    PATREEREF  patr ;


    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        dwTstsInd2 = mdwCurStsPtr - (1 + dwTstsInd) ;
            //  this is the safe way of decrementing an unsigned index

        stState = mpstsStateStack[dwTstsInd2].stState ;

        if(stState == STATE_COMMAND )
        {
            dwCommandID = mpstsStateStack[dwTstsInd2].dwSymbolID  ;
            break ;
            //  parser can't even recognize a command attribute
            //  outside of STATE_COMMAND so this path is 100% certain
        }
    }
    if(dwCommandID == INVALID_SYMBOLID)
    {
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("Internal error: BstoreCommandAttrib - invalid CommandID.\n"));
        return(FALSE) ;
    }

    if(!BconvertSymCmdIDtoUnidrvID( dwCommandID , &dwUnidrvID, pglobl) )
    {
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("unrecognized Unidrv command name: *%0.*s.\n",
            ptkmap->aarValue.dw,
            ptkmap->aarValue.pub));
        return(FALSE) ;
    }

    if(dwUnidrvID == CMD_SELECT)
    {
        PDFEATURE_OPTIONS   pfo ;
        DWORD   dwFeatureID ;

        for(dwTstsInd = 0 ; dwTstsInd < dwTstsInd2 ; dwTstsInd++)
        {
            stState = mpstsStateStack[dwTstsInd].stState ;
            if(stState == STATE_FEATURE )
            {
                BOOL    bInsideOpt ;

                dwFeatureID = mpstsStateStack[dwTstsInd].dwSymbolID  ;

                for(bInsideOpt = FALSE , dwTstsInd++ ; dwTstsInd < dwTstsInd2 ;
                    dwTstsInd++)
                {
                    stState = mpstsStateStack[dwTstsInd].stState ;
                    if(stState == STATE_OPTIONS )
                        bInsideOpt = TRUE ;
                }

                if(!bInsideOpt)
                    break ;  //  CmdSelect must reside within an option.

                pfo = (PDFEATURE_OPTIONS)
                    gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct +
                    dwFeatureID ;

                bStatus = BaddBranchToTree(ptkmap, &(pfo->atrCommandIndex), pglobl) ;
                return(bStatus) ;
            }
        }
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("syntax err: the CmdSelect specifier can only be used inside an Option construct.\n"));

        return(FALSE) ;
    }

    //  else  CommandID refers to a predefined Unidrv command.
    //  figure out address of command table.
    patr = (PATREEREF) gMasterTable[MTI_COMMANDTABLE].pubStruct ;
    bStatus = BaddBranchToTree(ptkmap,  patr + dwUnidrvID, pglobl) ;
    //  note: assumes commandtable is large enough.
    return(bStatus) ;
}



BOOL   BstoreFeatureOptionAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
/*  strange but true, since feature and option attributes
    share the same structure, they can use the same code!
    In fact LOCAL_FEATURES will end up single valued, and
    all OPTIONs will end up multivalued as planned!
*/
{
    BOOL    bStatus = FALSE ;
    PDFEATURE_OPTIONS   pfo ;
    DWORD   dwFeatureID = 0;  // to silence prefast
    DWORD    dwTstsInd ;  // temp state stack index
    STATE   stState ;
    DWORD   dwOffset;
    DWORD   dwKeywordID ;


    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        stState = mpstsStateStack[dwTstsInd].stState ;
        if(stState == STATE_FEATURE )
        {
            dwFeatureID = mpstsStateStack[dwTstsInd].dwSymbolID  ;
            break ;
        }
    }
    if(dwTstsInd >= mdwCurStsPtr)
        return (FALSE) ;

    // Return FAILURE  if we go through the entire
    // stack and never find a feature state.  this could only
    // happen via a coding error.  The process of creating the
    // token map uses the state to select the proper attribute
    // dictionary to be used to identify each unrecognized keyword.

    ASSERT(dwFeatureID < gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize);

    // paranoid  BUG_BUG:  may check to see if we allocated enough
    //  FeatureOptions
    //  if( dwFeatureID >= gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize )
    //      failure. - code error.

    //  just get address of structure holding attribute values.
    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct +
            dwFeatureID ;

    dwKeywordID = ptkmap->dwKeywordID ;
    dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

    bStatus = BaddBranchToTree(ptkmap,  (PATREEREF)((PBYTE)pfo + dwOffset), pglobl) ;

    return(bStatus) ;
}


BOOL  BstoreGlobalAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
{
    BOOL    bStatus = FALSE ;
    PBYTE   pub ;
    DWORD   dwOffset;
    DWORD   dwKeywordID ;


    // BUG_BUG:  may check to see if this value is equal to 1:
    //  if( gMasterTable[MTI_GLOBALATTRIB].dwArraySize != 1)
    //      failure. - code error.
    //  a zero indicates no memory has yet been allocated.
    ASSERT( gMasterTable[MTI_GLOBALATTRIB].dwArraySize == 1) ;

    //  just get address of structure holding attribute values.
    pub =  gMasterTable[MTI_GLOBALATTRIB].pubStruct ;

    dwKeywordID = ptkmap->dwKeywordID ;
    dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

    //  the location PATREEREF contains either the values offset
    //  in the heap or the index to the root of the attribute tree

    bStatus = BaddBranchToTree(ptkmap, (PATREEREF)(pub + dwOffset), pglobl) ;

    return(bStatus) ;
}






BOOL    BaddBranchToTree(
PTKMAP      ptkmap,   // pointer to tokenmap
PATREEREF   patrAttribRoot,  //   pointer to dword with index
                             //  of root to selected attribute value tree.
PGLOBL      pglobl
)

// create/expand attribute tree or overwrite node on existing tree
// If new branch is not compatible
// with existing tree, it is an error.  You may overwrite a node
// in the tree, but you may not alter the branches in the tree.
// in case of failure there will be 2 outcomes:
// a) the attribute tree is left unchanged.
// b) a new node is added, but is left uninitialized.
//    (atrAttribRoot == ATTRIB_UNINITIALIZED)     -or-
//    (patt[*pdwNodeIndex].eOffsetMeans == UNINITIALIZED)


//  algorithm: starting from index 0 walk up the state stack
//  recording symbolIDs until both a FeatureID and OptionID
//  has been collected.  This defines one segment of the
//  new branch that will be added to the tree.  Now walk
//  the tree to see if an identical branch exists.  If so
//  go there and go collect another FeatureID/OptionID pair
//  so we can repeat the process.  If such a segment does not
//  exist on the tree, create it.  When the stack is empty,
//  parse the value and store it on the new leaf node on the
//  tree.

//  In the simplest case, there are no feature/option pairs
//  on the stack.  This means we have a root level attribute,
//  which  just overwrite/creates the global initializer node.

//  If there is a feature/option pair on the stack we
//  enter a loop to process each feature/option pair.
//  the first pass of the loop handles the boundary conditions.
//  Here is where we need to deal with the special
//  cases of  patrAttribRoot referencing the heap
//  or the global initializer node.
//
//  I) patrAttribRoot contains node index
//      A) node is global default initializer
//          1) there is no sublevel.
//              create a new sublevel.
//              link global default initializer to sublevel
//          2) next points to a node (new sublevel)
//              go into new sublevel, now handle just like
//              case I.B).
//      B) node is normal
//          1) if node's Feature doesn't match FeatureID
//              the new branch is incompatible with the tree
//              abort.
//          2) Feature's match, search for matching option
//              a)  option found, drop to end of loop
//              b)  option not found, create new node at end
//                  i) previous node is a default initializer
//                      copy its contents to new node.
//                      initialize node just vacated to
//                      FeatureID, OptionID
//                  ii) initialize new node to
//                      FeatureID, OptionID
//  II) patrAttribRoot is uninitialized
//      create new sublevel
//      link patrAttribRoot to sublevel
//  III) patrAttribRoot pts to heap
//      create global initializer node
//      link heap to initializer node
//      create new sublevel
//      link initializer node to new sublevel
//
//
//
//   on each subsequent pass through the attribute tree/stack,
//      we attempt to enter the next sublevel, since
//      this is what corresponds to the new FeatureID/OptionID
//      pair retrieved from the stack.
//
//  I) there is a sublevel from this node
//      enter sublevel
//      1) if node's Feature doesn't match FeatureID
//          the new branch is incompatible with the tree
//          abort.
//      2) Feature's match, search for matching option
//          a)  option found, drop to end of loop
//          b)  option not found, create new node at end
//              i) previous node is a default initializer
//                  copy its contents to new node.
//                  initialize node just vacated to
//                  FeatureID, OptionID
//              ii) initialize new node to
//                  FeatureID, OptionID
//  II) there is no sublevel
//      1)  if the current node references a VALUE
//          create a new sublevel node (to be the default)
//          initialize it with the value from the
//          current node.
//          a)  if optionID is not DEFAULT_INIT
//              insert another node prior to
//              the default node just created.
//      2)  else current node is UNINITIALIZED.
//          create a new sublevel node.
//
//
//
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    DWORD        dwTstsInd ;  // temp state stack index
    STATE   stState ;
    DWORD   dwFeatureID, dwOptionID ;
    DWORD  dwNodeIndex ;
    DWORD  dwPrevsNodeIndex ;  // will keep track
    //  of where we are as we navigate the tree.


    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;
            //  determine this even though we may not use it.

    dwPrevsNodeIndex = END_OF_LIST ;  // first pass will go
    // through special initialization code.

    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        //  BUG_BUG  paranoid:  code assumes state stack is
        //  well behaved as it should be if code is written
        //  correctly.  No safety checks here.
        //  any errors will cause failure further along.

        stState = mpstsStateStack[dwTstsInd].stState ;

        if(stState == STATE_FEATURE  ||
            stState == STATE_SWITCH_ROOT  ||
            stState == STATE_SWITCH_FEATURE  ||
            stState == STATE_SWITCH_OPTION)
        {
            dwFeatureID = mpstsStateStack[dwTstsInd].dwSymbolID  ;
            continue ;
        }
        if(stState == STATE_OPTIONS  ||
            stState == STATE_CASE_ROOT  ||
            stState == STATE_CASE_FEATURE  ||
            stState == STATE_CASE_OPTION)
        {
            dwOptionID = mpstsStateStack[dwTstsInd].dwSymbolID  ;
        }
        else if(stState == STATE_DEFAULT_ROOT  ||
            stState == STATE_DEFAULT_FEATURE  ||
            stState == STATE_DEFAULT_OPTION)
        {
            dwOptionID = DEFAULT_INIT ;
        }
        else
        {
            continue ;  // these states have no effect on the attrib tree
        }

        if(dwPrevsNodeIndex == END_OF_LIST)
        {
            //  first pass through the for loop
            //  process all special cases first time
            //  around.

            if(*patrAttribRoot == ATTRIB_UNINITIALIZED)  //  case II)
            {
                //  create a new tree consisting of one node .

                if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                    dwOptionID, pglobl)  )
                {
                    return(FALSE) ;
                }

                *patrAttribRoot = dwNodeIndex ;  // Make this one node
                    //  the root of the tree.
                dwPrevsNodeIndex = dwNodeIndex ;
                continue ;  // ready for next level.
            }
            else if(*patrAttribRoot & ATTRIB_HEAP_VALUE)  // case III)
            {
                //  turn off heap flag to leave pure heap offset,
                //  then store heap offset into new Node.

                if(! BcreateGlobalInitializerNode(&dwNodeIndex,
                    *patrAttribRoot & ~ATTRIB_HEAP_VALUE, pglobl) )
                {
                    return(FALSE) ;
                }
                *patrAttribRoot = dwNodeIndex ;  // Make the global
                    //  initializer node the root of the new tree.

                dwPrevsNodeIndex = dwNodeIndex ;

                if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                    dwOptionID, pglobl)  )    //  new sublevel node.
                {
                    return(FALSE) ;
                }
                patt[dwPrevsNodeIndex].dwNext = dwNodeIndex ;
                    //  global initializer node references sublevel node.

                dwPrevsNodeIndex = dwNodeIndex ;
                continue ;  // ready for next level.
            }
            else  //  case I)
            {

                dwNodeIndex = *patrAttribRoot ;

                if(patt[dwNodeIndex].dwFeature == DEFAULT_INIT ) // I.A)
                {
                    if(patt[dwNodeIndex].dwNext == END_OF_LIST) // I.A.1)
                    {
                        //  create a new sublevel
                        dwPrevsNodeIndex = dwNodeIndex ;
                            // hold global initializer in PrevsNode.

                        if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                            dwOptionID, pglobl)  )
                        {
                            return(FALSE) ;
                        }

                        patt[dwPrevsNodeIndex].dwNext = dwNodeIndex ;
                            //  global initializer node references sublevel
                            //  node.
                        dwPrevsNodeIndex = dwNodeIndex ;
                        continue ;  // ready for next level.
                    }
                    else  //  I.A.2)
                    {
                        dwNodeIndex = patt[dwNodeIndex].dwNext ;
                        //  enter new sublevel and drop into
                        //  code path for case   I.B)
                    }
                }
                //  case I.B)
                if(!BfindOrCreateMatchingNode(dwNodeIndex, &dwNodeIndex,
                    dwFeatureID, dwOptionID, pglobl) )
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    return(FALSE) ;
                }
                dwPrevsNodeIndex = dwNodeIndex ;   // goto end of loop.
                continue ;
            }
        }

        //  this is the generic case: dwPrevsNodeIndex points
        //  to a normal node and this node matched the
        //  feature/option from the previous pass.
        //  objective:  boldly attempt to enter the sublevel
        //  and see if there is something there that matches
        //  what we are seeking.

        if(patt[dwPrevsNodeIndex].eOffsetMeans == NEXT_FEATURE)
        {
            // Down to the next level we go.
            dwNodeIndex = patt[dwPrevsNodeIndex].dwOffset ;

            if(!BfindOrCreateMatchingNode(dwNodeIndex, &dwNodeIndex, dwFeatureID,
                dwOptionID, pglobl) )
            {
                vIdentifySource(ptkmap, pglobl) ;
                return(FALSE) ;
            }
            dwPrevsNodeIndex = dwNodeIndex ;   // goto end of loop.
        }
        else  //  must create a new sublevel now.
        {
            DWORD  dwDefaultNode = END_OF_LIST;

            //  OffsetMeans can be either VALUE or  UNINITIALIZED.
            if(patt[dwPrevsNodeIndex].eOffsetMeans == VALUE_AT_HEAP)
            {
                // create a default initializer node for the
                //  new sublevel.  Transfer heap offset from Prevs
                //  node into it.

                if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                    DEFAULT_INIT, pglobl)  )
                {
                    return(FALSE) ;
                }
                patt[dwNodeIndex].eOffsetMeans = VALUE_AT_HEAP ;
                patt[dwNodeIndex].dwOffset =
                    patt[dwPrevsNodeIndex].dwOffset ;
                dwDefaultNode = dwNodeIndex ;  // remember this node
            }

            //  create first sublevel node with desired feature/option.

            if(dwDefaultNode == END_OF_LIST  ||
                dwOptionID != DEFAULT_INIT)
            {
                //  this means if a default initializer node
                //  was already created to propagate the value
                //  from the previous level AND  the new branch
                //  also specifies a default initializer node, there's
                //  no need to create a second initializer node.

                //  if this path is being executed, it means above
                //  statement is FALSE.

                if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                    dwOptionID, pglobl) )
                {
                    return(FALSE) ;
                }
                patt[dwNodeIndex].dwNext = dwDefaultNode ;
            }

            patt[dwPrevsNodeIndex].eOffsetMeans = NEXT_FEATURE ;
            patt[dwPrevsNodeIndex].dwOffset = dwNodeIndex ;

            dwPrevsNodeIndex = dwNodeIndex ;  // goto end of loop.
        }
    }  //  end of for loop

    //  we have navigated to the end of the new branch.
    //  now parse the value, and store in binary form in the heap.
    //  if a previous VALUE existed, overwrite it on the heap,
    //  otherwise allocate fresh storage on the heap.

    if(dwPrevsNodeIndex != END_OF_LIST)  // there was branch in the stack.
    {
        if (patt[dwPrevsNodeIndex].eOffsetMeans == NEXT_FEATURE)
        {
            vIdentifySource(ptkmap, pglobl) ;
            ERR(("syntax error: attempt to truncate existing attribute tree.\n"));
            return(FALSE) ;
        }
        if (!BaddValueToHeap(&patt[dwPrevsNodeIndex].dwOffset,
            ptkmap, (patt[dwPrevsNodeIndex].eOffsetMeans == VALUE_AT_HEAP ), pglobl))
        {
            return(FALSE) ;
        }
        patt[dwPrevsNodeIndex].eOffsetMeans = VALUE_AT_HEAP ;
        //  if dwOffset was originally UNINITIALIZED, its not anymore.
    }
    else                //  attribute found at root level.
    {                   //  this means we update/create
                        //  the global default initializer.
        if(*patrAttribRoot == ATTRIB_UNINITIALIZED)
        {
            //  parse value token, add value (in binary form) into heap.
            if(! BaddValueToHeap((PDWORD)patrAttribRoot, ptkmap, FALSE, pglobl) )
            {
                //  BUG_BUG  what do we do if parsing or something happens?
                //      for now just return failure as is.  Lose one attribute.
                //      Sanity check later will determine if this
                //      omission is fatal.
                *patrAttribRoot = ATTRIB_UNINITIALIZED ;
                return(FALSE);
            }
            // returns offset in heap of parsed Value in patrAttribRoot
            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
        }
        else if(*patrAttribRoot & ATTRIB_HEAP_VALUE)
        {
            *patrAttribRoot &= ~ATTRIB_HEAP_VALUE ;
            //  turn off flag to leave pure heap offset.

            if(! BaddValueToHeap((PDWORD)patrAttribRoot, ptkmap, TRUE, pglobl) )
            {
                *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
                return(FALSE);
            }
            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
        }
        else    // patrAttribRoot contains index of root of attribute tree.
        {

            //  does a global default initializer node exist?
            if(patt[*patrAttribRoot].dwFeature == DEFAULT_INIT)
            {
                if(! BaddValueToHeap(&patt[*patrAttribRoot].dwOffset,
                    ptkmap, TRUE, pglobl) )
                {
                    return(FALSE);
                }
            }
            else    //  if not, we need to create one.
            {
                if(! BcreateGlobalInitializerNode(&dwNodeIndex, 0, pglobl) )
                {
                    return(FALSE) ;
                }
                if (! BaddValueToHeap(&patt[dwNodeIndex].dwOffset,
                                                        ptkmap, FALSE, pglobl) )
                {
                    (VOID)BreturnElementFromMasterTable(MTI_ATTRIBTREE,
                        dwNodeIndex, pglobl);
                    return(FALSE) ;
                }

                patt[dwNodeIndex].dwNext = *patrAttribRoot ;

                *patrAttribRoot = dwNodeIndex ;  // Make the default
                    //  initializer the root of the tree.
            }
        }
    }
    return(TRUE) ;  // mission accomplished.
}

BOOL   BcreateGlobalInitializerNode(
PDWORD  pdwNodeIndex,
DWORD   dwOffset,  // caller can initialize this now.
PGLOBL  pglobl)
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    if(! BallocElementFromMasterTable(MTI_ATTRIBTREE ,
        pdwNodeIndex, pglobl ) )
    {
        return(FALSE) ;
    }
    patt[*pdwNodeIndex].dwFeature = DEFAULT_INIT ;
    //  don't care what dwOption says.
    patt[*pdwNodeIndex].eOffsetMeans = VALUE_AT_HEAP ;
    patt[*pdwNodeIndex].dwNext = END_OF_LIST ;
    patt[*pdwNodeIndex].dwOffset = dwOffset ;
    return(TRUE) ;
}

BOOL   BcreateEndNode(
PDWORD  pdwNodeIndex,
DWORD   dwFeature,
DWORD   dwOption,
PGLOBL  pglobl
)
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    if(! BallocElementFromMasterTable(MTI_ATTRIBTREE ,
        pdwNodeIndex, pglobl) )
    {
        return(FALSE) ;
    }
    patt[*pdwNodeIndex].dwFeature = dwFeature ;
    patt[*pdwNodeIndex].dwOption = dwOption ;
    patt[*pdwNodeIndex].eOffsetMeans = UNINITIALIZED ;
    patt[*pdwNodeIndex].dwNext = END_OF_LIST ;
    //  patt[*dwNodeIndex].dwOffset = not yet defined.
    return(TRUE) ;
}



BOOL   BfindOrCreateMatchingNode(
IN  DWORD   dwRootNodeIndex ,  //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,  // points to node in chain also matching option
    DWORD   dwFeatureID,   //
    DWORD   dwOptionID,     //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
)
/*  caller passes a NodeIndex that points to the first node in
    a horizontal (option) chain.
    If the feature of the Node doesn't match dwFeature, this indicates
    the new branch caller is attempting to add is incompatible
    with the existing tree and an error results.   Otherwise,
    search horizontally along the tree searching for a matching
    option.  If found, return the index of that node, else
    must create one.  Make sure the default initializer node is
    always the last node in the chain.
*/
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    DWORD           dwPrevsNodeIndex ;

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    if(patt[dwRootNodeIndex].dwFeature != dwFeatureID )
    {
        ERR(("BfindOrCreateMatchingNode: this branch conflicts with the existing tree \n"));
        //  and cannot be added.
        return(FALSE) ;
    }

    // Yes feature matches, search for matching option.

    *pdwNodeIndex = dwRootNodeIndex ;  // protects rootatr from
        // being overwritten.


    for(   ; FOREVER ; )
    {
        if(patt[*pdwNodeIndex].dwOption == dwOptionID )
        {
            //  we found it!
            return(TRUE) ;
        }
        if(patt[*pdwNodeIndex].dwNext == END_OF_LIST)
            break ;
        *pdwNodeIndex = patt[*pdwNodeIndex].dwNext ;
    }

    //  matching option not found
    //  create node, attach it to the end

    dwPrevsNodeIndex = *pdwNodeIndex ;  // last node in list.

    if(! BallocElementFromMasterTable(MTI_ATTRIBTREE ,
        pdwNodeIndex, pglobl) )
    {
        return(FALSE) ;
    }
    patt[*pdwNodeIndex].dwNext = END_OF_LIST ;
    patt[dwPrevsNodeIndex].dwNext = *pdwNodeIndex ;

    if(patt[dwPrevsNodeIndex].dwOption == DEFAULT_INIT)
    {
        // must copy default data to new node
        // the default initializer must remain at
        // the end of the list.
        patt[*pdwNodeIndex].dwOption =
            patt[dwPrevsNodeIndex].dwOption;
        patt[*pdwNodeIndex].dwOffset =
            patt[dwPrevsNodeIndex].dwOffset;
        patt[*pdwNodeIndex].dwFeature =
            patt[dwPrevsNodeIndex].dwFeature;
        patt[*pdwNodeIndex].eOffsetMeans =
            patt[dwPrevsNodeIndex].eOffsetMeans;
        *pdwNodeIndex = dwPrevsNodeIndex ;
        //  want new initialization to occur in
        //  second to last node.  How do you
        //  know dwOptionID isn't DEFAULT_INIT?
        //  simple because since a DEFAULT_INIT
        //  node does exist in the chain, the
        //  search would have found it and
        //  exited the function long before
        //  reaching this code.
    }

    //  initialize vacated or last node.

    patt[*pdwNodeIndex].dwOption = dwOptionID;
    patt[*pdwNodeIndex].dwFeature = dwFeatureID;
    patt[*pdwNodeIndex].eOffsetMeans = UNINITIALIZED ;
    //   patt[*pdwNodeIndex].dwOffset = don't know yet

    return(TRUE) ;
}


BOOL   BfindMatchingNode(
IN  DWORD   dwRootNodeIndex ,  //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,  // points to node in chain also matching option
    DWORD   dwFeatureID,
    DWORD   dwOptionID,     //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
)
/*  caller passes a NodeIndex that points to the first node in
    a horizontal (option) chain.
    If the feature of the Node doesn't match dwFeature, this indicates
    the new branch caller is attempting to add is incompatible
    with the existing tree and an error results.   Otherwise,
    search horizontally along the tree searching for a matching
    option.  If found, return the index of that node, else
    returns FALSE.
*/
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    DWORD           dwPrevsNodeIndex ;

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    *pdwNodeIndex = dwRootNodeIndex ;  // protects rootatr from
        // being overwritten.

    if(patt[*pdwNodeIndex].dwFeature != dwFeatureID )
    {
        ERR(("BfindMatchingNode: this branch conflicts with the existing tree \n"));
        //  and cannot be added.
        return(FALSE) ;
    }

    // Yes feature matches, search for matching option.

    for(   ; FOREVER ; )
    {
        if(patt[*pdwNodeIndex].dwOption == dwOptionID )
        {
            //  we found it!
            return(TRUE) ;
        }
        if(patt[*pdwNodeIndex].dwNext == END_OF_LIST)
            break ;
        *pdwNodeIndex = patt[*pdwNodeIndex].dwNext ;
    }

    return(FALSE);  //  matching option not found
}




BOOL BallocElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
PDWORD       pdwNodeIndex,
PGLOBL       pglobl)
{
    if(gMasterTable[eMTIndex].dwCurIndex >=
        gMasterTable[eMTIndex].dwArraySize)
    {
        ERR(("BallocElementFromMasterTable: Out of array elements - restart.\n"));

        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = eMTIndex ;
        }
        return(FALSE) ;
    }
    *pdwNodeIndex = gMasterTable[eMTIndex].dwCurIndex ;
    gMasterTable[eMTIndex].dwCurIndex++ ;  //  Node now taken.
    return(TRUE) ;
}

BOOL  BreturnElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
DWORD        dwNodeIndex,
PGLOBL       pglobl)
{
    if(gMasterTable[eMTIndex].dwCurIndex == dwNodeIndex + 1)
    {
        gMasterTable[eMTIndex].dwCurIndex = dwNodeIndex ;
        return(TRUE) ;
    }
    //   BUG_BUG:  Can return only the most recently allocated node
    //  not a concern , memory waste is at most 1% and only temporary.
    if(ERRSEV_CONTINUE > geErrorSev)
    {
        geErrorSev = ERRSEV_CONTINUE ;
        geErrorType = ERRTY_CODEBUG ;
        gdwMasterTabIndex = eMTIndex ;
    }
    return(FALSE) ;
}


BOOL    BconvertSymCmdIDtoUnidrvID(
IN  DWORD   dwCommandID , //  from RegisterSymbol
OUT PDWORD  pdwUnidrvID,
    PGLOBL  pglobl
)
{   //  convert dwCommandID to UnidrvID
    PSYMBOLNODE     psn ;
    ABSARRAYREF     aarKey ;
    DWORD           dwNodeIndex ;
    BOOL            bStatus ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwNodeIndex = DWsearchSymbolListForID(dwCommandID,
                mdwCmdNameSymbols, pglobl) ;
    aarKey.dw = psn[dwNodeIndex].arSymbolName.dwCount ;
    aarKey.pub = mpubOffRef + psn[dwNodeIndex].arSymbolName.loOffset ;

    bStatus = BparseConstant(&aarKey, pdwUnidrvID,
        VALUE_CONSTANT_COMMAND_NAMES, pglobl) ;
    return(bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\treewalk.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  treewalk.c - functions to enumerate string and font IDs found
in the GPD file.  */

/*  this source file used only by mdt  so is built only
as part of the gpd library  */

#include    "gpdparse.h"


#ifndef  PARSERDLL



// ----  functions defined in treewalk.c ---- //
BOOL    GetGPDResourceIDs(
PDWORD pdwResArray,
DWORD   dwArraySize,    //  number of elements in array.
PDWORD   pdwNeeded,
BOOL bFontIDs,
PRAWBINARYDATA prbd) ;

BOOL   BWalkTheAttribTree(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  BOOL    bList,  // is the value stored as a list?
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
);

BOOL    BRecurseDownTheTree(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  DWORD    dwNodeIndex,    //   first node in chain of attribute tree to navigate.
IN  BOOL    bList,  // is the value stored as a list?
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
) ;

BOOL    bWalkTheList(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  DWORD    dwListIndex,    //   first node in LIST to navigate.
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
);

BOOL    bAddIDtoArray(
IN  DWORD    dwID,    //   ID value to add to array.
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
);




BOOL    GetGPDResourceIDs(
PDWORD pdwResArray,
DWORD   dwArraySize,    //  number of elements in array.
PDWORD   pdwNeeded,
BOOL bFontIDs,
PRAWBINARYDATA prbd)
/*
Parameters:
    pdwResArray     Resource IDs are loaded into this array
    dwArraySize     Number of elements in the array
    pdwNeeded       Number of IDs of the specified resource in the GPD
    bFontIDs        True if UFM IDs should be loaded into array or false if string IDs should be loaded
    prbd        GPD raw data pointer from GPDPARSE.DLL.
Returns:
   Return FALSE only if BUD corruption has occured.

  if  pdwResArray is NULL, the number of elements required for the array  is stored in pdwNeeded.
  if pdwResArray is not NULL, the number of Resource IDs copied into the array  is stored in pdwNeeded.

*/
{
    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubHeap ;  // ptr to start of heap.
    PGLOBALATTRIB  pga ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    BOOL    bStatus = TRUE ;
    DWORD   dwNumFeatures, dwFea, dwNumStructs, dwIndex,
                    dwStart, dwEnd, dwI;
    PDFEATURE_OPTIONS  pfo ;
    PTTFONTSUBTABLE     pttfs ;
    PFONTCART                 pfontcart ;



    *pdwNeeded = 0 ;  // initally set to zero.

    pStatic = (PSTATICFIELDS)prbd ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;


//  need to do this for each section in ssTableIndex

    pga = (PGLOBALATTRIB)(pubRaw + pearTableContents[MTI_GLOBALATTRIB].
                            loOffset) ;


    dwStart = pStatic->ssTableIndex[SSTI_GLOBALS].dwStart ;  // starting Index
    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_UIINFO].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.

        if(bFontIDs  &&  !(pStatic->snapShotTable[dwI].dwFlags  & SSF_FONTID))
            continue;
        if(!bFontIDs  &&  !(pStatic->snapShotTable[dwI].dwFlags  & SSF_STRINGID))
            continue;

        patrRoot = (PATREEREF)((PBYTE)pga +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;

        bStatus = BWalkTheAttribTree(
            (PBYTE)prbd,  // start of Rawbinary data
            *patrRoot,    //
            pStatic->snapShotTable[dwI].dwFlags  & SSF_LIST,  // is the value stored as a list?
            pdwResArray,
            dwArraySize,    //  number of elements in array.
            pdwNeeded   ) ;
    }
    if(!bStatus)
        return(bStatus);

    //  find IDs in Feature/Option structure.

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;
    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    for( dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwStart = pStatic->ssTableIndex[SSTI_FEATURES].dwStart ;  // starting Index
        dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONEX].dwEnd ;  // Ending Index

        for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
        {
            if(!(pStatic->snapShotTable[dwI].dwNbytes))
                continue ;  // skip over section delimiter.

            if(bFontIDs  &&  !(pStatic->snapShotTable[dwI].dwFlags  & SSF_FONTID))
                continue;
            if(!bFontIDs  &&  !(pStatic->snapShotTable[dwI].dwFlags  & SSF_STRINGID))
                continue;

            patrRoot = (PATREEREF)((PBYTE)(pfo + dwFea) +
                        pStatic->snapShotTable[dwI].dwSrcOffset) ;

            bStatus = BWalkTheAttribTree(
                (PBYTE)prbd,  // start of Rawbinary data
                *patrRoot,    //
                pStatic->snapShotTable[dwI].dwFlags  & SSF_LIST,  // is the value stored as a list?
                pdwResArray,
                dwArraySize,    //  number of elements in array.
                pdwNeeded   ) ;
        }
        if(!bStatus)
            return(bStatus);
    }


    pfontcart = (PFONTCART)(pubRaw + pearTableContents[MTI_FONTCART].
                            loOffset) ;

    dwNumStructs = pearTableContents[MTI_FONTCART].dwCount  ;

    for( dwIndex = 0 ; bStatus  &&  (dwIndex < dwNumStructs) ; dwIndex++)
    {
        if(bFontIDs)
        {
            bStatus = bWalkTheList(
                            (PBYTE)prbd,  pfontcart[dwIndex].dwPortFontLst,
                            pdwResArray,  dwArraySize, pdwNeeded ) ;
            if(!bStatus)
                break;
            bStatus = bWalkTheList(
                            (PBYTE)prbd,  pfontcart[dwIndex].dwLandFontLst,
                            pdwResArray,  dwArraySize, pdwNeeded ) ;
            if(!bStatus)
                break;
        }
        else
        {
            bStatus = bAddIDtoArray(
                 pfontcart[dwIndex].dwRCCartNameID,    //   ID value to add to array.
                pdwResArray, dwArraySize,  pdwNeeded) ;
        }

        //  DWORD   dwFontLst ;  // Index to list of FontIDs
        //  is already incorporated into landscape and portrait lists
    }


    pttfs = (PTTFONTSUBTABLE)(pubRaw + pearTableContents[MTI_TTFONTSUBTABLE].
                            loOffset) ;

    dwNumStructs = pearTableContents[MTI_TTFONTSUBTABLE].dwCount  ;

    for( dwIndex = 0 ; !bFontIDs  &&  bStatus  &&
                    (dwIndex < dwNumStructs) ; dwIndex++)
    {
        bStatus = bAddIDtoArray(
             pttfs[dwIndex].dwRcTTFontNameID,    //   ID value to add to array.
            pdwResArray, dwArraySize,  pdwNeeded) ;

        if(!bStatus)
            break;

        bStatus = bAddIDtoArray(
             pttfs[dwIndex].dwRcDevFontNameID,    //   ID value to add to array.
            pdwResArray, dwArraySize,  pdwNeeded) ;
    }

    return(bStatus);
}



//   Return FALSE only if BUD corruption has occured.

BOOL   BWalkTheAttribTree(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  BOOL    bList,  // is the value stored as a list?
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
                                            //  or values found.  Initial value
                                            //  may be non-zero since this
                                            //  accumulates starting from the
                                            //  first call.  Also serves to track where
                                            //  in arIDarray the function should
                                            //  be storing the ID values.
)
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    DWORD  dwNodeIndex;  // Points to first node in chain

    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubHeap ;  // ptr to start of heap.
    BOOL    bStatus = TRUE ;
    DWORD   dwValue, dwListIndex ;   // index to listnode.
    PDWORD   pdwID ;   // points to value on the heap.


    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  obtain pointers to structures:

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    patt = (PATTRIB_TREE)(pubRaw + pearTableContents[MTI_ATTRIBTREE].
                            loOffset) ;

    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;

    //  *pdwNeeded  = 0 ;  //  this is done only once by the caller.

    //  after processing initial special cases, call another
    //  function to perform the recursion at each Feature level.

    if(atrRoot == ATTRIB_UNINITIALIZED)
        return TRUE ;  // go to next keyword.
    if(atrRoot & ATTRIB_HEAP_VALUE)
    {
        dwValue = *(PDWORD)(pubHeap + (atrRoot & ~ATTRIB_HEAP_VALUE) );

        if(bList)
        {
            dwListIndex = dwValue ;
            //  now need to traverse the listnodes.
            bStatus = bWalkTheList(
                            pubnRaw,  dwListIndex,
                            arIDarray,  dwArraySize, pdwNeeded ) ;
        }
        else    // ID Value is in the heap.
        {
            bStatus = bAddIDtoArray(dwValue,  //   ID value to add to array.
                arIDarray, dwArraySize,  pdwNeeded) ;
        }
        return(bStatus);  //  no more tree traveral to be done.
    }
    //  else    atrRoot specifies a node index
    dwNodeIndex = atrRoot ;

    //  first node only might be the global default initializer:
    if(patt[dwNodeIndex].dwFeature == DEFAULT_INIT )
    {
        // we have a global default initializer!
        //  it may be assumed dwOffset contains heap offset.
        if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP )
            return(FALSE);  // assumption violated.  BUD is corrupted.

        dwValue = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

        if(bList)
        {
            dwListIndex = dwValue ;
            //  now need to traverse the listnodes.
            bStatus = bWalkTheList(
                            pubnRaw,  dwListIndex,
                            arIDarray,  dwArraySize, pdwNeeded ) ;
        }
        else    // ID Value is in the heap.
        {
            bStatus = bAddIDtoArray(dwValue,  //   ID value to add to array.
                arIDarray, dwArraySize,  pdwNeeded) ;
        }

        dwNodeIndex = patt[dwNodeIndex].dwNext ;  // to the next node.
    }

    if(bStatus)
        bStatus = BRecurseDownTheTree(
                        pubnRaw,  dwNodeIndex, bList,
                        arIDarray,  dwArraySize, pdwNeeded ) ;

    //  have we overflowed the caller supplied array?
    //  who cares, just return.  It is the callers responsibility
    //  to see how many IDs were found and how much was
    //  allocated.
    return(bStatus);
}


BOOL    BRecurseDownTheTree(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  DWORD    dwNodeIndex,    //   first node in chain of attribute tree to navigate.
IN  BOOL    bList,  // is the value stored as a list?
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
                                            //  or values found.  Initial value
                                            //  may be non-zero since this
                                            //  accumulates starting from the
                                            //  first call.  Also serves to track where
                                            //  in arIDarray the function should
                                            //  be storing the ID values.
)
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.

    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubHeap ;  // ptr to start of heap.
    BOOL    bStatus = TRUE ;
    DWORD   dwValue;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  obtain pointers to structures:

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    patt = (PATTRIB_TREE)(pubRaw + pearTableContents[MTI_ATTRIBTREE].
                            loOffset) ;

    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;



    //  traverse the tree with wild abandon!  No more
    //  special cases to worry about!


    for(  ;  bStatus  &&   dwNodeIndex != END_OF_LIST ;
            dwNodeIndex = patt[dwNodeIndex].dwNext  )
    {
        //  does this node contain a sublevel?
        if(patt[dwNodeIndex].eOffsetMeans == NEXT_FEATURE)
        {
            DWORD   dwNewNodeIndex;

            // Down to the next level we go.
            dwNewNodeIndex = patt[dwNodeIndex ].dwOffset ;

            bStatus = BRecurseDownTheTree(
                                pubnRaw,  dwNewNodeIndex, bList,
                                arIDarray,  dwArraySize, pdwNeeded ) ;
        }
        else if(patt[dwNodeIndex].eOffsetMeans == VALUE_AT_HEAP)
        {
            dwValue = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

            if(bList)
            {
                DWORD   dwListIndex = dwValue;

                //  now need to traverse the listnodes.
                bStatus = bWalkTheList(
                                pubnRaw,  dwListIndex,
                                arIDarray,  dwArraySize, pdwNeeded ) ;
            }
            else    // ID Value is in the heap.
            {
                bStatus = bAddIDtoArray(dwValue,  //   ID value to add to array.
                    arIDarray, dwArraySize,  pdwNeeded) ;
            }
        }
        else
            bStatus = FALSE ;  //  Tree corruption.
    }

    return(bStatus);
}



BOOL    bWalkTheList(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  DWORD    dwListIndex,    //   first node in LIST to navigate.
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
                                            //  or values found.  Initial value
                                            //  may be non-zero since this
                                            //  accumulates starting from the
                                            //  first call.  Also serves to track where
                                            //  in arIDarray the function should
                                            //  be storing the ID values.
)
{
    PLISTNODE    plstRoot ;  // start of LIST array

    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;
    BOOL    bStatus = TRUE ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  obtain pointers to structures:

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    plstRoot = (PLISTNODE)(pubRaw + pearTableContents[MTI_LISTNODES].
                            loOffset) ;


    for(  ;  bStatus  &&   dwListIndex != END_OF_LIST ;
            dwListIndex = plstRoot[dwListIndex].dwNextItem  )
    {
        bStatus = bAddIDtoArray(
             plstRoot[dwListIndex].dwData,    //   ID value to add to array.
            arIDarray, dwArraySize,  pdwNeeded) ;
    }
    return(bStatus);
}



BOOL    bAddIDtoArray(
IN  DWORD    dwID,    //   ID value to add to array.
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
                                            //  or values found.  Initial value
                                            //  may be non-zero since this
                                            //  accumulates starting from the
                                            //  first call.  Also serves to track where
                                            //  in arIDarray the function should
                                            //  be storing the ID values.
)
{
        if(arIDarray  &&  *pdwNeeded < dwArraySize)
        {
            arIDarray[*pdwNeeded] =  dwID ;
        }

        (*pdwNeeded)++ ;
        return(TRUE);
}


/*  simplified rules for traversing attribute tree:
    features:  only time you need to check features is
    when you are looking at the first node.  Because this may be
    the Global default Initializer.

    Otherwise dwNext will always take you along to the next option
    until you hit END_OF_LIST.

    Now OffsetMeans = heapoffset  means you extract the value
        at the heap or interpret the heapoffset as the array index
        of a listnode.
    if Offsetmeans = Next_Fea, interpret heapoffset as treenode
        index and begin searching in this new branch.
        You must perform recursion.

    so this function must pass in a writable counter
    that track which entry in the user supplied array is
    'current'  (ready to be written into).   This serves both
    to keep track of where to write the ID values and how large
    an array the user should supply.  This same counter
    must be passed into the function that walks the listnodes.      */

#endif  PARSERDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\custsize.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    custsize.c

Abstract:

    Parser functions for handling custom page size feature

Environment:

    Windows NT PostScript driver

Revision History:

    03/20/97 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"


BOOL
BFixupCustomSizeDataFeedDirection(
    PUIINFO          pUIInfo,
    PPPDDATA         pPpdData,
    PCUSTOMSIZEDATA  pCSData
    )

/*++

Routine Description:

    Validate the requested paper feed direction parameter
    Fix up any inconsistency if necessary

Arguments:

    pPpdData - Points to PPDDATA structure
    pCSData - Specifies custom page size parameters

Return Value:

    TRUE if we can find a feeding direction to fit the custom page size.
    FALSE otherwise.

Note:

    See Figure 3 on page 109 of PPD 4.3 spec for more details.

--*/

#define ORIENTATION_AVAILABLE(iOrient) (dwFlags & (1 << (iOrient)))
#define FIXUP_FEEDDIRECTION(iMainOrient, iAltOrient, wAltFeedDirection) \
        { \
            if (! ORIENTATION_AVAILABLE(iMainOrient)) \
            { \
                pCSData->wFeedDirection = \
                    ORIENTATION_AVAILABLE(iAltOrient) ? \
                        (wAltFeedDirection) : \
                        MAX_FEEDDIRECTION; \
            } \
        }

{
    static const DWORD  adwMasks[4] = { 0x1, 0x3, 0x7, 0xf };
    DWORD   dwFlags;
    BOOL    bXGreaterThanY;
    BOOL    bShortEdgeFirst;
    LONG    lVal;
    WORD    wFeedDirectionSave;

    //
    // Figure out which custom page size orientations are supported
    // dwFlags is DWORD value whose lower-order 4 bits are interpreted as flags:
    //     If orientation N is supported, then bit 1 << N will be set
    //

    dwFlags = 0xf;

    if ((lVal = MINCUSTOMPARAM_ORIENTATION(pPpdData)) > 3)
        dwFlags = 0;
    else if (lVal > 0)
        dwFlags &= ~adwMasks[lVal - 1];

    if ((lVal = MAXCUSTOMPARAM_ORIENTATION(pPpdData)) < 3)
        dwFlags &= adwMasks[lVal];

    wFeedDirectionSave = pCSData->wFeedDirection;
    bXGreaterThanY = (pCSData->dwX > pCSData->dwY);

    //
    // First try to fit within the current feeding direction.
    //

    switch (pCSData->wFeedDirection)
    {
    case SHORTEDGEFIRST:

        if (bXGreaterThanY)
        {
            // orientation 0 (or 2)
            FIXUP_FEEDDIRECTION(0, 2, SHORTEDGEFIRST_FLIPPED);
        }
        else
        {
            // orientation 1 (or 3)
            FIXUP_FEEDDIRECTION(1, 3, SHORTEDGEFIRST_FLIPPED);
        }
        break;

    case SHORTEDGEFIRST_FLIPPED:

        if (bXGreaterThanY)
        {
            // orientation 2 (or 0)
            FIXUP_FEEDDIRECTION(2, 0, SHORTEDGEFIRST);
        }
        else
        {
            // orientation 3 (or 1)
            FIXUP_FEEDDIRECTION(3, 1, SHORTEDGEFIRST);
        }
        break;

    case LONGEDGEFIRST:

        if (bXGreaterThanY)
        {
            // orientation 1 (or 3)
            FIXUP_FEEDDIRECTION(1, 3, LONGEDGEFIRST_FLIPPED);
        }
        else
        {
            // orientation 0 (or 2)
            FIXUP_FEEDDIRECTION(0, 2, LONGEDGEFIRST_FLIPPED);
        }
        break;

    case LONGEDGEFIRST_FLIPPED:

        if (bXGreaterThanY)
        {
            // orientation 3 (or 1)
            FIXUP_FEEDDIRECTION(3, 1, LONGEDGEFIRST);
        }
        else
        {
            // orientation 2 (or 0)
            FIXUP_FEEDDIRECTION(2, 0, LONGEDGEFIRST);
        }
        break;
    }

    //
    // If the paper feed direction is not valid, we'll automatically
    // pick one here (default to long-edge-first if possible). This
    // should always change Long to Short, or Short to Long.
    //

    if (pCSData->wFeedDirection >= MAX_FEEDDIRECTION)
    {
        if (bXGreaterThanY)
        {
            if (ORIENTATION_AVAILABLE(1))
                pCSData->wFeedDirection = LONGEDGEFIRST;
            else if (ORIENTATION_AVAILABLE(3))
                pCSData->wFeedDirection = LONGEDGEFIRST_FLIPPED;
            else if (ORIENTATION_AVAILABLE(0))
                pCSData->wFeedDirection = SHORTEDGEFIRST;
            else // (ORIENTATION_AVAILABLE(2))
                pCSData->wFeedDirection = SHORTEDGEFIRST_FLIPPED;
        }
        else
        {
            if (ORIENTATION_AVAILABLE(0))
                pCSData->wFeedDirection = LONGEDGEFIRST;
            else if (ORIENTATION_AVAILABLE(2))
                pCSData->wFeedDirection = LONGEDGEFIRST_FLIPPED;
            else if (ORIENTATION_AVAILABLE(1))
                pCSData->wFeedDirection = SHORTEDGEFIRST;
            else // (ORIENTATION_AVAILABLE(3))
                pCSData->wFeedDirection = SHORTEDGEFIRST_FLIPPED;
        }
    }

    bShortEdgeFirst =
        (pCSData->wFeedDirection == SHORTEDGEFIRST ||
         pCSData->wFeedDirection == SHORTEDGEFIRST_FLIPPED);

    if ( (!bShortEdgeFirst && !LONGEDGEFIRST_SUPPORTED(pUIInfo, pPpdData)) ||
         (bShortEdgeFirst && !SHORTEDGEFIRST_SUPPORTED(pUIInfo, pPpdData)))
    {
        //
        // The other feeding direction we picked doesn't fit either, so we
        // have to stick with the original feeding direction.
        //

        pCSData->wFeedDirection = wFeedDirectionSave;

        //
        // Check the availability of orientations and flip the feed direction if necessary
        //

        if ((pCSData->wFeedDirection == LONGEDGEFIRST || pCSData->wFeedDirection == SHORTEDGEFIRST) &&
            !(ORIENTATION_AVAILABLE(0) || ORIENTATION_AVAILABLE(1)))
        {
            pCSData->wFeedDirection = (pCSData->wFeedDirection == LONGEDGEFIRST) ?
                LONGEDGEFIRST_FLIPPED : SHORTEDGEFIRST_FLIPPED;
        }
        else if ((pCSData->wFeedDirection == LONGEDGEFIRST_FLIPPED || pCSData->wFeedDirection == SHORTEDGEFIRST_FLIPPED) &&
            !(ORIENTATION_AVAILABLE(2) || ORIENTATION_AVAILABLE(3)))
        {
            pCSData->wFeedDirection = (pCSData->wFeedDirection == LONGEDGEFIRST_FLIPPED) ?
                LONGEDGEFIRST : SHORTEDGEFIRST;
        }

        return FALSE;
    }
    else
        return TRUE;
}



BOOL
BValidateCustomPageSizeData(
    IN PRAWBINARYDATA       pRawData,
    IN OUT PCUSTOMSIZEDATA  pCSData
    )

/*++

Routine Description:

    Validate the specified custom page size parameters, and
    Fix up any inconsistencies found.

Arguments:

    pRawData - Points to raw binary printer description data
    pCSData - Specifies the custom page size parameters to be validate

Return Value:

    TRUE if the custom page size parameters are valid, FALSE otherwise.
    If FALSE is returned, custom page size parameters have been
    fixed up to a consistent state.

--*/

{
    PUIINFO             pUIInfo;
    PPPDDATA            pPpdData;
    PPAGESIZE           pPageSize;
    CUSTOMSIZEDATA      csdata;
    PDWORD              pdwWidth, pdwHeight;
    DWORD               dwTemp;
    BOOL                bShortEdgeFirst, bXGreaterThanY;
    BOOL                bFit;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER((PINFOHEADER) pRawData);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pUIInfo != NULL && pPpdData != NULL);

    if ((pPageSize = PGetCustomPageSizeOption(pUIInfo)) == NULL)
    {
        RIP(("Custom page size not supported\n"));
        return TRUE;
    }

    csdata = *pCSData;

    //
    // Width and height offset parameters are straightforward to verify
    //

    if ((LONG) csdata.dwWidthOffset < MINCUSTOMPARAM_WIDTHOFFSET(pPpdData))
        csdata.dwWidthOffset = MINCUSTOMPARAM_WIDTHOFFSET(pPpdData);
    else if ((LONG) csdata.dwWidthOffset > MAXCUSTOMPARAM_WIDTHOFFSET(pPpdData))
        csdata.dwWidthOffset = MAXCUSTOMPARAM_WIDTHOFFSET(pPpdData);

    if ((LONG) csdata.dwHeightOffset < MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData))
        csdata.dwHeightOffset = MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData);
    else if ((LONG) csdata.dwHeightOffset > MAXCUSTOMPARAM_HEIGHTOFFSET(pPpdData))
        csdata.dwHeightOffset = MAXCUSTOMPARAM_HEIGHTOFFSET(pPpdData);

    //
    // Validate cut-sheet vs. roll-fed selection
    //

    if (csdata.wCutSheet && !(pPpdData->dwCustomSizeFlags & CUSTOMSIZE_CUTSHEET))
        csdata.wCutSheet = FALSE;
    else if (!csdata.wCutSheet && !(pPpdData->dwCustomSizeFlags & CUSTOMSIZE_ROLLFED))
        csdata.wCutSheet = TRUE;

    //
    // Check if the specified paper feed direction can be satisfied
    //

    bFit = BFixupCustomSizeDataFeedDirection(pUIInfo, pPpdData, &csdata);

    //
    // If we haven't been able to fit the custom paper size in
    // correct feeding direction and orientation, then we have
    // to swap width and height here, because they will be opposite
    // of what PPD spec 4.3 page 109 Figure 3 specifies.
    //

    if (!bFit)
    {
        dwTemp = csdata.dwX;
        csdata.dwX = csdata.dwY;
        csdata.dwY = dwTemp;
    }

    //
    // Verify width and height parameters
    //

    bShortEdgeFirst =
        (csdata.wFeedDirection == SHORTEDGEFIRST ||
         csdata.wFeedDirection == SHORTEDGEFIRST_FLIPPED);

    bXGreaterThanY = (csdata.dwX > csdata.dwY);

    if ((bShortEdgeFirst && bXGreaterThanY) ||
        (!bShortEdgeFirst && !bXGreaterThanY))
    {
        // In this case: x <=> height, y <=> width

        pdwHeight = &csdata.dwX;
        pdwWidth = &csdata.dwY;
    }
    else
    {
        // In this case: x <=> width, y <=> height

        pdwWidth = &csdata.dwX;
        pdwHeight = &csdata.dwY;
    }

    if ((LONG) (*pdwWidth + csdata.dwWidthOffset) > pPageSize->szPaperSize.cx)
    {
        *pdwWidth = pPageSize->szPaperSize.cx - csdata.dwWidthOffset;

        if ((LONG) *pdwWidth < MINCUSTOMPARAM_WIDTH(pPpdData))
        {
            *pdwWidth = MINCUSTOMPARAM_WIDTH(pPpdData);
            csdata.dwWidthOffset = pPageSize->szPaperSize.cx - *pdwWidth;
        }
    }
    else if ((LONG) *pdwWidth < MINCUSTOMPARAM_WIDTH(pPpdData))
    {
        *pdwWidth = MINCUSTOMPARAM_WIDTH(pPpdData);
    }

    if ((LONG) (*pdwHeight + csdata.dwHeightOffset) > pPageSize->szPaperSize.cy)
    {
        *pdwHeight = pPageSize->szPaperSize.cy - csdata.dwHeightOffset;

        if ((LONG) *pdwHeight < MINCUSTOMPARAM_HEIGHT(pPpdData))
        {
            *pdwHeight = MINCUSTOMPARAM_HEIGHT(pPpdData);
            csdata.dwHeightOffset = pPageSize->szPaperSize.cy - *pdwHeight;
        }
    }
    else if ((LONG) *pdwHeight < MINCUSTOMPARAM_HEIGHT(pPpdData))
    {
        *pdwHeight = MINCUSTOMPARAM_HEIGHT(pPpdData);
    }

    //
    // Check if anything has changed and
    // return appropriate result value
    //

    if (memcmp(pCSData, &csdata, sizeof(csdata)) == 0)
        return TRUE;

    *pCSData = csdata;
    return FALSE;
}



VOID
VFillDefaultCustomPageSizeData(
    IN PRAWBINARYDATA   pRawData,
    OUT PCUSTOMSIZEDATA pCSData,
    IN BOOL             bMetric
    )

/*++

Routine Description:

    Initialize the custom page size parameters to their default values

Arguments:

    pRawData - Points to raw printer description data
    pCSData - Buffer for storing default custom page size parameters
    bMetric - Whether we're on a metric system

Return Value:

    NONE

--*/

{
    PPPDDATA    pPpdData;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pPpdData != NULL);

    //
    // Default to Letter or A4 depending on whether
    // we're on metric system or not
    //

    if (bMetric)
    {
        pCSData->dwX = 210000;  // 210mm
        pCSData->dwY = 297000; // 297mm
    }
    else
    {
        pCSData->dwX = 215900;  // 8.5"
        pCSData->dwY = 279400; // 11"
    }

    //
    // Get default offsets and feed direction
    //

    pCSData->dwWidthOffset = MINCUSTOMPARAM_WIDTHOFFSET(pPpdData);
    pCSData->dwHeightOffset = MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData);

    pCSData->wFeedDirection =
        (pPpdData->dwCustomSizeFlags & CUSTOMSIZE_SHORTEDGEFEED) ?
            SHORTEDGEFIRST : LONGEDGEFIRST;

    //
    // Make sure the default custom page size parameters are consistent
    //

    (VOID) BValidateCustomPageSizeData(pRawData, pCSData);
}



VOID
VGetCustomSizeParamRange(
    IN PRAWBINARYDATA    pRawData,
    IN PCUSTOMSIZEDATA   pCSData,
    OUT PCUSTOMSIZERANGE pCSRange
    )

/*++

Routine Description:

    Return the valid ranges for custom page size width, height,
    and offset parameters based on their current values

Arguments:

    pRawData - Points to raw printer description data
    pCSData - Specifies the current custom page size parameter values
    pCSRange - Output buffer for returning custom page size parameter ranges
        It should point to an array of 4 CUSTOMSIZERANGE structures:
            0 (CUSTOMPARAM_WIDTH)
            1 (CUSTOMPARAM_HEIGHT)
            2 (CUSTOMPARAM_WIDTHOFFSET)
            3 (CUSTOMPARAM_HEIGHTOFFSET)

Return Value:

    NONE

--*/

{
    PUIINFO             pUIInfo;
    PPPDDATA            pPpdData;
    BOOL                bShortEdgeFirst, bXGreaterThanY;
    PPAGESIZE           pPageSize;
    CUSTOMSIZEDATA      csdata;
    PCUSTOMSIZERANGE    pWidthRange, pHeightRange, pTempRange;
    BOOL                bFit;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER((PINFOHEADER) pRawData);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pUIInfo != NULL && pPpdData != NULL);

    pPageSize = PGetCustomPageSizeOption(pUIInfo);

    ASSERT(pPageSize != NULL);

    //
    // The range for width and height offsets are predictable
    //

    pCSRange[CUSTOMPARAM_WIDTHOFFSET].dwMin = MINCUSTOMPARAM_WIDTHOFFSET(pPpdData);
    pCSRange[CUSTOMPARAM_WIDTHOFFSET].dwMax = MAXCUSTOMPARAM_WIDTHOFFSET(pPpdData);
    pCSRange[CUSTOMPARAM_HEIGHTOFFSET].dwMin = MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData);
    pCSRange[CUSTOMPARAM_HEIGHTOFFSET].dwMax = MAXCUSTOMPARAM_HEIGHTOFFSET(pPpdData);

    //
    // The range for width and height are affected by the selected paper feed direction
    //

    csdata = *pCSData;
    bFit = BFixupCustomSizeDataFeedDirection(pUIInfo, pPpdData, &csdata);

    bShortEdgeFirst =
        (csdata.wFeedDirection == SHORTEDGEFIRST ||
         csdata.wFeedDirection == SHORTEDGEFIRST_FLIPPED);

    bXGreaterThanY = (csdata.dwX > csdata.dwY);

    if ((bShortEdgeFirst && bXGreaterThanY) ||
        (!bShortEdgeFirst && !bXGreaterThanY))
    {
        //
        // Here user's logical x/y and custom page
        // size width/height are swapped
        //

        pWidthRange = pCSRange + CUSTOMPARAM_HEIGHT;
        pHeightRange = pCSRange + CUSTOMPARAM_WIDTH;
    }
    else
    {
        //
        // Here user's logical x/y correspond to
        // custom page size width/height
        //

        pWidthRange = pCSRange + CUSTOMPARAM_WIDTH;
        pHeightRange = pCSRange + CUSTOMPARAM_HEIGHT;
    }

    //
    // If we haven't been able to fit the custom paper size in
    // correct feeding direction and orientation, then we have
    // to swap width and height here, because they will be opposite
    // of what PPD spec 4.3 page 109 Figure 3 specifies.
    //

    if (!bFit)
    {
        pTempRange = pWidthRange;
        pWidthRange = pHeightRange;
        pHeightRange = pTempRange;
    }

    pWidthRange->dwMin = MINCUSTOMPARAM_WIDTH(pPpdData);
    pWidthRange->dwMax = MAXCUSTOMPARAM_WIDTH(pPpdData);
    pHeightRange->dwMin = MINCUSTOMPARAM_HEIGHT(pPpdData);
    pHeightRange->dwMax = MAXCUSTOMPARAM_HEIGHT(pPpdData);

    if (pWidthRange->dwMax > pPageSize->szPaperSize.cx - csdata.dwWidthOffset)
        pWidthRange->dwMax = pPageSize->szPaperSize.cx - csdata.dwWidthOffset;

    if (pHeightRange->dwMax > pPageSize->szPaperSize.cy - csdata.dwHeightOffset)
        pHeightRange->dwMax = pPageSize->szPaperSize.cy - csdata.dwHeightOffset;
}



BOOL
BFormSupportedThruCustomSize(
    PRAWBINARYDATA  pRawData,
    DWORD           dwX,
    DWORD           dwY,
    PWORD           pwFeedDirection
    )

/*++

Routine Description:

    Determine whether a form can be supported through custom page size

Arguments:

    pRawData - Points to raw printer description data
    dwX, dwY - Form width and height (in microns)
    pwFeedDirection - if not NULL, will be set to the selected feed direction

Return Value:

    TRUE if the form can be supported through custom page size
    FALSE if not. In that case, pwFeedDirection will be LONGEDGEFIRST.

--*/
{
    PPPDDATA        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);
    static WORD     awPrefFeedDir[] = {
                                        LONGEDGEFIRST,
                                        SHORTEDGEFIRST
                                      };
    CUSTOMSIZEDATA  csdata;
    DWORD           i;

    for (i = 0; i < (sizeof(awPrefFeedDir)/sizeof(WORD)); i++)
    {
        csdata.dwX = dwX;
        csdata.dwY = dwY;
        csdata.dwWidthOffset =
        csdata.dwHeightOffset = 0;
        csdata.wCutSheet = TRUE;
        csdata.wFeedDirection = awPrefFeedDir[i];

        (VOID) BValidateCustomPageSizeData(pRawData, &csdata);

        if (dwX == csdata.dwX && dwY == csdata.dwY && csdata.wFeedDirection != MAX_FEEDDIRECTION)
        {
            if (pwFeedDirection != NULL)
                *pwFeedDirection = csdata.wFeedDirection; // might be flipped

            return TRUE;
        }
    }

    if (pwFeedDirection != NULL)
        *pwFeedDirection = LONGEDGEFIRST; // just set a safe default, the return value should be checked !

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\value1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  value1.c - functions to parse value field
and to convert the information into the proper
binary format.  */


#include    "gpdparse.h"


// ----  functions defined in value1.c ---- //

BOOL   BaddValueToHeap(
IN  OUT  PDWORD  ploHeap,  // dest offset to value in binary form
IN   PTKMAP  ptkmap,   // pointer to tokenmap
IN   BOOL    bOverWrite,  // assume ploHeap contains a valid offset
        //  to a reserved region of the heap of the proper size
        //  and write binary value into this location instead of
        //  growing heap.  Note:  defer overwriting lpHeap
        //  until we are certain of success.
IN OUT PGLOBL pglobl
) ;

BOOL   BparseAndWrite(
IN     PBYTE   pubDest,       // write binary data or link to this address.
IN     PTKMAP  ptkmap,        // pointer to tokenmap
IN     BOOL    bAddToHeap,    // if true, write to curHeap not pubDest
OUT    PDWORD  pdwHeapOffset, // if (bAddToHeap)  heap offset where
IN OUT PGLOBL  pglobl
) ;

BOOL    BparseInteger(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue,  // dummy
IN  PGLOBL        pglobl
)  ;

BOOL    BparseList(
IN      PABSARRAYREF  paarValue,
IN      PDWORD        pdwDest,   //  location where index to start of list
                                 //  is saved
IN      BOOL          (*fnBparseValue)(PABSARRAYREF, PDWORD, VALUE, PGLOBL),   // callback
IN      VALUE         eAllowedValue, // dummy
IN  OUT PGLOBL        pglobl
) ;

BOOL    BeatLeadingWhiteSpaces(
IN  OUT  PABSARRAYREF   paarSrc
) ;

BOOL    BeatDelimiter(
IN  OUT  PABSARRAYREF   paarSrc,
IN  PBYTE  pubDelStr        //  points to a string which paarSrc must match
) ;

BOOL    BdelimitToken(
IN  OUT  PABSARRAYREF   paarSrc,    //  source string
IN  PBYTE   pubDelimiters,          //  array of valid delimiters
OUT     PABSARRAYREF   paarToken,   //  token defined by delimiter
OUT     PDWORD      pdwDel      //  which delimiter was first encountered?
) ;

BOOL    BeatSurroundingWhiteSpaces(
IN  PABSARRAYREF   paarSrc
) ;

BOOL    BparseSymbol(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,        //  write dword value here.
IN  VALUE         eAllowedValue,  // which class of symbol is this?
IN  PGLOBL        pglobl
)  ;

BOOL    BparseQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,       //  write dword value here.
IN  VALUE          eAllowedValue, // which class of symbol is this?
IN  PGLOBL         pglobl
)  ;

BOOL    BparseQualifiedNameEx
(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // which class of symbol is this?
IN  PGLOBL        pglobl
)  ;


BOOL    BparsePartiallyQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
) ;

BOOL    BparseOptionSymbol(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // which class of symbol is this?
IN  PGLOBL        pglobl
) ;

BOOL    BparseConstant(
IN  OUT  PABSARRAYREF  paarValue,
OUT      PDWORD        pdwDest,       //  write dword value here.
IN       VALUE         eAllowedValue,  // which class of constant is this?
IN       PGLOBL        pglobl
) ;

BOOL  BinitClassIndexTable(
IN  OUT PGLOBL      pglobl) ;

BOOL    BparseRect(
IN  PABSARRAYREF   paarValue,
IN  PRECT   prcDest,
    PGLOBL  pglobl
) ;

BOOL    BparsePoint(
IN  PABSARRAYREF   paarValue,
IN  PPOINT   pptDest,
    PGLOBL   pglobl
) ;

BOOL    BparseString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseAndTerminateString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  VALUE          eAllowedValue,
IN  OUT PGLOBL     pglobl
) ;

BOOL     BwriteUnicodeToHeap(
IN   PARRAYREF      parSrcString,
OUT  PARRAYREF      parUnicodeString,
IN  INT             iCodepage,
IN  OUT PGLOBL      pglobl
) ;

BOOL    BparseStrSegment(
IN  PABSARRAYREF   paarStrSeg,       // source str segment
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseStrLiteral(
IN  PABSARRAYREF   paarStrSeg,       // points to literal substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseHexStr(
IN  PABSARRAYREF   paarStrSeg,       // points to hex substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN OUT PGLOBL      pglobl
) ;

BOOL    BparseOrderDep(
IN  PABSARRAYREF   paarValue,
IN  PORDERDEPENDENCY   pordDest,
    PGLOBL          pglobl
) ;

PDWORD   pdwEndOfList(
PDWORD   pdwNodeIndex,
PGLOBL   pglobl) ;

#ifdef  GMACROS

PBYTE    ExtendChain(
         PBYTE   pubDest,
 IN      BOOL    bOverWrite,
 IN  OUT PGLOBL  pglobl) ;
#endif

// ---------------------------------------------------- //



BOOL   BaddValueToHeap(
IN  OUT  PDWORD  ploHeap,  // dest offset to value in binary form
IN   PTKMAP  ptkmap,   // pointer to tokenmap
IN   BOOL    bOverWrite,  // assume ploHeap contains a valid offset
        //  to a reserved region of the heap of the proper size
        //  and write binary value into this location instead of
        //  growing heap.  Note:  defer overwriting lpHeap
        //  until we are certain of success.
IN OUT PGLOBL pglobl
)
{
    DWORD       dwKeywordID ;
    PBYTE  pubDest ;


    dwKeywordID = ptkmap->dwKeywordID ;
    // BUG_BUG !!!!! what if dwKeywordID  is a special value?
    if(dwKeywordID >= ID_SPECIAL)
        return  FALSE ;

    //  note:  different attributes are stored in different places
    //  using different branching techniques.  See the
    //  Bstore_XXX_Attrib()  functions for the different
    //  setups.  This function works in concert with those
    //  functions.

    switch(mMainKeywordTable[dwKeywordID].flAgs & KWF_DEDICATED_FIELD)
    {   //  extract just the flags describing the attribute storage type.
        case KWF_TTFONTSUBS:
        {
            //  since ploHeap always points to the index
            //  of the appropriate FontSub structure,
            //  we ignore bOverWrite

            DWORD   dwOffset ;
            PTTFONTSUBTABLE   pttft ;

            dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

            pttft = (PTTFONTSUBTABLE)
                    gMasterTable[MTI_TTFONTSUBTABLE].pubStruct +  *ploHeap;

            //  write binary data into (PBYTE)pttft + dwOffset ;
            pubDest = (PBYTE)pttft + dwOffset ;

            if(bOverWrite  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_ADDITIVE  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST)
            {
                pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                                //  to the actual END_OF_LIST  value so it can be overwritten to
                                //   extend the list.
            }

#ifdef  GMACROS
            //   call this from every place that supports KWF_ADDITIVE.

            else if( mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
            {
                if(!(pubDest = ExtendChain(pubDest, bOverWrite, pglobl)))
                    return(FALSE) ;
            }
#endif


            if(!BparseAndWrite(pubDest,  ptkmap, FALSE, NULL, pglobl ) )
            {
                return(FALSE) ;
            }
            break;
        }
        case KWF_FONTCART:
        {
            //  since ploHeap always points to the index
            //  of the appropriate FontCart structure,
            //  we ignore bOverWrite

            DWORD   dwOffset ;
            PFONTCART   pfc ;

            dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

            pfc = (PFONTCART)
                    gMasterTable[MTI_FONTCART].pubStruct +  *ploHeap;

            //  write binary data into (PBYTE)pfc + dwOffset ;
            pubDest = (PBYTE)pfc + dwOffset ;

            if(bOverWrite  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_ADDITIVE  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST)
            {
                pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                                //  to the actual END_OF_LIST  value so it can be overwritten to
                                //   extend the list.
            }
#ifdef  GMACROS
            else if( mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
            {
                if(!(pubDest = ExtendChain(pubDest, bOverWrite, pglobl )))
                    return(FALSE) ;
            }
#endif

            if(!BparseAndWrite(pubDest,  ptkmap, FALSE, NULL , pglobl) )
            {
                return(FALSE) ;
            }
            break;
        }
        case KWF_COMMAND:
        {
            //  ploHeap actually points to the variable
            //  that will receive (or already contains) the CommandArray
            //  index .  This is most likely stored in the leaf node
            //  of the attribute tree or maybe the CommandTable
            //  itself if the command is single-valued.

            PCOMMAND    pcmd ;
            DWORD   dwOffset ;

            if(!bOverWrite)  //  ploHeap  is uninitialized.
            {
                //  obtain first free command element
                //  and initialize ploHeap.
                if(! BallocElementFromMasterTable(MTI_COMMANDARRAY ,
                    ploHeap, pglobl) )
                {
                    return(FALSE) ;
                }
            }
            //  this path now shared by both cases of (bOverWrite)

            pcmd = (PCOMMAND)
                gMasterTable[MTI_COMMANDARRAY].pubStruct +  *ploHeap;

            dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

            //  write binary data into CmdArray[*ploHeap] +  dwOffset;
            //  since we write into reserved memory

            pubDest = (PBYTE)pcmd + dwOffset ;

            if(bOverWrite  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_ADDITIVE  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST)
            {
                pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                                //  to the actual END_OF_LIST  value so it can be overwritten to
                                //   extend the list.
            }
#ifdef  GMACROS
            else if( mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
            {
                if(!(pubDest = ExtendChain(pubDest, bOverWrite, pglobl )))
                    return(FALSE) ;
            }
#endif

            if(!BparseAndWrite(pubDest,  ptkmap, FALSE, NULL, pglobl ) )
            {
                return(FALSE) ;
            }
            break ;
        }
        default:   //  no dedicated structures, save data on heap.
        {
            if(bOverWrite)  //  ploHeap really does contain
            {               //  an offset to the heap.
                pubDest = mpubOffRef + *ploHeap ;

                if(mMainKeywordTable[dwKeywordID].flAgs & KWF_ADDITIVE  &&
                    mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST)
                {
                    pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                                    //  to the actual END_OF_LIST  value so it can be overwritten to
                                    //   extend the list.
                }
#ifdef  GMACROS
                else if( mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
                {
                    if(!(pubDest = ExtendChain(pubDest, bOverWrite, pglobl )))
                        return(FALSE) ;
                }
#endif

                if(!BparseAndWrite(pubDest,  ptkmap, FALSE, NULL, pglobl ) )
                {
                    return(FALSE) ;
                }
            }
            else
            {
                //  write at cur heap ptr, tell me where
                //  this is,  and advance CurHeap.
                if(!BparseAndWrite(NULL,  ptkmap,
                                TRUE,  ploHeap, pglobl) )
                {
                    return(FALSE) ;
                }
            }
            break ;
        }
    }
    return(TRUE) ;
}


BOOL   BparseAndWrite(
IN   PBYTE    pubDest,        // write binary data or link to this address.
IN   PTKMAP   ptkmap,         // pointer to tokenmap
IN   BOOL     bAddToHeap,     // if true, write to curHeap not pubDest
OUT  PDWORD   pdwHeapOffset,  // if (bAddToHeap)  heap offset where
                              // binary data or link to data was written to.
IN OUT PGLOBL pglobl
)
/*  parses value according to its expected type and writes
    the appropriate data into the appropriate structures
    (if the value is a composite object)  and places an
    appropriate link in pubDest or simply writes the binary
    data directly to pubDest (if simple object).
    If (bAddToHeap == TRUE) ignore pubDest and write
    data or link to curHeap location and return that offset
    in pdwHeapOffset.

    Warning!  this function allocates a tmp buffer (pubBuf)
    which is freed at the very end.
    So do not add extra returns() in this function
    without freeing this buffer.
*/
{
    DWORD       dwKeywordID ;
    VALUE       eAllowedValue ;  //  how should token be parsed?
    ABSARRAYREF   aarValue ;     //  location of value token
    BOOL        bList ;
    BOOL        bStatus = FALSE ;
    PBYTE        pubBuf = NULL ;
                //  temp Dest if needed.
    PBYTE       pubTmp ;  // points to dest for parsing function.



    dwKeywordID = ptkmap->dwKeywordID ;
    eAllowedValue = mMainKeywordTable[dwKeywordID].eAllowedValue ;
    aarValue = ptkmap->aarValue ;
    bList = (mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST) ?
            (TRUE) : (FALSE);

    if(bAddToHeap)     //  PARANOID checks.
    {
        if(!pdwHeapOffset)
        {
            vIdentifySource(ptkmap, pglobl);
            ERR(("internal consistency error.  heap ptr not supplied.\n"));
            return(FALSE) ;
        }
    }
    else
    {
        if(!pubDest)
            return(FALSE) ;
    }

    if(bAddToHeap)
    {
        DWORD  dwSize ;  // for debugging purposes.

        dwSize = gValueToSize[VALUE_LARGEST] ;

        if(!(pubBuf = MemAlloc(dwSize) ))
        {
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            return(FALSE) ;
        }
    }
#ifdef  GMACROS
     if(bAddToHeap  && (mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN))
     {
         if(!(pubTmp = ExtendChain(pubBuf, /* bOverWrite = */ FALSE, pglobl )))
             return(FALSE) ;
     }
     else
#endif
          pubTmp = (bAddToHeap) ? (pubBuf) : (pubDest) ;

    //  all parsing functions write links to a specified
    //  memory location.  If the link is to be saved to
    //  the heap, the link is first created in a temp
    //  buffer pubBuf[] which is subseqently copied to
    //  the heap outside of the function.


    switch(eAllowedValue)
    {
        case  VALUE_STRING_NO_CONVERT:
        case  VALUE_STRING_DEF_CONVERT:
        case  VALUE_STRING_CP_CONVERT:
        {
            bStatus = BparseAndTerminateString(&aarValue, (PARRAYREF)pubTmp,
                                eAllowedValue, pglobl) ;
            break ;
        }
        case  VALUE_COMMAND_INVOC:
        {
            bStatus = BparseCommandString(&aarValue, (PARRAYREF)pubTmp, pglobl) ;
            break ;
        }
        case  VALUE_PARAMETER:
        {
            ((PARRAYREF)pubTmp)->dwCount = 0 ;

            bStatus = BprocessParam(&aarValue, (PARRAYREF)pubTmp, pglobl) ;
            break ;
        }
        case  VALUE_POINT:
        {
            bStatus = BparsePoint(&aarValue, (PPOINT)pubTmp, pglobl) ;
            break ;
        }
        case  VALUE_RECT:
        {
            bStatus = BparseRect(&aarValue, (PRECT)pubTmp, pglobl) ;
            break ;
        }
        case  VALUE_ORDERDEPENDENCY:
        {
            bStatus = BparseOrderDep(&aarValue, (PORDERDEPENDENCY)pubTmp, pglobl) ;
            break ;
        }
//        case  VALUE_BOOLEAN:  this is one class of CONSTANT.
        case  VALUE_SYMBOL_DEF:   //  what is this??
        {
            break ;
        }
        case  VALUE_INTEGER:
        {
            if(bList)
                bStatus = BparseList(&aarValue, (PDWORD)pubTmp,
                    BparseInteger, eAllowedValue, pglobl) ;
            else
                bStatus = BparseInteger(&aarValue, (PDWORD)pubTmp,
                    eAllowedValue, pglobl) ;

            break ;
        }

        case  VALUE_CONSTRAINT:
        {
            bStatus = BparseConstraint(&aarValue, (PDWORD)pubTmp,
                    bAddToHeap, pglobl) ;  //  create list vs append to existing
            break ;
        }
        case  VALUE_QUALIFIED_NAME:
        {
            if(bList)
                bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseQualifiedName, eAllowedValue, pglobl) ;
            else
                bStatus = BparseQualifiedName(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            break ;
        }
        case  VALUE_QUALIFIED_NAME_EX:
        {
            if(bList)
                bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseQualifiedNameEx, eAllowedValue, pglobl) ;
            else
                bStatus = BparseQualifiedNameEx(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            break ;
        }
        case  VALUE_PARTIALLY_QUALIFIED_NAME:
        {
            if(bList)
                bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparsePartiallyQualifiedName, eAllowedValue, pglobl) ;
            else
                bStatus = BparsePartiallyQualifiedName(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            break ;
        }
        case  NO_VALUE :  // how can an attribute not have a value?
        {
            bStatus = TRUE ;
            break ;
        }
        default:
        {
            if(  eAllowedValue >= VALUE_CONSTANT_FIRST  &&
                eAllowedValue <= VALUE_CONSTANT_LAST )
            {
                if(bList)
                    bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseConstant, eAllowedValue, pglobl) ;
                else
                    bStatus = BparseConstant(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            }
            else  if(  eAllowedValue == VALUE_SYMBOL_OPTIONS )  //  check
                    //  this case before the other symbols.
            {
                if(bList)
                    bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseOptionSymbol, eAllowedValue, pglobl) ;
                else
                    bStatus = BparseOptionSymbol(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            }
            else  if(  eAllowedValue >= VALUE_SYMBOL_FIRST  &&
                eAllowedValue <= VALUE_SYMBOL_LAST )
            {
                if(bList)
                    bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseSymbol, eAllowedValue, pglobl) ;
                else
                    bStatus = BparseSymbol(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            }
            else
            {
                ERR(("internal consistency error - unrecognized VALUE type!\n"));
                //  don't know how to parse unrecognized value type!
            }
            break ;
        }
    }
    if(!bStatus)
        vIdentifySource(ptkmap, pglobl);

    if(bStatus  && (eAllowedValue != NO_VALUE) )
    {
        if(bAddToHeap)
        {
#ifdef  GMACROS
            if(mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
            {
                if(!BwriteToHeap(pdwHeapOffset, pubBuf,
                    gValueToSize[VALUE_LIST], 4, pglobl) )   //  chains are LISTS of VALUES.
                {
                    bStatus = FALSE ;  // heap overflow start over.
                }
            }
            else
#endif

                if(!BwriteToHeap(pdwHeapOffset, pubTmp,
                gValueToSize[(bList) ? (VALUE_LIST) : (eAllowedValue)], 4, pglobl) )
            {
                bStatus = FALSE ;  // heap overflow start over.
            }
        }
    }
    if(pubBuf)
        MemFree(pubBuf) ;
    return(bStatus) ;
}




BOOL    BparseInteger(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // dummy
IN  PGLOBL        pglobl
)
/*  the GPD spec defines an integer as a sequence
    of numbers preceeded by an optional + or -  OR
    simply the symbol '*' which means 'don't care'.
    NEW:  also permit a leading 0x to indicate a number in
    hexadecimal format.  ie  0x01fE .  No + or - allowed
    in hex format.
*/
{
#define    pubM  (paarValue->pub)
#define    dwM   (paarValue->dw)

    BOOL  bNeg = FALSE ;
    DWORD   dwNumber   ;
    BOOL        bStatus = FALSE ;
    ABSARRAYREF   aarValue ;

    if(eAllowedValue != VALUE_INTEGER)
        return(FALSE); // paranoid check just to use variable
                        //  and thereby avoid compiler warning.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;

    aarValue.pub = pubM ;  // used only to emit error message.
    aarValue.dw  = dwM ;

    if(!dwM)
    {
        ERR(("BparseInteger: no integer found - empty list?\n"));
        //  ERR(("\t%0.40s\n", aarValue.pub )) ;
        //  danger of over shooting EOF
        return(FALSE);
    }
    if(*pubM == '*')
    {
        dwNumber = WILDCARD_VALUE ;
        pubM++ ;
        dwM-- ;
        bStatus = TRUE ;
    }
    else if(*pubM == '0')  //  leading zero indicates hexadecimal format
    {
        pubM++ ;
        dwM-- ;

        if(dwM  &&  (*pubM == 'x'  ||  *pubM == 'X'))
        {
            pubM++ ;
            dwM-- ;
        }
        else
        {
            dwNumber = 0 ;
            bStatus = TRUE ;
            goto  EndNumber ;
        }
        if(!dwM)
        {
            ERR(("BparseInteger: no digits found in Hex value.\n"));
            return(FALSE);
        }
        for(dwNumber = 0 ; dwM  ;  pubM++, dwM-- )
        {
            if(*pubM >= '0'  &&  *pubM <= '9')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - '0') ;
            }
            else if(*pubM >= 'a'  &&  *pubM <= 'f')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - 'a' + 0x0a) ;
            }
            else if(*pubM >= 'A'  &&  *pubM <= 'F')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - 'A' + 0x0a) ;
            }
            else
                break;

            bStatus = TRUE ;
        }
    }
    else
    {
        if(*pubM == '-')
        {
            bNeg = TRUE ;
            pubM++ ;
            dwM-- ;
        }
        else if(*pubM == '+')
        {
            pubM++ ;
            dwM-- ;
        }
        //  is there anything else after the sign?
        (VOID) BeatLeadingWhiteSpaces(paarValue) ;

        if(!dwM)
        {
            ERR(("BparseInteger: no digits found.\n"));
            return(FALSE);
        }
        for(dwNumber = 0 ; dwM  &&  *pubM >= '0'  &&  *pubM <= '9' ;  )
        {
            dwNumber *= 10 ;
            dwNumber += (*pubM - '0') ;
            pubM++ ;
            dwM-- ;
            bStatus = TRUE ;
        }
    }

EndNumber:

    if(! bStatus)
    {
        ERR(("error parsing integer value: %0.*s\n", aarValue.dw, aarValue.pub));
        return(FALSE);
    }

    //  is there anything else after the digit string?
    (VOID) BeatLeadingWhiteSpaces(paarValue) ;

    if(dwM)
    {
        ERR(("unexpected characters after digits in integer value: %0.*s\n", aarValue.dw, aarValue.pub));
        return(FALSE);
    }
    *pdwDest = (bNeg) ? ((unsigned)(-(signed)dwNumber)) : (dwNumber) ;
    return(TRUE);

#undef    pubM
#undef    dwM
}




BOOL    BparseList(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,       //  location where index to start of list
                                  //  is saved
IN  BOOL           (*fnBparseValue)(PABSARRAYREF, PDWORD, VALUE, PGLOBL),   // callback
IN  VALUE          eAllowedValue,  // dummy
IN OUT PGLOBL      pglobl
)
/*  non-destructively parse this list using
    callback function to parse the actual values
    in between the LIST structure.
    LIST ( <value> , <value> , ... )

    Notes:
    1) all continuation line delimiters have been replaced by
        spaces at TokenMap creation time.  No need to worry
        about this here
    2) The List construct must begin with the reserved token
        'LIST' which must be followed by the token '('.
    3) The list of values is enclosed by parenthesis,
        adjacent values are delimited by comma.
    4) This function assumes <value> does not contain any
        reserved characters ',' comma or ')' close parenthesis
    5) whitespaces may appear between syntactic elements (tokens).
    6) Even if a LIST is not detected, we will still save
        the single value in a LIST construct.
    7) Must check string count to see if we have reached the
        end of value statement.

*/
{
    ABSARRAYREF     aarToken ;  // points to individual value.
    PLISTNODE    plstRoot ;  // start of LIST array
    DWORD       dwNodeIndex , dwPrevsNode, dwFirstNode;
                        // index of list node.
    DWORD       dwDelIndex ;    //  if BdelimitToken
        //  found a delimiter, this contains the index to pubDelimiters
        //  of the delimiter that was found.
    BOOL    bSyntaxErr = FALSE ;

    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    if(! BeatDelimiter(paarValue, "LIST"))
    {
        //  this keyword LIST  was not found, assume just
        //  one value exists.

        if(! BallocElementFromMasterTable(MTI_LISTNODES ,
            &dwNodeIndex, pglobl) )
        {
            return(FALSE) ;
        }
        // shove parsed integer into data field of new listnode.

        if(!fnBparseValue(paarValue, &(plstRoot[dwNodeIndex].dwData),
                    eAllowedValue, pglobl))
        {
            (VOID)BreturnElementFromMasterTable(MTI_LISTNODES, dwNodeIndex, pglobl) ;
            return(FALSE) ;
        }
        plstRoot[dwNodeIndex].dwNextItem = END_OF_LIST ;

        *pdwDest = dwNodeIndex ;

        return(TRUE) ;
    }
    if(! BeatDelimiter(paarValue, "("))
    {
        ERR(("syntax error: missing '(' after LIST.\n"));
        return(FALSE) ;
    }

    dwPrevsNode = END_OF_LIST ;
    //  prepare to process an entire list of items.

    for(dwDelIndex = 0 ; dwDelIndex != 1 ;   )
    {
        if(!BdelimitToken(paarValue, ",)", &aarToken, &dwDelIndex) )
        {
            bSyntaxErr = TRUE ;

            ERR(("missing terminating )  in LIST construct.\n"));
            //  emit message for user.

            break ;   //  attempt to return the list we have so far.
        }
        if(dwDelIndex == 1  &&  !aarToken.dw)
            break ;  // empty item.

        if(! BallocElementFromMasterTable(MTI_LISTNODES ,
            &dwNodeIndex, pglobl) )
        {
            return(FALSE) ;
        }
        // shove parsed integer into data field of new listnode.

        if(!fnBparseValue(&aarToken, &(plstRoot[dwNodeIndex].dwData),
                eAllowedValue, pglobl))
        {
            (VOID)BreturnElementFromMasterTable(MTI_LISTNODES, dwNodeIndex, pglobl) ;
            continue ;   //  just skip to the next value in list.
        }
        plstRoot[dwNodeIndex].dwNextItem = END_OF_LIST ;

        if(dwPrevsNode == END_OF_LIST)
        {
            // Therefore, this is the first node in the list.
            dwFirstNode = dwNodeIndex ;
        }
        else    //  cause prevs node to point to this node.
        {
            plstRoot[dwPrevsNode].dwNextItem = dwNodeIndex ;
        }
        dwPrevsNode = dwNodeIndex ;  // place here instead
        // of part of for( ; ; ) statement so 'continue' will
        //  bypass this statement.
    }

    if(dwPrevsNode == END_OF_LIST)
        dwFirstNode = END_OF_LIST ;
        //  empty list is now acceptable.

    if(!bSyntaxErr)
    {
        //  verify there is nothing else in statement.
        (VOID) BeatLeadingWhiteSpaces(paarValue) ;
        if(paarValue->dw)
        {
            ERR(("extraneous characters found after the end of the LIST construct.\n"));
            //  may want to print them out.
            //  not a fatal condition, continue.
        }
    }
    *pdwDest  = dwFirstNode ;
    return(TRUE) ;
}


BOOL    BeatLeadingWhiteSpaces(
IN  OUT  PABSARRAYREF   paarSrc
)
/*  as name suggests, advance paarSrc to
    first nonwhite or set dw = 0  if src string
    is exhausted.
*/
{
    PBYTE  pub ;
    DWORD  dw  ;

    pub = paarSrc->pub ;
    dw = paarSrc->dw ;

    while(dw  &&  (*pub == ' '  ||  *pub == '\t') )
    {
        pub++ ;
        dw-- ;
    }
    paarSrc->pub = pub ;
    paarSrc->dw = dw ;
    return(TRUE);  // always return true now,
    // but can add more robust error checking in the future.
}


BOOL    BeatDelimiter(
IN  OUT  PABSARRAYREF   paarSrc,
IN       PBYTE          pubDelStr //  points to a string which paarSrc must match
)
    //  expects to encounter only
    //  whitespaces before reaching the specified delimiter string.
    //  if delimiter doesn't match or src string is exhausted, returns
    //  FALSE.  parrSrc  not updated.  Otherwise parrSrc
    //  is updated to point to char which follows delimiter.
{
    PBYTE  pub ;
    DWORD  dw, dwLen   ;

    (VOID) BeatLeadingWhiteSpaces(paarSrc) ;

    pub = paarSrc->pub ;
    dw = paarSrc->dw ;
    dwLen = strlen(pubDelStr) ;

    if(dw < dwLen)
        return(FALSE);

    if(strncmp(pub,  pubDelStr,  dwLen))
        return(FALSE);

    pub += dwLen;
    dw -= dwLen;  // 'Eat' delimiter string

    paarSrc->pub = pub ;
    paarSrc->dw = dw ;

    return(TRUE);
}

BOOL    BdelimitToken(
IN  OUT  PABSARRAYREF   paarSrc,       //  source string
IN       PBYTE          pubDelimiters, //  array of valid delimiters
OUT      PABSARRAYREF   paarToken,     //  token defined by delimiter
OUT      PDWORD         pdwDel         //  which delimiter was first encountered?
)
//  searchs paarSrc for the first occurence of one of the
//  characters in the string pubDelimiters.  Once found
//  all characters up to that delimiter are considered a
//  token and an abs string ref to this token is returned
//  in paarToken.   paarSrc is updated to point to first char
//  after the delimiter.  If delimiter is not found within paarSrc,
//  returns FALSE and neither paarSrc or paarToken is updated.
//  pdwDel  will contain the zero based index of the delimiter
//  that was first encountered:  pubDelimiters[pdwDel] .
//  Note this function ignores the " and < delimiters if they
//  are preceeded by the % character.  See ParseString for
//  more info.
{
    PBYTE  pub ;
    DWORD  dw, dwLen, dwI  ;


    pub = paarSrc->pub ;
    dw = paarSrc->dw ;

    dwLen = strlen(pubDelimiters) ;

    while( dw )
    {
        for(dwI = 0 ; dwI < dwLen ; dwI++)
        {
            if(*pub == pubDelimiters[dwI])
            {
                if((*pub == '"'  ||  *pub == '<')  &&
                    (dw < paarSrc->dw)  &&  *(pub - 1) == '%')
                {
                    continue ;
                }
                paarToken->pub = paarSrc->pub ;
                paarToken->dw = paarSrc->dw - dw ;

                *pdwDel = dwI ;  // this was the delimiter

                paarSrc->pub = ++pub ;  // position after delimiter.
                paarSrc->dw = --dw ;    //  may go to zero.

                return(TRUE);
            }
        }
        pub++ ;
        dw-- ;
    }
    return(FALSE);  // string exhausted, no delimiters found.
}


BOOL    BeatSurroundingWhiteSpaces(
IN  PABSARRAYREF   paarSrc
)
/*  as name suggests, advance paarSrc to
    first nonwhite and adjust count to exclude
    trailing whitespaces or set dw = 0  if src string
    is exhausted.   Note:  this routine expects
    only leading and trailing whitespaces.
    The presence of whitespaces within the token
    is a user error. (or maybe an internal error).
*/
{
    PBYTE  pub ;
    DWORD  dw , dwLen ;

    pub = paarSrc->pub ;
    dw = paarSrc->dw ;

    while(dw  &&  (*pub == ' '  ||  *pub == '\t') )
    {
        pub++ ;
        dw-- ;
    }
    paarSrc->pub = pub ;

    for(dwLen = 0 ; dw  &&  (*pub != ' ')  &&  (*pub != '\t') ; dwLen++ )
    {
        pub++ ;
        dw-- ;
    }
    paarSrc->dw = dwLen ;

    //  make sure the rest is white

    while(dw  &&  (*pub == ' '  ||  *pub == '\t') )
    {
        pub++ ;
        dw-- ;
    }
    if(dw)
    {
        ERR(("more than one token found where only one was expected: %0.*s\n",
            paarSrc->dw, paarSrc->pub));

        return(FALSE);
    }
    return(TRUE);
}


BOOL    BparseSymbol(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,       //  write dword value here.
IN  VALUE          eAllowedValue, // which class of symbol is this?
IN  PGLOBL         pglobl
)
{
    DWORD  dwSymbolTree ;

    dwSymbolTree = ((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct)
                        [eAllowedValue - VALUE_SYMBOL_FIRST] ;

    if(! BeatSurroundingWhiteSpaces(paarValue) )
        return(FALSE);

    *pdwDest = DWsearchSymbolListForAAR(paarValue, dwSymbolTree, pglobl) ;
    if(*pdwDest == INVALID_SYMBOLID)
    {
        ERR(("user supplied a non-existent symbol: %0.*s in class: %d\n",
        paarValue->dw, paarValue->pub, (eAllowedValue - VALUE_SYMBOL_FIRST) ));

        return(FALSE);
    }
    return(TRUE);
}


BOOL    BparseQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)
/*   A QualifiedName shall be stored in one DWord, if more
    storage is required, things get more complex.
    A QualifiedName shall consist of 2 parts, Attributes
    requiring more qualifiers may specify a LIST of
    qualified names.
    note: cramming DWORD into WORD, assumes all ID values
    are WORD sized.
*/
{
    ABSARRAYREF     aarFeature ;  // points to FeatureName.
    DWORD       dwDelIndex ;  // serves no purpose here.
    DWORD   dwFeatureID, dwFeatureIndex , dwRootOptions, dwOptionID;
    PSYMBOLNODE     psn ;

    if(!BdelimitToken(paarValue, ".", &aarFeature, &dwDelIndex) )
    {
        ERR(("required delimiter '.' missing in qualified value: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    if(! BeatSurroundingWhiteSpaces(&aarFeature) )  // holds feature
    {
        ERR(("no feature found in qualified value: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    if(! BeatSurroundingWhiteSpaces(paarValue) )  // holds option
    {
        ERR(("no option found in qualified value: %0.*s\n",
        aarFeature.dw, aarFeature.pub));
        return(FALSE);
    }

    dwFeatureID = DWsearchSymbolListForAAR(&aarFeature, mdwFeatureSymbols, pglobl) ;
    if(dwFeatureID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Feature symbol: %0.*s\n",
        aarFeature.dw, aarFeature.pub));
        //  for qualified value.
        return(FALSE);
    }
    dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
        mdwFeatureSymbols, pglobl);

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;
    dwOptionID = DWsearchSymbolListForAAR(paarValue, dwRootOptions, pglobl) ;
    if(dwOptionID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Option symbol: %0.*s\n",
            paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    ((PQUALNAME)pdwDest)->wFeatureID = (WORD)dwFeatureID ;
    ((PQUALNAME)pdwDest)->wOptionID = (WORD)dwOptionID ;

    return(TRUE);
}




BOOL    BparseQualifiedNameEx
(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue,  // which class of symbol is this?
IN  PGLOBL        pglobl
)
/*   A QualifiedNameEx is a QualifiedName followed
    by   an unsigned integer  with a  .  delimiter.
    Optionally it may just be an integer!
    This type shall be used to store resource references.

    This shall be stored in one DWord  in the following format:

    {   //  arranged in order of increasing memory addresses
        WORD    intValue ;
        BYTE    OptionIndex ;
        BYTE    FeatureIndex ;    //   note  high byte may be cleared
    }                                       //  since this is intended for use only
                                            //   as a resource reference.


*/
{
    ABSARRAYREF     aarFeature,   // points to FeatureName.
                                aarOption ;    // points to OptionName.
    DWORD       dwDelIndex ;  // serves no purpose here.
    DWORD   dwFeatureID, dwFeatureIndex , dwRootOptions, dwOptionID;
    PSYMBOLNODE     psn ;

    if(!BdelimitToken(paarValue, ".", &aarFeature, &dwDelIndex) )
    {
        //  assume this is an integer form.

        return(BparseInteger( paarValue,   pdwDest,   VALUE_INTEGER, pglobl) );
    }

    if(! BeatSurroundingWhiteSpaces(&aarFeature) )  // holds feature
    {
        ERR(("no feature found in qualified valueEx: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    if(!BdelimitToken(paarValue, ".", &aarOption, &dwDelIndex) )
    {
        ERR(("required 2nd delimiter '.' missing in qualified valueEx: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }

    if(! BeatSurroundingWhiteSpaces(&aarOption) )  // holds option
    {
        ERR(("no option found in qualified valueEx: %0.*s\n",
        aarFeature.dw, aarFeature.pub));
        return(FALSE);
    }
    if(!BparseInteger( paarValue,   pdwDest,   VALUE_INTEGER, pglobl) )
    {
        ERR(("Err parsing integer portion of qualified valueEx: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }

    dwFeatureID = DWsearchSymbolListForAAR(&aarFeature, mdwFeatureSymbols, pglobl) ;
    if(dwFeatureID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Feature symbol: %0.*s\n",
        aarFeature.dw, aarFeature.pub));
        //  for qualified value.
        return(FALSE);
    }
    dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
        mdwFeatureSymbols, pglobl) ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;
    dwOptionID = DWsearchSymbolListForAAR(&aarOption, dwRootOptions, pglobl) ;
    if(dwOptionID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Option symbol: %0.*s\n",
            aarOption.dw, aarOption.pub));
        return(FALSE);
    }
    if(gdwResDLL_ID)   //  has already been initialized
    {
        if(gdwResDLL_ID  !=  dwFeatureID)
        {
            ERR(("References to ResourceDLLs must be placed in the feature with symbolname: RESDLL.\n"));
            return(FALSE);
        }
    }
    else
        gdwResDLL_ID  =  dwFeatureID ;

    if(dwOptionID >= 0x80 )
    {
        ERR(("GPD may not reference more than 127 resource files.\n"));
        return(FALSE);
    }
    //  integer portion already set.
    ((PQUALNAMEEX)pdwDest)->bFeatureID = (BYTE)dwFeatureID ;
    ((PQUALNAMEEX)pdwDest)->bOptionID = (BYTE)dwOptionID ;

    //  if needed, clear high bit here!
    ((PQUALNAMEEX)pdwDest)->bOptionID &= ~0x80  ;

    return(TRUE);
}





BOOL    BparsePartiallyQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,   //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)
/*   Similar to  parseQualifiedName but will tolerate
    a Featurename by itself.
    in this case the optionID will be set to INVALID_SYMBOLID.
*/
{
    ABSARRAYREF     aarFeature ;  // points to FeatureName.
    DWORD       dwDelIndex ;  // serves no purpose here.
    DWORD   dwFeatureID, dwFeatureIndex , dwRootOptions,
        dwOptionID = 0;
    PSYMBOLNODE     psn ;

    if(!BdelimitToken(paarValue, ".", &aarFeature, &dwDelIndex) )
    {
        aarFeature = *paarValue ;  //  initialize since BdelimitToken doesn't
        dwOptionID = INVALID_SYMBOLID ;
    }
    if(! BeatSurroundingWhiteSpaces(&aarFeature) )  // holds feature
    {
        ERR(("no feature found in partially qualified value: %0.*s\n", paarValue->dw, paarValue->pub));
        return(FALSE);
    }

    if(!dwOptionID  &&
        ! BeatSurroundingWhiteSpaces(paarValue) )  // holds option
    {
        ERR(("no option found after . in partially qualified value: %0.*s\n", paarValue->dw, paarValue->pub));
        return(FALSE);
    }

    dwFeatureID = DWsearchSymbolListForAAR(&aarFeature, mdwFeatureSymbols, pglobl) ;
    if(dwFeatureID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Feature symbol: %0.*s\n", paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
        mdwFeatureSymbols, pglobl);

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;


    if(!dwOptionID)
    {
        dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;
        dwOptionID = DWsearchSymbolListForAAR(paarValue, dwRootOptions, pglobl) ;
        if(dwOptionID == INVALID_SYMBOLID)
        {
            ERR(("qualified name references a non-existent Option symbol: %0.*s\n", paarValue->dw, paarValue->pub));
            return(FALSE);
        }
    }
    ((PQUALNAME)pdwDest)->wFeatureID = (WORD)dwFeatureID ;
    ((PQUALNAME)pdwDest)->wOptionID = (WORD)dwOptionID ;

    return(TRUE);
}




BOOL    BparseOptionSymbol(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,       //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)
/*  Note we assume any attribute expecting an OptionSymbol
    must reside within a Feature Construct.
*/
{
    WORD    wTstsInd ;  // temp state stack index
    STATE   stState ;
    DWORD   dwFeatureID = 0, dwFeatureIndex , dwRootOptions;
    PSYMBOLNODE     psn ;

    if(  eAllowedValue != VALUE_SYMBOL_OPTIONS )
        return(FALSE);

    if(! BeatSurroundingWhiteSpaces(paarValue) )
        return(FALSE);

    for(wTstsInd = 0 ; wTstsInd < mdwCurStsPtr ; wTstsInd++)
    {
        stState = mpstsStateStack[wTstsInd].stState ;
        if(stState == STATE_FEATURE )
        {
            dwFeatureID = mpstsStateStack[wTstsInd].dwSymbolID  ;
            break ;
        }
    }
    if(wTstsInd >= mdwCurStsPtr)
        return (FALSE) ;

    dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
        mdwFeatureSymbols, pglobl) ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;
    *pdwDest = DWsearchSymbolListForAAR(paarValue, dwRootOptions, pglobl) ;
    if(*pdwDest == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Option symbol: %0.*s\n", paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    return(TRUE);
}



BOOL    BparseConstant(
IN  OUT  PABSARRAYREF  paarValue,
OUT      PDWORD        pdwDest,       //  write dword value here.
IN       VALUE         eAllowedValue,  // which class of constant is this?
IN       PGLOBL        pglobl
)
/*  note:  this function will destroy/modify paarValue, it will
    only reference the constant name when done.  */
{
    DWORD   dwClassIndex = eAllowedValue - VALUE_CONSTANT_FIRST ;
    DWORD   dwI, dwCount, dwStart , dwLen;

    dwStart = gcieTable[dwClassIndex].dwStart ;
    dwCount = gcieTable[dwClassIndex].dwCount ;

    if(! BeatSurroundingWhiteSpaces(paarValue) )
        return(FALSE);

    for(dwI = 0 ; dwI < dwCount ; dwI++)
    {
        dwLen = strlen(gConstantsTable[dwStart + dwI].pubName);

        if((dwLen == paarValue->dw)  &&
            !strncmp(paarValue->pub, gConstantsTable[dwStart + dwI].pubName,
                        paarValue->dw) )
        {
            *pdwDest = gConstantsTable[dwStart + dwI].dwValue ;
            return(TRUE);
        }
    }
#if defined(DEVSTUDIO)  //  Keep messages to one line, where possible
    ERR(("Error: constant value '%0.*s' is not a member of enumeration class: %s\n",
        paarValue->dw , paarValue->pub, gConstantsTable[dwStart - 1].pubName));
#else
    ERR(("Error: constant value not a member of enumeration class: %s\n", gConstantsTable[dwStart - 1].pubName));
    ERR(("\t%0.*s\n", paarValue->dw , paarValue->pub )) ;
#endif
    return(FALSE);
}


BOOL  BinitClassIndexTable(
IN  OUT     PGLOBL  pglobl)
{
    DWORD   dwOldClass, dwCTIndex ;

    for(dwCTIndex = 0 ; dwCTIndex < CL_NUMCLASSES ; dwCTIndex++ )
    {
        gcieTable[dwCTIndex].dwStart = 0 ;
        gcieTable[dwCTIndex].dwCount = 0 ;  // set to known state.
    }

    dwOldClass = gConstantsTable[0].dwValue  ;
    gcieTable[dwOldClass].dwStart = 2 ;  // index of first entry

    for(dwCTIndex = 2 ; 1 ; dwCTIndex++ )
    {
        if(!gConstantsTable[dwCTIndex].pubName)
        {
            gcieTable[dwOldClass].dwCount =
                dwCTIndex - gcieTable[dwOldClass].dwStart ;

            dwOldClass = gConstantsTable[dwCTIndex].dwValue ;

            if(dwOldClass == CL_NUMCLASSES)
                break ;  // reached end of table.

            gcieTable[dwOldClass].dwStart = dwCTIndex + 2 ;
        }
    }
    for(dwCTIndex = 0 ; dwCTIndex < CL_NUMCLASSES ; dwCTIndex++ )
    {
        if(!gcieTable[dwCTIndex].dwCount)
        {
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_CODEBUG ;
            return(FALSE) ; //   paranoid - some classes not
        }
    }           //  listed in    gConstantsTable[] .
    return(TRUE) ;
}

BOOL    BparseRect(
IN  PABSARRAYREF   paarValue,
IN  PRECT   prcDest,
    PGLOBL  pglobl
)
/*  note:  integers initialize the rect structure in memory
    in the order in which they appear.  First int initializes
    the lowest memory location and so on.
*/
{
    ABSARRAYREF     aarToken ;  // points to individual value.
    DWORD       dwDelIndex ;    //  if BdelimitToken
        //  found a delimiter, this contains the index to pubDelimiters
        //  of the delimiter that was found.
    DWORD   dwI ;  // number integers in RECT


    if(! BeatDelimiter(paarValue, "RECT"))
    {
        ERR(("expected token 'RECT'.\n"));
        return(FALSE) ;
    }
    if(! BeatDelimiter(paarValue, "("))
    {
        ERR(("syntax error: missing '(' after RECT.\n"));
        return(FALSE) ;
    }

    for(dwI = dwDelIndex = 0 ; dwI < 4  &&  dwDelIndex != 1 ;   dwI++)
    {
        if(!BdelimitToken(paarValue, ",)", &aarToken, &dwDelIndex) )
        {
            ERR(("missing terminating )  in RECT construct.\n"));
            //  emit message for user.

            return(FALSE) ;
        }
        if(!BparseInteger(&aarToken, (PDWORD)prcDest + dwI, VALUE_INTEGER, pglobl))
        {
            ERR(("syntax error in %d th integer of RECT.\n", dwI));
            ERR(("\t%0.*s\n", aarToken.dw, aarToken.pub));
            return(FALSE) ;
        }
    }

    if(dwI != 4  ||  dwDelIndex != 1)
    {
        ERR(("incorrect number of integers for RECT.\n"));
        return(FALSE) ;
    }
    //  verify there is nothing else in statement.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    if(paarValue->dw)
    {
        ERR(("extraneous characters found after the end of the RECT construct: %0.*s\n", paarValue->dw, paarValue->pub));
        //  may want to print them out.
        //  not a fatal condition, continue.
    }
    return(TRUE) ;
}


BOOL    BparsePoint(
IN  PABSARRAYREF   paarValue,
IN  PPOINT   pptDest,
    PGLOBL   pglobl
)
{
    ABSARRAYREF     aarToken ;  // points to individual value.
    DWORD       dwDelIndex ;    //  if BdelimitToken
        //  found a delimiter, this contains the index to pubDelimiters
        //  of the delimiter that was found.
    DWORD   dwI ;  // number integers in POINT


    if(! BeatDelimiter(paarValue, "PAIR"))
    {
        ERR(("expected token 'PAIR'.\n"));
        return(FALSE) ;
    }
    if(! BeatDelimiter(paarValue, "("))
    {
        ERR(("syntax error: missing '(' after PAIR.\n"));
        return(FALSE) ;
    }

    for(dwI = dwDelIndex = 0 ; dwI < 2  &&  dwDelIndex != 1 ;   dwI++)
    {
        if(!BdelimitToken(paarValue, ",)", &aarToken, &dwDelIndex) )
        {
            ERR(("missing terminating )  in PAIR construct.\n"));
            //  emit message for user.

            return(FALSE) ;
        }
        if(!BparseInteger(&aarToken, (PDWORD)pptDest + dwI, VALUE_INTEGER, pglobl))
        {
            ERR(("syntax error in %d th integer of PAIR.\n", dwI));
            ERR(("\t%0.*s\n", aarToken.dw, aarToken.pub));
            return(FALSE) ;
        }
    }

    if(dwI != 2  ||  dwDelIndex != 1)
    {
        ERR(("incorrect number of integers for PAIR.\n"));
        return(FALSE) ;
    }
    //  verify there is nothing else in statement.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    if(paarValue->dw)
    {
        ERR(("extraneous characters found after the end of the PAIR construct: %0.*s\n", paarValue->dw, paarValue->pub));
    }
    return(TRUE) ;
}


BOOL    BparseString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  OUT PGLOBL     pglobl
)
/*  strings are comprised of one or more string segments separated
    by optional arbitrary whitespace,
    each string segment is surrounded by double quotes.
    string segments may contain a mixture of literal sections
    and hexsubstrings.   Hexsubstrings are delimited by angle brackets.
    WhiteSpaces (but not linebreak chars) are permitted in the
    literal portion of the string, they part of the string.
    Otherwise only printable  chars are allowed.
    Valid hexchars and Arbitrary whitespace is permitted
    within the hexsubstrings.  Parsing of a string value ends
    when a statement terminator is encountered.

    The escape char %
    Within the literal portion of a string segment
    the following combinations are reinterpreted:

    %< maps to literal <
    %" maps to literal "

    > only has a special meaning within a hexsubstring.

    Assumption:  assumes the only heap usage that occurs
    within this function (and any called functions) is
    to assemble all string segments contiguously on the heap.
    Any hidden use of the heap will corrupt the continuity.

    the string may be terminated by : if a second value field is expected.
*/
{
    ABSARRAYREF     aarToken ;  // points to individual string segment.
    DWORD       dwDelIndex ;    //  dummy
    DWORD   dwI ;  // number of string segments parsed.


    if(! BeatDelimiter(paarValue, "\""))
    {
        ERR(("syntax error: string  must begin with '\"' .\n"));
        return(FALSE) ;
    }

    parStrValue->dwCount = 0 ;  // initialize so BparseStrSegment
                            //  will overwrite instead of append

    for(dwI = dwDelIndex = 0 ;  1 ;   dwI++)
    {
        if(!BdelimitToken(paarValue, "\"", &aarToken, &dwDelIndex) )
        {
            ERR(("missing terminating '\"'  in string.\n"));
            //  emit message for user.

            return(FALSE) ;
        }
        if(!BparseStrSegment(&aarToken, parStrValue, pglobl))
        {
            return(FALSE) ;
        }
        if(! BeatDelimiter(paarValue, "\""))  // find start of next
                //  string segment, if one exists.
            break ;
    }

    //  verify there is either a specially recognized character
    //  or nothing else in Value string.


    if(paarValue->dw)
    {
        if(*paarValue->pub == ':')
        {
            //  a keyword with a composite value
            (VOID)BeatDelimiter(paarValue, ":") ;
                //  I know this will succeed!
            (VOID) BeatLeadingWhiteSpaces(paarValue) ;
            return(TRUE) ;
        }
        else
        {
            ERR(("extraneous characters found after end quote, in string construct: %0.*s\n", paarValue->dw, paarValue->pub));
            //    may want to print them out.
            return(FALSE) ;
        }
    }
    return(TRUE) ;
}


BOOL    BparseAndTerminateString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  VALUE          eAllowedValue,
IN  OUT  PGLOBL    pglobl
)
{

    ARRAYREF    arSrcString ;
    INT     iCodepage ;  // unused for now.


    if(!BparseString(paarValue, parStrValue, pglobl) )
        return(FALSE) ;


    //  We don't want null terminations to occur between parameter
    //  portion of a string.  We just want to blindly add the NULL
    //  when parsing is really finished.

    {
        DWORD      dwDummy ;  // holds offset in heap, but we don't care.

        if(!BwriteToHeap(&dwDummy, "\0", 1, 1, pglobl) )  //  add Null termination
            return(FALSE) ;
    }

    if(eAllowedValue == VALUE_STRING_NO_CONVERT)
        return(TRUE) ;
    if(eAllowedValue == VALUE_STRING_CP_CONVERT)
    {
        //  we need to determine the value set by *CodePage
        PGLOBALATTRIB   pga ;
        DWORD   dwHeapOffset;

        pga =  (PGLOBALATTRIB)gMasterTable[
                    MTI_GLOBALATTRIB].pubStruct ;

        if(!BReadDataInGlobalNode(&pga->atrCodePage,
                &dwHeapOffset, pglobl) )
            return(TRUE);

        //  if no codepage is defined, we will not perform
        //  any xlation since we assume all strings are already
        //  expressed in unicode.

        iCodepage = *(PDWORD)(mpubOffRef + dwHeapOffset) ;
    }
    else   //  eAllowedValue == VALUE_STRING_DEF_CONVERT
        iCodepage = CP_ACP ; // use system default codepage.

    arSrcString = *parStrValue ;
    if(!BwriteUnicodeToHeap(&arSrcString, parStrValue,
            iCodepage, pglobl))
        return(FALSE) ;
    return(TRUE) ;
}

BOOL     BwriteUnicodeToHeap(
IN   PARRAYREF      parSrcString,
OUT  PARRAYREF      parUnicodeString,
IN   INT            iCodepage,
IN  OUT PGLOBL      pglobl
)
//  this function copies dwCnt bytes from pubSrc to
//  top of heap and writes the offset of the destination string
//  to pdwDestOff.   Nothing is changed if FAILS.
//  Warning!  Double Null termination is added to string.
{
    PBYTE  pubDest ;      //  destination location
    PBYTE  pubSrc ;       //  points to src string
    DWORD  dwAlign = sizeof(WCHAR) ;    //  align Unicode string at WORD boundaries.
    DWORD  dwMaxDestSize , dwActDestSize, dwDummy ;

    mloCurHeap = (mloCurHeap + dwAlign - 1) / dwAlign ;
    mloCurHeap *= dwAlign ;

    pubDest = mpubOffRef + mloCurHeap ;
    pubSrc  = mpubOffRef + parSrcString->loOffset ;

    parUnicodeString->loOffset = mloCurHeap ;

    dwMaxDestSize = sizeof(WCHAR) * (parSrcString->dwCount + 1) ;

    //  is there enough room in the heap ?
    if(mloCurHeap + dwMaxDestSize  >  mdwMaxHeap)
    {
        ERR(("Heap exhausted - restart.\n"));

        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STRINGHEAP ;
        }
        return(FALSE);
    }
    dwActDestSize = sizeof(WCHAR) * MultiByteToWideChar(iCodepage,
            MB_PRECOMPOSED, pubSrc, parSrcString->dwCount, (PWORD)pubDest,
            dwMaxDestSize);

    mloCurHeap += dwActDestSize ;   // update heap ptr.
    parUnicodeString->dwCount = dwActDestSize ;

    (VOID)BwriteToHeap(&dwDummy, "\0\0", 2, 1, pglobl)   ;
        //  add DoubleNull termination
        //  this cannot fail since we already took the NULs into account

    return(TRUE) ;
}






BOOL    BparseStrSegment(
IN  PABSARRAYREF   paarStrSeg,      // source str segment
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL         pglobl
)
{
    ABSARRAYREF     aarToken ;  // points to literal or hex substring segment.
    DWORD       dwDelIndex ;    //  dummy
    DWORD   dwI ;  // number of string segments parsed.

    for(dwI = dwDelIndex = 0 ;  1 ;   dwI++)
    {
        if(!BdelimitToken(paarStrSeg, "<", &aarToken, &dwDelIndex) )
        {
            // no more hex substrings.
            return(BparseStrLiteral(paarStrSeg, parStrLiteral, pglobl) ) ;
        }
        if(!BparseStrLiteral(&aarToken, parStrLiteral, pglobl))
        {
            return(FALSE) ;
        }
        if(!BdelimitToken(paarStrSeg, ">", &aarToken, &dwDelIndex) )
        {
            ERR(("Missing '>' terminator in hexsubstring.\n"));
            return(FALSE) ;
        }
        if(!(BparseHexStr(&aarToken, parStrLiteral, pglobl) ) )
            return(FALSE) ;
    }
    return TRUE;
}


BOOL    BparseStrLiteral(
IN  PABSARRAYREF   paarStrSeg,      // points to literal substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL         pglobl
)
/* in this function all delimiters have been parsed out.
    only special character sequence is %" and %<
    Does not Null terminate heap string
*/
{
    ARRAYREF      arTmpDest ;  // write result here first.
    DWORD       dwI ;  //  byte index along literal substring
    PBYTE       pubStartRun ;

    while(paarStrSeg->dw)
    {
        pubStartRun = paarStrSeg->pub ;

        for(dwI = 0 ; paarStrSeg->dw ;  dwI++)
        {
            if(*paarStrSeg->pub == '%'  &&  paarStrSeg->dw > 1  &&
                (paarStrSeg->pub[1] == '"'  ||  paarStrSeg->pub[1] == '<'))
            {
                paarStrSeg->dw-- ;    // skip the escape char.
                paarStrSeg->pub++ ;
                break ;
            }
            paarStrSeg->dw-- ;
            paarStrSeg->pub++ ;
        }
        if(!BwriteToHeap(&arTmpDest.loOffset, pubStartRun, dwI, 1, pglobl))
            return(FALSE) ;
        //  append this run to existing string
        if(!parStrLiteral->dwCount)  // no prevs string exists
        {
            parStrLiteral->loOffset = arTmpDest.loOffset ;
        }
        else
        {
            // BUG_BUG paranoid:  may check that string is contiguous
            // parStrLiteral->loOffset + parStrLiteral->dwCount
            // should equal arTmpDest.loOffset
            ASSERT(parStrLiteral->loOffset + parStrLiteral->dwCount == arTmpDest.loOffset );
        }
        parStrLiteral->dwCount += dwI ;
    }
    return(TRUE) ;
}


BOOL    BparseHexStr(
IN  PABSARRAYREF   paarStrSeg,      // points to hex substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
)
/* in this function all delimiters have been parsed out.
    only Whitespace and hex chars should exist.
    Does not Null terminate heap string
*/
{
    ARRAYREF      arTmpDest ;  // write result here first.
    DWORD       dwI ;  //  num dest bytes
    BYTE        ubHex, ubSrc, aub[40] ;  // accumulate hexbytes here
    BOOL        bHigh = TRUE ;

    while(paarStrSeg->dw)
    {
        for(dwI = 0 ; paarStrSeg->dw ;  )
        {
            ubSrc = *paarStrSeg->pub ;
            paarStrSeg->dw-- ;
            paarStrSeg->pub++ ;
            if(ubSrc >= '0'  &&  ubSrc <= '9')
            {
                ubHex =  ubSrc - '0' ;
            }
            else if(ubSrc >= 'a'  &&  ubSrc <= 'f')
            {
                ubHex =  ubSrc - 'a' + 10 ;
            }
            else if(ubSrc >= 'A'  &&  ubSrc <= 'F')
            {
                ubHex =  ubSrc - 'A' + 10 ;
            }
            else if(ubSrc == ' '  ||  ubSrc == '\t')
                continue;  // safe to ignore whitespace  chars
            else
            {
                ERR(("syntax error:  illegal char found within hexsubstring: %c\n", ubSrc));
                return(FALSE) ;
            }
            if(bHigh)
            {
                aub[dwI] = ubHex << 4 ;   // store in high nibble.
                bHigh = FALSE ;
            }
            else
            {
                aub[dwI] |= ubHex ;   // store in low nibble.
                bHigh = TRUE ;
                dwI++ ;  // advance to next dest byte
            }
            if(dwI >= 40)
                break ;   // buffer full -- must flush aub
        }
        if(!BwriteToHeap(&arTmpDest.loOffset, aub, dwI, 1, pglobl))
            return(FALSE) ;
        //  append this run to existing string
        if(!parStrLiteral->dwCount)  // no prevs string exists
        {
            parStrLiteral->loOffset = arTmpDest.loOffset ;
        }
     