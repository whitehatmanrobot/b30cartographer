 hItemSelected = TreeView_GetSelection(DBTree.m_hLibraryTree);

                //
                // Note that it is possible that this function returns false. 
                // This will happen if the user presses CANCEL for "Database Saveas" 
                // dialog for some "untitled_x" database
                //
                if (!CloseAllDatabases()) {
                    //
                    // Select the database that the user refused to save.
                    //
                    TreeView_SelectItem(DBTree.m_hLibraryTree, g_pPresentDataBase->hItemDB);
                }

                break;
            }
        
        case ID_DATABASE_SAVEALL:
            
            DatabaseSaveAll();
            break;
    
        case ID_EDIT_SELECTALL:
            
            if (g_bIsContentListVisible) {
                ListViewSelectAll(g_hwndContentsList);
            }

            break;
    
        case ID_EDIT_INVERTSELECTION:
            
            if (g_bIsContentListVisible) {
                ListViewInvertSelection(g_hwndContentsList);
            }

            break;
            
        case ID_EDIT_CUT:
        case ID_EDIT_COPY:

            SetCursor(LoadCursor(NULL, IDC_WAIT));
            CopyToClipBoard(wCode);               
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            break;
    
        case ID_EDIT_PASTE:
            {   
                //
                // This variable is presently not used
                //
                g_bEntryConflictDonotShow = FALSE;
                
                PasteFromClipBoard();
                
                //
                // Now we may need to refresh the contents list.
                //
                HTREEITEM hItem = TreeView_GetSelection(DBTree.m_hLibraryTree);
                TYPE      type  = (TYPE)GetItemType(DBTree.m_hLibraryTree, hItem);
    
                if (type == TYPE_GUI_APPS || type == TYPE_GUI_LAYERS || type == FIX_LAYER) {
                    PopulateContentsList(hItem);
                    SetStatusStringDBTree(hItem);
                }

                break;
            }
    
        case ID_MODIFY_COMPATIBILITYMODE:
            
            g_bSomeWizardActive = TRUE;
            ModifyLayer();
            g_bSomeWizardActive = FALSE;
            break;
    
        case ID_EDIT_RENAME:
            
            OnRename();
            break;
    
        case ID_EDIT_CONFIGURELUA:
            
            if (g_bAdmin == FALSE) {
                MessageBox(hdlg, GetString(IDS_ERRORNOTADMIN), g_szAppName, MB_ICONINFORMATION);
                break;
            }
            
            //
            // Start the LUA Wizard.
            //
            if (g_pSelEntry == NULL) {
                assert(FALSE);
                break;
            }

            g_bSomeWizardActive = TRUE;
            LuaBeginWizard(g_hDlg, g_pSelEntry, g_pPresentDataBase);
            g_bSomeWizardActive = FALSE;

            break;
    
        case ID_VIEW_DESCRIPTION:
            {
                HMENU           hMenu       = GetMenu(g_hDlg);
                HMENU           hMenuView   = GetSubMenu(hMenu, 2);
                MENUITEMINFO    mii         = {0};
                
                mii.cbSize = sizeof(mii);
                mii.fMask  = MIIM_STATE;
    
                GetMenuItemInfo(hMenu, ID_VIEW_DESCRIPTION, FALSE, &mii);
                
                if (mii.fState & MFS_CHECKED) {
                    mii.fState &= ~MFS_CHECKED;
                } else {
                    mii.fState |= MFS_CHECKED;
                }
    
                g_bDescWndOn = !g_bDescWndOn;
                
                SetMenuItemInfo(hMenu, ID_VIEW_DESCRIPTION, FALSE, &mii);
    
                UpdateDescWindowStatus();
    
                break;
            }

        case ID_VIEW_LOG:

            if (g_bAdmin == FALSE) {

                MessageBox(hdlg, 
                           GetString(IDS_ERRORNOTADMIN), 
                           g_szAppName, 
                           MB_ICONINFORMATION);
                break;
            }

            ShowShimLog();
            break;

        default:
            return FALSE;
        }

        break;

    default:
        return FALSE;
    }

    return TRUE;
}

int 
WINAPI
WinMain(
    IN  HINSTANCE hInstance,
    IN  HINSTANCE hPrevInstance,
    IN  LPSTR     lpCmdLine,
    IN  int       nCmdShow
    )
/*++
    WinMain

	Desc:	The WinMain

	Params: Standard WinMain params   
        IN  HINSTANCE hInstance
        IN  HINSTANCE hPrevInstance
        IN  LPSTR     lpCmdLine
        IN  int       nCmdShow

	Return: Standard WinMain return   
--*/
{
    HINSTANCE   hmodRichEdit = NULL;
    TCHAR       szLibPath[MAX_PATH * 2];
    BOOL        bIsGuest     = TRUE;   
    UINT        uResult      = 0;   

    //
    // Let the system handle data misalignment on Itanium. 
    //
    SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);

    *szLibPath = 0;

    uResult = GetSystemDirectory(szLibPath, MAX_PATH);

    if (uResult == 0 || uResult >= MAX_PATH) {
        assert(FALSE);
        Dbg(dlError, "WinMain", "GetSytemDirectory failed");
        //
        // We do NOT eject out from here as this is not critical
        //
    } else {
        ADD_PATH_SEPARATOR(szLibPath, ARRAYSIZE(szLibPath));

        StringCchCat(szLibPath, ARRAYSIZE(szLibPath), TEXT("RICHED32.DLL"));

        hmodRichEdit = LoadLibrary(szLibPath);
    }       
    
    //
    // The App Name
    //
    LoadString(g_hInstance, IDS_COMPATADMIN, g_szAppName, ARRAYSIZE(g_szAppName));

    if (!IsAdmin(&bIsGuest)) {

        if (bIsGuest) {
            //
            // Ok, guests cannot run compatadmin.
            //
            MessageBox(NULL, GetString(IDS_GUEST), g_szAppName, MB_ICONINFORMATION);
            goto End;
        }

        //
        // Not an admin, some features are disabled. Cannot do a test run and install databases
        //
        MessageBox(NULL, GetString(IDS_NEEDTOBEADMIN), g_szAppName, MB_ICONINFORMATION);
        g_bAdmin = FALSE;
    }
    
    g_hInstance = hInstance;

    INITCOMMONCONTROLSEX    icex;
    
    icex.dwSize    = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC     = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES | ICC_TAB_CLASSES | ICC_INTERNET_CLASSES | ICC_BAR_CLASSES ;

    if (!InitCommonControlsEx(&icex)) {
        InitCommonControls();
    }

    //
    // Check if the OS is Win2k
    //
    OSVERSIONINFOEX osvi;

    ZeroMemory(&osvi, sizeof (OSVERSIONINFOEX));

    g_fSPGreaterThan2 = FALSE; 

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((LPOSVERSIONINFO)&osvi);
    
    if ((osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion == 0)) {

        g_bWin2K = TRUE;

        if (osvi.wServicePackMajor > 2) {
            g_fSPGreaterThan2 = TRUE;   
        }
    }

    //
    // Attempt to locate the SDB in the AppPatch directory.
    //
    if (!CheckForSDB()) {

        if (g_bWin2K) {
            
            DialogBoxParam(g_hInstance,
                           MAKEINTRESOURCE(IDD_MSGBOX_SDB),
                           NULL,
                           MsgBoxDlgProc,
                           (LPARAM)0);
            goto End;

        } else {
            
            MessageBox(GetDesktopWindow(), 
                       GetString(IDS_XP_NO_SDB), 
                       g_szAppName, 
                       MB_OK | MB_ICONEXCLAMATION);

            goto End;
        }
    }
    
    if (g_bWin2K && !CheckProperSP()) {

        DialogBoxParam(g_hInstance,
                       MAKEINTRESOURCE(IDD_MSGBOX_SDB),
                       GetDesktopWindow(),
                       MsgBoxDlgProc,
                       (LPARAM)0); 
        goto End;
    }

    CoInitialize(NULL);

    g_hAccelerator = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDR_ACCL));

    MSG          msg ;
    WNDCLASS     wndclass ;
    
    wndclass.style         = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc   = (WNDPROC)CompatAdminDlgProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = g_hInstance;
    wndclass.hIcon         = NULL;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
    wndclass.lpszMenuName  = NULL;
    wndclass.lpszClassName = g_szAppName;
               
    if (!RegisterClass (&wndclass)) {

         MessageBox (NULL, 
                     GetString(IDS_INVALIDOS),
                     g_szAppName, 
                     MB_ICONERROR) ;
         
         goto End;
    }

    g_hDlg =  CreateDialog(g_hInstance,
                           MAKEINTRESOURCE(IDD_DIALOG),
                           GetDesktopWindow(),
                           CompatAdminDlgProc);

    ShowWindow(g_hDlg, SW_SHOWNORMAL);

    BOOL    bProcessMessage = TRUE;
    HWND    hwndActiveWindow;

    //try {

        while (GetMessage(&msg, NULL, 0, 0) > 0) {

            bProcessMessage = TRUE;
            
            if (g_hdlgSearchDB && IsDialogMessage(g_hdlgSearchDB, &msg)) {
                //
                // This is a message for the Search modeless dialog box
                //
                bProcessMessage = FALSE;

            } else if (g_hdlgQueryDB && IsDialogMessage(g_hdlgQueryDB, &msg)) {
                //
                // This is a message for the Query modeless dialog box
                //
                bProcessMessage = FALSE;

            } else if (g_hwndEventsWnd && IsDialogMessage(g_hwndEventsWnd, &msg)) {
                //
                // This is a message for the Events modeless dialog box
                //
                bProcessMessage = FALSE;
            }

            if (bProcessMessage) {
                //
                // Check if we have the text box for in-place renaming. If yes, we must
                // not call TranslateAccelerator() for the main app window. 
                //                
                if (GetFocus() == g_hwndRichEdit) {
                    //
                    // If we are on the rich edit control, we want to be able to do copy
                    // but also we want the tabs to be processed by IsDialogMessage()
                    //
                    if (g_hDlg && IsDialogMessage(g_hDlg, &msg)) {
                        //
                        // It was possibly a tab or a shift-tab
                        //
                        continue;
                    } else {
                        //
                        // Process all other rich edit messages
                        //
                        goto Translate;
                    }
                }

                if (!g_hwndEditText) {
                    
                    if (TranslateAccelerator(g_hDlg, g_hAccelerator, &msg)) {
                        //
                        // Accelerator for the main window, do not process this message.
                        //
                        continue;
                    }

                    //
                    // Process the tabs for the main window
                    //
                    if (g_hDlg && IsDialogMessage(g_hDlg, &msg)) {
                        continue;
                    }
                }

            Translate:

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    
    /*} catch (...) {

        MessageBox(GetDesktopWindow(), 
                   GetString(IDS_EXCEPTION), 
                   g_szAppName, 
                   MB_ICONERROR);
    }*/
    
End:
    if (hmodRichEdit) {
        FreeLibrary(hmodRichEdit);
    }

    return 0;
}


BOOL
HandleFirstEntryofAppDeletion(
    IN  PDATABASE   pDataBase,
    IN  PDBENTRY    pApp,
    IN  BOOL        bDelete
    )
/*++
    HandleFirstEntryofAppDeletion
    
    Desc:   Handles the special case, when the entry being deleted because of a cut
            or a delete is the first entry for the application
    
    Params:        
        IN  PDATABASE   pDataBase:  The database
        IN  PDBENTRY    pApp:       The application whose first enty is being deleted
        IN  BOOL        bDelete:    TRUE, if this function has been called because of
            a delete, FALSE if this function has been called because of a cut.If we 
            are removing the entry because of a cut,
            then we should not change the value of g_pEntrySelApp. If bCut is true that
            means focus is on some other app (may be in same diff. database) and we should
            be changing any focus etc.
        
    Return:
        FALSE:  There was some error
        TRUE:   Otherwise
        
    Notes:  This is a special case because when we are deleting the first entry of an 
            app, we have to check whether this is the only entry and if yes, then we might
            need to delete the entire app from the db tree. 
            Otherwise: The app tree item in the db tree contain a pointer to the first entry
            of the app in its lParam, this will need to be modified to point to the next item
--*/
{
    if (pApp == NULL || pDataBase == NULL) {
        assert(FALSE); 
        Dbg(dlError, "[HandleFirstEntryofAppDeletion] Invalid Arguments");
        return FALSE;
    }
    
    HTREEITEM   hItemApp    = DBTree.FindChild(pDataBase->hItemAllApps, (LPARAM)pApp);
    PDBENTRY    pEntryTemp  = pDataBase->pEntries;
    PDBENTRY    pEntryPrev  = NULL;

    //
    // Find the App Prev. to the one whose first entry is being deleted
    //
    while (pEntryTemp) {

        if (pEntryTemp == pApp) {
            break;
        }

        pEntryPrev = pEntryTemp;
        pEntryTemp = pEntryTemp->pNext;
    }

    if (pEntryPrev == NULL) {
        //
        // First Entry and first app.
        //
        if (pApp->pSameAppExe) {
            pDataBase->pEntries      = pApp->pSameAppExe;
            pApp->pSameAppExe->pNext = pApp->pNext;
        } else {
            pDataBase->pEntries = pApp->pNext;
        }

    } else {
        //
        // The next pointer of the app previous to the pApp should now point 
        // to the second entry for pApp as we are removing the first entry of pApp. 
        // if pApp has only one entry then we should make sure that the next pointer 
        // to the app prev to pApp should point to the next app after pApp
        //
        if (pApp->pSameAppExe) {
            pEntryPrev->pNext        = pApp->pSameAppExe;
            pApp->pSameAppExe->pNext = pApp->pNext;
        } else {
            pEntryPrev->pNext = pApp->pNext;
        }
    }

    if (pApp->pSameAppExe == NULL) {
        //
        // This was the only entry. We have to delete the application from the database tree
        //
        g_pEntrySelApp = NULL;

        DBTree.DeleteAppLayer(pDataBase, TRUE, hItemApp);

        --pDataBase->uAppCount;
        
    } else {
        //
        // We have to set the lParam of the app properly
        //
        DBTree.SetLParam(hItemApp, (LPARAM)pApp->pSameAppExe);

        if (bDelete) {
            //
            // If the deletion is because of a cut do not modify g_pEntrySelApp.
            // Because focus is on some other app (may be in some other database) and 
            // we do not want to change the present active app pointer.
            // Please note that we do the actual deletion part of a cut-paste after we 
            // have done the paste. So when this routine gets called because of a cut,
            // then we already have focus on the newly pasted item and g_pEntrySelApp
            // will be set to the first entry of the app in which the entry was pasted
            // This is correct, verified and needed. Do not change this.
            //
            g_pEntrySelApp = pApp->pSameAppExe;
        }
    }

    return TRUE;
}

void
GetDescriptionString(
    IN  LPARAM      itemlParam,
    OUT CSTRING&    strDesc,
    IN  HWND        hwndToolTip,
    IN  PCTSTR      pszCaption,       // (NULL)
    IN  HTREEITEM   hItem,            // (NULL)
    IN  HWND        hwnd,             // (NULL) 
    IN  INT         iListViewIndex    // (-1)
    ) 
/*++
    GetDescriptionString
    
    Desc:   Gets the description for the tree item hItem in tree hwnd or for the element 
            at index iListViewIndex in list view hwnd.
    
    Params:
        IN  LPARAM    itemlParam:   In case we are using a list view, the lParam of the item
        OUT CSTRING&  strDesc:      The description will be stored in this
        IN  HWND      hwndToolTip:  In case the description has to be shown in a tool-tip
                the handle to the tool tip window
                
        IN  PCTSTR    pszCaption (NULL):    In case the description has to be shown in a tool-tip
                the caption of the tool-tip window
                
        IN  HTREEITEM hItem (NULL): If we want to get the description of a tree item, the handle 
                to the tree item.
                
        IN  HWND      hwnd (NULL):  The handle to the list view or the tree view
        IN  INT       iListViewIndex (-1):  In case we are using a list view, the index of the item
                for which we want to get the description
                
        Notes:  If we are calling this routine for a list view, we must set correct iListViewIndex
                and itemlParam.
                itemlParam is ignored if we calling this routine for a tree view
--*/
{
    TYPE    type;
    LPARAM  lParam = itemlParam;

    strDesc = TEXT("");
    
    if (hItem) {
        
        if (hwnd == NULL) {
            assert(FALSE);
            goto End;
        }
        
        type = GetItemType(hwnd, hItem);
        CTree::GetLParam(hwnd, hItem, &lParam);

    } else {

        if (iListViewIndex != -1) {

            if (ListView_GetItemState(hwnd, iListViewIndex, LVIS_SELECTED) != LVIS_SELECTED) {

                if (hwndToolTip) {
                    SendMessage(hwndToolTip, TTM_SETTITLE, 0, (LPARAM)NULL);
                }
                
                return;
            }
        }

        if (lParam) {
            type = ConvertLparam2Type(lParam);
        } else {
            assert(FALSE);
        }
    }

    switch (type) {
    case FIX_LIST_SHIM:
        
        if (lParam) {
            lParam = (LPARAM)((PSHIM_FIX_LIST)lParam)->pShimFix;
        }
        //
        // CAUTION: case FIX_LIST_SHIM and FIX_SHIM should be one after another. 
        // NO break; The next FIX_SHIM case will now handle this.
        //
    case FIX_SHIM:
        {
            PSHIM_FIX pFix = (PSHIM_FIX)lParam;

            if (pFix == NULL) {
                assert(FALSE);
                goto End;
            }

            strDesc = (pFix->strDescription.Length() > 0) ? pFix->strDescription : TEXT("");
            break;
        }

    case FIX_LIST_FLAG:
        
        if (lParam) {
            lParam = (LPARAM)((PFLAG_FIX_LIST)lParam)->pFlagFix;
        }

        //
        // CAUTION: case FIX_LIST_FLAG and FIX_FLAG should be one after another. 
        // NO break; The next FIX_FLAG case will now handle this.
        //
    case FIX_FLAG:
        {
            PFLAG_FIX pFix = (PFLAG_FIX)lParam;
    
            if (pFix == NULL) {
                assert(FALSE);
                goto End;
            }
    
            strDesc = (pFix->strDescription.Length() > 0) ? pFix->strDescription : TEXT("");
            break;
        }

    case FIX_PATCH:
        {
            PPATCH_FIX pFix = (PPATCH_FIX)lParam;
            
            if (pFix == NULL) {
                assert(FALSE);
                goto End;
            }
            
            strDesc = (pFix->strDescription.Length() > 0) ? pFix->strDescription : TEXT("");
            break;
        }

    case FIX_LAYER:
        {
            PLAYER_FIX pFix = (PLAYER_FIX)lParam;
            
            if (pFix == NULL) {
                assert(FALSE);
                goto End;
            }
            
            strDesc = TEXT("");
            break;
        }
 
    case TYPE_APPHELP_ENTRY:
        {
            PAPPHELP pAppHelp = (PAPPHELP)lParam;

            if (pAppHelp == NULL) {
                break;
            }
             
            if (g_pPresentDataBase->type == DATABASE_TYPE_GLOBAL) {
    
                //
                // The AppHelp for the system database has to be picked up. This is not 
                // kept in the sysmain.sdb.
                // Also we do not keep this in the database data structure.
                // The apphelp messages for custom are kept in the .sdb and also they 
                // are kept in the database data structure. 
                //
                PDB pdbAppHelp = SdbOpenApphelpDetailsDatabase(NULL);
    
                APPHELP_DATA    AppHelpData;

                ZeroMemory(&AppHelpData, sizeof(APPHELP_DATA));

                if (g_pSelEntry == NULL) {
                    break;
                }
    
                AppHelpData.dwHTMLHelpID = g_pSelEntry->appHelp.HTMLHELPID;
    
                if (pdbAppHelp == NULL) {
                    strDesc = TEXT("");
                    break;
                }
            
                if (!SdbReadApphelpDetailsData(pdbAppHelp, &AppHelpData)) {
                    strDesc = TEXT("");
                    break;
                }
    
                strDesc.Sprintf(TEXT("%s %s"), CSTRING(IDS_DESC_APPHELP1).pszString, AppHelpData.szDetails);
    
                if (AppHelpData.szURL) {
                    strDesc.Strcat(CSTRING(IDS_DESC_APPHELP2));
                    strDesc.Strcat(AppHelpData.szURL);
                }
    
                if (pdbAppHelp) {
                    SdbCloseDatabase(pdbAppHelp);
                }

            } else {
                //
                // This is a custom database and we have the apphelp message loaded with the
                // database
                //
                strDesc.Sprintf(TEXT("%s %s"), CSTRING(IDS_DESC_APPHELP1).pszString, pAppHelp->strMessage);
    
                if (pAppHelp->strURL.Length()) {
                    strDesc.Strcat(CSTRING(IDS_DESC_APPHELP2));
                    strDesc.Strcat(pAppHelp->strURL);
                }
            }
    
            if (g_pSelEntry == NULL) {
                assert(FALSE);
                break;
            }
    
            switch (g_pSelEntry->appHelp.severity) {
            case APPTYPE_INC_HARDBLOCK:

                strDesc.Strcat(CSTRING(IDS_APPHELP_DESC_HARDBLOCK));
                break;
            
            case APPTYPE_NONE:

                strDesc.Strcat(CSTRING(IDS_APPHELP_DESC_NONE));
                break;
            
            default:

                strDesc.Strcat(CSTRING(IDS_APPHELP_DESC_SOFTBLOCK));
                break;
            }

            break;
        }

    default:

        strDesc = TEXT("");
        break;
    }
 
    if (strDesc.Length() && pszCaption && hwndToolTip) {
        //
        // We have a valid caption, so set it only if we have a tooltip
        //
        SendMessage(hwndToolTip, TTM_SETTITLE, 1, (LPARAM)pszCaption);
    } else if (hwndToolTip) {
        //
        // We do not have a caption, so tell the tool-tip that
        // we do not want to have any caption
        //
        SendMessage(hwndToolTip, TTM_SETTITLE, 0, (LPARAM)NULL);
    }

End:
    return;
}


INT
ShowMainEntries(
    IN  HWND hdlg
    )
/*++
    
    ShowMainEntries

	Desc:	Loads the PDBENTRY elements for the system database

	Params:
        IN  HWND hdlg:  The main app window    

	Return:
        -1: Some other thread has called this function and is not done as yet
         0: There was some error
         1: Either we loaded it successfully or we already had the main entries loaded
        
    Warn:   No two threads should call this function at the same time
        
    Note:   We can call ShowMainEntries() from a thread in query database modeless 
            dialog box. When we are doing the query we disable the main dialog box. We still
            have protection using critical sections here.
            
            When we call ShowMainEntries() from the main window, then we will not be able
            to invoke the search or query dialog because the main thread will be busy and no 
            messages will be processed
--*/
{
    INT         iOk                     = 1;
    BOOL        bReturn                 = FALSE;
    PDATABASE   pOldPresentDatabase     = NULL;
    
    EnterCriticalSection(&s_csExpanding);
    
    if (g_bExpanding) {
        //
        // Some other thread is already trying to load the system database
        //
        LeaveCriticalSection(&s_csExpanding);

        return -1;

    } else {
        g_bExpanding = TRUE;
    }

    LeaveCriticalSection(&s_csExpanding);

    EnterCriticalSection(&g_critsectShowMain);

    if (g_bMainAppExpanded) {
        goto End;
    }

    pOldPresentDatabase = g_pPresentDataBase;

    bReturn = GetDatabaseEntries(NULL, &GlobalDataBase);

    //
    // GetDatabaseEntries will change the g_pPresentDataBase, so revert back
    //
    g_pPresentDataBase = pOldPresentDatabase;
    
    if (bReturn == FALSE) {

        MessageBox(hdlg, CSTRING(IDS_ERROROPEN), g_szAppName, MB_ICONERROR);
        iOk = 0;
        goto End;
    }

    //
    // Delete the dummy node
    //
    HTREEITEM hItemTemp = TreeView_GetChild(DBTree.m_hLibraryTree, 
                                            GlobalDataBase.hItemAllApps);

    if (hItemTemp) {
        TreeView_DeleteItem(DBTree.m_hLibraryTree, hItemTemp);
    }

    //
    // Load only the apps as the lib has already been loaded when the system started
    //
    DBTree.PopulateLibraryTree(GlobalDataBase.hItemAllApps, &GlobalDataBase, FALSE, TRUE);
    
    g_bMainAppExpanded = TRUE;
    SetCaption();

End:
    LeaveCriticalSection(&g_critsectShowMain);

    EnterCriticalSection(&s_csExpanding);
    g_bExpanding = FALSE;
    LeaveCriticalSection(&s_csExpanding);

    SetStatus(g_hwndStatus, CSTRING(IDS_MAINLOADED));

    if (g_hdlgSearchDB) {
        //
        // If somebody clicked on the search modeless window while we were loading the 
        // system db then the search window will show in its status message that we are loading the system db, we need 
        // to change the status message when we are done
        //
        SetStatus(GetDlgItem(g_hdlgSearchDB, IDC_STATUSBAR), GetString(IDS_SEARCHCOMPLETE));
    }

    return iOk;
}

void
DrawSplitter(
    IN  HWND hdlg
    )
/*++
    DrawSplitter
    
    Desc:   Draws the vertical. split bar. 
            We call this function when we are moving the mouse with the LBUTTON pressed
            and the mouse button was initially pressed on top of the split bar
             
            We also call this function when we need to position the 
            vert. split bar when we start up and have to position the split bar
            as it was during the last session
    
    Params: 
        IN  HWND hdlg: The main dialog box.
--*/
{   
    RECT        rectDBTree, rectEntryTree;
    PAINTSTRUCT ps;
    HDC         hDC;
    
    GetWindowRect(GetDlgItem(hdlg, IDC_LIBRARY), &rectDBTree);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&rectDBTree, 2);

    GetWindowRect(GetDlgItem(hdlg, IDC_ENTRY), &rectEntryTree);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&rectEntryTree, 2);

    hDC = BeginPaint(hdlg, &ps);

    RECT rectDraw, rectBar;

    if (!g_bDrag) {
        //
        // The mouse is not being dragged. We also call this function when we need to 
        // position the vert. split bar when we start up and have to position the split bar
        // as it was during the last session
        //
        rectBar.left   = rectDBTree.right + 1;
        rectBar.top    = rectDBTree.top;
        rectBar.right  = rectEntryTree.left - 1;
        rectBar.bottom = rectDBTree.bottom;
    
    } else {
        //
        // The mouse is being dragged
        //
        rectBar = g_rectBar;
    }
    
    //
    // Fill the entire with gray. This is required because otherwise we had
    // to draw a rectangle, and change the default pen before this.
    // This would have painted the inside with the default brush.
    //
    SetRect(&rectDraw, rectBar.left - 1, rectBar.top, rectBar.right + 1, rectBar.bottom);
    FillRect(hDC, &rectDraw, (HBRUSH)GetStockObject(GRAY_BRUSH));

    SetRect(&rectDraw, rectBar.left - 1, rectBar.top + 1, rectBar.left, rectBar.bottom - 1);
    FillRect(hDC, &rectDraw, (HBRUSH)(HBRUSH)GetStockObject(WHITE_BRUSH));
    
    SetRect(&rectDraw, rectBar.left, rectBar.top + 1, rectBar.right, rectBar.bottom - 1);
    FillRect(hDC, &rectDraw, (HBRUSH)(HBRUSH)GetStockObject(LTGRAY_BRUSH));

    EndPaint(hdlg, &ps);
}

BOOL
CloseAllDatabases(
    void
    )
/*++
    
    CloseAllDatabases
    
    Desc:   Closes all the working databases
    
    Return:
        TRUE:   All the databases were not closed
        FALSE:  All the databases were not closed, either because of some error
                Or the user selected cancel on the prompt for some unsaved database
--*/
{
    PDATABASE pDatabase = DataBaseList.pDataBaseHead;

    while (pDatabase) {

        HTREEITEM hItemDB = pDatabase->hItemDB;

        if (pDatabase->bChanged) {
            TreeView_SelectItem(DBTree.m_hLibraryTree, hItemDB);
        }

        if (!CloseDataBase(pDatabase)) {
            break;
        }
        
        //
        // The DataBaseList.pDataBaseHead now points to the  next database
        //
        pDatabase = DataBaseList.pDataBaseHead;
    }

    if (pDatabase != NULL) {
        //
        // Was Cancel pressed in between.
        //
        g_pPresentDataBase = pDatabase;
        TreeView_SelectItem(DBTree.m_hLibraryTree, pDatabase->hItemDB);
        return FALSE;
    }

    return TRUE;
}

INT_PTR 
CALLBACK 
HandleConflictEntry(
    IN  HWND    hdlg, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++
    HandleConflictEntry
    
    Desc:   The handler for the entry conflict dialog box
    
    Params: Standard dialog handler parameters
    
    IN  HWND   hDlg 
    IN  UINT   uMsg 
    IN  WPARAM wParam 
    IN  LPARAM lParam
        
    Return: Standard dialog handler return
--*/
{
    switch (uMsg) {
    case WM_INITDIALOG:
        
        CenterWindow(g_hDlg, hdlg);
        SetDlgItemText(hdlg, IDC_CONFLICT_MSG, (TCHAR*)lParam);
        break;
        

    case WM_COMMAND:

        switch (LOWORD (wParam)) {
            
        case IDNO:
        case IDCANCEL:
        case IDYES:

            EndDialog(hdlg, LOWORD (wParam));
            break;

        default: return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

TYPE
ConvertLparam2Type(
    IN  LPARAM lParam
    )
/*++
    
    ConvertLparam2Type
    
    Desc:   Converts the lParam to a TYPE
    
    Params:
        IN  LPARAM lParam: The lParam that has to be converted
            
    Return:   Converts the lParam to a TYPE
    
    Warn:   Do not use this routine for lParams of the entry tree. 
            The entry tree has attribute items whose lParams are the index in a bit array.
            So for them we see if the parent has type TYPE_MATCHIING_FILE and handle them 
            differently.
            
            For trees, GetItemType() instead.
--*/
{   
    if (lParam > TYPE_NULL) {

        PDS_TYPE pds = (PDS_TYPE)lParam;

        if (pds) {
            return (pds->type);
        } else {
            assert(FALSE);
        }   
    }

    return (TYPE)lParam;
}

TYPE
ConvertLpVoid2Type(
    IN  LPVOID lpVoid
    )
/*++
    
    ConvertLpVoid2Type
    
    Desc:   Converts the lpVoid to a TYPE
    
    Params:
        IN  LPVOID lpVoid: The lpVoid that has to be converted
            
    Return:   Converts the lpVoid to a TYPE
    
    Warn:   Do not use this routine for lParams of the entry tree. 
            The entry tree has attribute items whose lParams are the index in a bit array.
            So for them we see if the parent has type TYPE_MATCHIING_FILE and handle them 
            differently.
            
            For trees, use GetItemType() instead.
--*/
{
    if ((LPARAM)lpVoid > TYPE_NULL) {

        PDS_TYPE pds = (PDS_TYPE)lpVoid;

        if (pds) {
            return (pds->type);
        } else {
            assert(FALSE);
        }
    }

    return (TYPE)(LPARAM)lpVoid;
}


TYPE
GetItemType(
    IN  HWND        hwndTree,
    IN  HTREEITEM   hItem
    )
/*++
    Desc:   For the HTREEITEM hItem in tree view hwndTree, finds the data type of the item
            For the list of possible data types see CompatAdmin.h
            
    Params:
        IN  HWND        hwndTree: Handle to the tree view, should be one of
            g_hwndTree or DBTree.m_hLibraryTree
        
        IN  HTREEITEM   hItem: The HTREITEM whose type we need to find
        
    Notes:  The type can be either a GUI type or a data structure type or attribute type
            (If it is a child of a matching file, applicable only to entry tree[RHS])
            
            This routine should be the preferred method for getting the type of tree items,
            over Convert*2Type routines, which should be used for the list view items
--*/
{   
    TVITEM  Item;

    Item.mask   = TVIF_PARAM;
    Item.hItem  = hItem;

    if (!TreeView_GetItem(hwndTree, &Item)) {
        return TYPE_UNKNOWN;
    }

    HTREEITEM hItemParent = TreeView_GetParent(hwndTree, hItem);

    if (hItemParent != NULL) {

        if (GetItemType(hwndTree, hItemParent) == TYPE_MATCHING_FILE) {
            return TYPE_MATCHING_ATTRIBUTE;
        }
    }

    if (Item.lParam > TYPE_NULL) {

        PDS_TYPE pds = (PDS_TYPE)Item.lParam;

        if (pds) {
            return (pds->type);
        } else {
            assert(FALSE);
        }
    }

    return (TYPE)Item.lParam;
}

void
DoTheCutEntryTree(
    IN  PDATABASE       pDataBase,
    IN  TYPE            type,
    IN  SOURCE_TYPE     SourceType,  
    IN  LPVOID          lpData,
    IN  HTREEITEM       hItem,
    IN  BOOL            bDelete
    )
/*++
    
    DoTheCutEntryTree
    
    Desc:   This function does the cut part for the entry tree (LHS). 
            This routine is also called when we want to delete.
            
    Params:
        IN  PDATABASE       pDataBase:  The database where we are doing a cut/delete
        IN  TYPE            type:       The type of the element that has to be deleted
        IN  SOURCE_TYPE     SourceType: Where the cut/delete was performed. Always: ENTRY_TREE
        IN  LPVOID          lpData:     The pointer to the element that has to be deleted
        IN  HTREEITEM       hItem:      The tree item, if there is some          
        IN  BOOL            bDelete:    Is this because of a delete or a cut. True if delete
    
    Note:   If we have done a cut and attempt to do the paste on the same database, 
            the ID_EDIT_PASTE handler returns before doing any paste.
            Also then this function WILL NOT get called.
            
            *********************
                Important 
            *********************
            As of now only Entries can be cut from the entry tree, 
            individual shims, layers, apphelp etc.
            of entries cannot be cut. So if the type is anything other than TYPE_ENTRY
            then we should have the focus on the entry tree and the operation should be 
            a delete and NOT a cut
            
            We use g_pSelEntry here when we remove the shims, layers, matching files etc. 
            This is based on the assumption that for non-entries we have the focus on a a 
            item under g_pSelEntry
--*/
{
    HWND    hwndFocus       = GetFocus();
    LPARAM  LPARAMFirstFix  = NULL;

    if (bDelete == FALSE && type != TYPE_ENTRY) {
        //
        // For entry tree only entries can be cut, others can be deleted but not cut. 
        //
        assert(FALSE);
        Dbg(dlError, "[DoTheCutEntryTree]: Trying to cut a non-entry item in the entry tree");
        return;
    }

    switch(type) {
    case TYPE_ENTRY:
        {
            PDBENTRY pApp = NULL;
            //
            // Get the app for this entry.
            //
            pApp = GetAppForEntry(pDataBase, (PDBENTRY)lpData);

            if (pApp) {
                RemoveEntry(pDataBase, (PDBENTRY)lpData, pApp, bDelete);
            }
            
            break;
        }   

    case TYPE_APPHELP_ENTRY:
        {
            if (g_pSelEntry == NULL) {
                assert(FALSE);
                break;
            }

            //
            // If the entry has only apphelp and we are deleting the 
            // apphelp the entry has to be deleted
            //
            if (g_pSelEntry->pFirstFlag  
                || g_pSelEntry->pFirstLayer 
                || g_pSelEntry->pFirstPatch 
                || g_pSelEntry->pFirstShim) {
                //
                // The entry has some other stuff besides apphelp
                //
                TreeView_DeleteItem(g_hwndEntryTree, hItem);

                if (DeleteAppHelp(pDataBase, g_pSelEntry->appHelp.HTMLHELPID)) {
                    g_pSelEntry->appHelp.bPresent   = FALSE;
                    g_pSelEntry->appHelp.bBlock     = FALSE;
                    g_pSelEntry->appHelp.severity   = APPTYPE_NONE;
                } else {
                    assert(FALSE);
                }

            } else {
                //
                // Prompt the user, want to delete the entry ?
                //
                int nResult = MessageBox(g_hDlg,
                                         GetString(IDS_DELETE_VERIFY),
                                         g_szAppName,
                                         MB_YESNO | MB_ICONQUESTION);

                if (nResult == IDYES) {

                    DoTheCutEntryTree(pDataBase,
                                      TYPE_ENTRY,
                                      SourceType,
                                      g_pSelEntry,
                                      g_pSelEntry->hItemExe, 
                                      bDelete);
                }
            }
        }

        break;

    case TYPE_MATCHING_FILE:
        {
            if (!g_pSelEntry) {
                assert(FALSE);
                break;
            }
            
            PMATCHINGFILE pMatch = (PMATCHINGFILE)lpData;

            if (!pMatch) {
                assert(FALSE);
                break;
            }

            if (pMatch->strMatchName == TEXT("*")) {
                //
                // Main file must not be deleted
                //
                MessageBox(g_hDlg, 
                           GetString(IDS_REQUIREDFORMATCHING), 
                           g_szAppName,
                           MB_ICONWARNING);

            } else {

                DeleteMatchingFile(&g_pSelEntry->pFirstMatchingFile,
                                   pMatch,
                                   g_hwndEntryTree,
                                   hItem);
            }
        }
        
        break;

    case TYPE_MATCHING_ATTRIBUTE:
        {
            HTREEITEM   hItemParent = TreeView_GetParent(g_hwndEntryTree, hItem);
            LPARAM      lParam;

            if (hItemParent == NULL) {
                assert(FALSE);
                break;
            }

            if (!DBTree.GetLParam(hItemParent, &lParam)) {
                break;
            }

            PMATCHINGFILE pMatch = PMATCHINGFILE(lParam);

            if (!pMatch) {
                assert(FALSE);
                break;
            }

            //
            // Set off the bit for this attribute in the mask, so we know that
            // this is no longer in use
            // The lParam of the attributes items which are sub-items of the matching file tree
            // item contain the type of the attribute
            // The mask for a matching file specifies which attributes of this matching file
            // are in use
            // the lParam of the attributes is : TYPE_NULL + 1 + (1 << (dwPos + 1));
            // where dwPos is the index of the attribute in the attribute array: g_Attributes
            // which is defined in dbsupport.cpp
            //
            pMatch->dwMask &= ~ ((ULONG_PTR)lpData - (TYPE_NULL + 1));

            TreeView_DeleteItem(g_hwndEntryTree, hItem);
        }

        break;

    case TYPE_GUI_MATCHING_FILES:

        MessageBeep(MB_ICONEXCLAMATION);
        break;

    case FIX_LAYER:
        {
            if (!g_pSelEntry) {
                assert(FALSE);
                break;
            }
            
            PLAYER_FIX plfTobeRemoved = (PLAYER_FIX)lpData;

            if (g_pSelEntry->pFirstLayer == NULL || plfTobeRemoved == NULL) {
                assert(FALSE);
                break;
            }

            if (g_pSelEntry->pFirstLayer->pNext) {
                //
                // We have more than one layer
                //
                PLAYER_FIX_LIST plflTemp = g_pSelEntry->pFirstLayer, plflPrev = NULL;

                while (plflTemp) {

                    if (plflTemp->pLayerFix == plfTobeRemoved) {
                        break;
                    }

                    plflPrev = plflTemp;
                    plflTemp = plflTemp->pNext;
                }

                if (plflTemp) {

                    TreeView_DeleteItem(g_hwndEntryTree, hItem);

                    if (plflPrev == NULL) {
                        g_pSelEntry->pFirstLayer = plflTemp->pNext;
                    } else {
                        plflPrev->pNext = plflTemp->pNext;
                    }
    
                    delete plflTemp;
                    plflTemp = NULL;
                }

            } else {
                //
                // Same as if we are trying to remove the root of the layers
                //
                DoTheCutEntryTree(pDataBase,
                                  TYPE_GUI_LAYERS,
                                  SourceType,
                                  NULL,
                                  TreeView_GetParent(g_hwndEntryTree, hItem),
                                  bDelete);
            }
        }

        break;

    case FIX_SHIM:
        {
            if (!g_pSelEntry) {
                assert(FALSE);
                break;
            }

            PSHIM_FIX psfTobeRemoved = (PSHIM_FIX)lpData;

            if (g_pSelEntry->pFirstShim == NULL || psfTobeRemoved == NULL) {
                assert(FALSE);
                break;
            }

            if (g_pSelEntry->pFirstShim->pNext || g_pSelEntry->pFirstFlag) {
                //
                // We have more than one item under the "Compatibility Fixes" tree item
                //
                PSHIM_FIX_LIST psflTemp = g_pSelEntry->pFirstShim, psflPrev = NULL;

                while (psflTemp) {

                    if (psflTemp->pShimFix == psfTobeRemoved) {
                        break;
                    }

                    psflPrev = psflTemp;
                    psflTemp = psflTemp->pNext;
                }

                if (psflTemp) {

                    TreeView_DeleteItem(g_hwndEntryTree, hItem);

                    if (psflPrev == NULL) {
                        g_pSelEntry->pFirstShim = psflTemp->pNext;
                    } else {
                        psflPrev->pNext = psflTemp->pNext;
                    }

                    delete psflTemp;
                }   

            } else {
                //
                // Same as we are trying to remove the root of the shims
                //
                DoTheCutEntryTree(pDataBase,
                                  TYPE_GUI_SHIMS,
                                  SourceType,
                                  NULL,
                                  TreeView_GetParent(g_hwndEntryTree, hItem),
                                  bDelete);
            }
        }

        break;

    case FIX_FLAG:
        {
            if (!g_pSelEntry) {
                assert(FALSE);
                break;
            }

            PFLAG_FIX pffTobeRemoved = (PFLAG_FIX)lpData;

            if (g_pSelEntry->pFirstFlag == NULL || pffTobeRemoved == NULL) {
                assert(FALSE);
                break;
            }
            
            if (g_pSelEntry->pFirstFlag->pNext || g_pSelEntry->pFirstShim) {
                //
                // We have more than one item under the "Compatibility Fixes" tree item
                //
                PFLAG_FIX_LIST pfflTemp = g_pSelEntry->pFirstFlag, pfflPrev = NULL;

                while (pfflTemp) {

                    if (pfflTemp->pFlagFix == pffTobeRemoved) {
                        break;
                    }

                    pfflPrev = pfflTemp;
                    pfflTemp = pfflTemp->pNext;
                }

                if (pfflTemp) {

                    TreeView_DeleteItem(g_hwndEntryTree, hItem);

                    if (pfflPrev == NULL) {
                        g_pSelEntry->pFirstFlag = pfflTemp->pNext;
                    } else {
                        pfflPrev->pNext = pfflTemp->pNext;
                    }
    
                    delete pfflTemp;
                }

            } else {
                //
                // Same as we are trying to remove the root of the flags
                //
                DoTheCutEntryTree(pDataBase,
                                  TYPE_GUI_SHIMS,
                                  SourceType,
                                  NULL,
                                  TreeView_GetParent(g_hwndEntryTree, hItem),
                                  bDelete);
            }
        }

        break;

    case FIX_PATCH:
        {
            if (!g_pSelEntry) {
                assert(FALSE);
                break;
            }

            PPATCH_FIX pPatchTobeRemoved = (PPATCH_FIX)lpData;

            if (g_pSelEntry->pFirstPatch == NULL || pPatchTobeRemoved == NULL) {
                assert(FALSE);
                break;
            }

            if (g_pSelEntry->pFirstPatch->pNext || g_pSelEntry->pFirstShim) {

                PPATCH_FIX_LIST pPatchTemp = g_pSelEntry->pFirstPatch, pPatchflPrev = NULL;

                while (pPatchTemp) {

                    pPatchflPrev = pPatchTemp;

                    if (pPatchTemp->pPatchFix == pPatchTobeRemoved) {
                        break;
                    }
                    
                    pPatchTemp = pPatchTemp->pNext;
                }

                if (pPatchTemp) {

                    TreeView_DeleteItem(g_hwndEntryTree, hItem);

                    if (pPatchflPrev == NULL) {
                        g_pSelEntry->pFirstPatch = pPatchTemp->pNext;
                    } else {
                        pPatchflPrev->pNext = pPatchTemp->pNext;
                    }
    
                    delete pPatchTemp;
                }

            } else {
                //
                // Same as we are trying to remove the root of the patches
                //
                DoTheCutEntryTree(pDataBase,
                                  TYPE_GUI_PATCHES,
                                  SourceType,
                                  NULL,
                                  TreeView_GetParent(g_hwndEntryTree, hItem),
                                  bDelete);
            }
        }
        
        break;
        
    case TYPE_GUI_LAYERS:
        {
            if (!g_pSelEntry) {
                assert(FALSE);
                break;
            }

            //
            // If the entry has only layers and we are deleting it the 
            // entry has to be deleted
            //
            if (g_pSelEntry->pFirstFlag       
                || g_pSelEntry->pFirstPatch      
                || g_pSelEntry->appHelp.bPresent 
                || g_pSelEntry->pFirstShim) {
                
                TreeView_DeleteItem(g_hwndEntryTree, hItem);

                DeleteLayerFixList(g_pSelEntry->pFirstLayer);
                g_pSelEntry->pFirstLayer = NULL;

            } else {
                //
                // Prompt the user, want to delete the entry ?
                //
                int nResult = MessageBox(g_hDlg, 
                                         GetString(IDS_DELETE_VERIFY), 
                                         g_szAppName, 
                                         MB_YESNO | MB_ICONQUESTION);

                if (nResult == IDYES) {

                    DoTheCutEntryTree(pDataBase,
                                      TYPE_ENTRY,
                                      SourceType,
                                      g_pSelEntry,
                                      g_pSelEntry->hItemExe, 
                                      bDelete);
                }
            }
        }
        
        break;

    case TYPE_GUI_PATCHES:
        {
            if (!g_pSelEntry) {
                assert(FALSE);
                break;
            }

            //
            // If the entry has only patches and we are deleting it  the entry has 
            // to be deleted
            //
            if (g_pSelEntry->pFirstFlag       
                || g_pSelEntry->appHelp.bPresent 
                || g_pSelEntry->pFirstLayer      
                || g_pSelEntry->pFirstShim) {
                
                TreeView_DeleteItem(g_hwndEntryTree, hItem);

                DeletePatchFixList(g_pSelEntry->pFirstPatch);
                g_pSelEntry->pFirstPatch = NULL;

            } else {
                
                //
                // Prompt the user, want to delete the entry ?
                //
                int nResult = MessageBox(g_hDlg, 
                                         GetString(IDS_DELETE_VERIFY), 
                                         g_szAppName, 
                                         MB_YESNO | MB_ICONQUESTION);

                if (nResult == IDYES) {

                    DoTheCutEntryTree(pDataBase,
                                      TYPE_ENTRY,
                                      SourceType,
                                      g_pSelEntry,
                                      g_pSelEntry->hItemExe, 
                                      bDelete);
                }
            }
        }
        
        break;

    case TYPE_GUI_SHIMS:
        {
            
            if (!g_pSelEntry) {
                assert(FALSE);
                break;
            }

            //
            // If the entry has only shims & flags and we are deleting it the entry 
            // has to be deleted
            //
            if (g_pSelEntry->pFirstPatch
                || g_pSelEntry->appHelp.bPresent
                || g_pSelEntry->pFirstLayer) {
                
                TreeView_DeleteItem(g_hwndEntryTree, hItem);

                DeleteShimFixList(g_pSelEntry->pFirstShim);
                g_pSelEntry->pFirstShim = NULL;

                DeleteFlagFixList(g_pSelEntry->pFirstFlag);
                g_pSelEntry->pFirstFlag = NULL;

            } else {
                //
                // Prompt the user, want to delete the entry ?
                //
                int nResult = MessageBox(g_hDlg, 
                                         GetString(IDS_DELETE_VERIFY), 
                                         g_szAppName, 
                                         MB_YESNO | MB_ICONQUESTION);

                if (nResult == IDYES) {

                    DoTheCutEntryTree(pDataBase,
                                      TYPE_ENTRY,
                                      SourceType,
                                      g_pSelEntry,
                                      g_pSelEntry->hItemExe, 
                                      bDelete);
                }
            }
        }

        break;
    }
}

void
DoTheCut(
    IN  PDATABASE       pDataBase,
    IN  TYPE            type,
    IN  SOURCE_TYPE     SourceType,  
    IN  LPVOID          lpData, // To be removed       
    IN  HTREEITEM       hItem,
    IN  BOOL            bDelete
    )
/*++
    
    DoTheCut
    
    Desc:   This function does the cut part. This routine is also called when we want 
            to delete.
            
    Params:
        IN  PDATABASE       pDataBase   : The database where we are doing a cut/delete
        IN  TYPE            type        : The type of the element that has to be deleted
        IN  SOURCE_TYPE     SourceType  : Where the cut/delete was performed. One of:
                a) ENTRY_TREE
                b) ENTRY_LIST
                c) LIB_TREE
                
        IN  LPVOID          lpData:     The pointer to the element that has to be deleted
        IN  HTREEITEM       hItem:      The tree item, if there is some          
        IN  BOOL            bDelete:    If this is true that means that this routine has been 
            called because of a delete operation. Deletion is a bit different than cut because 
            when we delete then we might need to repaint the UI. When doing a cut, the actual 
            cut is done only after paste has been successful. In that case the newly pasted 
            item is shown in the UI and we should not try to update the UI.
    
    Note:   If we have done a cut and attempt to do the paste on the same database, 
            the ID_EDIT_PASTE handler returns before doing any paste.
            Also then this function WILL NOT get called.
--*/
{
    INT     iIndex  = -1;
    HWND    hwndFocus;

    hwndFocus = GetFocus();

    if (SourceType == ENTRY_TREE) {

        DoTheCutEntryTree(pDataBase,
                          type,     
                          SourceType,
                          lpData,
                          hItem,    
                          bDelete);
        return;
    }

    switch (type) {
    case TYPE_ENTRY:
        
        if (SourceType == LIB_TREE || SourceType == ENTRY_LIST) {
            //
            // Must delete the tree item before actually removing the 
            // entry using RemoveApp/RemoveEntry
            //
            if (bDelete) {
                TreeDeleteAll(g_hwndEntryTree);
                g_pEntrySelApp = g_pSelEntry = NULL;
            }

            if (SourceType == ENTRY_LIST && bDelete) {
                iIndex = GetContentsListIndex(g_hwndContentsList, (LPARAM)lpData);

                if (iIndex > -1) {
                    ListView_DeleteItem(g_hwndContentsList, iIndex);
                }
            }

            DBTree.DeleteAppLayer(pDataBase, TRUE, hItem, bDelete);

            RemoveApp(pDataBase, (PDBENTRY)lpData);

            if (bDelete && pDataBase->hItemAllApps) {
                //
                // Show that we now have one less entry/app
                //
                SetStatusStringDBTree(pDataBase->hItemAllApps);
            }
        }

        break;
        
    case TYPE_GUI_APPS:
        
        TreeView_DeleteItem(DBTree.m_hLibraryTree, pDataBase->hItemAllApps);
        RemoveAllApps(pDataBase);
        pDataBase->hItemAllApps = NULL;

        break;
        
    case FIX_LAYER:
        
        if (RemoveLayer(pDataBase, (PLAYER_FIX)lpData, NULL)) {
            //
            // This function will return FALSE, if the layer in in use
            //
            if (SourceType == ENTRY_LIST && bDelete && type == FIX_LAYER) {
                iIndex = GetContentsListIndex(g_hwndContentsList, (LPARAM)lpData);

                if (iIndex > -1) {
                    ListView_DeleteItem(g_hwndContentsList, iIndex);
                }
            }

            DBTree.DeleteAppLayer(pDataBase, FALSE, hItem, bDelete);

            //
            // Show that we now  have one less layer
            //
            if (bDelete && pDataBase->hItemAllLayers) {
                SetStatusStringDBTree(pDataBase->hItemAllLayers);
            }
        }
        
        break;

    case TYPE_GUI_LAYERS:
        {
            BOOL fAllDeleted = TRUE;

            while (pDataBase->pLayerFixes && fAllDeleted) {

                fAllDeleted = fAllDeleted && RemoveLayer(pDataBase, 
                                                         pDataBase->pLayerFixes,
                                                         NULL);
            }

            if (fAllDeleted) {
                TreeView_DeleteItem(DBTree.m_hLibraryTree, pDataBase->hItemAllLayers);
                pDataBase->hItemAllLayers = NULL;
            }
        }

        break;
    }
}

LRESULT 
CALLBACK 
ListViewProc(
    IN  HWND    hWnd, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++
    ListViewProc

	Desc:	Subclasses the message proc for the contents list view (RHS)    
	
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard handler return
    
--*/
{   
    switch (uMsg) {
    case WM_SETFOCUS:
        {
            LVITEM  lvi;

            ZeroMemory(&lvi, sizeof(lvi));

            lvi.mask        = LVIF_PARAM;
            lvi.iItem       = g_iContentsListSelectIndex;
            lvi.iSubItem    = 0;

            if (ListView_GetItem(hWnd, &lvi)) {

                HTREEITEM   hItemInDBTree = NULL;

                hItemInDBTree = DBTree.FindChild(TreeView_GetSelection(DBTree.m_hLibraryTree),
                                                 lvi.lParam);

                SetStatusStringDBTree(hItemInDBTree);
            }
        }

        break;
    }

    return CallWindowProc(g_PrevListProc, hWnd, uMsg, wParam, lParam);
}

LRESULT 
CALLBACK 
TreeViewProc(
    HWND    hWnd, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    )

/*++
    TreeViewProc

	Desc:	Subclasses the message proc for both the tree views
	
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard handler return
    
--*/

{
    switch (uMsg) 
    case WM_SETFOCUS:
        {
            HTREEITEM hItem= TreeView_GetSelection(hWnd);
    
            if (hItem) {
    
                if (hWnd && hWnd == DBTree.m_hLibraryTree) {
                     SetStatusStringDBTree(hItem);  
                } else if (hWnd && hWnd == g_hwndEntryTree) {
                     SetStatusStringEntryTree(hItem);
                }
            }

            break;
        }
    
    return CallWindowProc(g_PrevTreeProc, hWnd, uMsg, wParam, lParam);
}

void
PopulateContentsList(
    IN  HTREEITEM hItem
    )
/*++

    PopulateContentsList

	Desc:	Populates the contents list with the children of hItem in the DB Tree
            At the moment we show the items in the contents list only if the type of 
            hItem is of:
            
                TYPE_GUI_APPS     
                TYPE_GUI_LAYERS 
                TYPE_GUI_SHIMS 
                FIX_LAYER
                
	Params:
        IN  HTREEITEM hItem:    A tree item in the db tree.    

	Return:
        void
        
    Notes:  This routine will not/should not be called when the user has selected a
            an app in the Lib Tree.
--*/
{   
    TCHAR   szBuffer[512];
    TYPE    type = (TYPE)GetItemType(DBTree.m_hLibraryTree, hItem);
    TVITEM  Item;
    UINT    uIndex = 0;
    LVITEM  lvi;

    if (type == TYPE_GUI_APPS 
        || type == TYPE_GUI_LAYERS 
        || type == TYPE_GUI_SHIMS 
        || type == FIX_LAYER) {

        ShowWindow(g_hwndEntryTree, SW_HIDE);

        TreeDeleteAll(g_hwndEntryTree);

        g_bIsContentListVisible = TRUE;
        
        ListView_DeleteAllItems(g_hwndContentsList);

        //
        // ASSUMPTION:  We are assuming (this is correct at the moment), that we 
        //              have only one column in the list view
        //
        ListView_DeleteColumn(g_hwndContentsList, 0);
        
        ShowWindow(g_hwndContentsList, SW_SHOW);
        SendMessage(g_hwndContentsList, WM_SETREDRAW, TRUE, 0);

        *szBuffer       = 0;

        Item.mask        = TVIF_TEXT;
        Item.hItem       = hItem;
        Item.pszText     = szBuffer;
        Item.cchTextMax  = ARRAYSIZE(szBuffer);

        if (!TreeView_GetItem(DBTree.m_hLibraryTree, &Item)) {
            assert(FALSE);
            goto End;
        }
        
        //
        // Set the column text as the text of the item in the tree view
        //
        InsertColumnIntoListView(g_hwndContentsList, szBuffer, 0, 100);

        //
        // Add all the children of the selected item in the tree view
        //
        hItem = TreeView_GetChild(DBTree.m_hLibraryTree, hItem);

        Item.mask       = TVIF_PARAM | TVIF_IMAGE | TVIF_TEXT;
        Item.pszText    = szBuffer;
        Item.cchTextMax = ARRAYSIZE(szBuffer);

        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;

        while (hItem) {
            
            *szBuffer = 0;
            Item.hItem = hItem;

            if (!TreeView_GetItem(DBTree.m_hLibraryTree, &Item)) {
                assert(FALSE);
                return;
            }

            lvi.pszText   = Item.pszText;
            lvi.iSubItem  = 0;
            lvi.lParam    = Item.lParam;
            lvi.iImage    = Item.iImage;
            lvi.iItem     = uIndex;

            ListView_InsertItem(g_hwndContentsList, &lvi);

            UpdateWindow(g_hwndContentsList);

            uIndex++;
            hItem = TreeView_GetNextSibling(DBTree.m_hLibraryTree, hItem);
        }

        //
        // Set the selection mark for the first element.
        //
        ListView_SetSelectionMark(g_hwndContentsList, 0);
        ListView_SetItemState(g_hwndContentsList, 
                              0, 
                              LVIS_FOCUSED | LVIS_SELECTED , 
                              LVIS_FOCUSED | LVIS_SELECTED);

        //
        // Set the column width of the list view appropriately to cover the width of the 
        // list view
        // Assumption:  The list view has only one column
        //
        ListView_SetColumnWidth(g_hwndContentsList, 0, LVSCW_AUTOSIZE_USEHEADER);

    } else {
        //
        // Clear the contents pane. This is the only way.
        //
        TreeDeleteAll(g_hwndEntryTree);
        g_pSelEntry = g_pEntrySelApp = NULL;

        ShowWindow(g_hwndContentsList, SW_HIDE);

        g_bIsContentListVisible = FALSE;

        ShowWindow(g_hwndEntryTree, SW_SHOW);
    }

End:
    return;
}

void
LoadPerUserSettings(
    void
    )
/*++

    LoadPerUserSettings

	Desc:	Loads the list of per-user settings

	Params:
        void

	Return:
        void
--*/
{
    WCHAR           szwName[1024];
    TCHAR           szUserName[256], szDomainName[256];
    TCHAR           szValueName[MAX_PATH];
    HKEY            hKey            = NULL;
    PSID            pSid            = NULL;
    DWORD           dwIndex         = 0;
    LPTSTR          pszData         = NULL;
    DWORD           dwIndexValue    = 0;
    INT             iLength         = 0;
    SID_NAME_USE    sid_type;
    TVINSERTSTRUCT  is;
    
    
    *szwName = 0;
    
    SendMessage(DBTree.m_hLibraryTree, WM_SETREDRAW, FALSE, 0);

    //
    // Remove the tree item for per-user settings if it exists. We 
    // repopulate the entire list.
    //
    if (DBTree.m_hPerUserHead) {
        TreeView_DeleteItem(DBTree.m_hLibraryTree, DBTree.m_hPerUserHead);
        DBTree.m_hPerUserHead = NULL;
    }
    

    DWORD dwchSizeSubKeyName = sizeof(szwName)/sizeof(WCHAR);

    //
    // Enumerate the sub-keys under HKEY_USERS. 
    //
    while (ERROR_SUCCESS == RegEnumKey(HKEY_USERS,
                                       dwIndex,
                                       szwName,
                                       dwchSizeSubKeyName)) {
        dwIndex++;
        
        pSid = NULL;

        if (!ConvertStringSidToSid(szwName, &pSid)) {

            if (pSid) {
                LocalFree(pSid);
                pSid = NULL;
            }
            
            continue;
        }

        DWORD dwchSizeofUserName = ARRAYSIZE(szUserName);
        DWORD dwchSizeDomainName = ARRAYSIZE(szDomainName);

        *szUserName = *szDomainName = 0;

        if (!LookupAccountSid(NULL,
                              pSid,
                              szUserName,
                              &dwchSizeofUserName,
                              szDomainName,
                              &dwchSizeDomainName,
                              &sid_type)) {
        
            if (pSid) {
                LocalFree(pSid);
                pSid = NULL;
            }
            
            continue;
        }

        if (sid_type != SidTypeUser) {

            if (pSid) {
                LocalFree(pSid);
                pSid = NULL;
            }

            continue;
        }

        if (pSid) {
            LocalFree(pSid);
            pSid = NULL;
        }

        iLength = lstrlen(szwName);
        
        SafeCpyN(szwName + iLength, APPCOMPAT_PERM_LAYER_PATH, ARRAYSIZE(szwName) - iLength);
        
        if (RegOpenKeyEx(HKEY_USERS, szwName, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
            //
            // enumerate the values
            //
            *szValueName = 0;

            DWORD       dwchSizeofValueName;
            DWORD       dwSizeofData;
            DWORD       dwType = REG_SZ;  
            LONG        lReturn;
            HTREEITEM   hItemSingleUser = NULL, hItemApp = NULL;

            while (TRUE) {

                dwchSizeofValueName = ARRAYSIZE(szValueName);
                dwSizeofData        = 512; 
                dwType              = REG_SZ;

                pszData = new TCHAR[dwSizeofData / sizeof(TCHAR)];
                
                if (pszData == NULL) {
                   MEM_ERR;
                   break;
                }
                
                lReturn = RegEnumValue(hKey,
                                       dwIndexValue,
                                       szValueName,
                                       &dwchSizeofValueName,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)pszData,
                                       &dwSizeofData);

                if (lReturn == ERROR_NO_MORE_ITEMS) {
                    break;
                }

                if (lReturn != ERROR_SUCCESS || dwType != REG_SZ) {
                    assert(FALSE);
                    break;
                }
                
                if (DBTree.m_hPerUserHead == NULL) {
                    //
                    // Make the first node.
                    //
                    is.hParent             = TVI_ROOT;
                    is.hInsertAfter        = (DBTree.m_hItemAllInstalled) ? DBTree.m_hItemAllInstalled : DBTree.m_hItemGlobal;

                    is.item.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
                    is.item.stateMask      = TVIS_EXPANDED;
                    is.item.pszText        = GetString(IDS_PERUSER);
                    is.item.iImage         = IMAGE_ALLUSERS;
                    is.item.iSelectedImage = IMAGE_ALLUSERS;

                    DBTree.m_hPerUserHead = TreeView_InsertItem(DBTree.m_hLibraryTree, &is);
                }

                if (dwIndexValue == 0) {
                    //
                    // First app, we have to create the user icon as well
                    //
                    is.hParent             = DBTree.m_hPerUserHead;
                    is.hInsertAfter        = TVI_SORT;
                    is.item.pszText        = szUserName;
                    is.item.iImage         = IMAGE_SINGLEUSER;
                    is.item.iSelectedImage = IMAGE_SINGLEUSER;

                    hItemSingleUser = TreeView_InsertItem(DBTree.m_hLibraryTree, &is);
                }
                
                //
                // Now add the app for the user.
                //
                is.hInsertAfter        = TVI_SORT;
                is.hParent             = hItemSingleUser;
                is.item.pszText        = szValueName;
                is.item.iImage         = IMAGE_SINGLEAPP;
                is.item.iSelectedImage = IMAGE_SINGLEAPP;
                hItemApp               = TreeView_InsertItem(DBTree.m_hLibraryTree, &is);
                
                //
                // Now we have to add all the layers for this app.
                //
                is.hParent             = hItemApp;
                is.item.iImage         = IMAGE_LAYERS;
                is.item.iSelectedImage = IMAGE_LAYERS;
                
                LPCTSTR pszLayerName = NULL;
                
                //
                // Get the individual mode names that have been applied to the app (BO)
                //
                pszLayerName = _tcstok(pszData, TEXT(" "));

                while (pszLayerName) {
                 
                    PLAYER_FIX plf = (PLAYER_FIX)FindFix(pszLayerName,
                                                         FIX_LAYER,
                                                         &GlobalDataBase);

                    if (plf) {

                        is.item.pszText = plf->strName.pszString;
                        TreeView_InsertItem(DBTree.m_hLibraryTree, &is);
                    }

                    pszLayerName = _tcstok(NULL, TEXT(" "));
                }
                
                ++dwIndexValue;

                if (pszData) {
                    delete[] pszData;
                    pszData = NULL;
                }
            }
            
            REGCLOSEKEY(hKey);

            //
            // We might come here if we had some error and we break off the while loop
            //
            if (pszData) {
                delete[] pszData;
                pszData = NULL;
            }
        }
    }

    SendMessage(DBTree.m_hLibraryTree, WM_SETREDRAW, TRUE, 0);

    return;
}


INT_PTR 
CALLBACK
MsgBoxDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++
    MsgBoxDlgProc

    Desc:   Displays a message box dialog so we can use the hyperlink.
    
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
--*/
{
    int wCode       = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            TCHAR   szLink[MAX_PATH];
            UINT    uNoSDB;
    
            uNoSDB = (UINT)lParam;
            //
            // Use the parameter to determine what text to display.
            //
            if (uNoSDB) {
    
                LoadString(g_hInstance, IDS_W2K_NO_SDB, szLink, ARRAYSIZE(szLink));
                SetDlgItemText(hdlg, IDC_MESSAGE, szLink);
    
            } else {
                LoadString(g_hInstance, IDS_SP2_SDB, szLink, ARRAYSIZE(szLink));
                SetDlgItemText(hdlg, IDC_MESSAGE, szLink);
            }
    
            LoadString(g_hInstance, IDS_MSG_LINK, szLink, ARRAYSIZE(szLink));
            SetDlgItemText(hdlg, IDC_MSG_LINK, szLink);
    
            ShowWindow(hdlg, SW_SHOWNORMAL);
            break;
        }   

    case WM_NOTIFY:
        {
            NMHDR* pHdr = (NMHDR*)lParam;

            if (pHdr->idFrom == IDC_MSG_LINK) {

                if (pHdr->code == NM_CLICK || pHdr->code == NM_RETURN) {
                    
                    SHELLEXECUTEINFO sei = { 0 };
                    
                    sei.cbSize = sizeof(SHELLEXECUTEINFO);
                    sei.fMask  = SEE_MASK_DOENVSUBST;
                    sei.hwnd   = hdlg;
                    sei.nShow  = SW_SHOWNORMAL;
                    sei.lpFile = g_szW2KUrl;
    
                    ShellExecuteEx(&sei);
                }
            }

            break;
        }
    
    case WM_COMMAND:

        switch (wCode) {
        case IDCANCEL:

            EndDialog(hdlg, FALSE);
            break;

        case ID_UPDATE:
            {
                SHELLEXECUTEINFO sei = { 0 };
                
                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.fMask  = SEE_MASK_DOENVSUBST;
                sei.hwnd   = NULL;
                sei.nShow  = SW_SHOWNORMAL;
                sei.lpFile = g_szW2KUrl;

                ShellExecuteEx(&sei);

                EndDialog(hdlg, TRUE);
            }

            break;
        
        default:
            return FALSE;
        }

        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
CheckProperSP(
    void
    )
/*++

    CheckProperSP

    Returns:
        TRUE:   If the service pack is more than two
        FALSE:  Otherwise
--*/
{
    if (g_fSPGreaterThan2) {
        return TRUE;
    }

    return FALSE;
}

void
CopyToClipBoard(
    IN  WPARAM wCode
    )
/*++
    
    CopyToClipBoard
    
    Desc:   Copies data into our Clipboard data structure. (Not the windows clipboard)
    
    Params:
        IN WPARAMS wCode: 
            One of:
                ID_EDIT_CUT:    This is a cut
                ID_EDIT_COPY:   This is a copy
--*/
{
    TCHAR       szBuffer[256];
    TYPE        type;          
    HGLOBAL     hGlobal     = NULL;
    HWND        hwndFocus   = GetFocus();
    LPARAM      lParam      = NULL;  
    TCHAR*      pszGlobal   = NULL;
    CopyStruct* pCopyTemp   = NULL;
    HTREEITEM   hItem;
    TVITEM      Item;
    SIZE_T      chBuffersize;

    *szBuffer = 0;

    gClipBoard.RemoveAll();

    g_bIsCut = (wCode == ID_EDIT_CUT);
    gClipBoard.pDataBase = g_pPresentDataBase;

    if (hwndFocus == g_hwndEntryTree || hwndFocus == DBTree.m_hLibraryTree) {

        //
        // Copy/Cut is on some tree.
        //
        pCopyTemp= new CopyStruct;

        if (pCopyTemp == NULL) {
            MEM_ERR;
            goto End;
        }

        hItem = TreeView_GetSelection(hwndFocus);

        Item.mask       = TVIF_PARAM | TVIF_TEXT;
        Item.pszText    = szBuffer;
        Item.cchTextMax = ARRAYSIZE(szBuffer);
        Item.hItem      = hItem;

        if (!TreeView_GetItem(hwndFocus, &Item) || Item.lParam == NULL) {
            assert(FALSE);

            if (pCopyTemp) {
                delete pCopyTemp;
                pCopyTemp = NULL;
            }

            goto End;
        }

        lParam = Item.lParam;

        //
        // Copy text to Windows clipboard
        //
        chBuffersize = ARRAYSIZE(szBuffer);

        hGlobal = GlobalAlloc(GHND | GMEM_SHARE, chBuffersize * sizeof(TCHAR));

        if (hGlobal) {
            pszGlobal = (TCHAR*)GlobalLock(hGlobal);
            SafeCpyN(pszGlobal, szBuffer, chBuffersize);
        }

        GlobalUnlock(hGlobal);

        if (OpenClipboard(g_hDlg)) {

            EmptyClipboard();
            SetClipboardData(CF_UNICODETEXT, hGlobal);
            CloseClipboard();
        }

        //
        // Now copy the data to our own clipboard, which is nothing but a linked list
        //
        type = GetItemType(hwndFocus, hItem);
        
        gClipBoard.type = type;

        //
        // Set the source type. This will indicate on which control out copy-cut operation
        // took place
        //
        if (hwndFocus == g_hwndEntryTree) {
            gClipBoard.SourceType = ENTRY_TREE;
        } else if(hwndFocus == DBTree.m_hLibraryTree) {
            gClipBoard.SourceType = LIB_TREE;
        }

        pCopyTemp->hItem    = hItem;   
        pCopyTemp->lpData   = (LPVOID)lParam;

        gClipBoard.Add(pCopyTemp);

    } else if (hwndFocus == g_hwndContentsList) {
        //
        // We can have multiple selects here.
        //
        gClipBoard.SourceType = ENTRY_LIST;

        //
        // Get the type of the items for the content list at the moment.
        //
        LVITEM lvItem;

        lvItem.mask     = LVIF_PARAM;
        lvItem.iItem    = 0;

        if (!ListView_GetItem(g_hwndContentsList, &lvItem)) {
            assert(FALSE);
            goto End;
        }

        assert(lvItem.lParam);

        if (lvItem.lParam > TYPE_NULL) {
            PDS_TYPE pdsType = (PDS_TYPE)lvItem.lParam;
            type = pdsType->type;
        } else {
            type = (TYPE)lvItem.lParam;
        }

        gClipBoard.type = type;
        
        UINT        uSelectedCount      = ListView_GetSelectedCount(g_hwndContentsList);
        INT         iTotalCount         = ListView_GetItemCount(g_hwndContentsList);
        INT         iIndex              = 0;
        UINT        uState              = 0;
        LONG        lSizeofClipboard    = 0;
        HTREEITEM   hParent; // This will be either the AllApps item or the AllLayers Item
        CSTRINGLIST strlListContents;

        lvItem.mask         = LVIF_PARAM | LVIF_STATE | LVIF_TEXT;
        lvItem.stateMask    = LVIS_SELECTED;

        for (UINT uFoundSelected = 1;
             iIndex < iTotalCount && uFoundSelected <= uSelectedCount;
             iIndex++) {

            *szBuffer             = 0;

            lvItem.iItem          = iIndex;
            lvItem.iSubItem       = 0;
            lvItem.pszText        = szBuffer;
            lvItem.cchTextMax     = ARRAYSIZE(szBuffer) - ARRAYSIZE(STR_NEW_LINE_CHARS);
            
            if(!ListView_GetItem(g_hwndContentsList, &lvItem)) {
              assert(FALSE);
              continue;
            }
            
            if (lvItem.state & LVIS_SELECTED) {
              
              pCopyTemp = new CopyStruct;
            
              if (pCopyTemp == NULL) {
                  MEM_ERR;
                  goto End;
              }

              INT iItemLength = lstrlen(szBuffer);
            
              //
              // See below: + 2 for the TEXT("\r\n") characters. Note that we are 
              // adding 2 because lSizeofClipboard represents the number of
              // characters and not the size.
              // Do NOT change this to sizeof(TCHAR)
              //
              lSizeofClipboard += iItemLength + 2; 

              if (((ARRAYSIZE(szBuffer) - 1) - iItemLength) >= (ARRAYSIZE(STR_NEW_LINE_CHARS) - 1)) {
                  //
                  // Make sure we have sufficient space
                  //
                  SafeCpyN(szBuffer + iItemLength, STR_NEW_LINE_CHARS, ARRAYSIZE(szBuffer) - iItemLength);
              } else {
                  assert(FALSE);
              }
            
              strlListContents.AddString(szBuffer);
            
              if (type == TYPE_ENTRY) {
                  hParent = g_pPresentDataBase->hItemAllApps;

              } else if (type == FIX_LAYER) {
                  hParent = g_pPresentDataBase->hItemAllLayers;

              } else if (type == FIX_SHIM || type == FIX_FLAG) {
                  hParent = DBTree.FindChild(g_pPresentDataBase->hItemDB, 
                                             TYPE_GUI_SHIMS);
              } else {
                  assert(FALSE);
              }
            
              pCopyTemp->hItem  = DBTree.FindChild(hParent, lvItem.lParam);
              pCopyTemp->lpData = (LPVOID)lvItem.lParam;
            
              gClipBoard.Add(pCopyTemp);
              uFoundSelected++;
            }
        }

        //
        // Copy text to the Windows clipboard
        //
        if (lSizeofClipboard) {

            chBuffersize = lSizeofClipboard + 1; // The last + 1 for the last NULL character

            hGlobal = GlobalAlloc(GHND | GMEM_SHARE, chBuffersize * sizeof(TCHAR)); 

            if (hGlobal) {

                pszGlobal = (TCHAR*)GlobalLock(hGlobal);
                
                if (pszGlobal == NULL) {
                    assert(FALSE);
                    goto End;
                }

                PSTRLIST pHead = strlListContents.m_pHead;

                *pszGlobal = 0;

                while (pHead) {
                    StringCchCat(pszGlobal, chBuffersize, pHead->szStr.pszString );
                    pHead = pHead->pNext;
                }
        
                GlobalUnlock(hGlobal);

                if (OpenClipboard(g_hDlg)) {

                    EmptyClipboard();
                    SetClipboardData(CF_UNICODETEXT, hGlobal);
                    CloseClipboard();
                }

            } else {
                assert(FALSE);
            }
        }
    }

End:;
}

void
PasteFromClipBoard(
    void
    )
/*++

    PasteFromClipBoard
    
    Desc:   Pastes from our own CLIPBOARD data structure. This routine will also do the cut part. We will
            cut an entry if the entry was cut instead of being copied. Once we have successfully pasted an entry 
            at the destination then we proceed with our cut.
    
    Note:   1. If the source and the dest. databases are same, and the operation involves a cut
            for an application or a layer and the source is the DB tree do nothing
            
            2. If the source is the entry tree then we do allow cut for the same database.
            
                Assumption: Only entries can be copied/cut from the entry tree. If you allow
                            non-entries to be copied as well, but do not allow cut for them, it 
                            will be a mess
                
            Copy proceeds normally but for cut we have to do something extra. If this
            is a cut operation then when we check for conflicts we will definitely find  
            the entry being cut as a conflict (we do not cut the 
            entry until after it has been pasted successfully), so we must leave that 
            entry when we check for conflicts and we must delete that entry at 
            the end of paste.
            
            Note that cut is not allowed for shims / flags in any case
--*/
{
    //
    // If we are doing a cut and the source and the destination databases are the same and 
    // the source of the cut is either the db tree or the entry list then there is no need to do a paste
    // But the situation is different if we are doing a cut in the entry tree. Because in this case we 
    // should allow users to cut an entry and paste it in a different application. If the user tries to 
    // paste in the same application then we do not do anything
    //
    if (g_bIsCut && gClipBoard.pDataBase == g_pPresentDataBase && 
        (gClipBoard.SourceType ==  LIB_TREE || gClipBoard.SourceType == ENTRY_LIST) && 
        (gClipBoard.type == TYPE_ENTRY 
         || gClipBoard.type ==  TYPE_GUI_APPS
         || gClipBoard.type == TYPE_GUI_LAYERS
         || gClipBoard.type == FIX_LAYER)) {

        return;
    }

    HWND    hwndFocus   = GetFocus();
    TYPE    typeTemp    = TYPE_UNKNOWN;
     
    switch (gClipBoard.type) {
    case TYPE_ENTRY:
        {
            HTREEITEM hItem = NULL;

            if (hwndFocus != g_hwndContentsList) {
                 hItem = TreeView_GetSelection(DBTree.m_hLibraryTree);
            } else {
                
                LVITEM lvItem;

                lvItem.mask         = LVIF_PARAM | LVIF_STATE ;
                lvItem.stateMask    = LVIS_SELECTED;
                lvItem.iItem        = ListView_GetSelectionMark(g_hwndContentsList);
                lvItem.iSubItem     = 0;

                if (g_pPresentDataBase == NULL) {
                    assert(FALSE);
                    break;
                }

                if (ListView_GetItem(g_hwndContentsList, &lvItem) && 
                    (lvItem.state & LVIS_SELECTED)) {

                    //
                    // Check that the selected item is an App
                    //
                    typeTemp = ConvertLparam2Type(lvItem.lParam);

                    if (typeTemp != TYPE_ENTRY) {
                        //
                        // We needed a entry to be selected in the contents list
                        //
                        assert(FALSE);
                        break;
                    }

                    hItem = DBTree.FindChild(g_pPresentDataBase->hItemAllApps, lvItem.lParam);

                } else {
                    hItem = g_pPresentDataBase->hItemAllApps;
                }

                if (hItem == NULL) {
                    assert(FALSE);
                    break;
                }
            }
            
            //
            // We selected an entry from the tree on the right and we have also selected an app on the left.
            // That means we wish to put the selected entry into the selected app on the left.
            // Note that if we have selected some app from the contents list, we find the corresponding
            // tree item in the db tree for that app and proceed as if we had tried to do paste 
            // on that tree item
            //
            if (gClipBoard.SourceType == ENTRY_TREE  &&  
                GetItemType(DBTree.m_hLibraryTree, hItem) == TYPE_ENTRY) {

                LPARAM lParam;    

                if(!DBTree.GetLParam(hItem, &lParam)) {
                    break;
                }

                //
                // If we are doing a cut and the the destination app is the same as the app of the 
                // entry being cut, do nothing
                //
                if (g_bIsCut && (PDBENTRY)lParam == GetAppForEntry(gClipBoard.pDataBase, 
                                                                   (PDBENTRY)gClipBoard.pClipBoardHead->lpData)) {
                    
                    goto End;
                }

                PasteSingleApp((PDBENTRY)gClipBoard.pClipBoardHead->lpData, 
                               g_pPresentDataBase, 
                               gClipBoard.pDataBase,
                               FALSE, 
                               ((PDBENTRY)lParam)->strAppName.pszString);

                SendMessage(g_hwndEntryTree, WM_SETREDRAW, TRUE, 0);     
                
            } else if (gClipBoard.SourceType == ENTRY_TREE) {
                //
                // Paste this in the database itself, we do not have any specific app
                // in which we can paste this
                //
                PasteSingleApp((PDBENTRY)gClipBoard.pClipBoardHead->lpData, 
                               g_pPresentDataBase,
                               gClipBoard.pDataBase,
                               FALSE);

                SendMessage(g_hwndEntryTree, WM_SETREDRAW, TRUE, 0);
            
            } else {
                
                PasteMultipleApps(g_pPresentDataBase);

                SendMessage(g_hwndEntryTree, WM_SETREDRAW, TRUE, 0);
            }
        }

        break;

    case TYPE_GUI_APPS:

        PasteAllApps(g_pPresentDataBase);
        break;

    case FIX_LAYER:

        PasteMultipleLayers(g_pPresentDataBase);
        break;

    case TYPE_GUI_LAYERS:
        
        PasteAllLayers(g_pPresentDataBase);
        break;

    case FIX_FLAG:
    case FIX_SHIM:

        PasteShimsFlags(g_pPresentDataBase);
        break;

    default: assert(FALSE);
    }

    if (g_bIsCut) {
        //
        // If this routine was called because of a cut, then we do the actual cut here
        // 
        CopyStruct* pCopyTemp = gClipBoard.pClipBoardHead;
        CopyStruct* pCopyTempNext = NULL;

        while (pCopyTemp) {

            pCopyTempNext = pCopyTemp->pNext;

            DoTheCut(gClipBoard.pDataBase,
                     gClipBoard.type,
                     gClipBoard.SourceType,
                     pCopyTemp->lpData,
                     pCopyTemp->hItem,
                     FALSE);
            
            //
            // NOTE:    The gClipBoard.pClipBoardHead might have got changed in ValidateClipboard()
            //
            if (gClipBoard.pClipBoardHead == pCopyTemp) {
                //
                // We were not able to remove this entry, that is cut must have failed.
                // An example situation is when we are trying to cut a layer that is in use by some 
                // entry
                //
                break;
            } else {
                pCopyTemp = gClipBoard.pClipBoardHead;
            }
        }

        gClipBoard.pDataBase->bChanged = TRUE;

        //
        // Set the caption only for the tree item
        //
        SetCaption(TRUE, gClipBoard.pDataBase, TRUE);
        gClipBoard.RemoveAll();
    }


    if (!g_pPresentDataBase->bChanged) {
        g_pPresentDataBase->bChanged = TRUE;
        SetCaption();
    }

    if (g_pEntrySelApp && gClipBoard.SourceType == ENTRY_TREE) {
        //
        // We will now try to set focus to the last entry pasted. The focus will
        // be set in the entry tree.
        //
        TreeView_SelectItem(g_hwndEntryTree, g_pEntrySelApp->hItemExe);

    } else if (gClipBoard.SourceType == LIB_TREE) {
        //
        // Select the first entry.
        //
        TreeView_SelectItem(g_hwndEntryTree, TreeView_GetRoot(g_hwndEntryTree));
    }
    
    //
    // The refresh of the content list is handled in  ID_EDIT_PASTE
    //
End:;

}

void
ListViewSelectAll(
    IN  HWND hwndList
    )
/*++
    ListViewInvertSelection

	Desc:	Selects all the items for the list view

	Params: 
        IN  HWND hwndList:  The handle to the list view    

	Return:
        void
        
--*/
{
    INT iLastindex = ListView_GetItemCount(hwndList) - 1;

    if (iLastindex > -1) {

        for (iLastindex; iLastindex >= 0; iLastindex--) {

            ListView_SetItemState(g_hwndContentsList,
                                  iLastindex,
                                  LVIS_SELECTED,
                                  LVIS_SELECTED);
        }
    }
}

void
ListViewInvertSelection(
    IN  HWND hwndList
    )
/*++
    ListViewInvertSelection

	Desc:	Inverts the selection for the list view

	Params: 
        IN  HWND hwndList:  The handle to the list view    

	Return:
        void
        
--*/
{
    INT iLastindex = ListView_GetItemCount(hwndList) - 1;

    if (iLastindex > -1) {

        for (iLastindex; iLastindex >= 0; iLastindex--) {

            UINT uState = ListView_GetItemState(g_hwndContentsList, iLastindex, LVIS_SELECTED);

            (uState == LVIS_SELECTED) ? (uState = 0) : (uState = LVIS_SELECTED);

            ListView_SetItemState(g_hwndContentsList, iLastindex, uState, LVIS_SELECTED);
        }
    }
}

BOOL
DeleteMatchingFile(
    IN  OUT PMATCHINGFILE*      ppMatchFirst,
    IN      PMATCHINGFILE       pMatchToDelete,
    IN      HWND                hwndTree,  
    IN      HTREEITEM           hItem
    )
/*++
    
    DeleteMatchingFile
    
    Desc:   Deletes a matching file tree item from the entry tree.
    
    Params:
        IN  OUT PMATCHINGFILE*  ppMatchFirst:   The address of g_pSelEntry->pFirstMatchingFile
        IN      PMATCHINGFILE   pMatchToDelete: The matching file that has to be deleted
        IN      HWND            hwndTree:       The handle to the entry tree  
        IN      HTREEITEM       hItem:          The matching tree item that has to be deleted 
--*/
{

    if (ppMatchFirst == NULL || pMatchToDelete == NULL) {
        assert(FALSE);
        Dbg(dlError, "[DeleteMatchingFile] Invalid parameters");
        return FALSE;
    }

    PMATCHINGFILE pMatchTemp = *ppMatchFirst, pMatchPrev = NULL;
    
    while (NULL != pMatchTemp) {

        if (pMatchTemp == pMatchToDelete) {
            break;
        }

        pMatchPrev = pMatchTemp;
        pMatchTemp = pMatchTemp->pNext;
    }

    if (pMatchTemp == NULL) {
        return FALSE;
    }    

    if (pMatchPrev == NULL) {
        //
        //Delete first matching file
        //
        *ppMatchFirst = pMatchTemp->pNext;
    } else {
        pMatchPrev->pNext = pMatchTemp->pNext;
    }

    TreeView_DeleteItem(hwndTree, hItem);

    delete pMatchTemp;
    pMatchTemp = NULL;
    

    return TRUE;
}

BOOL
CheckInstalled(
    IN  PCTSTR  pszPath,
    IN  PCTSTR  pszGUID
    )
/*++
    
    CheckInstalled
    
    Desc:   Checks if the database with path szPath and guid szGuid is an installed database
            That is to say that it checks if the file exists in the %windir%AppPatch\Custom
            Directory and has the same file-name as the guid. (Plus a .sdb)
            
    Params: 
        IN  PCTSTR  szPath: The path of the database that has to be checked
        IN  PCTSTR  szGUID: The guid of the database
--*/
{   

    Dbg(dlInfo, "File Name = %S", pszPath);

    TCHAR   szDrive[MAX_PATH], 
            szDir[MAX_PATH], 
            szFile[MAX_PATH];
    CSTRING strAppPatchCustom;
    CSTRING strPath;

    *szDir = *szDrive = *szFile = 0;

    _tsplitpath(pszPath, szDrive, szDir, szFile, NULL);

    strPath = szDrive;
    strPath += szDir;

    if (!strAppPatchCustom.GetSystemWindowsDirectory()) {
        assert(FALSE);
        return FALSE;
    }

    strAppPatchCustom += TEXT("AppPatch\\Custom\\");

    if (strAppPatchCustom == strPath && lstrcmpi(pszGUID, szFile) == 0) {
        return TRUE;
    }

    return FALSE;
}

DWORD WINAPI
ThreadEventKeyNotify(
    LPVOID pVoid
    )
/*++

    ThreadEventKeyNotify

	Desc:	Thread routine that is responsible for automatic updating of the 
            Installed databases list and the per user settings list

	Params:
        LPVOID pVoid: Not used

	Return:
        void
--*/

{
    DWORD dwInd;
    
    while (TRUE) {

        #ifdef HELP_BOUND_CHECK
        
            if (s_bProcessExiting) {

                if (g_hKeyNotify[IND_PERUSER]) {
                    REGCLOSEKEY(g_hKeyNotify[IND_PERUSER]);
                }

                if (g_hKeyNotify[IND_ALLUSERS]) {
                    REGCLOSEKEY(g_hKeyNotify[IND_ALLUSERS]);
                }

                return 0;
            }
        #endif

        dwInd = WaitForMultipleObjects(2, g_arrhEventNotify, FALSE, INFINITE);
        
        switch (dwInd) {
        case WAIT_OBJECT_0:
            //
            // We use PostMessage, so that if we get the two events in quick succession
            // we do not mess up our data structures
            //
            PostMessage(g_hDlg, WM_USER_UPDATEPERUSER, 0, 0);

            RegNotifyChangeKeyValue(g_hKeyNotify[IND_PERUSER], 
                                    TRUE, 
                                    REG_NOTIFY_CHANGE_NAME 
                                    | REG_NOTIFY_CHANGE_ATTRIBUTES 
                                    | REG_NOTIFY_CHANGE_LAST_SET,
                                    g_arrhEventNotify[IND_PERUSER],
                                    TRUE);
            break;
        
        case WAIT_OBJECT_0 + 1:
            //
            // We use PostMessage, so that if we get the two events in quick succession
            // we do not mess up our data structures
            //    
            PostMessage(g_hDlg, WM_USER_UPDATEINSTALLED, 0, 0);

            RegNotifyChangeKeyValue(g_hKeyNotify[IND_ALLUSERS], 
                                    TRUE, 
                                    REG_NOTIFY_CHANGE_NAME 
                                    | REG_NOTIFY_CHANGE_ATTRIBUTES 
                                    | REG_NOTIFY_CHANGE_LAST_SET,
                                    g_arrhEventNotify[IND_ALLUSERS],
                                    TRUE);
            break;
        
        default:
            break;
        }
    }
}

void 
SetStatus(
    IN  INT iCode
    )
/*++
    SetStatus

	Desc:	Sets the text for the status control in the main window     

	Params:
        IN  INT iCode:  This is the resource id of the string in the string table that
            has to be displayed in the status control
            
    Return:
        void
        
--*/

{
    SetWindowText(GetDlgItem(g_hDlg, IDC_STATUSBAR), GetString(iCode));
}

void
SetStatus(
    IN  PCTSTR pszMessage
    )
/*++
    
    SetStatus

	Desc:	Sets the text for the status control in the main window

	Params:
        IN  PCTSTR pszMessage:   The text that has to be displayed in the status control

	Return:
        void
--*/
{
    SetWindowText(GetDlgItem(g_hDlg, IDC_STATUSBAR), pszMessage);
}

void
SetStatus(
    IN  HWND    hwndStatus,
    IN  PCTSTR  pszMessage
    )
/*++
    
    SetStatus

	Desc:	Sets the text for a status control

	Params:
        IN  HWND    hwndStatus: The handle to the status window
        IN  PCTSTR  pszMessage: The text that has to be displayed in the status control

	Return:
        void
--*/
{
    SetWindowText(hwndStatus, pszMessage);
}

void
SetStatus(
    IN  HWND    hwndStatus,
    IN  INT     iCode
    )
/*++

    SetStatus

	Desc:	Sets the text for a status control

	Params:
        IN  INT iCode:  This is the resource id of the string in the string table that
            has to be displayed in the status control
            
    Return:
        void
--*/

{
    SetWindowText(hwndStatus, GetString(iCode));
}


void
SetStatusDBItems(
    IN  HTREEITEM hItem
    )
/*++

    SetStausDBItems

	Desc:	Sets the main window status control, when the user selects some item
            in the db tree(LHS)

	Params:   
        IN  HTREEITEM hItem:    The tree item that the user selected

	Return:
        void
        
--*/
{
    TCHAR   szStatus[512];
    TYPE    type    = GetItemType(DBTree.m_hLibraryTree, hItem);
    UINT    uCount  = ARRAYSIZE(szStatus);
    

    switch (type) {
    case TYPE_ENTRY:
        {
            LPARAM lParam;

            if (DBTree.GetLParam(hItem, &lParam)) {

                PDBENTRY    pApp        = (PDBENTRY)lParam;
                UINT        uEntryCount = GetAppEntryCount(pApp);

                *szStatus = 0;

                StringCchPrintf(szStatus, 
                                uCount, 
                                GetString(IDS_STA_ENTRYCOUNT), 
                                pApp->strAppName.pszString, 
                                uEntryCount);

                SetStatus(szStatus);
            }
        }

        break;

    case FIX_SHIM:

        SetStatus(IDS_STA_SHIM);
        break;

    case TYPE_GUI_COMMANDLINE:

        SetStatus(IDS_STA_COMMANDLINE);
        break;

    case TYPE_GUI_EXCLUDE:
        
        ShowExcludeStatusMessage(DBTree.m_hLibraryTree, hItem);
        break;
        
    case TYPE_GUI_INCLUDE:
        
        ShowIncludeStatusMessage(DBTree.m_hLibraryTree, hItem);
        break;

    case  TYPE_GUI_APPS:  
        
        if (g_pPresentDataBase) {

            StringCchPrintf(szStatus, 
                            uCount, 
                            GetString(IDS_STA_POPCONTENTS_GUI_APPS), 
                            g_pPresentDataBase->uAppCount);

            SetStatus(szStatus);
        }

        break;

    case TYPE_GUI_LAYERS:

        if (g_pPresentDataBase) {

            StringCchPrintf(szStatus, 
                            uCount, 
                            GetString(IDS_STA_POPCONTENTS_GUI_LAYERS), 
                            GetLayerCount((LPARAM)g_pPresentDataBase, g_pPresentDataBase->type));
    
            SetStatus(szStatus);
        }
        
        break;

    case FIX_LAYER:
        {
            LPARAM      lParam;
            PLAYER_FIX  plf;

            DBTree.GetLParam(hItem, &lParam);

            plf = (PLAYER_FIX)lParam;

            if (plf) {

                StringCchPrintf(szStatus, 
                                uCount, 
                                GetString(IDS_STA_POPCONTENTS_GUI_SHIMS), 
                                GetShimFlagCount((LPARAM)plf, FIX_LAYER));

                SetStatus(szStatus);
            }
        }

        break;

    case TYPE_GUI_SHIMS:
        
        if (g_pPresentDataBase) {

            StringCchPrintf(szStatus, 
                            uCount, 
                            GetString(IDS_STA_POPCONTENTS_GUI_SHIMS), 
                            g_pPresentDataBase->uShimCount);

            SetStatus(szStatus);                   
        }

        break;
    }
}

void
SetStatusStringDBTree(
    IN  HTREEITEM hItem
    )
/*++
    
    SetStatusStringDBTree
    
    Desc:   Given a hItem from the db tree, determines the status string to be displayed 
            in the status control.
    Params:
        IN  HTREEITEM hItem: The tree item whose status string we want to display
    
--*/
{
    HWND hwndFocus = GetFocus();

    INT iCode = 0;
    
    if (hItem == DBTree.m_hItemAllInstalled) {
        iCode = IDS_STA_INSTALLED;

    } else if (hItem == DBTree.m_hItemAllWorking) {
        iCode = IDS_STA_WORKING;

    } else if (hItem == DBTree.m_hPerUserHead) {
        iCode =   IDS_STA_PERUSER;

    } else {

        if (g_pPresentDataBase && hItem == g_pPresentDataBase->hItemDB) {

            if (g_pPresentDataBase->type == DATABASE_TYPE_INSTALLED) {
                iCode = IDS_DESC_INSTALLED;

            } else if (g_pPresentDataBase->type == DATABASE_TYPE_WORKING) {
                iCode = IDS_STA_WORKINGDB;

            } else if (g_pPresentDataBase->type == DATABASE_TYPE_GLOBAL) {
                iCode = IDS_SYSDB;
            }

        } else {
            SetStatusDBItems(hItem);
        }
    }

    if (iCode) {
        SetStatus(iCode);
    }
}

void
SetStatusStringEntryTree(
    IN  HTREEITEM hItem
    )
/*++
    
    SetStatusStringEntryTree
    
    Desc:   Given a hItem from the db tree, determines the status string to be displayed 
            in the status control.
    Params:
        IN  HTREEITEM hItem: The tree item whose status string we want to display
    
--*/
{
    HWND hwndFocus = GetFocus();

    if (hwndFocus != g_hwndEntryTree) {
        //
        // We can come here if we we selected some item programmatically.
        // But we want to show the status message in the context of the control that
        // is presently selected. So do not put an assert() here.
        //
        return;
    }

    TYPE    type = GetItemType(g_hwndEntryTree, hItem);
    TCHAR   szStatus[256];

    *szStatus = 0;

    if (g_pSelEntry == NULL) {
        assert(FALSE);
        return;
    }

    switch (type) {
    case TYPE_ENTRY:

        StringCchPrintf(szStatus,
                        ARRAYSIZE(szStatus),
                        GetString(IDS_STA_TYPE_ENTRY),
                        g_pSelEntry->strExeName.pszString,
                        g_pSelEntry->strAppName.pszString,
                        g_pSelEntry->strVendor.pszString);

        SetStatus(szStatus);
        break;

    case TYPE_APPHELP_ENTRY:

        SetStatus (IDS_STA_TYPE_APPHELP);
        break;

    case FIX_LAYER: 

        SetStatus (IDS_STA_FIX_LAYER);
        break;

    case FIX_FLAG:
    case FIX_SHIM:

        SetStatus (IDS_STA_FIX_SHIM);
        break;

    case FIX_PATCH:

        SetStatus (IDS_STA_FIX_PATCH);
        break;

    case TYPE_GUI_PATCHES:

        StringCchPrintf(szStatus, 
                        ARRAYSIZE(szStatus), 
                        GetString(IDS_STA_FIX_PATCHES), 
                        g_pSelEntry->strExeName);

        SetStatus(szStatus);

        break;

    case TYPE_GUI_LAYERS:
        
        StringCchPrintf(szStatus, 
                        ARRAYSIZE(szStatus), 
                        GetString(IDS_STA_FIX_LAYERS),  
                        g_pSelEntry->strExeName);

        SetStatus(szStatus);
        break;

    case TYPE_GUI_SHIMS:

        StringCchPrintf(szStatus, 
                        ARRAYSIZE(szStatus), 
                        GetString(IDS_STA_FIX_SHIMS), 
                        g_pSelEntry->strExeName);

        SetStatus(szStatus);
        break;

    case TYPE_GUI_MATCHING_FILES:
        
        StringCchPrintf(szStatus, 
                        ARRAYSIZE(szStatus), 
                        GetString(IDS_STA_MATCHINGFILES), 
                        g_pSelEntry->strExeName);

        SetStatus(szStatus);
        break;

    case TYPE_MATCHING_FILE:

        SetStatus (IDS_STA_MATCHINGFILE);
        break;

    case TYPE_MATCHING_ATTRIBUTE:

        SetStatus(IDS_STA_MATCHINGATTRIBUTE);
        break;

    case TYPE_GUI_EXCLUDE:

        ShowExcludeStatusMessage(g_hwndEntryTree, hItem);
        break;

    case TYPE_GUI_INCLUDE:

        ShowIncludeStatusMessage(g_hwndEntryTree, hItem);
        break;

    case TYPE_GUI_COMMANDLINE:

        SetStatus(IDS_STA_COMMANDLINE);
        break;

    default: SetStatus(TEXT(""));
    }
}

void 
OnMoveSplitter(
    IN  HWND   hdlg,
    IN  LPARAM lParam,
    IN  BOOL   bDoTheDrag,
    IN  INT    iDiff
    )
/*++

    OnMoveSplitter
    
	Desc:	May move the vertical split bar (if bDoTheDrag is true), 
            iDiff pixels +ve units to the right. Changes the mouse cursor to
            horiz. arrow if it is over the split bar

	Params:
        IN  HWND   hdlg:        The main app window    
        IN  LPARAM lParam:      The mouse position
        IN  BOOL   bDoTheDrag:  Should we move the  split bar
        IN  INT    iDiff:       The distance in pixels that the split bar has to
                to be moved. +ve right, -ve left. Relevant only if bDoTheDrag is 
                TRUE
                
	Return:
        void
--*/
{
    
    RECT rectDlg, rectEntryTree, rectDBTree;
    HWND hwndDBTree, hwndEntryTree;

    hwndDBTree = GetDlgItem(hdlg, IDC_LIBRARY);
    GetWindowRect(hwndDBTree, &rectDBTree);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&rectDBTree, 2);

    hwndEntryTree = GetDlgItem(hdlg, IDC_ENTRY);
    GetWindowRect(hwndEntryTree, &rectEntryTree);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&rectEntryTree, 2);

    GetWindowRect(hdlg, &rectDlg);
    
    int iMX = (int)LOWORD(lParam);
    int iMY = (int)HIWORD(lParam);

    if (iMX > rectDBTree.right  && iMX < rectEntryTree.left && iMY  > rectDBTree.top && iMY < rectDBTree.bottom) {
       SetCursor(LoadCursor(NULL, IDC_SIZEWE));
    }
    
    if (bDoTheDrag) {
        
        int iDlgWidth = rectDlg.right - rectDlg.left;

        //
        // Enforce left and right limit
        //
        if ((rectDBTree.right - rectDBTree.left < 0.20 * iDlgWidth && (iDiff <= 0)) || // Not too much left
            (rectDBTree.right - rectDBTree.left > 0.80 * iDlgWidth && (iDiff >= 0))) { // Not too much right
            
            return;

        } else if (iMX < iDlgWidth) { 
            //
            // Note: We get +ve values when the mouse goes out of the window. -1 becomes 65535
            //
            g_iMousePressedX = iMX;

            RECT rectRedraw;
            SetRect(&rectRedraw, rectDBTree.left, rectDBTree.top, rectEntryTree.right, rectDBTree.bottom);

            InvalidateRect(hdlg, &rectRedraw, TRUE);
            
            SetRect(&g_rectBar,
                    rectDBTree.right   + iDiff + 1,
                    rectDBTree.top,
                    rectEntryTree.left + iDiff - 1,
                    rectDBTree.bottom);
        
            //
            // Move the db tree
            //
            HDWP hdwp = BeginDeferWindowPos(MAIN_WINDOW_CONTROL_COUNT);

            DeferWindowPos(hdwp,
                           hwndDBTree,
                           NULL,
                           rectDBTree.left,
                           rectDBTree.top,
                           rectDBTree.right  - rectDBTree.left + iDiff , 
                           rectDBTree.bottom - rectDBTree.top, 
                           REDRAW_TYPE);

            //
            // Move the exe tree
            //
            DeferWindowPos(hdwp,
                           hwndEntryTree, 
                           NULL,
                           rectEntryTree.left + iDiff, 
                           rectEntryTree.top, 
                           rectEntryTree.right - rectEntryTree.left - iDiff , 
                           rectEntryTree.bottom - rectEntryTree.top, 
                           REDRAW_TYPE);
            //
            // Move the contents list.
            //
            DeferWindowPos(hdwp,
                           GetDlgItem(hdlg, IDC_CONTENTSLIST),
                           NULL,
                           rectEntryTree.left + iDiff, 
                           rectEntryTree.top, 
                           rectEntryTree.right - rectEntryTree.left - iDiff , 
                           rectEntryTree.bottom - rectEntryTree.top, 
                           REDRAW_TYPE);

            //
            // Move the description window.
            //
            if (g_bDescWndOn) {
                
                HWND hwndDesc;
                RECT rectDesc;

                hwndDesc = GetDlgItem(hdlg, IDC_DESCRIPTION);
                GetWindowRect(hwndDesc, &rectDesc);
                MapWindowPoints(NULL, hdlg, (LPPOINT)&rectDesc, 2);

                DeferWindowPos(hdwp,
                               GetDlgItem(hdlg, IDC_DESCRIPTION),
                               NULL,
                               rectDesc.left + iDiff, 
                               rectDesc.top, 
                               rectDesc.right - rectDesc.left - iDiff , 
                               100, 
                               REDRAW_TYPE);

                InvalidateRect(hwndDesc, NULL, TRUE);
                UpdateWindow(hwndDesc);
            }
            
            EndDeferWindowPos(hdwp);
        }
    }
}

UINT
GetAppEntryCount(
    IN  PDBENTRY pEntry
    )
/*++
    Desc:   Gets the number of entries in an app
    
    Params:
        IN  PDBENTRY pEntry: The pointer to the first entry in the app
    
    Return: Number of entries which are in same app as pEntry.
            pEntry should point to the first entry in the app.
--*/
{
    UINT uCount = 0;

    while (pEntry) {
        ++uCount;
        pEntry = pEntry->pSameAppExe;
    }

    return uCount;
}

void
AddToMRU(
    IN  CSTRING& strPath
    ) 
/*++

    AddToMRU
    
    Desc:   Adds the file name to the MRU (Most recently used files). 
    
            1. First of all tries to remove the file from the MRU.
            
            2. Then checks if the count in the MRU is equal or greater than the 
                MAX_MRU_COUNT.
                a) If yes, then it removes the last from the MRU
                
            3. Adds the new file name to the MRU.    
            
    Params:
        IN  CSTRING& strPath:   The full path of the program that has to be added
--*/    
{
    assert(g_strlMRU.m_uCount <= MAX_MRU_COUNT);

    g_strlMRU.Remove(strPath);

    if (g_strlMRU.m_uCount >= MAX_MRU_COUNT) {
        g_strlMRU.RemoveLast();
    }

    g_strlMRU.AddStringAtBeg(strPath);
}

void
AddMRUItemsToMenu(
    IN  HMENU hMenu,
    IN  int iPos
    )
/*++
    
    AddMRUItemsToMenu
    
    Desc:   Adds the MRU menus items for the File menu
    
    Params:
        IN  HMENU hMenu:    The File top-level menu
        IN  int iPos:       Position of the menu item before which to insert 
            the new item
        
    Return:
        void
--*/
{
    TCHAR           szRetPath[MAX_PATH];   
    TCHAR*          pszMenuString;
    MENUITEMINFO    menuItem    = {0};
    INT             iId         = ID_FILE_MRU1, iIndex = 0;
    PSTRLIST        pHead       = g_strlMRU.m_pHead;

    menuItem.cbSize = sizeof (MENUITEMINFO);
    menuItem.fMask  = MIIM_TYPE | MIIM_ID;
    menuItem.fType  = MFT_STRING;

    while (pHead) {
        
        //
        // Now add this to the menuItem.
        //
        *szRetPath              = 0;
        pszMenuString           = FormatMRUString(pHead->szStr.pszString, 
                                                  iIndex + 1, 
                                                  szRetPath, 
                                                  ARRAYSIZE(szRetPath));

        menuItem.dwTypeData     = pszMenuString;
        menuItem.cch            = lstrlen(pszMenuString);
        menuItem.wID            = iId;

        InsertMenuItem(hMenu,
                       iPos,
                       TRUE,
                       &menuItem);

        ++iId;
        ++iPos;
        ++iIndex;

        pHead = pHead->pNext;
    }
}

void
AddMRUToFileMenu(
    IN  HMENU  hmenuFile
    )
/*++  
    
    AddMRUToFileMenu
    
    Desc:   Populates the MRU
    
    Params:
        IN  HMENU  hmenuFile:   The File top level menu
--*/
{
    HKEY            hKey    = NULL;
    DWORD           dwType  = REG_SZ;  
    MENUITEMINFO    minfo   = {0};          
    INT             iPos    = 0;
    LONG            lResult = 0;
    BOOL            bValid  = FALSE;
    TCHAR           szData[MAX_PATH + 1], szValueName[MAX_PATH + 1];
    DWORD           dwchSizeofValueName, dwIndexValue;
    DWORD           dwSizeofData;

    g_strlMRU.DeleteAll();

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                      MRU_KEY,
                                      0,
                                      KEY_READ,
                                      &hKey)) {

        Dbg(dlInfo, "[AddMRUToFileMenu]: No MRU items exist, could not open - Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\CompatAdmin\\MRU");
        return;
    }

    dwIndexValue = 0;

    while (TRUE  && iPos < MAX_MRU_COUNT) { 
        //
        // Note that the values are not ordered in any particular way !
        //
        dwchSizeofValueName = ARRAYSIZE(szValueName);
        dwSizeofData        = sizeof(szData); 
        *szData             = 0;
        *szValueName        = 0; 

        lResult = RegEnumValue(hKey,
                               dwIndexValue,
                               szValueName,
                               &dwchSizeofValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)szData,
                               &dwSizeofData);

        if (lResult == ERROR_NO_MORE_ITEMS) {
            break;
        }

        if (ERROR_SUCCESS != lResult || dwType != REG_SZ) {
            assert(FALSE);
            break;
        }

        iPos = Atoi(szValueName, &bValid);

        if (iPos >= 0 && bValid) {
            g_strlMRU.AddStringInOrder(szData, iPos);
        } else {
            assert(FALSE);
        }

        ++dwIndexValue;
    }
    
    //
    // The MRU has been populated, now add these to the "File" menu Item
    //
    if (g_strlMRU.IsEmpty() == FALSE) {
        
        //
        // Add the separator
        //
        minfo.cbSize    = sizeof(MENUITEMINFO);
        minfo.fMask     = MIIM_TYPE;
        minfo.fType     = MFT_SEPARATOR;

        INT iPosSeparator = GetMenuItemCount(hmenuFile) - 2; // -1 for the exit menu and -1 for the separator above it

        InsertMenuItem(hmenuFile,
                       iPosSeparator,
                       TRUE,
                       &minfo);

        AddMRUItemsToMenu(hmenuFile, iPosSeparator + 1);
    }

    if (hKey) {
        REGCLOSEKEY(hKey);
    }
}
           
TCHAR*
FormatMRUString(
    IN  PCTSTR pszPath,
    IN  INT    iIndex,
    OUT PTSTR  pszRetPath,
    IN  UINT   cchRetPath
    )
/*++
    Desc:   Formats szPath so that we can show it as a menu item in Files
            Max. length of the returned string is MAX_LENGTH_MRU_MENUITEM
    
    Params: IN  PCTSTR pszPath:     The complete path of the .sdb file
            IN  INT    iIndex:      The index of this MRU item. This will also serve 
                as the short-cut key. First MRU item will have index as 1 and number of 
                mru items is limited by MAX_MRU_COUNT
                    
            OUT PTSTR   pzRetPath:  This will have the formatted string 
            IN  UINT   cchRetPath:  Number of chars that can be stored in cchRetpath.
                    This will include the NULL char as well. 
                    To be safe it should be greater than 128
                    
    Return: Fills up pszPath with the formatted file name and returns a pointer to it
--*/
{   
    assert(cchRetPath > 128);                           

    if (pszRetPath) {
        *pszRetPath = 0;
    } else {
        assert(FALSE);
        return TEXT("");
    }

    if (iIndex < 1 || iIndex > MAX_MRU_COUNT) {
        assert(FALSE);
        return TEXT("");
    }

    TCHAR   szResult[MAX_PATH * 2],
            szDir[MAX_PATH],
            szFileName[MAX_PATH],
            szExt[MAX_PATH];

    szResult[0] = TEXT('&');

    //
    // We have already checked that iIndex is a valid +ve integer and is within proper bounds
    //
    _itot(iIndex, szResult + 1, 10);

    StringCchCat(szResult, ARRAYSIZE(szResult), TEXT(" "));

    if (lstrlen(pszPath) <= MAX_LENGTH_MRU_MENUITEM) {
        StringCchCat(szResult, ARRAYSIZE(szResult), pszPath);
        goto End;
    }

    _tsplitpath(pszPath,
                szResult + lstrlen(szResult),
                szDir,
                szFileName,
                szExt);

    //
    // Now for the directory. Start from the front and add MAX_DIR_SHOW chars to szResult.
    //
    _tcsncat(szResult, szDir, MAX_DIR_SHOW);

    if (lstrlen(szDir) > MAX_DIR_SHOW) {
        StringCchCat(szResult, ARRAYSIZE(szResult), TEXT("...\\"));
    }

    //
    // For the file-name get the first MAX_FILE_SHOW chars and then append ... to the file name, after that put the .SDB
    //
    _tcsncat(szResult, szFileName, MAX_FILE_SHOW);

    if (lstrlen(szFileName) <= MAX_FILE_SHOW) {
        StringCchCat(szResult, ARRAYSIZE(szResult), szExt);
    } else {
        StringCchCat(szResult, ARRAYSIZE(szResult), TEXT("..."));
    }

End:
    SafeCpyN(pszRetPath, szResult, cchRetPath);

    return pszRetPath;
}

void
RefreshMRUMenu(
    void
    )
/*++
    
    RefreshMRUMenu

    Desc:   Refreshes the "File" menu contents (the MRU), this is called when we 
            open a new database or save, save as an existing one.
--*/
{

    HMENU           hMenu   = GetMenu(g_hDlg);
    MENUITEMINFO    minfo   = {0};  
    //
    // Get the file menu
    //
    hMenu       = GetSubMenu(hMenu, 0);
    
    //
    // Delete all the MRU items from the menu
    //
    for (UINT uCount = 0; uCount < g_strlMRU.m_uCount; ++uCount) {
        DeleteMenu(hMenu, ID_FILE_MRU1 + uCount, MF_BYCOMMAND);
    }

    INT iItemCount = GetMenuItemCount(hMenu);

    //
    // Check if the separator for the top of the MRU list exists or not, if not add it
    //
    minfo.cbSize    = sizeof(minfo);
    minfo.fMask     = MIIM_TYPE;

    if (GetMenuItemID(hMenu, iItemCount - 3) == ID_FILE_PROPERTIES) {
        //
        // There was no  MRU file in the MRU menu, so we have to add the separator
        //
        minfo.fType = MFT_SEPARATOR;

        InsertMenuItem(hMenu,
                       iItemCount - 2, // Before the sep. of the Exit menu
                       TRUE,
                       &minfo);

        ++iItemCount;
    }                

    AddMRUItemsToMenu(hMenu, iItemCount - 2); // -1 for the EXIT, -1 for the separator above that

    DrawMenuBar(g_hDlg);
}

BOOL
LoadDataBase(
    IN  TCHAR* szPath
    )
/*++
    LoadDataBase

	Desc:	Load the database file with szPath as its path

	Params:
        IN  TCHAR* szPath:  Path of the database to be loaded

	Return:
        FALSE:  If the database could not be loadd
        TRUE:   False otherwise
--*/
{
    PDATABASE   pOldPresentDatabase = NULL;
    PDATABASE   pDataBase = new DATABASE(DATABASE_TYPE_WORKING);

    if (pDataBase == NULL) {
        MEM_ERR;
        return FALSE;
    }

    //
    // NOTE:    If GetDatabaseEntries() returns succeeds then it set the g_pPresentDataBase to pDataBase,
    //          so after it returns successfully, the g_pPresentDataBase is changed. 
    //
    pOldPresentDatabase = g_pPresentDataBase;

    BOOL bReturn = GetDatabaseEntries(szPath, pDataBase);

    g_pPresentDataBase = pOldPresentDatabase;

    if (!bReturn) {
        delete pDataBase;            
        return FALSE;
    }

    if (!DBTree.AddWorking(pDataBase)) {

        delete pDataBase;
        return FALSE;
    }

    pDataBase->bChanged = FALSE;

    return TRUE;
}


BOOL
AddRegistryKeys(
    void
    )
/*++
    AddRegistryKeys
    
    Desc:   Adds the necessary registry keys so that we can listen on them.
            If they are not there, we cannot listen on them and update the 
            list of all installed databases and the per-user settings
            
    Return:
        void
--*/
{

    HKEY    hKey = NULL, hKeySub = NULL;
    DWORD   dwDisposition;

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                      KEY_BASE,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hKey)) {       
        
        assert(FALSE);
        return FALSE;
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(hKey,
                                        TEXT("AppCompatFlags"),
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKeySub,
                                        &dwDisposition)) {

        REGCLOSEKEY(hKey);
        return FALSE;
    }

    REGCLOSEKEY(hKey);
    hKey = hKeySub;

    if (ERROR_SUCCESS != RegCreateKeyEx(hKey,
                                        TEXT("InstalledSDB"),
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKeySub,
                                        &dwDisposition)) {
        
        REGCLOSEKEY(hKey);
        return FALSE;
    }

    REGCLOSEKEY(hKey);
    REGCLOSEKEY(hKeySub);

    return TRUE;
}

void
SetTBButtonStatus(
    IN  HWND hwndTB,
    IN  HWND hwndControl
    )
{
/*++

    SetTBButtonStatus
    
    Desc:   This routine is called when the selection changes for DB Tree or the 
            Entry Tree. This routine enables/disables some of the tool bar buttons as 
            deemed necessary.
    Params:
        IN  HWND hwndTB:        The handle to the tool bar        
        IN  HWND hwndControl:   The control on which the sel change has taken place   
        
    Return:
        void
--*/

    TYPE typeDB = TYPE_UNKNOWN;
    BOOL bEnable;

    if (hwndControl == DBTree.m_hLibraryTree) {

        if (g_pPresentDataBase) {
            typeDB = g_pPresentDataBase->type;
        }

        bEnable = g_pPresentDataBase && typeDB == DATABASE_TYPE_WORKING;

        //
        // Set the options as for working databases
        //
        EnableToolBarButton(hwndTB, ID_FILE_SAVE, bEnable);
        EnableToolBarButton(hwndTB, ID_DATABASE_CLOSE, bEnable);
        EnableToolBarButton(hwndTB, ID_FIX_CREATEANAPPLICATIONFIX, bEnable);

        //
        // AppHelp mechanism is not supported in win2k
        //
        EnableToolBarButton(hwndTB, 
                            ID_FIX_CREATEANEWAPPHELPMESSAGE, 
                            (g_bWin2K) ? FALSE : bEnable);

        EnableToolBarButton(hwndTB, ID_FIX_CREATENEWLAYER, bEnable);

        bEnable = (g_pSelEntry != NULL);
        EnableToolBarButton(hwndTB, ID_FIX_EXECUTEAPPLICATION, bEnable);

    } else if (hwndControl == g_hwndEntryTree) {
        //
        // Run Program button
        //
        bEnable = (g_pSelEntry != NULL);
        EnableToolBarButton(hwndTB, ID_FIX_EXECUTEAPPLICATION, bEnable);
    }
}

void
ShowToolBarToolTips(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )

/*++
    
    ShowToolBarToolTips
    
	Desc:	Gets the text for the tool bar tool tips

	Params:
        IN  HWND    hdlg:   The main app window
        IN  LPARAM  lParam: The lParam for WM_NOTIFY

	Return:
        void
--*/
{
    LPTOOLTIPTEXT   lpttt; 
    INT             idStringResource = 0;
 
    lpttt = (LPTOOLTIPTEXT)lParam; 

    if (lpttt == NULL) {
        assert(FALSE);
        return;
    }

    lpttt->hinst = g_hInstance;
    
    //
    // Specify the resource identifier of the descriptive 
    // text for the given button. 
    //
    switch (lpttt->hdr.idFrom) {
    case ID_FILE_NEW:

        idStringResource = IDS_TB_TT_NEW;
        break;

    case ID_FILE_OPEN:

        idStringResource = IDS_TB_TT_OPEN;
        break;

    case ID_FILE_SAVE:

        idStringResource = IDS_TB_TT_SAVE;
        break;

    case ID_FIX_CREATEANAPPLICATIONFIX:

        idStringResource = IDS_TB_TT_CREATEFIX;
        break;

    case ID_FIX_CREATEANEWAPPHELPMESSAGE:

        idStringResource = IDS_TB_TT_CREATEAPPHELP;
        break;

    case ID_FIX_CREATENEWLAYER:

        idStringResource = IDS_TB_TT_CREATEMODE;
        break;

    case ID_FIX_EXECUTEAPPLICATION:

        idStringResource = IDS_TB_TT_RUN;
        break;

    case ID_TOOLS_SEARCHFORFIXES:

        idStringResource = IDS_TB_TT_SEARCH;
        break;

    case ID_SEARCH_QUERYDATABASE:

        idStringResource = IDS_TB_TT_QUERY;
        break;
    }

    lpttt->lpszText = MAKEINTRESOURCE(idStringResource);
}

PSHIM_FIX_LIST
IsLUARedirectFSPresent(
    IN  PDBENTRY pEntry
    )
/*++    
    IsLUARedirectFSPresent
    
    Desc:   Checks if the entry pEntry has LUARedirectFS shim applied to it
    
    Params:
        IN  PDBENTRY pEntry:    The entry for which we want to make the check     
    
    Return:
        PSHIM_FIX_LIST for LUARedirectFS: if the entry has LUARedirectFS applied
        NULL:    otherwise
    
    Notes:  Because we always add the shims in the LUA layer individually,
            we only check in the shim fix list of this entry.
--*/    
{
    if (pEntry == NULL) {
        assert(FALSE);
        return NULL;
    }

    PSHIM_FIX_LIST psfl = pEntry->pFirstShim;

    while (psfl) {

        if (psfl->pShimFix->strName == TEXT("LUARedirectFS")) {
            return psfl;
        }

        psfl = psfl->pNext;
    }

    return NULL;
}

void
CreateNewAppHelp(
    void
    )
/*++
    
    CreateNewAppHelp
    
    Desc:   Creates a new AppHelp fix. This routine starts up the wizard to do the job
            and if an entry has been created (the user pressed finish button) adds the entry 
            into the database
--*/
{
    CAppHelpWizard  wizAppHelp;
    PDATABASE       pCurrentSelectedDB  = GetCurrentDB();
    BOOL            bReturn             = FALSE;

    if (pCurrentSelectedDB == NULL) {
        assert(FALSE);
        return;
    }

    bReturn = wizAppHelp.BeginWizard(g_hDlg, NULL, pCurrentSelectedDB);

    if (bReturn == FALSE) {
        return;
    }

    PDBENTRY pEntry = new DBENTRY;
    
    if (pEntry == NULL) {
        MEM_ERR;
        return;
    }
    
    //
    // This will point to the entry that conflicts.
    //
    PDBENTRY    pEntryConflict = NULL;

    if (CheckIfConflictingEntry(pCurrentSelectedDB, 
                                &wizAppHelp.m_Entry, 
                                NULL, 
                                &pEntryConflict)) {

        StringCchPrintf(g_szData, 
                        ARRAYSIZE(g_szData),
                        GetString(IDS_CONFLICT_CREATE_EDIT), 
                        pEntryConflict->strExeName.pszString,
                        pEntryConflict->strAppName.pszString);

        if (IDNO == MessageBox(g_hDlg, 
                               g_szData, 
                               g_szAppName, 
                               MB_ICONQUESTION | MB_YESNO)) {
            return;
        }
    }

    //
    // NOTE: "=" is overloaded. Does not modify the pNext member.
    //
    *pEntry = wizAppHelp.m_Entry;

    PDBENTRY pApp;
    BOOL     bNew;
    
    pApp = AddExeInApp(pEntry, &bNew, pCurrentSelectedDB); 

    if (bNew == TRUE) {
        //
        // This means that this is going to be a new application. There does not
        // exist anyt app with this name in the database
        //
        pApp = NULL;
    }

    DBTree.AddNewExe(pCurrentSelectedDB, pEntry, pApp);

    if (!pCurrentSelectedDB->bChanged) {
        pCurrentSelectedDB->bChanged = TRUE;
        SetCaption();
    }
}

void
ModifyAppHelp(
    void
    )
/*++
    ModifyAppHelp
    
    Desc:   Modifies or adds a new apphelp entry for the presently selected 
            application fix
--*/
{
    PDBENTRY        pEntry = g_pSelEntry;
    CAppHelpWizard  Wiz;
    PDBENTRY        pEntryConflict      = NULL;
    PDATABASE       pCurrentSelectedDB  = GetCurrentDB();
    BOOL            bRet                = FALSE;

    if (pEntry == NULL || pCurrentSelectedDB == NULL) {
        assert(FALSE);
        return;
    }

    bRet = Wiz.BeginWizard(g_hDlg, pEntry, pCurrentSelectedDB);

    if (bRet) {

        if (CheckIfConflictingEntry(pCurrentSelectedDB, 
                                    &Wiz.m_Entry, 
                                    pEntry, 
                                    &pEntryConflict)) {

            *g_szData = 0;

            StringCchPrintf(g_szData, 
                            ARRAYSIZE(g_szData),
                            GetString(IDS_ENTRYCONFLICT), 
                            pEntryConflict->strExeName.pszString,
                            pEntryConflict->strAppName.pszString);

            if (IDNO == MessageBox(g_hDlg,
                                   g_szData,
                                   g_szAppName,
                                   MB_ICONQUESTION | MB_YESNO)) {
                return;
            }
        }

        //
        // NOTE: "=" is overloaded. Does not modify the pNext member.
        //
        *pEntry = Wiz.m_Entry;
	
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        UpdateEntryTreeView(g_pEntrySelApp, g_hwndEntryTree);
        SetCursor(LoadCursor(NULL, IDC_ARROW));

        if (!pCurrentSelectedDB->bChanged) {
            pCurrentSelectedDB->bChanged = TRUE;
            SetCaption();
        }
    }
}

void
CreateNewAppFix(
    void
    )
/*++
    
    CreateNewAppFix
    
    Desc:   Creates a new application fix.
    
--*/
{
    CShimWizard Wiz;
    BOOL        bShouldStartLUAWizard;
    PDATABASE   pCurrentSelectedDB  = GetCurrentDB();
    BOOL        bReturn             = FALSE;
    PDBENTRY    pEntryConflict      = NULL;

    if (pCurrentSelectedDB == NULL) {
        assert(FALSE);
        return;
    }
    
    bReturn = Wiz.BeginWizard(g_hDlg, NULL, pCurrentSelectedDB, &bShouldStartLUAWizard);

    if (bReturn == FALSE) {
        return;
    }
    
    if (CheckIfConflictingEntry(pCurrentSelectedDB, 
                                &Wiz.m_Entry, 
                                NULL, 
                                &pEntryConflict)) {

        *g_szData = 0;

        StringCchPrintf(g_szData, 
                        ARRAYSIZE(g_szData),
                        GetString(IDS_CONFLICT_CREATE_EDIT), 
                        pEntryConflict->strExeName.pszString,
                        pEntryConflict->strAppName.pszString);
        
        if (IDNO == MessageBox(g_hDlg,
                               g_szData,
                               g_szAppName,
                               MB_ICONQUESTION | MB_YESNO)) {
            return;
        }
    }

    PDBENTRY pEntry = new DBENTRY;

    if (pEntry == NULL) {
        MEM_ERR;
        return;
    }

    //
    // "=" is overloaded. Does not modify the pNext member.
    //
    *pEntry = Wiz.m_Entry;

    BOOL bNew;
    PDBENTRY pApp = AddExeInApp(pEntry, &bNew, pCurrentSelectedDB);

    if (bNew == TRUE) {
        pApp = NULL;
    }

    DBTree.AddNewExe(pCurrentSelectedDB, pEntry, pApp);

    if (!pCurrentSelectedDB->bChanged) {
        pCurrentSelectedDB->bChanged = TRUE;
        SetCaption();
    }

    if (bShouldStartLUAWizard) {
        LuaBeginWizard(g_hDlg, pEntry, pCurrentSelectedDB);
    }
}

void
ChangeEnableStatus(
    void
    )
/*++
    
    ChangeEnableStatus
    
    Desc:   Toggles the status of the presently selected entry. 
            If the entry is disabled, the fixes will no longer be applied to it.
            
    Notes:   No point in calling this function if the user is not an admin
            
--*/
{
    if (g_pSelEntry == NULL) {
        ASSERT(FALSE);
        return;
    }

    BOOL bFlags = !g_pSelEntry->bDisablePerMachine;

    if (SetDisabledStatus(HKEY_LOCAL_MACHINE, g_pSelEntry->szGUID, bFlags)) {

        if (bFlags == FALSE) {
            //
            // We have enabled the fix, we need too flush the cache
            //
            FlushCache();
        }

        g_pSelEntry->bDisablePerMachine = bFlags;
        
        //
        // Just update the icon
        //
        TVITEM Item;

        Item.mask           = TVIF_SELECTEDIMAGE | TVIF_IMAGE;
        Item.hItem          = g_pSelEntry->hItemExe;

        if (bFlags) {

            //
            // This is disabled
            //
            Item.iImage         = IMAGE_WARNING;
            Item.iSelectedImage = IMAGE_WARNING;
            SetStatus(GetString(IDS_STA_DISABLED));

        } else {

            Item.iImage = LookupFileImage(g_hImageList, 
                                          g_pSelEntry->strExeName, 
                                          IMAGE_APPLICATION, 
                                          g_uImageRedirector, 
                                          ARRAYSIZE(g_uImageRedirector));

            Item.iSelectedImage = Item.iImage;

            SetStatus(GetString(IDS_STA_ENABLED));
        }

        TreeView_SetItem(g_hwndEntryTree, &Item);
    }

    return;
}

void
ModifyAppFix(
    void
    )
/*++
    ModifyAppFix
    
    Desc:   Modifies the selected entry in the Entry Tree. This routine will either modify the
            app fix or might create a new one if the selected entry had only AppHelp.
            
            This routine calls the CShimWizard::BeginWizard to do the job
--*/    
{   
    
    CShimWizard Wiz;
    BOOL        bShouldStartLUAWizard;
    PDBENTRY    pEntryConflict      = NULL;
    PDBENTRY    pEntry              = g_pSelEntry;
    PDATABASE   pCurrentSelectedDB  = GetCurrentDB();
    BOOL        bRet                = FALSE;

    if (g_pSelEntry == NULL || pCurrentSelectedDB == NULL) {
        assert(FALSE);
        return;
    }

    bRet = Wiz.BeginWizard(g_hDlg, pEntry, pCurrentSelectedDB, &bShouldStartLUAWizard);

    if (bRet) {

        if (CheckIfConflictingEntry(pCurrentSelectedDB, 
                                    &Wiz.m_Entry, 
                                    pEntry, 
                                    &pEntryConflict)) {

            *g_szData = 0;

            StringCchPrintf(g_szData, 
                            ARRAYSIZE(g_szData),
                            GetString(IDS_CONFLICT_CREATE_EDIT), 
                            pEntryConflict->strExeName.pszString,
                            pEntryConflict->strAppName.pszString);

            if (IDNO == MessageBox(g_hDlg,
                                   g_szData,
                                   g_szAppName,
                                   MB_ICONQUESTION | MB_YESNO)) {
                return;
            }
        }

        SetCursor(LoadCursor(NULL, IDC_WAIT));

        *pEntry = Wiz.m_Entry;

        UpdateEntryTreeView(g_pEntrySelApp, g_hwndEntryTree);

        SetCursor(LoadCursor(NULL, IDC_ARROW));

        if (!pCurrentSelectedDB->bChanged) {
            pCurrentSelectedDB->bChanged = TRUE;
            SetCaption();
        }

        if (bShouldStartLUAWizard) {
            LuaBeginWizard(g_hDlg, pEntry, pCurrentSelectedDB);
        }
    }

    return;
}

void
CreateNewLayer(
    void
    )
/*++
    
    CreateNewLayer
    
    Desc:   Calls CCustomLayer::AddCustomLayer to create a new layer (compatibility mode)
            Calls DBTree.AddNewLayer() to add the new layer to the tree
--*/
{
    CCustomLayer    CustomLayer;
    HWND            hWnd                = GetFocus();
    PDATABASE       pCurrentSelectedDB  = GetCurrentDB();
    PLAYER_FIX      plfNew              = NULL;

    if (pCurrentSelectedDB == NULL) {
        assert(FALSE);
        return;
    }

    plfNew = new LAYER_FIX(TRUE);

    if (plfNew == NULL) {
        MEM_ERR;
        return;
    }

    if (CustomLayer.AddCustomLayer(plfNew, pCurrentSelectedDB)) {
        //
        // Add this new layer in the datbase.
        //
        plfNew->pNext                   =  pCurrentSelectedDB->pLayerFixes;
        pCurrentSelectedDB->pLayerFixes = plfNew;
        
        if (!pCurrentSelectedDB->bChanged) {
            pCurrentSelectedDB->bChanged = TRUE;
            SetCaption();
        }
        
        DBTree.AddNewLayer(pCurrentSelectedDB, plfNew, TRUE);

    } else {
        delete plfNew;
    }

    SetFocus(hWnd);
}

void
OnDelete(
    void
    )
/*++
    OnDelete
    
    Desc:   Handles the ID_EDIT_DELETE message to delete an entry.
            The entry can be either in the entry-tree, db tree or the contents list.
--*/
{
    HWND        hwndFocus = GetFocus();
    SOURCE_TYPE srcType;
    HTREEITEM   hItem = NULL;
    PDATABASE   pCurrentSelectedDB  = GetCurrentDB();

    if (pCurrentSelectedDB == NULL) {
        assert(FALSE);
        return;
    }

    if (hwndFocus == DBTree.m_hLibraryTree || hwndFocus == g_hwndEntryTree) {

        hItem = TreeView_GetSelection(hwndFocus);

        TYPE type = (TYPE)GetItemType(hwndFocus, hItem);
        
        if (hwndFocus == g_hwndEntryTree) {
             srcType = ENTRY_TREE;
        } else {
            srcType  = LIB_TREE;
        }

        LPARAM lParam;

        CTree::GetLParam(hwndFocus, hItem, &lParam);
        DoTheCut(pCurrentSelectedDB, type, srcType, (LPVOID)lParam, hItem, TRUE);
        
    } else {
        //
        // Handle delete for the contents list.
        //
        HTREEITEM   hParent = NULL;
        LVITEM      lvItem;
        TYPE        type;

        lvItem.mask     = LVIF_PARAM;
        lvItem.iItem    = 0;

        if (!ListView_GetItem(g_hwndContentsList, &lvItem)) {
            assert(FALSE);
            return;
        }

        if (lvItem.lParam > TYPE_NULL) {
            PDS_TYPE pdsType = (PDS_TYPE)lvItem.lParam;
            type = pdsType->type;
        } else {
            type = (TYPE)lvItem.lParam;
        }

        if (type == TYPE_ENTRY) {
            hParent = pCurrentSelectedDB->hItemAllApps;

        } else if (type == FIX_LAYER) {
            hParent = pCurrentSelectedDB->hItemAllLayers;

        } else {
            assert(FALSE);
            return;
        }

        //
        // Get the selected items and then delete them
        //
        UINT uSelectedCount = ListView_GetSelectedCount(g_hwndContentsList);
        INT  iLastIndex     = ListView_GetItemCount(g_hwndContentsList) - 1;

        lvItem.mask         = LVIF_PARAM | LVIF_STATE;
        lvItem.stateMask    = LVIS_SELECTED;
        
        for (UINT uFoundSelected = 1;
             iLastIndex >= 0 && uFoundSelected <= uSelectedCount;
             --iLastIndex) {

            lvItem.iItem       = iLastIndex;
            lvItem.iSubItem    = 0;

            if (!ListView_GetItem(g_hwndContentsList, &lvItem)) {
                assert(FALSE);
                break;
            }
            
            if (lvItem.state & LVIS_SELECTED) {

                hItem = DBTree.FindChild(hParent, lvItem.lParam);
                assert(hItem);
                
                DoTheCut(pCurrentSelectedDB, type, ENTRY_LIST, (LPVOID)lvItem.lParam, hItem, TRUE);
                
                uFoundSelected++;
            }
        }
    }

    pCurrentSelectedDB->bChanged = TRUE;

    SetCaption(TRUE, pCurrentSelectedDB);
}

void
CreateNewDatabase(
    void
    )
/*++
    
    CreateNewDatabase
    
    Desc:   Creates a new database and adds it to the db tree 
            calling DBTree.AddWorking()
--*/
{
    PDATABASE pDatabaseNew = new DATABASE(DATABASE_TYPE_WORKING);

    if (pDatabaseNew == NULL) {
        MEM_ERR;
        return;
    }

    pDatabaseNew->bChanged = FALSE;

    DataBaseList.Add(pDatabaseNew);
    
    g_pEntrySelApp = g_pSelEntry = NULL;
    SetCaption();

    ++g_uNextDataBaseIndex;

    //
    // Now update the screen
    //
    DBTree.AddWorking(pDatabaseNew);

    TreeDeleteAll(g_hwndEntryTree);

    SetFocus(DBTree.m_hLibraryTree);
}

void
OnDatabaseClose(
    void
    )
/*++
    OnDatabaseClose

    Desc:   Calls CloseDataBase to close a database. 
            This is called on ID_DATABASE_CLOSE message
            
--*/
{
    PDATABASE   pCurrentSelectedDB  = GetCurrentDB();

    if (pCurrentSelectedDB == NULL) {
        
        MessageBox(g_hDlg,
                   GetString(IDS_CANNOTBECLOSED),
                   g_szAppName,
                   MB_ICONWARNING);
        return;
    }

    TYPE typeDB = pCurrentSelectedDB->type;

    if (typeDB == DATABASE_TYPE_WORKING) {
        CloseDataBase(pCurrentSelectedDB);
    }
}

void
DatabaseSaveAll(
    void
    )
/*++
    
    DatabaseSaveAll
    
    Desc:   Saves all the working databases
    
--*/
{
    PDATABASE g_pOldPresentDataBase = g_pPresentDataBase;

    g_pPresentDataBase = DataBaseList.pDataBaseHead;

    while (g_pPresentDataBase) {
       
        if (g_pPresentDataBase->bChanged 
            || NotCompletePath(g_pPresentDataBase->strPath)) {

            BOOL bReturn = TRUE;

            if (NotCompletePath(g_pPresentDataBase->strPath)) {
                bReturn = SaveDataBaseAs(g_pPresentDataBase);
            } else {
                bReturn = SaveDataBase(g_pPresentDataBase, 
                                       g_pPresentDataBase->strPath);
            }

            if (bReturn == FALSE) {

                CSTRING strMessage;
                strMessage.Sprintf(GetString(IDS_NOTSAVED), g_pPresentDataBase->strName);

                if (g_hDlg && strMessage.pszString) {
                    MessageBox(g_hDlg,
                               strMessage.pszString,
                               g_szAppName,
                               MB_ICONWARNING);
                }
            }
        }

        g_pPresentDataBase = g_pPresentDataBase->pNext;
    }

    g_pPresentDataBase = g_pOldPresentDataBase;

    if (g_pPresentDataBase) {
        TreeView_SelectItem(DBTree.m_hLibraryTree, g_pPresentDataBase->hItemDB);
    } else {
        TreeView_SelectItem(DBTree.m_hLibraryTree, DBTree.m_hLibraryTree);
    }
}

BOOL
ModifyLayer(
    void
    )
/*++
    ModifyLayer
    
    Desc:   Modifies a layer. Calls CustomLayer.EditCustomLayer to do the actual job
--*/
{
    CCustomLayer    clayer;
    BOOL            bOk = FALSE;
    HWND            hwndGetFocus = GetFocus();
    PDATABASE       pCurrentSelectedDB  = GetCurrentDB();

    if (hwndGetFocus == DBTree.m_hLibraryTree) {
        
        HTREEITEM hSelectedItem = TreeView_GetSelection(hwndGetFocus);

        if (hSelectedItem && GetItemType(DBTree.m_hLibraryTree, hSelectedItem) == FIX_LAYER) {
            
            LPARAM lParamMode;
            
            if (DBTree.GetLParam(hSelectedItem, &lParamMode)) {
                bOk =  clayer.EditCustomLayer((PLAYER_FIX)lParamMode, pCurrentSelectedDB);  
            }

            if (bOk) {
                //
                // We have to refresh all the layers. We have to refresh all the layers
                // Because the UI provides the user the flexibility to edit more than one layer :(
                //
                if (!pCurrentSelectedDB->bChanged) {
                    pCurrentSelectedDB->bChanged = TRUE;
                    SetCaption();
                }

                DBTree.RefreshAllLayers(pCurrentSelectedDB);

                hSelectedItem = DBTree.FindChild(pCurrentSelectedDB->hItemAllLayers,
                                                 lParamMode);

                TreeView_SelectItem(DBTree.m_hLibraryTree, hSelectedItem);
                SetStatusStringDBTree(hSelectedItem);
            }
        }
    }
    
    SetFocus(hwndGetFocus);
    return bOk;
}

void    
OnRename(
    void
    )
/*++
    OnRename
    
    Desc:   Processes the ID_EDIT_RENAME message to handle renaming of databases, 
            compatibility modes and applications.
--*/
{
    HWND    hwndFocus = GetFocus();
    INT_PTR iStyle;
    TYPE    type;
    
    if (hwndFocus == DBTree.m_hLibraryTree) {
    
        HTREEITEM hItemSelected = TreeView_GetSelection(hwndFocus);
    
        if (hItemSelected == NULL) {
            return;
        }
    
        iStyle = GetWindowLongPtr(hwndFocus, GWL_STYLE);
        iStyle |= TVS_EDITLABELS;
    
        SetWindowLongPtr(hwndFocus, GWL_STYLE, iStyle);
    
        HWND hwndText = NULL;
        type = (TYPE)GetItemType(hwndFocus, hItemSelected); 
    
        switch(type) {
        case TYPE_ENTRY:
        case FIX_LAYER:
        case DATABASE_TYPE_WORKING:
            
            hwndText = TreeView_EditLabel(hwndFocus, hItemSelected);
            break;
        }

    } else if (hwndFocus == g_hwndContentsList) {
    
        INT iSelected = ListView_GetSelectionMark(g_hwndContentsList);
    
        if (iSelected == -1) {
            return;
        }
    
        iStyle = GetWindowLongPtr(hwndFocus, GWL_STYLE);
        iStyle |= LVS_EDITLABELS;
    
        SetWindowLongPtr(hwndFocus, GWL_STYLE, iStyle);
    
        LVITEM lvItem;

        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;
        lvItem.iSubItem = 0;
    
        if(!ListView_GetItem(g_hwndContentsList, &lvItem)) {
            return;
        }

        assert(lvItem.lParam);
    
        type = (TYPE)ConvertLparam2Type(lvItem.lParam);

        if (type == TYPE_ENTRY || type == FIX_LAYER) {
            ListView_EditLabel(g_hwndContentsList, iSelected);
        }
    }
}

INT_PTR
ShowDBPropertiesDlgProcOnInitDialog(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++

    ShowDBPropertiesDlgProcOnInitDialog
    
    Desc:   Handles the WM_INITDIALOG for the database properties dialog box
    
    Params:
        IN  HWND    hdlg:   The database properties dialog box
        IN  LPARAM  lParam: The database pointer whose properties we want to see
        
    Return:
        TRUE
    
--*/
{
    PDATABASE                   pDatabase = (PDATABASE)lParam;
    FILETIME                    localtime;
    SYSTEMTIME                  systime;
    WIN32_FILE_ATTRIBUTE_DATA   attr;
    TCHAR                       szBuffer[MAX_PATH];
    PDBENTRY                    pApp;
    PDBENTRY                    pEntry;
    INT                         iAppCount   = 0;
    INT                         iEntryCount = 0;

    *szBuffer = 0;

    if (pDatabase == NULL) {
        assert(FALSE);
        goto End;
    }

    //
    // If we are trying to show the properties of the system database, the apps must be 
    // loaded first
    //
    if (pDatabase->type == DATABASE_TYPE_GLOBAL && !g_bMainAppExpanded) {

        SetCursor(LoadCursor(NULL, IDC_WAIT));
        INT iResult = ShowMainEntries(hdlg);

        if (iResult == -1) {

            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
            SetStatus(g_hwndStatus, CSTRING(IDS_LOADINGMAIN));
            SetCursor(LoadCursor(NULL, IDC_WAIT));

        } else {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
    }

    //
    // Show the friendly name
    //
    SetDlgItemText(hdlg, IDC_NAME, pDatabase->strName);

    //
    // Show the path
    //
    SetDlgItemText(hdlg, IDC_PATH, pDatabase->strPath);

    //
    // Show the GUID
    //
    SetDlgItemText(hdlg, IDC_GUID, pDatabase->szGUID);

    //
    // Show the various dates: creation, modification and access dates
    //
    if (GetFileAttributesEx(pDatabase->strPath, GetFileExInfoStandard, &attr)) {

        //
        // Creation date-time
        //
        FileTimeToLocalFileTime(&attr.ftCreationTime, &localtime);
        FileTimeToSystemTime(&localtime, &systime);
        FormatDate(&systime, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hdlg, IDC_DATE_CREATED, szBuffer);

        //
        // Modification date-time
        //
        FileTimeToLocalFileTime(&attr.ftLastWriteTime, &localtime);
        FileTimeToSystemTime(&localtime, &systime);
        FormatDate(&systime, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hdlg, IDC_DATE_MODIFIED, szBuffer);

        //
        // Access date-time
        //
        FileTimeToLocalFileTime(&attr.ftLastAccessTime, &localtime);
        FileTimeToSystemTime(&localtime, &systime);
        FormatDate(&systime, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hdlg, IDC_DATE_ACCESSED, szBuffer);

    } else {

        //
        // New database: does not exist on disk.
        //
        SetDlgItemText(hdlg, IDC_DATE_CREATED, GetString(IDS_NOTCREATED));
        SetDlgItemText(hdlg, IDC_DATE_MODIFIED, TEXT(""));
        SetDlgItemText(hdlg, IDC_DATE_ACCESSED, TEXT(""));
    }
    
    //
    // Get Application count and entry count
    //
    pApp = pDatabase->pEntries;

    while (pApp) {

        ++iAppCount;
        pEntry = pApp;

        while (pEntry) {
            iEntryCount++;
            pEntry = pEntry->pSameAppExe;
        }

        pApp = pApp->pNext;
    }

    //
    // App-Count
    //
    *szBuffer = 0;
    SetDlgItemText(hdlg, IDC_APP_COUNT, _itot(iAppCount, szBuffer, 10));

    //
    // Entry-Count
    //
    *szBuffer = 0;
    SetDlgItemText(hdlg, IDC_ENTRY_COUNT, _itot(iEntryCount, szBuffer, 10));

    //
    // Get the number of custom compatibility modes
    //
    INT         iModeCount = 0;
    PLAYER_FIX  plf        = pDatabase->pLayerFixes; 

    while (plf) {
        ++iModeCount;
        plf = plf->pNext;
    }

    //
    // Layer count 
    //

    *szBuffer = 0;
    SetDlgItemText(hdlg, IDC_MODE_COUNT, _itot(iModeCount, szBuffer, 10));
    

    //
    // We need to have protected access because, the installed list data structure 
    // might get modified if somebody does a (un)install when we are iterating
    // the list in CheckIfInstalledDB()
    //
    // ********** Warning *****************************************************
    //
    // Do not do EnterCriticalSection(g_csInstalledList) in CheckIfInstalledDB()
    // because CheckIfInstalledDB() is called by Qyery db as well when it tries
    // to evaluate expressions and it might already have done a 
    // EnterCriticalSection(g_csInstalledList)
    // and then we will get a deadlock
    //
    // *************************************************************************
    //
    EnterCriticalSection(&g_csInstalledList);
    //
    // Installed
    //
    SetDlgItemText(hdlg, 
                   IDC_INSTALLED, 
                   CheckIfInstalledDB(pDatabase->szGUID) ? GetString(IDS_YES):GetString(IDS_NO));

    LeaveCriticalSection(&g_csInstalledList);

End:

    return TRUE;
}

INT_PTR 
CALLBACK
ShowDBPropertiesDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++

    ShowDBPropertiesDlgProc
    
    Desc:   Shows the properties of the selected database
            
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam: contains the pointer to the selected database
        
    Return: Standard dialog handler return
    
--*/
{
    int wCode       = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:

        ShowDBPropertiesDlgProcOnInitDialog(hdlg, lParam);
        break;

    case WM_COMMAND:
        {
            switch (wCode) {
                case IDOK:
                case IDCANCEL:
                    
                    EndDialog(hdlg, TRUE);
                    break;

                default: return FALSE;
            }

            break;
        }

    default: return FALSE;

    }

    return TRUE;
}

INT_PTR 
CALLBACK
EventDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++
    Desc:   Dialog Proc for the events dialog.
    
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            g_hwndEventsWnd = hdlg;

            HWND hwndEventsList = GetDlgItem(g_hwndEventsWnd, IDC_LIST);
            g_iEventCount    = 0;

            ListView_SetImageList(hwndEventsList, g_hImageList, LVSIL_SMALL);

            ListView_SetExtendedListViewStyleEx(hwndEventsList,
                                                0,
                                                LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);

            InsertColumnIntoListView(hwndEventsList, 
                                     GetString(IDS_EVENT_COL_TIME), 
                                     EVENTS_COLUMN_TIME, 
                                     30);

            InsertColumnIntoListView(hwndEventsList, 
                                     GetString(IDS_EVENT_COL_MSG), 
                                     EVENTS_COLUMN_MSG, 
                                     70);

            ListView_SetColumnWidth(hwndEventsList, 1, LVSCW_AUTOSIZE_USEHEADER);

            RECT    r;

            GetWindowRect(hdlg,  &r);
            s_cEventWidth   = r.right - r.left;
            s_cEventHeight  = r.bottom - r.top;

            //
            // Disable the min/maximize menu in the system window. This is needed because otherwise
            // the user can minimize the events window and if he maximizes and restores the 
            // main window, our events window will  pop-up.
            //
            // The events window gets popped up if it has been created when we do a restore
            // for the main window
            //
            HMENU   hSysmenu = GetSystemMenu(hdlg, FALSE);

            EnableMenuItem(hSysmenu, SC_MINIMIZE, MF_GRAYED);
            EnableMenuItem(hSysmenu, SC_MAXIMIZE, MF_GRAYED);

            SetFocus(hwndEventsList);
            break;
        }

    case WM_SIZE:

        EventsWindowSize(hdlg);
        break;

    case WM_GETMINMAXINFO:
        {
            MINMAXINFO* pmmi = (MINMAXINFO*)lParam;
        
            pmmi->ptMinTrackSize.x = 300;
            pmmi->ptMinTrackSize.y = 100;
        
            return 0;
        }

    case WM_COMMAND:

        switch (wCode) {
        case IDCANCEL:

            g_hwndEventsWnd = NULL;
            DestroyWindow(hdlg);
            break;

        default: return FALSE;
        }

        break;

    default: return FALSE;
    }

    return TRUE;
}

BOOL
AppendEvent(
    IN  INT     iType,
    IN  TCHAR*  pszTimestamp,
    IN  TCHAR*  pszMsg,
    IN  BOOL    bAddToFile // DEF = FALSE
    )
/*++
    
    AppendEvent
    
    Desc:   Adds a new description to the events window, if it is visible also opens
            events log file and appends it to that
            
    Params:
        IN  INT     iType: The type of the event.
        
                One of: EVENT_LAYER_COPYOK
                        EVENT_ENTRY_COPYOK 
                        EVENT_SYSTEM_RENAME
                        EVENT_CONFLICT_ENTRY
            
        IN  TCHAR*  pszTimestamp:       Timestamp when the event occurred
        IN  TCHAR*  pszMsg:             The message to be displayed      
        IN  BOOL    bAddToFile(FALSE):  Whether we want to append the event to the log file
                As of now always FALSE
--*/
{
    TCHAR   szTime[256];
    LVITEM  lvi;
    INT     iIndex = -1;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask    = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;                                 

    if (pszTimestamp == NULL) {
        //
        // Get the time
        //
        SYSTEMTIME st;
        GetLocalTime(&st);
        
        *szTime = 0;
        FormatDate(&st, szTime, ARRAYSIZE(szTime));
        pszTimestamp = szTime;
    }

    if (g_hwndEventsWnd) {

        HWND hwndEventsList = GetDlgItem(g_hwndEventsWnd, IDC_LIST);

        switch (iType) {
        
        case EVENT_LAYER_COPYOK:
        case EVENT_ENTRY_COPYOK:  

            lvi.iImage = IMAGE_EVENT_INFO;
            break;

        case EVENT_SYSTEM_RENAME: 

            lvi.iImage = IMAGE_EVENT_WARNING;
            break;

        case EVENT_CONFLICT_ENTRY:

            lvi.iImage    = IMAGE_EVENT_ERROR;
            break;
        }
        
        lvi.pszText     = pszTimestamp;
        lvi.iSubItem    = EVENTS_COLUMN_TIME;
        lvi.lParam      = iType;
        lvi.iItem       = 0;

        iIndex = ListView_InsertItem(hwndEventsList, &lvi);
        ListView_SetItemText(hwndEventsList, iIndex, EVENTS_COLUMN_MSG, pszMsg);
    }

    if (bAddToFile) {
        //
        // So append this to the file
        //
        FILE*   fp = _tfopen(TEXT("events.log"), TEXT("a+"));
        
        if (fp == NULL) {
            return FALSE;
        }
        
        fwprintf(fp, TEXT("%d %s; %s;"), iType, pszTimestamp, pszMsg);
        fclose(fp);
    }

    return TRUE;
}

void
EventsWindowSize(
    IN  HWND    hDlg
    )
/*++
    Desc:   Handles the WM_SIZE for the event dialog
    
    Params: 
        IN  HWND    hDlg: The events dialog
--*/
{
    
    RECT rDlg;
    
    if (s_cEventHeight == 0 || s_cEventWidth == 0) {
        return;
    }
        
    GetWindowRect(hDlg, &rDlg);

    int nWidth = rDlg.right - rDlg.left;
    int nHeight = rDlg.bottom - rDlg.top;

    int deltaW = nWidth - s_cEventWidth;
    int deltaH = nHeight - s_cEventHeight;

    HWND hwnd;
    RECT r;

    //
    // List
    //
    hwnd = GetDlgItem(hDlg, IDC_LIST);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left,
               r.top,
               r.right - r.left + deltaW,
               r.bottom - r.top + deltaH,
               TRUE);

    s_cEventHeight  = nHeight;
    s_cEventWidth   = nWidth;
    ListView_SetColumnWidth(hwnd, 1, LVSCW_AUTOSIZE_USEHEADER);
}

void
UpdateControls(
    void
    )
/*++

    UpdateControls
    
    Desc:   Updates/redraws the controls when we need to update them, this will be needed 
            when we show the save as dialog box or the open dialog box. 
            The controls below the dialog box need to be repainted.
--*/
{
    UpdateWindow(DBTree.m_hLibraryTree);
    UpdateWindow(g_hwndToolBar);
    UpdateWindow(g_hwndStatus);
    UpdateWindow(g_hwndRichEdit);

    if (g_bIsContentListVisible) {
       UpdateWindow(g_hwndContentsList);
    } else {
       UpdateWindow(g_hwndEntryTree);
    }
}

void
ProcessSwitches(
    void
    )
/*++

    ProcessSwitches
    
    Desc:   Processes the various switches. The switches have to be prefixed with 
            either a '-' or a '/'
            Present switches are:
                1. x: Expert mode
--*/
{
    INT     iArgc       = 0;
    LPWSTR* arParams    = CommandLineToArgvW(GetCommandLineW(), &iArgc);
        
    if (arParams) {

        *g_szAppPath = 0;

        GetModuleFileName(g_hInstance, g_szAppPath, ARRAYSIZE(g_szAppPath) - 1);

        for (int iIndex = 1; iIndex < iArgc; ++iIndex) {

            if (arParams[iIndex][0] == TEXT('-') || arParams[iIndex][0] == TEXT('/')) {

                switch (arParams[iIndex][1]) {
                case TEXT('X'):
                case TEXT('x'):

                    g_bExpert = TRUE;
                    break;
                }
            }
        }
        
        GlobalFree(arParams);
    }
}

void
OnExitCleanup(
    void
    )
/*++
    OnExitCleanup
    
    Desc:   Does cleaning up of critical sections, other stuff.
            This module is called when we are sure that we are going to exit            
            
--*/
{
    g_strlMRU.DeleteAll();

    InstalledDataBaseList.RemoveAll();
    CleanupDbSupport(&GlobalDataBase);

    //
    // NOTE:    It is possible that after we have deleted the cs, some other thread might try
    //          to use it.
    //          So this function should not be called in the release bits.
    //          HELP_BOUND_CHECK should not be defined.        
    //
    DeleteCriticalSection(&g_critsectShowMain);
    DeleteCriticalSection(&s_csExpanding);
    DeleteCriticalSection(&g_csInstalledList);

    if (g_arrhEventNotify[IND_PERUSER]) {
        CloseHandle(g_arrhEventNotify[IND_PERUSER]);
    }

    if (g_arrhEventNotify[IND_ALLUSERS]) {
        CloseHandle(g_arrhEventNotify[IND_ALLUSERS]);
    }

    if (g_hThreadWait) {
        CloseHandle(g_hThreadWait);
    }

    ImageList_Destroy(g_hImageList);
    ImageList_Destroy(s_hImageListToolBar);
    ImageList_Destroy(s_hImageListToolBarHot);
}

void
ShowIncludeStatusMessage(
    IN  HWND        hwndTree,
    IN  HTREEITEM   hItem
    )
/*++

    ShowIncludeStatusMessage
    
    Desc: Sets the status message when the htree item in question is an "include" item
    
    Params:
        IN  HWND        hwndTree:   The handle to the tree. Should be one of
                g_hwndTree or DBTree.m_hLibraryTree
                
        IN  HTREEITEM   hItem:      The tree-item for which we need the status message
--*/
{
    TVITEM  tvi;

    *g_szData       = 0;

    tvi.mask        = TVIF_TEXT;
    tvi.hItem       = hItem;
    tvi.pszText     = g_szData;
    tvi.cchTextMax  = ARRAYSIZE(g_szData);

    if (TreeView_GetItem(hwndTree, &tvi)) {
        //
        // Special status messages if we have * or .EXE
        //
        if (lstrcmpi(g_szData, TEXT("*")) == 0) {
            SetStatus(IDS_STA_ALL_INCLUDED);

        } else if (lstrcmpi(g_szData, GetString(IDS_INCLUDEMODULE)) == 0) {
            SetStatus(IDS_STA_EXE_INCLUDED);

        } else {
            //
            // Default inlude message
            //
            SetStatus(IDS_STA_INCLUDE);
        }
    }
}
    
void
ShowExcludeStatusMessage(
    IN  HWND        hwndTree,
    IN  HTREEITEM   hItem
    )
/*++
    
    ShowExcludeStatusMessage
    
    Desc:   Sets the status message when the htree item in question is a "exclude" item
    
    Params:
        IN  HWND        hwndTree:   The handle to the tree. Should be one of
            g_hwndTree or DBTree.m_hLibraryTree
                
        IN  HTREEITEM   hItem:      The tree-item for which we need the status message
--*/
{
    TVITEM  tvi;

    *g_szData       = 0;
    tvi.mask        = TVIF_TEXT;
    tvi.hItem       = hItem;
    tvi.pszText     = g_szData;
    tvi.cchTextMax  = ARRAYSIZE(g_szData);

    if (TreeView_GetItem(DBTree.m_hLibraryTree, &tvi)) {
        //
        // Special status messages if we have * or .EXE
        //
        if (lstrcmpi(g_szData, TEXT("*")) == 0) {
            SetStatus(IDS_STA_ALL_EXCLUDED);
        } else if (lstrcmpi(g_szData, GetString(IDS_INCLUDEMODULE)) == 0) {
            SetStatus(IDS_STA_EXE_EXCLUDED);
        } else {
            //
            // Default exclude message
            //
            SetStatus(IDS_STA_EXCLUDE);
        }
    }
}

void
ShowHelp(
    IN  HWND    hdlg,
    IN  WPARAM  wCode
    )
/*++

    ShowHelp

	Desc:	Shows the help window(s) for CompatAdmin

	Params:
        IN  HWND    hdlg:   The main app window
        IN  WPARAM  wCode:  The menu item chosen

	Return:
        void
--*/
{
    TCHAR   szDrive[MAX_PATH * 2], szDir[MAX_PATH]; 
    INT     iType = 0;

    *szDir = *szDrive = 0;

    _tsplitpath(g_szAppPath, szDrive, szDir, NULL, NULL);

    StringCchCat(szDrive, ARRAYSIZE(szDrive), szDir);
    StringCchCat(szDrive, ARRAYSIZE(szDrive), TEXT("CompatAdmin.chm"));

    switch (wCode) {
    case ID_HELP_TOPICS:

        iType = HH_DISPLAY_TOC;
        break;

    case ID_HELP_INDEX:

        iType = HH_DISPLAY_INDEX;
        break;

    case ID_HELP_SEARCH:

        iType = HH_DISPLAY_SEARCH;
        break;

    default:

        assert(FALSE);
        break;
    }

    if (iType != HH_DISPLAY_SEARCH) {
        HtmlHelp(GetDesktopWindow(), szDrive, iType, 0);
    } else {
        
        HH_FTS_QUERY Query;

        ZeroMemory(&Query, sizeof(Query));
        Query.cbStruct = sizeof(Query);
        HtmlHelp(GetDesktopWindow(), szDrive, iType, (DWORD_PTR)&Query);
    }
}

void
ShowEventsWindow(
    void
    )
/*++
    ShowEventsWindow

	Desc:	Shows the events window. (This is not the same as the shim log)

	Params: 
        void

	Return:
        void
--*/
{
    HWND hwnd = NULL;

    if (g_hwndEventsWnd) {
        //
        // If we have the events window already, then just display it and 
        // set the focus to it
        //
        ShowWindow(g_hwndEventsWnd, SW_SHOWNORMAL);
        SetFocus(GetDlgItem(g_hwndEventsWnd, IDC_LIST));
    } else {
        //
        // We need to create the events window
        //
        hwnd = CreateDialog(g_hInstance, 
                            MAKEINTRESOURCE(IDD_EVENTS), 
                            GetDesktopWindow(), 
                            EventDlgProc);

        ShowWindow(hwnd, SW_NORMAL);
    }
}

void
OnEntryTreeSelChange(
    IN  LPARAM lParam
    )
/*++
    
    OnEntryTreeSelChange

	Desc:	Handles the TVN_SELCHANGED for the entry tree (RHS)

	Params:
        IN  LPARAM lParam: The lParam that comes with WM_NOTIFY

	Return:
        void
--*/
{   
    LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
    
    if (pnmtv == NULL) {
        return;
    }

    HTREEITEM hItem = pnmtv->itemNew.hItem;

    if (hItem != 0) {
        //
        // Now we have to find the root entry, because that is the exe
        //
        HTREEITEM hItemParent = TreeView_GetParent(g_hwndEntryTree, hItem);

        while (hItemParent != NULL) {
            hItem       = hItemParent;
            hItemParent = TreeView_GetParent(g_hwndEntryTree, hItem);
        }

        TVITEM  Item;

        Item.mask   = TVIF_PARAM;
        Item.hItem  = hItem;
        
        if (!TreeView_GetItem(g_hwndEntryTree, &Item)) {
            goto End;
        }

        TYPE type = (TYPE)GetItemType(g_hwndEntryTree, hItem);

        if (type == TYPE_UNKNOWN) {
            goto End;
        }

        if (type == TYPE_ENTRY) {
            PDBENTRY pEntry = (PDBENTRY)Item.lParam;
            g_pSelEntry = pEntry;
        } else {
            //
            // CAUTION: Note that when we shut down CompatAdmin, then it is possible
            //          that we have deleted all the entries from the database, but not
            //          from the entry tree. In this case if we get focus there then  
            //          the lParam will point to some invalid entry.
            //
            goto End;
        }

        SetStatusStringEntryTree(pnmtv->itemNew.hItem);
        SetTBButtonStatus(g_hwndToolBar, g_hwndEntryTree);
        
        CSTRING strToolTip;
        TCHAR   szText[256];
        *szText = 0;
        CTree::GetTreeItemText(g_hwndEntryTree, 
                               pnmtv->itemNew.hItem, 
                               szText, 
                               ARRAYSIZE(szText));

        LPARAM  lParamTreeItem;

        CTree::GetLParam(g_hwndEntryTree, pnmtv->itemNew.hItem, &lParamTreeItem);

        GetDescriptionString(lParamTreeItem, 
                             strToolTip,
                             NULL,
                             szText,
                             pnmtv->itemNew.hItem,
                             g_hwndEntryTree); 

        if (strToolTip.Length() > 0) {
            SetDescription(szText, strToolTip.pszString);
        } else {
            SetDescription(NULL, TEXT(""));
        }
    }

End:
    return;
}

BOOL
EndListViewLabelEdit(
    IN  LPARAM lParam
    )
/*++

    EndListViewLabelEdit

	Desc:	Processes LVN_ENDLABELEDIT message for the contents list

	Params:
        EndListViewLabelEdit: The lParam that comes with WM_NOTIFY

	Return:
        void
--*/
{
    g_hwndEditText = NULL;

    NMLVDISPINFO FAR*   pLvd =  (NMLVDISPINFO FAR*)lParam;
    LVITEM              lvItem;

    BOOL fValid = TRUE;

    if (pLvd == NULL) {
        fValid = FALSE;
        goto end;
    }

    lvItem = pLvd->item;

    if (lvItem.pszText == NULL) {
        fValid = FALSE;
        goto end;
    }
    
    TCHAR szText[256];

    *szText = 0;
    SafeCpyN(szText, lvItem.pszText, ARRAYSIZE(szText));

    if (CSTRING::Trim(szText) == 0) {
        fValid = FALSE;
        goto end;
    }
    
    lvItem.lParam = NULL;
    lvItem.mask = LVIF_PARAM;

    if (!ListView_GetItem(g_hwndContentsList, &lvItem)) {

        assert(FALSE);
        fValid = FALSE;
        goto end;
    }

    TYPE type = ConvertLparam2Type(lvItem.lParam);

    switch (type) {
    case TYPE_ENTRY:
        {
            PDBENTRY pEntry = (PDBENTRY)lvItem.lParam;

            assert(pEntry);
            PDBENTRY pApp = g_pPresentDataBase->pEntries;

            if (!IsValidAppName(szText)) {
                //
                // The app name contains invalid chars
                //
                DisplayInvalidAppNameMessage(g_hDlg);

                break;
            }

            //
            // Check if we have some app of the same name that we are trying to give...
            //
            while (pApp) {

                if (pApp->strAppName == szText) {
                    //
                    // Yes, we have, so do not allow this name
                    //
                    MessageBox(g_hDlg, GetString(IDS_SAMEAPPEXISTS), g_szAppName, MB_ICONWARNING);
                    fValid = FALSE;
                }

                pApp = pApp->pNext;
            }

            //
            // Now change the name of all the entries for this app
            //
            while (pEntry) {
                pEntry->strAppName = szText;
                pEntry = pEntry->pSameAppExe;
            }
        }

        break;

    case FIX_LAYER:
        {   
            PLAYER_FIX plf = (PLAYER_FIX)lvItem.lParam;

            if (plf == NULL) {
                assert(FALSE);
                return FALSE;
            }

            if (FindFix(szText, FIX_LAYER, g_pPresentDataBase)) {
                //
                // A layer with the same name already exists in the system or the
                // present database
                //
                MessageBox(g_hDlg, 
                           GetString(IDS_LAYEREXISTS), 
                           g_szAppName, 
                           MB_ICONWARNING);

                return FALSE;
            }

            plf->strName = szText;
        }

        break;

    default: fValid = FALSE;
    }// switch

end:
    INT_PTR iStyle = GetWindowLongPtr(g_hwndContentsList, GWL_STYLE);

    iStyle &= ~LVS_EDITLABELS;

    SetWindowLongPtr(g_hwndContentsList, GWL_STYLE, iStyle);

    if (fValid) {

        g_pPresentDataBase->bChanged;

        HTREEITEM hParent;

        if (type == TYPE_ENTRY) {
            hParent = g_pPresentDataBase->hItemAllApps;
        } else if (type == FIX_LAYER) {
            hParent = g_pPresentDataBase->hItemAllLayers;
        } else {
            assert(FALSE);
        }

        HTREEITEM hItem = DBTree.FindChild(hParent, lvItem.lParam);

        assert(hItem);

        //
        // Refresh the entry in the tree
        //
        PostMessage(g_hDlg, 
                    WM_USER_REPAINT_TREEITEM, 
                    (WPARAM)hItem,
                    (LPARAM)lvItem.lParam);

        PostMessage(g_hDlg, 
                    WM_USER_REPAINT_LISTITEM, 
                    (WPARAM)lvItem.iItem,
                    (LPARAM)lvItem.lParam);
        return TRUE;

    } else {
        return FALSE;
    }
}

void
HandleMRUActivation(
    IN  WPARAM wCode
    )
/*++
    HandleMRUActivation

	Desc:	The user wishes to open a database that is in the MRU list. If this
            database is already open then we simply select this database in the 
            database tree. (LHS)

	Params:
        IN  WPARAM wCode: The LOWORD(wParam) that comes with WM_COMMAND. This will
            identify which MRU menu item was activated

	Return:
        void
--*/
{
    
    CSTRING strPath;

    if (!g_strlMRU.GetElement(wCode - ID_FILE_FIRST_MRU, strPath)) {
        assert(FALSE);
        return;
    }

    //
    // Test to see if we have the database open already. 
    // If it is open, we just highlight that and return
    //
    PDATABASE   pDataBase = DataBaseList.pDataBaseHead;
    BOOL        bFound    = FALSE;

    while (pDataBase) {

        if (pDataBase->strPath == strPath) {

            TreeView_SelectItem(DBTree.m_hLibraryTree, pDataBase->hItemDB);
            bFound = TRUE;
            break;
            
        }

        pDataBase = pDataBase->pNext;
    }

    BOOL bLoaded = FALSE;

    if (!bFound) {

        SetCursor(LoadCursor(NULL, IDC_WAIT));

        bLoaded = LoadDataBase((LPTSTR)strPath);

        if (bLoaded) {

            SetCursor(LoadCursor(NULL, IDC_ARROW));

            AddToMRU(g_pPresentDataBase->strPath);
    
            RefreshMRUMenu();     
    
            SetCaption();
        }
    }
}

void
OnDbRenameInitDialog(
    IN HWND hdlg
    )
/*++
    OnDbRenameInitDialog
    
    Description:    Processes WM_INITDIALOG for IDD_DBRENAME.
                    Limits the text field
                    
    Params:
        IN  HWND    hdlg:   The handle to the rename dialog box
--*/
{
    SendMessage(GetDlgItem(hdlg, IDC_NAME), 
                EM_LIMITTEXT, 
                (WPARAM)LIMIT_APP_NAME, 
                (LPARAM)0);

    if (g_pPresentDataBase) {
        SetDlgItemText(hdlg, IDC_NAME, (LPCTSTR)g_pPresentDataBase->strName);
    }

    CenterWindow(GetParent(hdlg), hdlg);
}

void
OnDbRenameOnCommandIDC_NAME(
    IN  HWND    hdlg,
    IN  WPARAM  wParam
    )
/*++
    OnDbRenameOnCommandIDC_NAME
    
    Description:    Processes WM_COMMAND for the text box in IDD_DBRENAME.
                    Disables the OK button if we do not have any text in there.
                    
    Params:
        IN  HWND    hdlg:   The handle to the rename dialog box
        IN  WPARAM  wParam: The WPARAM that comes with WM_COMMAND 
    
--*/
{
    BOOL    bEnable;
    TCHAR   szDBName[LIMIT_APP_NAME + 1];

    if (hdlg == NULL) {
        return;
    }

    if (EN_CHANGE == HIWORD(wParam)) {

        *szDBName = 0;

        GetWindowText(GetDlgItem(hdlg, IDC_NAME), szDBName, ARRAYSIZE(szDBName));
        bEnable = ValidInput(szDBName);

        //
        // Enable the OK button only if we have some text in the box
        //
        ENABLEWINDOW(GetDlgItem(hdlg, IDOK), bEnable);
    }
}

void
OnDbRenameOnCommandIDOK(
    IN  HWND        hdlg,
    OUT CSTRING*    pstrString
    )
/*++
    OnDbRenameOnCommandIDOK
    
    Description:    Handles the pressing of OK button in IDD_DBRENAME. Gets the text 
                    from the text box and stores that in g_szData
                    
    Params:
        IN  HWND     hdlg:          The handle to the dialog rename window: IDD_DBRENAME
        OUT CSTRING* pstrString:    The pointer to the CSTRING that should contain the new name
--*/
{   
    TCHAR   szDBName[LIMIT_APP_NAME + 1];

    *szDBName = 0;

    GetDlgItemText(hdlg, IDC_NAME, szDBName, ARRAYSIZE(szDBName));
    CSTRING::Trim(szDBName);

    //
    // Change the name
    //
    *pstrString = szDBName;
}


INT_PTR CALLBACK
DatabaseRenameDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++
    DatabaseRenameProc

    Description:    Handles messages for the database rename option
    
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam: This will be a pointer to a CSTRING that should contain the new string
        
    Return: Standard dialog handler return    

--*/
{   
    int         wCode               = LOWORD(wParam);
    int         wNotifyCode         = HIWORD(wParam);
    static CSTRING*    s_pstrParam  = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:

        OnDbRenameInitDialog(hdlg);
        s_pstrParam = (CSTRING*)lParam;
        break;

    case WM_COMMAND:
        switch (wCode) {
        case IDOK:

            OnDbRenameOnCommandIDOK(hdlg, s_pstrParam);
            EndDialog(hdlg, TRUE);
            break;

        case IDC_NAME:

            OnDbRenameOnCommandIDC_NAME(hdlg, wParam);
            break;

        case IDCANCEL:

            EndDialog(hdlg, FALSE);
            break;

        }
        break;

    default: return FALSE;
    }

    return TRUE;
}

PDATABASE
GetCurrentDB(
    void
    )
{
    return g_pPresentDataBase;
}

void
DisplayInvalidAppNameMessage(
    IN  HWND hdlg
    )
/*++
    
    DisplayInvalidAppNameMessage
    
    Desc:   If the app name contains one of the chars that cannot
            be part of a dir name we will show this message.
    
    Params:
        IN  HWND hdlg:  The window where this dialog message should be shown.
    )
--*/
{
    CSTRING strMessage(IDS_ERROR_DEFAULTNAME);

    strMessage.Strcat(TEXT(" \""));

    MessageBox(hdlg,
               strMessage,
               g_szAppName,
               MB_ICONWARNING);
}

INT
GetContentsListIndex(
    IN  HWND    hwndList,
    IN  LPARAM  lParam
    )
/*++
    GetContentsListIndex
    
    Desc:   Gets the index of a item that has the LPARAM of lParam
    
    Params:
        IN  HWND    hwndList:   The list view 
        IN  LPARAM  lParam:     The LPARAM 
        
    Return:
        The index of the item that has a LPARAM of lParam
        or -1 if that does not exist
--*/
{
    LVFINDINFO  lvFind;
    INT         iIndex  = 0;

    lvFind.flags    = LVFI_PARAM;
    lvFind.lParam   = lParam;

    return ListView_FindItem(hwndList, -1, &lvFind);
}

BOOL
DeleteFromContentsList(
    IN  HWND    hwndList,
    IN  LPARAM  lParam
    )
/*++
    DeleteFromContentsList
    
    Desc:   Deletesan element with LPARAM of lParam from the ListView hwndList 
    
    Params:
        IN  HWND    hwndList:   The list view from which we want to delete
        IN  LPARAM  lParam:     The LPARAM of the item that we want to delete
        
    Return:
        TRUE:   The item was deleted successfully
        FALSE:  Otherwise
--*/
{
    INT     iIndex  = -1;
    BOOL    bOk     = FALSE;

    iIndex = GetContentsListIndex(hwndList, lParam);
    
    if (iIndex > -1) {
        bOk = ListView_DeleteItem(hwndList, iIndex);
    } else {
        assert(FALSE);
        Dbg(dlError, "DeleteFromContentsList", "Could not find Element with lParam = %X", lParam);
        bOk = FALSE;
    }

    return bOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\csearch.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    CSearch.cpp

Abstract:

    This module contains code that handles the searching of the disk for
    fixed entries. 
        
Author:

    kinshu created  July 2, 2001
    
Notes:

    The search window is implemented as a modeless window that has NULL as its parent.
    We had to do this because we want the users to tab between the main window and the 
    search window

--*/


#include "precomp.h"

/////////////////////// Extern variables //////////////////////////////////////

extern BOOL         g_bMainAppExpanded;
extern BOOL         g_bSomeWizardActive;
extern HINSTANCE    g_hInstance;
extern HWND         g_hDlg;
extern HIMAGELIST   g_hImageList;

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Defines //////////////////////////////////////////////

// We're using the high 4 bits of the TAGID to say what PDB the TAGID is from.
#define PDB_MAIN            0x00000000
#define PDB_TEST            0x10000000
#define PDB_LOCAL           0x20000000

// Used to get the tag ref from the tagid, the low 28 bits
#define TAGREF_STRIP_TAGID  0x0FFFFFFF

// Used to get the PDB from the tagid, the high 4 bits
#define TAGREF_STRIP_PDB    0xF0000000

// Subitems for the columns of the list view
#define SEARCH_COL_AFFECTEDFILE 0
#define SEARCH_COL_PATH		    1
#define SEARCH_COL_APP		    2
#define SEARCH_COL_ACTION	    3
#define SEARCH_COL_DBTYPE	    4

// Total number of columns in the search dialog list view
#define TOT_COLS                5

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Global variables /////////////////////////////////////

// Index where the next element will be inserted in the list view
UINT g_nIndex = 0;

// The search object
CSearch* g_pSearch;

// width and height of the dialog box. These are required in the WM_SIZE handler
int      g_cWidthSrch;
int      g_cHeightSrch;

//
// This will hold the path that we want to search. e.g c:\*.exe or c:\
// This will be the content of the text box
static TCHAR    s_szPath[MAX_PATH + 5]; // just so that we can have *.exe at the end, if needed. This will be an invalid path.

// The path that the user last searched on.
static TCHAR    s_szPrevPath[MAX_PATH + 5]; // just so that we can have *.exe at the end, if needed. This will be an invalid path.

//
// What type of entries are we looking for. The values of these will be set depending 
// upon if the corresponding check boxes are set
BOOL    s_bAppHelp; // We want to see entries with Apphelp
BOOL    s_bShims;   // We want to see entries with shims/flags or patches
BOOL    s_bLayers;  // We want to see entries with layers

HSDB    g_hSDB;

// The handle to the search dialog
HWND    g_hSearchDlg;

// The thread which does all the job
HANDLE  g_hSearchThread = NULL;

// The handle to the search results list
HWND    g_hwndSearchList; 

// If this is TRUE, we must abort the search. Typically set when the user presses STOP button
BOOL    g_bAbort;

// The critical section that guards g_bAbort and access to the list view
CRITICAL_SECTION g_CritSect;

// The handle to the main dialog
HWND    g_hdlgSearchDB;

// This is a bit array that describes which cols are sorted in which fashion
static  LONG  s_lColumnSort;

//
// This will contain the cur dir before we started search
TCHAR   g_szPresentDir[MAX_PATH];

// This will be the path that we want to show in the status bar
TCHAR   g_szNewPathFound[MAX_PATH];

//////////////////////////////////////////////////////////////////////////////

//////////////////////// Function Declarations //////////////////////////////


void
ShowContextMenu(
    WPARAM wParam,
    LPARAM lParam
    );

void
OnBrowse(
    HWND hdlg
    );

BOOL
AddNewResult(
    LPARAM lParam
    );

void
DoSearch(
    HWND hDlg
    );

void
OnSearchInitDialog(
    HWND    hDlg,
    LPARAM  lParam
    );

void
SaveResults(
    HWND    hdlg
    );

void
SearchDirectory(
    LPTSTR szDir,
    LPTSTR szExt
    );

//////////////////////////////////////////////////////////////////////////////

void
GetCheckStatus(
    IN  HWND hDlg
    )
/*++
    GetCheckStatus

	Desc:	Ses static variables by looking which check boxes have been selected

	Params:
        IN  HWND hDlg:  The search dialog box

	Return:
        void
        
    Notes:  The check boxes work in OR manner. So if we select all of them it means select fixes
            that have either of them
--*/
{
    //
    // Do we want to search for entries with Apphelp?
    //
    s_bAppHelp = (IsDlgButtonChecked(hDlg, IDC_CHKAPP) == BST_CHECKED) ? TRUE : FALSE; 

    //
    // Do we want to search for entries with shims, flags or patches?
    //
    s_bShims   = (IsDlgButtonChecked(hDlg, IDC_CHKSHI) == BST_CHECKED) ? TRUE : FALSE; 

    //
    // Do we want to search for entries with layers?
    //
    s_bLayers  = (IsDlgButtonChecked(hDlg, IDC_CHKLAY) == BST_CHECKED) ? TRUE : FALSE; 
}

void
StopSearch(
    void
    )
/*++
    
    StopSearch
    
    Desc:   Enables/Disables the various buttons and does other stuff that has to 
            be done after the search has stopped because it was complete or the user
            pressed Stop button
            
    Notes:  Does not actually stop the search, but performs the necessary actions after
            search has been stopped 
--*/
{
    HWND hwndList = NULL;
    
    if (g_hSearchThread) {
        CloseHandle(g_hSearchThread);
        g_hSearchThread = NULL;
    }

    KillTimer(g_hSearchDlg, 0);

    Animate_Stop(GetDlgItem(g_hSearchDlg, IDC_ANIMATE));

    SetCurrentDirectory(g_szPresentDir);
    
    EnableWindow(GetDlgItem(g_hSearchDlg, IDC_STOP), FALSE);
    EnableWindow(GetDlgItem(g_hSearchDlg, IDC_SEARCH), TRUE);
    EnableWindow(GetDlgItem(g_hSearchDlg, IDC_NEWSEARCH), TRUE);
    EnableWindow(GetDlgItem(g_hSearchDlg, IDC_SAVE), TRUE);

    EnableWindow(GetDlgItem(g_hSearchDlg, IDC_CHKAPP), TRUE);
    EnableWindow(GetDlgItem(g_hSearchDlg, IDC_CHKLAY), TRUE);
    EnableWindow(GetDlgItem(g_hSearchDlg, IDC_CHKSHI), TRUE);

    hwndList = GetDlgItem(g_hSearchDlg, IDC_LIST);

    //
    // We need to enable the static control if we have found some results in search
    //
    EnableWindow(GetDlgItem(g_hSearchDlg, IDC_STATIC_CAPTION), 
                 ListView_GetItemCount(hwndList) > 0);

    SetActiveWindow(g_hdlgSearchDB);
    SetFocus(g_hdlgSearchDB);
}

void
HandleSearchSizing(
    IN  HWND hDlg
    )
/*++

    HandleSearchSizing
    
	Desc:	Handles WM_SIZE for the search dialog

	Paras:
        IN  HWND hDlg:  The search dialog

	Return:
        void
        
--*/
{
    int     nWidth;
    int     nHeight;
    int     nStatusbarTop;
    RECT    rDlg;

    if (g_cWidthSrch == 0 || g_cHeightSrch == 0) {
        return;
    }
    
    GetWindowRect(hDlg, &rDlg);

    nWidth  = rDlg.right - rDlg.left;
    nHeight = rDlg.bottom - rDlg.top;

    int deltaW = nWidth - g_cWidthSrch;
    int deltaH = nHeight - g_cHeightSrch;

    HWND hwnd;
    RECT r;

    HDWP hdwp = BeginDeferWindowPos(10);

    if (hdwp == NULL) {
        //
        // NULL indicates that insufficient system resources are available to 
        // allocate the structure. To get extended error information, call GetLastError.
        //
        assert(FALSE);
        goto End;
    }

    //
    // The status bar
    //
    hwnd = GetDlgItem(hDlg, IDC_STATUSBAR);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);
    
    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   nStatusbarTop = r.top + deltaH,
                   r.right - r.left + deltaW,
                   r.bottom - r.top + deltaH,
                   SWP_NOZORDER | SWP_NOACTIVATE);
    
    //
    // The result list view
    //
    hwnd = GetDlgItem(hDlg, IDC_LIST);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top,
                   r.right - r.left + deltaW,
                   nStatusbarTop - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // The browse button
    //
    hwnd = GetDlgItem(hDlg, IDC_BROWSE);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left + deltaW,
                   r.top,
                   r.right - r.left,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);
    
    //
    // The search button
    //
    hwnd = GetDlgItem(hDlg, IDC_SEARCH);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left + deltaW,
                   r.top,
                   r.right - r.left,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // The save button. Used to export results to a tab separated text file
    //
    hwnd = GetDlgItem(hDlg, IDC_SAVE);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left + deltaW,
                   r.top,
                   r.right - r.left,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // The stop button
    //
    hwnd = GetDlgItem(hDlg, IDC_STOP);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left + deltaW,
                   r.top,
                   r.right - r.left,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);
    
    //
    // The new search button
    //
    hwnd = GetDlgItem(hDlg, IDC_NEWSEARCH);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left + deltaW,
                   r.top,
                   r.right - r.left,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // The help button
    //
    hwnd = GetDlgItem(hDlg, IDC_SEARCH_HELP);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left + deltaW,
                   r.top,
                   r.right - r.left,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // The animate control
    //
    hwnd = GetDlgItem(hDlg, IDC_ANIMATE);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left + deltaW,
                   r.top,
                   r.right - r.left,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);
    
    //
    // The text box
    //
    hwnd = GetDlgItem(hDlg, IDC_PATH);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top,
                   r.right - r.left + deltaW,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);
    
    //
    // The group control
    //
    hwnd = GetDlgItem(hDlg, IDC_GROUP);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top,
                   r.right - r.left + deltaW,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    EndDeferWindowPos(hdwp);

    ListView_SetColumnWidth(g_hwndSearchList, TOT_COLS - 1, LVSCW_AUTOSIZE_USEHEADER);

    g_cWidthSrch    = nWidth;
    g_cHeightSrch   = nHeight;

End:
    return;
}

INT_PTR
HandleTextChange(
    IN  HWND    hdlg,
    IN  WPARAM  wParam
    )
/*++

    HandleTextChange
    
    Desc: Handles the WM_COMMAND messages for the text box
    
    Params:
        IN  HWND    hdlg:   The handle to the query dilaog box
        IN  WPARAM  wParam: The wParam that comes with WM_COMMAND 
        
    Return:
        TRUE: If we process this message
        FALSE: Otherwise
--*/
{
    TCHAR   szText[MAX_PATH];
    DWORD   dwFlags;
    BOOL    bEnable;
    INT_PTR ipReturn = FALSE;

    switch (HIWORD(wParam)) {
    case EN_CHANGE:
        //
        // We disable the search button if there is no path that we can search on//
        //
        *szText = 0;
        GetDlgItemText(hdlg, IDC_PATH, szText, ARRAYSIZE(szText));

        bEnable = ValidInput(szText);
        
        //
        // If we have some text in the text field, enable the search button, otherwise
        // disable it
        //
        EnableWindow(GetDlgItem(hdlg, IDC_SEARCH), bEnable);
        ipReturn = TRUE;
        break;

    default: ipReturn = FALSE;
    }

    return ipReturn;
}

INT_PTR CALLBACK
SearchDialog(
    IN  HWND    hDlg, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++
    
    SearchDialog
    
    Desc:   Dialog proc for the search dialog
    
    Paras: Standard dialog handler parameters
        
        IN  HWND    hDlg 
        IN  UINT    uMsg 
        IN  WPARAM  wParam 
        IN  LPARAM  lParam
        
    Return: Standard dialog handler return
    
--*/
{
    switch (uMsg) {

    case WM_SIZE:
        
        if (wParam != SIZE_MINIMIZED) {
            HandleSearchSizing(hDlg);
        }

        break;

    case WM_GETMINMAXINFO:
        {
            MINMAXINFO* pmmi = (MINMAXINFO*)lParam;

            pmmi->ptMinTrackSize.x = 400;
            pmmi->ptMinTrackSize.y = 365;

            return 0;
            break;
        }
    
    case WM_INITDIALOG:
            
        OnSearchInitDialog(hDlg, lParam);
        break;
    
    case WM_DESTROY:
        {
            HIMAGELIST hImageList = ListView_GetImageList(g_hwndSearchList, LVSIL_SMALL);

            if (hImageList) {
                ImageList_Destroy(hImageList);
            }

            hImageList = ListView_GetImageList(g_hwndSearchList, LVSIL_NORMAL);

            if (hImageList) {
                ImageList_Destroy(hImageList);
            }

            g_hdlgSearchDB = NULL;
    
            if (g_pSearch) {
                delete g_pSearch; 
                g_pSearch = NULL;
            }

            DeleteCriticalSection(&g_CritSect);
            //
            // Remove the list view contents and the items that are tied with it.
            //
            ClearResults(hDlg, TRUE);

            return 0;
        }

    case WM_USER_NEWMATCH:
        
        AddNewResult(lParam);
        break;
    
    case WM_USER_NEWFILE:
        {
            EnterCriticalSection(&g_CritSect);

            if (g_pSearch) {
                SetWindowText(g_pSearch->m_hStatusBar , (LPTSTR)lParam);
            }

            if (lParam) {
                delete[] ((TCHAR*)lParam);
            }

            LeaveCriticalSection(&g_CritSect);
            
            break;
        }

    case WM_CONTEXTMENU:
            
        ShowContextMenu(wParam, lParam);
        break;
        
    case WM_NOTIFY:
        {   
            LPNMHDR lpnmhdr = (LPNMHDR)lParam;
            
            if (lpnmhdr && lpnmhdr->idFrom == IDC_LIST) {
                return HandleSearchListNotification(hDlg, lParam);
            }

            return FALSE;
        }

    case WM_TIMER:

        if (g_hSearchThread) {

            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hSearchThread, 0)) {
                
                StopSearch();

                K_SIZE  k_size = 260;

                TCHAR* pszString = new TCHAR[k_size];

                if (pszString == NULL) {
                    MEM_ERR;
                    break;
                }
                
                SafeCpyN(pszString, CSTRING(IDS_SEARCHCOMPLETE), k_size);

                SendNotifyMessage(g_hSearchDlg, WM_USER_NEWFILE, 0,(LPARAM)pszString);
            }
        }

        break;

    case WM_COMMAND:
        
        switch (LOWORD(wParam)) {
        case IDC_STOP:

            g_bAbort = TRUE;
            break;

        case IDC_BROWSE:
            
            OnBrowse(hDlg); 
            break;

        case IDC_SEARCH:
            
            DoSearch(hDlg);
            break;

        case IDC_NEWSEARCH:

            ClearResults(hDlg, TRUE);
            break;

        case IDC_SAVE:

            SaveResults(hDlg);
            break;

        case IDC_PATH:

            HandleTextChange(hDlg, wParam);
            break;

        case IDC_SEARCH_HELP:

            ShowInlineHelp(TEXT("searching_for_fixes.htm"));
            break;

        case IDCANCEL:
            {   
                Animate_Close(GetDlgItem(hDlg, IDC_ANIMATE));

                g_bAbort = TRUE;
    
                if (g_hSearchThread) {
                    WaitForSingleObject(g_hSearchThread, INFINITE);
                }

                DestroyWindow(hDlg);
                break;
            }
                    
        case ID_VIEWCONTENTS:
            {
                
                LVITEM          lvi;
                PMATCHEDENTRY   pmMatched;
                INT             iSelection;

                iSelection = ListView_GetSelectionMark(g_hwndSearchList);
    
                if (iSelection == -1) {
                    break;
                }

                ZeroMemory(&lvi, sizeof(lvi));
    
                lvi.iItem       = iSelection;
                lvi.iSubItem    = 0;
                lvi.mask        = LVIF_PARAM;
    
                if (ListView_GetItem(g_hwndSearchList, &lvi)) {
                    pmMatched = (PMATCHEDENTRY)lvi.lParam;
                    GotoEntry(pmMatched);
                }

                break;
            }
            
        default:
            return FALSE;
        }
        
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

DWORD WINAPI
SearchThread(
    IN  LPVOID pVoid
    )
/*++

    SearchThread

	Desc:	The thread routine that does the actual search

	Params:
        IN  LPVOID pVoid: Pointer to the search string. We get it trimmed

	Return:
        0
--*/
{
    LPTSTR  szSearch         = (LPTSTR)pVoid;
    PTCHAR  pchFirstSlash    = NULL;
    DWORD   dwReturn;

    //
    // Separate the extension and the directory
    //
    TCHAR szDrive[_MAX_DRIVE], szDir[MAX_PATH], szFile[MAX_PATH * 2] , szExt[MAX_PATH], szDirWithDrive[MAX_PATH * 2];

    *szDirWithDrive = *szDrive = *szDir = *szFile = *szExt = 0;

    _tsplitpath(szSearch, szDrive, szDir, szFile, szExt);                 

    SafeCpyN(szDirWithDrive, szDrive, ARRAYSIZE(szDirWithDrive));

    StringCchCat(szDirWithDrive, ARRAYSIZE(szDirWithDrive), szDir);

    if (lstrlen(szDirWithDrive) == 0) {
        //
        // Only the file name is there, check in the current drive
        //
        *szDirWithDrive = 0;

        dwReturn = GetCurrentDirectory(MAX_PATH, szDirWithDrive);

        if (dwReturn > 0 && dwReturn < ARRAYSIZE(szDirWithDrive)) {

            pchFirstSlash = _tcschr(szDirWithDrive, TEXT('\\'));

            if (pchFirstSlash) {
                //
                // We will now get only the present drive in szDirWithDrive
                //
                *(++pchFirstSlash) = 0;
            }
        } else {
            //
            // Error condition. 
            //
            Dbg(dlError, "[SearchThread]: Could not execute GetCurrentDirectory properly");
            goto End;
        }
    }

    StringCchCat(szFile, ARRAYSIZE(szFile), szExt);

    if (lstrlen(szFile) == 0) {
        SafeCpyN(szFile, TEXT("*.EXE"), ARRAYSIZE(szFile));
    }

    if (!SetCurrentDirectory(szDirWithDrive)) {
        
        MSGF(g_hdlgSearchDB,
             g_szAppName, 
             MB_ICONINFORMATION, 
             TEXT("\'%s\'-%s"), 
             szDirWithDrive, 
             GetString(IDS_PATHERROR));

        return 0;
    }

    SearchDirectory(szDirWithDrive, szFile);

End:

    return 0;
}  

void
Search(
    IN  HWND    hDlg,
    IN  LPCTSTR szSearch
    )
/*++

    Search 

	Desc:	Creates the thread that will do the actual search

	Params:
        IN  HWND    hDlg:       The search dialog
        IN  LPCTSTR szSearch:   The files to search

	Return:
        void
        
--*/
{
    DWORD dwID; 

    Animate_Play(GetDlgItem(hDlg, IDC_ANIMATE), 0, -1, -1);
    
    g_hSearchThread = (HANDLE)_beginthreadex(NULL, 0, (PTHREAD_START)SearchThread, (PVOID)szSearch, 0, (unsigned int*)&dwID);
}


BOOL 
PopulateFromExes(
    IN  LPTSTR szPath, 
    IN  TAGREF tagref
    )
/*++

    PopulateFromExes

	Desc:	For the file with path szPath, checks if it needs to be added to the results
            list view and if yes, then calls SendNotifyMessage() to add this to the results
            list view

	Params:
        IN  LPTSTR szPath:  The path of the file found
        IN  TAGREF tagref:  TAGREF for the entry. The TAGREF incorporates the TAGID and a 
            constant that tells us which PDB the TAGID is from.

	Return:
    
--*/
{   
    BOOL    bEntryHasAppHelp   = FALSE;
    BOOL    bEntryHasShims     = FALSE;
    BOOL    bEntryHasPatches   = FALSE;
    BOOL    bEntryHasFlags     = FALSE;
    BOOL    bEntryHasLayers    = FALSE;
    TAGID   ID;                         //TAGID for the entry
    PDB     pDB;                        //The database pdb
    BOOL    bOk =   TRUE;

    PMATCHEDENTRY pmEntry = new MATCHEDENTRY;

    if (pmEntry == NULL) {
        MEM_ERR;
        return FALSE;
    }

    // 
    // Get the database pdb and the tag id for this tagref of the entry. We need
    // these so that we can get the properties of this entry from the database in which
    // it resides
    //
    if (!SdbTagRefToTagID(g_hSDB, tagref, &pDB, &ID)) {

        bOk = FALSE;
        assert(FALSE);
        goto End;
    }

    //
    // Find out how this entry has been fixed. Get its app-name as well
    //
    if (pDB == NULL || !LookUpEntryProperties(pDB, 
                                              ID, 
                                              &bEntryHasLayers, 
                                              &bEntryHasShims, 
                                              &bEntryHasPatches, 
                                              &bEntryHasFlags, 
                                              &bEntryHasAppHelp,
                                              pmEntry->strAppName)) {
        assert(FALSE);
        bOk = FALSE;
        goto End;
    }

    pmEntry->tiExe      = ID;
    pmEntry->strPath    = szPath;
    
    switch (tagref & TAGREF_STRIP_PDB) {
    case PDB_MAIN:      
                                                    
        pmEntry->strDatabase = CSTRING(IDS_GLOBAL);
        break;               

    case PDB_TEST:                                                  

        pmEntry->strDatabase = CSTRING(IDS_TEST);                               
        break;                                                         

    case PDB_LOCAL:                                                 

        pmEntry->strDatabase = CSTRING(IDS_LOCAL);                            
        break;

    default:

        pmEntry->strDatabase = CSTRING(IDS_LOCAL);
        break;

    }                                                                  

    if (!GetDbGuid(pmEntry->szGuid, ARRAYSIZE(pmEntry->szGuid), pDB)) {
            
        assert(FALSE);
        bOk = FALSE;
        goto End;
    }
    

    BOOL bShow = FALSE;
    
    if (bEntryHasAppHelp && s_bAppHelp) {
        pmEntry->strAction.Strcat(CSTRING(IDS_APPHELPS));
        bShow = TRUE;
    }

    if ((bEntryHasShims || bEntryHasFlags || bEntryHasPatches) && s_bShims) {
        pmEntry->strAction.Strcat(CSTRING(IDS_FIXES));
        bShow = TRUE;
    }

    if (bEntryHasLayers && s_bLayers) {
        pmEntry->strAction.Strcat(CSTRING(IDS_MODES));
        bShow = TRUE;
    }

    int nLength = pmEntry->strAction.Length();

    if (nLength) {
        pmEntry->strAction.SetChar(nLength - 1, TEXT('\0'));
    }


    if (bShow) {
        SendNotifyMessage(g_hSearchDlg, WM_USER_NEWMATCH, 0, (LPARAM)pmEntry);
    }

    //
    // NOTE:    the strings of pmEntry that are not used later are freed by the handler
    //          of WM_USER_NEWMATCH, only the szGuid is retained 
    //          after the handler of WM_USER_NEWMATCH ends.
    //          This is required so that we can double click on the list item.
    //
    //          The pmEntry data-structure is deleted when the window gets destroyed
    //

End:
    if (bOk == FALSE && pmEntry) {
        delete pmEntry;
    }

    return bOk;
}                                                  

void
SearchDirectory(
    IN  LPTSTR pszDir,
    IN  LPTSTR szExtension
    )
/*++
    
    SearchDirectory

	Desc:	Searches a directory recursively for fixed files with a specified extension. 
            Wild cards are allowed

	Params:
        IN  LPTSTR pszDir:       The directory to search in. This may or may not have a ending \
             
        IN  LPTSTR szExtension: The extensions to look for

	Return:
        void
        
    
    Note:   If pszDir is a drive should have a \ at the end
    
--*/
{
    HANDLE          hFile;
    WIN32_FIND_DATA Data;
    TCHAR           szCurrentDir[MAX_PATH_BUFFSIZE];
    BOOL            bAbort      = FALSE;
    TCHAR*          pszString   = NULL;
    INT             iLength     = 0;
    DWORD           dwReturn    = 0;

    *szCurrentDir = 0;
    
    dwReturn = GetCurrentDirectory(ARRAYSIZE(szCurrentDir), szCurrentDir);

    if (dwReturn == 0 || dwReturn >= ARRAYSIZE(szCurrentDir)) {
        assert(FALSE);
        Dbg(dlError, "SearchDirectory GetCurrentDirectory Failed");
        return;
    }
    
    if (!SetCurrentDirectory(pszDir)) {
        //
        // We do not prompt here, because we might have encountered a directory that we
        // do not have rights to access. Typically, network paths.
        //
        return;
    }

    iLength     = lstrlen(pszDir) + 1;

    pszString   = new TCHAR[iLength];

    if (pszString == NULL) {
        MEM_ERR;
        return;
    }

    SafeCpyN(pszString, pszDir, iLength);

    SendNotifyMessage(g_hSearchDlg, WM_USER_NEWFILE, 0, (LPARAM)pszString);

    hFile = FindFirstFile(szExtension, &Data);

    if (hFile != INVALID_HANDLE_VALUE) {
        
        do {
            CSTRING szStr;

            szStr.Sprintf(TEXT("%s"), pszDir);

            if (*pszDir && TEXT('\\') != pszDir[lstrlen(pszDir) - 1]) {
                szStr.Strcat(TEXT("\\"));
            }

            szStr.Strcat(Data.cFileName);

            SDBQUERYRESULT Res;

            ZeroMemory(&Res, sizeof(SDBQUERYRESULT));

            //
            // Determine if this file is affected in any way.
            //
            if ((Data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

                if (SdbGetMatchingExe(g_hSDB,
                                      (LPCTSTR)szStr,
                                      NULL,
                                      NULL,
                                      SDBGMEF_IGNORE_ENVIRONMENT,
                                      &Res)) {
                    
                    //
                    // At the moment we only look for exe entires. i.e. to say, we
                    // do not catch programs fixed using the compat UI or the tab
                    // we only show programs that have been fixed by installing some
                    // custom database
                    //
                    for (int nExeLoop = 0; nExeLoop < SDB_MAX_EXES; ++nExeLoop) {

                        if (Res.atrExes[nExeLoop]) {
                            PopulateFromExes(szStr, Res.atrExes[nExeLoop]);
                        }
                    }
                }

                //
                // Close any local databases that might have been opened by SdbGetMatchingExe(...)
                //
                SdbReleaseMatchingExe(g_hSDB, Res.atrExes[0]);
            }

            bAbort = g_bAbort;
        
        } while (FindNextFile(hFile, &Data) && !bAbort);

        FindClose(hFile);
    }

    //
    // Now go through the sub-directories.
    //
    hFile = FindFirstFile(TEXT("*.*"), &Data);

    if (hFile !=  INVALID_HANDLE_VALUE) {

        do {

            if (Data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                
                BOOL bForbidden = FALSE;

                if (TEXT('.') == Data.cFileName[0]) {
                    bForbidden = TRUE;
                }

                if (!bForbidden) {
                    
                    TCHAR szPath[MAX_PATH * 2];

                    SafeCpyN(szPath, pszDir, MAX_PATH);

                    ADD_PATH_SEPARATOR(szPath, ARRAYSIZE(szPath));

                    StringCchCat(szPath, ARRAYSIZE(szPath), Data.cFileName);

                    SearchDirectory(szPath, szExtension);
                }
            }

            bAbort = g_bAbort;
        
        } while (FindNextFile(hFile, &Data) && !bAbort);

        FindClose(hFile);
    }

    SetCurrentDirectory(szCurrentDir);
}

void
CSearch::Begin(
    void
    )
/*++
    CSearch::Begin
    
    Desc:   Begins the search
        
--*/
{   
    if (g_hSDB == NULL) {
        g_hSDB =  SdbInitDatabase(0, NULL);
    }

    g_pSearch = this;

    InitializeCriticalSection(&g_CritSect);

    HWND    hwnd = CreateDialog(g_hInstance, 
                                MAKEINTRESOURCE(IDD_SEARCH), 
                                GetDesktopWindow(),
                                SearchDialog);

    ShowWindow(hwnd, SW_NORMAL);

    return;
}

void
GotoEntry(
    IN  PMATCHEDENTRY pmMatched
    )
/*++
    GotoEntry 
    
    Desc:   Selects the entry with tagid of pmMatched->tiExe in the entry tree.
    
    Params:
        IN  PMATCHEDENTRY pmMatched: Contains information about the entry that we want to
            show in the contents pane(RHS) and the database pane(LHS) in the main window
            
    Return:
        void
--*/
{
    
    if (g_bSomeWizardActive) {
        
        //
        // We do not want that the focus should go to some other database, because
        // some wizard is active, which believes that he is modal.
        //
        MessageBox(g_hdlgSearchDB, GetString(IDS_SOMEWIZARDACTIVE), g_szAppName, MB_ICONINFORMATION);
        return;

    }
    
    if (pmMatched == NULL) {
        assert(FALSE);
        return;
    }

    BOOL    bMainSDB = FALSE;
    WCHAR   wszShimDB[MAX_PATH];

    *wszShimDB = 0;

    if (pmMatched == NULL) {
        return;
    }

    PDATABASE   pDatabase = NULL;

    if (lstrcmp(GlobalDataBase.szGUID, pmMatched->szGuid) == 0) {
        
        //
        // This is the global database
        //
        pDatabase = &GlobalDataBase;
        bMainSDB = TRUE;

        if (!g_bMainAppExpanded) {

            SetStatus(GetDlgItem(g_hSearchDlg, IDC_STATUSBAR), IDS_LOADINGMAIN);
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            INT iResult = ShowMainEntries(g_hdlgSearchDB);

            if (iResult == -1) {
                SetStatus(GetDlgItem(g_hdlgSearchDB, IDC_STATUSBAR), CSTRING(IDS_LOADINGMAIN));
                SetCursor(LoadCursor(NULL, IDC_WAIT));
                return;
            } else {
                SetCursor(LoadCursor(NULL, IDC_ARROW));
            }

            SetStatus(GetDlgItem(g_hSearchDlg, IDC_STATUSBAR), TEXT(""));
        }

    } else {

        //
        // We have to now search for the database in the installed databases list
        //
        PDATABASE pDatabaseInstalled = InstalledDataBaseList.pDataBaseHead;

        while (pDatabaseInstalled) {

            if (lstrcmpi(pmMatched->szGuid, pDatabaseInstalled->szGUID) == 0) {
                pDatabase = pDatabaseInstalled;
                break;
            }

            pDatabaseInstalled = pDatabaseInstalled->pNext;
        }

        if (pDatabaseInstalled ==  NULL) {
            //
            // We might come here if the database was uninstalled after we populated
            // the search results
            //
            MessageBox(g_hSearchDlg, GetString(IDS_NOLONGEREXISTS), g_szAppName, MB_ICONWARNING);
            return;
        }
    }

    //
    // Now for this database, search the particular entry
    //
    PDBENTRY pApp = pDatabase->pEntries, pEntry;

    pEntry = pApp;

    while (pApp) {

        pEntry = pApp;

        while (pEntry) {
            if (pEntry->tiExe == pmMatched->tiExe) {
                goto EndLoop;
            }

            pEntry = pEntry->pSameAppExe;
        }

        pApp = pApp->pNext;
    }
    
    if (pApp == NULL) {

        MessageBox(g_hSearchDlg, GetString(IDS_NOLONGEREXISTS), g_szAppName, MB_ICONWARNING);
        return;
    }

EndLoop:

    //
    // Select the app in the DB tree
    //
    HTREEITEM hItemEntry = DBTree.FindChild(pDatabase->hItemAllApps, (LPARAM)pApp);
    assert(hItemEntry);

    TreeView_SelectItem(DBTree.m_hLibraryTree, hItemEntry);

    //
    // Now select the entry within the app in the entry tree
    //
    hItemEntry = CTree::FindChild(g_hwndEntryTree, TVI_ROOT, (LPARAM)pEntry);
    assert(hItemEntry);

    if (hItemEntry) {
        TreeView_SelectItem(g_hwndEntryTree, hItemEntry);
        SetFocus(g_hwndEntryTree);
    }
}

BOOL    
HandleSearchListNotification(
    IN  HWND    hdlg,
    IN  LPARAM  lParam    
    )
/*++

    HandleSearchListNotification
    
    Desc:   Handles the notification messages for the Search List
    
    Params:
        IN  HWND    hdlg:   The search dialog   
        IN  LPARAM  lParam: The LPARAM of WM_NOTIFY
    
    Return: 
        TRUE:   If the message was handled by this routine.
        FALSE:  Otherwise
--*/
{
    LPNMHDR pnm         = (LPNMHDR)lParam;
    HWND    hwndList    = GetDlgItem(hdlg, IDC_LIST); 

    switch (pnm->code) {
    
    case NM_DBLCLK:

        SendMessage(hdlg, WM_COMMAND, (WPARAM)ID_VIEWCONTENTS, 0);
        break;

    case LVN_COLUMNCLICK:
        {
            LPNMLISTVIEW    pnmlv = (LPNMLISTVIEW)lParam;
            COLSORT         colSort;

            colSort.hwndList        = hwndList;
            colSort.iCol            = pnmlv->iSubItem;
            colSort.lSortColMask    = s_lColumnSort;
            
            ListView_SortItemsEx(hwndList, CompareItemsEx, &colSort);

            if ((s_lColumnSort & 1L << colSort.iCol) == 0) {
                //
                // Was in ascending order
                //
                s_lColumnSort |= (1L << colSort.iCol);
            } else {
                s_lColumnSort &= (~(1L << colSort.iCol));
            }

            break;
        }

    default: return FALSE;

    }

    return TRUE;
}

void
ClearResults(
    IN  HWND    hdlg,
    IN  BOOL    bClearSearchPath
    )
/*++
    ClearResults
    
    Desc:   Clears the contents of the list view and the text box
    
    Params:
        IN  HWND    hdlg:               The search dialog
        IN  BOOL    bClearSearchPath:   Do we wish to clear the contents of the text field also
--*/
{
    HWND    hwndList    = GetDlgItem(hdlg, IDC_LIST);
    INT     iCount      = ListView_GetItemCount(hwndList);
    LVITEM  lvi;

    ZeroMemory(&lvi, sizeof(lvi));

    //
    // Free the lParam for the list view.
    //
    CleanUpListView(hdlg);


    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    ListView_DeleteAllItems(hwndList);
    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

    InvalidateRect(hwndList, NULL, TRUE);
    UpdateWindow(hwndList);

    if (bClearSearchPath) {
        SetDlgItemText(hdlg, IDC_PATH, TEXT(""));
    }
}

void
SaveResults(
    IN  HWND    hdlg
    )
/*++
    
    SaveResults
    
    Desc:   Saves the search results in a tab separated file
    
    Params:
        IN  HWND    hdlg:   The search dialog    
    
--*/
{
    CSTRING strFileName;
    TCHAR szTitle[256], szFilter[128], szExt[8];

    *szTitle = *szFilter = *szExt = 0;

    BOOL bResult = GetFileName(hdlg, 
                               GetString(IDS_SAVE_RESULTS_TITLE, szTitle, ARRAYSIZE(szTitle)),
                               GetString(IDS_SAVE_RESULTS_FILTER, szFilter, ARRAYSIZE(szFilter)),
                               TEXT(""),
                               GetString(IDS_SAVE_RESULTS_EXT, szExt, ARRAYSIZE(szExt)),
                               OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
                               FALSE,
                               strFileName,
                               TRUE);

    if (bResult) {

        SetCursor(LoadCursor(NULL, IDC_WAIT));
        SaveListViewToFile(GetDlgItem(hdlg, IDC_LIST), TOT_COLS, strFileName.pszString, NULL);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
}

void
CleanUpListView(
    IN  HWND    hdlg
    )
/*++
    
    CleanUpListView

    Desc:   Frees the structures associated with the lParam of the list view
    
    Params:
        IN  HWND    hdlg:   The search dialog
    
    ******************************************************************************    
    Warn: This method should not be directky called. Call ClearResults instead
    ******************************************************************************
--*/
{
    HWND    hwndList    = GetDlgItem(hdlg, IDC_LIST);
    INT     iCount      = ListView_GetItemCount(hwndList);
    LVITEM  lvi;

    ZeroMemory(&lvi, sizeof(lvi));

    //
    // Free the lParam for the list view.
    //
    for (INT iIndex = 0; iIndex < iCount; ++iIndex) {
        
        lvi.mask        = LVIF_PARAM;
        lvi.iItem       = iIndex;
        lvi.iSubItem    = 0;

        if (ListView_GetItem(hwndList, &lvi) && lvi.lParam) {
            delete (PMATCHEDENTRY)lvi.lParam;
        } else {
            assert(FALSE);
        }
    }
}

void
OnSearchInitDialog(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++

    OnSearchInitDialog

	Desc:	Handles WM_INITDIALOG for the search dialog box

	Params:
        IN  HWND    hDlg:   The search dialog box
        IN  LPARAM  lParam: The lParam for WM_INITDIALOG

	Return:
        void
--*/
{   
    //
    // Limit the length of the path text field
    // 
    SendMessage(GetDlgItem(hDlg, IDC_PATH), 
                EM_LIMITTEXT, 
                (WPARAM)MAX_PATH - 1, 
                (LPARAM)0);
            
    g_hdlgSearchDB = hDlg;

    s_lColumnSort = 0;

    Animate_OpenEx(GetDlgItem(hDlg, IDC_ANIMATE),
                   g_hInstance,
                   MAKEINTRESOURCE(IDA_SEARCH));
    
    //
    // Set all the buttons
    //
    CheckDlgButton(hDlg, IDC_CHKLAY, BST_CHECKED);
    CheckDlgButton(hDlg, IDC_CHKSHI, BST_CHECKED);
    CheckDlgButton(hDlg, IDC_CHKAPP, BST_CHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_STOP), FALSE);

    g_pSearch->m_hStatusBar = GetDlgItem(hDlg, IDC_STATUSBAR);
    
    CSearch* pPresentSearch = (CSearch*)lParam;

    g_hSearchDlg = hDlg;
    
    g_hwndSearchList = GetDlgItem(hDlg, IDC_LIST);

    ListView_SetExtendedListViewStyleEx(g_hwndSearchList, 
                                        0, 
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT); 

    
    //
    // Add the columns that we are going to show in the list view
    //


    //
    // Name of the fixed program file
    //
    InsertColumnIntoListView(g_hwndSearchList,
                             GetString(IDS_AFFECTED_FILE),
                             SEARCH_COL_AFFECTEDFILE,
                             20);
    
    //
    // Path of the fixed program file
    //
    InsertColumnIntoListView(g_hwndSearchList,
                             GetString(IDS_PATH),
                             SEARCH_COL_PATH,
                             30);

    //
    // App-Name of the fixed program file
    //
    InsertColumnIntoListView(g_hwndSearchList,
                             GetString(IDS_APP),
                             SEARCH_COL_APP,
                             20);

    //
    // Action type. This column will show a concatenated string specifying
    // whether fixes, layers and/or apphelp is used for this entry
    //
    InsertColumnIntoListView(g_hwndSearchList,
                             GetString(IDS_ACTION),
                             SEARCH_COL_ACTION,
                             15);

    //
    // The database type of the database where the entry resides. One of Global or Local
    //
    InsertColumnIntoListView(g_hwndSearchList,
                             GetString(IDS_DATABASE),
                             SEARCH_COL_DBTYPE,
                             15);

    ListView_SetColumnWidth(g_hwndSearchList, TOT_COLS - 1, LVSCW_AUTOSIZE_USEHEADER);
    
    RECT r;

    GetWindowRect(hDlg, &r);

    g_cWidthSrch = r.right - r.left;
    g_cHeightSrch = r.bottom - r.top;

    SHAutoComplete(GetDlgItem(hDlg, IDC_PATH), AUTOCOMPLETE);

    if (*s_szPrevPath) {

        //
        // The user has invoked the search dialog previously, let us
        // now show the directory/path that he searched for previously
        //
        SetDlgItemText(hDlg, IDC_PATH, s_szPrevPath);

    } else {

        //
        // This is the first time that the user is using this search option.
        // Default to the programs folder
        //
        LPITEMIDLIST lpIDL = NULL;

        if (SUCCEEDED(SHGetFolderLocation(NULL, 
                                          CSIDL_PROGRAM_FILES, 
                                          NULL, 
                                          0, 
                                          &lpIDL))) {

            if (lpIDL == NULL) {
                return;
            }
            
            if (SHGetPathFromIDList(lpIDL, s_szPath)) {
                
                ADD_PATH_SEPARATOR(s_szPath, ARRAYSIZE(s_szPath));

                StringCchCat(s_szPath, ARRAYSIZE(s_szPath), TEXT("*.exe"));
                SetDlgItemText(hDlg, IDC_PATH, s_szPath);

                //
                // Free the pidl
                //
                LPMALLOC    lpMalloc = NULL;

                if (SUCCEEDED(SHGetMalloc(&lpMalloc)) && lpMalloc) {
                    lpMalloc->Free(lpIDL);
                } else {
                    assert(FALSE);
                }
            }
        }
    }

    return;
}

void
DoSearch(
    IN  HWND hDlg
    )
/*++

    DoSearch
    
	Desc:	Handle the pressing of the search button. 

	Params:
        IN  HWND hDlg: The search dialog box

	Return:
        void
--*/
{
    if (hDlg == NULL) {
        ASSERT(FALSE);
        return;
    }

    DWORD   dwReturn = 0;
    HWND    hwndList = GetDlgItem(hDlg, IDC_LIST);

    if (GetFocus() == hwndList
        && ListView_GetNextItem(hwndList, -1, LVNI_SELECTED) != -1) {

        //
        // We will get this message when we press enter in the list box,
        // as IDC_SEARCH is the default button.
        // So in this case we have to pretend as the user double clicked in the list
        // view
        //
        SendNotifyMessage(hDlg, WM_COMMAND, (WPARAM)ID_VIEWCONTENTS , 0);
        return;
    }
    
    //
    // We need to get rid of the drop down list for the AUTOCOMPLETE text field. 
    //
    SetFocus(GetDlgItem(hDlg, IDC_SEARCH));

    SendMessage(GetDlgItem(hDlg, IDC_SEARCH), 
                WM_NEXTDLGCTL, 
                (WPARAM)TRUE, 
                (LPARAM)GetDlgItem(hDlg, IDC_SEARCH));

    FlushCache();

    GetCheckStatus(hDlg);
    
    *s_szPath       = 0;
    *s_szPrevPath   = 0;

    GetDlgItemText(hDlg, IDC_PATH, s_szPath, ARRAYSIZE(s_szPath));
    CSTRING::Trim(s_szPath);

    SafeCpyN(s_szPrevPath, s_szPath, ARRAYSIZE(s_szPrevPath));

    g_nIndex = 0;

    //
    // Clear the list view but do not remove the contents of the text field
    //
    ClearResults(hDlg, FALSE); 
    
    SetTimer(hDlg, 0, 100, NULL);

    EnableWindow(GetDlgItem(hDlg, IDC_STOP),  TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_SEARCH), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_NEWSEARCH), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_SAVE), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CAPTION), FALSE);

    EnableWindow(GetDlgItem(hDlg, IDC_CHKAPP), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_CHKLAY), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_CHKSHI), FALSE);

    g_bAbort = FALSE;

    *g_szPresentDir = 0;

    dwReturn =  GetCurrentDirectory(ARRAYSIZE(g_szPresentDir), g_szPresentDir);

    if (dwReturn == 0 || dwReturn >= ARRAYSIZE(g_szPresentDir)) {
        assert(FALSE);
        Dbg(dlError, "DoSearch GetCurrentDirectory failed");
    }

    Search(hDlg, s_szPath);
}

BOOL
AddNewResult(
    IN  LPARAM lParam
    )
/*++
    
    AddNewResult

	Desc:	We found a new file that matches out search criteria, lets now add this
            to the list view. This is the handler for WM_USER_NEWMATCH
            
	Params:
        IN  LPARAM lParam: The lParam that comes with WM_USER_NEWMATCH. This is 
            a pointer to a MATCHEDENTRY
            
    Notes:  Please note that this routine will also free some members of MATCHEDENTRY that 
            we do not need except to populate the list view

	Return:
        TRUE:   If we added the result fields in the list view
        FALSE:  Otherwise
--*/
{
    PMATCHEDENTRY   pmEntry = (PMATCHEDENTRY)lParam;
    CSTRING         strExeName;
    int             iImage;
    HICON           hIcon;
    HIMAGELIST      himl;
    HIMAGELIST      himlSm;
    LVITEM          lvi; 

    if (pmEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }
        
    EnterCriticalSection(&g_CritSect);

    strExeName = pmEntry->strPath;
    
    strExeName.ShortFilename();

    himl = ListView_GetImageList(g_hwndSearchList, LVSIL_NORMAL);
    
    if (!himl) {

        himl = ImageList_Create(16, 15, ILC_COLOR32 | ILC_MASK, 10, 1);

        if (!himl) {
            return FALSE;
        }
        
        hIcon = LoadIcon(0, MAKEINTRESOURCE(IDI_APPLICATION));

        ImageList_AddIcon(himl, hIcon);
        ListView_SetImageList(g_hwndSearchList, himl, LVSIL_NORMAL);
    }

    himlSm = ListView_GetImageList(g_hwndSearchList, LVSIL_SMALL);
    
    if (!himlSm) {

        himlSm = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                  GetSystemMetrics(SM_CYSMICON), ILC_COLOR | ILC_MASK, 0, 0);

        if (!himlSm) {
            return FALSE;
        }

        hIcon = LoadIcon(0, MAKEINTRESOURCE(IDI_APPLICATION));

        ImageList_AddIcon(himlSm, hIcon);
        ListView_SetImageList(g_hwndSearchList, himlSm, LVSIL_SMALL);
    }

    //
    // Get the icon for the file
    //
    hIcon = ExtractIcon(g_hInstance, pmEntry->strPath, 0);

    if (!hIcon) {
        iImage = 0;
    } else {

        iImage = ImageList_AddIcon(himl, hIcon);
        
        if (iImage == -1) {
            iImage = 0;
        }

        int iImageSm = ImageList_AddIcon(himlSm, hIcon);

        assert(iImage == iImageSm);
        DestroyIcon(hIcon);
    }

    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;                                 
    lvi.pszText   = strExeName;
    lvi.iItem     = g_nIndex;                                                
    lvi.iSubItem  = SEARCH_COL_AFFECTEDFILE;                                                     
    lvi.iImage    = iImage;
    lvi.lParam    = (LPARAM)pmEntry;                                        

    INT iIndex = ListView_InsertItem(g_hwndSearchList, &lvi);                           

    //
    // Set the  various result fields in the list view
    //
    ListView_SetItemText(g_hwndSearchList, iIndex, SEARCH_COL_PATH, pmEntry->strPath);             
    ListView_SetItemText(g_hwndSearchList, iIndex, SEARCH_COL_APP, pmEntry->strAppName); 
    ListView_SetItemText(g_hwndSearchList, iIndex, SEARCH_COL_ACTION, pmEntry->strAction);          
    ListView_SetItemText(g_hwndSearchList, iIndex, SEARCH_COL_DBTYPE, pmEntry->strDatabase);     

    //
    // Remove the strings that are no longer going to be used. 
    // Keep the dbguid, this will be used for matching when we double click.
    //
    pmEntry->strAction.Release();
    pmEntry->strDatabase.Release();
    pmEntry->strPath.Release();

    //
    // Increment the index where we want to put in the next result
    //
    g_nIndex++;

    LeaveCriticalSection(&g_CritSect);

    return TRUE;
}

void
OnBrowse(
    IN  HWND hDlg
    )
/*++
    
    OnBrowse

	Desc:	Handles the pressing of the browse button

	Params:
        IN  HWND hdlg: The handle to the search dialog

	Return:
        void
--*/
{

    BROWSEINFO  brInfo;
    TCHAR       szDir[MAX_PATH * 2] = TEXT("");

    brInfo.hwndOwner      = g_hwndSearchList;
    brInfo.pidlRoot       = NULL;
    brInfo.pszDisplayName = szDir;
    brInfo.lpszTitle      = GetString(IDS_SELECTDIR);
    brInfo.ulFlags        = BIF_STATUSTEXT | BIF_RETURNONLYFSDIRS;
    brInfo.lpfn           = NULL; 
    brInfo.lParam         = NULL;

    LPITEMIDLIST lpIDL = SHBrowseForFolder(&brInfo);

    *szDir = 0;

    if (lpIDL == NULL) {
        //
        // The user pressed cancel
        //
        return;
    }

    //
    // Get the actual path from the pidl and free it
    //
    if (SHGetPathFromIDList(lpIDL, szDir)) {

        ADD_PATH_SEPARATOR(szDir, ARRAYSIZE(szDir));

        StringCchCat(szDir, ARRAYSIZE(szDir), TEXT("*.exe"));
        SetDlgItemText(hDlg, IDC_PATH, szDir);

        //
        // Free the pidl
        //
        LPMALLOC    lpMalloc;

        if (SUCCEEDED(SHGetMalloc(&lpMalloc))) {
            lpMalloc->Free(lpIDL);
        } else {
            assert(FALSE);
        }

    } else {
        assert(FALSE);
    }
}   

void
ShowContextMenu(
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++

    ShowContextMenu
    
	Desc:	Shows the context menu. Handles WM_CONTEXTMENU

	Params:
        IN  WPARAM wParam: The wParam that comes with WM_CONTEXTMENU.
            

	Return:
--*/
{
    HWND hWnd = (HWND)wParam;

    if (hWnd == g_hwndSearchList) {

        int iSelection = ListView_GetSelectionMark(g_hwndSearchList);
        
        if (iSelection == -1) {
            return;
        }

        LVITEM         lvi          = {0};
        PMATCHEDENTRY  pmMatched    = NULL;

        lvi.iItem       = iSelection;
        lvi.iSubItem    = 0;
        lvi.mask        = LVIF_PARAM;

        if (!ListView_GetItem(g_hwndSearchList, &lvi)) {
            return;
        }

        pmMatched = (PMATCHEDENTRY)lvi.lParam;

        if (pmMatched == NULL) {
            assert(FALSE);
            return;
        }

        UINT  uX = LOWORD(lParam);
        UINT  uY = HIWORD(lParam);

        HMENU hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_CONTEXT));
        HMENU hContext;

        //
        // Get the context menu for search
        //
        hContext = GetSubMenu(hMenu, 3);

        if (hContext == NULL) {
            goto End;
        }

        TrackPopupMenuEx(hContext,
                         TPM_LEFTALIGN | TPM_TOPALIGN,
                         uX,
                         uY,
                         g_hSearchDlg,
                         NULL);

End:
        if (hMenu) {
            DestroyMenu(hMenu);
            hMenu = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\ctree.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    CTree.h

Abstract:

    Header file for CTree.cpp: Wrapper for some general tree functions
        
Author:

    kinshu created  October 15, 2001

--*/


class CTree
{
public:
    static
    BOOL
    SetLParam(
        HWND        hwndTree,
        HTREEITEM   hItem, 
        LPARAM      lParam
        );
    
    static
    BOOL
    GetLParam(
        HWND        hwndTree,
        HTREEITEM   hItem, 
        LPARAM      *plParam
        );
    
    static
    HTREEITEM
    FindChild(
        HWND        hwndTree,
        HTREEITEM   hItemParent,
        LPARAM      lParam
        );
    
    static
    BOOL
    GetTreeItemText(
        HWND        hwndTree,
        HTREEITEM   hItem,
        PTSTR       pszText,
        UINT        cchText
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\cstring.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    CSTRING.cpp

Abstract:

    Header for 
    
Author:

    kinshu created  December 12,2001
    
Revision History:

--*/

#ifndef _CSTRING_H
#define _CSTRING_H

#include "resource.h"
#include <strsafe.h>

#define MAX_PATH_BUFFSIZE  (MAX_PATH+1)

//
// This also controls how much space we allocate during Sprintf implementation. Since large strings
// like the commandlines and the app help messages are passed in Sprintf (See GetXML() in dbsupport.cpp)
// Presently the commandlines are limited to 1024 chars and the app help messages also to 1024 chars
// Note that when we call sprintf we pass additional strings along with these big strings and we are just
// makign sure that the space is big enough.
#define MAX_STRING_SIZE 1024 * 3

//////////////////////// Externs //////////////////////////////////////////////

extern struct _tagSpecialCharMap    g_rgSpecialCharMap[4][2];
extern TCHAR                        g_szAppName[];

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Defines //////////////////////////////////////////////

#define MEM_ERR  MessageBox(NULL, GetString(IDS_EXCEPTION, NULL, 0), g_szAppName,MB_ICONWARNING|MB_OK);

#define SafeCpyN(pszDest, pszSource, nDestSize) StringCchCopy(pszDest, nDestSize, pszSource)

///////////////////////////////////////////////////////////////////////////////

/*++

  Used to convert from special chars viz. <, >, &, " to the XML equivalents
  
--*/
typedef struct _tagSpecialCharMap {

    TCHAR*  szString;   // The string
    INT     iLength;    // Length of the string in TCHARs
} SpecialCharMap;


PTSTR
GetString(
    UINT    iResource,
    PTSTR   szStr,
    int     nLength
    );

int
CDECL
MSGF(
    HWND    hwndParent,
    PCTSTR  pszCaption,
    UINT    uType,     
    PCTSTR  pszFormat,
    ...
    );


//
// The string class
//
class CSTRING {
public:

    WCHAR*      pszString;   // The wide string
    LPSTR       pszANSI;     // The ansi string

public:

    CSTRING();

    CSTRING(CSTRING& Str);

    CSTRING(LPCTSTR szString);

    CSTRING(UINT uID);

    ~CSTRING();

    void Init(void);

    void Release(void);

    BOOL SetString(UINT uID);

    BOOL SetString(LPCTSTR szStringIn);
    
    CSTRING operator + (CSTRING& str) 
    {
        return(*this + str.pszString);
    }

    CSTRING operator + (LPCTSTR szStr) 
    {
        CSTRING strStr;
        strStr = *this;
        strStr.Strcat(szStr);

        return strStr;
    }

    CSTRING& operator += (LPCTSTR szString)
    {
        if (szString) {
            Strcat(szString);
        }

        return *this;
    }

    CSTRING& operator += (CSTRING& string)
    {
        Strcat((LPCTSTR)string);
        return *this;
    }

    BOOL
    ConvertToLongFileName()
    {   
        TCHAR   szLongPath[MAX_PATH];
        DWORD   dwReturn    = 0;
        BOOL    bOk         = TRUE;

        dwReturn = GetLongPathName(pszString, szLongPath, MAX_PATH);

        if (dwReturn > 0 && dwReturn <= sizeof(szLongPath) / sizeof(szLongPath[0])) {
            SetString(szLongPath);
        } else {
            ASSERT(FALSE);
            bOk = FALSE;
        }

        return bOk;
    }

    PCTSTR GetFileNamePointer()
    {   
        if (pszString) {

            return PathFindFileName(pszString);
        }

        return NULL;
    }

    BOOL GetWindowsDirectory()
    /*++
        Desc:   Gets the windows directory. Will always be appended by a slash
    --*/
    {
        TCHAR           szPath[MAX_PATH];
        INT             iLength;
        const size_t    kszPath = sizeof(szPath) / sizeof(szPath[0]);
        UINT            uResult = 0;

        *szPath = 0;

        uResult = ::GetWindowsDirectory(szPath, kszPath - 1);

        if (uResult > 0 && uResult < (kszPath - 1)) {

            iLength = lstrlen(szPath);                                               

            if ((iLength < kszPath - 1 && iLength > 0) && szPath[iLength - 1] != TEXT('\\')) {

                *(szPath + iLength)      =  TEXT('\\');
                *(szPath + iLength + 1)  =  0;

                SetString(szPath);
                return TRUE;
            }
        }

        return FALSE;
    }
                                  
    BOOL GetSystemWindowsDirectory()
    /*++
        Desc:   Gets the system directory. Will always be appended by a slash
    --*/
    {
        TCHAR           szPath[MAX_PATH];
        INT             iLength;
        const size_t    kszPath = sizeof(szPath) / sizeof(szPath[0]);
        UINT            uResult = 0;

        *szPath = 0;

        uResult = ::GetSystemWindowsDirectory(szPath, kszPath - 1);

        if (uResult > 0 && uResult < (kszPath - 1)) {

            iLength = lstrlen(szPath);                                               

            if ((iLength < kszPath - 1 && iLength > 0) && szPath[iLength - 1] != TEXT('\\')) {

                *(szPath + iLength)      =  TEXT('\\');
                *(szPath + iLength + 1)  =  0;

                SetString(szPath);
                return TRUE;
            }
        }    

        return FALSE;
    }

    BOOL GetSystemDirectory()
    /*++
        Desc:   Gets the system directory. Will always be appended by a slash
    --*/
    {
        TCHAR           szPath[MAX_PATH];
        INT             iLength;
        const size_t    kszPath = sizeof(szPath) / sizeof(szPath[0]);
        UINT            uResult = 0;

        *szPath = 0;

        uResult = ::GetSystemDirectory(szPath, kszPath - 1);

        if (uResult > 0 && uResult < (kszPath - 1)) {

            iLength = lstrlen(szPath);                                               

            if ((iLength < kszPath - 1 && iLength > 0) && szPath[iLength - 1] != TEXT('\\')) {

                *(szPath + iLength)      =  TEXT('\\');
                *(szPath + iLength + 1)  =  0;

                SetString(szPath);
                return TRUE;
            }  
        }

        return FALSE;
    }

    operator LPWSTR()
    {
        return pszString;
    }

    operator LPCWSTR()
    {
        return pszString;

    }

    CSTRING& operator =(LPCWSTR szStringIn)
    {
        SetString(szStringIn);
        return *this;
    }

    CSTRING& operator =(CSTRING & szStringIn)
    {
        SetString(szStringIn.pszString);
        return  *this;
    }

    BOOL operator == (CSTRING & szString)
    {
        return(*this == szString.pszString);
    }

    BOOL operator == (LPCTSTR szString)
    {
        //
        // Both of them are NULL, we say that they are similar
        //
        if (NULL == pszString && NULL == szString) {
            return TRUE;
        }

        //
        // One of them is NULL, but the other one is NOT, we return dissimilar
        //
        if (NULL == pszString || NULL == szString) {
            return FALSE;
        }

        if (0 == lstrcmpi(szString, pszString)) {
            return TRUE;
        }

        return FALSE;
    }

    BOOL operator != (CSTRING& szString)
    {
        if (NULL == pszString && NULL == szString.pszString) {
            return FALSE;
        }  

        if (NULL == pszString || NULL == szString.pszString) {
            return TRUE;
        }

        if (0 == lstrcmpi(szString.pszString,pszString)) {
            return FALSE;
        }

        return TRUE;
    }

    BOOL operator != (LPCTSTR szString)
    {
        return(! (*this == szString));
    }

    BOOL operator <= (CSTRING &szString)
    {
        return((lstrcmpi (*this,szString) <= 0) ? TRUE : FALSE);
    }

    BOOL operator < (CSTRING &szString)
    {
        return((lstrcmpi (*this,szString) < 0) ? TRUE : FALSE);
    }

    BOOL operator >= (CSTRING &szString)
    {
        return((lstrcmpi (*this,szString) >= 0) ? TRUE : FALSE);
    }

    BOOL operator > (CSTRING &szString)
    {
        return((lstrcmpi (*this, szString) > 0) ? TRUE : FALSE);
    }

    void __cdecl Sprintf(LPCTSTR szFormat, ...);

    UINT Trim(void);

    static INT  Trim(IN OUT LPTSTR str);

    BOOL SetChar(int nPos, TCHAR chValue);

    BOOL GetChar(int nPos, TCHAR* chReturn);

    CSTRING SpecialCharToXML(BOOL bApphelpMessage = FALSE);

    TCHAR* XMLToSpecialChar(void);

    static TCHAR* StrStrI(const TCHAR* szString,const TCHAR* szMatch);

    BOOL BeginsWith(LPCTSTR szPrefix);

    BOOL EndsWith(LPCTSTR szSuffix);

    static BOOL EndsWith(LPCTSTR szString, LPCTSTR szSuffix);

    LPCTSTR Strcat(CSTRING & szStr);

    LPCTSTR Strcat(LPCTSTR pString);

    BOOL isNULL(void);

    int Length(void);

    void GUID(GUID& Guid);

    CSTRING& ShortFilename(void);

    BOOL RelativeFile(CSTRING& szPath);
    
    BOOL RelativeFile(LPCTSTR pExeFile);

    TCHAR* Replace(PCTSTR pszToFind, PCTSTR pszWith);
};

/*++
     CSTRINGLIST is a list of these
--*/
typedef struct _tagSList {
    CSTRING             szStr;  // The string
    int                 data ;  // Any data that is associated with this string
    struct _tagSList  * pNext;  // The next string

} STRLIST, *PSTRLIST;

/*++
    A linked list of PSTRLIST
--*/
class CSTRINGLIST {
public:

    UINT        m_uCount;   // The total number of elements
    PSTRLIST    m_pHead;    // The first element
    PSTRLIST    m_pTail;    // The last element

public:

    CSTRINGLIST();

    ~CSTRINGLIST();

    BOOL IsEmpty(void);

    void DeleteAll(void);

    BOOL AddString(CSTRING& Str, int data = 0);

    BOOL AddStringAtBeg(LPCTSTR lpszStr,int data = 0);

    BOOL AddStringInOrder(LPCTSTR pStr,int data = 0);

    BOOL GetElement(UINT uPos, CSTRING& str);

    BOOL AddString(LPCTSTR pStr, int data = 0);

    CSTRINGLIST& operator =(CSTRINGLIST& strlTemp);

    BOOL operator != (CSTRINGLIST &strlTemp);

    BOOL operator == (CSTRINGLIST &strlTemp);
    
    BOOL Remove(CSTRING &str);

    void RemoveLast(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\csearch.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    CSearch.h

Abstract:

    Header for the CSearch.cpp
        
Author:

    kinshu created  July 2,2001

--*/

#ifndef _CSEARCH_H
#define _CSEARCH_H

#include "compatadmin.h"

extern "C" {
#include "shimdb.h"
}

/*++
    
    class CSearch

	Desc:	Make a object of this class and call Begin() to call the search window

	Members:
        HWND    m_hStatusBar:   We just put this as a member because we were trying to avoid
            global variables in csearch.cpp initially. Now we have plentiful of them :-(
            And calling GetDlgItem() whenever we get a file (we need to show the file name in
            the status bar) was not a very good idea.
--*/

class CSearch
{
public:
    HWND    m_hStatusBar;

void Begin();

};

void
GotoEntry(
    PMATCHEDENTRY pmMatched
    );

void
Search(
    HWND    hDlg,
    LPCTSTR szSearch
    );

BOOL    
HandleSearchListNotification(
    HWND    hdlg,
    LPARAM  lParam    
    );

void
ClearResults(
    HWND    hdlg,
    BOOL    bClearSearchPath
    );

void
CleanUpListView(
    HWND    hdlg
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\cstring.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    CSTRING.cpp
Abstract:

    The code for the CSTRING and the CSTRINGLIST
    
Author:

    kinshu created  December 12, 2001
    
Revision History:

--*/

#include "precomp.h"

///////////////////////////////////////////////////////////////////////////////
// 
//    The string class
//
//

CSTRING::CSTRING()
/*++
    CSTRING::CSTRING()
    
	Desc:	Constructor     
	
--*/
{

    Init();

}

CSTRING::CSTRING(CSTRING& Str)
/*++
    CSTRING::CSTRING(CSTRING& Str)
    
	Desc:	Constructor     
    
    Params:
        CSTRING& Str: Another string.
	
--*/
{
    Init();
    SetString(Str.pszString);
}

CSTRING::CSTRING(IN LPCTSTR szString)
/*++
    CSTRING::CSTRING(IN LPCTSTR szString)
    
	Desc:	Constructor     
    
    Params:
        IN LPCTSTR szString: The CSTRING should have this as its value
	
--*/
{
    Init();
    SetString(szString);
}

CSTRING::CSTRING(IN UINT uID)
/*++
    CSTRING::CSTRING(IN UINT uID)
    
	Desc:	Constructor. Loads the string resource with resource id uID
            and sets that to this string
            
    Params:
        IN  UINT uID: The resource id for the string that we want to load
	
--*/
{
    Init();
    SetString(uID);
}

CSTRING::~CSTRING()
/*++
    CSTRING::~CSTRING()
    
	Desc: Destructor
	
--*/
{
    Release();
}

void
CSTRING::Init(
    void
    )
/*++

    CSTRING::Init

	Desc:	Does some initialisation stuff    
	
--*/
{
    pszString   = NULL;
    pszANSI     = NULL;
}

inline void 
CSTRING::Release(
    void
    )
/*++
    CSTRING::Release
    
	Desc:	Frees the data associated with this string    
	
--*/
{
    if (NULL != pszString) {
        delete[] pszString;
    }

    if (NULL != pszANSI) {
        delete[] pszANSI;
    }

    pszString = NULL;
    pszANSI = NULL;
}

inline BOOL 
CSTRING::SetString(
    IN  UINT uID
    )
/*++


	Desc:	Loads the string resource with resource id uId
            and sets that to this string

	Params:   
        IN  UINT uID: The resource id for the string that we want to load

	Return:
        TRUE:   String value set successfully
        FALSE:  Otherwise
--*/
{
    TCHAR szString[1024];

    if (0 != LoadString(GetModuleHandle(NULL), uID, szString, ARRAYSIZE(szString))) {
        return SetString(szString);
    }

    return FALSE;
}

inline BOOL 
CSTRING::SetString(
    IN  LPCTSTR pszStringIn
    )
/*++
    CSTRING::SetString

	Desc:	Frees the current data for this string and assigns a new string
            value to it

	Params:
        IN  LPCTSTR pszStringIn: Pointer to the new string

	Return:
        TRUE:   Successful
        FALSE:  Otherwise
--*/
{
    UINT  uLen = 0;

    if (pszString == pszStringIn) {
        return TRUE;
    }

    Release();

    if (NULL == pszStringIn) {
        return TRUE;
    }

    uLen = lstrlen(pszStringIn) + 1;

    try {
        pszString = new TCHAR[uLen];
    } catch(...) {
        pszString = NULL;
    }             

    if (NULL != pszString) {
        SafeCpyN(pszString, pszStringIn, uLen);
    } else {
        MEM_ERR;
        return FALSE;
    }

    return TRUE;
}

void __cdecl 
CSTRING::Sprintf(
    IN  LPCTSTR szFormat, ...
    )
/*++
    
    CSTRING::Sprintf

	Desc:	Please see _vsntprintf

	Params: Please see _vsntprintf

	Return:
        void
--*/
{   
    K_SIZE  k_pszTemp   = MAX_STRING_SIZE;
    PTSTR   pszTemp     = new TCHAR[k_pszTemp];
    INT     cch         = 0;
    va_list list;
    HRESULT hr;

    if (pszTemp == NULL) {
        MEM_ERR;
        goto End;
    }

    if (szFormat == NULL) {
        ASSERT(FALSE);
        goto End;
    }

    va_start(list, szFormat);
    hr = StringCchVPrintf(pszTemp, k_pszTemp, szFormat, list);

    if (hr != S_OK) {
        DBGPRINT((sdlError,("CSTRING::Sprintf"), ("%s"), TEXT("Too long for StringCchVPrintf()")));
        goto End;
    }

    pszTemp[k_pszTemp - 1] = 0;

    SetString(pszTemp);

End:
    if (pszTemp) {
        delete[] pszTemp;
        pszTemp = NULL;
    }
}

UINT 
CSTRING::Trim(
    void
    )
/*++
    CSTRING::Trim

	Desc:	Removes white spaces tabs from the left and right of this string

	Params:
        void

	Return:
        The length of the final string
--*/
{   
    CSTRING szTemp          = *this;
    UINT    uOrig_length    = Length();
    WCHAR*  pStart          = szTemp.pszString;
    WCHAR*  pEnd            = szTemp.pszString + uOrig_length  - 1;
    UINT    nLength         = 0;


    if (pStart == NULL) {
        nLength = 0;
        goto End;
    }

    while (*pStart == TEXT(' ') || *pStart == TEXT('\t')) {
        ++pStart;
    }

    while ((pEnd >= pStart) && (*pEnd == TEXT(' ') || *pEnd == TEXT('\t'))) {
        --pEnd;
    }

    *(pEnd + 1) = TEXT('\0');

    nLength = pEnd - pStart + 1;

    //
    // If no trimming has been done, return right away
    //
    if (uOrig_length == nLength || pStart == szTemp.pszString) {
        return nLength;
    }

    SetString(pStart);

End:
    return(nLength);
}

BOOL 
CSTRING::SetChar(
    IN  int     nPos, 
    IN  TCHAR   chValue
    )
/*++
    CSTRING::SetChar

	Desc:	Sets the character at position nPos of the string to chValue
            Pos is 0 based 

	Params:
        IN  int     nPos:       The position
        IN  TCHAR   chValue:    The new value

	Return:
        TRUE:   Successful
        FALSE:  Otherwise
--*/
{   
    int length =  Length();

    if (nPos >= length || nPos < 0 || length <= 0) {
        return FALSE;
    }

    pszString[nPos] = chValue;
    return TRUE;
}

BOOL 
CSTRING::GetChar(
    IN  int     nPos, 
    OUT TCHAR*  pchReturn
    )
/*++

    CSTRING::GetChar
    
	Desc:	Gets the character at position nPos in the string

	Params:
        IN  int     nPos:       The position of the character
        OUT TCHAR*  pchReturn:  This will store the character

	Return:
        void
--*/
{

    int length =  Length();

    if (nPos >= length || length <= 0 || pchReturn == NULL) {
        return FALSE;
    }

    *pchReturn = pszString[nPos];

    return TRUE;
}

CSTRING 
CSTRING::SpecialCharToXML(
    IN  BOOL bApphelpMessage 
    )
/*++
    
    CSTRING::SpecialCharToXML

	Desc:	Substitutes the special chars such as & with the correct XML string
            Please note that this function returns a new string and DOES NOT
            modify the existing string

	Params:
        IN  BOOL bApphelpMessage:   Whether this is an apphelp message. For apphelp messages
            we should NOT check for <, > but check for &, "

	Return:
        The new string if we made some changes, otherwise the present string
--*/

{
    TCHAR*  pszBuffer       = NULL;
    TCHAR*  pszIndex        = pszString;
    TCHAR*  pszIndexBuffer  = NULL;
    BOOL    bFound          = FALSE;
    CSTRING strTemp;
    INT     iRemainingsize;
    INT     iBuffSize       = 0;

    strTemp = GetString(IDS_UNKNOWN);

    //
    // Some vendor names might be NULL.
    //
    if (pszString == NULL) {
        return strTemp;
    }

    iBuffSize = max((Length() + 1) * sizeof(TCHAR) * 2, MAX_STRING_SIZE); // 2 at the end because some special chars may need to be expanded

    pszBuffer = new TCHAR[iBuffSize];

    if (pszBuffer == NULL) {
        MEM_ERR;
        return *this;
    }

    pszIndexBuffer = pszBuffer;

    iRemainingsize = iBuffSize / sizeof(TCHAR);

    INT iCount      = sizeof(g_rgSpecialCharMap) / sizeof(g_rgSpecialCharMap[0]);

    while (*pszIndex) {

        INT iArrayIndex = 0;

        for (iArrayIndex = 0; iArrayIndex < iCount; ++iArrayIndex) {

            if (bApphelpMessage && (*pszIndex == TEXT('>') || *pszIndex == TEXT('<'))) {
                //
                // Apphelp messages can have <P/> and <BR/>, so we should not change them
                //
                continue;
            }

            if (g_rgSpecialCharMap[iArrayIndex][0].szString[0] == *pszIndex) {

                bFound      = TRUE;
                SafeCpyN(pszIndexBuffer, g_rgSpecialCharMap[iArrayIndex][1].szString, iRemainingsize);

                iRemainingsize = iRemainingsize - g_rgSpecialCharMap[iArrayIndex][1].iLength;

                if (iRemainingsize <= 1) {
                    //
                    // No space in buffer now
                    //

                    //
                    // If we did not manage to copy the entire substring, make sure that we do not copy a part. This will
                    // be an invalid XML
                    //
                    *pszIndexBuffer = 0;
                    goto End;
                }

                pszIndexBuffer += g_rgSpecialCharMap[iArrayIndex][1].iLength;
                break;
            }
        }

        if (iArrayIndex == iCount) {
            //
            // This is not a special char
            //
            *pszIndexBuffer   = *pszIndex;
            iRemainingsize      = iRemainingsize - 1;

            if (iRemainingsize <= 1) {
                //
                // No space in buffer now
                //

                //
                // Point to the end of the buffer, we will be nulling it at the end
                //
                pszIndexBuffer = pszBuffer + (iBuffSize / sizeof(TCHAR)) - 1;
                goto End;
            }

            ++pszIndexBuffer;
        }

        pszIndex++;
    }

End:
    if (pszIndexBuffer) {
        *pszIndexBuffer = 0;
    }

    if (bFound) {
        //
        // Some special chars were found
        //
        strTemp = pszBuffer;

        if (pszBuffer) {
            delete[] pszBuffer;
            pszBuffer = NULL;
        }

        return strTemp;
    }

    //
    // Free the allocated buffer
    //
    if (pszBuffer) {
        delete[] pszBuffer;
        pszBuffer = NULL;
    }

    return *this;
}

TCHAR* 
CSTRING::XMLToSpecialChar(
    void
    )
/*++
    
    CSTRING::XMLToSpecialChar

	Desc:	Substitutes the strings such as &amp; with the normals characters such as &
            Please note that this function DOES modify the existing string

	Params:
        void

	Return:
        The pointer to the pszString member of this string
--*/
{

    if (pszString == NULL) {
        assert(FALSE);
        Dbg(dlError, "CSTRING::XMLToSpecialChar - Invalid value of memeber pszString");
        return NULL;
    }

    TCHAR*  pszBuffer       = NULL;
    TCHAR*  pszIndex        = pszString;
    TCHAR*  pszEnd          = pszString + Length() - 1;
    TCHAR*  pszIndexBuffer  = NULL;
    BOOL    bFound          = FALSE;
    INT     iRemainingsize;
    INT     iBuffSize       = 0;

    iBuffSize = (Length() + 1) * sizeof(TCHAR);

    pszBuffer = new TCHAR[iBuffSize];

    if (pszBuffer == NULL) {
        MEM_ERR;
        return *this;
    }

    pszIndexBuffer = pszBuffer;

    iRemainingsize = iBuffSize / sizeof(TCHAR);

    const INT iCount = sizeof(g_rgSpecialCharMap) / sizeof(g_rgSpecialCharMap[0]);

    while (*pszIndex) {

        INT iArrayIndex = 0;

        for (iArrayIndex = 0; iArrayIndex < iCount; ++iArrayIndex) {

            if (pszIndex + g_rgSpecialCharMap[iArrayIndex][1].iLength > pszEnd) {
                continue;
            }

            if (StrCmpNI(pszIndex, 
                         g_rgSpecialCharMap[iArrayIndex][1].szString, 
                         g_rgSpecialCharMap[iArrayIndex][1].iLength) == 0) {

                bFound = TRUE;

                SafeCpyN(pszIndexBuffer, g_rgSpecialCharMap[iArrayIndex][0].szString, iRemainingsize);

                iRemainingsize = iRemainingsize - g_rgSpecialCharMap[iArrayIndex][0].iLength;

                if (iRemainingsize <= 1) {
                    //
                    // No space in buffer now
                    //

                    //
                    // Point to the end of the buffer, we will be nulling it at the end
                    //
                    pszIndexBuffer = pszBuffer + (iBuffSize / sizeof(TCHAR)) - 1;
                    goto End;
                }

                pszIndexBuffer  += g_rgSpecialCharMap[iArrayIndex][0].iLength;
                pszIndex        += g_rgSpecialCharMap[iArrayIndex][1].iLength;

                break;
            }
        }

        if (iArrayIndex == iCount) {
            //
            // This is not XML for any special char
            //
            *pszIndexBuffer = *pszIndex++;

            iRemainingsize = iRemainingsize - 1;

            if (iRemainingsize <= 1) {
                //
                // No space in buffer now
                //
    
                //
                // Point to the end of the buffer, we will be nulling it at the end
                //
                pszIndexBuffer = pszBuffer + (iBuffSize / sizeof(TCHAR)) - 1;
                goto End;
            }

            ++pszIndexBuffer;
        }
    }

End:
    if (pszIndexBuffer) {
        *pszIndexBuffer = 0;
    }

    if (bFound) {
        *this = pszBuffer;
    }
    
    //
    // Free the allocated buffer
    //
    if (pszBuffer) {
        delete[] pszBuffer;
        pszBuffer = NULL;
    }

    return this->pszString;
}


BOOL 
CSTRING::BeginsWith(
    IN  LPCTSTR pszPrefix
    )
/*++
    
    CSTRING::BeginsWith

	Desc:	Checks if the string begins with a prefix
            Comparison is case insensitive

	Params:
        IN  LPCTSTR pszPrefix: The prefix that we want to check for

	Return:
        TRUE:   The string begins with the prefix
        FALSE:  Otherwise
--*/
{
    if (StrStrI(this->pszString, pszPrefix) == this->pszString) {
        return TRUE;
    }

    return FALSE;
}

BOOL 
CSTRING::EndsWith(
    IN  LPCTSTR pszPrefix
    )
/*++

    CSTRING::EndsWith

	Desc:	Checks if the string ends with some suffix

	Params:
        IN  LPCTSTR pszPrefix: The suffix that we want to check for

	Return:   
        TRUE:   The string ends with the suffix
        FALSE:  Otherwise
--*/
{
    return EndsWith(pszString, pszPrefix);
}

BOOL
CSTRING::EndsWith(
    IN  LPCTSTR pszString,
    IN  LPCTSTR pszSuffix
    )
/*++
    CSTRING::EndsWith

	Desc:	Checks if the string ends with some suffix

	Params:
        IN  LPCTSTR pszString:  The string for which we want to make this check
        IN  LPCTSTR pszSuffix:  The suffix that we want to check for

	Return:   
        TRUE:   The string ends with the suffix
        FALSE:  Otherwise
--*/
{   

    INT iLengthStr      = lstrlen(pszString);
    INT iLengthSuffix   = lstrlen(pszSuffix);

    if (iLengthSuffix > iLengthStr) {
        return FALSE;
    }

    return((lstrcmpi(pszString + (iLengthStr - iLengthSuffix), pszSuffix) == 0) ? TRUE: FALSE);
}


LPCTSTR 
CSTRING::Strcat(
    IN  CSTRING&    szStr
    )
/*++

    CSTRING::Strcat
    
	Desc:	String concatenations

	Params:
        IN  CSTRING&    szStr: The string to concatenate

	Return:
        The resultant string
--*/
{
    return Strcat((LPCTSTR)szStr);
}

LPCTSTR 
CSTRING::Strcat(
    IN  LPCTSTR pString
    )
/*++
    
	CSTRING::Strcat
    
	Desc:	String concatenations

	Params:
        IN  CSTRING&    szStr: The string to concatenate

	Return:
        The resultant string
--*/
{
    
    if (pString == NULL) {
        return pszString;
    }

    int nLengthCat = lstrlen(pString);
    int nLengthStr = Length();
            
    TCHAR *szTemp = new TCHAR [nLengthStr + nLengthCat + 1];

    if (szTemp == NULL) {
        MEM_ERR;
        return NULL;
    }

    szTemp[0] = 0;

    //
    // Copy only if pszString != NULL. Otherwise we will get mem exception/garbage value
    //
    if (nLengthStr) {
        SafeCpyN(szTemp, pszString, nLengthStr + 1);
    }

    SafeCpyN(szTemp + nLengthStr, pString, nLengthCat + 1);

    szTemp[nLengthStr + nLengthCat] = TEXT('\0');

    Release();
    pszString = szTemp;

    return pszString;
}

BOOL 
CSTRING::isNULL(
    void
    )
/*++
    CSTRING::isNULL

	Desc:	Checks if the pszString parameter is NULL

	Params:
        void

	Return:
        TRUE:   The pszString parameter is NULL
        FALSE:  Otherwise  
        
--*/
{
    return(this->pszString == NULL);
}

inline int 
CSTRING::Length(
    void
    )
/*++

    CSTRING::Length
    
	Desc:	Gets the length of the string in TCHARS

	Params:
        void

	Return:
        The length of the string in TCHARS
--*/
{
    if (NULL == pszString) {
        return 0;
    }

    return lstrlen(pszString);
}
 

CSTRING& 
CSTRING::ShortFilename(
    void
    )
/*++

    CSTRING::ShortFilename

	Desc:	Gets the filename and the exe part from a path
            Modifies the string

	Params:
        void

	Return:
        Filename and the exe part of the path    
--*/
{
    TCHAR   szTemp[MAX_PATH_BUFFSIZE];
    LPTSTR  pszHold = NULL;

    if (pszString == NULL) {
        goto End;
    }

    *szTemp = 0;

    SafeCpyN(szTemp, pszString, ARRAYSIZE(szTemp));

    LPTSTR  szWalk = szTemp;

    pszHold = szWalk;

    while (0 != *szWalk) {
        
        if (TEXT('\\') == *szWalk) {
            pszHold = szWalk + 1;
        }

        ++szWalk;
    }

    SetString(pszHold);

End:
    return *this;
}

BOOL 
CSTRING::RelativeFile(
    CSTRING& szPath
    )
/*++
    CSTRING::RelativeFile

	Desc:	If this string contains a complete path, gets the relative path w.r.t to some 
            other complete path. Modifies this string

	Params:
        CSTRING& szPath: The other path w.r.t to which we have to get the relative path

	Return:
--*/
{
    return RelativeFile((LPCTSTR)szPath);
}

//
// BUGBUG : consider using shlwapi PathRelativePathTo
//
BOOL 
CSTRING::RelativeFile(
    LPCTSTR pExeFile
    )
/*++
    CSTRING::RelativeFile

	Desc:	If this string contains a complete path, gets the relative path w.r.t to some 
            other complete path. Modifies this string

	Params:
        CSTRING& szPath: The other path w.r.t to which we have to get the relative path

	Return:
--*/
{
    if (pExeFile == NULL) {
        assert(FALSE);
        return FALSE;
    }

    LPCTSTR pMatchFile      = pszString;
    int     nLenExe         = 0;
    int     nLenMatch       = 0;
    LPCTSTR pExe            = NULL;
    LPCTSTR pMatch          = NULL;
    LPTSTR  pReturn         = NULL;
    BOOL    bCommonBegin    = FALSE; // Indicates if the paths have a common beginning
    LPTSTR  resultIdx       = NULL;
    TCHAR   result[MAX_PATH * 2]; 
    INT     iLength         = 0;

    resultIdx   = result;
    *result     = TEXT('\0');

    iLength = lstrlen(pExeFile);

    if (iLength > min(MAX_PATH, ARRAYSIZE(result) - 1)) {
        assert(FALSE);
        Dbg(dlError, "CSTRING::RelativeFile", "Length of passed file name greater than size of buffer");
        return FALSE;
    }   

    //
    // Ensure that the beginning of the path matches between the two files
    //
    // BUGBUG this code has to go -- look into replacing this with Shlwapi PathStripPath 
    //
    //
    pExe = _tcschr(pExeFile, TEXT('\\'));
    pMatch = _tcschr(pMatchFile, TEXT('\\'));

    while (pExe && pMatch) {

        nLenExe = pExe - pExeFile;
        nLenMatch = pMatch - pMatchFile;

        if (nLenExe != nLenMatch) {
            break;
        }

        if (!(_tcsnicmp(pExeFile, pMatchFile, nLenExe) == 0)) {
            break;
        }

        bCommonBegin    = TRUE;
        pExeFile        = pExe + 1;
        pMatchFile      = pMatch + 1;

        pExe    = _tcschr(pExeFile, TEXT('\\'));
        pMatch  = _tcschr(pMatchFile, TEXT('\\'));
    }

    //
    // Walk the path and put '..\' where necessary
    //
    if (bCommonBegin) {

        while (pExe) {

            //_tcsncpy(resultIdx, TEXT("..\\"), ARRAYSIZE(result) - (resultIdx - result));
            SafeCpyN(resultIdx, TEXT("..\\"), ARRAYSIZE(result) - (resultIdx - result));
            resultIdx   = resultIdx + 3;
            pExeFile    = pExe + 1;
            pExe        = _tcschr(pExeFile, TEXT('\\'));
        }

        //_tcsncpy(resultIdx, pMatchFile, ARRAYSIZE(result) - (resultIdx - result));
        SafeCpyN(resultIdx, pMatchFile, ARRAYSIZE(result) - (resultIdx - result));

        SetString(result);

    } else {

        return FALSE;
    }

    return TRUE;

}

inline TCHAR* 
CSTRING::Replace(
    IN  PCTSTR  pszToFind,
    IN  PCTSTR  pszWith
    )
/*++
    CSTRING::Replace

	Desc:	Replace a substring with another string.
            As almost all others this function is also case insensitive

	Params:
        IN  PCTSTR  pszToFind:  The sub string to find
        IN  PCTSTR  pszWith:    Replace the above sub-string by this

	Return:
        The pszString member
--*/
{
    TCHAR*  pszPtr      = pszString;
    TCHAR*  pszFoundPos = NULL;
    INT     iLength     = lstrlen(pszToFind);
    CSTRING strTemp;

    while (pszFoundPos = StrStrI(pszPtr, pszToFind)) {

        *pszFoundPos = 0;
        strTemp.Strcat(pszPtr);
        pszPtr = pszFoundPos + iLength;
    }

    if (strTemp.Length()) {
        *this = strTemp;
    }

    return pszString;
}

///////////////////////////////////////////////////////////////////////////////
// 
//    Static Member Functions for CSTRING
//
//
//

TCHAR* 
CSTRING::StrStrI(
    IN  PCTSTR pszString,
    IN  PCTSTR pszMatch
    )
/*++
    CSTRING::StrStrI

	Desc:
        Finds a substring in this string. Not case sensitive   

	Params:
        IN  PCTSTR pszString:   The string in which we want to search
        IN  PCTSTR pszMatch:    The string to search

	Return:
        If found pointer to the substring
        NULL: Otherwise
--*/
{
    INT iLenghtStr      = lstrlen(pszString);
    INT iLengthMatch    = lstrlen(pszMatch);

    for (INT iIndex = 0; iIndex <= iLenghtStr - iLengthMatch; ++iIndex) {

        if (StrCmpNI(pszString + iIndex, pszMatch, iLengthMatch) == 0) {

            return (TCHAR*)(pszString + iIndex);
        }
    }

    return NULL;
}

INT
CSTRING::Trim(
    IN OUT LPTSTR str
    )
/*++
    CSTRING::Trim

	Desc:	Removes white spaces tabs from the left and right of this string

	Params:
        IN OUT LPTSTR str:  The string to trim

	Return:
        The length of the final string
--*/
{   
    UINT    nLength = 0;
    UINT    uOrig_length = lstrlen(str); // Original length
    TCHAR*  pStart       = str;
    TCHAR*  pEnd         = str + uOrig_length - 1;

    if (str == NULL) {
        return 0;
    }

    while (*pStart == TEXT(' ') || *pStart == TEXT('\t')) {
        ++pStart;
    }

    while ((pEnd >= pStart) && (*pEnd == TEXT(' ') || *pEnd == TEXT('\t'))) {
        --pEnd;
    }

    *(pEnd + 1) = TEXT('\0');

    nLength = pEnd - pStart + 1;

    //
    // If no trimming has been done, return right away
    //
    if (uOrig_length == nLength || pStart == str) {
        //
        // In case of RTRIM we are putting in the NULL char appropriately
        //
        return nLength;
    }

    wmemmove(str, pStart, (nLength + 1)); // + 1 for the 0 character.

    return(nLength);
}


///////////////////////////////////////////////////////////////////////////////
//
//      The CSTRINGLIST member functions
//
//

CSTRINGLIST::CSTRINGLIST()
/*++
    CSTRINGLIST::CSTRINGLIST

	Desc:   Constructor   
--*/
{
    m_pHead = NULL;
    m_pTail = NULL;
    m_uCount = 0;
}

CSTRINGLIST::~CSTRINGLIST()
/*++
    CSTRINGLIST::~CSTRINGLIST

	Desc:   Destructor   
--*/
{

    DeleteAll();    
}

BOOL 
CSTRINGLIST::IsEmpty(
    void
    )
/*++
    CSTRINGLIST::IsEmpty

	Desc:	Checks if there are elements in the string list

	Params:
        void

	Return:
        TRUE:   There are no elements in the string list
        FALSE:  Otherwise
--*/
{
    if (m_pHead == NULL) {
        assert (m_pTail == NULL);
        return TRUE;
    } else {
        assert(m_pTail != NULL);
    }

    return FALSE;
}

void 
CSTRINGLIST::DeleteAll(
    void
    )
/*++
    CSTRINGLIST::DeleteAll

	Desc:	Removes all the elements in this string list   
	
--*/
{
    while (NULL != m_pHead) {
        PSTRLIST pHold = m_pHead->pNext;
        delete m_pHead;
        m_pHead = pHold;
    }

    m_pTail     = NULL;
    m_uCount    = 0;
}

BOOL 
CSTRINGLIST::AddString(
    IN  CSTRING& Str, 
    IN  int data // (0)
    )
/*++
    CSTRINGLIST::AddString

	Desc:	Adds a CSTRING to the end of this string list

	Params:
        IN  CSTRING& Str:   The CSTRING to add
        IN  int data (0):   The data member. Please see STRLIST in CSTRING.H

	Return:
        TRUE:   Successful
        FALSE:  Otherwise
--*/
{
    return AddString((LPCTSTR)Str, data);
}

BOOL 
CSTRINGLIST::AddStringAtBeg(
    IN  LPCTSTR lpszStr,
    IN  int data // (0)
    )
/*++
	CSTRINGLIST::AddStringAtBeg

	Desc:	Adds a CSTRING to the beginning of this string list

	Params:
        IN  CSTRING& Str:   The CSTRING to add
        IN  int data (0):   The data member. Please see STRLIST in CSTRING.H

	Return:
        TRUE:   Successful
        FALSE:  Otherwise
--*/
{
    PSTRLIST pNew = new STRLIST;

    if (NULL == pNew) {
        MEM_ERR;
        return FALSE;
    }

    pNew->data  = data; 
    pNew->szStr = lpszStr;        

    pNew->pNext = m_pHead;
    m_pHead     = pNew;

    if (m_pTail == NULL) {
        m_pTail = m_pHead;
    }

    ++m_uCount;

    return TRUE;
}

BOOL 
CSTRINGLIST::AddStringInOrder(
    IN  LPCTSTR pStr,
    IN  int    data // (0)
    )
/*++
    CSTRINGLIST::AddStringInOrder

	Desc:	Adds a string in a sorted fashion, sorted by the data member. 
            Please see STRLIST in CSTRING.H

	Params:
        IN  LPCTSTR pStr:   The string to add
        IN  int data (0):   The data member. Please see STRLIST in CSTRING.H

	Return:
        TRUE:   Successful
        FALSE:  Otherwise
--*/
{
    PSTRLIST pTemp, pPrev;
    PSTRLIST pNew = new STRLIST;

    if (NULL == pNew) {
        MEM_ERR;
        return FALSE;
    }   

    pNew->data  = data; 
    pNew->szStr = pStr;

    pTemp = m_pHead;
    pPrev = NULL;

    while (pTemp) {

        if (data < pTemp->data && (pPrev == NULL || data >= pPrev->data)) {
            break;
        }

        pPrev = pTemp;  
        pTemp = pTemp->pNext;
    }


    if (pPrev == NULL) {
        //
        // Add it to the beg, smallest number
        //
        pNew->pNext = m_pHead;
        m_pHead = pNew;

    } else {
        //
        // Add somewhere in the middle or end
        //
        pNew->pNext = pTemp;
        pPrev->pNext = pNew;
    }

    if (pTemp == NULL) {
        //
        // largest number.
        //
        m_pTail = pNew;
    }

    if (m_pTail == NULL) {
        //
        // Added first element
        //
        m_pTail = m_pHead;
    }

    ++m_uCount;
    return TRUE;
}

BOOL 
CSTRINGLIST::GetElement(
    IN  UINT        uPos,
    OUT CSTRING&    str
    )
/*++
    CSTRINGLIST::GetElement

	Desc:	Gets the element at a given position in the string list
            The position of the first string is 0

	Params:
        IN  UINT        uPos:   The position
        OUT CSTRING&    str:    This will contain the CSTRING at that position

	Return:
        TRUE:   Successful
        FALSE:  Otherwise
--*/
{
    PSTRLIST    pHead = m_pHead;
    UINT        uIndex = 0;

    while (pHead && uIndex != uPos) {
        pHead = pHead->pNext;
        ++uIndex;
    }

    if (uIndex == uPos) {
        str = pHead->szStr;
        return TRUE;

    } else {
        return FALSE;
    }
}

BOOL 
CSTRINGLIST::AddString(
    IN  LPCTSTR pStr, 
    IN  int data // (0)
    )
/*++
    CSTRINGLIST::AddString

	Desc:	Adds a string to the end of this string list

	Params:
        IN  LPCTSTR pStr:   The string to add
        IN  int data (0):   The data member. Please see STRLIST in CSTRING.H

	Return:
        TRUE:   Successful
        FALSE:  Otherwise
--*/
{
    PSTRLIST pNew = new STRLIST;

    if (NULL == pNew) {
        MEM_ERR;
        return FALSE;
    }   

    pNew->data  = data; 
    pNew->szStr = pStr;        
    pNew->pNext = NULL;

    if (NULL == m_pTail) {
        m_pHead = m_pTail = pNew;
    } else {
        m_pTail->pNext = pNew;
        m_pTail = pNew;
    }

    ++m_uCount;
    return TRUE;
}

CSTRINGLIST& 
CSTRINGLIST::operator = (
    IN  CSTRINGLIST& strlTemp
    )
/*++
    CSTRINGLIST::operator =
    
	Desc:	Assigns  one string list to another

	Params:
        CSTRINGLIST& strlTemp: The right hand side of the = operator

	Return:
        This string list
--*/
{
    PSTRLIST tempHead = NULL;

    DeleteAll();

    tempHead = strlTemp.m_pHead;

    while (tempHead) {

        AddString(tempHead->szStr, tempHead->data);
        tempHead = tempHead->pNext;
    }

    return *this;
}

BOOL 
CSTRINGLIST::operator != (
    IN  CSTRINGLIST &strlTemp
    )
/*++
    CSTRINGLIST::operator !=
    
	Desc:	Cheks if two string lists are different

	Params:
        CSTRINGLIST& strlTemp: The right hand side of the != operator

	Return:
        TRUE:   The string lists are different
        FALSE:  The two string lists are similar
--*/
{
    return(! (*this == strlTemp));
}

BOOL 
CSTRINGLIST::operator == (
    IN  CSTRINGLIST &strlTemp
    )
/*++
    CSTRINGLIST::operator == 

	Desc:	Presently we check that the two stringlists are in the exact order. 
            e.g if string A = {x, y} and string B = {x, y} this function will return TRUE
            but if string B = {y, x} then this function will return FALSE.
            Their corresponding data members should also match

	Params:
        CSTRINGLIST& strlTemp: The right hand side of the == operator

	Return:
        TRUE:   The string lists are similar
        FALSE:  The two string lists are different
--*/
{   
    PSTRLIST tempHeadOne = m_pHead; 
    PSTRLIST tempHeadTwo = strlTemp.m_pHead;

    if (m_uCount != strlTemp.m_uCount) {
        
        Dbg(dlInfo, "CSTRINGLIST::operator == ", "Lengths are different for the two stringlists so we will return FALSE");
        return FALSE;
    }

    while (tempHeadOne && tempHeadTwo) {

        if (!(tempHeadOne->szStr == tempHeadTwo->szStr 
              && tempHeadOne->data == tempHeadTwo->data)) {
            return FALSE;
        }

        tempHeadOne = tempHeadOne->pNext;
        tempHeadTwo = tempHeadTwo->pNext;
    }
    
    return TRUE;
}

BOOL 
CSTRINGLIST::Remove(
    IN  CSTRING &str
    )
/*++
    CSTRINGLIST::Remove

	Desc:	Removes the element with CSTRING value of str from this string list

	Params:
        IN  CSTRING &str:   The CSTRING to remove

	Return:
--*/
{
    PSTRLIST pHead = m_pHead, pPrev = NULL;

    while (pHead) {

        if (pHead->szStr == str) {
            break;
        }

        pPrev = pHead;
        pHead = pHead->pNext;
    }

    if (pHead) {

        if (pPrev == NULL) {
            //
            // First element.
            //
            m_pHead = pHead->pNext;
        } else {
            pPrev->pNext = pHead->pNext;
        }
        
        if (pHead == m_pTail) {
            //
            // Last element
            //
            m_pTail = pPrev;
        }

        delete pHead;
        pHead = NULL;

        --m_uCount;

        return TRUE;
    }

    return FALSE;
}

void 
CSTRINGLIST::RemoveLast(
    void
    )
/*++
    CSTRINGLIST::RemoveLast

	Desc:	Removes the last element from this string list

	Params:
        void

	Return:
        void
--*/
{
    if (m_pTail) {
        Remove(m_pTail->szStr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\ctree.cpp ===
#include "precomp.h"

/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    CTree.cpp

Abstract:

    Wrapper for some general tree functions
        
Author:

    kinshu created  October 15, 2001

--*/

BOOL
CTree::SetLParam(
    IN  HWND        hwndTree,
    IN  HTREEITEM   hItem, 
    IN  LPARAM      lParam
    )
/*++ 

    CTree::SetLParam
    
    Desc:   Sets the lParam of a tree item
    
    Params:
        IN  HWND        hwndTree:   The handle to the tree
        IN  HTREEITEM   hItem:      The tree item
        IN  LPARAM      lParam:     The lParam to set
        
    Return:
        TRUE:   If the lParam was set properly
        FALSE:  Otherwise
        
--*/
{   
    TVITEM  Item;

    Item.mask   = TVIF_PARAM;
    Item.hItem  = hItem;
    Item.lParam = lParam;

    return TreeView_SetItem(hwndTree, &Item);
}

BOOL
CTree::GetLParam(
    IN  HWND      hwndTree,
    IN  HTREEITEM hItem, 
    OUT LPARAM*   plParam
    )
/*++

    CTree::GetLParam
    
    Desc:   Gets the lParam of a tree item
    
    Params:
        IN  HWND        hwndTree:   The handle to the tree
        IN  HTREEITEM   hItem:      The tree item
        OUT LPARAM*     lParam:     The lParam will be stored here
        
    Return:
        TRUE:   If the lParam was obtained properly
        FALSE:  Otherwise
    
--*/
{
    TVITEM  Item;

    if (plParam == NULL) {
        assert(FALSE);
        return FALSE;
    }

    *plParam = 0;

    Item.mask   = TVIF_PARAM;
    Item.hItem  = hItem;

    if (TreeView_GetItem(hwndTree, &Item)) {
        *plParam = Item.lParam;
        return TRUE;
    }

    return FALSE;
}

HTREEITEM
CTree::FindChild(
    IN  HWND       hwndTree,
    IN  HTREEITEM  hItemParent,
    IN  LPARAM     lParam
    )
/*++

    CTree::FindChild
        
    Desc:   Given a parent item and a lParam, finds the first child of the parent, with 
            that value of lParam. This function only searches in the next level and not all
            the generations of the parent
            
    Params: 
        IN  HWND       hwndTree:    The handle to the tree
        IN  HTREEITEM  hItemParent: The hItem of the parent
        IN  LPARAM     lParam:      The lParam to search for
            
    Return: The handle to the child or NULL if it does not exist        
--*/
{
    HTREEITEM hItem = TreeView_GetChild(hwndTree, hItemParent);

    while (hItem) {

        LPARAM lParamOfItem;

        if (!GetLParam(hwndTree, hItem, &lParamOfItem)) {
            assert(FALSE);
            return NULL;
        }

        if (lParamOfItem == lParam) {
            return hItem;
        } else {
            hItem = TreeView_GetNextSibling(hwndTree, hItem);
        }
    }

    return NULL;
}

BOOL
CTree::GetTreeItemText(
    IN  HWND        hwndTree,
    IN  HTREEITEM   hItem,
    OUT PTSTR       pszText,
    IN  UINT        cchText
    )
/*++

    CTree::GetTreeItemText
    
	Desc:	Gets the text of a tree view item

	Params:
        IN  HWND        hwndTree:   The handle to the tree
        IN  HTREEITEM   hItem:      The item whose text we want to find
        OUT TCHAR       *pszText:   This will store the text
        IN  UINT        cchText:    Number of TCHARS that can be stored in pszText

	Return:
        TRUE:   successful
        FALSE:  Otherwise
--*/

{
    TVITEM          Item;

    Item.mask       = TVIF_TEXT;
    Item.hItem      = hItem;
    Item.pszText    = pszText;
    Item.cchTextMax = cchText;

    return TreeView_GetItem(hwndTree,&Item);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\customlayer.h ===
enum
{
    LAYERMODE_ADD=0,
    LAYERMODE_EDIT
};

/*++

    class CCustomLayer

	Desc:	Used for creating or editing a custom compatibility layer

	Members:
        UINT    m_uMode:    The type of operation we want to perform. One of LAYERMODE_ADD,
            LAYERMODE_EDIT
--*/

class CCustomLayer
{
    public:

        UINT        m_uMode;
        PDATABASE   m_pCurrentSelectedDB;

    public:

        BOOL 
        AddCustomLayer(
            PLAYER_FIX  pLayer,
            PDATABASE   pPresentDatabase
            );

        BOOL
        EditCustomLayer(
            PLAYER_FIX  pLayer,
            PDATABASE   pPresentDatabase
            );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\customlayer.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    customlayer.cpp

Abstract:

    Code for creating, removing and editing custom layers
    
Author:

    kinshu created  July 2, 2001
    
Revision History:

--*/
    
#include "precomp.h"

//////////////////////// Extern variables /////////////////////////////////////

extern HWND         g_hDlg;
extern HINSTANCE    g_hInstance;
extern HIMAGELIST   g_hImageList;
extern DatabaseTree DBTree; 
extern struct DataBase GlobalDataBase;


///////////////////////////////////////////////////////////////////////////////

//////////////////////// Global Variables /////////////////////////////////////

// Pointer to the instance of CCustomLayer
CCustomLayer* g_pCustomLayer;

//
// The layer that was passed to us through the lParam when we created the dialog. 
// If we are editing a layer, this will point to the layer being modified. If we want to 
// create a new layer, the caller of the dialog box, creates a new layer and passes the pointer
// to that while calling the dialog box. If user presses cancel when creating a new layer, caller
// must free the new layer.
static PLAYER_FIX s_pLayerParam = NULL;

///////////////////////////////////////////////////////////////////////////////


//////////////////////// Function Declarations ///////////////////////////////


void
ResizeControls(
    HWND hdlg
    );

void
RemoveAll(
    HWND hDlg
    );

void
SetOkParamsStatus(
    HWND    hdlg
    );

BOOL
HandleNotifyShimList(
    HWND    hDlg, 
    LPARAM  lParam
    );

BOOL
HandleNotifyLayerList(
    HWND    hDlg, 
    LPARAM  lParam
    );

void
ShowParams(
    HWND    hDlg,
    HWND    hwndList
    );

void
RemoveSingleItem(
    HWND    hdlg,
    INT     iIndex,
    BOOL    bOnlySelected
    );

void
OnCopy(
    HWND hdlg
    );

void
LoadCombo(
    HWND hdlg
    );

INT_PTR
CALLBACK 
CustomLayerProc(
    HWND    hDlg, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

INT_PTR
CALLBACK 
ChooseLayersProc(
    HWND    hDlg, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

void
OnDone(
    HWND        hDlg,
    PLAYER_FIX  pLayerParam
    );

void
PopulateLists(
    HWND        hdlg,
    PLAYER_FIX  pLayerParam,
    BOOL       bSelChange
    );

///////////////////////////////////////////////////////////////////////////////

BOOL
CheckLayerInUse(
    IN  PLAYER_FIX_LIST plfl, 
    IN  PLAYER_FIX      plfArg
    )
/*++

    CheckLayerInUse

	Desc:	Checks if the layer plfArg is pointed to by plfl. This is used when we want to 
            check if some layer list contains a particular layer

	Params:
        IN  PLAYER_FIX_LIST plfl:   The layer list in which to check
        IN  PLAYER_FIX      plfArg: The layer to check

	Return:
        TRUE:   If the layer exists in the layer list
        FALSE:  Otherwise
--*/
{
    if (plfl == NULL) {
        return FALSE;
    }

    //
    // For all the layer fix lists in the list headed by plfl, check if any one of 
    // is for plfArg
    //
    while (plfl) {

        assert(plfl->pLayerFix);

        if (plfl->pLayerFix == plfArg) {
            return TRUE;
        }

        plfl = plfl->pNext;
    }

    return FALSE;
}

void
OnRemove(
    IN  HWND hDlg
    )
/*++
    OnRemove

	Desc:   Moves a selected list item from the layer list (RHS) to the shim list (LHS)

	Params:
        IN  HWND hDlg:  The handle to the customlayer dialog    

	Return:
        void
--*/
{
    HWND            hwndLayerList  = GetDlgItem(hDlg, IDC_LAYERLIST);
    HWND            hwndShimList   = GetDlgItem(hDlg, IDC_SHIMLIST);
    LVITEM          lvi;
    INT             nCount;
    INT             nTotal;
    PSHIM_FIX_LIST  psflInLayerList = NULL;
    PFLAG_FIX_LIST  pfflInLayerList = NULL;

    ZeroMemory(&lvi, sizeof(lvi));

    SendMessage(hwndLayerList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndShimList, WM_SETREDRAW, FALSE, 0);

    //
    // Enumerate all the selected items and add them to the shim list
    //
    nTotal = ListView_GetItemCount(hwndLayerList);

    for (nCount= nTotal - 1; nCount >= 0; --nCount) {
        RemoveSingleItem(hDlg, nCount, TRUE); // Remove only if selected
    }

    SendMessage(hwndLayerList, WM_SETREDRAW, TRUE, 0);
    SendMessage(hwndShimList, WM_SETREDRAW, TRUE, 0);

    InvalidateRect(hwndShimList, NULL, TRUE);
    InvalidateRect(hwndLayerList, NULL, TRUE);

    UpdateWindow(hwndShimList);
    UpdateWindow(hwndLayerList);
}

void
OnAdd(
    IN  HWND hDlg
    )
/*++
    OnAdd

	Desc:   Moves a selected list item from the shim list (LHS) to the layer list (RHS)  

	Params:
        IN  HWND hDlg:  The handle to the customlayer dialog    

	Return:
        void
--*/

{
    HWND            hwndShimList  = GetDlgItem(hDlg, IDC_SHIMLIST);
    HWND            hwndLayerList = GetDlgItem(hDlg, IDC_LAYERLIST);
    PSHIM_FIX_LIST  psflInShimList = NULL;
    PFLAG_FIX_LIST  pfflInShimList = NULL;
    LVITEM          lvi;
    INT             nCount;
    INT             nTotal;

    ZeroMemory(&lvi, sizeof(lvi));

    SendMessage(hwndShimList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndLayerList, WM_SETREDRAW, FALSE, 0);
    
    nTotal = ListView_GetItemCount(hwndShimList);

    //
    // Enumerate all the selected items and add them to the layer list
    //
    for (nCount= nTotal - 1; nCount >= 0; --nCount) {

        lvi.mask        = LVIF_PARAM | LVIF_STATE ;
        lvi.stateMask   = LVIS_SELECTED;
        lvi.iItem       = nCount;
        lvi.iSubItem    = 0;

        if (!ListView_GetItem(hwndShimList, &lvi)) {
            assert(FALSE);
            continue;
        }

        if (lvi.state & LVIS_SELECTED) {

            TYPE type = ConvertLparam2Type(lvi.lParam);

            if (type == FIX_LIST_SHIM) {
                //
                // This is a shim
                //
                psflInShimList = (PSHIM_FIX_LIST)lvi.lParam;

                if (psflInShimList->pShimFix == NULL) {
                    assert(FALSE);
                    continue;
                }
                
                lvi.mask        = LVIF_PARAM | LVIF_TEXT;
                lvi.pszText     = psflInShimList->pShimFix->strName.pszString;
                lvi.iImage      = IMAGE_SHIM;
                lvi.iItem       = 0;
                lvi.iSubItem    = 0;
                lvi.lParam      = (LPARAM)psflInShimList;

                INT iIndex = ListView_InsertItem(hwndLayerList, &lvi);

                //
                // Add the command line and the params in the expert mode
                //
                if (g_bExpert) {

                    //
                    // We need to set the commandline in the list view, if we are in
                    // expert mode. Unlike flags, shims  can have include-exclude params
                    // in addition to command line parameter
                    //
                    ListView_SetItemText(hwndLayerList, 
                                         iIndex, 
                                         1, 
                                         psflInShimList->strCommandLine);
    
                    ListView_SetItemText(hwndLayerList,
                                         iIndex, 
                                         2, 
                                         psflInShimList->strlInExclude.IsEmpty() ? 
                                         GetString(IDS_NO) : GetString(IDS_YES));
                }

            } else if (type ==  FIX_LIST_FLAG) {
                //
                // This is a flag
                //
                pfflInShimList = (PFLAG_FIX_LIST)lvi.lParam;

                if (pfflInShimList->pFlagFix == NULL) {
                    assert(FALSE);
                    continue;
                }
    
                lvi.mask        = LVIF_PARAM | LVIF_TEXT;
                lvi.pszText     = pfflInShimList->pFlagFix->strName.pszString;
                lvi.iImage      = IMAGE_SHIM;
                lvi.iItem       = 0;
                lvi.iSubItem    = 0;
                lvi.lParam      = (LPARAM)pfflInShimList;
                INT iIndex      = ListView_InsertItem(hwndLayerList, &lvi);

                if (g_bExpert) {
                    //
                    // We need to set the commandline in the list view, if we are in
                    // expert mode. Unlike shims flags can only have command lines, they
                    // do not have any include-exclude params
                    //
                    ListView_SetItemText(hwndLayerList, 
                                         iIndex, 
                                         1, 
                                         pfflInShimList->strCommandLine);

                    ListView_SetItemText(hwndLayerList, iIndex, 2, GetString(IDS_NO));
                }
            }

            //
            // Remove the shim or flag from the shim list (LHS)
            //
            ListView_DeleteItem(hwndShimList, nCount);
        }
    }

    SendMessage(hwndShimList, WM_SETREDRAW, TRUE, 0);
    SendMessage(hwndLayerList, WM_SETREDRAW, TRUE, 0);

    InvalidateRect(hwndLayerList, NULL, TRUE);
    InvalidateRect(hwndShimList, NULL, TRUE);

    UpdateWindow(hwndLayerList);
    UpdateWindow(hwndShimList);

}

BOOL 
CCustomLayer::AddCustomLayer(
    OUT PLAYER_FIX  pLayer,
    IN  PDATABASE   pDatabase
    )
/*++
    
    CCustomLayer::AddCustomLayer
    
    Desc:   Sets the shims and/or flags for a new layer    
    
    Params:
        OUT PLAYER_FIX pLayer:      The pointer to the layer for which we have to 
            set the shims and/or flags. If we return FALSE, the caller should delete
            it.
            
        IN  PDATABASE   pDatabase:  The presently selected database
        
            
    Return:
        TRUE: If the shims and/or flags have been properly set, the user pressed OK on the
            custom layer dialog
            
        FALSE:  Otherwise
--*/
{   
    g_pCustomLayer          = this;
    m_uMode                 = LAYERMODE_ADD;
    m_pCurrentSelectedDB    = pDatabase;
    
    return DialogBoxParam(g_hInstance,
                          MAKEINTRESOURCE(IDD_CUSTOMLAYER),
                          g_hDlg,
                          CustomLayerProc,
                          (LPARAM)pLayer);
}

BOOL
CCustomLayer::EditCustomLayer(
    IN OUT  PLAYER_FIX  pLayer,
    IN      PDATABASE   pDatabase
    )
/*++
    
    CCustomLayer::EditCustomLayer
    
    Desc:   Modifies the shims and/or flags for an existing layer    
    
    Params:
        IN OUT PLAYER_FIX pLayer:  The pointer to the layer for which we have to 
            set the shims and/or flags. If we return FALSE this means that the layer 
            was not modified            
            
        IN  PDATABASE   pDatabase:  The presnntly selected database
        
    Return:
        TRUE: If the shims and/or flags have been modified, the user pressed OK on the
            custom layer dialog
            
        FALSE:  Otherwise
--*/
{   
    g_pCustomLayer          = this;
    m_uMode                 = LAYERMODE_EDIT;
    m_pCurrentSelectedDB    = pDatabase;

    return DialogBoxParam(g_hInstance,
                          MAKEINTRESOURCE(IDD_CUSTOMLAYER),
                          g_hDlg,
                          CustomLayerProc,
                          (LPARAM)pLayer);
}

void
OnCustomLayerInitDialog(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++
    DoInitDialog
    
    Desc:   Handles the WM_INITDIALOG message for the custom layer dialog box
            If we are in non-expert mode, calls ResizeControls() so that the sizes
            of both the list views is same
            
    Params:
        IN  HWND hdlg:      The custom layer dialog.
        IN  LPARAM lParam:  This will contain the pointer to a LAYER_FIX
            This is the layer that was passed to us through the lParam when we created the 
            dialog. If we are editing a layer, this will point to the layer being 
            modified. If we want to create a new layer, the caller of the dialog box, 
            creates a new layer and passes the pointer to that while calling the 
            dialog box. If user presses cancel when creating a new layer, caller
            must free the new layer.
        
    Return:
        void
--*/
{   
    if (lParam == NULL) {
        assert(FALSE);
        return;
    }

    HWND    hwndLayerList   = GetDlgItem(hDlg, IDC_LAYERLIST);
    HWND    hwndShimList    = GetDlgItem(hDlg, IDC_SHIMLIST);

    //
    // Add the columns for the list views and set the image lists. The layer list
    // will have columns for the commandline and the include-exclude params only
    // in expert mode
    //
    ListView_SetImageList(hwndLayerList, g_hImageList, LVSIL_SMALL);
    ListView_SetImageList(hwndShimList, g_hImageList, LVSIL_SMALL);

    InsertColumnIntoListView(hwndShimList, 
                             CSTRING(IDS_COL_FIXNAME), 
                             0, 
                             100);

    InsertColumnIntoListView(hwndLayerList, 
                             CSTRING(IDS_COL_FIXNAME), 
                             0, 
                             g_bExpert ? 50 : 100);

    if (g_bExpert) {

        InsertColumnIntoListView(hwndLayerList, CSTRING(IDS_COL_CMDLINE), 1, 30);
        InsertColumnIntoListView(hwndLayerList, CSTRING(IDS_COL_MODULE),  2, 20);

        ListView_SetColumnWidth(hwndLayerList, 2, LVSCW_AUTOSIZE_USEHEADER);

    } else {
        //
        // We do not allow to configure parameters in non-expert mode
        //  
        ShowWindow(GetDlgItem(hDlg, IDC_PARAMS), SW_HIDE);
        ListView_SetColumnWidth(hwndLayerList, 0, LVSCW_AUTOSIZE_USEHEADER);
    }

    ListView_SetExtendedListViewStyleEx(hwndShimList, 
                                        0, 
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT); 

    ListView_SetExtendedListViewStyleEx(hwndLayerList, 
                                        0, 
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT); 
    //
    // When this dialog is called, it is passed a PLAYER_FIX. This will be either a
    // new PLAYER_FIX if want to create a new layer or an existing one in case
    // we are trying to modify an existing one
    // 
    s_pLayerParam = (PLAYER_FIX)lParam;

    if (g_pCustomLayer->m_uMode == LAYERMODE_ADD) {
        //
        // We are creating a new layer
        //
        ENABLEWINDOW(GetDlgItem(hDlg, IDC_NAME), TRUE);

        ShowWindow(GetDlgItem(hDlg, IDC_NAME), SW_SHOW);

        SendMessage(GetDlgItem(hDlg, IDC_NAME),
                    EM_LIMITTEXT,
                    (WPARAM) 
                    LIMIT_LAYER_NAME,
                    (LPARAM)0);
        
        ENABLEWINDOW(GetDlgItem(hDlg, IDOK), FALSE);

        SetFocus(GetDlgItem(hDlg, IDC_NAME));

    } else {
        //
        // We want to edit an existing layer
        //
        int iPos = -1;

        ENABLEWINDOW(GetDlgItem(hDlg, IDC_COMBO), TRUE);

        ShowWindow  (GetDlgItem(hDlg, IDC_COMBO), SW_SHOW);

        //
        // Load the combo box with the names of the existing layers 
        // for the present database.
        //
        LoadCombo(hDlg);

        //
        // Set the selection in the combo box to the layer that was passed to us
        //
        if (s_pLayerParam) {

            iPos = SendMessage(GetDlgItem(hDlg, IDC_COMBO),
                               CB_SELECTSTRING,
                               (WPARAM)0,
                               (LPARAM)(s_pLayerParam->strName.pszString));

            assert(iPos !=  CB_ERR);
        }

        SetFocus(GetDlgItem(hDlg, IDC_COMBO));
        SetWindowText (hDlg, GetString(IDS_EDITCUSTOMCOMPATDLG));
    }

    //
    // Populate both the shim list and the layer lust. Since we are 
    // editing a layer here, the layer list will contain the fixes for 
    // the layer being edited
    //
    PopulateLists(hDlg, s_pLayerParam, FALSE);

    if (g_bExpert == FALSE) {
        //
        // We are in non-expert mode, so we must make the sizes of both the list view
        // controls equal as we will now not show the command lines and the params of
        // the shims in the layer list view(RHS). We will also need to move the buttons
        // 
        ResizeControls(hDlg);
    }

    SetFocus(GetDlgItem(hDlg, IDC_SHIMLIST));
}

BOOL 
CALLBACK 
CustomLayerProc(
    IN  HWND hDlg, 
    IN  UINT uMsg, 
    IN  WPARAM wParam, 
    IN  LPARAM lParam
    )
/*++
    
    CustomLayerProc
    
    Desc:   The dialog proc for the custom layer
                
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam: This will contain the pointer to a LAYER_FIX
            This is the layer that was passed to us thorugh the lParam when we created the 
            dialog. If we are editing a layer, this will point to the layer being 
            modified. If we want to create a new layer, the caller of the dialog box, 
            creates a new layer and passes the pointer to that while calling the 
            dialog box. If user presses cancel when creating a new layer, caller
            must free the new layer.
        
    Return: Standard dialog handler return
    
--*/
{   
    switch (uMsg) {
    case WM_INITDIALOG:

        OnCustomLayerInitDialog(hDlg, lParam);
        break;

    case WM_NOTIFY:
            {
                LPNMHDR lpnmhdr = (LPNMHDR)lParam;

                if (lpnmhdr == NULL) {
                    break;
                }

                if (lpnmhdr->idFrom == IDC_SHIMLIST) {
                    return HandleNotifyShimList(hDlg, lParam);

                } else if (lpnmhdr->idFrom == IDC_LAYERLIST) {
                    return HandleNotifyLayerList(hDlg, lParam);

                } else {
                    return FALSE;
                }       

                break;
            }

    case WM_DESTROY:
            {
                HWND    hwndLayerList = GetDlgItem(hDlg, IDC_SHIMLIST);
                int     nTotal = ListView_GetItemCount(hwndLayerList);
                LVITEM  lvi;

                ZeroMemory(&lvi, sizeof(lvi));

                lvi.mask        = LVIF_PARAM;
                lvi.iSubItem    = 0;

                //
                // Enumerate all the shims/flags listed on the shim side and delete 
                // their corresponding PSHIM_FIX_LIST
                // or PFLAG_FIX_LIST
                //
                for (int nCount = 0; nCount < nTotal; ++nCount) {
                    
                    lvi.iItem = nCount;

                    if (!ListView_GetItem(hwndLayerList, &lvi)) {
                        assert(FALSE);
                        continue;
                    }

                    TYPE type = ConvertLparam2Type(lvi.lParam);

                    if (type == FIX_LIST_SHIM) {
                        DeleteShimFixList((PSHIM_FIX_LIST)lvi.lParam);

                    } else if (type == FIX_LIST_FLAG) {
                        DeleteFlagFixList((PFLAG_FIX_LIST)lvi.lParam);

                    } else {
                        //
                        // Invalid type for this operation
                        //
                        assert(FALSE);
                    }
                }

                break;
            }

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
        case IDC_NAME:
            {
                //
                // The Ok button will be enabled only if the IDC_NAME, text box is non-empty and the 
                // the number of elements in the IDC_LAYERLIST is > 0
                //
                if (EN_UPDATE == HIWORD(wParam)) {

                    TCHAR   szText[MAX_PATH_BUFFSIZE];
                    UINT    uTotal = ListView_GetItemCount(GetDlgItem(hDlg, 
                                                                      IDC_LAYERLIST));
                    BOOL    bEnable = TRUE;

                    *szText = 0;

                    GetDlgItemText(hDlg, 
                                   IDC_NAME,
                                   szText, 
                                   ARRAYSIZE(szText));

                    bEnable = (uTotal > 0) && CSTRING::Trim(szText);
                    
                    ENABLEWINDOW(GetDlgItem(hDlg, IDOK), bEnable);
                }
            }

            break;

        case IDC_REMOVEALL:

            RemoveAll(hDlg);
            break;

        case IDC_COPY:  

            OnCopy(hDlg);
            SetOkParamsStatus(hDlg);
            break;

        case IDC_ADD:   

            OnAdd(hDlg);
            SetOkParamsStatus(hDlg);
            break;

        case IDC_REMOVE:

            OnRemove(hDlg);
            SetOkParamsStatus(hDlg);
            break;

        case IDOK://DONE Button

            OnDone(hDlg, s_pLayerParam);
            break;

        case IDC_PARAMS:

            ShowParams(hDlg, GetDlgItem(hDlg, IDC_LAYERLIST));
            break;
        
        case IDCANCEL:
        case IDC_CANCEL:
            {
                //
                // Note:    We only free the items for the layer list here.
                //          The items for the shim list will be freed up in destroy            
                //
                HWND    hwndLayerList = GetDlgItem(hDlg, IDC_LAYERLIST);
                int     nTotal = ListView_GetItemCount(hwndLayerList);
                LVITEM  lvi;

                ZeroMemory(&lvi, sizeof(lvi));

                lvi.mask        = LVIF_PARAM;
                lvi.iSubItem    = 0;

                //
                // Enumerate all the shims/flags listed on the layer side and delete 
                // their corresponding PSHIM_FIX_LIST
                // or PFLAG_FIX_LIST
                //
                for (int nCount = 0; nCount < nTotal; ++nCount) {
                    
                    lvi.iItem = nCount;

                    if (!ListView_GetItem(hwndLayerList, &lvi)) {
                        assert(FALSE);
                        continue;
                    }

                    TYPE type = ConvertLparam2Type(lvi.lParam);

                    if (type == FIX_LIST_SHIM) {
                        DeleteShimFixList((PSHIM_FIX_LIST)lvi.lParam);

                    } else if (type == FIX_LIST_FLAG) {
                        DeleteFlagFixList((PFLAG_FIX_LIST)lvi.lParam);

                    } else {
                        //
                        // Invalid type for this operation
                        //
                        assert(FALSE);
                    }
                }

                EndDialog(hDlg, FALSE);
            }

            break;

        case IDC_COMBO:
            {
                HWND hwndCombo = GetDlgItem(hDlg, IDC_COMBO);

                if (HIWORD(wParam) == CBN_SELCHANGE) {
                    
                    int iPos = SendMessage(hwndCombo,
                                           CB_GETCURSEL,
                                           0,
                                           0);

                    if (iPos == CB_ERR) {
                        break;
                    }

                    s_pLayerParam = (PLAYER_FIX)SendMessage(hwndCombo, 
                                                            CB_GETITEMDATA, 
                                                            iPos, 
                                                            0);
                    //
                    // We need to repopulate the lists with the new layer that was selected
                    //
                    PopulateLists(hDlg, s_pLayerParam, TRUE);

                } else {
                    return FALSE;
                }
            }

            break;
        
        default:

            return FALSE;
            break;
        }

    default:return FALSE;
    }
    
    return TRUE;
}

INT_PTR
CALLBACK 
ChooseLayersProc(
    IN  HWND    hDlg, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++
    
    ChooseLayersProc
    
    Desc:   The dialog proc for the dialog that allows us to choose a layer, when we do a Copy
            layer operation from the custom layer dialog
                
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: 
        PLAYER_FIX of selected layer, if OK is pressed
        NULL, otherwise
--*/
{
    switch (uMsg) {
    case WM_INITDIALOG:
        {
            PLAYER_FIX    pLayerFix = NULL;
            //
            // Add the global layers
            //
            pLayerFix = GlobalDataBase.pLayerFixes;

            while (NULL != pLayerFix) {

                int nIndex = SendDlgItemMessage(hDlg,
                                                IDC_LIST,
                                                LB_ADDSTRING,
                                                0,
                                                (LPARAM)(LPCTSTR)pLayerFix->strName);

                if (LB_ERR != nIndex) {

                    SendDlgItemMessage(hDlg, 
                                       IDC_LIST, 
                                       LB_SETITEMDATA, 
                                       nIndex,
                                       (LPARAM)pLayerFix);
                }

                pLayerFix = pLayerFix->pNext;
            }
            //
            // Add the custom layers
            //
            pLayerFix = g_pCustomLayer->m_pCurrentSelectedDB->pLayerFixes;

            while (NULL != pLayerFix) {

                int nIndex = SendDlgItemMessage(hDlg,
                                                IDC_LIST,
                                                LB_ADDSTRING,
                                                0,
                                                (LPARAM)(LPCTSTR)pLayerFix->strName);

                if (LB_ERR != nIndex) {

                    SendDlgItemMessage(hDlg, 
                                       IDC_LIST, 
                                       LB_SETITEMDATA, 
                                       nIndex,
                                       (LPARAM)pLayerFix);
                }

                pLayerFix = pLayerFix->pNext;
            }

            SendMessage(GetDlgItem(hDlg, IDC_LIST), LB_SETCURSEL, (WPARAM)0, (LPARAM)0);

            SetFocus(GetDlgItem (hDlg, IDC_LIST));
        }

        break;

    case WM_COMMAND:
        {
            switch (LOWORD(wParam)) {
            case IDC_LIST:
                
                if (LB_ERR == SendMessage(GetDlgItem(hDlg, IDC_LIST), LB_GETCURSEL, 0, 0)) {
                    ENABLEWINDOW(GetDlgItem(hDlg, IDOK), FALSE);

                } else {
                    ENABLEWINDOW(GetDlgItem(hDlg, IDOK), TRUE);
                }
                
                break;

            case IDOK:
                {
                    int nIndex = SendMessage(GetDlgItem(hDlg, IDC_LIST), LB_GETCURSEL, 0, 0);
                    

                    PLAYER_FIX pLayerTemp = (PLAYER_FIX) SendDlgItemMessage(hDlg,
                                                                            IDC_LIST,
                                                                            LB_GETITEMDATA,
                                                                            nIndex,
                                                                            0);

                    if (pLayerTemp == NULL) {
                        assert(FALSE);
                        break;
                    }

                    EndDialog(hDlg, (INT_PTR)pLayerTemp);
                }

                break;

            case IDCANCEL:

                EndDialog(hDlg, NULL);
                break;
            }
        }

        break;
    }

    return FALSE;
}

BOOL
RemoveLayer(
    IN  PDATABASE  pDataBase,
    IN  PLAYER_FIX pLayerToRemove,
    OUT HTREEITEM* pHItem
    )
/*++

    RemoveLayer
    
    Desc:   Removes a layer from a database
    
    Params:
        IN  PDATABASE  pDataBase:       The database in which the layer resides
        IN  PLAYER_FIX pLayerToRemove:  The layer to remove
        OUT HTREEITEM* pHItem:          If this not null, then we can save the hitem
            for the layer in the db tree in this variable
            
    Warn:   Before removing a layer we must make sure that this layer is not in use
    
    Return: 
        TRUE:   We managed to remove the layer
        FALSE:  Otherwise
    
--*/
{   
    HTREEITEM   hItem;
    LPARAM      lParam;
    PDBENTRY    pEntry  = NULL, pApp = NULL;
    PLAYER_FIX  plfTemp = NULL;
    PLAYER_FIX  plfPrev = NULL;
    CSTRING     strMessage;

    if (pDataBase == NULL || pLayerToRemove == NULL) {
        assert(FALSE);
        return FALSE;
    }

    pApp = pEntry = pDataBase->pEntries;

    //
    // Check if the layer is in use by any entry
    //
    while (NULL != pEntry) {

        if (CheckLayerInUse(pEntry->pFirstLayer, pLayerToRemove)) {
            //
            // This layer is applied to some app and cannot be removed
            //

            strMessage.Sprintf(GetString(IDS_UNABLETOREMOVE_MODE),
                               (LPCTSTR)pLayerToRemove->strName,
                               (LPCTSTR)pEntry->strExeName,
                               (LPCTSTR)pEntry->strAppName);

            MessageBox(g_hDlg,
                       (LPCTSTR)strMessage,   
                       g_szAppName,                  
                       MB_ICONWARNING);                                        

            return FALSE;
        }

        if (pEntry->pSameAppExe) {
            pEntry = pEntry->pSameAppExe;
        } else {
            pEntry  = pApp->pNext;
            pApp    = pApp->pNext;
        }
    }

    plfTemp =  pDataBase->pLayerFixes, plfPrev = NULL;

    while (plfTemp) {

        if (plfTemp == pLayerToRemove) {
            break;
        }

        plfPrev = plfTemp;
        plfTemp = plfTemp->pNext;
    }

    if (plfTemp) {
        //
        // The layer was found
        //
        if (plfPrev) {
            plfPrev->pNext = plfTemp->pNext;
        } else {
            //
            // This was the first layer of the database
            //
            pDataBase->pLayerFixes = plfTemp->pNext;
        }
    }

    hItem = pDataBase->hItemAllLayers;

    //
    // Set the phItem properly if asked to. This is the hItem of the layer in the Lib Tree. This can be used to 
    // remove the item directly.
    //
    if (pHItem) {

        *pHItem = NULL;

        while (hItem) {
            
            DBTree.GetLParam(hItem, &lParam);

            if ((PLAYER_FIX)lParam == pLayerToRemove) {
                *pHItem  = hItem;
                break;
            }

            hItem = TreeView_GetNextSibling(DBTree.m_hLibraryTree, hItem);
        }
    }

    ValidateClipBoard(NULL, (LPVOID)plfTemp);

    if (plfTemp) {
        delete plfTemp;
        plfTemp = NULL;
    }
    
    pDataBase->uLayerCount--;
    return TRUE;
}

void
PopulateLists(
    IN  HWND        hdlg,
    IN  PLAYER_FIX  pLayerParam,
    IN  BOOL        bSelChange
    )
/*++
    
    PopulateLists

	Desc:	Populates both the shim list (LHS) and the layer list (RHS)

	Params:
        IN  HWND        hdlg:           The custom layer dialog proc
        IN  PLAYER_FIX  pLayerParam:    The layer that has to be shown in the layer list
        IN  BOOL        bSelChange:     Is this because of a selchange in the combo box 

	Return:
        void
--*/
{   
    HWND        hwndShimList    = GetDlgItem(hdlg, IDC_SHIMLIST);
    HWND        hwndLayerList   = GetDlgItem(hdlg, IDC_LAYERLIST);
    PSHIM_FIX   psf             = GlobalDataBase.pShimFixes;
    PFLAG_FIX   pff             = GlobalDataBase.pFlagFixes;
    INT         iIndex          = 0;
    LVITEM      lvi;

    ZeroMemory(&lvi, sizeof (lvi));

    //
    // Turn off repaints
    //
    SendDlgItemMessage(hdlg, IDC_SHIMLIST, WM_SETREDRAW, FALSE, 0);
    SendDlgItemMessage(hdlg, IDC_LAYERLIST, WM_SETREDRAW, FALSE, 0);

    //
    // This is because of a selchange in the combo box. So we must 
    // remove all the shims that are shown in the layer list. This means that we
    // will move the entries from the layer list to the shim list
    //
    if (bSelChange) {
        RemoveAll(hdlg);
    }
    
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;

    if (!bSelChange) {

        //
        // The function has been called because of the initialization of the dialog box
        // If we are editing a layer, pLayerParam will be the pointer to the layer
        // being edited
        //

        //
        // Add the shims first
        //
        while (psf != NULL) {

            if ((psf->bGeneral || g_bExpert) && 
                !ShimFlagExistsInLayer(psf, pLayerParam, FIX_SHIM)) {

                //
                // Add a new shim item to the shim list view
                //
                PSHIM_FIX_LIST  psfl = new SHIM_FIX_LIST;

                if (psfl == NULL) {
                    MEM_ERR;
                    return;
                }

                psfl->pShimFix = psf;

                lvi.pszText     = psf->strName;
                lvi.iSubItem    = 0;
                lvi.lParam      = (LPARAM)psfl;
                lvi.iImage      = IMAGE_SHIM;
                lvi.iItem       = 0;
        
                ListView_InsertItem(hwndShimList, &lvi);
            }

            psf = psf->pNext;
        }

        //
        // Add the flags next
        //
        while (pff != NULL) {

            if ((pff->bGeneral || g_bExpert) && 
                !ShimFlagExistsInLayer(pff, pLayerParam, FIX_FLAG)) {

                //
                // Add a new flag item to the shim list view
                //
                PFLAG_FIX_LIST  pffl = new FLAG_FIX_LIST;

                if (pffl == NULL) {
                    MEM_ERR;
                    return;
                }

                pffl->pFlagFix = pff;

                lvi.pszText     = pff->strName;
                lvi.iSubItem    = 0;
                lvi.lParam      = (LPARAM)pffl;
                lvi.iItem       = 0;
                lvi.iImage      = IMAGE_SHIM;

                ListView_InsertItem(hwndShimList, &lvi);
            }

            pff = pff->pNext;
        }
    }

    if (NULL != pLayerParam) {

        PSHIM_FIX_LIST  psflInLayer = pLayerParam->pShimFixList;
        PFLAG_FIX_LIST  pfflInLayer = pLayerParam->pFlagFixList;
        
        //
        // Copy the shims to the layer list
        //
        while (psflInLayer) {

            if (psflInLayer->pShimFix == NULL) {
                assert(FALSE);
                goto Next_Shim;
            }

            //
            // Add a new shim item to the layer list view
            //
            PSHIM_FIX_LIST  psfl = new SHIM_FIX_LIST;

            if (psfl == NULL) {
                MEM_ERR;
                break;
            }

            psfl->pShimFix = psflInLayer->pShimFix;

            //
            // Add the command lines for this shim
            //
            psfl->strCommandLine = psflInLayer->strCommandLine;

            //
            // Add the inclusion-exclusion list for this shim
            //
            psfl->strlInExclude = psflInLayer->strlInExclude;  

            //
            // Copy the LUA data
            //
            if (psflInLayer->pLuaData) {
                psfl->pLuaData = new LUADATA;

                if (psfl->pLuaData == NULL) {
                    MEM_ERR;
                    return;
                }

                psfl->pLuaData->Copy(psflInLayer->pLuaData);
            }

            lvi.pszText     = psflInLayer->pShimFix->strName;
            lvi.iSubItem    = 0;
            lvi.lParam      = (LPARAM)psfl;
            lvi.iItem       = 0;
            lvi.iImage      = IMAGE_SHIM;

            iIndex = ListView_InsertItem(hwndLayerList, &lvi);

            if (g_bExpert) {
                ListView_SetItemText(hwndLayerList, 
                                     iIndex, 
                                     1, 
                                     psfl->strCommandLine);

                ListView_SetItemText(hwndLayerList, 
                                     iIndex, 
                                     2, 
                                     psfl->strlInExclude.IsEmpty() ? GetString(IDS_NO) : GetString(IDS_YES));
            }

        Next_Shim:

            psflInLayer = psflInLayer->pNext;
        }

        //
        // Copy the flags to the layer list
        //
        while (pfflInLayer) {

            if (pfflInLayer->pFlagFix == NULL) {
                assert(FALSE);
                goto Next_Flag;
            }

            //
            // Add a new flag item to the layer list view
            //
            PFLAG_FIX_LIST  pffl = new FLAG_FIX_LIST;

            if (pffl == NULL) {
                MEM_ERR;
                return;
            }   

            pffl->pFlagFix = pfflInLayer->pFlagFix;
            
            //
            // Add the command lines for this flag
            //
            pffl->strCommandLine = pfflInLayer->strCommandLine;

            lvi.pszText     = pfflInLayer->pFlagFix->strName;
            lvi.iSubItem    = 0;
            lvi.lParam      = (LPARAM)pffl;
            lvi.iItem       = 0;
            lvi.iImage      = IMAGE_SHIM;

            INT iIndexFlag = ListView_InsertItem(hwndLayerList, &lvi);

            if (g_bExpert) {
                ListView_SetItemText(hwndLayerList, 
                                     iIndexFlag, 
                                     1, 
                                     pffl->strCommandLine);
            }

        Next_Flag:

            pfflInLayer = pfflInLayer->pNext;
        }

        SendDlgItemMessage(hdlg, IDC_SHIMLIST, WM_SETREDRAW, TRUE, 0);
        InvalidateRect(GetDlgItem(hdlg, IDC_SHIMLIST), NULL, TRUE);   
        UpdateWindow(GetDlgItem(hdlg, IDC_SHIMLIST));               

        SendDlgItemMessage(hdlg, IDC_LAYERLIST, WM_SETREDRAW, TRUE, 0);
        InvalidateRect(GetDlgItem(hdlg, IDC_LAYERLIST), NULL, TRUE);  
        UpdateWindow(GetDlgItem(hdlg, IDC_LAYERLIST));

    } else {
        assert(FALSE);
    }
}

void
LoadCombo(
    IN  HWND hdlg
    )
/*++
    
    LoadCombo    
    
    Desc:   Loads the combo box with the names of the existing layers for the present database.
            Sets the lParam to the PLAYER_FIX for the layer
            Should be called when editing layers only
            
    Params:
        IN  HWND        hdlg:   The custom layer dialog proc
--*/    
{

    PLAYER_FIX  plf         = g_pCustomLayer->m_pCurrentSelectedDB->pLayerFixes;
    int         iPos        = -1;
    HWND        hwndCombo   = GetDlgItem(hdlg, IDC_COMBO);

    //
    // Add all the layers for the database to the combo-box
    //
    while (plf) {

        iPos = SendMessage(hwndCombo, CB_ADDSTRING, 0,(LPARAM)plf->strName.pszString);

        if (iPos != CB_ERR) {
            SendMessage(hwndCombo, CB_SETITEMDATA, (WPARAM)iPos, (LPARAM)plf);
        }

        plf = plf->pNext;
    }
}

void
OnCopy(
    IN  HWND hDlg
    )
/*++

    OnCopy
    
    Desc:   Handles the case when the user presses "Copy" button in the dialog box
    
            This routine allows us to make shim combinations based on existing layers
            The commandline and the in-ex list of the shims in the layers are also copied
            
    Params:
        IN  HWND        hdlg:   The custom layer dialog proc
--*/
{
    LVITEM  lvi;
    INT     iIndex;
    HWND    hwndShimList    = GetDlgItem(hDlg, IDC_SHIMLIST);
    HWND    hwndLayerList   = GetDlgItem(hDlg, IDC_LAYERLIST);

    ZeroMemory(&lvi, sizeof(lvi));

    HWND hwndFocus = GetFocus();

    //
    // Get the layer whose shims/flags we want to copy
    //
    PLAYER_FIX plfSelected = (PLAYER_FIX)DialogBox(g_hInstance,
                                                   MAKEINTRESOURCE(IDD_SELECTLAYER),
                                                   hDlg,
                                                   ChooseLayersProc);

    if (plfSelected) {

        PSHIM_FIX_LIST  psfl = plfSelected->pShimFixList;
        PFLAG_FIX_LIST  pffl = plfSelected->pFlagFixList;

        PSHIM_FIX_LIST  psflInShimList = NULL;
        PFLAG_FIX_LIST  pfflInShimList = NULL;
        LVFINDINFO      lvfind;

        SendDlgItemMessage(hDlg, IDC_SHIMLIST, WM_SETREDRAW, FALSE, 0);
        SendDlgItemMessage(hDlg, IDC_LAYERLIST, WM_SETREDRAW, FALSE, 0);

        lvfind.flags = LVFI_STRING;

        //
        // Add over all the shims for this layer that we want to copy
        //
        while (psfl) {

            if (psfl->pShimFix == NULL) {
                assert(FALSE);
                goto Next_Shim;
            }

            lvfind.psz      = psfl->pShimFix->strName.pszString;
            iIndex          = ListView_FindItem(hwndShimList, -1, &lvfind);

            if (iIndex != -1) {
                //
                // This was a general shim, we have to add this to the layer list
                //
                lvi.mask        = LVIF_PARAM;
                lvi.iItem       = iIndex;
                lvi.iSubItem    = 0;
    
                if (!ListView_GetItem(hwndShimList, &lvi)) {
                    assert(FALSE);
                    goto Next_Shim;
                }

                psflInShimList = (PSHIM_FIX_LIST)lvi.lParam;
    
                psflInShimList->strCommandLine  = psfl->strCommandLine;
                psflInShimList->strlInExclude   = psfl->strlInExclude;
    
                //
                // LUA data. This will be not required but just in case ...
                //
                if (psflInShimList->pLuaData) {
                    delete psflInShimList->pLuaData;
                    psflInShimList->pLuaData = NULL;
                }
    
                if (psfl->pLuaData) {
                    psflInShimList->pLuaData = new LUADATA;

                    if (psflInShimList->pLuaData == NULL) {
                        MEM_ERR;
                        return;
                    }

                    psflInShimList->pLuaData->Copy(psfl->pLuaData);
                }
    
                //
                // Remove the item from the shim list and add it to the layer list
                //
                ListView_DeleteItem(hwndShimList, iIndex);

            } else {
                //
                // The shim may be present in the layer list, if yes we can remove it now
                //
                assert(psfl->pShimFix);
                lvfind.psz   = psfl->pShimFix->strName.pszString;
                iIndex = ListView_FindItem(hwndLayerList, -1, &lvfind);
    
                if (iIndex != -1) {
    
                    lvi.mask        = LVIF_PARAM;
                    lvi.iItem       = iIndex;
                    lvi.iSubItem    = 0;
        
                    if (!ListView_GetItem(hwndLayerList, &lvi)) {
                        assert(FALSE);
                        goto Next_Shim;
                    }

                    //
                    // This is the PSHIM_FIX_LIST that was present in the 
                    // layer list view
                    //
                    psflInShimList = (PSHIM_FIX_LIST)lvi.lParam;
        
                    psflInShimList->strCommandLine  = psfl->strCommandLine;
                    psflInShimList->strlInExclude   = psfl->strlInExclude;
        
                    //
                    // LUA data. This will be not required but just in case ...
                    //
                    if (psflInShimList->pLuaData) {
                        delete psflInShimList->pLuaData;
                        psflInShimList->pLuaData = NULL;
                    }
        
                    if (psfl->pLuaData) {
                        psflInShimList->pLuaData = new LUADATA;

                        if (psflInShimList->pLuaData) {
                            psflInShimList->pLuaData->Copy(psfl->pLuaData);
                        } else {
                            MEM_ERR;
                            return;
                        }
                    }
        
                    //
                    // Remove the item from the layer list view. We will add it again soon.
                    //
                    ListView_DeleteItem(hwndLayerList, iIndex);

                } else {

                    //
                    // We have to create new as this is a non-general shim 
                    //
                    psflInShimList = new SHIM_FIX_LIST;

                    if (psflInShimList == NULL) {
                        MEM_ERR;
                        return;
                    }

                    psflInShimList->pShimFix        = psfl->pShimFix;
                    psflInShimList->strCommandLine  = psfl->strCommandLine;
                    psflInShimList->strlInExclude   = psfl->strlInExclude;
    
                    if (psfl->pLuaData) {

                        psflInShimList->pLuaData = new LUADATA;

                        if (psflInShimList->pLuaData) {
                            MEM_ERR;
                            return;
                        }

                        psflInShimList->pLuaData->Copy(psfl->pLuaData);
                    }
                }
            }

            //
            // Add this psflInshimList to the layer list now
            //
            lvi.mask        = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
            lvi.pszText     = psflInShimList->pShimFix->strName;
            lvi.iSubItem    = 0;
            lvi.lParam      = (LPARAM)psflInShimList;
            lvi.iImage      = IMAGE_SHIM;
            lvi.iItem       = 0;

            iIndex = ListView_InsertItem(hwndLayerList, &lvi);

            if (g_bExpert) {

                ListView_SetItemText(hwndLayerList, 
                                     iIndex, 
                                     1, 
                                     psflInShimList->strCommandLine);

                ListView_SetItemText(hwndLayerList, 
                                     iIndex, 
                                     2, 
                                     psflInShimList->strlInExclude.IsEmpty() ? 
                                        GetString(IDS_NO) : GetString(IDS_YES));
            }
Next_Shim:
            psfl = psfl->pNext;
        }

        //
        // Now add the flags for the layer
        //
        while (pffl) {

            if (pffl->pFlagFix == NULL) {
                assert(FALSE);
                goto Next_Flag;
            }

            lvfind.psz  = pffl->pFlagFix->strName.pszString;
            iIndex      = ListView_FindItem(hwndShimList, -1, &lvfind);

            if (iIndex != -1) {
                //
                // This was a general flag, we have to  add this to the layer lit
                //
                lvi.mask        = LVIF_PARAM;
                lvi.iItem       = iIndex;
                lvi.iSubItem    = 0;
    
                if (!ListView_GetItem(hwndShimList, &lvi)) {
                    assert(FALSE);
                    goto Next_Flag;
                }

                pfflInShimList = (PFLAG_FIX_LIST)lvi.lParam;
                //
                // Add the command lines for this shim
                //
                pfflInShimList->strCommandLine = pffl->strCommandLine;
    
                //
                // Remove the item from the flag list and add it to the layer list
                //
                ListView_DeleteItem(hwndShimList, iIndex);

            } else {
                //
                // The flag may be present in the layer list, if yes we can remove it now
                //
                if (pffl->pFlagFix == NULL) {
                    assert(FALSE);
                    goto Next_Flag;
                }

                lvfind.psz      = pffl->pFlagFix->strName.pszString;
                iIndex          = ListView_FindItem(hwndLayerList, -1, &lvfind);
    
                if (iIndex != -1) {

                    lvi.mask        = LVIF_PARAM;
                    lvi.iItem       = iIndex;
                    lvi.iSubItem    = 0;
        
                    if (!ListView_GetItem(hwndLayerList, &lvi)) {
                        assert(FALSE);
                        goto Next_Flag;
                    }

                    //
                    // This is the PFLAG_FIX_LIST that was present in the 
                    // layer list view
                    //
                    pfflInShimList = (PFLAG_FIX_LIST)lvi.lParam;
        
                    pfflInShimList->strCommandLine = pffl->strCommandLine;
        
                    //
                    // Remove the item from the layer list. We will add it again soon.
                    //
                    ListView_DeleteItem(hwndLayerList, iIndex);

                } else {
                
                    //
                    // We have to create new
                    //
                    pfflInShimList = new FLAG_FIX_LIST;

                    if (pfflInShimList == NULL) {
                        MEM_ERR;
                        return;
                    }

                    pfflInShimList->pFlagFix = pffl->pFlagFix;
                    pfflInShimList->strCommandLine = pffl->strCommandLine;
                }
            }

            //
            // Add this pfflInflagList to the layer list now
            //
            lvi.mask        = LVIF_PARAM | LVIF_TEXT;
            lvi.pszText     = pfflInShimList->pFlagFix->strName;
            lvi.iSubItem    = 0;
            lvi.lParam      = (LPARAM)pfflInShimList;
            lvi.iImage      = IMAGE_SHIM;
            lvi.iItem       = 0;

            iIndex = ListView_InsertItem(hwndLayerList, &lvi);

            if (g_bExpert) {

                ListView_SetItemText(hwndLayerList, 
                                     iIndex, 
                                     1, 
                                     pfflInShimList->strCommandLine);

                ListView_SetItemText(hwndLayerList, 
                                     iIndex, 
                                     2, 
                                     GetString(IDS_NO));
            }
Next_Flag:    
            pffl = pffl->pNext;
        }

        SendDlgItemMessage(hDlg, IDC_SHIMLIST, WM_SETREDRAW, TRUE, 0); 
        SendDlgItemMessage(hDlg, IDC_LAYERLIST, WM_SETREDRAW, TRUE, 0);

        InvalidateRect(GetDlgItem(hDlg, IDC_SHIMLIST), NULL, TRUE);
        UpdateWindow(GetDlgItem(hDlg, IDC_SHIMLIST));

        InvalidateRect(GetDlgItem(hDlg, IDC_LAYERLIST), NULL, TRUE);
        UpdateWindow(GetDlgItem(hDlg, IDC_LAYERLIST));
    }

    SetFocus(hwndFocus);
}

void
OnDone(
    IN      HWND        hDlg,
    IN  OUT PLAYER_FIX  pLayerParam
    )
/*++
    OnDone
    
    Desc:   Removes all the existing shims and flags from pLayerParam and then 
            adds the selected shims and flags (those in the layerlist (RHS)) to pLayerParam
    
    Params:
        IN      HWND        hDlg:           The custom layer dialog proc
        IN  OUT PLAYER_FIX  pLayerParam:    The layer that has to be populated with the
            selected shims and flags
--*/
{
    
    TCHAR   szText[MAX_PATH_BUFFSIZE];
    LVITEM  lvi;
    HWND    hwndLayerList;

    ZeroMemory(&lvi, sizeof(lvi));

    *szText = 0;

    hwndLayerList = GetDlgItem(hDlg, IDC_LAYERLIST);

    if (g_pCustomLayer->m_uMode == LAYERMODE_EDIT) {
        GetDlgItemText(hDlg, IDC_COMBO, szText, ARRAYSIZE(szText));
    } else {
        GetDlgItemText(hDlg, IDC_NAME, szText, ARRAYSIZE(szText));
    }

    if (CSTRING::Trim(szText) == 0) {

        MessageBox(hDlg,
                   GetString(IDS_INVALID_LAYER_NAME),
                   g_szAppName,
                   MB_ICONWARNING);

        return;
    }

    CSTRING strLayerName = szText;
    
    //
    // Check if the new name already exists, if yes give error.
    //
    if (g_pCustomLayer->m_uMode == LAYERMODE_ADD 
        && FindFix((LPCTSTR)strLayerName, FIX_LAYER, g_pCustomLayer->m_pCurrentSelectedDB)) { 

        //
        // Since we have a read only combo box when we are editing a fix, the user
        // cannot change the name, so we only check for whether we have an existing layer of the
        // same name when we are creating a new layer
        //	
        MessageBox(hDlg, GetString(IDS_LAYEREXISTS), g_szAppName, MB_ICONWARNING);
        return;
    }

    // 
    // Remove all the shims.
    //
    DeleteShimFixList(pLayerParam->pShimFixList);
    pLayerParam->pShimFixList = NULL;

    // 
    // Remove all the Flags.
    //       
    DeleteFlagFixList (pLayerParam->pFlagFixList);
    pLayerParam->pFlagFixList = NULL;

    pLayerParam->uShimCount = 0;

    int nCount;
    int nTotal;

    pLayerParam->strName = szText;

    nTotal = ListView_GetItemCount(hwndLayerList);

    //
    // Enumerate all the shims listed and add to the layer.
    //
    for (nCount=0; nCount < nTotal; ++nCount) {

        lvi.mask        = LVIF_PARAM;
        lvi.iItem       = nCount;
        lvi.iSubItem    = 0;

        if (!ListView_GetItem(hwndLayerList, &lvi)) {
            assert(FALSE);
            continue;
        }

        TYPE type = ConvertLparam2Type(lvi.lParam);

        if (type == FIX_LIST_SHIM) {

            //
            // Add this shim to the layer
            //
            PSHIM_FIX_LIST   pShimFixList = (PSHIM_FIX_LIST)lvi.lParam;

            assert(pShimFixList);
    
            if (pLayerParam->pShimFixList == NULL) {
                pLayerParam->pShimFixList = pShimFixList;
                pLayerParam->pShimFixList->pNext = NULL;
            } else {
                pShimFixList->pNext              = pLayerParam->pShimFixList->pNext;
                pLayerParam->pShimFixList->pNext = pShimFixList;
            }

        } else if (FIX_LIST_FLAG) {

            //
            // Add this flag to the layer
            //
            PFLAG_FIX_LIST  pFlagFixList = (PFLAG_FIX_LIST) lvi.lParam;

            assert(pFlagFixList);

            if (pLayerParam->pFlagFixList == NULL) {
                pLayerParam->pFlagFixList        = pFlagFixList;
                pLayerParam->pFlagFixList->pNext = NULL;
            } else {
                pFlagFixList->pNext              = pLayerParam->pFlagFixList->pNext;
                pLayerParam->pFlagFixList->pNext = pFlagFixList; 
            }
        }

        //
        // Count of both shims and flags, we do not use this variable now
        // BUBUG: remove this variable from the structure
        //
        pLayerParam->uShimCount++;
    }

    EndDialog(hDlg, TRUE);
}

void
RemoveSingleItem(
    IN  HWND    hdlg,
    IN  INT     iIndex,
    IN  BOOL    bOnlySelected
    )
/*++
    RemoveSingleItem
    
    Desc:   Moves a single item from the layer list to the shim list
    
    Params:
        IN  HWND    hdlg:           The custom layer dialog
        IN  INT     iIndex:         The index of the item that has to be removed
        IN  BOOL    bOnlySelected:  We should remove the item only if it selected
--*/
{
    LVITEM  lvi;
    HWND    hwndLayerList   = GetDlgItem(hdlg, IDC_LAYERLIST);
    HWND    hwndShimList    = GetDlgItem(hdlg, IDC_SHIMLIST);

    PSHIM_FIX_LIST  psflInLayerList = NULL;
    PFLAG_FIX_LIST  pfflInLayerList = NULL;

    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask        = LVIF_PARAM | LVIF_STATE ;
    lvi.stateMask   = LVIS_SELECTED;
    lvi.iItem       = iIndex;
    lvi.iSubItem    = 0;

    if (!ListView_GetItem(hwndLayerList, &lvi)) {
        assert(FALSE);
        return;
    }

    if (!bOnlySelected ||(lvi.state & LVIS_SELECTED)) {

        TYPE type = ConvertLparam2Type(lvi.lParam);

        if (type == FIX_LIST_SHIM) {

            psflInLayerList = (PSHIM_FIX_LIST)lvi.lParam;
            assert(psflInLayerList->pShimFix);
            
            lvi.mask        = LVIF_PARAM | LVIF_TEXT;
            lvi.pszText     = psflInLayerList->pShimFix->strName;
            lvi.iImage      = IMAGE_SHIM;
            lvi.iItem       = 0;
            lvi.iSubItem    = 0;
            lvi.lParam      = (LPARAM)psflInLayerList;

        } else if (type ==  FIX_LIST_FLAG) {

            pfflInLayerList = (PFLAG_FIX_LIST)lvi.lParam;
            assert(pfflInLayerList->pFlagFix);

            lvi.mask        = LVIF_PARAM | LVIF_STATE | LVIF_TEXT;
            lvi.pszText     = pfflInLayerList->pFlagFix->strName;
            lvi.iImage      = IMAGE_SHIM;
            lvi.iItem       = 0;
            lvi.iSubItem    = 0;
            lvi.lParam      = (LPARAM)pfflInLayerList;
        }

        ListView_InsertItem(hwndShimList, &lvi);
        ListView_DeleteItem(hwndLayerList, iIndex);
    }
}

BOOL
HandleNotifyLayerList(
    IN  HWND    hDlg, 
    IN  LPARAM  lParam
    )
/*++

    HandleNotifyLayerList
    
    Desc:   Handles the notification messages for the layer list. This is the RHS list view
            
    Params:
        IN  HWND    hDlg:   The custom layer dialog proc
        IN  LPARAM  lParam: The lParam with WM_NOTIFY    

--*/

{
    NMHDR * pHdr = (NMHDR*)lParam;
    
    switch (pHdr->code) {
    case NM_DBLCLK:

        OnRemove(hDlg);
        SetOkParamsStatus(hDlg);
        break;

    case NM_CLICK:
        
        if (ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_LAYERLIST)) == 0) {
            ENABLEWINDOW(GetDlgItem(hDlg, IDC_PARAMS), FALSE);
        } else {
            ENABLEWINDOW(GetDlgItem(hDlg, IDC_PARAMS), TRUE);
        }

        break;

    case LVN_ITEMCHANGED:
        {
            LPNMLISTVIEW lpnmlv;
        
            lpnmlv = (LPNMLISTVIEW)lParam;

            if (lpnmlv && (lpnmlv->uChanged & LVIF_STATE)) {
            
                if (lpnmlv->uNewState & LVIS_SELECTED) {
                    ENABLEWINDOW(GetDlgItem(hDlg, IDC_PARAMS), TRUE);
                }
            }

            break;
        }

    default: return FALSE;
    }

    return TRUE;
}

BOOL
HandleNotifyShimList(
    IN  HWND    hDlg, 
    IN  LPARAM  lParam
    )
/*++

    HandleNotifyShimList
    
    Desc:   Handles the notification messages for the ShimList. This is the LHS list view
            
    Params:
        IN  HWND    hDlg:   The custom layer dialog proc
        IN  LPARAM  lParam: The lParam with WM_NOTIFY    
--*/
{
    NMHDR* pHdr = (NMHDR*)lParam;
    
    switch (pHdr->code) {
    case NM_DBLCLK:

        OnAdd(hDlg);
        SetOkParamsStatus(hDlg);
        break;

    default: return FALSE;

    }

    return TRUE;
}

void
SetOkParamsStatus(
    IN  HWND hdlg
    )
/*++

    SetOkParamsStatus
    
    Desc:   Sets the status of the ok button and the params button
    
    Params:
        IN  HWND    hDlg:   The custom layer dialog proc
--*/
{
    INT iTotalCount = ListView_GetItemCount(GetDlgItem(hdlg, IDC_LAYERLIST));

    if (g_pCustomLayer->m_uMode == LAYERMODE_ADD) {
        SendMessage(hdlg, WM_COMMAND, MAKELONG(IDC_NAME, EN_UPDATE), 0);
    } else {
        ENABLEWINDOW(GetDlgItem(hdlg, IDOK), iTotalCount > 0);
    }

    //
    // Enable the params button only if we have some selection in the layer list view(RHS)
    //
    ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS),
                 ListView_GetNextItem(GetDlgItem(hdlg, IDC_LAYERLIST), -1, LVNI_SELECTED) != -1);
}

void
RemoveAll(
    IN  HWND hDlg
    )
/*++

    RemoveAll

	Desc:	Removes all the shims/flags from the layer list and adds them
            to the shim list

	Params:
        IN  HWND hDlg:  The custom layer dialog    

	Return:
--*/
{
    SendDlgItemMessage(hDlg, IDC_SHIMLIST, WM_SETREDRAW, FALSE, 0);
    SendDlgItemMessage(hDlg, IDC_LAYERLIST, WM_SETREDRAW, FALSE, 0);

    int nCount;

    nCount = ListView_GetItemCount(GetDlgItem(hDlg, IDC_LAYERLIST)) - 1;

    for (;nCount >= 0; --nCount) {
        
        //
        // Remove all either selected or not
        //
        RemoveSingleItem(hDlg, nCount, FALSE); 
    }
    

    SendDlgItemMessage(hDlg, IDC_SHIMLIST, WM_SETREDRAW, TRUE, 0);
    SendDlgItemMessage(hDlg, IDC_LAYERLIST, WM_SETREDRAW, TRUE, 0);

    InvalidateRect(GetDlgItem(hDlg, IDC_SHIMLIST), NULL, TRUE);
    UpdateWindow(GetDlgItem(hDlg, IDC_SHIMLIST));
    InvalidateRect(GetDlgItem(hDlg, IDC_LAYERLIST), NULL, TRUE);
    UpdateWindow(GetDlgItem(hDlg, IDC_LAYERLIST));

    SetOkParamsStatus(hDlg);
}

void
ResizeControls(
    IN  HWND hdlg
    )
/*++

    ResizeControls

	Desc:	Make the sizes of both the list view  controls equal as we will now
            not show the command lines and the params of the shims in the layer 
            list view(RHS) in non-expert mode. We will also need to move the buttons

	Params:
        IN  HWND hdlg: The custom layer dialog box

	Return:
        void
--*/
{
    HWND    hwndTemp;
    RECT    rcTemp;
    INT     iWidthShimList;
    INT     iWidthLayerList;
    INT     iWidthDiff;

    HDWP hdwp = BeginDeferWindowPos(3);

    //
    // Note:    DeferWindowPos: All windows in a multiple-window position structure must 
    //          have the same parent. 
    //
    hwndTemp = GetDlgItem(hdlg, IDC_SHIMLIST);

    GetWindowRect(hwndTemp, &rcTemp);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&rcTemp, 2);

    iWidthShimList = rcTemp.right - rcTemp.left;

    hwndTemp = GetDlgItem(hdlg, IDC_LAYERLIST);

    GetWindowRect(hwndTemp, &rcTemp);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&rcTemp, 2);

    iWidthLayerList = rcTemp.right - rcTemp.left;

    iWidthDiff = iWidthLayerList - iWidthShimList;
    
    //
    // Make the width of the layer list equal to the width of the shim list
    //
    DeferWindowPos(hdwp,
                   hwndTemp,
                   NULL,
                   0,
                   0,
                   iWidthShimList,
                   rcTemp.bottom - rcTemp.top,
                   SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // Move the OK button to the left
    //
    hwndTemp = GetDlgItem(hdlg, IDOK);

    GetWindowRect(hwndTemp, &rcTemp);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&rcTemp, 2);

    DeferWindowPos(hdwp,
                   hwndTemp,
                   NULL,
                   rcTemp.left - iWidthDiff,
                   rcTemp.top,
                   0,
                   0,
                   SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // Move the Cancel button to the left
    //
    hwndTemp = GetDlgItem(hdlg, IDC_CANCEL);

    GetWindowRect(hwndTemp, &rcTemp);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&rcTemp, 2);

    DeferWindowPos(hdwp,
                   hwndTemp,
                   NULL,
                   rcTemp.left - iWidthDiff,
                   rcTemp.top,
                   0,
                   0,
                   SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

    EndDeferWindowPos(hdwp);

    //
    // Now we must reduce the size of the main dialog as well
    //
    GetWindowRect(hdlg, &rcTemp);

    MoveWindow(hdlg,
               rcTemp.left,
               rcTemp.top,
               rcTemp.right - rcTemp.left - iWidthDiff,
               rcTemp.bottom - rcTemp.top,
               TRUE);

    //
    // Make the last column fit in the list view
    //
    hwndTemp = GetDlgItem(hdlg, IDC_LAYERLIST);
    ListView_SetColumnWidth(hwndTemp, 0, LVSCW_AUTOSIZE_USEHEADER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\lua.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    Lua.h

Abstract:

    Header for Lua.cpp
        
Author:

    kinshu created  October 19,2001

--*/


#ifndef _LUA_H
#define _LUA_H

#include "compatadmin.h"


BOOL
LuaBeginWizard(
    HWND        hParent,
    PDBENTRY    pEntry,     // Entry for which we are setting the LUA params
    PDATABASE   pDatabase   // Database where the entry resides
    ); 

PLUADATA
LuaProcessLUAData(
    const PDB     pdb,
    const TAGID   tiFix
    );

BOOL
LuaGenerateXML(
    LUADATA*        pLuaData,
    CSTRINGLIST&    strlXML
    );

#endif // _LUA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\dbtree.cpp ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    CompatAdmin.cpp

Abstract:

    This module handles the code for handling the db tree used in the application
        
Author:

    kinshu created  October 15, 2001

--*/

#include "precomp.h"

//////////////////////// Function Declarations ////////////////////////////////

BOOL
DeleteFromContentsList(
    HWND    hwndList,
    LPARAM  lParam
    );

///////////////////////////////////////////////////////////////////////////////

/////////////////////// Extern variables //////////////////////////////////////

extern BOOL         g_bIsContentListVisible;
extern HWND         g_hwndContentsList;

///////////////////////////////////////////////////////////////////////////////

void 
DatabaseTree::Init(
    IN  HWND    hdlg,
    IN  INT     iHeightToolbar,
    IN  INT     iHeightStatusbar,
    IN  RECT*   prcMainClient
    )    
/*++
    
    DatabaseTree::Init
        
    Desc:   This sets up the system database tree item.
    
    Params:
        IN  HWND    hdlg:               The parent of the tree view. This will be the
            main app window
            
        IN  INT     iHeightToolbar:     Height of the tool bar
        IN  INT     iHeightStatusbar:   Height of the status bar 
        IN  RECT*   prcMainClient:      The client rectangle for hdlg
--*/
{
    RECT    r;
    GetWindowRect(hdlg, &r);
    m_hLibraryTree = GetDlgItem(hdlg, IDC_LIBRARY);

    //
    // Resize it
    //
    GetWindowRect(m_hLibraryTree, &r);
    MapWindowPoints(NULL, hdlg, (LPPOINT)&r, 2);

    MoveWindow(m_hLibraryTree,
               r.left,
               r.top,
               r.right - r.left,
               prcMainClient->bottom - prcMainClient->top - iHeightStatusbar - iHeightToolbar - 20,
               TRUE);

    InvalidateRect(m_hLibraryTree, NULL, TRUE);
    UpdateWindow(m_hLibraryTree);

    //
    // Make the System entry in the Tree
    //
    TVINSERTSTRUCT  is;

    is.hParent             = TVI_ROOT;
    is.hInsertAfter        = TVI_SORT;
    is.item.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    is.item.stateMask      = TVIS_EXPANDED;
    is.item.lParam         = (LPARAM)&GlobalDataBase;
    is.item.pszText        = GetString(IDS_SYSDB);
    is.item.iImage         = IMAGE_GLOBAL;
    is.item.iSelectedImage = IMAGE_GLOBAL;

    GlobalDataBase.hItemDB = m_hItemGlobal = TreeView_InsertItem(m_hLibraryTree, &is);

    //
    // Now add the applications item for the global database
    //
    is.hParent             = m_hItemGlobal;
    is.item.lParam         = TYPE_GUI_APPS;
    is.item.pszText        = GetString(IDS_APPS);
    is.item.iImage         = IMAGE_APP;
    is.item.iSelectedImage = IMAGE_APP;

    GlobalDataBase.hItemAllApps = TreeView_InsertItem(m_hLibraryTree, &is);

    //
    // Dummy item. This is required to give a + button to the tree item.
    // BUGBUG:     There should be a proper way to do this.
    //
    is.hParent = GlobalDataBase.hItemAllApps;
    is.item.pszText = TEXT("            000");


    TreeView_InsertItem(m_hLibraryTree, &is);

    m_hItemAllInstalled = NULL;
    m_hItemAllWorking   = NULL;
    m_hPerUserHead      = NULL;

    //
    // Set the image list for the tree
    //
    TreeView_SetImageList(m_hLibraryTree, g_hImageList, TVSIL_NORMAL);
}

BOOL
DatabaseTree::PopulateLibraryTreeGlobal(
    void
    )
/*++
    DatabaseTree::PopulateLibraryTreeGlobal
    
    Desc:   This function loads the shims and layers for the system database tree item. It does
            not load the applications. The applications are loaded when the user first selects
            or expand the "applications" item for the system database tree item
            
    Warn:   This function should be called only once.
        
--*/
{
    BOOL bReturn = PopulateLibraryTree(m_hItemGlobal, &GlobalDataBase, TRUE);

    TreeView_Expand(m_hLibraryTree, m_hItemGlobal, TVE_EXPAND);

    return bReturn;
}

BOOL
DatabaseTree::AddWorking(
    IN  PDATABASE pDataBase
    )
/*++
    
    DatabaseTree::AddWorking
    
    Desc:   Adds a new working database into the DB tree under the "Working Databases" entry
    
    Params:
        IN  PDATABASE pDataBase: The database that we want to add into the list
    
    Return:
        TRUE:   If successfully added
        FALSE:  Otherwise
--*/
{

    TVINSERTSTRUCT  is;

    if (m_hPerUserHead) {

        is.hInsertAfter = m_hPerUserHead;
    } else if (m_hItemAllInstalled) {

        is.hInsertAfter = m_hItemAllInstalled;
    } else {

        is.hInsertAfter = m_hItemGlobal;
    }

    is.item.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
    is.item.stateMask      = TVIS_EXPANDED;

    if (m_hItemAllWorking == NULL) {

        //
        // Add the Parent tree item for all the working DBs tree items
        //
        is.hParent             = TVI_ROOT;
        is.item.lParam         = TYPE_GUI_DATABASE_WORKING_ALL;
        is.item.pszText        = GetString(IDS_WORKDB);
        is.item.iImage         = IMAGE_WORKING;
        is.item.iSelectedImage = IMAGE_WORKING; 

        m_hItemAllWorking = TreeView_InsertItem(m_hLibraryTree, &is);
    }

    //
    // Now Add the Working database
    //
    is.item.iImage         = IMAGE_DATABASE;
    is.item.iSelectedImage = IMAGE_DATABASE;
    is.hParent             = m_hItemAllWorking;
    is.item.lParam         = (LPARAM)pDataBase;
    is.item.pszText        = pDataBase->strName;

    HTREEITEM hItemDB = TreeView_InsertItem(m_hLibraryTree, &is);

    //
    // The other HTREEITEM for the database are set in the PopulateLibraryTree function
    //
    if (!PopulateLibraryTree(hItemDB, pDataBase)) {
        return FALSE;
    }

    pDataBase->hItemDB = hItemDB;

    //
    // Now select the first application or the DB item if there is none
    //
    HTREEITEM hItemFirstApp = GetFirstAppItem(hItemDB);

    if (hItemFirstApp) {  
        TreeView_SelectItem(m_hLibraryTree, hItemFirstApp);
    } else {
        TreeView_SelectItem(m_hLibraryTree, hItemDB);
    }

    LPARAM lParam;

    //
    // Set the app to be selected
    //
    if (GetLParam(hItemFirstApp, &lParam)) {
        g_pEntrySelApp = (PDBENTRY)lParam; 
    } else {
        g_pEntrySelApp = NULL;
    }

    return TRUE;
}

BOOL
DatabaseTree::RemoveDataBase(
    IN  HTREEITEM hItemDB,
    IN  TYPE      typeDB,
    IN  BOOL      bSelectSibling
    )
/*++
    
    DatabaseTree::RemoveDataBase
    
    Desc:   Removes the item for the working or the  installed database.
            Sets focus to sibling or parent if no sibling exists.   
            
    Params:
        IN  HTREEITEM hItemDB:                  The tree item of the db to be removed
        IN  TYPE      typeDB:                   The type of database
        IN  BOOL      bSelectSibling (TRUE):    When we call this 
            function from ID_CLOSE_ALL, we do not want unnecessary selections
--*/
{
    if (hItemDB == NULL) {
        return FALSE;
    }

    HTREEITEM hItemSibling    = TreeView_GetNextSibling(m_hLibraryTree, hItemDB);

    if (hItemSibling == NULL) {
        hItemSibling = TreeView_GetPrevSibling(m_hLibraryTree, hItemDB);
    }

    if (hItemSibling == NULL) {
        //
        // This was the last database, the database item gets deleted with the parent
        //
        HTREEITEM hItemParent = TreeView_GetParent(m_hLibraryTree, hItemDB);

        assert(hItemParent);

        TreeView_DeleteItem(m_hLibraryTree, hItemParent);

        if (typeDB == DATABASE_TYPE_WORKING) {

            m_hItemAllWorking    = NULL;
            g_uNextDataBaseIndex = 0;   

        } else {
            m_hItemAllInstalled = NULL;
        }
        
        return TRUE;
    }

    TreeView_DeleteItem(m_hLibraryTree, hItemDB);
    return TRUE;
}

void
DatabaseTree::RemoveAllWorking(
    void
    )
/*++

    DatabaseTree::RemoveAllWorking    
    
    Desc:   Delete all the working databases tree items
    
--*/
{
    TreeView_DeleteItem(m_hLibraryTree, m_hItemAllWorking);
}

BOOL
DatabaseTree::SetLParam(
    IN  HTREEITEM   hItem, 
    IN  LPARAM      lParam
    )
/*++
    DatabaseTree::SetLParam
    
    Desc:   Sets the lParam of a tree item
    
    Params:
        IN  HTREEITEM hItem:    The hItem for the db tree item for which we want to 
            set the lParam
            
        IN  LPARAM lParam:      The lParam to set
        
    Return:
        TRUE:   Successful
        FALSE:  Error
--*/
{
    TVITEM  Item;

    Item.mask   = TVIF_PARAM;
    Item.hItem  = hItem;
    Item.lParam = lParam;

    return TreeView_SetItem(m_hLibraryTree, &Item);
}

BOOL
DatabaseTree::GetLParam(
    IN  HTREEITEM   hItem, 
    OUT LPARAM*     plParam
    )
/*++

    DatabaseTree::GetLParam
    
    Desc:   Gets the lParam of a tree item
    
    Params:
        IN  HTREEITEM   hItem:      The hItem for which we want to get the lParam
        OUT LPARAM*     plParam:    This will store the lParams for the tree item
    
    Return:
        TRUE:   Successful
        FALSE:  Error      
--*/
{   
    TVITEM  Item;
    
    if (plParam == NULL) {
        assert(FALSE);
        return FALSE;
    }

    *plParam = 0;

    Item.mask   = TVIF_PARAM;
    Item.hItem  = hItem;

    if (TreeView_GetItem(m_hLibraryTree, &Item)) {
        *plParam = Item.lParam;
        return TRUE;
    }

    return FALSE;
}

HTREEITEM
DatabaseTree::FindChild(
    IN  HTREEITEM   hItemParent,
    IN  LPARAM      lParam
    )
/*++
    
    DatabaseTree::FindChild
    
    Desc:   Given a parent item and a lParam, finds the first child of the parent, with 
            that value of lParam. This function only searches in the next level and not all
            the generations of the parent
            
    Params:
        IN  HTREEITEM hItemParent:  The tree item whose child we want to search 
        IN  LPARAM lParam:          The lParam of the child item should match this
            
    Return: The handle to the child or NULL if it does not exist        
    
--*/
{
    HWND        hwndTree = m_hLibraryTree;
    HTREEITEM   hItem = TreeView_GetChild(hwndTree, hItemParent);

    while (hItem) {

        LPARAM lParamOfItem;

        if (!GetLParam (hItem, &lParamOfItem)) {
            return NULL;
        }

        if (lParamOfItem == lParam) {
            return hItem;
        } else {
            hItem = TreeView_GetNextSibling(hwndTree, hItem);
        }
    }           

    return NULL;
}

HTREEITEM
DatabaseTree::GetAllAppsItem(
    IN  HTREEITEM hItemDataBase
    )
/*++

    DatabaseTree::GetAllAppsItem    
    
    Desc:   Given the handle to the database item, finds the handle for the "Applications"
            item. 
            
    Params:
        IN  HTREEITEM hItemDataBase:    The handle to the database tree item
            
    Return: The proper value of the handle or NULL if it does not exist.
    
--*/
{
    HTREEITEM   hItem = TreeView_GetChild(m_hLibraryTree, hItemDataBase); 
    TVITEM      Item;

    while (hItem) {

        Item.mask = TVIF_PARAM;
        Item.hItem = hItem;

        if (!TreeView_GetItem(m_hLibraryTree, &Item)) {
            assert(FALSE);
            hItem = NULL;
            break;
        }

        TYPE type = (TYPE)Item.lParam;

        if (type == TYPE_GUI_APPS) {
            break;
        } else {
            hItem = TreeView_GetNextSibling(m_hLibraryTree, hItem); 
        }
    }

    return hItem;
}

HTREEITEM
DatabaseTree::GetFirstAppItem(
    IN  HTREEITEM hItemDataBase
    )
/*++

    DatabaseTree::GetFirstAppItem
    
    Desc:   The handle to the first application's item; given the database tree item.
    
    Params:
        IN  HTREEITEM hItemDataBase:    The handle to the database tree item
    
    Return: The proper value or NULL if there is no application for this database

--*/
{
    HTREEITEM hItem = GetAllAppsItem(hItemDataBase);

    if (hItem == NULL) {
        return NULL;
    }

    return TreeView_GetChild(m_hLibraryTree, hItem);
}

void
DatabaseTree::AddNewLayer(
    IN  PDATABASE   pDataBase,
    IN  PLAYER_FIX  pLayer,
    IN  BOOL        bShow //(FALSE)
    )
/*++
    
    DatabaseTree::AddNewLayer
        
    Desc:   Adds a new layer tree item in the tree for the database: pDatabase
            The layer is specified by pLayer.
            This routine might create the root of all layers: "Compatibility Modes", if 
            it does not exist.
            
    Params:
        IN  PDATABASE   pDataBase:      The database for which we want to add the new layer
        IN  PLAYER_FIX  pLayer:         The layer
        IN  BOOL        bShow (FALSE):  Should we set the focus to the layer after it is created
        
    Return:
        void
--*/        
{
    TVINSERTSTRUCT  is;

    if (!pDataBase || !(pDataBase->hItemDB)) {
        assert(FALSE);
        return;
    }

    if (pDataBase->hItemAllLayers == NULL) {

        //
        // Create a new root of all layers: "Compatibility Modes".
        //
        is.hParent             = pDataBase->hItemDB;
        is.hInsertAfter        = TVI_SORT;
        is.item.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
        is.item.stateMask      = TVIS_EXPANDED;
        is.item.lParam         = TYPE_GUI_LAYERS;
        is.item.pszText        = GetString(IDS_COMPATMODES);
        is.item.iImage         = IMAGE_LAYERS;
        is.item.iSelectedImage = IMAGE_LAYERS;

        pDataBase->hItemAllLayers   = TreeView_InsertItem(m_hLibraryTree, &is);
        pDataBase->uLayerCount      = 0;
    }

    pDataBase->uLayerCount++;

    InsertLayerinTree(pDataBase->hItemAllLayers, pLayer, m_hLibraryTree, bShow);
}

void
DatabaseTree::RefreshAllLayers(
    IN  PDATABASE  pDataBase
    )
/*++
    
    DatabaseTree::RefreshAllLayers    

    Desc:   Redraws all the layer tree item for the database pDataBase. 
            This may be required when we have edited some layer
            
    Params:
        IN  PDATABASE  pDataBase: The database whose layers we want to refresh
    
    Return:
        void
--*/
{
    if (pDataBase == NULL) {
        assert(FALSE);
        return;
    }

    PLAYER_FIX plfTemp = pDataBase->pLayerFixes;

    SendMessage(m_hLibraryTree, WM_SETREDRAW, FALSE , 0);

    while (plfTemp) {
        RefreshLayer(pDataBase, plfTemp);
        plfTemp = plfTemp->pNext;
    }

    SendMessage(m_hLibraryTree, WM_SETREDRAW, TRUE , 0);
}

HTREEITEM
DatabaseTree::RefreshLayer(
    IN  PDATABASE   pDataBase,
    IN  PLAYER_FIX  pLayer
    )
/*++

    DatabaseTree::RefreshLayer
        
    Desc:   Redraws the tree item for the layer: pLayer in database pDataBase.
            First removes the tree item and adds it again
    
    Params:
        IN  PDATABASE pDataBase:    Database in which the layer exists
        IN  PLAYER_FIX pLayer:      The  layer to be refreshed
        
    Return: The HTREEITEM for pLayer if it was found or NULL
    
--*/
{   
    if (!pDataBase || !(pDataBase->hItemAllLayers)) {
        assert(FALSE);
        return NULL;
    }

    HTREEITEM hItem = TreeView_GetChild(m_hLibraryTree, pDataBase->hItemAllLayers);

    while (hItem) {

        PLAYER_FIX  pLayerExist;
        LPARAM      lParam;

        if (GetLParam(hItem, &lParam)) {

            pLayerExist = (PLAYER_FIX)lParam;

            if (pLayerExist == pLayer) {

                TreeView_DeleteItem(m_hLibraryTree, hItem);

                InsertLayerinTree(pDataBase->hItemAllLayers, 
                                  pLayer, 
                                  m_hLibraryTree, 
                                  TRUE);
                break;

            } else {
                hItem = TreeView_GetNextSibling(m_hLibraryTree, hItem);
            }

        } else {
            //
            // Error:
            //
            return NULL;
        }
    }

    return hItem;
}


BOOL
DatabaseTree::AddNewExe(
    IN  PDATABASE pDataBase,
    IN  PDBENTRY  pEntry,
    IN  PDBENTRY  pApp,
    IN  BOOL      bRepaint // (TRUE)
    )
/*++

    DatabaseTree::AddNewExe
    
    Desc:   Adds a new exe entry in the apps Tree. First finds the database tree item 
            under the list of working database , then if pApp is NULL, checks if the Apps 
            htree item is there or not, If not creates a new item
            If the pApp is not NULL, then we select that app. And add the exe in the EXE tree 
            and set the focus to it.
            
    Params:
        IN  PDATABASE pDataBase:        The database in which we wan to add the new entry
        IN  PDBENTRY  pEntry:           The entry to add
        IN  PDBENTRY  pApp:             The app of the entry
        IN  BOOL      bRepaint (TRUE):  <TODO>
        
    Return:
        TRUE:   Added successfully
        FALSE:  There was some error
--*/
{

    if (!pEntry || !pDataBase) {
        assert(FALSE);
        return FALSE;
    }

    HTREEITEM       hItemDB         = pDataBase->hItemDB, hItem;
    HTREEITEM       hItemAllApps    = pDataBase->hItemAllApps;
    TVINSERTSTRUCT  is;

    SendMessage(g_hwndEntryTree, WM_SETREDRAW, TRUE, 0);

    assert(m_hItemAllWorking);
    assert(hItemDB);

    if (hItemAllApps == NULL) {

        is.hParent             = hItemDB;
        is.hInsertAfter        = TVI_SORT;
        is.item.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        is.item.stateMask      = TVIS_EXPANDED;
        is.item.lParam         = TYPE_GUI_APPS;
        is.item.pszText        = GetString(IDS_APPS);
        is.item.iImage         = IMAGE_APP;
        is.item.iSelectedImage = IMAGE_APP;

        HTREEITEM hItemApp = TreeView_InsertItem(m_hLibraryTree, &is);

        g_pPresentDataBase->hItemAllApps = hItemApp;
    }

    if (pApp == NULL) {

        is.hParent             = g_pPresentDataBase->hItemAllApps;
        is.hInsertAfter        = TVI_SORT;
        is.item.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
        is.item.stateMask      = TVIS_EXPANDED;
        is.item.lParam         = (LPARAM)pEntry;
        is.item.pszText        = pEntry->strAppName;
        is.item.iImage         = IMAGE_SINGLEAPP;
        is.item.iSelectedImage = IMAGE_SINGLEAPP;

        hItem       = TreeView_InsertItem(m_hLibraryTree, &is);
        g_pSelEntry = g_pEntrySelApp = pEntry;

        TreeView_SelectItem(m_hLibraryTree, hItem);
        return TRUE;
    }

    //
    // Now loop through all the apps and then find the app for this exe
    //
    hItem =  TreeView_GetChild(m_hLibraryTree, hItemAllApps);

    while (hItem) {

        LPARAM lParam;

        if (!GetLParam(hItem, &lParam)) {

            assert(FALSE);
            break;
        }

        if ((PDBENTRY)lParam == pApp) {

            TVITEM Item;

            Item.mask   = TVIF_PARAM;
            Item.lParam = (LPARAM)pEntry;
            Item.hItem  = hItem;

            TreeView_SetItem(m_hLibraryTree, &Item);

            //
            // This entry was added in the beginning of the list. TODO This can be removed
            //
            g_pEntrySelApp  = pEntry;                                                     

            if (TreeView_GetSelection(m_hLibraryTree) != hItem && bRepaint) {

                //
                // Focus is on some other App. Select this app
                //
                TreeView_SelectItem(m_hLibraryTree, hItem);

                //
                // The above will refresh the EXE Tree and call a UpdateEntryTreeView(). That will
                // add the pEntry to the tree and set a valid pEntry->hItemExe, which we can now select
                //
                TreeView_SelectItem(g_hwndEntryTree, pEntry->hItemExe);

            } else {

                //
                // Add the exe in the EXE tree and set the focus to it. The focus is on this app. 
                //
                AddSingleEntry(g_hwndEntryTree, pEntry);

                if (bRepaint) {
                    TreeView_SelectItem(g_hwndEntryTree, pEntry->hItemExe);
                }
            }

            //
            // This entry was added in the beginning of the list
            //
            g_pSelEntry     = pEntry;
            return TRUE;
        }

        hItem =  TreeView_GetNextSibling(m_hLibraryTree, hItem);
    }

    if (bRepaint) {
        SendMessage(g_hwndEntryTree, WM_SETREDRAW, TRUE, 0);
    }

    return FALSE;
}

BOOL
DatabaseTree::AddInstalled(
    IN  PDATABASE pDataBase
    )
/*++
    
    DatabaseTree::AddInstalled    
    
    Desc:   Adds a New installed database under the "installed databases" tree item in the 
            database tree.
            
            If the root of all installed databases: "Installed databases" is  not present
            this routine first of all adds that.
            
    Params:
        IN  PDATABASE pDataBase: The installed database to be shown in the db tree
        
    Return:
        TRUE:   Added successfully
        FALSE:  There was some error
--*/
{
    TVINSERTSTRUCT  is;

    is.item.mask        = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
    is.item.stateMask   = TVIS_EXPANDED;

    if (m_hItemAllInstalled == NULL) {

        //
        // Add the Parent tree item for all the Installed DBs tree items
        //
        is.hParent             = TVI_ROOT;
        is.hInsertAfter        = m_hItemGlobal;
        is.item.lParam         = TYPE_GUI_DATABASE_INSTALLED_ALL;
        is.item.pszText        = GetString(IDS_INSTALLEDDB);
        is.item.iImage         = IMAGE_INSTALLED;
        is.item.iSelectedImage = IMAGE_INSTALLED;

        m_hItemAllInstalled = TreeView_InsertItem(m_hLibraryTree, &is);
    }

    is.hInsertAfter        = TVI_SORT;

    //
    // Now Add the installed dataBase
    //
    is.hInsertAfter         = TVI_SORT;
    is.hParent              = m_hItemAllInstalled; 
    is.item.lParam          = (LPARAM)pDataBase;
    is.item.pszText         = pDataBase->strName;
    is.item.iImage          = IMAGE_DATABASE;
    is.item.iSelectedImage  = IMAGE_DATABASE;

    HTREEITEM hItemDB = TreeView_InsertItem(m_hLibraryTree, &is);

    if (!PopulateLibraryTree(hItemDB, pDataBase)) {
        return FALSE;
    }

    pDataBase->hItemDB = hItemDB;

    return TRUE;
}

void
DatabaseTree::DeleteAppLayer(
    IN  PDATABASE   pDataBase,
    IN  BOOL        bApp,
    IN  HTREEITEM   hItemDelete,
    IN  BOOL        bRepaint // (TRUE)
    )
/*++
    DatabaseTree::DeleteAppLayer
    
    Desc:   This function is to be used for deleting apps and layers.
            Give the focus to the prev or the next sibling. If neither exist, delete the 
            parent and give the focus to the grandparent.
            
    Params:
        IN  PDATABASE pDataBase:    The database in which the app or layer to be deleted resides
        IN  BOOL bApp:              Is it an app or a layer?
        IN  HTREEITEM hItemDelete:  The tree item to be deleted
        IN  BOOL bRepaint (TRUE):   Not used
        
    Warning:
        *************************************************************************
        The actual layer or app has already been deleted before calling this function. 
        So do not get the lParam and do any stuff with it. Do not call GetItemType for
        the hItemDelete
        *************************************************************************
--*/
{
    HTREEITEM   hItemPrev = NULL, 
                hItemNext = NULL, 
                hParent = NULL, 
                hGrandParent = NULL;

    LPARAM      lParam = NULL;
    TYPE        type   = TYPE_UNKNOWN;

    hItemPrev = TreeView_GetPrevSibling(m_hLibraryTree, hItemDelete);
    
    HTREEITEM hItemShow;

    if (hItemPrev != NULL) {
        hItemShow = hItemPrev;
    } else {

        hItemNext = TreeView_GetNextSibling(m_hLibraryTree, hItemDelete);

        if (hItemNext != NULL) {

            hItemShow = hItemNext;
        } else {

            //
            // Now delete the parent and set the focus to the grandparent
            //
            if (bApp) {

                pDataBase->hItemAllApps = NULL;

            } else {

                pDataBase->hItemAllLayers = NULL;
            }

            hParent       =  TreeView_GetParent(m_hLibraryTree, hItemDelete);
            hGrandParent  = TreeView_GetParent(m_hLibraryTree, hItemDelete);

            hItemDelete   = hParent;
            hItemShow     = hGrandParent;
        }
    }

    SetStatusStringDBTree(TreeView_GetParent(m_hLibraryTree, hItemDelete)); 

    TreeView_DeleteItem(m_hLibraryTree, hItemDelete);

    if (bRepaint) {
        //
        // Tree view automatically selects the next element or the parent it there is no next.
        //
        SetFocus(m_hLibraryTree);
    }
}

void 
DatabaseTree::InsertLayerinTree(
    IN  HTREEITEM   hItemLayers, 
    IN  PLAYER_FIX  plf,
    IN  HWND        hwndTree, // (NULL)
    IN  BOOL        bShow     // (FALSE)
    )
/*++
    DatabaseTree::InsertLayerinTree
    
    Desc:   Given a single layer, it adds it under "Compatibility Modes" tree item for that database
            It assumes that the parent "Compatibility Modes" tree item is already present 
            
    Params:
        IN  HTREEITEM   hItemLayers:        The all layers item for the database
        IN  PLAYER_FIX  plf:                The layer that we are adding
        IN  HWND        hwndTree (NULL):    The tree
        IN  BOOL        bShow (FALSE):      If true will select the newly added layer
--*/
{
    if (hwndTree == NULL) {
        hwndTree = m_hLibraryTree;
    }

    if (plf == NULL) {
        assert(FALSE);
        Dbg(dlError, "DatabaseTree::InsertLayerinTree Invalid parameter");
        return;
    }

    TVINSERTSTRUCT  is;

    is.hInsertAfter        = TVI_SORT;
    is.item.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    is.item.stateMask      = TVIS_EXPANDED;

    is.hParent             = hItemLayers ;
    is.item.lParam         = (LPARAM)plf ;
    is.item.pszText        = plf->strName;
    is.item.iImage         = IMAGE_LAYERS;
    is.item.iSelectedImage = IMAGE_LAYERS;

    HTREEITEM hSingleLayer = TreeView_InsertItem(hwndTree, &is);

    //
    // Add the shims for this Layer
    //  
    PSHIM_FIX_LIST pShimFixList = plf->pShimFixList;
    PFLAG_FIX_LIST pFlagFixList = plf->pFlagFixList;

    if (pShimFixList || pFlagFixList) {

        while (pShimFixList) {

            is.hInsertAfter        = TVI_SORT;

            assert(pShimFixList->pShimFix != NULL);

            is.hParent             = hSingleLayer;
            is.item.pszText        = pShimFixList->pShimFix->strName;
            is.item.lParam         = (LPARAM)pShimFixList->pShimFix;
            is.item.iImage         = IMAGE_SHIM;
            is.item.iSelectedImage = IMAGE_SHIM;

            HTREEITEM hSingleShimInLayer = TreeView_InsertItem(hwndTree, &is);

            //
            // Add the Include and Exclude list for this shim (Expert mode only)
            //
            if (!pShimFixList->strlInExclude.IsEmpty() && g_bExpert) {
    
                is.hParent      = hSingleShimInLayer;
                is.hInsertAfter = TVI_LAST;
    
                PSTRLIST listTemp = pShimFixList->strlInExclude.m_pHead;
    
                while (listTemp) {
    
                    if (listTemp->data == INCLUDE) {
    
                        is.item.iImage         = IMAGE_INCLUDE;
                        is.item.iSelectedImage = IMAGE_INCLUDE;
                        is.item.lParam         = TYPE_GUI_INCLUDE;
                    } else {
    
                        is.item.iImage         = IMAGE_EXCLUDE;
                        is.item.iSelectedImage = IMAGE_EXCLUDE;
                        is.item.lParam         = TYPE_GUI_EXCLUDE;
                    }
    
                    is.item.pszText = listTemp->szStr;
                    listTemp        = listTemp->pNext;
    
                    TreeView_InsertItem(m_hLibraryTree, &is);
                }
            }

            if (pShimFixList->strCommandLine.Length() > 0 && g_bExpert) {

                //
                // Add the commandline for this shim in the layer.
                //
                CSTRING str;

                str.Sprintf(CSTRING(IDS_COMMANDLINE), pShimFixList->strCommandLine);

                is.hParent             = hSingleShimInLayer;
                is.item.lParam         = TYPE_GUI_COMMANDLINE;
                is.item.pszText        = str;
                is.item.iImage         = IMAGE_COMMANDLINE;
                is.item.iSelectedImage = IMAGE_COMMANDLINE;

                TreeView_InsertItem(hwndTree, &is);
            }
            
            pShimFixList = pShimFixList->pNext;
        }
    }

    is.hInsertAfter = TVI_SORT;

    //
    // Add the Flags for this Layer. Flags are also shown under the "Compatibility Fixes" parent
    // and they have the same icon as the compatibility fixes.
    //
    if (pFlagFixList) {

        while (pFlagFixList) {

            assert(pFlagFixList->pFlagFix != NULL);

            is.hParent             = hSingleLayer;
            is.item.iImage         = IMAGE_SHIM;
            is.item.iSelectedImage = IMAGE_SHIM;

            is.item.pszText = pFlagFixList->pFlagFix->strName;
            is.item.lParam  = (LPARAM)pFlagFixList->pFlagFix;

            HTREEITEM hSingleFlagInLayer = TreeView_InsertItem(hwndTree, &is);

            if (g_bExpert && pFlagFixList->strCommandLine.Length() > 0) {

                //
                // Add the commandline for this flag in the layer.
                //
                CSTRING str;

                str.Sprintf(CSTRING(IDS_COMMANDLINE), pFlagFixList->strCommandLine);

                is.hParent             = hSingleFlagInLayer;
                is.item.lParam         = TYPE_GUI_COMMANDLINE;
                is.item.pszText        = str;
                is.item.iImage         = IMAGE_COMMANDLINE;
                is.item.iSelectedImage = IMAGE_COMMANDLINE;

                TreeView_InsertItem(hwndTree, &is);
            }

            pFlagFixList =  pFlagFixList->pNext;
        }
    }

    if (bShow) {
        TreeView_SelectItem(m_hLibraryTree, hSingleLayer);
    }
}

BOOL
DatabaseTree::PopulateLibraryTree(
     IN  HTREEITEM   hRoot,
     IN  PDATABASE   pDataBase, 
     IN  BOOL        bLoadOnlyLibrary,   // (FALSE)
     IN  BOOL        bLoadOnlyApps       // (FALSE)  
     )
/*++
    
    DatabaseTree::PopulateLibraryTree
    
    Desc:   This does the bulk of work of loading a database into the tree
    
    Params:
    IN  HTREEITEM   hRoot:                      This will be the handle for either the "System Database"
        or the "Working Databases" or the "Installed Databases" tree item, depending upon where we want 
        to add the new database tree item. This is therefore the parent of the database tree item
        that we are going to add
    
    IN  PDATABASE   pDataBase:                  The database that is being loaded 
    IN  BOOL        bLoadOnlyLibrary (FALSE):   We do not want the apps to be loaded into the tree
        This is used, when we initially load the system DB  

    IN  BOOL        bLoadOnlyApps (FALSE):      We only want the apps to be loaded into the tree.
        This is used, when we load the apps for the sys DB  
        
--*/
{
    HTREEITEM       hItemShims;
    HTREEITEM       hItemLayers;
    TVINSERTSTRUCT  is;

    SendMessage(m_hLibraryTree, WM_SETREDRAW, FALSE, 0);

    //
    // Default settings
    //
    is.hInsertAfter   = TVI_SORT;
    is.item.mask      = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    is.item.stateMask = 0;
    is.item.lParam    = 0;

    if (bLoadOnlyApps == TRUE) {
        goto LoadApps;
    }

    //
    // Populate with the shims
    //
    if (pDataBase->pShimFixes != NULL || pDataBase->pFlagFixes != NULL) {
        is.hParent             = hRoot;
        is.item.lParam         = TYPE_GUI_SHIMS;
        is.item.pszText        = GetString(IDS_COMPATFIXES);
        is.item.iImage         = IMAGE_SHIM;
        is.item.iSelectedImage = IMAGE_SHIM;

        hItemShims = TreeView_InsertItem(m_hLibraryTree, &is);

        PSHIM_FIX psf = pDataBase->pShimFixes;

        while (psf) {

            //
            // Show only general shims
            //
            if (psf->bGeneral == FALSE && !g_bExpert) {

                psf = psf->pNext;
                continue;
            }

            is.hParent              = hItemShims;
            is.hInsertAfter         = TVI_SORT;
            is.item.lParam          = (LPARAM)psf;   
            is.item.pszText         = psf->strName;
            is.item.iImage          = IMAGE_SHIM;
            is.item.iSelectedImage  = IMAGE_SHIM;

            HTREEITEM hItemSingleShim = TreeView_InsertItem(m_hLibraryTree, &is);

            if (hItemSingleShim == NULL) {
                Dbg(dlError, "Failed to add a individual shim in TreePopulate");
                return FALSE;

            } else {

                //
                // Add the Include and Exclude list for this shim (Expert mode only)
                //
                if (!psf->strlInExclude.IsEmpty() && g_bExpert) {

                    is.hParent = hItemSingleShim;
                    is.hInsertAfter   = TVI_LAST;

                    PSTRLIST listTemp = psf->strlInExclude.m_pHead;

                    while (listTemp) {

                        if (listTemp->data == INCLUDE) {

                            is.item.iImage         = IMAGE_INCLUDE;
                            is.item.iSelectedImage = IMAGE_INCLUDE;
                            is.item.lParam         = TYPE_GUI_INCLUDE;
                        } else {

                            is.item.iImage         = IMAGE_EXCLUDE;
                            is.item.iSelectedImage = IMAGE_EXCLUDE;
                            is.item.lParam         = TYPE_GUI_EXCLUDE;
                        }

                        is.item.pszText = listTemp->szStr;
                        listTemp        = listTemp->pNext;

                        TreeView_InsertItem(m_hLibraryTree, &is);
                    }
                }

                //
                // Now add the command line
                //
                if (psf->strCommandLine.Length() > 0 && g_bExpert) {

                    is.hParent     = hItemSingleShim;
                    is.item.lParam = TYPE_GUI_COMMANDLINE;

                    CSTRING str;

                    str.Sprintf(CSTRING(IDS_COMMANDLINE), psf->strCommandLine);

                    is.item.pszText        = str;
                    is.item.iImage         = IMAGE_COMMANDLINE;
                    is.item.iSelectedImage = IMAGE_COMMANDLINE;

                    TreeView_InsertItem(m_hLibraryTree, &is);
                }
            }

            psf = psf->pNext;
        }

        //
        // Put the Flags now, this time under the shims icon
        // 
        is.hInsertAfter   = TVI_SORT;

        if (pDataBase->pFlagFixes != NULL) {

            is.hParent             = hItemShims;
            is.item.iImage         = IMAGE_SHIM;
            is.item.iSelectedImage = IMAGE_SHIM;

            PFLAG_FIX pff = pDataBase->pFlagFixes;

            while (pff) {

                if (pff->bGeneral || g_bExpert) {

                    is.item.lParam  = (LPARAM)pff;
                    is.item.pszText = pff->strName;
                    TreeView_InsertItem(m_hLibraryTree, &is);
                }

                pff = pff->pNext;
            }
        }
    }

    //
    // Now populate the layers.
    //
    if (pDataBase->pLayerFixes != NULL) {

        is.hParent             = hRoot;
        is.item.lParam         = TYPE_GUI_LAYERS;
        is.item.iImage         = IMAGE_LAYERS;
        is.item.iSelectedImage = IMAGE_LAYERS;
        is.item.pszText        = GetString(IDS_COMPATMODES);  

        hItemLayers = TreeView_InsertItem(m_hLibraryTree, &is);

        pDataBase->hItemAllLayers = hItemLayers;

        PLAYER_FIX plf = pDataBase->pLayerFixes;

        while (plf) {
            InsertLayerinTree(hItemLayers, plf, FALSE);
            plf = plf->pNext;
        }
    }

LoadApps:

    //
    // Now add the Apps
    //
    if (pDataBase->pEntries && !bLoadOnlyLibrary) {

        is.hParent             = hRoot;
        is.item.lParam         = TYPE_GUI_APPS;
        is.item.pszText        = GetString(IDS_APPS);
        is.item.iImage         = IMAGE_APP;
        is.item.iSelectedImage = IMAGE_APP;

        if (pDataBase->type != DATABASE_TYPE_GLOBAL) {
            pDataBase->hItemAllApps = TreeView_InsertItem(m_hLibraryTree, &is);
        }

        PDBENTRY pApps = pDataBase->pEntries;

        while (pApps) {

            is.hParent              = pDataBase->hItemAllApps;
            is.item.lParam          = (LPARAM)pApps;
            is.item.pszText         = pApps->strAppName;
            is.item.iImage          = IMAGE_SINGLEAPP;
            is.item.iSelectedImage  = IMAGE_SINGLEAPP;
             
            TreeView_InsertItem(m_hLibraryTree, &is);
            
            pApps = pApps->pNext;
        }
    }

    SendMessage(m_hLibraryTree, WM_SETREDRAW, TRUE, 0);
    return TRUE;
}

void
DatabaseTree::AddApp(
    IN  PDATABASE   pDatabase,
    IN  PDBENTRY    pApp,
    IN  BOOL        bUpdate // (TRUE)
    )
/*++
    
    DatabaseTree::AddApp
    
    Desc:    If there is no app for
             pApp->strApp:  Adds a new app entry in the db tree for the database
             Otherwise, it sets the lParam of the existing entry to pApp.
             Calls UpdateEntryTree() after this
             
    Params:
        IN  PDATABASE   pDatabase:      The database in which this app has been added
        IN  PDBENTRY    pApp:           The app that is to be added to the tree
        IN  BOOL        bUpdate (TRUE): Should we set the focus to the new tree item
        
    Return:
        void
--*/
{
    if (pDatabase == NULL) {
        assert(FALSE);
        return;
    }
    
    HTREEITEM   hItem = pDatabase->hItemAllApps;
    TVITEM      tvitem;
    TCHAR       szBuffer[MAX_PATH];

    
    if (pDatabase->hItemAllApps == NULL) {

        AddNewExe(pDatabase, pApp, NULL, bUpdate);
        return;
    }

    //
    // Search for the app-name 
    //
    hItem = TreeView_GetChild(m_hLibraryTree, hItem);
    
    tvitem.mask         = TVIF_TEXT;
    tvitem.pszText      = szBuffer;
    tvitem.cchTextMax   = ARRAYSIZE(szBuffer);

    while (hItem) {

        tvitem.hItem        = hItem;
        *szBuffer           = 0;

        if (!TreeView_GetItem(m_hLibraryTree, &tvitem)) {
            assert(FALSE);
            goto Next;
        }

        if (lstrcmpi(szBuffer, pApp->strAppName) == 0) {

            //
            // This is the app name
            //
            SetLParam(hItem, (LPARAM)pApp);

            if (bUpdate) {
                //
                // This entry was added in the beginning of the list
                //
                TreeView_SelectItem(m_hLibraryTree, hItem);

                g_pEntrySelApp  = pApp;
                g_pSelEntry     = pApp;

                UpdateEntryTreeView(pApp, g_hwndEntryTree);
            }

            return;
        }
Next:
        hItem = TreeView_GetNextSibling(m_hLibraryTree, hItem);
    }

    //
    // There is no entry with this app-name uder the apps of the database
    //
    AddNewExe(pDatabase, pApp, NULL, bUpdate);
}

HTREEITEM
DatabaseTree::GetSelection(
    void
    )
/*++
    DatabaseTree::GetSelection
    
    Desc:   Returns the selected item in the db tree.
    
    Return: Returns the selected item in the db tree.
        
--*/
{
    return TreeView_GetSelection(m_hLibraryTree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\dbtree.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    DBTree.h

Abstract:

    Header file for DBTree.cpp which handles the code for handling the trees used 
    in the application
        
Author:

    kinshu created  October 15, 2001

--*/

#include "precomp.h"

/////////////////////// Extern Variables //////////////////////////////////////

extern struct DataBase  GlobalDataBase;
extern HIMAGELIST       g_hImageList;
extern PDBENTRY         g_pEntrySelApp;
extern PDATABASE        g_pPresentDataBase;
extern HWND             g_hwndEntryTree;
extern UINT             g_uNextDataBaseIndex;
extern PDBENTRY         g_pSelEntry; 
extern HINSTANCE        g_hInstance;
extern HWND             g_hwndToolBar;
extern HWND             g_hwndStatus;


///////////////////////////////////////////////////////////////////////////////

/*++
 
  The db tree that appears in the LHS
  
--*/
class DatabaseTree : public CTree {

public:
    HWND        m_hLibraryTree;         // The handle to the db tree
    INT         m_width;                // Width  of this tree view

    HTREEITEM   m_hItemGlobal;          // Handle to the "System Database" node
    HTREEITEM   m_hItemAllInstalled;    // Handle to the "Installed Databases" node
    HTREEITEM   m_hItemAllWorking;      // Handle to the "Custom Databases" node
    HTREEITEM   m_hPerUserHead;         // Handle to the "Per User Compatibility Settings" node

    void 
    Init(
        HWND    hdlg,
        INT     iHeightToolbar,
        INT     iHeightStatusbar,
        RECT*   prcMainClient
        );

    BOOL
    PopulateLibraryTreeGlobal(
        void
        );

    BOOL
    AddWorking(
        PDATABASE pDataBase
        );
    
    BOOL
    RemoveDataBase(
        HTREEITEM hItemDB,
        TYPE      typeDB,
        BOOL      bSelectSibling = TRUE
        );

    void
    RemoveAllWorking(
        void
        );

    BOOL
    SetLParam(
        HTREEITEM hItem, 
        LPARAM lParam
        );
    
    BOOL
    GetLParam(
        HTREEITEM hItem, 
        LPARAM *plParam
        );
    
    HTREEITEM
    DatabaseTree::
    FindChild(
        HTREEITEM hItemParent,
        LPARAM lParam
        );

    HTREEITEM
    GetAllAppsItem (
        HTREEITEM hItemDataBase
        );
        
    HTREEITEM
    GetFirstAppItem(
        HTREEITEM hItemDataBase
        );

    void
    AddNewLayer(   
        PDATABASE   pDataBase,
        PLAYER_FIX  pLayer,
        BOOL        bShow = FALSE
        );
    
    void
    RefreshAllLayers(
        PDATABASE  pDataBase
        );
    
    HTREEITEM
    RefreshLayer(
        PDATABASE   pDataBase,
        PLAYER_FIX  pLayer
        );
    
    BOOL
    AddNewExe(
        PDATABASE pDataBase,
        PDBENTRY  pEntry,
        PDBENTRY  pApp,
        BOOL      bRepaint = TRUE
        );

    BOOL
    AddInstalled(
        PDATABASE pDataBase
        );

    void
    DeleteAppLayer(
        PDATABASE   pDataBase,
        BOOL bApp,
        HTREEITEM   hItemDelete,
        BOOL        bRepaint = TRUE
        );
    
    void 
    InsertLayerinTree(
        HTREEITEM   hItemLayers, 
        PLAYER_FIX  plf,
        HWND        hwndTree = NULL,
        BOOL        bRepaint = FALSE
        );

    BOOL
    PopulateLibraryTree(
        HTREEITEM   hRoot,                    
        PDATABASE   pDataBase, 
        BOOL        bLoadOnlyLibrary = FALSE, 
        BOOL        bLoadOnlyApps = FALSE 
        );

    void
    AddApp(
        PDATABASE   pDatabase,
        PDBENTRY    pApp,
        BOOL        bUpdate = TRUE
        );
    
    HTREEITEM
    GetSelection(
        void
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\lua.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    LUA.cpp

Abstract:
    
    Implementation of the LUA wizard in CompatAdmin.
    
Author:

    maonis

--*/

/*++

The UI to customize the LUA shims lets you track and edit the list of files
and directories passed as the command line to the LUA shims. Only the LUA 
FS shims are parameterized so the UI is for editing the list of files.

Page 1: Tracking
================

We apply the LUATrackFS shim to the executable. When the app finishes running,
we get a log in AppPatch directory that tells us which files and directories
the app attempted to write to.

Next time when the sdb is loaded, the user can choose to discard the old result
and start fresh, append the new data to the old one (with duplicates removed), 
or simply just edit the data collected last time.

Scenario: if the user forgot to test some features, he would not want to check 
the "Override existing data" checkbox because he won't want to test all the 
features he already tested.

Page 2: Extension exclusion list
================================

By default we exclude a list of file extensions because files with these extensions
are likely to be user data only. The list can be found as a value called 
LUADefaultExclusionList under the reg key 
HKLM\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags.

This page gives you an option to modify this list.

Page 3: Editing the redirect file list
======================================

(We call it a file list, but really it includes files and directories. A directory
is indicated by the trailing slash.)

If an item is already exactly what you want, you simply check the checkbox before
the file name. But sometimes you want to use wildcards or whatever, in which case
you can either copy it to edit, or type in a new item name.

Use the "Redirect to All User" checkbox to toggle between redirecting to the 
per-user directory and all-user directory. The default is to redirect to per-user.

The xml looks like:

    <APP NAME="Some app" VENDOR="Some company">
        <EXE NAME="Some executable">
            <SHIM NAME="LUARedirectFS">

                <DATA NAME="AllUserDir" VALUETYPE="STRING"
                      VALUE="%ALLUSERSPROFILE%\AllUserRedirect"/>

                <DATA NAME="PerUserDir" VALUETYPE="STRING"
                      VALUE="%USERSPROFILE%\Redirect"/>

                <DATA NAME="StaticList" VALUETYPE="STRING"
                      VALUE="AC-%APPDRIVE%\a\;PU-%APPPATH%\b.txt"/>

                <DATA NAME="DynamicList" VALUETYPE="STRING"
                      VALUE="AC-%APPPATH%\b\;PU-c:\b\b.txt;AU-c:\c\"/>

                <DATA NAME="ExcludedExtensions" VALUETYPE="STRING"
                      VALUE="doc txt gif"/>
            </SHIM>
        </EXE>
    </APP>

A means to redirect to the all-user directory.
P means to redirect to the per-user directory.
C means the item is checked.
U means the item is not checked.

We use variables to make the sdb portable. We define 2 variables and the rest can
be any enviorment variable.

%APPPATH% - this is the path of the executable. 
            eg, in c:\temp\notepad.exe, %APPPATH% is c:\temp

%APPDRIVE% - this is the drive the executable is on.
            eg, in c:\temp\notepad.exe, %APPDRIVE% is c:

The LUARedirectFS shim knows how to interpret the <DATA> sections.

Page 4: Redirect paths
======================

We show the user what the all-user and per-user redirect redirectories are - we use
the app name as the directory name under the all-user and per-user profile directories
and this can not be changed.

--*/

#include "precomp.h"

extern HINSTANCE g_hInstance;

#define NUM_PAGES_LUA            4

#define PAGE_LUA_ACTION          0
#define PAGE_LUA_EXCLUSION       1
#define PAGE_LUA_EDIT_FILE_LIST  2
#define PAGE_LUA_COMMON_PATHS    3

#define IS_IN_COMMANDLINE   1
#define IS_IN_DATA          2
#define IS_IN_BOTH          3

#define LUA_DATA_ALLUSERDIR             L"AllUserDir"
#define LUA_DATA_PERUSERDIR             L"PerUserDir"
#define LUA_DATA_STATICLIST             L"StaticList"
#define LUA_DATA_DYNAMICLIST            L"DynamicList"
#define LUA_DATA_EXCLUDEDEXTENSIONS     L"ExcludedExtensions"

typedef struct tagREDIRECT_ITEM {

    LIST_ENTRY  entry;
    CSTRING     strName;
    BOOL        bChecked;
    BOOL        bRedirectToAllUser;

    tagREDIRECT_ITEM()
    {
        bChecked = FALSE;
        bRedirectToAllUser = FALSE;
    }

} REDIRECT_ITEM, *PREDIRECT_ITEM;

typedef struct tagUNTOKENIZED_ITEM {

    LIST_ENTRY entry;
    CSTRING    strName;

} UNTOKENIZED_ITEM, *PUNTOKENIZED_ITEM;

// The line type for the file generated by the LUATrackFS shim.
typedef enum {
    LINE_INVALID,
    LINE_FILE_COUNT, // The file count line: Fn
    LINE_DIR_COUNT,  // The directory count line: Dn
} LINETYPE;

typedef enum {

    LUA_TRACK_UNKNOWN = 0,
    LUA_TRACK_YES,
    LUA_TRACK_NO

} LUA_TRACK_STATE;

int g_iCurrentEditItem = -1;
BOOL g_bNewListViewItem = FALSE;
int g_nStaticItems = 0;
HMENU g_hContextMenu = NULL;

// The entry we currently work on.
PDBENTRY        g_pEntryLua;

// Points to the shim that has the lua data.
PSHIM_FIX_LIST  g_psflLua = NULL;

// This is *our* copy of the lua data so we don't overwrite the data in the entry
// before the user presses Finish.
LUADATA         g_LuaData;

BOOL            g_bUseNewStaticList = TRUE;

// List of items displayed in the 2nd page of the wizard. 
// This includs items that can and can not be edited.
LIST_ENTRY g_OldStaticList;
LIST_ENTRY g_NewStaticList;
LIST_ENTRY g_DynamicList;
BOOL g_bListsInitialized = FALSE;

LIST_ENTRY g_UntokenizedList;

// Has this executable been tracked using LUATrackFS shim yet?
LUA_TRACK_STATE g_TrackState;

BOOL    g_bHasAppPathSet = FALSE;
WCHAR   g_wszAppPath[MAX_PATH] = L"";
UINT    g_cAppPath = 0;

// If APPPATH is c:\x\y\z, this is 4.
UINT    g_cAppPath1stComp = 0;

// We always display the files in Program Files\Common Files as 
// %ProgramFiles%\Common Files.
WCHAR   g_wszProgramFilesCommon[MAX_PATH] = L"";
UINT    g_czProgramFilesCommon = 0;

#define COMMON_FILES L"\\Common Files\\"
#define COMMON_FILES_LEN (sizeof(COMMON_FILES) / sizeof(WCHAR) - 1)

BOOL    g_bDuringUntokenize = FALSE;

// The font for displaying up and down arrows.
HFONT g_hArrowFont = NULL;

// The database in which the entry being customized resides.
static PDATABASE s_pDatabase;

// This is where we store the default exclusion list in the registry under HKLM.
#define LUA_APPCOMPAT_FLAGS_PATH L"Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags"
#define LUA_DEFAULT_EXCLUSION_LIST L"LUADefaultExclusionList"

// We are not freeing it here - it'll stay the whole time the process is running and
// we'll let the process itself do the cleanup.
LPWSTR g_pwszDefaultExclusionList = NULL;

// We want to remember if the user wants to redirect any files at all to all user redirec
// dir; if not we won't bother to create it.
BOOL g_bAllUserDirUsed = FALSE;

// This is for debugging purposes.
void
LuapDumpList(
    LPCWSTR pwsz,
    PLIST_ENTRY pHead
    )
{
    OutputDebugString(pwsz);

    PREDIRECT_ITEM pItem;
    
    for (PLIST_ENTRY pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);

        OutputDebugString(L"\t");
        OutputDebugString(pItem->strName);
        OutputDebugString(L"\n");
    }
}

BOOL
LuapAddItem(
    PLIST_ENTRY pHead,
    LPCWSTR     pwszName,
    BOOL        bChecked,
    BOOL        bRedirectToAllUser
    )
{
    PREDIRECT_ITEM pItem = new REDIRECT_ITEM;

    if (pItem == NULL) {
        MEM_ERR;
        return FALSE;
    }

    pItem->strName = pwszName;
    pItem->bChecked = bChecked;
    pItem->bRedirectToAllUser = bRedirectToAllUser;

    InsertTailList(pHead, &pItem->entry);

    return TRUE;
}

void
LuapDeleteList(
    PLIST_ENTRY pHead
    )
{
    PREDIRECT_ITEM pItem;
    PLIST_ENTRY pTempEntry;

    for (PLIST_ENTRY pEntry = pHead->Flink; pEntry && pEntry != pHead; pEntry = pEntry->Flink) {

        pTempEntry = pEntry->Flink;
        pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);
        RemoveEntryList(pEntry);
        delete pItem;
        
        pEntry = pTempEntry;
    }

    pHead->Flink = pHead->Blink = NULL;
}

PLIST_ENTRY
LuapFindEntry(
    PLIST_ENTRY pHead,
    PLIST_ENTRY pEntryToFind
    )
{
    PREDIRECT_ITEM pItem;
    PREDIRECT_ITEM pItemToFind = CONTAINING_RECORD(pEntryToFind, REDIRECT_ITEM, entry);

    for (PLIST_ENTRY pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);

        if (!_wcsicmp(pItem->strName, pItemToFind->strName)) {
            return pEntry;
        }
    }

    return NULL;
}

PLIST_ENTRY
LuapFindEntry(
    PLIST_ENTRY pHead,
    PREDIRECT_ITEM pItemToFind
    )
{
    PREDIRECT_ITEM pItem;

    for (PLIST_ENTRY pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);

        if (!_wcsicmp(pItem->strName, pItemToFind->strName)) {
            return pEntry;
        }
    }

    return NULL;
}

LINETYPE 
LuapGetLineType(
    LPCWSTR pwszLine
    )
{
    if (pwszLine && *pwszLine) {
        WCHAR ch0, ch1;
        ch0 = *pwszLine;
        ch1 = *++pwszLine;
        if (ch0 == L'F' || ch0 == L'D') {
            if (ch1 >= L'0' && ch1 <= L'9') {
                return (ch0 == L'F' ? LINE_FILE_COUNT : LINE_DIR_COUNT);
            }
        }
    }
    
    return LINE_INVALID;
}

DWORD 
LuapGetListItemCount(
    LPCWSTR pwsz
    )
{
    DWORD cItems = 0;

    while (*pwsz) {

        if (*pwsz == L';') {
            ++cItems;
        }
        ++pwsz;
    }

    return cItems;
}

BOOL
LuapGenerateTrackXML(
    const PDBENTRY pEntry,
    CSTRINGLIST* strlXML
    )
{
    CSTRING strTemp;

    if (!strlXML->AddString(TEXT("<?xml version=\"1.0\" encoding=\"UTF-16\"?>")) || 
        !strlXML->AddString(TEXT("<DATABASE NAME=\"Test database\">"))) {
        return FALSE;
    }

    strTemp.Sprintf(TEXT("\t<APP NAME=\"%s\" VENDOR=\"%s\">"),
                    (LPCTSTR)(pEntry->strAppName.SpecialCharToXML()),
                    (LPCTSTR)(pEntry->strVendor.SpecialCharToXML()));

    if (!strlXML->AddString(strTemp)) {
        return FALSE;
    }

    strTemp.Sprintf(TEXT("\t\t<EXE NAME=\"%s\">"), 
                    (LPCTSTR)pEntry->strExeName.SpecialCharToXML());

    if (!strlXML->AddString(strTemp)) {
        return FALSE;
    }

    if (!strlXML->AddString(TEXT("\t\t\t<SHIM NAME= \"LUATrackFS\"/>")) ||
        !strlXML->AddString(TEXT("\t\t</EXE>")) ||
        !strlXML->AddString(TEXT("\t</APP>")) ||
        !strlXML->AddString(TEXT("</DATABASE>"))) {
        return FALSE;
    }

    return TRUE;
}

// If we see a file begins with %ProgramFiles%\Common Files, we susbstitute it.
BOOL
LuapSubstituteProgramFilesCommon(
    LPCWSTR pwszItem,
    CSTRING& strItem
    )
{
    if (g_wszProgramFilesCommon[0] != L'\0') {
        if (!_wcsnicmp(pwszItem, g_wszProgramFilesCommon, g_czProgramFilesCommon)) {

            strItem = L"%ProgramFiles%\\Common Files";
            strItem += CSTRING(pwszItem + g_czProgramFilesCommon);

            return TRUE;
        }
    }

    return FALSE;
}

// We check if we should display the path as relative to APPPATH -
// we only do this when the item path has more than just the common
// root with APPPATH.
BOOL
LuapGetRelativeName(
    LPCWSTR pwszItem,
    CSTRING& strItem
    )
{
    if (g_cAppPath1stComp > 2 && !_wcsnicmp(pwszItem + 2, g_wszAppPath + 2, g_cAppPath1stComp - 2)) {

        CSTRING strTemp = pwszItem;
        CSTRING strAppPath(g_wszAppPath);
        strAppPath.Strcat(L"\\");
        
        if (strTemp.RelativeFile(strAppPath)) {
            strItem = L"%APPPATH%\\";
            strItem += strTemp;

            return TRUE;
        }
    }

    return FALSE;
}

BOOL
LuapGetFileListFromFile(
    CSTRING& strExeName,
    PLIST_ENTRY pHead
    )
{

    if (strExeName == NULL) {
        return FALSE;
    }

    CSTRING strLuaLog;
    LPWSTR  pwszLuaLogContents = NULL;

    TCHAR szWindowsDir[MAX_PATH];
    *szWindowsDir = 0;
    //
    // Need to leave space for adding the trailing slash.
    //
    UINT cBufferLen = MAX_PATH - 1;
    UINT cWindowsDirLen = GetSystemWindowsDirectory(szWindowsDir, cBufferLen);

    if (cWindowsDirLen == 0 || cWindowsDirLen >= cBufferLen) {
        Dbg(dlError,"[LuapGetFileListFromFile] Error getting the windows directory");
        return FALSE;
    }

    ADD_PATH_SEPARATOR(szWindowsDir, ARRAYSIZE(szWindowsDir));

    CSTRING strTempExeName = strExeName;

    LPTSTR pszExtension = _tcsrchr(strTempExeName, TEXT('.'));

    //
    // If there's no extension we use the whole file name.
    //
    if (pszExtension) {
        *pszExtension = 0;
    }

    strLuaLog.Sprintf(TEXT("%sAppPatch\\%s.LUA.log"), (LPCTSTR)szWindowsDir, strTempExeName);
    
    //
    // Get the file list.
    //
    if (!GetFileContents(strLuaLog, &pwszLuaLogContents)) {

        return FALSE;
    }

    LPWSTR pwszNextLine = GetNextLine(pwszLuaLogContents);
    LPWSTR pwszItem;
    CSTRING strItem;
    DWORD cItems, i;
    LINETYPE LineType;
    
    while (pwszNextLine)
    {
        LineType = LuapGetLineType(pwszNextLine);
        if (LineType == LINE_INVALID) {
            Dbg(dlError,"[LuapGetFileListFromFile] Invalid line %S", pwszNextLine);
            return FALSE;
        }

        cItems = _wtoi(++pwszNextLine);
        for (i = 0; i < cItems; ++i) {
            pwszItem = GetNextLine(NULL);

            if (pwszItem == NULL) {
                Dbg(dlError,"[LuapGetFileListFromFile] count and actual files mismatch");
                return FALSE;
            }

            //
            // By now the apppath and appdrive should be set, so tokenize the item.
            //
            if (!_wcsnicmp(pwszItem, g_wszAppPath, 2)) {

                if (!LuapSubstituteProgramFilesCommon(pwszItem, strItem)) {
                    if (!LuapGetRelativeName(pwszItem, strItem)) {
                        strItem = L"%APPDRIVE%";
                        strItem.Strcat(pwszItem + 2);
                    }
                }

            } else {
                strItem = pwszItem;
            }

            if (!LuapAddItem(pHead, strItem, FALSE, FALSE)) {
                return FALSE;
            }
        }

        pwszNextLine = GetNextLine(NULL);
    }
        
    if (pwszLuaLogContents) {
        delete[] pwszLuaLogContents;
        pwszLuaLogContents = NULL;
    }

    return TRUE;
}

BOOL
LuapFillInList(
    LPCWSTR pwszList,
    PLIST_ENTRY pHead
    )
{
    if (pwszList) {
        //
        // Make a copy.
        //
        CSTRING strList = pwszList;

        LPWSTR pwsz = strList;
        LPWSTR pwszToken = pwsz;
        WCHAR  ch;
        BOOL   bChecked, bRedirectToAllUser;
        
        while (TRUE) {
            if (*pwsz == L';' || *pwsz == L'\0') {

                ch = *pwsz;
                *pwsz = L'\0';
     
                TrimLeadingSpaces(pwszToken);
                TrimTrailingSpaces(pwszToken);

                bChecked = (pwszToken[1] == L'C');
                bRedirectToAllUser = (pwszToken[0] == L'A');
                
                if (!LuapAddItem(pHead, pwszToken + 3, bChecked, bRedirectToAllUser)) {
                    return FALSE;
                }

                pwszToken = pwsz + 1;

                if (ch == L'\0') {
                    break;
                }
            }

            ++pwsz;
        }
    }

    return TRUE;
}

/*++

Desc:

    The algorithm for append:

    for each item in the new static list, attempt to find it in the old static list

    if (FALSE) 
        remove it from the new static list
        add it to the end of the old static list 
        check if it exists in the dynamic list
        
        if (TRUE)
            copy the attributes from the dynamic list
            remove it from the dynamic list

--*/
void
LuapTrackAppend(
    )
{
    PREDIRECT_ITEM pItem, pDynamicItem;
    PLIST_ENTRY pDynamicEntry;

    PLIST_ENTRY pEntry = g_NewStaticList.Flink; 
    PLIST_ENTRY pTempEntry; 
    
    while (pEntry != &g_NewStaticList) {

        pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);

        if (LuapFindEntry(&g_OldStaticList, pItem)) {
            pEntry = pEntry->Flink;
        } else {

            pTempEntry = pEntry->Flink;
            RemoveEntryList(pEntry);
            InsertTailList(&g_OldStaticList, pEntry);

            if (pDynamicEntry = LuapFindEntry(&g_DynamicList, pItem)) {

                pDynamicItem = CONTAINING_RECORD(pDynamicEntry, REDIRECT_ITEM, entry);
                
                pItem->bChecked = pDynamicItem->bChecked;
                pItem->bRedirectToAllUser = pDynamicItem->bRedirectToAllUser;

                RemoveEntryList(pDynamicEntry);
            }

            pEntry = pTempEntry;
        }
    }

    g_bUseNewStaticList = FALSE;
}

/*++

Desc:

    The algorithm for start fresh:

    for each item in the new static list, attempt to find it in the dynamic list

    if (TRUE) 
        copy the attributes from the dynamic list
        remove it from the dynamic list

    for each *checked* item in the old static list, attempt to find it in the new static list

    if (FALSE)
        add it to the tail of the dynamic list
        remove it from the old static list

--*/
void
LuapTrackFresh(
    )
{
    PREDIRECT_ITEM pItem, pDynamicItem;
    PLIST_ENTRY pEntry, pTempEntry, pDynamicEntry, pNewStaticEntry;

    for (pEntry = g_NewStaticList.Flink; pEntry != &g_NewStaticList; pEntry = pEntry->Flink) {
        if (pDynamicEntry = LuapFindEntry(&g_DynamicList, pEntry)) {

            pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);
            pDynamicItem = CONTAINING_RECORD(pDynamicEntry, REDIRECT_ITEM, entry);
            
            pItem->bChecked = pDynamicItem->bChecked;
            pItem->bRedirectToAllUser = pDynamicItem->bRedirectToAllUser;

            RemoveEntryList(pDynamicEntry);
        }
    }

    pEntry = g_OldStaticList.Flink;

    while (pEntry != &g_OldStaticList) {

        pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);

        if (pItem->bChecked) {

            if (pNewStaticEntry = LuapFindEntry(&g_NewStaticList, pItem)) {

                pTempEntry = pEntry->Flink;
                RemoveEntryList(pEntry);
                InsertTailList(&g_DynamicList, pEntry);
                pEntry = pTempEntry;

                continue;
            }
        }
                    
        pEntry = pEntry->Flink;
    }
}

void
LuapCleanup()
{
    LuapDeleteList(&g_OldStaticList);
    LuapDeleteList(&g_NewStaticList);
    LuapDeleteList(&g_DynamicList);

    g_LuaData.Free();

    g_bHasAppPathSet = FALSE;
    g_bDuringUntokenize = FALSE;

    g_wszAppPath[0] = L'\0';
    g_cAppPath = 0;
    g_cAppPath1stComp = 0;
    g_wszProgramFilesCommon[0] = L'\0';
    g_czProgramFilesCommon = 0;

    //
    // Clear the enviornment variables.
    //
    SetEnvironmentVariable(L"APPPATH", NULL);
    SetEnvironmentVariable(L"APPDRIVE", NULL);
}

BOOL
LuapInitializeOldLists(
    HWND hDlg
    )
{
    InitializeListHead(&g_OldStaticList);
    InitializeListHead(&g_DynamicList);
    if (LuapFillInList(g_LuaData.strStaticList, &g_OldStaticList) && 
        LuapFillInList(g_LuaData.strDynamicList, &g_DynamicList)) {

        return TRUE;
    }

    MessageBox(hDlg, 
        GetString(IDS_LUA_INIT_OLD_LISTS), 
        g_pEntryLua->strAppName,
        MB_ICONERROR);

    return FALSE;
}

/*++

Desc:

    Merges the list from <DATA> section and the COMMAND_LINE of LUARedirectFS.
    For each item in command line, look it up in <DATA> so we know how to display
    those items in <DATA> in the UI.

--*/
BOOL
LuapMergeLists(
    BOOL bMergeOld, // Merge the old data from the <DATA> section.
    HWND hDlg
    )
{
    g_bListsInitialized = TRUE;
    BOOL bIsSuccess = FALSE;

    if (!LuapInitializeOldLists(hDlg)) {

        return FALSE;
    }

    //
    // Initialize the new static list.
    //
    InitializeListHead(&g_NewStaticList);
    if (!LuapGetFileListFromFile(g_pEntryLua->strExeName, &g_NewStaticList)) {
        goto EXIT;
    }

    bMergeOld ? LuapTrackAppend() : LuapTrackFresh();

    bIsSuccess = TRUE;

EXIT:

    if (!bIsSuccess) {
        LuapCleanup();
    }

    return bIsSuccess;
}

/*++

Desc:
    
    Copy the data over - we don't want to modify the original copy until the user 
    tells us to.
    
--*/
void 
LuapGetDataFromEntry(
    PLUADATA pLuaData
    )
{
    //
    // We can set the redirect dirs now.
    //
    CSTRING strAllUserDir(L"%ALLUSERSPROFILE%\\Application Data\\");
    strAllUserDir += g_pEntryLua->strAppName;
    CSTRING strPerUserDir(L"%USERPROFILE%\\Application Data\\");
    strPerUserDir += g_pEntryLua->strAppName;
    
    g_LuaData.strAllUserDir = strAllUserDir;
    g_LuaData.strPerUserDir = strPerUserDir;

    if (pLuaData) {
        g_LuaData.strStaticList = pLuaData->strStaticList;
        g_LuaData.strDynamicList = pLuaData->strDynamicList;
        g_LuaData.strExcludedExtensions = pLuaData->strExcludedExtensions;

        g_TrackState = ((g_LuaData.strStaticList.isNULL() && 
                         g_LuaData.strDynamicList.isNULL() && 
                         g_LuaData.strExcludedExtensions.isNULL()) ? 
                        LUA_TRACK_NO : 
                        LUA_TRACK_YES);
    } else {
        g_TrackState = LUA_TRACK_NO;
    }
}

void
LuapCopyItems(
    HWND hwndList
    )
{
    int cItems = ListView_GetItemCount(hwndList);
    int iIndex = cItems;
    WCHAR wszItem[MAX_PATH] = L"";
    WCHAR wszRedirect[32] = L"";
    LVITEM lvi;
    int index;

    for (int i = 0 ; i < cItems; ++i) {

        if (ListView_GetItemState(hwndList, i, LVIS_SELECTED) == LVIS_SELECTED) {
            ListView_GetItemText(hwndList, i, 0, wszItem, MAX_PATH);
            ListView_GetItemText(hwndList, i, 1, wszRedirect, 32);

            //
            // Need to add the new item.
            //
            lvi.mask      = LVIF_TEXT;
            lvi.lParam    = 0;
            lvi.pszText   = wszItem;
            lvi.iItem     = iIndex++;
            lvi.iSubItem  = 0;

            index = ListView_InsertItem(hwndList, &lvi);

            ListView_SetItemText(hwndList, index, 1, wszRedirect);
        }
    }
}

void 
LuapTokenizeItems(
    HWND hwndList,
    BOOL bUntokenize
    )
{
    int cItems = ListView_GetItemCount(hwndList);
    WCHAR wszItem[MAX_PATH] = L"";
    WCHAR wszExpandItem[MAX_PATH] = L"";
    LPWSTR pwszUntokenizedItem = NULL;
    LVITEM lvi;
    int index;
    PLIST_ENTRY pEntry;
    PUNTOKENIZED_ITEM pItem;

    if (bUntokenize) {
        InitializeListHead(&g_UntokenizedList);
    } else {
        pEntry = g_UntokenizedList.Flink;
    }

    for (int i = 0 ; i < cItems; ++i) {

        ListView_GetItemText(hwndList, i, 0, wszItem, MAX_PATH);
            
        if (bUntokenize) {
            
            pItem = new UNTOKENIZED_ITEM;

            if (pItem == NULL) {
                MEM_ERR;
                return;
            }

            pItem->strName = wszItem;
            InsertTailList(&g_UntokenizedList, &pItem->entry);

            if (ExpandEnvironmentStrings(wszItem, wszExpandItem, MAX_PATH)) {
                pwszUntokenizedItem = wszExpandItem;
            } else {
                pwszUntokenizedItem = wszItem;
            }

            ListView_SetItemText(hwndList, i, 0, pwszUntokenizedItem);

        } else {
            
            pItem = CONTAINING_RECORD(pEntry, UNTOKENIZED_ITEM, entry);

            ListView_SetItemText(hwndList, i, 0, pItem->strName);

            pEntry = pEntry->Flink;
        }
    }

    if (!bUntokenize) {
        LuapDeleteList(&g_UntokenizedList);
    }
}

BOOL
LuapSaveFileLists(
    HWND hwndList
    )
{
    g_bListsInitialized = FALSE;

    BOOL            bIsSuccess = FALSE;
    int             nItems = ListView_GetItemCount(hwndList);
    int             i, j;
    WCHAR           wszItem[MAX_PATH + 3] = L""; 
    WCHAR           wszRedirect[MAX_PATH] = L"";
    BOOL            bChecked, bRedirectAllUser;
    PLIST_ENTRY     pHead = (g_bUseNewStaticList ? &g_NewStaticList : &g_OldStaticList);
    PLIST_ENTRY     pEntry = pHead->Flink;
    PREDIRECT_ITEM  pItem;

    //
    // For all the checked items we check if there are any duplicates.
    // Note that we don't allow duplicate items even if they are specified
    // to redirect to the same directory - because the position of the checked
    // items does matter (a checked item above another takes precedence over 
    // that other one when redirected).
    //
    LPWSTR*         ppTempCheckedItems = NULL;
    DWORD           dwTempIndex = 0;

    g_LuaData.strStaticList.Release();
    g_LuaData.strDynamicList.Release();
    g_bAllUserDirUsed = FALSE;

    ppTempCheckedItems = new LPWSTR [nItems];

    if (!ppTempCheckedItems) {
        MEM_ERR;
        goto EXIT;
    }

    for (i = 0; i < nItems; ++i) {
        
        ListView_GetItemText(hwndList, i, 1, wszRedirect, MAX_PATH);

        bRedirectAllUser = !wcscmp(wszRedirect, GetString(IDS_LUA_RDIR_ALLUSER));
        wszItem[0] = (bRedirectAllUser ? L'A' : L'P');

        bChecked = ListView_GetCheckState(hwndList, i);
        wszItem[1] = (bChecked ? L'C' : L'U');

        wszItem[2] = L'-';
        wszItem[3] = L'\0';

        if (bRedirectAllUser && bChecked) {
            g_bAllUserDirUsed = TRUE;
        }

        if (bChecked) {
            
            ppTempCheckedItems[dwTempIndex] = new WCHAR [MAX_PATH];

            if (!ppTempCheckedItems[dwTempIndex]) {
                MEM_ERR;
                goto EXIT;
            }

            ++dwTempIndex;
        }

        if (i < g_nStaticItems) {

            pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);
            g_LuaData.strStaticList.Strcat(wszItem);
            g_LuaData.strStaticList.Strcat(pItem->strName);
            g_LuaData.strStaticList.Strcat(L";");

            if (bChecked) {
                StringCchCopy(
                    ppTempCheckedItems[dwTempIndex - 1], 
                    MAX_PATH, 
                    pItem->strName);
            }

            pEntry = pEntry->Flink;

        } else {

            ListView_GetItemText(hwndList, i, 0, wszItem + 3, MAX_PATH);

            if (bChecked) {

                for (j = 0; j < dwTempIndex - 1; ++j) {

                    if (!_wcsicmp(ppTempCheckedItems[j], wszItem + 3)) {

                        CSTRING strMessage;
                        strMessage.Sprintf(
                            L"%s was already in the list. Please remove one.",
                            wszItem + 3);

                        MessageBox(
                            NULL,
                            strMessage,
                            g_pEntryLua->strAppName,
                            MB_ICONERROR);

                        goto EXIT;
                    }
                }

                StringCchCopy(
                    ppTempCheckedItems[dwTempIndex - 1], 
                    MAX_PATH, 
                    wszItem + 3);
            }

            StringCchCat(wszItem, ARRAYSIZE(wszItem), L";");
            g_LuaData.strDynamicList.Strcat(wszItem);
        }
    }

    int cLen = g_LuaData.strStaticList.Length();
    g_LuaData.strStaticList.SetChar(cLen - 1, L'\0');
    cLen = g_LuaData.strDynamicList.Length();
    g_LuaData.strDynamicList.SetChar(cLen - 1, L'\0');

    bIsSuccess = TRUE;

EXIT:

    for (i = 0; i < dwTempIndex; ++i) {
        delete [] ppTempCheckedItems[i];
    }

    if (ppTempCheckedItems) {
        delete [] ppTempCheckedItems;
    }

    if (bIsSuccess) {

        //
        // We want to keep the lists in case of failure because we
        // can come back and try again.
        //
        LuapDeleteList(&g_OldStaticList);
        LuapDeleteList(&g_NewStaticList);
        LuapDeleteList(&g_DynamicList);
        g_bUseNewStaticList = FALSE;
    }

    return bIsSuccess;
}

void
LuapEditCell(
    HWND hwndList,
    int iItem, 
    int iSubItem
    )
{
    //
    // If the user holds down shift or control while clicking,
    // it means he wants to select multiple rows. We'll let 
    // the listview handle it.
    //
    SHORT sStateShift = GetAsyncKeyState(VK_SHIFT);
    SHORT sStateControl = GetAsyncKeyState(VK_CONTROL);
    if (sStateShift & (1 << 15) || 
        sStateControl & (1 << 15)) {
        return;
    }

    if (iSubItem) {

        //
        // Before we display the combobox, we need to 
        // de-select all items in the listview.
        //
        int index = -1;
        while ((index = ListView_GetNextItem(hwndList, index, LVIS_SELECTED)) != -1) {

            ListView_SetItemState(hwndList, index, 0, LVIS_SELECTED);
        }

        RECT rect, rectListView, rectParent;
        WCHAR szText[MAX_PATH];
        HWND hwnd = GetParent(hwndList);

        GetWindowRect(hwndList, &rectListView);
        GetWindowRect(hwnd, &rectParent);

        g_iCurrentEditItem = iItem;

        SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);

        LVITEM lvi;
        lvi.mask = LVIF_TEXT;
        lvi.lParam = 0;
        lvi.pszText = szText;
        lvi.cchTextMax = MAX_PATH;
        lvi.iItem = iItem;
        lvi.iSubItem  = iSubItem;

        ListView_GetSubItemRect(hwndList, iItem, iSubItem, LVIR_LABEL, &rect);
        ListView_GetItem(hwndList, &lvi);

        //
        // Move the combobox to cover this item.
        //
        HWND hwndCombo = GetDlgItem(hwnd, IDC_LUA_RDIR);
        MoveWindow(hwndCombo, 
            rect.left + rectListView.left - rectParent.left + 2, 
            rect.top + rectListView.top - rectParent.top + 1, 
            rect.right - rect.left, 
            rect.bottom - rect.top - 7, TRUE);

        SetFocus(hwndCombo);
        ShowWindow(hwndCombo, SW_SHOW);
        ListView_SetItemState(hwndList, iItem, LVIS_FOCUSED, LVIS_FOCUSED);

        int nID = (wcscmp(lvi.pszText, GetString(IDS_LUA_RDIR_PERUSER)) ? 0 : 1);
        SendMessage(hwndCombo, CB_SETCURSEL, (WPARAM)nID, 0);
        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
    }
}

BOOL
LuapSetAppEnvVars(
    HWND hDlg)
{
    BOOL bIsSuccess = TRUE;
    CSTRING strFullPath;
    LPWSTR pwsz = NULL;

    if (g_bHasAppPathSet) {
        goto EXIT;
    }

    strFullPath = g_pEntryLua->strFullpath;
    pwsz = strFullPath;

    if (g_pEntryLua->strFullpath.isNULL()) {
        goto EXIT;
    }

    bIsSuccess = FALSE;

    LPWSTR pwszLastSlash = wcsrchr(pwsz, L'\\');

    if (pwszLastSlash == NULL) {

        MessageBox(hDlg, 
            L"The full path doesn't contain a '\\'?",
            g_pEntryLua->strAppName,
            MB_ICONERROR);
        goto EXIT;
    }

    *pwszLastSlash = L'\0';

    g_cAppPath = wcslen(pwsz);

    if (g_cAppPath >= ARRAYSIZE(g_wszAppPath)) {
        MessageBox(hDlg, 
            L"Exe path too long - we don't handle it",
            g_pEntryLua->strAppName,
            MB_ICONERROR);

        g_cAppPath = 0;

        goto EXIT;
    }

    wcsncpy(g_wszAppPath, pwsz, g_cAppPath);

    g_wszAppPath[g_cAppPath] = L'\0';

    LPWSTR pwsz1stComp = wcschr(g_wszAppPath, L'\\');
    if (pwsz1stComp) {
        if (pwsz1stComp = wcschr(pwsz1stComp + 1, L'\\')) {
            g_cAppPath1stComp = pwsz1stComp - g_wszAppPath + 1;
        }
    }

    SetEnvironmentVariable(L"APPPATH", pwsz);

    *(pwsz + 2) = L'\0';
    SetEnvironmentVariable(L"APPDRIVE", pwsz);

    g_bHasAppPathSet = TRUE;
    
    bIsSuccess = TRUE;

EXIT:

    return bIsSuccess;
}

INT_PTR
CALLBACK
LuapAction(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    LPARAM buttons;

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            HWND hwndParent = GetParent(hDlg);
            
            CenterWindow(GetParent(hwndParent), hwndParent);
            SetWindowText(hwndParent, GetString(IDS_LUA_WIZARD_TITLE));
            
            //
            // Fill in the executable name.
            //
            SetDlgItemText(hDlg, IDC_LUA_EXE, g_pEntryLua->strExeName);
            ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_MODIFY_DATA), (g_TrackState == LUA_TRACK_YES));
            CheckDlgButton(hDlg,
                           (g_TrackState == LUA_TRACK_YES ? IDC_LUA_MODIFY_DATA : IDC_LUA_RUN_PROGRAM),
                           BST_CHECKED);

            //
            // Set the appropriate description
            //
            SetDlgItemText(hDlg, IDC_DESCRIPTION,
                           (g_TrackState == LUA_TRACK_NO ?
                                GetString(IDS_LUA_DESC_NODATA) :
                                GetString(IDS_LUA_DESC_DATA)));

            buttons = 0;
            SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);
        }

        break;

    case WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch (pHdr->code) {
            case PSN_SETACTIVE:
                {
                    buttons = PSWIZB_NEXT;
                    SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);
                    ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_MODIFY_DATA), (g_TrackState == LUA_TRACK_YES));
                    
                    if (g_TrackState == LUA_TRACK_YES &&
                        IsDlgButtonChecked(hDlg, IDC_LUA_RUN_PROGRAM)) {
                        ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_OVERRIDE), TRUE);
                    } else {
                        ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_OVERRIDE), FALSE);
                    }
                }

                break;

            case PSN_WIZNEXT:
                {
                    BOOL bIsSuccess     = FALSE;
                    g_bUseNewStaticList = TRUE;

                    if (IsDlgButtonChecked(hDlg, IDC_LUA_RUN_PROGRAM) == BST_CHECKED) {

                        buttons = PSWIZB_NEXT;
                        SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);

                        BOOL bMergeOld = (g_TrackState == LUA_TRACK_YES &&
                            IsDlgButtonChecked(hDlg, IDC_LUA_OVERRIDE) == BST_UNCHECKED);
                        
                        //
                        // Apply the LUATrackFS shim to the executable.
                        //
                        CSTRING strExeName = (g_pEntryLua->strFullpath.isNULL() ? 
                                              g_pEntryLua->strExeName :
                                              g_pEntryLua->strFullpath);
                        CSTRINGLIST strlXML;

                        if (LuapGenerateTrackXML(g_pEntryLua, &strlXML)) {

                            if (TestRun(g_pEntryLua, &strExeName, NULL, hDlg, &strlXML)) {

                                //
                                // Set the new enviorment variables APPPATH and APPDRIVE.
                                //
                                if (g_pEntryLua->strFullpath.isNULL()) {
                                    g_pEntryLua->strFullpath = strExeName;
                                }

                                if (!LuapSetAppEnvVars(hDlg)) {
                                    goto RETURN;
                                }

                                //
                                // There should be a file generated by the LUATrackFS shim in AppPatch.
                                // We will merge this with the original data.
                                //
                                if (LuapMergeLists(bMergeOld, hDlg)) {
                                    g_TrackState = LUA_TRACK_YES;
                                    bIsSuccess = TRUE;
                                } else {
                                    MessageBox(hDlg, 
                                        GetString(IDS_LUA_MERGE_LIST),
                                        g_pEntryLua->strAppName,
                                        MB_ICONERROR);
                                }
                            }
                        } else {

                            MessageBox(hDlg, 
                                GetString(IDS_LUA_TRACKXML),
                                g_pEntryLua->strAppName,
                                MB_ICONERROR);
                        }

                    } else {

                        //
                        // Initialize the old static and the dynamic list.
                        //
                        if (LuapInitializeOldLists(hDlg)) {
                            g_bUseNewStaticList = FALSE;
                            bIsSuccess = TRUE;
                        }
                    }

                    RETURN:

                    //
                    // Prevent from going to the next page if any error occured.
                    //
                    if (!bIsSuccess) {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    }
                }

                break;
            }
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_LUA_RUN_PROGRAM:
        case IDC_LUA_MODIFY_DATA:
            if (IsDlgButtonChecked(hDlg, IDC_LUA_RUN_PROGRAM) == BST_CHECKED) {
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_OVERRIDE), (g_TrackState == LUA_TRACK_YES));
            }

            if (IsDlgButtonChecked(hDlg, IDC_LUA_MODIFY_DATA) == BST_CHECKED) {
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_OVERRIDE), FALSE);
            }

            buttons = PSWIZB_NEXT;
            SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);

            break;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

void
LuapAddItemToListView(
    HWND hwndList,
    PLIST_ENTRY pEntry,
    int i
    )
{
    PREDIRECT_ITEM pItem = CONTAINING_RECORD(pEntry, REDIRECT_ITEM, entry);

    LVITEM        lvi;
    int           index;
    lvi.mask      = LVIF_TEXT;
    lvi.lParam    = 0;
    lvi.pszText   = pItem->strName;
    lvi.iItem     = i;
    lvi.iSubItem  = 0;

    index = ListView_InsertItem(hwndList, &lvi);

    ListView_SetItemText(
        hwndList, 
        index, 
        1, 
        pItem->bRedirectToAllUser ?
        GetString(IDS_LUA_RDIR_ALLUSER) :
        GetString(IDS_LUA_RDIR_PERUSER));

    ListView_SetCheckState(hwndList, index, pItem->bChecked);
}

void
LuapDeleteSelectedItems(
    HWND hwndList
    )
{
    int index = -1;

    while ((index = ListView_GetNextItem(hwndList, g_nStaticItems - 1, LVNI_SELECTED)) != -1) {
        ListView_DeleteItem(hwndList, index);
    }
}

inline void
LuapGetRGB(
    COLORREF cr,
    BYTE* pR,
    BYTE* pG,
    BYTE* pB
    )
{
    *pR = GetRValue(cr);
    *pG = GetGValue(cr);
    *pB = GetBValue(cr);
}

inline void 
LuapSwapColor(
    BYTE* pFont,
    BYTE* pBk
    )
{
    BYTE temp;

    if (*pFont > *pBk) {
        temp = *pFont;
        *pFont = *pBk;
        *pBk = temp;
    }
}

// font is garanteed to be less than bk.
inline BYTE
LuapGetHalfColor(
    BYTE font,
    BYTE bk
    )
{
    return (font + (bk - font) / 2);
}

COLORREF
LuapGetHalfIntensity(
    COLORREF crFont, 
    COLORREF crBk
    )
{
    BYTE rFont, gFont, bFont, rBk, gBk, bBk;
    LuapGetRGB(crFont, &rFont, &gFont, &bFont);
    LuapGetRGB(crBk, &rBk, &gBk, &bBk);

    //
    // if the value of the text is greater than that of the Bk, we swap them.
    //
    LuapSwapColor(&rFont, &rBk);
    LuapSwapColor(&gFont, &gBk);
    LuapSwapColor(&bFont, &bBk);

    //
    // The half color is computed as the lower value + half of the difference
    // between the higher and the lower value.
    BYTE rHalf = LuapGetHalfColor(rFont, rBk);
    BYTE gHalf = LuapGetHalfColor(gFont, gBk);
    BYTE bHalf = LuapGetHalfColor(bFont, bBk);
    
    return RGB(rHalf, gHalf, bHalf);
}

typedef enum {
    CM_SELECT,
    CM_DESELECT,
    CM_REDIRECT_ALLUSER,
    CM_REDIRECT_PERUSER,
    CM_REDIRECT_LASTINDEX
} LUA_CM_INDEX;

BOOL
LuapDisplayContextMenu(
    HWND hwndList, 
    POINT* ppt)
{
    int i;

    if (g_hContextMenu == NULL) {
        g_hContextMenu = CreatePopupMenu();

        if (g_hContextMenu == NULL) {
            MessageBox(
                hwndList, 
                GetString(IDS_LUA_ERROR_CM), 
                g_pEntryLua->strAppName, 
                MB_ICONERROR);
            return FALSE;
        }

        CSTRING strItems[CM_REDIRECT_LASTINDEX];

        strItems[CM_SELECT] = GetString(IDS_LUA_CM_SELECT);
        strItems[CM_DESELECT] = GetString(IDS_LUA_CM_DESELECT);
        strItems[CM_REDIRECT_ALLUSER] = GetString(IDS_LUA_CM_REDIRECT_ALLUSER);
        strItems[CM_REDIRECT_PERUSER] = GetString(IDS_LUA_CM_REDIRECT_PERUSER);

        MENUITEMINFO mi = {0};
        mi.cbSize = sizeof(MENUITEMINFO);
        mi.fMask = MIIM_STRING | MIIM_ID;

        for (i = 0; i < CM_REDIRECT_LASTINDEX; ++i) {

            mi.dwTypeData = strItems[i];
            mi.cch = wcslen(mi.dwTypeData);
            mi.wID = i + 1;

            InsertMenuItem(g_hContextMenu, i, TRUE, &mi);
        }
    }

    //
    // Disable the corresponding item in the context menu if all the selected items
    // already have that attribute, eg, if all of them are checked already, "Select"
    // should be disabled.
    //
    BOOL bChecked, bUnchecked, bPerUser, bAllUser;
    bChecked = bUnchecked = bPerUser = bAllUser = TRUE;

    int cItems = ListView_GetItemCount(hwndList);
    WCHAR wszRedirect[32] = L"";

    for (i = 0 ; i < cItems; ++i) {

        if (ListView_GetItemState(hwndList, i, LVIS_SELECTED) == LVIS_SELECTED) {

            if (ListView_GetCheckState(hwndList, i)) {
                bUnchecked = FALSE;
            } else {
                bChecked = FALSE;
            }

            ListView_GetItemText(hwndList, i, 1, wszRedirect, 32);
            if (!wcscmp(wszRedirect, GetString(IDS_LUA_RDIR_ALLUSER))) {
                bPerUser = FALSE;
            } else {
                bAllUser = FALSE;
            }
        }
    }
    
    if (bChecked) {
        EnableMenuItem(g_hContextMenu, CM_SELECT, MF_BYPOSITION | MF_GRAYED);
    }
    
    if (bUnchecked) {
        EnableMenuItem(g_hContextMenu, CM_DESELECT, MF_BYPOSITION | MF_GRAYED);
    }

    if (bAllUser) {
        EnableMenuItem(g_hContextMenu, CM_REDIRECT_ALLUSER, MF_BYPOSITION | MF_GRAYED);
    }

    if (bPerUser) {
        EnableMenuItem(g_hContextMenu, CM_REDIRECT_PERUSER, MF_BYPOSITION | MF_GRAYED);
    }

    UINT nIDSelected = TrackPopupMenuEx(g_hContextMenu, 
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RETURNCMD, 
                   ppt->x, 
                   ppt->y,  
                   hwndList,
                   NULL);

    int iCheck, iRedirectAllUser;
    iCheck = iRedirectAllUser = -1;

    iCheck = (nIDSelected == CM_SELECT + 1 ? 1 : 
                nIDSelected == CM_DESELECT + 1 ? 0 : -1);

    iRedirectAllUser = (nIDSelected == CM_REDIRECT_ALLUSER + 1 ? 1 : 
                        nIDSelected == CM_REDIRECT_PERUSER + 1 ? 0 : -1);

    for (i = 0 ; i < cItems; ++i) {

        if (ListView_GetItemState(hwndList, i, LVIS_SELECTED) == LVIS_SELECTED) {

            if (iCheck != -1) {
                if (ListView_GetCheckState(hwndList, i) != (BOOL)iCheck) {
                    ListView_SetCheckState(hwndList, i, (BOOL)iCheck);
                }
            }

            if (iRedirectAllUser != -1) {
                ListView_GetItemText(hwndList, i, 1, wszRedirect, 32);
                if (!wcscmp(wszRedirect, GetString(IDS_LUA_RDIR_ALLUSER)) != 
                    (BOOL)iRedirectAllUser) {

                    ListView_SetItemText(
                        hwndList, 
                        i, 
                        1, 
                        GetString((BOOL)iRedirectAllUser ? 
                            IDS_LUA_RDIR_ALLUSER : 
                            IDS_LUA_RDIR_PERUSER));
                }
            }
        }
    }

    //
    // Restore the state of menu items.
    //
    for (i = 0; i < CM_REDIRECT_LASTINDEX; ++i) {
        EnableMenuItem(g_hContextMenu, i, MF_BYPOSITION | MF_ENABLED);
    }

    return TRUE;
}

//
// dwRefData stores the index of the item that this edit control covers.
//
LRESULT CALLBACK 
ListViewEditControlSubclass(HWND hwndEdit, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    if (uMsg == WM_SIZE) {
         
        DefSubclassProc(hwndEdit, uMsg, wParam, lParam);

        HWND hwndList = GetParent(hwndEdit);

        RECT rect;
        ListView_GetItemRect(hwndList, dwRefData, &rect, LVIR_LABEL);

        MoveWindow(
            hwndEdit, 
            rect.left,
            rect.top,
            rect.right - rect.left, 
            rect.bottom - rect.top, TRUE);

        return TRUE;
    }
 
    return DefSubclassProc(hwndEdit, uMsg, wParam, lParam);
}

LRESULT CALLBACK 
ListViewSubclass(HWND hwndList, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    if (uMsg == WM_LBUTTONDOWN) {
 
        LVHITTESTINFO lvhti;
 
        GetCursorPos(&lvhti.pt);
        ScreenToClient(hwndList, &lvhti.pt);

        if (ListView_SubItemHitTest(hwndList, &lvhti) != -1 && lvhti.iSubItem != 0) {
 
            ListView_SetItemState(hwndList, lvhti.iItem, 0, LVIS_SELECTED);
            ListView_SetItemState(hwndList, lvhti.iItem, 0, LVIS_FOCUSED);
 
            LuapEditCell(hwndList, lvhti.iItem, lvhti.iSubItem);

            return TRUE;
        }
    } else if (uMsg == WM_VSCROLL) {
        if (wParam == SB_PAGEUP || wParam == SB_PAGEDOWN || wParam == SB_LINEUP || wParam == SB_LINEDOWN) {
            DefSubclassProc(hwndList, uMsg, wParam, lParam);
            InvalidateRect(hwndList, NULL, FALSE);
            return TRUE;
        }
    }
 
    return DefSubclassProc(hwndList, uMsg, wParam, lParam);
}

BOOL
LuapIsItemDuplicate(
    HWND hwndList,
    LPCWSTR pszText,
    int iItem
    )
{
    int cItems = ListView_GetItemCount(hwndList);
    WCHAR wszItem[MAX_PATH] = L"";
    LVITEM lvi;

    for (int i = 0 ; i < cItems; ++i) {

        if (i != iItem) {
            ListView_GetItemText(hwndList, i, 0, wszItem, MAX_PATH);

            if (!_wcsicmp(wszItem, pszText)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

/*++

Desc:

    Rules of moving an item up or down:

    1) We don't allow moving multiple items. 
    
    2) If there's no items selected, this function simply does nothing.

    3) We don't change the static item list so you can't move a dynamic
       item to inbetween 2 static ones.

--*/
void
LuapMoveListViewItem(
    HWND hwndList, 
    int wCode
    )
{
    UINT cSelectedItems = ListView_GetSelectedCount(hwndList);

    if (cSelectedItems > 1) {
        MessageBox(
            hwndList,
            GetString(IDS_LUA_TOO_MANY_SELECTED),
            g_pEntryLua->strAppName,
            MB_ICONERROR);

        return;
    }

    int iSelectedIndex = ListView_GetNextItem(
        hwndList,
        -1,
        LVIS_SELECTED);

    int cItems = ListView_GetItemCount(hwndList);

    if (iSelectedIndex >= g_nStaticItems) {
        if ((wCode == IDC_LUA_UP && iSelectedIndex == g_nStaticItems) ||
            (wCode == IDC_LUA_DOWN && iSelectedIndex == (cItems - 1))) {

            //
            // Can't move the first item up or the last item down.
            //
            return;
        }

        int iNewIndex = 
            (wCode == IDC_LUA_UP ? 
            (iSelectedIndex - 1) : 
            (iSelectedIndex + 1));

        BOOL bChecked = ListView_GetCheckState(hwndList, iSelectedIndex);

        WCHAR wszText[MAX_PATH];
        WCHAR wszRedirect[32];
        
        ListView_GetItemText(hwndList, iSelectedIndex, 0, wszText, MAX_PATH);
        ListView_GetItemText(hwndList, iSelectedIndex, 1, wszRedirect, 32);
        ListView_DeleteItem(hwndList, iSelectedIndex);

        LVITEM lvi;

        lvi.mask      = LVIF_TEXT;
        lvi.lParam    = 0;
        lvi.pszText   = wszText;
        lvi.iItem     = iNewIndex;
        lvi.iSubItem  = 0;

        ListView_InsertItem(hwndList, &lvi);
        ListView_SetItemText(hwndList, iNewIndex, 1, wszRedirect);
        ListView_SetCheckState(hwndList, iNewIndex, bChecked);

        SetFocus(hwndList);
        ListView_SetItemState(hwndList, iNewIndex, LVIS_SELECTED, LVIS_SELECTED);
    }
}

INT_PTR
CALLBACK
LuapEditFileList(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            ShowWindow(GetDlgItem(hDlg, IDC_LUA_FILE_EDIT), SW_HIDE);

            HWND hwndCombo = GetDlgItem(hDlg, IDC_LUA_RDIR);
            SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_LUA_RDIR_PERUSER));
            SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_LUA_RDIR_ALLUSER));
            ShowWindow(hwndCombo, SW_HIDE);

            ShowWindow(GetDlgItem(hDlg, IDC_LUA_EDIT_BROWSE), SW_HIDE);

            HWND hwndUpButton = GetDlgItem(hDlg, IDC_LUA_UP);
            HWND hwndDownButton = GetDlgItem(hDlg, IDC_LUA_DOWN);

            SendMessage(hwndUpButton, WM_SETFONT, (WPARAM)g_hArrowFont, TRUE);
            SendMessage(hwndDownButton, WM_SETFONT, (WPARAM)g_hArrowFont, TRUE);

            SetWindowText(hwndUpButton, TEXT("\xE1"));
            SetWindowText(hwndDownButton, TEXT("\xE2"));

            HWND hwndList = GetDlgItem(hDlg, IDC_LUA_FILE_LIST); 
            SetWindowSubclass(hwndList, ListViewSubclass, 0, 0);

            ListView_SetExtendedListViewStyleEx(
                hwndList,
                0,
                LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | LVS_EX_GRIDLINES); 

            InsertColumnIntoListView(hwndList, CSTRING(IDS_LUA_FILEDIR_NAME), 0, 80);
            InsertColumnIntoListView(hwndList, CSTRING(IDS_LUA_REDIRECT), 1, 20);

            //
            // Set the column width of the last column of the list view appropriately
            // to cover the width of the list view
            // Assumption: The list veiw has two columns
            //
            ListView_SetColumnWidth(hwndList, 
                                    1, 
                                    LVSCW_AUTOSIZE_USEHEADER);
        }

        break;

    case WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch (pHdr->code) {
            case PSN_SETACTIVE:
                {
                    if (!LuapSetAppEnvVars(hDlg)) {
                        //
                        // Prevent from going to the next page if any error occured.
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_UNTOK), g_bHasAppPathSet);
                    LPARAM buttons = PSWIZB_BACK | PSWIZB_NEXT;
                    SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);

                    HWND hwndList = GetDlgItem(hDlg, IDC_LUA_FILE_LIST); 
                    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);

                    //
                    // First delete all items
                    //
                    int i;
                    int cItems = ListView_GetItemCount(hwndList);

                    for (i = 0; i < cItems; ++i) {
                        ListView_DeleteItem(hwndList, 0);
                    }

                    //
                    // If the lists are not there, it means we are back from the
                    // Exclusion or the Common Path page, regenerate the lists.
                    //
                    if (!g_bListsInitialized) {
                        LuapInitializeOldLists(hDlg);
                    }

                    //
                    //
                    // Populate the static items.
                    //        
                    i = 0;
                    PLIST_ENTRY pHead = (g_bUseNewStaticList ? 
                                         &g_NewStaticList : 
                                         &g_OldStaticList);
                    
                    for (PLIST_ENTRY pEntry = pHead->Flink; 
                         pEntry != pHead; 
                         pEntry = pEntry->Flink) {
                        
                        LuapAddItemToListView(hwndList, pEntry, i);
                        ++i;
                    }
                
                    g_nStaticItems = i;

                    //
                    // Populate the dynamic items.
                    //
                    pHead = &g_DynamicList;
                    
                    for (PLIST_ENTRY pEntry = pHead->Flink; 
                         pEntry != pHead; 
                         pEntry = pEntry->Flink) {
                        
                        LuapAddItemToListView(hwndList, pEntry, i);
                        ++i;
                    }

                    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

                    g_TrackState = LUA_TRACK_YES;
                }

                break;

            case PSN_WIZNEXT:
            case PSN_WIZBACK:
                {
                    //
                    // Save the static and the dynamic lists.
                    //
                    if (!LuapSaveFileLists(GetDlgItem(hDlg, IDC_LUA_FILE_LIST))) {
                        //
                        // Prevent from going to the next page if any error occured.
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    }
                }

                break;

            case PSN_RESET:
                {
                    LuapCleanup();
                }

                break;

            case NM_CLICK:
                {
                    if (g_bDuringUntokenize) {
                        //
                        // When we show the items untokenized, we don't allow the users
                        // to edit anything.
                        //
                        break;
                    }

                    HWND hwndList = GetDlgItem(hDlg, IDC_LUA_FILE_LIST);
                    LVHITTESTINFO lvhti;

                    GetCursorPos(&lvhti.pt);
                    ScreenToClient(hwndList, &lvhti.pt);

                    if (ListView_SubItemHitTest(hwndList, &lvhti) != -1) {
                        //
                        // If the user clicked on a subitem, we need to show the combo box.
                        //
                        LuapEditCell(hwndList, lvhti.iItem, lvhti.iSubItem);

                    } else {
                        //
                        // Check if the user clicked on the row right below the last item,
                        // which means he wants to add a new row.
                        //
                        int iLastItem = ListView_GetItemCount(hwndList);
                        RECT rect;

                        g_bNewListViewItem = FALSE;

                        if (iLastItem == 0) {
                            g_bNewListViewItem = TRUE;
                        } else {
                            ListView_GetItemRect(
                                hwndList, 
                                iLastItem - 1, 
                                &rect, 
                                LVIR_LABEL);
                            
                            LONG x = lvhti.pt.x;
                            LONG y = lvhti.pt.y;
                            LONG height = rect.bottom - rect.top;

                            if (x > rect.left && 
                                x < rect.right && 
                                y > rect.bottom &&
                                y < (rect.bottom + height)) {

                                g_bNewListViewItem = TRUE;
                            } 
                        }

                        if (g_bNewListViewItem) {

                            LVITEM lvi;
                            int index;

                            lvi.mask      = LVIF_TEXT;
                            lvi.lParam    = 0;
                            lvi.pszText   = L"";
                            lvi.iItem     = iLastItem;
                            lvi.iSubItem  = 0;

                            index = ListView_InsertItem(hwndList, &lvi);

                            ListView_SetItemText(
                                hwndList, 
                                index, 
                                1, 
                                GetString(IDS_LUA_RDIR_PERUSER));

                            SetFocus(hwndList);
                            ListView_EditLabel(hwndList, index);

                            g_iCurrentEditItem = iLastItem;
                        }
                    }
                }

                break;

            case NM_RCLICK:
                {
                    HWND hwndList = GetDlgItem(hDlg, IDC_LUA_FILE_LIST);
                    LVHITTESTINFO lvhti;

                    GetCursorPos(&lvhti.pt);

                    //
                    // Display a context menu for the user to (de)select the items
                    // and change the selection of the redirect dir.
                    //
                    LuapDisplayContextMenu(hwndList, &lvhti.pt);
                }

                break;

            case LVN_ITEMCHANGED:
                {
                    //
                    // If nothing is selected, the up/down and copy buttons will
                    // be disabled.
                    //
                    int index = -1;
                    BOOL bNoneSelected = TRUE;
                    HWND hwndList = GetDlgItem(hDlg, IDC_LUA_FILE_LIST);
                    while ((index = ListView_GetNextItem(hwndList, index, LVIS_SELECTED)) != -1) {

                        bNoneSelected = FALSE;
                        break;
                    }

                    ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_UP), !bNoneSelected && !g_bDuringUntokenize);
                    ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_DOWN), !bNoneSelected && !g_bDuringUntokenize);
                    ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_COPY), !bNoneSelected && !g_bDuringUntokenize);
                }

                break;

            case LVN_BEGINSCROLL:
                {
                    //
                    // When the scrolling begins, we need to hide the combobox.
                    //
                    ShowWindow(GetDlgItem(hDlg, IDC_LUA_RDIR), SW_HIDE);
                    SetFocus(GetDlgItem(hDlg, IDC_LUA_FILE_LIST));
                }

                break;

            case LVN_KEYDOWN:
                {
                    NMLVKEYDOWN* pnkd = (NMLVKEYDOWN*)lParam;

                    if (pnkd->wVKey == VK_DELETE) {
                        
                        //
                        // Delete all the selected items.
                        //
                        LuapDeleteSelectedItems(GetDlgItem(hDlg, IDC_LUA_FILE_LIST));
                    }
                }

                break;

            case LVN_BEGINLABELEDIT:
                {
                    NMLVDISPINFO FAR *pdi =  (NMLVDISPINFO FAR *) lParam;
                    LVITEM lvi = pdi->item;
                    BOOL bRet = (lvi.iItem < g_nStaticItems || g_bDuringUntokenize);

                    HWND hwndList = pdi->hdr.hwndFrom;
                    HWND hwndListViewEdit = ListView_GetEditControl(hwndList);
        
                    SendMessage(
                        hwndListViewEdit, 
                        EM_LIMITTEXT, 
                        (WPARAM)(MAX_PATH - 1), 
                        (LPARAM)0);

                    SetWindowSubclass(hwndListViewEdit, ListViewEditControlSubclass, 0, lvi.iItem);

                    SHAutoComplete(hwndListViewEdit, AUTOCOMPLETE);

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)bRet);
                    return bRet;
                }

            case LVN_ENDLABELEDIT:
                {
                    NMLVDISPINFO FAR *pdi =  (NMLVDISPINFO FAR *) lParam;
                    LVITEM lvi = pdi->item;
                    BOOL bRet = FALSE;

                    if (lvi.iItem >= g_nStaticItems) {
            
                        int iLastItem = ListView_GetItemCount(pdi->hdr.hwndFrom) - 1;

                        if (g_bNewListViewItem && lvi.iItem == iLastItem && 
                            (lvi.pszText == NULL || lvi.pszText[0] == L'\0')) {
                            //
                            // if we are adding a new row, we delete it whether 
                            // the user cancelled or typed in something then deleted
                            // it.
                            //
                            ListView_DeleteItem(pdi->hdr.hwndFrom, iLastItem);
    
                            g_bNewListViewItem = FALSE;
                            return bRet;
                        }

                        if (lvi.pszText && lvi.pszText[0] == L'\0') {
                            ListView_DeleteItem(pdi->hdr.hwndFrom, lvi.iItem);
                        } else {

                            CSTRING strCurrentItem = lvi.pszText;

                            if (lvi.pszText == NULL) {

                                if (!g_bNewListViewItem) {
                                    //
                                    // If the user cancelled editing, we should still check if it's a duplicated
                                    // in case the user was editing a copied item.
                                    //
                                    WCHAR wszItem[MAX_PATH];
                                    ListView_GetItemText(
                                        pdi->hdr.hwndFrom, 
                                        lvi.iItem, 
                                        0, 
                                        wszItem, 
                                        MAX_PATH);

                                    strCurrentItem = wszItem;
                                }
                            
                            } else {

                                if (g_bHasAppPathSet) {

                                    //
                                    // Tokenize it.
                                    // 
                                    LPWSTR pwszItem = lvi.pszText;

                                    if (!_wcsnicmp(pwszItem, g_wszAppPath, 2)) {

                                        if (!LuapSubstituteProgramFilesCommon(pwszItem, strCurrentItem)) {

                                            if (!LuapGetRelativeName(pwszItem, strCurrentItem)) {
                                                strCurrentItem = L"%APPDRIVE%";
                                                strCurrentItem.Strcat(pwszItem + 2);
                                            }
                                        }
                                    }
                                }
                            }

                            if (strCurrentItem == TEXT("")) {
                                ListView_DeleteItem(pdi->hdr.hwndFrom, lvi.iItem);
                            } else {
                                ListView_SetItemText(pdi->hdr.hwndFrom, lvi.iItem, 0, strCurrentItem);
                            }

                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)FALSE);
                        }
                    }

                    g_iCurrentEditItem = -1;
                    g_bNewListViewItem = FALSE;
                }

                break;

            case NM_CUSTOMDRAW:
                {
                    if (pHdr->hwndFrom == GetDlgItem(hDlg, IDC_LUA_FILE_LIST)) {
                        NMLVCUSTOMDRAW* pcd = (NMLVCUSTOMDRAW*)lParam;

                        switch (pcd->nmcd.dwDrawStage) {
                        case CDDS_PREPAINT:
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)CDRF_NOTIFYITEMDRAW);
                            return CDRF_NOTIFYITEMDRAW;
                            
                        case CDDS_ITEMPREPAINT:
                            {
                                //
                                // If it's a dynamic item we just let the control draw itself.
                                //
                                if (pcd->nmcd.dwItemSpec >= g_nStaticItems) {
                                    return CDRF_DODEFAULT;
                                }

                                //
                                // Use half of the intensity of the default font to draw the static items.
                                //
                                HDC hdc = pcd->nmcd.hdc;

                                COLORREF crFont = GetTextColor(hdc);
                                COLORREF crBk = GetBkColor(hdc);

                                pcd->clrText = LuapGetHalfIntensity(crFont, crBk);
                                
                                return CDRF_NEWFONT;
                            }
                        }
                        
                        return CDRF_DODEFAULT;
                    }

                    break;
                }
            }

            break;
        }

    case WM_COMMAND:
        
        if ((wNotifyCode == CBN_KILLFOCUS || wNotifyCode == CBN_SELCHANGE) && 
            wCode == IDC_LUA_RDIR) {

            HWND hwndCombo = GetDlgItem(hDlg, IDC_LUA_RDIR);
            SendMessage(hwndCombo, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0);
            ShowWindow(hwndCombo, SW_HIDE);

            HWND hwndList = GetDlgItem(hDlg, IDC_LUA_FILE_LIST); 
            WCHAR wszText[MAX_PATH];
            SendMessage(hwndCombo, WM_GETTEXT, MAX_PATH, (LPARAM)wszText);
            ListView_SetItemText(hwndList, g_iCurrentEditItem, 1, wszText);

            g_iCurrentEditItem = -1;
            break;
        }

        if (wCode == IDC_LUA_UP || wCode == IDC_LUA_DOWN) {

            LuapMoveListViewItem(GetDlgItem(hDlg, IDC_LUA_FILE_LIST), wCode);

            break;
        }

        if (wCode == IDC_LUA_COPY) {

            //
            // Copy the selected items to the bottom of the list view.
            //
            g_bNewListViewItem = FALSE;
            LuapCopyItems(GetDlgItem(hDlg, IDC_LUA_FILE_LIST));

            break;
        }

        if (wCode == IDC_LUA_UNTOK) {

            LPARAM buttons;
            HWND hwndList = GetDlgItem(hDlg, IDC_LUA_FILE_LIST);

            // 
            // The "Show Untokenized" is only for convenience purposes so 
            // if the user check this checkbox, we need to disable the NEXT button,
            // and disble editing, and prevent the user from going backward or forward
            // in the wizard.
            // 
            if (IsDlgButtonChecked(hDlg, IDC_LUA_UNTOK) == BST_CHECKED) {
                buttons = 0;
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_COPY), FALSE);
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_UP), FALSE);
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_DOWN), FALSE);
                g_bDuringUntokenize = TRUE;
                LuapTokenizeItems(hwndList, TRUE);

            } else {
                buttons = PSWIZB_BACK | PSWIZB_NEXT;
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_COPY), TRUE);
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_UP), TRUE);
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_LUA_DOWN), TRUE);
                g_bDuringUntokenize = FALSE;
                LuapTokenizeItems(hwndList, FALSE);
            }

            SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);
        }

    default:
        return FALSE;
    }

    return TRUE;
}

LONG
GetDefaultExclusionList()
{
    HKEY hKey;
    LONG lRet;
    
    if ((lRet = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, 
        LUA_APPCOMPAT_FLAGS_PATH,
        0,
        KEY_QUERY_VALUE,
        &hKey)) == ERROR_SUCCESS)
    {
        DWORD dwSize = 0;

        if ((lRet = RegQueryValueEx(
            hKey,
            LUA_DEFAULT_EXCLUSION_LIST,
            NULL,
            NULL,
            NULL,
            &dwSize)) == ERROR_SUCCESS)
        {
            //
            // Prefix problem. I mean prefix is a problem :-)
            //
            try{
                g_pwszDefaultExclusionList = new WCHAR [dwSize];
            } catch(...) {
                g_pwszDefaultExclusionList = NULL;
            }
            

            if (g_pwszDefaultExclusionList)
            {
                if ((lRet = RegQueryValueEx(
                    hKey,
                    LUA_DEFAULT_EXCLUSION_LIST,
                    NULL,
                    NULL,
                    (LPBYTE)g_pwszDefaultExclusionList,
                    &dwSize)) != ERROR_SUCCESS)
                {
                    delete [] g_pwszDefaultExclusionList;
                    g_pwszDefaultExclusionList = NULL;
                }
            }
            else
            {
                MEM_ERR;
                lRet = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        REGCLOSEKEY(hKey);
    }

    return lRet;
}

INT_PTR
CALLBACK
LuapExclusion(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            SendMessage(
                GetDlgItem(hDlg, IDC_LUA_EXTS), 
                EM_LIMITTEXT, 
                (WPARAM)(MAX_STRING_SIZE - 1), 
                (LPARAM)0);
        }

        break;

    case WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch (pHdr->code) {
            case PSN_SETACTIVE:
                {
                    LPARAM buttons = PSWIZB_BACK | PSWIZB_NEXT;
                    SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);
                    LPWSTR pwszExcludedExtensions = L"";
                    
                    if (g_LuaData.strExcludedExtensions.isNULL()) {
                        //
                        // We don't have lua data from the SDB, so display the default 
                        // exclusion list.
                        //
                        if (!g_pwszDefaultExclusionList) {
                            //
                            // Don't need to check the return value - if we can't get
                            // it, just display an empty string.
                            //
                            GetDefaultExclusionList();
                        }
                        
                        if (g_pwszDefaultExclusionList) {
                            pwszExcludedExtensions = g_pwszDefaultExclusionList;
                        }
                    } else {
                        pwszExcludedExtensions = g_LuaData.strExcludedExtensions;
                    }

                    SetDlgItemText(
                        hDlg, 
                        IDC_LUA_EXTS, 
                        pwszExcludedExtensions);
                }

                break;

            case PSN_WIZNEXT:
            case PSN_WIZBACK:
                {
                    TCHAR szExcludedExtensions[MAX_STRING_SIZE];
                    GetDlgItemText(
                        hDlg, 
                        IDC_LUA_EXTS, 
                        szExcludedExtensions, 
                        ARRAYSIZE(szExcludedExtensions));

                    g_LuaData.strExcludedExtensions = szExcludedExtensions;
                }

                break;

            case PSN_RESET:
                {
                    LuapCleanup();
                }

                break;
            }
        }

    default:
        return FALSE;
    }

    return TRUE;
}

void
LuapGetRedirectDirs(
    HWND hDlg
    )
{
    WCHAR wszPath[MAX_PATH];

    g_LuaData.strPerUserDir.Release();
    g_LuaData.strAllUserDir.Release();

    GetDlgItemText(hDlg, IDC_LUA_PERUSER_DIR, wszPath, ARRAYSIZE(wszPath));

    if (wszPath[0] != L'\0') {
        g_LuaData.strPerUserDir = wszPath;
    }

    GetDlgItemText(hDlg, IDC_LUA_ALLUSER_DIR, wszPath, ARRAYSIZE(wszPath));

    if (wszPath[0] != L'\0') {
        g_LuaData.strAllUserDir = wszPath;
    }
}

INT_PTR
CALLBACK
LuapCommonPaths(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);
    LPARAM buttons;

    switch (uMsg) {
    case WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch (pHdr->code) {
            case PSN_SETACTIVE:
                {
                    buttons = PSWIZB_BACK | PSWIZB_FINISH;
                    SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);

                    SetDlgItemText(hDlg, IDC_LUA_PERUSER_DIR, g_LuaData.strPerUserDir);
                    SetDlgItemText(hDlg, IDC_LUA_ALLUSER_DIR, g_LuaData.strAllUserDir);
                }

                break;

            case PSN_WIZFINISH:
                {
                    //
                    // Save everything we have changed.
                    //
                    BOOL bChanged = FALSE;

                    //LuapGetRedirectDirs(hDlg);
                    if (!g_bAllUserDirUsed) {
                        //
                        // If the user didn't want to redirect any files to 
                        // the all user redirect dir, we need to record this.
                        //
                        g_LuaData.strAllUserDir.Release();
                    }

                    PLUADATA pOriginalLuaData = g_psflLua->pLuaData;

                    if (pOriginalLuaData == NULL) {
                        if (!g_LuaData.strAllUserDir.isNULL() ||
                            !g_LuaData.strPerUserDir.isNULL() ||
                            !g_LuaData.strStaticList.isNULL() ||
                            !g_LuaData.strDynamicList.isNULL()) {
                         
                            pOriginalLuaData = new LUADATA;

                            if (!pOriginalLuaData) {
                                MEM_ERR;
                                break;
                            }

                            bChanged = TRUE;
                        }
                    } else {

                        if (!pOriginalLuaData->IsEqual(g_LuaData)) {
                            bChanged = TRUE;
                        }
                    }

                    if (bChanged) {
                        pOriginalLuaData->Copy(g_LuaData);

                        g_psflLua->pLuaData = pOriginalLuaData;
                    }

                    if (s_pDatabase != g_pPresentDataBase) {
                        
                        //
                        // g_pPresentDataBase can change because the query and search
                        // windows can be used to select some entry in some other database.
                        // The TVN_SELCHANGE event changes g_pPresentDataBase
                        // These dialogs are modeless
                        //
                        g_pPresentDataBase = s_pDatabase;
                    }

                    if (!g_pPresentDataBase->bChanged) {

                        g_pPresentDataBase->bChanged = bChanged;
                        SetCaption();
                    }

                    LuapCleanup();
                }

                break;
            }
        }

        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*++
Desc:
    This functions is called when we select the menu item for configuring the LUA for the selectd
    entry.
    
Return:
    TRUE  : if changes made are to be preserved. 
    FALSE : if the changes should not be saved.
--*/
BOOL
LuaBeginWizard(
    HWND        hParent,
    PDBENTRY    pEntry,          // Entry for which we are setting the LUA params
    PDATABASE   pDatabase        // The present database
    )
{
    s_pDatabase = pDatabase;

    if (pEntry == NULL || pDatabase == NULL) {
        assert(FALSE);
        return FALSE;
    }

    //
    // If we haven't gotten the value of %ProgramFiles%\Common Files, get it now. 
    // This is not going to change anyway so we only get it once.
    //
    if (g_wszProgramFilesCommon[0] == L'\0') {
        DWORD cBufferLen = MAX_PATH - COMMON_FILES_LEN;

        if ((g_czProgramFilesCommon = GetEnvironmentVariableW(
            L"ProgramFiles", 
            g_wszProgramFilesCommon, 
            cBufferLen)) &&
            g_czProgramFilesCommon < cBufferLen) {

            wcsncat(g_wszProgramFilesCommon, COMMON_FILES, COMMON_FILES_LEN);
            g_czProgramFilesCommon += COMMON_FILES_LEN;
            g_wszProgramFilesCommon[g_czProgramFilesCommon] = L'\0';

        } else {
            MessageBoxA(
                hParent, 
                "Failed to get the value of %ProgramFiles% or it's too long", 
                "Error",
                MB_ICONERROR);

            g_wszProgramFilesCommon[0] = L'\0';
            g_czProgramFilesCommon = 0;

            return FALSE;
        }
    }

    g_bAllUserDirUsed = FALSE;
    g_bUseNewStaticList = TRUE;
    g_TrackState = LUA_TRACK_UNKNOWN;
    g_psflLua = NULL;
    
    g_pEntryLua = pEntry;

    g_psflLua = IsLUARedirectFSPresent(pEntry);

    if (g_psflLua == NULL) {
        assert(FALSE);
        return FALSE;
    }

    LuapGetDataFromEntry(g_psflLua->pLuaData);

    if (g_TrackState == LUA_TRACK_UNKNOWN) {
        //
        // We shouldn't get here!!!
        //
        MessageBox(
            hParent,
            GetString(IDS_LUA_ERROR_FIND),
            pEntry->strAppName,
            MB_ICONERROR);

        return FALSE;
    }

    if (g_hArrowFont == NULL) {
        g_hArrowFont =  CreateFont(
            14,
            0,
            0,
            0,
            FW_DONTCARE,
            0,
            0,
            0,
            DEFAULT_CHARSET,
            OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS,
            DEFAULT_QUALITY,
            DEFAULT_PITCH,
            TEXT("Wingdings"));

        if (g_hArrowFont == NULL) {
            MessageBox(
                NULL,
                GetString(IDS_LUA_ARROW_FONT),
                g_pEntryLua->strAppName,
                MB_ICONERROR);

            return FALSE;
        }
    }

    PROPSHEETPAGE Pages[NUM_PAGES_LUA] = {0};
    ZeroMemory(Pages, sizeof(Pages));

    //
    // Begin the wizard
    //
    PROPSHEETHEADER Header = {0};

    Header.dwSize = sizeof(PROPSHEETHEADER);
    Header.dwFlags = PSH_WIZARD97 | PSH_HEADER |  PSH_WATERMARK | PSH_PROPSHEETPAGE;
    Header.hwndParent = hParent;
    Header.hInstance = g_hInstance;
    Header.nStartPage = 0;
    Header.ppsp = Pages;
    Header.nPages = NUM_PAGES_LUA;
    Header.pszbmHeader = MAKEINTRESOURCE(IDB_WIZBMP);
    Header.pszbmWatermark = MAKEINTRESOURCE(IDB_TOOL);

    Pages[PAGE_LUA_ACTION].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_LUA_ACTION].dwFlags = PSP_DEFAULT|PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    Pages[PAGE_LUA_ACTION].hInstance = g_hInstance;
    Pages[PAGE_LUA_ACTION].pszTemplate = MAKEINTRESOURCE(IDD_LUA_ACTION);
    Pages[PAGE_LUA_ACTION].pfnDlgProc = LuapAction;
    Pages[PAGE_LUA_ACTION].pszHeaderTitle = MAKEINTRESOURCE(IDS_LUA_TRACK_FILES);
    Pages[PAGE_LUA_ACTION].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_LUA_TRACK_FILES_SUBHEADING);
    
    Pages[PAGE_LUA_EXCLUSION].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_LUA_EXCLUSION].dwFlags = PSP_DEFAULT|PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    Pages[PAGE_LUA_EXCLUSION].hInstance = g_hInstance;
    Pages[PAGE_LUA_EXCLUSION].pszTemplate = MAKEINTRESOURCE(IDD_LUA_EXCLUSION);
    Pages[PAGE_LUA_EXCLUSION].pfnDlgProc = LuapExclusion;
    Pages[PAGE_LUA_EXCLUSION].pszHeaderTitle = MAKEINTRESOURCE(IDS_LUA_EXCLUSION_HEADING);
    Pages[PAGE_LUA_EXCLUSION].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_LUA_EXCLUSION_SUBHEADING);

    Pages[PAGE_LUA_EDIT_FILE_LIST].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_LUA_EDIT_FILE_LIST].dwFlags = PSP_DEFAULT|PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    Pages[PAGE_LUA_EDIT_FILE_LIST].hInstance = g_hInstance;
    Pages[PAGE_LUA_EDIT_FILE_LIST].pszTemplate = MAKEINTRESOURCE(IDD_LUA_TRACKED_FILES);
    Pages[PAGE_LUA_EDIT_FILE_LIST].pfnDlgProc = LuapEditFileList;
    Pages[PAGE_LUA_EDIT_FILE_LIST].pszHeaderTitle = MAKEINTRESOURCE(IDS_LUA_EDIT_FILE_LIST);
    Pages[PAGE_LUA_EDIT_FILE_LIST].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_LUA_EDIT_FILE_LIST_SUBHEADING);
    
    Pages[PAGE_LUA_COMMON_PATHS].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_LUA_COMMON_PATHS].dwFlags = PSP_DEFAULT|PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    Pages[PAGE_LUA_COMMON_PATHS].hInstance = g_hInstance;
    Pages[PAGE_LUA_COMMON_PATHS].pszTemplate = MAKEINTRESOURCE(IDD_LUA_COMMON_PATHS);
    Pages[PAGE_LUA_COMMON_PATHS].pfnDlgProc = LuapCommonPaths;
    Pages[PAGE_LUA_COMMON_PATHS].pszHeaderTitle = MAKEINTRESOURCE(IDS_LUA_COMMON_PATHS_HEADING);
    Pages[PAGE_LUA_COMMON_PATHS].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_LUA_COMMON_PATHS_SUBHEADING);

    if (PropertySheet(&Header) < 0) {
        return FALSE;
    }

    return TRUE;
}

BOOL
GetDBStringData(
    const PDB pdb,
    const TAGID tiFix,
    LPCWSTR pwszName,
    CSTRING& strValue
    )
{
    WCHAR wsz[32];
    DWORD dwDataType, cSize = 0;

    if (SdbQueryDataExTagID(pdb, 
                            tiFix, 
                            pwszName, 
                            &dwDataType, 
                            NULL, 
                            &cSize, 
                            NULL) != ERROR_INSUFFICIENT_BUFFER) {
    
        Dbg(dlWarning,"Cannot get the size for DATA named %S\n", pwszName);
        return FALSE;
    }

    LPWSTR pwszValue = new WCHAR [cSize / sizeof(WCHAR)];

    if (pwszValue == NULL) {
        MEM_ERR;
        return FALSE;
    }

    if (SdbQueryDataExTagID(
        pdb, 
        tiFix, 
        pwszName, 
        &dwDataType, 
        pwszValue, 
        &cSize, 
        NULL) != ERROR_SUCCESS) {

        Dbg(dlWarning,"Cannot read the VALUE of DATA named %S\n", pwszName);
        return FALSE;
    }
 
    strValue = pwszValue;
    delete [] pwszValue;

    return TRUE;
}

/*++
Desc:
    This function gets the pdb and the tagid for the layer or the shim and creates a LUADATA*
    and returns it back.

    This function is invoked when we are reading in the .SDB file.

Return:
    Valid LUADATA* if there is one
    NULL: Otherwise.

--*/
PLUADATA
LuaProcessLUAData(
    const PDB     pdb,
    const TAGID   tiFix
    )
{
    PLUADATA pLuaData = new LUADATA;

    if (pLuaData == NULL) {
        MEM_ERR;
    } else {

        GetDBStringData(pdb, tiFix, LUA_DATA_ALLUSERDIR, pLuaData->strAllUserDir);
        GetDBStringData(pdb, tiFix, LUA_DATA_PERUSERDIR, pLuaData->strPerUserDir);
        GetDBStringData(pdb, tiFix, LUA_DATA_STATICLIST, pLuaData->strStaticList);
        GetDBStringData(pdb, tiFix, LUA_DATA_DYNAMICLIST, pLuaData->strDynamicList);
        GetDBStringData(pdb, tiFix, LUA_DATA_EXCLUDEDEXTENSIONS, pLuaData->strExcludedExtensions);
    }

    return pLuaData;
}

BOOL 
LuapAddDataNode(
    LPCWSTR pwszName,
    CSTRING& strValue,
    CSTRINGLIST& strlXML
    )
{
    CSTRING strSpecialChar;
    TCHAR   szSpace[64];
    INT     iszSpaceSize = 0;

    *szSpace        = 0;
    iszSpaceSize    = ARRAYSIZE(szSpace);

    if (!strValue.isNULL() && strValue.pszString[0] != 0) {

        CSTRING strTemp;

        strTemp.Sprintf(TEXT("%s<DATA NAME=\"%s\" VALUETYPE=\"STRING\""), 
                        GetSpace(szSpace, TAB_SIZE * 4, iszSpaceSize),
                        pwszName);

        if (!strlXML.AddString(strTemp)) {
            return FALSE;
        }

        strSpecialChar = strValue.SpecialCharToXML();
        
        strTemp.Sprintf(TEXT("%sVALUE=\""), GetSpace(szSpace, TAB_SIZE * 5, iszSpaceSize));
        strTemp.Strcat(strValue.SpecialCharToXML().pszString);
        strTemp.Strcat(TEXT("\"/>"));
        
        if (!strlXML.AddString(strTemp)) {
            return FALSE;
        }
    }

    return TRUE;
}

/*++
Desc:
    This function is called when we are about to write out the data to an XML file.

Return:
    TRUE : If valid added has been added to strlXML
    FALSE: Otherwise
--*/
BOOL
LuaGenerateXML(
    PLUADATA pLuaData,
    CSTRINGLIST& strlXML
    )
{
    return (LuapAddDataNode(LUA_DATA_ALLUSERDIR, pLuaData->strAllUserDir, strlXML) &&
            LuapAddDataNode(LUA_DATA_PERUSERDIR, pLuaData->strPerUserDir, strlXML) &&
            LuapAddDataNode(LUA_DATA_STATICLIST, pLuaData->strStaticList, strlXML) &&
            LuapAddDataNode(LUA_DATA_DYNAMICLIST, pLuaData->strDynamicList, strlXML) &&
            LuapAddDataNode(LUA_DATA_EXCLUDEDEXTENSIONS, pLuaData->strExcludedExtensions, strlXML));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\precomp.h ===
#ifndef __COMPATADMIN_PRECOMP_H
#define __COMPATADMIN_PRECOMP_H

#undef NDEBUG

#include <assert.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define CSTRING ACCSTRING

#include <Shlwapi.h>
#include <Shellapi.h>
#include <commctrl.h>
#include <Commdlg.h>
#include <Sddl.h>
#include <Winbase.h>
#include <map>

#include <tchar.h>
#include "CSTRING.H"

#include "resource.h"
#include "compatadmin.h"
#include "CSearch.h"
#include "wizard.h"
#include "customlayer.h"
#include "csearch.h"
#include "CAppHelpWizard.h"
#include "LUA.h"
#include "SQLDriver.h"
#include "CTree.h" 
#include "DbTree.h"

#include "Shlobj.h"
#include "Shlobjp.h"
#include "cderr.h"
#include <commctrl.h>
#include <commdlg.h>

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#include <psapi.h>

#include "uxtheme.h"
#include <process.h>

extern "C" {
#include "shimdb.h"
}

#endif // __COMPATADMIN_PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\dbsupport.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    dbsupport.cpp

Abstract:

    Code for the functions that perform most of the database related tasks
    
Author:

    kinshu created  July 2, 2001
    
Revision History:

--*/

#include "precomp.h"

//////////////////////// Extern variables /////////////////////////////////////

extern BOOL             g_bWin2K;    
extern HINSTANCE        g_hInstance; 
extern HWND             g_hDlg;
extern HWND             g_hwndContentsList;
extern TCHAR            g_szData[1024];
extern CSTRINGLIST      g_strMRU;
extern PDBENTRY         g_pEntrySelApp;
extern HWND             g_hwndEntryTree;
extern UINT             g_uNextDataBaseIndex;
extern BOOL             g_bIsCut; 

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Defines //////////////////////////////////////////////

// Size of a temporary buffer that is used to read in strings from the database
#define MAX_DATA_SIZE       1024

// The size of a buffer that holds the names of shims, layers, patches
#define MAX_NAME MAX_PATH

//
// The guid of the system db. Note that on Win2kSP3, it is not this constant, so we should
// NOT rely  on this.
#define GUID_SYSMAIN_SDB _T("{11111111-1111-1111-1111-111111111111}")

// Guid of  apphelp.sdb. There is no apphelp.sdb in Win2K
#define GUID_APPHELP_SDB _T("{22222222-2222-2222-2222-222222222222}")

// Guid of systest.sdb. This is no longer used
#define GUID_SYSTEST_SDB _T("{33333333-3333-3333-3333-333333333333}")

// Guid of drvmain.sdb
#define GUID_DRVMAIN_SDB _T("{F9AB2228-3312-4A73-B6F9-936D70E112EF}")

// Guid of msimain.sdb
#define GUID_MSI_SDB     _T("{d8ff6d16-6a3a-468a-8b44-01714ddc49ea}")

// Used to check if the entry is disabled
#define APPCOMPAT_DISABLED  0x03

// Key of AppCompat data  in the registry. This will contain the disable status of 
// various entries
#define APPCOMPAT_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags")

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Function Declarations /////////////////////////////////

INT_PTR CALLBACK
DatabaseRenameDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
HandleFirstEntryofAppDeletion(
    PDATABASE   pDataBase,
    PDBENTRY    pApp,
    BOOL        bRepaint
    );

BOOL
GetEntryXML(
    CSTRINGLIST* strlXML,
    PDBENTRY     pEntry
    );

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Global Variables /////////////////////////////////////

// This is the system database
struct DataBase GlobalDataBase(DATABASE_TYPE_GLOBAL);

// The list of custom databases
struct tagDataBaseList  DataBaseList;

// The list of installed databases
struct tagDataBaseList  InstalledDataBaseList;

// Should we show the entry conflict dialog. Presently this is not used and is always FALSE
BOOL    g_bEntryConflictDonotShow   = FALSE;

// Temporary buffer for reading strings from the database
WCHAR   g_wszData[MAX_DATA_SIZE];

// Used to convert from special chars to valid XML and vice-versa
SpecialCharMap g_rgSpecialCharMap[4][2] = {
    TEXT("&"),  1,  TEXT("&amp;"),  5, // 5 is the length of the string in the prev. column
    TEXT("\""), 1,  TEXT("&quot;"), 6, 
    TEXT("<"),  1,  TEXT("&lt;"),   4, 
    TEXT(">"),  1,  TEXT("&gt;"),   4
};

//
// The various possible attributes for matching files
//
// Caution:
//          If you change g_Attributes or their order, 
//          you will have to change DEFAULT_MASK in CompatAdmin.h
//
TAG g_Attributes[] = {
    TAG_SIZE,
    TAG_CHECKSUM,
    TAG_BIN_FILE_VERSION,
    TAG_BIN_PRODUCT_VERSION,
    TAG_PRODUCT_VERSION,
    TAG_FILE_DESCRIPTION,
    TAG_COMPANY_NAME,
    TAG_PRODUCT_NAME,
    TAG_FILE_VERSION,
    TAG_ORIGINAL_FILENAME,
    TAG_INTERNAL_NAME,
    TAG_LEGAL_COPYRIGHT,
    TAG_VERDATEHI,
    TAG_VERDATELO,
    TAG_VERFILEOS,
    TAG_VERFILETYPE,
    TAG_MODULE_TYPE,
    TAG_PE_CHECKSUM,
    TAG_LINKER_VERSION,
#ifndef KERNEL_MODE
    TAG_16BIT_DESCRIPTION,
    TAG_16BIT_MODULE_NAME,
#endif
    TAG_UPTO_BIN_FILE_VERSION,
    TAG_UPTO_BIN_PRODUCT_VERSION,
    TAG_LINK_DATE,
    TAG_UPTO_LINK_DATE,
    TAG_VER_LANGUAGE
 };

// Total number of attributes available
DWORD ATTRIBUTE_COUNT = ARRAYSIZE(g_Attributes);

///////////////////////////////////////////////////////////////////////////////

BOOL
CheckRegistry(
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszGUID
    )
/*++

    CheckRegistry
    
	Desc:	Checks if the entry with GUID pszGUID is disabled

	Params:
        IN  HKEY    hkeyRoot:    The key under which to search
        IN  LPCTSTR pszGUID:    The guid of the entry

	Return:
        TRUE:   The entry is disabled
        FALSE:  The entry is enabled or there was some error
--*/
{
    LONG  status;
    HKEY  hkey = NULL;
    BOOL  bDisabled = FALSE;
    DWORD dwFlags;
    DWORD type;
    DWORD cbSize = sizeof(DWORD);

    status = RegOpenKey(hkeyRoot, APPCOMPAT_KEY, &hkey);

    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    status = RegQueryValueEx(hkey, pszGUID, NULL, &type, (LPBYTE)&dwFlags, &cbSize);

    if (status == ERROR_SUCCESS && type == REG_DWORD && (dwFlags & APPCOMPAT_DISABLED)) {
        bDisabled = TRUE;
    }

    REGCLOSEKEY(hkey);

    return bDisabled;
}

BOOL
SetDisabledStatus(
    IN  HKEY   hKeyRoot, 
    IN  PCTSTR pszGuid,
    IN  BOOL   bDisabled
    )
/*++

    SetDisabledStatus
    
	Desc:	Sets the disabled status of a entry

	Params:
        IN  HKEY   hkeyRoot:    The AppCompat Key
        IN  PCTSTR pszGUID:     The guid of the entry
        IN  BOOL   bDisabled:   Do we want to make it disabled?

	Return:
        TRUE:   The entry's status has been changed 
        FALSE:  There was some error
--*/

{

    DWORD dwFlags       = 0;
    HKEY  hkey          = NULL;
    DWORD dwValue       = 0x03;
    DWORD dwDisposition = 0;
    LONG  status;
    
    if (bDisabled == TRUE) {
        dwFlags = 0x1;
    }

    status = RegOpenKey(hKeyRoot, APPCOMPAT_KEY, &hkey);

    if (status != ERROR_SUCCESS) {

        status = RegCreateKeyEx(hKeyRoot,
                                APPCOMPAT_KEY,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkey,
                                &dwDisposition);

        if (status != ERROR_SUCCESS) {
            return FALSE;
        }
    }

    status = RegSetValueEx(hkey, 
                           pszGuid, 
                           0, 
                           REG_DWORD, 
                           (LPBYTE) &dwFlags, 
                           sizeof(DWORD));

    REGCLOSEKEY(hkey);

    return ((status == ERROR_SUCCESS) ? TRUE : FALSE);
}

BOOL
RemoveEntry(
    IN  PDATABASE   pDataBase,
    IN  PDBENTRY    pEntryToRemove,
    IN  PDBENTRY    pApp,
    IN  BOOL        bRepaint   //def = TRUE
    )
/*++

    RemoveEntry

	Desc:	Remove an Entry from the database. This will also do any UI updates.

	Params:
        IN  PDATABASE   pDataBase:      The database in which the entry being removed lives
        IN  PDBENTRY    pEntryToRemove: The entry to remove
        IN  PDBENTRY    pApp:           The fist entry for the app to which this entry belongs
        IN  BOOL        bRepaint:       <TODO>

	Return:
        TRUE:   The entry has been removed
        FALSE:  There was some error  
--*/
{
    if (pEntryToRemove == NULL) {
        return FALSE;
    }

    PDBENTRY    pPrev           = NULL;
    PDBENTRY    pEntry          = pApp;
    HTREEITEM   hItemEntryExe   = NULL, htemEntrySibling = NULL;
    
    while (pEntry) {

        if (pEntry == pEntryToRemove) {
            break;
        }

        pPrev  = pEntry;
        pEntry = pEntry->pSameAppExe;
    }
    
    if (pEntry == pEntryToRemove && pEntry != NULL) {

        if (pEntry == pApp) {
            //
            // First entry for the app. Note that this routine does not actually remove this
            // pEntry. Does stuff only on the UI
            //
            HandleFirstEntryofAppDeletion(pDataBase, pEntry, bRepaint);

        } else {
            assert(pPrev);

            if (pPrev) {
                pPrev->pSameAppExe = pEntry->pSameAppExe;
            }
        }

        // [BUGBUG]: We need to keep this in the destructor of PDBENTRY
        if (pEntry->appHelp.bPresent) {
            DeleteAppHelp(pDataBase, pEntry->appHelp.HTMLHELPID);
            pEntry->appHelp.bBlock = pEntry->appHelp.bPresent = FALSE;
            pEntry->appHelp.severity = APPTYPE_NONE;
        }

        //
        // Now we have to set the focus to some sibling of the deleted entry and 
        // Update the g_pSelEntry
        //
        if (!(pApp == pEntryToRemove && pApp->pSameAppExe == NULL)) {
            //
            // The previous entry tree will be still there only if the condition is true
            // Otherwise the old tree will have gone because HandleFirstEntryofAppDeletion 
            // will have caused the sibling of the app being deleted to be selected and the 
            // previous entry tree will no 
            // longer be there
            // We will have a new entry tree of the second app.
            //
            hItemEntryExe  = NULL, htemEntrySibling = NULL;

            hItemEntryExe = CTree::FindChild(g_hwndEntryTree, TVI_ROOT, (LPARAM)pEntryToRemove);

            if (hItemEntryExe) {

                htemEntrySibling = TreeView_GetNextSibling(g_hwndEntryTree, hItemEntryExe);

                if (htemEntrySibling == NULL) {
                    htemEntrySibling = TreeView_GetPrevSibling(g_hwndEntryTree, 
                                                               hItemEntryExe);
                }
    
                SendMessage(g_hwndEntryTree, WM_SETREDRAW, FALSE, 0);
                TreeView_DeleteItem(g_hwndEntryTree, hItemEntryExe);
                SendMessage(g_hwndEntryTree, WM_SETREDRAW, TRUE, 0);

                //
                // g_pSelEntry will get changed in the notification handler for the tree
                //
                if (htemEntrySibling && bRepaint) {
                    TreeView_SelectItem(g_hwndEntryTree, htemEntrySibling);
                }
            }
        }
       
        ValidateClipBoard(NULL, pEntry);
        //
        // Has destructor
        //
        delete pEntry;

    } else {
        assert(FALSE);
        return FALSE;
    }

    return TRUE;
}

LPVOID
FindFix(
    IN  PCTSTR      pszFixName,
    IN  TYPE        fixType,
    IN  PDATABASE   pDataBase // (NULL)
    )
/*++

    FindFix

	Desc:	Searches for a fix of type fixType in pDataBase with name pszFixName

	Params:
        IN  LPCTSTR     pszFixName:         The fix to search for
        IN  TYPE        fixType:            The type of the fix. One of
            a) FIX_SHIM
            b) FIX_FLAG
            c) FIX_LAYER
            d) FIX_PATCH
            
        IN  PDATABASE   pDataBase(NULL):    The database in which to search. 
            If this is NULL we search in the GlobalDatabase

	Return:
        The pointer to the fix if found
        NULL otherwise
--*/
{   
    if (pszFixName == NULL) {
        assert(FALSE);
        return NULL;
    }

    switch (fixType) {
    case FIX_SHIM:
        {
            PSHIM_FIX pFix = GlobalDataBase.pShimFixes;
            
            while (pFix) {
    
                if (pFix->strName.Length() && !lstrcmpi(pszFixName, pFix->strName)) {
                    return pFix;
                }
    
                pFix = pFix->pNext;
            }

            break;
        }
    
    case FIX_FLAG:
        {
            PFLAG_FIX pFix = GlobalDataBase.pFlagFixes;
            
            while (pFix) {
    
                if (pFix->strName.Length() && !lstrcmpi(pszFixName, pFix->strName)) {
                    return pFix;
                }
    
                pFix = pFix->pNext;
            }

            break;
        }
    
    case FIX_LAYER:
        { 
            //
            // Search in the local database.
            //
            if (pDataBase == NULL || pDataBase == &GlobalDataBase) {
                goto SearchGlobal;
            }

            PLAYER_FIX pFix = pDataBase->pLayerFixes;
            
            while (pFix) {
    
                if (pFix->strName.Length() && !lstrcmpi(pszFixName, pFix->strName)) {
                    return pFix;
                }
    
                pFix = pFix->pNext;
            }

            //
            // Search in the global database.
            //
SearchGlobal:

            pFix = GlobalDataBase.pLayerFixes;
            
            while (pFix) {
    
                if (pFix->strName.Length() && !lstrcmpi(pszFixName, pFix->strName)) {
                    return pFix;
                }
    
                pFix = pFix->pNext;
            }

            break;
        }
    
    case FIX_PATCH:
        {
            PPATCH_FIX pFix = GlobalDataBase.pPatchFixes;
            
            while (pFix) {
    
                if (pFix->strName.Length() && !lstrcmpi(pszFixName, pFix->strName)) {
                    return pFix;
                }
    
                pFix = pFix->pNext;
            }

            break;
        }
    }
        
    return NULL;
}

CSTRING 
ReadDBString(
    IN  PDB   pDB,
    IN  TAGID tagID
    )
/*++
    ReadDBString

	Desc:	Reads a string from the database

	Params:
        IN  PDB   pDB:      The database
        IN  TAGID tagID:    The tag id for the string type

	Return: The string read. Will return a string of zero length if there is some error 
    
--*/
{
    
    CSTRING Str;
    K_SIZE  k_pszAppName    = MAX_STRING_SIZE;
    PTSTR   pszAppName      = new TCHAR[k_pszAppName];

    if (pszAppName == NULL) {
        MEM_ERR;
        goto End;
    }

    if (pDB == NULL) {
        goto End;
    }

    if (!SdbReadStringTag(pDB, tagID, pszAppName, k_pszAppName)) {
        assert(FALSE);
        goto End;
    }

    pszAppName[k_pszAppName - 1] = 0;
    
    Str = pszAppName;
    Str.XMLToSpecialChar();

End:
    if (pszAppName) {
        delete[] pszAppName;
        pszAppName = NULL;
    }

    return Str;
}

BOOL
ReadAppHelp(
    IN  PDB         pdb,     
    IN  TAGID       tiAppHelp,
    IN  PDATABASE   pDataBase
    )
/*++
    
    ReadAppHelp

	Desc:	Reads the apphelp from the library section of the database

	Params:   
        IN  PDB         pdb:        The database pdb
        IN  TAGID       tiAppHelp:  The TAGID for the apphelp
        IN  PDATABASE   pDataBase:  The database in which to add the apphelp    

	Return:
        TRUE:   The apphelp was read and added to the database
        FALSE:  There was some error
        
    Notes:  We do not read the apphelp for system database. The apphelp for system database
            is kept in apphelp.sdb. For system database, this function will apparently not get
            called
            
--*/
{
    TAGID       tiInfo;
    PAPPHELP    pAppHelp  = NULL;

    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "ReadAppHelp NULL pDataBase passed");
        return FALSE;
    }

    pAppHelp = new APPHELP;
    
    if (pAppHelp == NULL) {
        MEM_ERR;
        goto error;
    }
    
    //
    // Add for the specified database.
    //
    pAppHelp->pNext         = pDataBase->pAppHelp;
    pDataBase->pAppHelp     = pAppHelp;    

    tiInfo = SdbGetFirstChild(pdb, tiAppHelp);

    while (0 != tiInfo) {

        TAG tag;

        tag = SdbGetTagFromTagID(pdb, tiInfo);

        switch (tag) {
        case TAG_HTMLHELPID:
            
            pAppHelp->HTMLHELPID =  SdbReadDWORDTag(pdb, tiInfo, 0);

            //
            // Set the highest html id for the database. The next apphelp message
            // should have a value one more than this
            //
            if (pAppHelp->HTMLHELPID > pDataBase->m_nMAXHELPID) {
                pDataBase->m_nMAXHELPID = pAppHelp->HTMLHELPID;  
            }

            break;

        case TAG_LINK:
            {
                TAGID tagLink  =  SdbFindFirstTag(pdb, tiAppHelp, TAG_LINK);

                //
                // Get the apphelp URL
                //
                if (tagLink) {
                    tagLink = SdbFindFirstTag(pdb, tagLink, TAG_LINK_URL);
                    pAppHelp->strURL = ReadDBString(pdb, tagLink);
                }
            }

            break;

        case TAG_APPHELP_DETAILS:
            
            //
            // Get the apphelp text message
            //
            pAppHelp->strMessage = ReadDBString(pdb, tiInfo);
            break;
        }

        tiInfo = SdbGetNextChild(pdb, tiAppHelp, tiInfo);
    }

    return TRUE;

error:

    if (pAppHelp) {
        delete pAppHelp;
        pAppHelp = NULL;
    }

    return FALSE;
}

BOOL
ReadIncludeExlude(
    IN  PDB          pdb, 
    IN  TAGID        tiShim,
    OUT CSTRINGLIST& strlInExclude
    )
/*++

    ReadIncludeExlude

	Desc:	Reads the include-exclude list for a shim

	Params: 
        IN  PDB             pdb:            The database pdb
        IN  TAGID           tiShim:         TAGID for TAG_SHIM or TAG_SHIM_REF
        OUT CSTRINGLIST&    strlInExclude:  The include-exclude module names will be stored in
            this

	Return:
        TRUE:   The include-exclude list was read properly
        FALSE:  There was some error
        
    Notes:  In the .sdb the include exclude modules are arranged in this way
    
            0x0000012E | 0x7003 | INEXCLUDE      | LIST | Size 0x00000006
                    0x00000134 | 0x6003 | MODULE         | STRINGREF | out.dll
            -end- INEXCLUDE
            
            0x0000013A | 0x7003 | INEXCLUDE      | LIST | Size 0x00000008
                0x00000140 | 0x1001 | INCLUDE        | NULL |
                0x00000142 | 0x6003 | MODULE         | STRINGREF | IN.DLL
            -end- INEXCLUDE            
            
            The above means that first exclude the module out.dll then 
            include the module in.dll
--*/
{
    TAGID   tiInExclude;
    BOOL    bReturn = FALSE;
    CSTRING strTemp;

    //
    // Read the INCLUSION list
    //
    tiInExclude = SdbFindFirstTag(pdb, tiShim, TAG_INEXCLUDE);
    
    if (tiInExclude == TAGID_NULL) {
        return FALSE;
    }

    while (tiInExclude) {

        TAGID tiInfo =  SdbFindFirstTag(pdb, tiInExclude, TAG_INCLUDE);
    
        if (tiInfo != TAGID_NULL) {
            
            tiInfo = SdbFindFirstTag(pdb, tiInExclude, TAG_MODULE);
    
            if (tiInfo != 0) {
                
                strTemp = ReadDBString(pdb, tiInfo);
                
                if (strTemp == TEXT("$")) {
                    //
                    // Means include the module being fixed
                    //
                    strTemp = GetString(IDS_INCLUDEMODULE);
                }                             
                
                strlInExclude.AddStringAtBeg(strTemp, INCLUDE);
                bReturn= TRUE;
            }

        } else {
            //
            // Look for exclusions
            //
            tiInfo = SdbFindFirstTag(pdb, tiInExclude, TAG_MODULE);
            
            if (tiInfo != 0) {

                strTemp = ReadDBString(pdb, tiInfo);
                strlInExclude.AddStringAtBeg(strTemp, EXCLUDE);
                bReturn= TRUE;
            }
        }
        
        tiInExclude = SdbFindNextTag(pdb, tiShim, tiInExclude);
    }
    
    return bReturn;
}

BOOL
AddShimFix(
    IN      PDB         pdb,
    IN      TAGID       tiFix,
    IN  OUT PDBENTRY    pEntry,
    IN  OUT PLAYER_FIX  pLayerFix,
    IN      BOOL        bAddToLayer
    )
/*++
    
    AddShimFix

	Desc:	Adds a shim fix list in an entry or a layer

	Params:   
        IN      PDB         pdb:            The database pdb
        IN      TAGID       tiFix:          TAG_SHIM_REF
        IN  OUT PDBENTRY    pEntry:         The pointer to entry if we want to add this shim to an entry
        IN  OUT PLAYER_FIX  pLayerFix:      The pointer to a layer if we want to add this shim to a layer
        IN      BOOL        bAddToLayer:    Do we want to add this to a layer or an entry? 

	Return:
        TRUE:   Shim was added properly
        FALSE:  There was some error
--*/
{   
    TAGID          tiName;
    TCHAR          szFixName[MAX_NAME];
    PSHIM_FIX      pFix;
    PSHIM_FIX_LIST pFixList;
    BOOL           bOk = TRUE; 

    tiName = SdbFindFirstTag(pdb, tiFix, TAG_NAME);

    if (!SdbReadStringTag(pdb, tiName, g_wszData, ARRAYSIZE(g_wszData))) {
        Dbg(dlError, "Cannot read the name of the fix\n");
        return FALSE;
    }

    SafeCpyN(szFixName, g_wszData, ARRAYSIZE(szFixName));

    pFix = (PSHIM_FIX)FindFix(CSTRING(szFixName).XMLToSpecialChar(), FIX_SHIM);

    if (pFix == NULL) {
        Dbg(dlError, "Cannot find fix ref for: \"%S\" type %d\n", szFixName, FIX_SHIM);
        return FALSE;
    }

    pFixList = new SHIM_FIX_LIST;

    if (pFixList == NULL) {
        Dbg(dlError, "Cannot allocate %d bytes\n", sizeof(SHIM_FIX_LIST));
        return FALSE;
    }

    pFixList->pShimFix = pFix;

    tiName = SdbFindFirstTag(pdb, tiFix, TAG_COMMAND_LINE);

    if (tiName != TAGID_NULL) {
        pFixList->strCommandLine = ReadDBString(pdb, tiName);
    }

    tiName = SdbFindFirstTag(pdb, tiFix, TAG_INEXCLUDE);

    if (tiName != TAGID_NULL) {
        ReadIncludeExlude(pdb, tiFix, pFixList->strlInExclude);
    }

    if (pFix->strName.BeginsWith(TEXT("LUARedirectFS"))) {
        //
        // Get the data for LUARedirectFS shim
        //
        pFixList->pLuaData = LuaProcessLUAData(pdb, tiFix);
    }
 
    if (bAddToLayer == FALSE) {

        if (pEntry) {

            pFixList->pNext = pEntry->pFirstShim;
            pEntry->pFirstShim = pFixList;

        } else {
            assert(FALSE);
            Dbg(dlError, "AddShimFix bAddLayer == FALSE and pEntry == NULL");
            bOk = FALSE;
        }

    } else {
        //
        // We want to put this in the layer list of the library.
        //
        if (pLayerFix) {

            pFixList->pNext = pLayerFix->pShimFixList;
            pLayerFix->pShimFixList = pFixList;
            ++pLayerFix->uShimCount;

        } else {
            bOk = FALSE;
            assert(FALSE);
            Dbg(dlError, "AddShimFix bAddLayer == TRUE and pLayerFix == NULL");
        }
    }

    if (bOk == FALSE && pFixList) {
        assert(FALSE);
        
        delete pFixList;
        pFixList  = NULL;
    }
    
    return bOk;
}

BOOL
AddFlagFix(
    IN      PDB        pdb,
    IN      TAGID      tiFix,
    IN OUT  PDBENTRY   pEntry,
    IN OUT  PLAYER_FIX pLayerFix,
    IN      BOOL       bAddToLayer
    )
/*++
    
    AddFlagFix

	Desc:	Adds a flag fix list in an entry or a layer

	Params:   
        IN      PDB         pdb:            The database pdb
        IN      TAGID       tiFix:          TAG_FLAG_REF
        IN  OUT PDBENTRY    pEntry:         The pointer to entry if we want to add this flag to an entry
        IN  OUT PLAYER_FIX  pLayerFix:      The pointer to a layer if we want to add this flag to a layer
        IN      BOOL        bAddToLayer:    Do we want to add this to a layer or an entry? 

	Return:
        TRUE:   Flag was added properly
        FALSE:  There was some error
--*/

{
    TAGID           tiName;
    TCHAR           szFixName[MAX_NAME];
    PFLAG_FIX       pFix        = NULL;
    PFLAG_FIX_LIST  pFixList    = NULL;
    BOOL            bOk         = TRUE;

    tiName = SdbFindFirstTag(pdb, tiFix, TAG_NAME);

    if (!SdbReadStringTag(pdb, tiName, g_wszData, ARRAYSIZE(g_wszData))) {
        Dbg(dlError, "Cannot read the name of the fix\n");
        bOk = FALSE;
        goto End;
    }

    SafeCpyN(szFixName, g_wszData, ARRAYSIZE(szFixName));
    szFixName[ARRAYSIZE(szFixName) - 1] = 0;

    pFix = (PFLAG_FIX)FindFix(CSTRING(szFixName).XMLToSpecialChar(), FIX_FLAG);

    if (pFix == NULL) {
        Dbg(dlError, "Cannot find fix ref for: \"%S\" type %d\n", szFixName, FIX_FLAG);
        bOk = FALSE;
        goto End;
    }

    pFixList = new FLAG_FIX_LIST;

    if (pFixList == NULL) {
        Dbg(dlError, "Cannot allocate %d bytes\n", sizeof(FLAG_FIX_LIST));
        bOk = FALSE;
        goto End;
    }

    pFixList->pFlagFix = pFix;

    //
    // Add the commandline for flags
    //
    tiName = SdbFindFirstTag(pdb, tiFix, TAG_COMMAND_LINE);

    if (tiName != TAGID_NULL) {
        pFixList->strCommandLine = ReadDBString(pdb, tiName);
    }

    if (bAddToLayer == FALSE) {

        if (pEntry == NULL) {
            //
            // We wanted this flag to be added to an entry but did not give a pointer to the entry
            //
            assert(FALSE);
            bOk = FALSE;
            goto End;
        }   

        pFixList->pNext = pEntry->pFirstFlag;
        pEntry->pFirstFlag = pFixList;

    } else {
        //
        // We want to put this in the layer list of the library.
        //
        if (pLayerFix == NULL) {
            assert(FALSE);
            bOk = FALSE;
            goto End;
        }
        
        pFixList->pNext = pLayerFix->pFlagFixList;
        pLayerFix->pFlagFixList = pFixList;
        ++pLayerFix->uShimCount;
    }

End:  

    if (bOk == FALSE) {
        //
        // There was some error, free any memory that we might have allocated in this routine
        //
        assert(FALSE);

        if (pFixList) {
            delete pFixList;
            pFixList = NULL;
        }
    }

    return bOk;
}

BOOL
AddPatchFix(
    IN      PDB      pdb,
    IN      TAGID    tiFix,
    IN  OUT PDBENTRY pEntry
    )
/*++
    
    AddPatchFix

	Desc:	Adds a patch fix list in an entry

	Params:   
        IN      PDB         pdb:    The database pdb
        IN      TAGID       tiFix:  TAG_PATCH_REF
        IN  OUT PDBENTRY    pEntry: The pointer to entry that we want the patch to be added

	Return:
        TRUE:   Patch was added properly
        FALSE:  There was some error
--*/
{
    TAGID            tiName;
    TCHAR            szFixName[MAX_NAME];
    PPATCH_FIX       pFix;
    PPATCH_FIX_LIST* ppHead;
    PPATCH_FIX_LIST  pFixList;

    if (pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    tiName = SdbFindFirstTag(pdb, tiFix, TAG_NAME);

    if (!SdbReadStringTag(pdb, tiName, g_wszData, ARRAYSIZE(g_wszData))) {
        Dbg(dlError, "Cannot read the name of the fix\n");
        return FALSE;
    }

    SafeCpyN(szFixName, g_wszData, ARRAYSIZE(szFixName));

    CSTRING strTemp = szFixName;

    strTemp.XMLToSpecialChar();

    pFix = (PPATCH_FIX)FindFix(strTemp, FIX_PATCH);

    if (pFix == NULL) {
        Dbg(dlError, "Cannot find fix ref for: \"%S\" type %d\n", szFixName, FIX_PATCH);
        return FALSE;
    }

    ppHead = &pEntry->pFirstPatch;

    pFixList = new PATCH_FIX_LIST;

    if (pFixList == NULL) {
        Dbg(dlError, "Cannot allocate %d bytes\n", sizeof(PATCH_FIX_LIST));
        return FALSE;
    }
    
    pFixList->pPatchFix = pFix;
    pFixList->pNext     = *ppHead;
    *ppHead             = pFixList;
        
    return TRUE;
}

BOOL
AddLayerFix(
    IN              PDB         pdb,
    IN              TAGID       tiFix,
    IN  OUT         PDBENTRY    pEntry,
    IN              PDATABASE   pDataBase
    )
/*++
    
    AddLayerFix

	Desc:	Adds a layer fix list in an entry

	Params:   
        IN      PDB         pdb:        The database pdb
        IN      TAGID       tiFix:      TAG_LAYER_REF
        IN  OUT PDBENTRY    pEntry:     The pointer to entry that we want the layer to be added
        IN      PDATABASE   pDataBase:  The database where this entry lives in.
                We need this because we need to pass the database to FindFix in case of layers.
                Layers can be present in the custom database as well as system database
                and we have to search in the custom database also to make sure that
                the layer name in the TAG_LAYER_REF is a valid layer.

	Return:
        TRUE:   Layer was added properly
        FALSE:  There was some error
--*/
{
    TAGID               tiName;
    TCHAR               szFixName[MAX_NAME];
    PLAYER_FIX          pFix;
    PLAYER_FIX_LIST*    ppHead;
    PLAYER_FIX_LIST     pFixList;

    if (pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    tiName = SdbFindFirstTag(pdb, tiFix, TAG_NAME);

    if (!SdbReadStringTag(pdb, tiName, g_wszData, ARRAYSIZE(g_wszData))) {
        Dbg(dlError, "Cannot read the name of the fix\n");
        return FALSE;
    }

    SafeCpyN(szFixName, g_wszData, ARRAYSIZE(szFixName));

    CSTRING strTemp = szFixName;

    strTemp.XMLToSpecialChar();

    pFix = (PLAYER_FIX)FindFix(strTemp, FIX_LAYER, pDataBase);

    if (pFix == NULL) {
        assert(FALSE);
        Dbg(dlError, "Cannot find fix ref for: \"%S\" type %d\n", szFixName, FIX_LAYER);
        return FALSE;
    }

    ppHead = &pEntry->pFirstLayer;

    pFixList = new LAYER_FIX_LIST;

    if (pFixList == NULL) {
        Dbg(dlError, "Cannot allocate %d bytes\n", sizeof(LAYER_FIX_LIST));
        return FALSE;
    }                

    pFixList->pLayerFix = pFix;
    pFixList->pNext     = *ppHead;
    *ppHead             = pFixList;
        
    return TRUE;
}

void
ReadShimFix(
    IN  PDB         pdb,
    IN  TAGID       tiFix,
    IN  PDATABASE   pDataBase
    )
/*++           
    ReadShimFix

	Desc:	Adds the shim to the database

	Params:
		IN  PDB         pdb:        The database pdb
        IN  TAGID       tiFix:      The TAGID for the shim
        IN  PDATABASE   pDataBase:  The database in which to add the shim fix
        
	Return:
        void
--*/
{
    TAGID       tiInfo;
    TAG         tWhich;
    BOOL        bInExcludeProcessed = FALSE;
    PSHIM_FIX   pFix                = NULL;

    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "ReadShimFix NULL pDataBase passed");
        return;
    }

    pFix = new SHIM_FIX;
    
    if (pFix == NULL) {
        MEM_ERR;
        return;
    }

    pFix->pNext = NULL;

    tiInfo = SdbGetFirstChild(pdb, tiFix);

    while (tiInfo != 0) {
        
        tWhich = SdbGetTagFromTagID(pdb, tiInfo);

        switch (tWhich) {
        case TAG_NAME:

            pFix->strName = ReadDBString(pdb,  tiInfo);
            break;

        case TAG_DESCRIPTION:

            pFix->strDescription = ReadDBString(pdb,  tiInfo);
            break;

        case TAG_COMMAND_LINE:
            
            pFix->strCommandLine = ReadDBString(pdb,  tiInfo);
            break;

        case TAG_GENERAL:

            pFix->bGeneral = TRUE;
            break;

       
        case TAG_INEXCLUDE:

            if (bInExcludeProcessed == FALSE) {

                ReadIncludeExlude(pdb, tiFix, pFix->strlInExclude);
                bInExcludeProcessed  = TRUE;
            }

            break;
        }

        tiInfo = SdbGetNextChild(pdb, tiFix, tiInfo);
    }
    
    //
    // Add for the specified database.
    //
    pFix->pNext             = pDataBase->pShimFixes;
    pDataBase->pShimFixes   = pFix;

    if (pFix->bGeneral || g_bExpert) {
        ++pDataBase->uShimCount;
    }
}

void
ReadLayerFix(
    IN  PDB         pdb,
    IN  TAGID       tiFix,
    IN  PDATABASE   pDataBase
    )
/*++

    ReadLayerFix

	Desc:	Adds the layer to the database

	Params:
		IN  PDB         pdb:        The database pdb
        IN  TAGID       tiFix:      The TAGID for the layer
        IN  PDATABASE   pDataBase:  The database in which to add the layer    
        
	Return:
        void
--*/
{
    TAGID       tiInfo;
    TAG         tWhich;
    PLAYER_FIX  pFix =  NULL;

    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "ReadLayerFix NULL pDataBase passed");
        return;
    }

    pFix =  new LAYER_FIX(pDataBase != &GlobalDataBase);

    if (!pFix) {
        MEM_ERR;
        return;
    }

    tiInfo = SdbGetFirstChild(pdb, tiFix);

    while (tiInfo != 0) {

        tWhich = SdbGetTagFromTagID(pdb, tiInfo);

        switch (tWhich) {
        case TAG_NAME:

            pFix->strName = ReadDBString(pdb,  tiInfo);
            break;
        
        case TAG_SHIM_REF:

            AddShimFix(pdb, tiInfo, NULL, pFix, TRUE);
            break;

        case TAG_FLAG_REF:

            AddFlagFix(pdb, tiInfo, NULL, pFix, TRUE);
            break;
        }

        tiInfo = SdbGetNextChild(pdb, tiFix, tiInfo);
    }

    //
    // Add for the specified database.
    //
    pFix->pNext              = pDataBase->pLayerFixes;
    pDataBase->pLayerFixes   = pFix;
    ++pDataBase->uLayerCount;
}

void
ReadPatchFix(
    IN  PDB         pdb,
    IN  TAGID       tiFix,
    IN  PDATABASE   pDataBase
    )
/*++                
    ReadPatchFix

	Desc:	Adds the patch to the database

	Params:
		IN  PDB         pdb:        The database pdb
        IN  TAGID       tiFix:      The TAGID for the patch
        IN  PDATABASE   pDataBase:  The database in which to add the apphelp    
        
	Return:
        void
--*/        
{
    TAGID       tiInfo;
    TAG         tWhich;
    PPATCH_FIX  pFix =  NULL;

    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "ReadPatchFix NULL pDataBase passed");
        return;
    }

    pFix =  new PATCH_FIX;

    if (pFix == NULL) {
        MEM_ERR;
        return;
    }

    tiInfo = SdbGetFirstChild(pdb, tiFix);
    
    while (tiInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiInfo);

        switch (tWhich) {
        case TAG_NAME:

            pFix->strName = ReadDBString(pdb,  tiInfo);
            break;

        case TAG_DESCRIPTION:

            pFix->strDescription = ReadDBString(pdb,  tiInfo);
            break;
        }

        tiInfo = SdbGetNextChild(pdb, tiFix, tiInfo);
    }

    //
    // Add for the specified database.
    //
    pFix->pNext             = pDataBase->pPatchFixes;
    pDataBase->pPatchFixes  = pFix;
}


void
ReadFlagFix(
    IN  PDB         pdb,
    IN  TAGID       tiFix,
    IN  PDATABASE   pDataBase
    )
/*++

    ReadFlagFix

	Desc:	Adds the flag to the database

	Params:
		IN  PDB     pdb:            The database pdb
        IN  TAGID   tiFix:          The TAGID for the flag
        IN  PDATABASE   pDataBase:  The database in which to add the FlagFix
        
	Return:
        void
--*/ 
{
    TAGID       tiInfo;
    TAG         tWhich;
    ULONGLONG   ullUser     = 0;
    ULONGLONG   ullKernel   = 0;
    PFLAG_FIX   pFix        = NULL;

    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "ReadFlagFix NULL pDataBase passed");
        return;
    }

    pFix = new FLAG_FIX;

    if (pFix == NULL) {
        MEM_ERR;
        return;
    }

    
    tiInfo = SdbGetFirstChild(pdb, tiFix);

    while (tiInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiInfo);

        switch (tWhich) {

        case TAG_NAME:

            pFix->strName = ReadDBString(pdb,  tiInfo);
            break;

        case TAG_DESCRIPTION:

            pFix->strDescription = ReadDBString(pdb,  tiInfo);
            break;

        case TAG_COMMAND_LINE:
            
            pFix->strCommandLine = ReadDBString(pdb,  tiInfo);
            break;

        case TAG_GENERAL:

            pFix->bGeneral = TRUE;
            break;


        case TAG_FLAG_MASK_USER:

            ullUser = SdbReadQWORDTag(pdb, tiInfo, 0);
            break;

        case TAG_FLAG_MASK_KERNEL:

            ullKernel = SdbReadQWORDTag(pdb, tiInfo, 0);
            break; 
        }

        tiInfo = SdbGetNextChild(pdb, tiFix, tiInfo);
    }


    if (ullKernel == 0) {

        pFix->flagType = FLAG_USER;
        pFix->ullMask = ullUser;

    } else {

        pFix->flagType = FLAG_KERNEL;
        pFix->ullMask = ullKernel;
    }

    //
    // Add for the specified database.
    //
    pFix->pNext         = pDataBase->pFlagFixes;
    pDataBase->pFlagFixes   = pFix;

    if (pFix->bGeneral || g_bExpert) {
        ++pDataBase->uShimCount;
    }
}

void
ReadFixes(
    IN  PDB         pdb,
    IN  TAGID       tiDatabase,
    IN  TAGID       tiLibrary,
    IN  PDATABASE   pDataBase
    )
/*++

    ReadFixes

	Desc:	Reads the apphelps, shims, patch, flag, layers for the main database

	Params:
		IN  PDB         pdb:        The pdb for the database
        IN  TAGID       tiDatabase: The tagid for the database
        IN  TAGID       tiLibrary:  The tagid for the library
        IN  PDATABASE   pDataBase:  The database in which to add all the fixes

	Return:
        void
--*/

{
    TAGID tiFix;

    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "ReadFixes NULL pDataBase passed");
        return;
    }

    tiFix = SdbFindFirstTag(pdb, tiDatabase, TAG_APPHELP);

    //
    // Read all apphelp messages for this database
    //
    while (tiFix) {
        ReadAppHelp(pdb, tiFix, pDataBase);
        tiFix = SdbFindNextTag(pdb, tiDatabase, tiFix);
    }
    
    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_SHIM);

    //
    // Read all shims for this database
    //
    while (tiFix != 0) {
        ReadShimFix(pdb, tiFix, pDataBase);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_PATCH);

    //
    // Read all patches for this database
    //
    while (tiFix != 0) {
        ReadPatchFix(pdb, tiFix, pDataBase);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_FLAG);

    //
    // Read all flags for this database
    //
    while (tiFix != 0) {
        ReadFlagFix(pdb, tiFix, pDataBase);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    //
    // Note: The LAYERs are under the DATABASE tag instead of LIBRARY
    //
    tiFix = SdbFindFirstTag(pdb, tiDatabase, TAG_LAYER);

    //
    // Read all layers for this database
    //
    while (tiFix != 0) {
        ReadLayerFix(pdb, tiFix, pDataBase);
        tiFix = SdbFindNextTag(pdb, tiDatabase, tiFix);
    }
}


BOOL
AddMatchingFile(
    IN  PDB      pdb,
    IN  TAGID    tiMatch,
    IN  PDBENTRY pEntry
    )
/*++

    AddMatchingFile

	Desc:	Reads the matching file entry from the database and adds it to the entry

	Params:
		IN  PDB         pdb:        The database pdb
        IN  TAGID       tiMatch:    The tag id for the matching file
        IN  PDBENTRY    pEntry:     The entry in which we want to add the matching file

	Return:
        FALSE:  There was some error
        TRUE:   Successful
--*/        
{   
    TAGID           tiMatchInfo;
    TAG             tWhich;
    PMATCHINGFILE   pMatch;
    DWORD           dwValue;
    DWORD           dwPos; //Position of the tag in the g_rgAttributeTags array.
    LARGE_INTEGER   ullValue;

    if (pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    pMatch = (PMATCHINGFILE) new MATCHINGFILE;
    
    if (pMatch == NULL) {
        MEM_ERR;
        return FALSE;
    }

    pMatch->dwMask = 0;

    PATTRINFO_NEW pAttr = pMatch->attributeList.pAttribute;
    
    tiMatchInfo = SdbGetFirstChild(pdb, tiMatch);
    
    while (tiMatchInfo != 0) {

        tWhich = SdbGetTagFromTagID(pdb, tiMatchInfo);
        dwPos = TagToIndex(tWhich);
    
        UINT       tagType = GETTAGTYPE(tWhich);
    
        switch (tagType) {
        case TAG_TYPE_DWORD:

            dwValue = SdbReadDWORDTag(pdb, tiMatchInfo, -1);
         
            if (dwValue != -1 && dwPos != -1) {

                pMatch->dwMask |= (1 << (dwPos + 1));
                pAttr[dwPos].tAttrID = tWhich;
                pAttr[dwPos].dwFlags |= ATTRIBUTE_AVAILABLE;
                pAttr[dwPos].dwAttr  = dwValue;
            }

            break; 
           
        case TAG_TYPE_QWORD: 
            
            ullValue.QuadPart = SdbReadQWORDTag(pdb, tiMatchInfo, 0);

            if ((ullValue.HighPart != 0 || ullValue.LowPart != 0) && dwPos != -1) {

                pMatch->dwMask |= (1 << (dwPos + 1));
                pAttr[dwPos].tAttrID = tWhich;
                pAttr[dwPos].dwFlags |= ATTRIBUTE_AVAILABLE;
                pAttr[dwPos].ullAttr = ullValue.QuadPart;
            }

            break;

        case TAG_TYPE_STRINGREF:
            {
                CSTRING str = ReadDBString(pdb, tiMatchInfo);
            
                //
                // NOTE: The TAG_NAME is not present in the g_rgAttributeTags array !!!
                //
                if (str.Length() > 0 && (tWhich == TAG_NAME || dwPos != -1)) {
                
                    if (tWhich == TAG_NAME) {
                        pMatch->strMatchName = str;
                    } else {
                    
                        pMatch->dwMask |= (1 << (dwPos + 1));
                        
                        pAttr[dwPos].tAttrID  = tWhich;
                        pAttr[dwPos].dwFlags |= ATTRIBUTE_AVAILABLE;
                        pAttr[dwPos].strValue = str;
                        pAttr[dwPos].lpAttr   = pAttr[dwPos].strValue.pszString;
                    }
                }
            }

            break;
        }

        tiMatchInfo = SdbGetNextChild(pdb, tiMatch, tiMatchInfo);
    }
    
    pMatch->pNext = pEntry->pFirstMatchingFile;
    pEntry->pFirstMatchingFile = pMatch;
    
    (pEntry->nMatchingFiles)++;

    return TRUE;
}

PAPPHELP
FindAppHelp(
    IN  DWORD       HTMLHELPID,
    IN  PDATABASE   pDataBase
    )
/*++

    FindAppHelp

	Desc:	Finds the apphelp with id HTMLHELPID in the database pDataBaseIn

	Params:   
        IN  DWORD       HTMLHELPID:         The htmlhelp id to look for
        IN  PDATABASE   pDataBase:          The database to look in.
        
	Return: If found the corresponding PAPPHELP or NULL if not found
--*/

{   
    PAPPHELP    pAppHelp  = NULL;  

    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "FindAppHelp NULL pDataBase passed");
	    return NULL;
    }

    pAppHelp = pDataBase->pAppHelp;

    while (pAppHelp) {

        if (pAppHelp->HTMLHELPID == HTMLHELPID) {
            return pAppHelp;
        } else {
            pAppHelp = pAppHelp->pNext;
        }
    }

    return NULL;
}

PDBENTRY
AddExeInApp(
    IN      PDBENTRY    pEntry,
    OUT     BOOL*       pbNew,
    IN      PDATABASE   pDataBase
    )
/*++

    AddExeInApp

	Desc:   Adds the entry pEntry in the database pDataBaseIn	

	Params:
        IN      PDBENTRY    pEntry:     The entry to add
        OUT     BOOL*       pbNew:      Will be true if this is a new app
        IN      PDATABASE   pDataBase:  The database to add into

	Return: Returns the PDBENTRY for the parent App.
--*/

{   
    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "AddExeInApp NULL pDataBase passed");
	    return NULL;
    }

    //
    // Now add this entry in its correct position for the app.
    //
    for (PDBENTRY pApps = pDataBase->pEntries,  pAppsPrev = NULL; 
         pApps; 
         pAppsPrev = pApps, pApps = pApps->pNext) {

        if (pApps->strAppName == pEntry->strAppName) {
            //
            // We insert the new entry at the head of the app
            //
            if (pAppsPrev == NULL) {
                pDataBase->pEntries = pEntry;
            } else {
                pAppsPrev->pNext = pEntry;
            }

            pEntry->pNext       = pApps->pNext;
            pApps->pNext        = NULL;
            pEntry->pSameAppExe = pApps;

            if (pbNew != NULL) {
                *pbNew = FALSE;
            }

            return pApps;
        }
    }

    //
    // This an entry for a new app.
    //
    pEntry->pNext       = pDataBase->pEntries;
    pDataBase->pEntries = pEntry;

    ++pDataBase->uAppCount;

    if (pbNew != NULL) {
        *pbNew = TRUE;  
    }

    return pEntry;
}

PDBENTRY
AddEntry(
    IN  PDB         pdb,
    IN  TAGID       tiExe,
    IN  PDATABASE   pDataBase
    )
/*++
    
    AddEntry

	Desc:	Reads a new entry from the database

	Params:
		IN  PDB         pdb:        The database pdb
        IN  TAGID       tiExe:      The tagid of the exe     
        IN  PDATABASE   pDataBase:  The database in which to perform this operation

	Return: Pointer to the entry read. PDBENTRY
    
--*/                          
{
    TAGID     tiExeInfo;
    TAGID     tiSeverity, tiHelpId;
    TAG       tWhich;
    PDBENTRY  pEntry    = NULL;

    if (pDataBase == NULL) {
        assert(FALSE);
        Dbg(dlError, "AddEntry NULL pDataBase passed");
	    return NULL;
    }

    tiExeInfo   = SdbGetFirstChild(pdb, tiExe);
    pEntry      = new DBENTRY;

    if (pEntry == NULL) {
        Dbg(dlError, "Cannot allocate %d bytes\n", sizeof(DBENTRY));
        MEM_ERR;
        return NULL;
    }

    pEntry->tiExe = tiExe;
    
    while (tiExeInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiExeInfo);

        switch (tWhich) {
        case TAG_NAME:
            
            pEntry->strExeName = ReadDBString(pdb, tiExeInfo);
            break;

        case TAG_APP_NAME:
            
            pEntry->strAppName = ReadDBString(pdb, tiExeInfo);
            break;

        case TAG_VENDOR:

            pEntry->strVendor = ReadDBString(pdb, tiExeInfo);
            break;

        case TAG_MATCHING_FILE:
            AddMatchingFile(pdb, tiExeInfo, pEntry);
            break;

        case TAG_APPHELP:
            pEntry->appHelp.bPresent = TRUE;
            
            tiSeverity = SdbFindFirstTag(pdb, tiExeInfo, TAG_PROBLEMSEVERITY);
            pEntry->appHelp.severity = (SEVERITY)SdbReadDWORDTag(pdb, tiSeverity, 0);

            if (pEntry->appHelp.severity == APPTYPE_INC_HARDBLOCK) {
                pEntry->appHelp.bBlock = TRUE;
            } else {
                pEntry->appHelp.bBlock = FALSE;
            }

            tiHelpId = SdbFindFirstTag(pdb, tiExeInfo, TAG_HTMLHELPID);

            pEntry->appHelp.HTMLHELPID      = SdbReadDWORDTag(pdb, tiHelpId, 0);

            if (pDataBase == &GlobalDataBase) {
                //
                // We do not wish to keep the apphelp data for main database in memory
                // Too big.. So we will load it from apphelp.sdb whenever we will need it
                // But still we will have to do the following so that the type of the lParam of 
                // the tree-item in the entry tree is TYPE_APPHELP, so that when we select that
                // we know that it is for apphelp
                //
                pEntry->appHelp.pAppHelpinLib = (PAPPHELP)TYPE_APPHELP_ENTRY;
            } else {
                pEntry->appHelp.pAppHelpinLib   = FindAppHelp(pEntry->appHelp.HTMLHELPID, pDataBase);
            }
            
            break;

        case TAG_SHIM_REF:
            AddShimFix(pdb, tiExeInfo, pEntry, NULL, FALSE);
            break;

        case TAG_FLAG_REF:
            AddFlagFix(pdb, tiExeInfo, pEntry, NULL, FALSE);
            break;

        case TAG_PATCH_REF:
            AddPatchFix(pdb, tiExeInfo, pEntry);
            break;

        case TAG_LAYER:
            AddLayerFix(pdb, tiExeInfo, pEntry, pDataBase);
            break;

        case TAG_EXE_ID:
            {
                GUID* pGuid = NULL;
    
                pGuid = (GUID*)SdbGetBinaryTagData(pdb, tiExeInfo);
    
                if (pGuid != NULL) {

                    StringCchPrintf(pEntry->szGUID,
                                    ARRAYSIZE(pEntry->szGUID),
                                    TEXT ("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                                    pGuid->Data1,
                                    pGuid->Data2,
                                    pGuid->Data3,
                                    pGuid->Data4[0],
                                    pGuid->Data4[1],
                                    pGuid->Data4[2],
                                    pGuid->Data4[3],
                                    pGuid->Data4[4],
                                    pGuid->Data4[5],
                                    pGuid->Data4[6],
                                    pGuid->Data4[7]);
                }

                break;
            }

        default:
            break;
        }

        tiExeInfo = SdbGetNextChild(pdb, tiExe, tiExeInfo);
    }
    
    pEntry->bDisablePerMachine  = CheckRegistry(HKEY_LOCAL_MACHINE, pEntry->szGUID);
    pEntry->bDisablePerUser     = CheckRegistry(HKEY_CURRENT_USER, pEntry->szGUID);

    //
    // Search the application where this entry should go and add it
    //
    AddExeInApp(pEntry, (BOOL*)NULL, pDataBase);

    return pEntry;
}


BOOL
LookUpEntryProperties(
    IN  PDB         pdb,
    IN  TAGID       tiExe,
    OUT BOOL*       pbLayers,
    OUT BOOL*       pbShims,
    OUT BOOL*       pbPatches,
    OUT BOOL*       pbFlags,
    OUT BOOL*       pbAppHelp,
    OUT CSTRING&    strAppName 
    )
/*++

    LookUpEntryProperties

    Desc:   Checks if the entry has shims, layers, flags, patches, or apphelp. NULL values
            for the various BOOL* is allowed
    
    Params:
        IN  PDB         pdb:        The database pdb
        IN  TAGID       tiExe:      The TAGID of the entry whose properties we want to check
        OUT BOOL*       pbLayers:   Does the entry have layers?
        OUT BOOL*       pbShims:    Does the entry have shims?
        OUT BOOL*       pbPatches:  Does the entry have patches?
        OUT BOOL*       pbFlags:    Does the entry have flags?
        OUT BOOL*       pbAppHelp:  Does the entry have apphelp?
        OUT CSTRING&    strAppName: The name of the application of this entry    
    
    Return: TRUE:   The routine was able to obtain the info for the entry, 
            FALSE:  otherwise
--*/
{
    TAGID   tiExeInfo;
    TAG     tWhich;
    BOOL    bOk = TRUE;      

    tiExeInfo = SdbGetFirstChild(pdb, tiExe);
    
    while (tiExeInfo != 0) {

        tWhich = SdbGetTagFromTagID(pdb, tiExeInfo);

        switch (tWhich) {
        case TAG_APP_NAME:

            strAppName = ReadDBString(pdb, tiExeInfo);
            break;

        case TAG_APPHELP:
            
            if (pbAppHelp) {
                *pbAppHelp = TRUE;
            }

            break;

        case TAG_SHIM_REF:

            if (pbShims) {
                *pbShims = TRUE;
            }

            break;

        case TAG_FLAG_REF:

            if (pbFlags) {
                *pbFlags = TRUE;
            }

            break;

        case TAG_PATCH_REF:

            if (pbPatches) {
                *pbPatches = TRUE;
            }

            break;

        case TAG_LAYER:

            if (pbLayers) {
                *pbLayers = TRUE;
            }

            break;
        }

        tiExeInfo = SdbGetNextChild(pdb, tiExe, tiExeInfo);
    }

    return bOk;
}

void
DeleteShimFixList(
    IN  PSHIM_FIX_LIST psl
    )
/*++

    DeleteShimFixList

	Desc:	Deletes this PSHIM_FIX_LIST and all PSHIM_FIX_LIST in this chain

	Params:  
        IN  PSHIM_FIX_LIST psl: The PSHIM_FIX_LIST to delete.
        
    Note:   Caller must NULLify this argument

	Return:
        void
--*/    
{
    PSHIM_FIX_LIST pslNext;

    while (psl) {

        pslNext = psl->pNext;

        if (psl->pLuaData) {
            delete psl->pLuaData;
            psl->pLuaData = NULL;
        }

        delete psl;
        psl = pslNext;
    }
}

void
DeletePatchFixList(
    IN  PPATCH_FIX_LIST pPat
    )
/*++

    DeletePatchFixList

	Desc:	Deletes this PPATCH_FIX_LIST and all PPATCH_FIX_LIST in this chain

	Params:  
        IN  PPATCH_FIX_LIST pPat: The PPATCH_FIX_LIST to delete.
        
    Note:   Caller must NULLify this argument

	Return:
        void
--*/
{
    PPATCH_FIX_LIST pPatNext;

    while (pPat) {

         pPatNext = pPat->pNext;
         delete (pPat);
         pPat = pPatNext;
    }

}

void
DeleteLayerFixList(
    IN  PLAYER_FIX_LIST pll
    )
/*++

    DeleteLayerFixList

	Desc:	Deletes this PLAYER_FIX_LIST and all PLAYER_FIX_LIST in this chain
        
    Note:   Caller must NULLify this argument

	Params:  
        IN  PLAYER_FIX_LIST pll: The PLAYER_FIX_LIST to delete.

	Return:
        void
--*/
{
    PLAYER_FIX_LIST pllNext;

    while (pll) {

        pllNext = pll->pNext;
        delete (pll);
        pll = pllNext;
    }
}

void
DeleteFlagFixList(
    IN  PFLAG_FIX_LIST pfl
    )
/*++

    DeleteFlagFixList

	Desc:	Deletes this PFLAG_FIX_LIST and all PFLAG_FIX_LIST in this chain
        
    Note:   Caller must NULLify this argument

	Params:  
        IN  PFLAG_FIX_LIST pfl: The PFLAG_FIX_LIST to delete.

	Return:
        void
--*/
{
    PFLAG_FIX_LIST pflNext;

    while (pfl) {

        pflNext = pfl->pNext;
        delete (pfl);
        pfl = pflNext;
    }
}

void
DeleteMatchingFiles(
    IN  PMATCHINGFILE pMatch
    )
/*++

    DeleteMatchingFiles

	Desc:	Deletes this PMATCHINGFILE and all PMATCHINGFILE in this chain
        
    Note:   Caller must NULLify this argument

	Params:  
        IN  PMATCHINGFILE pMatch: The PMATCHINGFILE to delete.

	Return:
        void
--*/


{
    PMATCHINGFILE pMatchNext;

    while (pMatch) {

        pMatchNext = pMatch->pNext;
        delete (pMatch);
        pMatch = pMatchNext;
    }
}

BOOL 
WriteXML(
    IN  CSTRING&        szFilename,
    IN  CSTRINGLIST*    pString
    )
/*++
    
    WriteXML

	Desc:   Writes the XML contained in pString to file szFilename. CSTRINGLIST is a linked
            list of CSTRING, and a node contains one line of XML to be written to the file

	Params:
        IN  CSTRING& szFilename:    The name of the file
        IN  CSTRINGLIST* pString:   Linked list of CSTRING containing the XML. 
            Each node contains one line of XML to be written to the file
        
	Return:
        TRUE:   Success
        FALSE:  There was some error
--*/

{
    BOOL        bOk         = TRUE;
    HANDLE      hFile       = NULL;
    PSTRLIST    pTemp       = NULL;
    TCHAR       chUnicodeID = 0xFEFF; // Ensure that the file is saved as unicode
    TCHAR       szCR[]      = {TEXT('\r'), TEXT('\n')};
    DWORD       dwBytesWritten;
    CSTRING     szTemp;

    if (NULL == pString) {
        bOk = FALSE;
        goto End;
    }

    pTemp   = pString->m_pHead;

    hFile   = CreateFile((LPCTSTR)szFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        bOk = FALSE;
        goto End;
    }

    if (!WriteFile(hFile, &chUnicodeID, sizeof(chUnicodeID) , &dwBytesWritten, NULL)) {
        assert(FALSE);
        bOk = FALSE;
        goto End;
    }
    
    while (NULL != pTemp) {
        
        if (!WriteFile(hFile, 
                       pTemp->szStr.pszString, 
                       pTemp->szStr.Length() * sizeof(TCHAR) ,
                       &dwBytesWritten,
                       NULL)) {

            bOk = FALSE;
            goto End;
        }

        if (!WriteFile(hFile, szCR, sizeof(szCR) , &dwBytesWritten, NULL)) {
            bOk = FALSE;
            goto End;
        }

        pTemp = pTemp->pNext;
    }

End:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return bOk;
}


void
CleanupDbSupport(
    IN   PDATABASE pDataBase
    )
/*++

    CleanupDbSupport
    
	Desc:	Deletes the data structures associated with a PDATABASE. This should be called 
            when we are going to close a database or we are going to delete a database.
            
            We should call this function before we do a delete PDATABASE

	Params:
        IN   PDATABASE pDataBase:    The pointer to the database

	Return:
        void
--*/
{   
    if (pDataBase == NULL) {
        assert(FALSE);
        return;
    }

    //
    // Free the Library section for the local database
    //

    //
    // Free the shims
    //
    PSHIM_FIX  pShimFixNext;

    while (pDataBase->pShimFixes) {

        pShimFixNext = pDataBase->pShimFixes->pNext;
        delete (pDataBase->pShimFixes);             
        pDataBase->pShimFixes = pShimFixNext;       
    }

    //
    // Free the patches
    //
    PPATCH_FIX  pPatchFixNext;

    while (pDataBase->pPatchFixes) {

        pPatchFixNext = pDataBase->pPatchFixes->pNext;
        delete (pDataBase->pPatchFixes);              
        pDataBase->pPatchFixes = pPatchFixNext;
    }

    //
    // Free the flags
    //
    PFLAG_FIX  pFlagFixNext;

    while (pDataBase->pFlagFixes) {

        pFlagFixNext = pDataBase->pFlagFixes->pNext;
        delete(pDataBase->pFlagFixes);              
        pDataBase->pFlagFixes = pFlagFixNext;
    }

    //
    // Free the layers.
    //
    PLAYER_FIX  pLayerFixNext;

    while (pDataBase->pLayerFixes) {

        pLayerFixNext = pDataBase->pLayerFixes->pNext;
        
        //
        // Delete the shim list for this layer       
        //
        DeleteShimFixList(pDataBase->pLayerFixes->pShimFixList);

        //
        // Delete the flags for this layer           
        //
        DeleteFlagFixList(pDataBase->pLayerFixes->pFlagFixList);

        delete (pDataBase->pLayerFixes);            
        pDataBase->pLayerFixes = pLayerFixNext;
    }

    //
    // Free the AppHelp
    //
    PAPPHELP pAppHelpNext;

    while (pDataBase->pAppHelp) {

        pAppHelpNext = pDataBase->pAppHelp->pNext;
        delete pDataBase->pAppHelp;
        pDataBase->pAppHelp = pAppHelpNext;
    }

    //
    // Free the exes of the local database.
    //
    PDBENTRY    pEntryNext = NULL;
    PDBENTRY    pApp = pDataBase->pEntries, pEntry = pDataBase->pEntries;

    while (pApp) {
        
        pEntry  = pApp;
        pApp    = pApp->pNext;

        while (pEntry) {

            pEntryNext = pEntry->pSameAppExe;
            delete pEntry;
            pEntry = pEntryNext;
        }
    }

    pDataBase->pEntries = NULL;
}   

BOOL
GetDatabaseEntries(
    IN  PCTSTR      szFullPath,
    IN  PDATABASE   pDataBase
    )
/*++

    GetDatabaseEntries

	Desc:	Reads in database contents. 
            If this is the system database, then we only read in the
            fix entries as the library section has been already read when we started up.
            For other databases reads in both the library section and the entries

	Params:   
        IN  PCTSTR      szFullPath: Full path of the database. If NULL we load the system database
        IN  PDATABASE   pDataBase:  Pointer to the database that we are going to populate

	Return:
        TRUE:   Success
        FALSE:  Failure
--*/
{  
    CSTRING     strMessage;
    TAGID       tiDatabase, tiLibrary, tiExe;
    BOOL        bOk                     = TRUE;
    WCHAR       wszShimDB[MAX_PATH * 2] = L"";
    PDB         pdb                     = NULL;
    UINT        uResult                 = 0;

    if (pDataBase == NULL) {
        assert(FALSE);
        return FALSE;
    }

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (pDataBase == &GlobalDataBase) {

        uResult = GetSystemWindowsDirectoryW(wszShimDB, MAX_PATH);

        if (uResult == 0 || uResult >= MAX_PATH) {

            bOk = FALSE;
            goto Cleanup;
        }

        ADD_PATH_SEPARATOR(wszShimDB, ARRAYSIZE(wszShimDB));
        StringCchCat(wszShimDB, ARRAYSIZE(wszShimDB), TEXT("AppPatch\\sysmain.sdb"));

    } else {

        if (StringCchPrintf(wszShimDB, ARRAYSIZE(wszShimDB), TEXT("%s"), szFullPath) != S_OK) {

            bOk = FALSE;
            goto Cleanup_Msg;
        }

        pDataBase->strPath = wszShimDB;
    }

    //
    // Open the database.
    //
    pdb = SdbOpenDatabase(wszShimDB, DOS_PATH);

    if (pdb == NULL) {

        Dbg(dlError, "Cannot open shim DB \"%ws\"\n", wszShimDB);
        bOk = FALSE;
        goto Cleanup_Msg;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == 0) {

        Dbg(dlError, "Cannot find TAG_DATABASE\n");
        bOk = FALSE;
        goto Cleanup_Msg;
    }
    
    TAGID   tiGuid = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);
    TAGID   tName  = NULL;

    //
    // Get the guid for the database
    //
    if (0 != tiGuid) {

        GUID* pGuid;

        pGuid = (GUID*)SdbGetBinaryTagData(pdb, tiGuid);

        TCHAR szGuid[128];
        *szGuid = 0;

        if (pGuid != NULL) {

            StringCchPrintf(szGuid,
                            ARRAYSIZE(szGuid),
                            TEXT ("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                            pGuid->Data1,
                            pGuid->Data2,
                            pGuid->Data3,
                            pGuid->Data4[0],
                            pGuid->Data4[1],
                            pGuid->Data4[2],
                            pGuid->Data4[3],
                            pGuid->Data4[4],
                            pGuid->Data4[5],
                            pGuid->Data4[6],
                            pGuid->Data4[7]);

            if (pDataBase != &GlobalDataBase &&
                 (!lstrcmpi(szGuid, GlobalDataBase.szGUID)
                  || !lstrcmpi(szGuid, GUID_APPHELP_SDB) 
                  || !lstrcmpi(szGuid, GUID_SYSTEST_SDB) 
                  || !lstrcmpi(szGuid, GUID_MSI_SDB)
                  || !lstrcmpi(szGuid, GUID_DRVMAIN_SDB))) {

                MessageBox(g_hDlg,
                           CSTRING(IDS_ERROR_SYSDB),
                           g_szAppName,
                           MB_ICONERROR);

                bOk = FALSE;
                goto Cleanup;
            }

            SafeCpyN(pDataBase->szGUID, szGuid, ARRAYSIZE(pDataBase->szGUID));
            
            //
            // Get the name of the database
            //
            tName = SdbFindFirstTag(pdb, tiDatabase, TAG_NAME);

            if (0 != tName) {
                pDataBase->strName = ReadDBString(pdb, tName);
            }

        } else {
            bOk = FALSE;
            goto Cleanup_Msg;
        }

    } else {
        bOk = FALSE;
        goto Cleanup_Msg;
    }

    if ((pDataBase->type == DATABASE_TYPE_WORKING) && CheckInstalled(pDataBase->strPath, 
                                                                     pDataBase->szGUID)) {

        MessageBox(g_hDlg,
                   GetString(IDS_TRYOPENINSTALLED),
                   g_szAppName,
                   MB_ICONWARNING);

        bOk = FALSE;
        goto Cleanup;
    }

    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (tiLibrary == 0) {

        Dbg(dlError, "Cannot find TAG_LIBRARY\n");
        bOk = FALSE;
        goto Cleanup_Msg;
    }

    if (pDataBase != &GlobalDataBase) {

        //
        // Fixes for the main database have been read when the program started.
        //
        ReadFixes(pdb, tiDatabase, tiLibrary, pDataBase);
    }  
    
    //
    // Loop through the EXEs.
    //
    tiExe = SdbFindFirstTag(pdb, tiDatabase, TAG_EXE);

    while (tiExe != TAGID_NULL) {
        AddEntry(pdb, tiExe, pDataBase); 
        tiExe = SdbFindNextTag(pdb, tiDatabase, tiExe);
    }

    //
    // Add the pDataBase to the DATABASELIST
    //
    if (pDataBase->type == DATABASE_TYPE_WORKING) {
        DataBaseList.Add(pDataBase);
    }

    goto Cleanup;

Cleanup_Msg:
    
    strMessage.Sprintf(GetString(IDS_ERROROPEN), wszShimDB);
    MessageBox(g_hDlg,
               strMessage,
               g_szAppName, 
               MB_ICONERROR);

Cleanup:
    if (pdb != NULL) {
        SdbCloseDatabase(pdb);
    }

    if (bOk == FALSE) {
        CleanupDbSupport(pDataBase);
    }

    SetCursor(LoadCursor(NULL, IDC_ARROW));
    return bOk;
}

BOOL
ReadMainDataBase(
    void
    )
/*++
    ReadMainDataBase
    
    Desc:   Read the library section of the main database
    
    Return:
        TRUE:   The library section of the main database was read successfully
        FALSE:  Otherwise
--*/
{
    PDB     pdb;
    TAGID   tiDatabase, tiLibrary;
    BOOL    bOk                 = TRUE;
    TCHAR   szShimDB[MAX_PATH * 2]  = TEXT("");
    TAGID   tName, tiGuid;
    UINT    uResult = 0;

    tiDatabase = tiLibrary = tName = tiGuid = NULL;

    uResult = GetSystemWindowsDirectory(szShimDB, MAX_PATH);

    if (uResult == 0 || uResult >= MAX_PATH) {
        assert(FALSE);
        return FALSE;
    }
    
    ADD_PATH_SEPARATOR(szShimDB, ARRAYSIZE(szShimDB));

    StringCchCat(szShimDB, ARRAYSIZE(szShimDB), TEXT("apppatch\\sysmain.sdb"));

    //
    // Open the database.
    //
    pdb = SdbOpenDatabase(szShimDB, DOS_PATH);

    if (pdb == NULL) {

        Dbg(dlError, "Cannot open shim DB \"%ws\"\n", szShimDB);
        bOk = FALSE;
        goto Cleanup;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == 0) {

        Dbg(dlError, "Cannot find TAG_DATABASE\n");
        bOk = FALSE;
        goto Cleanup;
    }

    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (tiLibrary == 0) {

        Dbg(dlError, "Cannot find TAG_LIBRARY\n");
        bOk = FALSE;
        goto Cleanup;
    }

    //
    // Read in the guid and the name of the system database.
    //
    tiGuid = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);

    if (0 != tiGuid) {

        GUID*   pGuid;
        TCHAR   szGuid[128];

        pGuid   = (GUID*)SdbGetBinaryTagData(pdb, tiGuid);

        if (pGuid != NULL) {

            *szGuid = 0;

            StringCchPrintf(szGuid,
                            ARRAYSIZE(szGuid),
                            TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                            pGuid->Data1,
                            pGuid->Data2,
                            pGuid->Data3,
                            pGuid->Data4[0],
                            pGuid->Data4[1],
                            pGuid->Data4[2],
                            pGuid->Data4[3],
                            pGuid->Data4[4],
                            pGuid->Data4[5],
                            pGuid->Data4[6],
                            pGuid->Data4[7]);

            SafeCpyN(GlobalDataBase.szGUID, szGuid, ARRAYSIZE(GlobalDataBase.szGUID));

            tName = SdbFindFirstTag(pdb, tiDatabase, TAG_NAME);

            if (0 != tName) {
                GlobalDataBase.strName = ReadDBString(pdb, tName);
            }

        } else {
            assert(FALSE);
            bOk = FALSE;
            goto Cleanup;
        }

    } else {                                  
        assert(FALSE);
        bOk = FALSE;
        goto Cleanup;
    }

    ReadFixes(pdb, tiDatabase, tiLibrary, &GlobalDataBase);

Cleanup:

    if (pdb != NULL) {
        SdbCloseDatabase(pdb);
    }   

    return bOk;

}

BOOL 
AttributesToXML(
    IN  OUT CSTRING&        strStr,
    IN      PMATCHINGFILE   pMatch
    )
/*++

    AttributesToXML

	Desc:	Appends the XML for the attributes of pMatch to strStr

	Params:
        IN  OUT CSTRING&        strStr: Appends the XML for the attributes of pMatch to this
        IN      PMATCHINGFILE   pMatch: The PMATCHINGFILE, whose attributes have to converted 
            to XML 

	Return: 
        TRUE:   Success
        FALSE:  Otherwise
--*/                                          
{
    TCHAR           szText[1024];
    CSTRING         strTemp;
    PATTRINFO_NEW   pAttr = NULL;

    *szText = 0;
    
    if (pMatch == NULL) {
        Dbg(dlError, "pMatch == NULL in AttributesToXML function");
        return FALSE;
    }

    pAttr = pMatch->attributeList.pAttribute;

    if (pAttr == NULL) {
        assert(FALSE);
        return FALSE;
    }

    //
    // For all the attributes see if it available (ATTRIBUTE_AVAILABLE) 
    // and if the user has selected this attribute (use the mask), if yes then
    // we get the formatted string for this attribute value that we can write to XML
    //
    for (DWORD dwIndex = 0; dwIndex < ATTRIBUTE_COUNT; ++dwIndex) {

        DWORD dwPos = TagToIndex(pAttr[dwIndex].tAttrID);

        if ((pAttr[dwIndex].dwFlags & ATTRIBUTE_AVAILABLE) 
            && dwPos != -1 
            && (pMatch->dwMask  & (1 << (dwPos + 1)))) {

            *szText = 0;

            SdbFormatAttribute(&pAttr[dwIndex], szText, ARRAYSIZE(szText));

            strStr.Strcat(TEXT(" "));
            strStr.Strcat(szText);
        }
    }

    return TRUE;
}

BOOL
CreateXMLForLUAAction(
    IN      PLUADATA        pLuaData,
    IN  OUT CSTRINGLIST*    strlXML
    )
/*++
    
    CreateXMLForLUAAction

	Desc:	Appends the action string for PLUADATA to strlXML     

	Params:
        IN      PLUADATA        pLuaData
        IN  OUT CSTRINGLIST*    strlXML

	Return:
        FALSE:  If there is some error
        TRUE:   Otherwise
        
    Notes:  Currently only one type of ACTION is supported for the LUA shims.
    
--*/
{
    TCHAR   szSpace[64];
    INT     iszSpaceSize = 0;

    iszSpaceSize = ARRAYSIZE(szSpace);

    CSTRING strTemp;
    
    strTemp.Sprintf(TEXT("%s<ACTION NAME = \"REDIRECT\" TYPE=\"ChangeACLs\">"), 
                    GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize));

    if (!strlXML->AddString(strTemp)) {
        return FALSE;
    }

    if (pLuaData == NULL) {
        strTemp.Sprintf(
            TEXT("%s<DATA NAME = \"AllUserDir\" VALUETYPE=\"STRING\" VALUE=\"%%ALLUSERSPROFILE%%\\Application Data\\Redirected\"/>"), 
                 GetSpace(szSpace, TAB_SIZE * 4, iszSpaceSize));
    } else {
        strTemp.Sprintf(
            TEXT("%s<DATA NAME = \"AllUserDir\" VALUETYPE=\"STRING\" VALUE=\"%s\"/>"), 
            GetSpace(szSpace, TAB_SIZE * 4, iszSpaceSize),
            pLuaData->strAllUserDir.SpecialCharToXML().pszString);
    }

    if (!strlXML->AddString(strTemp)) {
        return FALSE;
    }

    strTemp.Sprintf(TEXT("%s</ACTION>"), GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize));

    if (!strlXML->AddString(strTemp)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
CreateXMLForShimFixList(
    IN      PSHIM_FIX_LIST pShimFixList,
    IN  OUT CSTRINGLIST*    strlXML
    )
/*++

    CreateXMLForShimFixList

	Desc:	Creates XML for a pShimFixList chain 

	Params: 
        IN      PSHIM_FIX_LIST  pShimFixList:   The head of the shim fix list
        IN  OUT CSTRINGLIST*    strlXML:        We should append the XML to this

	Return:
        TRUE:   If success
        FALSE:  If error
--*/

{
    CSTRING strTemp;
    TCHAR   szSpace[64];
    INT     iszSpaceSize = 0;

    iszSpaceSize = ARRAYSIZE(szSpace);

    while (pShimFixList) {

        if (pShimFixList->pShimFix == NULL) {
            assert(FALSE);
            goto Next_ShimList;
        }
        
        //
        // Check if we have a specific commandline for this shim. For shims with lua data handled differently
        //
        if (pShimFixList->pLuaData) {
            strTemp.Sprintf(TEXT("%s<SHIM NAME=\"%s\" COMMAND_LINE=\"%%DbInfo%%\">"), 
                            GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                            pShimFixList->pShimFix->strName.SpecialCharToXML().pszString);

        } else if (pShimFixList->strCommandLine.Length()) {
        
            strTemp.Sprintf(TEXT("%s<SHIM NAME=\"%s\" COMMAND_LINE= \"%s\">"),
                            GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                            pShimFixList->pShimFix->strName.SpecialCharToXML().pszString,
                            pShimFixList->strCommandLine.SpecialCharToXML().pszString);            

        } else {
            strTemp.Sprintf(TEXT("%s<SHIM NAME=\"%s\">"),
                            GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                            pShimFixList->pShimFix->strName.SpecialCharToXML().pszString);
        }

        if (!strlXML->AddString(strTemp)) {
            return FALSE;
        }

        //
        // Look for INCLUSIONS & EXCLUSIONS
        //
        if (!pShimFixList->strlInExclude.IsEmpty()) {

            PSTRLIST pList = pShimFixList->strlInExclude.m_pHead;

            while (pList) {

                if (pList->data == INCLUDE) {

                    if (pList->szStr == GetString(IDS_INCLUDEMODULE)) {

                        strTemp.Sprintf(TEXT("%s<INCLUDE MODULE = \"%s\" />"), 
                                        GetSpace(szSpace, TAB_SIZE * 4, iszSpaceSize),
                                        TEXT("$"));

                    } else {
                        strTemp.Sprintf(TEXT("%s<INCLUDE MODULE = \"%s\" />"), 
                                        GetSpace(szSpace, TAB_SIZE * 4, iszSpaceSize),
                                        pList->szStr.SpecialCharToXML().pszString);
                    }
                    
                } else {

                    strTemp.Sprintf(TEXT("%s<EXCLUDE MODULE = \"%s\" />"), 
                                    GetSpace(szSpace, TAB_SIZE * 4, iszSpaceSize),
                                    pList->szStr.SpecialCharToXML().pszString);
                }
                
                if (!strlXML->AddString(strTemp)) {
                    return FALSE;
                }

                pList = pList->pNext;
            }
        }
        
        //
        // Get the LUA data.
        //
        if (pShimFixList->pLuaData) {
            LuaGenerateXML(pShimFixList->pLuaData, *strlXML);
        }

        strTemp.Sprintf(TEXT("%s</SHIM>"),
                        GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                        pShimFixList->pShimFix->strName.SpecialCharToXML().pszString);

        if (!strlXML->AddString(strTemp)) {
            return FALSE;
        }

        if (pShimFixList->pShimFix->strName == TEXT("LUARedirectFS")) {

            if (pShimFixList->pLuaData){

                //
                // If this entry has been customized we need to check if we should create
                // an ACTION node for it.
                //
                if (!(pShimFixList->pLuaData->strAllUserDir.isNULL())) {
                    CreateXMLForLUAAction(pShimFixList->pLuaData, strlXML);
                }
            } else {
                //
                // If we don't have any LUA data it means this hasn't been customized. 
                // We always create the default Redirected dir.
                //
                CreateXMLForLUAAction(NULL, strlXML);
            }
        }

Next_ShimList:

        pShimFixList = pShimFixList->pNext;
    }

    return TRUE;
}
            
BOOL
GetXML(
    IN  PDBENTRY        pEntry,
    IN  BOOL            bComplete,
    OUT CSTRINGLIST*    strlXML,
    IN  PDATABASE       pDataBase
    )
/*++

    GetXML

	Desc:	Gets the XML for a fix entry

	Params:
        IN PDBENTRY        pEntry:      The app or entry whose XML we want
        IN BOOL            bComplete:   Save  all entries for this app. 
            pEntry is the head of the list, i.e an app. Otherwise just get the XML for this
            entry
            
        OUT  CSTRINGLIST*    strlXML:   The XML has to be written into this 
        
        IN  PDATABASE       pDataBase:  The database for which we want to perform the operation

	Return:
        TRUE:   Success
        FALSE:  Otherwise
        
    Notes:  Also gets the XML for the entire library section. Will create a guid for the database
            If there is none and we are trying to do a save.
            
            During test run we do not care and allow the compiler to create a guid, but for 
            save since the guid member of the PDATABASE has to be updated if there is no guid,
            we create it ourselves
--*/        
{
    PSHIM_FIX_LIST  pShimFixList;
    CSTRING         strTemp;
    TCHAR           szSpace[64];
    INT             iszSpaceSize = 0;

    iszSpaceSize = ARRAYSIZE(szSpace);

    if (pDataBase == NULL) {
        assert(FALSE);
        return FALSE;
    }

    if (!strlXML->AddString(TEXT("<?xml version=\"1.0\" encoding=\"UTF-16\"?>"))) {
        return FALSE;
    }

    if (bComplete == FALSE) {
        //
        // This is a test-run, guid should be generated automatically
        //
        strTemp.Sprintf(TEXT("<DATABASE NAME=\"%s\">"),
                        pDataBase->strName.SpecialCharToXML().pszString);

    } else {

        //
        // We are trying to save the database, create a guid if it is not there
        //
        if (*(pDataBase->szGUID) == 0) {
            
            GUID Guid;

            CoCreateGuid(&Guid);

            StringCchPrintf(pDataBase->szGUID,
                            ARRAYSIZE(pDataBase->szGUID),
                            TEXT ("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                            Guid.Data1,
                            Guid.Data2,
                            Guid.Data3,
                            Guid.Data4[0],
                            Guid.Data4[1],
                            Guid.Data4[2],
                            Guid.Data4[3],
                            Guid.Data4[4],
                            Guid.Data4[5],
                            Guid.Data4[6],
                            Guid.Data4[7]);
        }

        strTemp.Sprintf(TEXT("<DATABASE NAME=\"%s\" ID = \"%s\">"),
                        pDataBase->strName.SpecialCharToXML().pszString,
                        pDataBase->szGUID);
    }
                    
    strlXML->AddString(strTemp);

    strTemp.Sprintf(TEXT("%s<LIBRARY>"), 
                    GetSpace(szSpace, TAB_SIZE * 1, iszSpaceSize));

    strlXML->AddString(strTemp);

    //
    // Put the AppHelp messages.
    //
    PAPPHELP pAppHelp = pDataBase->pAppHelp;

    while (pAppHelp) {

        CSTRING strName;

        strName.Sprintf(TEXT("%u"), pAppHelp->HTMLHELPID);

        strTemp.Sprintf(TEXT("%s<MESSAGE NAME = \"%s\" >"), 
                        GetSpace(szSpace, TAB_SIZE * 2, iszSpaceSize), 
                        strName.SpecialCharToXML().pszString);

        strlXML->AddString(strTemp);

        strTemp.Sprintf(TEXT("%s<SUMMARY>"), GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize));
        strlXML->AddString(strTemp);

        //
        // We must use SpecialCharToXML() and pass TRUE for the apphelp message as html 
        // tags are allowed. When we pass TRUE to SpecialCharToXML(), it understands that this is a AppHelp
        // message and ignores the <, > but handles &, " correctly
        //      
        strTemp.Sprintf(TEXT("%s%s"), 
                        GetSpace(szSpace, TAB_SIZE * 4, iszSpaceSize),
                        pAppHelp->strMessage.SpecialCharToXML(TRUE).pszString);

        strlXML->AddString(strTemp);

        strTemp.Sprintf(TEXT("%s</SUMMARY>"), GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize));
        strlXML->AddString(strTemp);

        strTemp.Sprintf(TEXT("%s</MESSAGE>"), GetSpace(szSpace, TAB_SIZE * 2, iszSpaceSize));
        strlXML->AddString(strTemp);

        pAppHelp = pAppHelp->pNext;
    }
    
    //
    // AppHelp Added to Library
    //
    PLAYER_FIX plf = pDataBase->pLayerFixes;

    while (plf) {

        strTemp.Sprintf(TEXT("%s<LAYER NAME=\"%s\">"), 
                        GetSpace(szSpace, TAB_SIZE * 2, iszSpaceSize),
                        plf->strName.SpecialCharToXML().pszString);
        
        strlXML->AddString(strTemp);

        pShimFixList = plf->pShimFixList;

        CreateXMLForShimFixList(pShimFixList, strlXML);
        
        //
        // Now the same story for the flags for this layer.
        //
        PFLAG_FIX_LIST pFlagFixList =  plf->pFlagFixList;

        while (pFlagFixList) {

            PFLAG_FIX pff = pFlagFixList->pFlagFix;

            if (pFlagFixList->strCommandLine.Length() == 0) {
                strTemp.Sprintf(TEXT("%s<FLAG NAME = \"%s\"/>"), 
                                GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                                pff->strName.SpecialCharToXML().pszString);
            } else {

                strTemp.Sprintf(TEXT("%s<FLAG NAME = \"%s\" COMMAND_LINE = \"%s\" />"), 
                                GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                                pff->strName.SpecialCharToXML().pszString, 
                                pFlagFixList->strCommandLine.SpecialCharToXML().pszString);
            }

            if (!strlXML->AddString(strTemp)) {
                return FALSE;
            }

            pFlagFixList = pFlagFixList->pNext;
        } 

        strTemp.Sprintf(TEXT("%s</LAYER>"), GetSpace(szSpace, TAB_SIZE * 2, iszSpaceSize));

        if (!strlXML->AddString(strTemp)) {
            return FALSE;
        }
            
        plf = plf->pNext;                        

    }

    strTemp.Sprintf(TEXT("%s</LIBRARY>"), GetSpace(szSpace, TAB_SIZE * 1, iszSpaceSize));

    if (!strlXML->AddString(strTemp)) {
        return FALSE;
    }

    //
    // Now for the EXE entries
    //
    if (!bComplete) {

        if (!GetEntryXML(strlXML, pEntry)) {
            return FALSE;
        }

    } else {
        //
        // Get the XML for all the entries
        //  
        for (PDBENTRY pApps = pEntry; pApps != NULL; pApps = pApps->pNext) {

            for (PDBENTRY pEntryinApp = pApps; 
                 pEntryinApp; 
                 pEntryinApp = pEntryinApp->pSameAppExe) {

                if (!GetEntryXML(strlXML, pEntryinApp)) {
                    return FALSE;
                }
            }
        }
    }

    if (!strlXML->AddString(TEXT("</DATABASE>"))) {
        return FALSE;
    }

    return TRUE;
}

BOOL
GetEntryXML(
    IN  OUT CSTRINGLIST* pstrlXML,
    IN      PDBENTRY pEntry
    )
/*++
    
    GetEntryXML

	Desc:	Gets the XML for an entry

	Params:   
        IN  OUT CSTRINGLIST* pstrlXML:  Append the XML to this
        IN      PDBENTRY pEntry:        Entry whose XML we want to get

	Return:
        TRUE:   Success
        FALSE:  Otherwise
--*/
{
    PSHIM_FIX_LIST      pShimFixList;
    PFLAG_FIX_LIST      pFlagFixList;
    PLAYER_FIX_LIST     pLayerFixList;
    PPATCH_FIX_LIST     pPatchFixList;
    TCHAR               szSpace[64];
    INT                 iszSpaceSize = 0;

    iszSpaceSize = ARRAYSIZE(szSpace);
    
    //
    // The App Info
    //
    if (pEntry == NULL || pstrlXML == NULL) {
        assert(FALSE);
        return FALSE;
    }

    CSTRING strTemp;


    strTemp.Sprintf(TEXT("%s<APP NAME=\"%s\" VENDOR=\"%s\">"),
                    GetSpace(szSpace, TAB_SIZE * 1, iszSpaceSize),
                    pEntry->strAppName.SpecialCharToXML().pszString,
                    pEntry->strVendor.SpecialCharToXML().pszString);

    if (!pstrlXML->AddString(strTemp)) {
        return FALSE;
    }

    if (pEntry->szGUID[0] == 0) {
        strTemp.Sprintf(TEXT("%s<EXE NAME=\"%s\""),
                        GetSpace(szSpace, TAB_SIZE * 2, iszSpaceSize),
                        pEntry->strExeName.SpecialCharToXML().pszString);
    } else {
        strTemp.Sprintf(TEXT("%s<EXE NAME=\"%s\" ID=\"%s\""),
                        GetSpace(szSpace, TAB_SIZE * 2, iszSpaceSize),
                        pEntry->strExeName.SpecialCharToXML().pszString,
                        pEntry->szGUID);
    }
    
    PMATCHINGFILE pMatch = pEntry->pFirstMatchingFile;

    //
    // Resolve for the "*". We need to get the attributes for the program being fixed
    //

    while (pMatch) {

        if (pMatch->strMatchName == TEXT("*")) {
            AttributesToXML(strTemp, pMatch);
            break;
        } else {
            pMatch = pMatch->pNext;
        }
    }

    strTemp.Strcat(TEXT(">"));
    
    if (!pstrlXML->AddString(strTemp)) {
        return FALSE;
    }

    //
    // Add the matching info
    //
    pMatch = pEntry->pFirstMatchingFile;

    while (pMatch) {
        //
        // We will ignore the program file being fixed(represented by *), because
        // we have already added its xml above
        //
        if (pMatch->strMatchName != TEXT("*")) {

            strTemp.Sprintf(TEXT("%s<MATCHING_FILE NAME=\"%s\""),
                            GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                            pMatch->strMatchName.SpecialCharToXML().pszString);

            AttributesToXML(strTemp, pMatch);

            strTemp.Strcat(TEXT("/>"));

            if (!pstrlXML->AddString(strTemp)) {
                return FALSE;
            }
        }

        pMatch = pMatch->pNext;
    }

    //
    // Add the layers
    //
    pLayerFixList   = pEntry->pFirstLayer;
    pShimFixList    = pEntry->pFirstShim;
    
    BOOL bCustomLayerFound = FALSE; // Does there exist a layer for this exe entry? 

    while (pLayerFixList) {

        if (pLayerFixList->pLayerFix == NULL) {
            assert(FALSE);
            goto Next_Layer;
        }

        if (pLayerFixList->pLayerFix->bCustom) {
            bCustomLayerFound = TRUE;
        }

        strTemp.Sprintf(TEXT("%s<LAYER NAME = \"%s\"/>"), 
                        GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                        pLayerFixList->pLayerFix->strName.SpecialCharToXML().pszString);
        
        if (!pstrlXML->AddString(strTemp)) {
            return FALSE;
        }

    Next_Layer:
        pLayerFixList = pLayerFixList->pNext;
    }

    if (g_bWin2K 
        && (bCustomLayerFound == TRUE || pShimFixList)
        && !IsShimInEntry(TEXT("Win2kPropagateLayer"), pEntry)) {

        //
        // On Win2K we need to add Win2kPropagateLayer shim to entries that have a shim 
        // or a custom layer. 
        //
        strTemp.Sprintf(TEXT("%s<SHIM NAME= \"Win2kPropagateLayer\"/>"), 
                        GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize));

        if (!pstrlXML->AddString(strTemp)) {
            return FALSE;
        }
    }

    //
    // Add the Shims for this exe
    //
    if (pShimFixList) {
        
        if (!CreateXMLForShimFixList(pShimFixList, pstrlXML)) {
            return FALSE;
        }   
    }

    //
    // Add the Patches
    //
    pPatchFixList = pEntry->pFirstPatch;

    while (pPatchFixList) {
    
        if (pPatchFixList->pPatchFix == NULL) {
            assert(FALSE);
            goto Next_Patch;
        }

        strTemp.Sprintf(TEXT("%s<PATCH NAME = \"%s\"/>"), 
                        GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                        pPatchFixList->pPatchFix->strName.SpecialCharToXML().pszString);

        if (!pstrlXML->AddString(strTemp)) {
            return FALSE;
        }

    Next_Patch:
        pPatchFixList = pPatchFixList->pNext;
    }

    //
    // Add the flags
    //
    pFlagFixList = pEntry->pFirstFlag;

    
    while (pFlagFixList) {

        if (pFlagFixList->pFlagFix == NULL) {
            assert(FALSE);
            goto Next_Flag;
        }

        if (pFlagFixList->strCommandLine.Length() == 0) {
            strTemp.Sprintf(TEXT("%s<FLAG NAME = \"%s\"/>"), 
                            GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                            pFlagFixList->pFlagFix->strName.SpecialCharToXML().pszString);
        } else {
            strTemp.Sprintf(TEXT("%s<FLAG NAME = \"%s\" COMMAND_LINE = \"%s\"/>"), 
                            GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                            pFlagFixList->pFlagFix->strName.SpecialCharToXML().pszString,
                            pFlagFixList->strCommandLine.SpecialCharToXML().pszString);
        }
        
        if (!pstrlXML->AddString(strTemp)) {
            return FALSE;
        }

Next_Flag:
        pFlagFixList = pFlagFixList->pNext;
    }

    //
    // Add the AppHelp
    //
    PAPPHELP pAppHelp = &(pEntry->appHelp);

    assert(pAppHelp);

    if (pAppHelp->bPresent) {

        CSTRING strBlock;

        if (pAppHelp->bBlock) {
            strBlock = TEXT("YES");
        } else {
            strBlock = TEXT("NO");
        }

        CSTRING strName;
        strName.Sprintf(TEXT("%u"), pAppHelp->HTMLHELPID);
        
        CSTRING strHelpID;
        strHelpID.Sprintf(TEXT("%u"), pAppHelp->HTMLHELPID);
        

        //
        // The URL is kept with the apphelp in the Library. Just as in the .SDB
        //
        pAppHelp = pEntry->appHelp.pAppHelpinLib;

        assert(pAppHelp);
        assert(pEntry->appHelp.HTMLHELPID == pAppHelp->HTMLHELPID);
        
        if (pAppHelp->strURL.Length()) {

            strTemp.Sprintf(TEXT("%s<APPHELP MESSAGE = \"%s\"  BLOCK = \"%s\"  HTMLHELPID = \"%s\" DETAILS_URL = \"%s\" />"),
                            GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                            strName.pszString,
                            strBlock.pszString,
                            strHelpID.pszString,
                            pAppHelp->strURL.SpecialCharToXML().pszString);
        } else {
            
            strTemp.Sprintf(TEXT("%s<APPHELP MESSAGE = \"%s\"  BLOCK = \"%s\"  HTMLHELPID = \"%s\" />"),
                            GetSpace(szSpace, TAB_SIZE * 3, iszSpaceSize),
                            strName.pszString, 
                            strBlock.pszString,
                            strHelpID.pszString);
        }

        if (!pstrlXML->AddString(strTemp)) {
            return FALSE;
        }
    }

    // End of AppHelp

    strTemp.Sprintf(TEXT("%s</EXE>"), GetSpace(szSpace, TAB_SIZE * 2, iszSpaceSize));

    if (!pstrlXML->AddString(strTemp)) {
        return FALSE;
    }

    strTemp.Sprintf(TEXT("%s</APP>"), GetSpace(szSpace, TAB_SIZE * 1, iszSpaceSize));

    if (!pstrlXML->AddString(strTemp)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
CheckForDBName(
    IN  PDATABASE pDatabase
    )
/*++
    CheckForDBName
    
    Description:    Prompts the user if the database name is still the default name
    
    Params:
        IN  PDATABASE pDatabase:    The pointer to the database, for which we need to make
            the check.    
    
    Return:
        TRUE:   The database name is now not the default name
        FALSE:  The databae name is still the default name
--*/
{
    
    BOOL    bOkayPressed = TRUE;
    CSTRING strNewDBName;

    //
    // Check if the database name is the default name that we provided. We should not 
    // allow that because the database name appears in the "Add and Remove" Programs list
    //
    while (pDatabase->strName.BeginsWith(GetString(IDS_DEF_DBNAME))) {
        //
        // Yes, it does
        //
        bOkayPressed = DialogBoxParam(g_hInstance,
                                      MAKEINTRESOURCE(IDD_DBRENAME),
                                      g_hDlg,
                                      DatabaseRenameDlgProc,
                                      (LPARAM)&strNewDBName);

        if (bOkayPressed == FALSE) {
            //
            // User pressed cancel, we must not save this database
            //
            goto End;

        } else {
            pDatabase->strName = strNewDBName;
        }
    }

End:
    return bOkayPressed;
}

BOOL
SaveDataBase(
    IN  PDATABASE   pDataBase,
    IN  CSTRING&    strFileName
    )
/*++
    
    SaveDataBase

	Desc:	Saves the database pDataBase in file strFileName

	Params:
        IN  PDATABASE pDataBase:    The database that we want to save
        IN  CSTRING &strFileName:   The file in which to save

	Return:
        TRUE:   Success
        FALSE:  Otherwise
--*/
{       
    BOOL        bOk = TRUE;
    CSTRINGLIST strlXML;
    CSTRING     strTemp;
    CSTRING     strCommandLine;
    TCHAR       szPath[MAX_PATH * 2];
    TCHAR       szXMLFileName[MAX_PATH];
    GUID        Guid;
    DWORD       dwCount = 0;
    
    *szPath = 0;
    
    if (!pDataBase || !strFileName.Length()) {
        assert(FALSE);
        bOk = FALSE;
        goto End;
    }

    //
    // Check if the database name has the default name. This routine will prompt
    // the user and lets the user change the name
    //
    if (!CheckForDBName(pDataBase)) {
        //
        // The user did not change the default database name, we must not save
        // the database
        //
        bOk = FALSE;
        goto End;
    }

    SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    dwCount = GetTempPath(MAX_PATH, szPath);

    if (dwCount == 0 || dwCount > MAX_PATH) {
        bOk = FALSE;
        goto End;
    }

    ADD_PATH_SEPARATOR(szPath, ARRAYSIZE(szPath));

    if (*(pDataBase->szGUID) == NULL) {
        //
        // We do not have a guid. Get that..
        //
        CoCreateGuid(&Guid);

        StringCchPrintf(pDataBase->szGUID,
                        ARRAYSIZE(pDataBase->szGUID),
                        TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                        Guid.Data1,
                        Guid.Data2,
                        Guid.Data3,
                        Guid.Data4[0],
                        Guid.Data4[1],
                        Guid.Data4[2],
                        Guid.Data4[3],
                        Guid.Data4[4],
                        Guid.Data4[5],
                        Guid.Data4[6],
                        Guid.Data4[7]);
    }

    StringCchPrintf(szXMLFileName, ARRAYSIZE(szXMLFileName), TEXT("%s.XML"), pDataBase->szGUID);

    szXMLFileName[ARRAYSIZE(szXMLFileName) - 1] = 0;

    StringCchCat(szPath, ARRAYSIZE(szPath), szXMLFileName);
    
    if (!GetXML(pDataBase->pEntries, TRUE, &strlXML, pDataBase)) {
        bOk = FALSE;
        goto End;
    }

    strTemp = szPath;

    if (!WriteXML(strTemp , &strlXML)) {

        bOk = FALSE;
        goto End;
    }

    strCommandLine.Sprintf(TEXT("custom \"%s\" \"%s\""),
                           (LPCTSTR)strTemp,
                           (LPCTSTR)strFileName);

    if (!InvokeCompiler(strCommandLine)) {

        MSGF(g_hDlg,
             g_szAppName,
             MB_ICONERROR,
             GetString(IDS_CANNOTSAVE),
             (LPCTSTR)pDataBase->strName);
        
        bOk = FALSE;
        goto End;
    }

    pDataBase->strPath  = strFileName;
    pDataBase->bChanged = FALSE;

    //
    // Add this name to the MRU list and refresh this MRU menu
    //
    AddToMRU(pDataBase->strPath);
    RefreshMRUMenu();

End:      

    SetCaption();
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    return bOk;
}

BOOL
SaveDataBaseAs(
    IN  PDATABASE pDataBase
    )
/*++
    
    SaveDataBaseAs

	Desc:	Saves the database pDataBase after prompting for a file name

	Params:
        IN  PDATABASE pDataBase:    The database that we want to save
        
	Return:
        TRUE:   Success
        FALSE:  Otherwise
--*/

{
    TCHAR   szBuffer1[MAX_PATH] = TEXT(""), szBuffer2[MAX_PATH] = TEXT("");
    CSTRING strCaption;
    CSTRING strFileName;
    BOOL    bOk = FALSE;

    if (pDataBase == NULL) {
        assert(FALSE);
        return FALSE;
    }

    //
    // Check if the database name has the default name. This routine will prompt
    // the user and lets the user change the name
    //
    if (!CheckForDBName(pDataBase)) {
        //
        // The user did not change the default database name, we must not save
        // the database
        //
        bOk = FALSE;
        goto End;
    }

    strCaption.Sprintf(TEXT("%s: \"%s\""), GetString(IDS_SAVE), pDataBase->strName);
    
    BOOL bResult = GetFileName(g_hDlg,
                               strCaption,
                               GetString(IDS_FILTER, szBuffer1, ARRAYSIZE(szBuffer1)),
                               TEXT(""),
                               GetString(IDS_SDB_EXT, szBuffer2, ARRAYSIZE(szBuffer2)),
                               OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
                               FALSE,
                               strFileName);
    //
    // Redraw the controls
    // 
    UpdateControls();
    
    if (bResult) {
       bOk = SaveDataBase(pDataBase, strFileName);
    } else {
        bOk = FALSE;
    }

End:       

    SetCaption();
    return bOk;
}

BOOL
CheckIfConflictingEntry(
    IN  PDATABASE   pDataBase,
    IN  PDBENTRY    pEntry,
    IN  PDBENTRY    pEntryBeingEdited,
    IN  PDBENTRY*   ppEntryFound, // (NULL)
    IN  PDBENTRY*   ppAppFound    // (NULL)
    )
/*++

    CheckIfConflictingEntry

	Desc:	Checks if some entry that will conflict with pEntry already exists in the database     
    
    Algo:   For all the entries in the database that have the same name as this 
            entry (we do not care for the application name), let us say an 
            existing entry with the same name as pEntry is X, we see if all 
            the matching files for the entry being checked (pEntry) are also similar to 
            some matching files in X
            
            If yes then we say that pEntry conflicts with X
            
            Two matching files are said to be similar if there does not any exist any attribute
            that has different values in these two matching files

	Params:   
        IN  PDATABASE   pDataBase           : The database in which to make the check
        IN  PDBENTRY    pEntry,             : The entry to check
        IN  PDBENTRY    pEntryBeingEdited   : This is required because when we check for existing 
            entries and we are editing an entry, then the entry being edited
            Will always match (well, not if we modify the matching file)         
    
        IN  PDBENTRY*   ppEntryFound (NULL) : If not NULL this will hold the conflicting entry
        IN  PDBENTRY*   ppAppFound   (NULL) : If not NULL this will hold the app of the conflicting entry 

	Return:
        TRUE:   There is a conflict
        FALSE:  Otherwise
--*/
{
    PDBENTRY pApps = NULL, pEntryExists = NULL;

    if (pDataBase == NULL || pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    for (pApps = pDataBase->pEntries;
         pApps != NULL; 
         pApps = pApps->pNext) {

        for (pEntryExists = pApps;
             pEntryExists;
             pEntryExists = pEntryExists->pSameAppExe) {

            if (pEntryExists == pEntryBeingEdited) {
                //
                // Do not compare with self. Also pEntryExists will never be NULL here(see the for loop)
                // So we will not enter here when we are creating a new entry as we pass
                // NULL for pEntryBeingEdited.
                //
                continue;
            }

            if (pEntryExists->strExeName == pEntry->strExeName) {

                for (PMATCHINGFILE pMatchNewEntry = pEntry->pFirstMatchingFile;
                     pMatchNewEntry != NULL;
                     pMatchNewEntry = pMatchNewEntry->pNext) {

                    BOOL bFound = FALSE;
                      
                    for (PMATCHINGFILE pMatchOldEntry = pEntryExists->pFirstMatchingFile;
                         pMatchOldEntry != NULL;
                         pMatchOldEntry = pMatchOldEntry->pNext) {

                        if (*pMatchNewEntry == *pMatchOldEntry) {
                            bFound = TRUE;
                            break;
                        }
                    }

                    if (bFound == FALSE) {
                        goto next_entry;
                    }
                }

                if (ppAppFound) {
                    *ppAppFound   = pApps;
                }
                
                if (ppEntryFound) {
                    *ppEntryFound = pEntryExists;
                }

                return TRUE;
            }

next_entry: ;

        }
    }

    return FALSE;
}

BOOL
CloseDataBase(
    IN  PDATABASE pDataBase
    )
/*++
    CloseDataBase

    Desc:   Closes the pDataBase database, prompts for save if not saved already.
            This routine will also remove the item for the database from the db tree.
            Only working databases can be closed.
            
            This routine first checks if the database is saved, if not prompts the user to save it.
            If the user, says CANCEL then we return FALSE.
            
            Otherwise we first remove the entry from the tree, then close the database 
            and return.
            
    Params:
        IN  PDATABASE pDataBase: Database to close    
            
    Return: 
        TRUE:   The database entry was removed from the tree and the database was 
                removed from the list of working databases.
        FALSE:  Otherwise
        
    Notes:  In some bizarre condition if DataBaseList.Remove(pDataBase) fails then we will end up
            removing the item from the tree but not from the database list. This is certainly a 
            big error but there is no need to worry as by then we are already totally messed up, 
            so as to come to this situation
            
            Please note that we must remove the entry before removing/deleting the database pointer,
            because in case we get the focus on the db tree item whose database has been deleted
            then the lParam of the database tree item will point to a freed memory location
--*/
{
    if (pDataBase == NULL) {
        assert(FALSE);
        return FALSE;
    }

    if (!CheckAndSave(pDataBase)) {
        return FALSE;
    }

    //
    // NOTE:    This routine will remove the entry and in the process set the focus 
    //          on some other entry. This will change the g_pPresentDatabase
    //
    if (!DBTree.RemoveDataBase(pDataBase->hItemDB , DATABASE_TYPE_WORKING)) {

        assert(FALSE);
        return FALSE;
    }

    //
    // Clear the entry tree so that we do not get any selection message there. We have to do this
    // because in the next step we are removing the database and if the tree view stays around and it
    // gets a sel change message somehow we may AV as: 
    //      1. CompatAdminDlgProc handles WM_NOTIFY for the entry tree
    //      2. HandleNotifyExeTree
    //      3. OnEntrySelChange
    //      4. GetItemType. 
    //  In GetItemType the pEntry for the entry tree is now no longer valid
    //
    //  We do not get this behavior if the focus is in the contents list
    //
    TreeDeleteAll(g_hwndEntryTree);
    g_pSelEntry = g_pEntrySelApp = NULL;

    //
    // Remove this database from the list of databases
    //
    PDATABASELIST pDataBaseList;

    if (pDataBase->type != DATABASE_TYPE_WORKING) {
        assert(FALSE);
        return FALSE;
    }

    return (DataBaseList.Remove(pDataBase));
}

void
GetNextSDBFileName(
    OUT CSTRING& strFileName,
    OUT CSTRING& strDBName
    )
/*++
    
    GetNextSDBFileName

	Desc:	Gets the next filename and then database name for a working database
            The file name is not the complete path but just the file name like
            Untitled_X
            
            The database name will be something like New Database(X)

	Params:
        OUT CSTRING &strFileName:   Will contain the filename
        OUT CSTRING &strDBName:     Will contain the database name

	Return:
        void
--*/

{
    BOOL bRepeat = TRUE;

    //
    // When we close the databases, we decrement g_uNextDataBaseIndex, so that it can become
    // 0, but we want to start from 1
    //
    if (g_uNextDataBaseIndex == 0) {
        g_uNextDataBaseIndex = 1;
    }

    strFileName.Sprintf(TEXT("%s_%u"), GetString(IDS_DEF_FILENAME), g_uNextDataBaseIndex);

    while (bRepeat) {

        PDATABASE pDatabase = DataBaseList.pDataBaseHead;
        strDBName.Sprintf(TEXT("%s(%u)"), GetString(IDS_DEF_DBNAME), g_uNextDataBaseIndex);

        //
        // Try to make sure that we do not have a database with  the same name.
        // This is not a strict rule and users can rename it to some existing open database
        //
        while (pDatabase) {

            if (pDatabase->strName == strDBName) {
                ++g_uNextDataBaseIndex;
                break;
            }

            pDatabase = pDatabase->pNext;
        }

        bRepeat = (pDatabase == NULL) ? FALSE : TRUE;
    }
}

BOOL
CompareLayers(
    IN  PLAYER_FIX pLayerOne,
    IN  PLAYER_FIX pLayerTwo
    )
/*++

    CompareLayers
    
	Desc:	Checks if two layers have the same stuff
    
    Algo:   Two layers will be said to be same if they have the same shims and fixes and for each 
            similar shim and fix, the parameters also tally.
            
            For shims two include-exclude lists will be said to be similar if they have the same modules
            and module types and the order of occurrence is also same

	Params:
        IN  PLAYER_FIX pLayerOne:   Layer 1
        IN  PLAYER_FIX pLayerTwo:   layer 2

	Return:
        TRUE:   Both layers have same stuff
        FALSE:  Otherwise
--*/

{
    BOOL bFound = FALSE;
    
    if (pLayerOne == NULL || pLayerTwo == NULL) {
        assert(FALSE);
        return FALSE;
    }

    //
    // First compare the flag Lists
    //
    int countOne = 0, countTwo = 0; // Number of elements in pFlag/ShimListOne/Two

    for (PFLAG_FIX_LIST pFlagListOne = pLayerOne->pFlagFixList;
         pFlagListOne;
         pFlagListOne = pFlagListOne->pNext) {

        countOne++;
        bFound = FALSE;

        for (PFLAG_FIX_LIST pFlagListTwo = pLayerTwo->pFlagFixList;
             pFlagListTwo;
             pFlagListTwo = pFlagListTwo->pNext) {

            if (pFlagListOne->pFlagFix == pFlagListTwo->pFlagFix) {

                if (pFlagListOne->strCommandLine != pFlagListTwo->strCommandLine) {
                    return FALSE;
                }

                bFound = TRUE;
                break;
            }
        }

        if (bFound == FALSE) {
            return FALSE;
        }
    }

    // TODO: Can optimize
    // Count the number of items in the second list.
    //
    countTwo = 0;

    for (PFLAG_FIX_LIST pFlagListTwo = pLayerTwo->pFlagFixList;
             pFlagListTwo;
             pFlagListTwo = pFlagListTwo->pNext) {

        countTwo++;
    }

    if (countOne != countTwo) {
        return FALSE;
    }

    bFound      = FALSE;
    countOne    = 0;

    for (PSHIM_FIX_LIST pShimListOne = pLayerOne->pShimFixList;
         pShimListOne;
         pShimListOne = pShimListOne->pNext) {

        bFound = FALSE;
        countOne++;

        for (PSHIM_FIX_LIST pShimListTwo = pLayerTwo->pShimFixList;
             pShimListTwo;
             pShimListTwo = pShimListTwo->pNext) {

            if (pShimListOne->pShimFix == pShimListTwo->pShimFix) {
                //
                // Now check if the command lines are same
                //
                if (pShimListOne->strCommandLine != pShimListTwo->strCommandLine) {

                    return FALSE;
                }
                //
                // Now check if the include exclude lists are same. Operator is overloaded
                //
                if (pShimListOne->strlInExclude != pShimListTwo->strlInExclude) {

                    return FALSE;
                }
                
                bFound = TRUE;
                break;
            }
        }

        if (bFound == FALSE) {
            return FALSE;
        }
    }

    countTwo = 0;

    for (PSHIM_FIX_LIST pShimListTwo = pLayerTwo->pShimFixList;
         pShimListTwo;
         pShimListTwo = pShimListTwo->pNext) {

        countTwo++;
    }

    return (countOne == countTwo);
}

BOOL
PasteSystemAppHelp(
    IN      PDBENTRY        pEntry,
    IN      PAPPHELP_DATA   pData,
    IN      PDATABASE       pDataBaseTo,
    OUT     PAPPHELP*       ppAppHelpInLib
    )
/*++

    PasteSystemAppHelp
    
    Desc:   This routine, copies the apphelp for the help-id present in apphelp.sdb,
            to the custom database specified by pDataBaseTo 
    
    Params:
        IN      PDBENTRY        pEntry:         The entry to which this apphelp message has been applied
        IN      PAPPHELP_DATA   pData:          Address of a APPHELP_DATA to pass to SdbReadApphelpDetailsData
            This contains among other things the HTMLHELPID of the message to be copied
            
        IN      PDATABASE       pDataBaseTo:    The database in which we want to copy this message to
        OUT     PAPPHELP*       ppAppHelpInLib: If not null Will contain a pointer to copied PAPPHELP
            in the library section of pDataBaseTo
        
    Return:
        TRUE:   Successful
        FALSE:  Otherwise
--*/
{
    PDB     pdbAppHelp  = NULL;
    BOOL    bOk         = TRUE;

    if (!pEntry || !pData || !pDataBaseTo) {
        
        assert (FALSE);
        return FALSE;
    }

    pdbAppHelp = SdbOpenApphelpDetailsDatabase(NULL);
    
    if (pdbAppHelp == NULL) {
        bOk = FALSE;
        goto end;
    }

    if (!SdbReadApphelpDetailsData(pdbAppHelp, pData)) {
        bOk = FALSE;
        goto end;
    }

    PAPPHELP pAppHelpNew = new APPHELP;

    if (NULL == pAppHelpNew) {

        MEM_ERR;
        bOk = FALSE;
        goto end;
    }
    
    pAppHelpNew->strURL     = pData->szURL;
    pAppHelpNew->strMessage = pData->szDetails;
    pAppHelpNew->HTMLHELPID = ++(pDataBaseTo->m_nMAXHELPID);
    pAppHelpNew->severity   = pEntry->appHelp.severity;
    pAppHelpNew->bBlock     = pEntry->appHelp.bBlock;

    pAppHelpNew->pNext      = pDataBaseTo->pAppHelp;
    pDataBaseTo->pAppHelp   = pAppHelpNew;

    if (ppAppHelpInLib) {
        *ppAppHelpInLib = pAppHelpNew;
    }

end:
    if (pdbAppHelp) {
        SdbCloseDatabase(pdbAppHelp);
        pdbAppHelp = NULL;
    }

    return bOk;
}

BOOL
PasteAppHelpMessage(
    IN      PAPPHELP    pAppHelp,
    IN      PDATABASE   pDataBaseTo,
    OUT     PAPPHELP*   ppAppHelpInLib
    )
/*++
    PasteAppHelpMessage
    
    Desc:   This routine is used to copy a single apphelp from a custom database 
            to some another database. This will be employed when we are copy pasting the
            DBENTRY ies from one database to another. The APPHELP pointed to by the 
            DBENTRY, in the library, has to be copied to the library of the second database.
            
    Notes:  This routine is to be used only when we are copying from a custom (working or installed)
            database, because for them we keep the app help data in the library.
            
            For system aka main or global database the apphelp that is kept in the lib section for
            custom databases is kept in apphelp.sdb so we employ PasteSystemAppHelp() for pasting
            system database apphelp messages
            
            Important:  Win2K SP3 does not have apphelp.sdb and SdbOpenApphelpDetailsDatabase(NULL)
                        will fail there, so we cannot copy-paste app help from the system 
                        database to a custom database in win2k
--*/
{
    PAPPHELP pAppHelpNew = NULL;

    if (pAppHelp == NULL || pDataBaseTo == NULL) {
        assert(FALSE);
        return FALSE;
    }

    pAppHelpNew = new APPHELP;

    if (pAppHelpNew == NULL) {
        MEM_ERR;
        return FALSE;
    }

    //
    // Copy all members of pAppHelp to pAppHelpNew
    //
    *pAppHelpNew = *pAppHelp;

    //
    // Now change the members that should change. 
    //
    pAppHelpNew->HTMLHELPID = ++(pDataBaseTo->m_nMAXHELPID);

    pAppHelpNew->pNext      = pDataBaseTo->pAppHelp;
    pDataBaseTo->pAppHelp   = pAppHelpNew;

    if (ppAppHelpInLib) {
        *ppAppHelpInLib = pAppHelpNew;
    }

    return TRUE;
}

INT
PasteLayer(
    IN      PLAYER_FIX      plf,
    IN      PDATABASE       pDataBaseTo,
    IN      BOOL            bForcePaste,        // (FALSE)
    OUT     PLAYER_FIX*     pplfNewInserted,    // (NULL)
    IN      BOOL            bShow               // (FALSE)
    )

/*++ 
    PasteLayer
    
    Desc:   Pastes single layer plf to pDataBaseTo
    
    Params:
        IN      PLAYER_FIX      plf:                    The layer to paste
        IN      PDATABASE       pDataBaseTo:            The database to paste into
        IN      BOOL            bForcePaste (FALSE):    This means that we do want to 
            copy the layer, even if there exists a layer with the same name and shims 
            in database
            
        OUT     PLAYER_FIX*     pplfNewInserted (NULL): Will contain the pointer to the 
            newly pasted layer or existing exactly similar layer
            
        IN      BOOL            bShow (FALSE):           Should we set the focus to the 
            newly created layer in the DBTree
            
    Return:
        0:  Copied, Note that we will return 0, if a layer already exists in this database
            with the same name and same set of fixes and bForce == FALSE
        -1: There was some error
        
     Algo:
    
        We proceed this way, for the modes to be pasted, we check if there exists some layer
        in the target database with the same name. If there does not exist then we just paste it.
        If there exists a layer with the same name then we check if the two layers are exactly 
        similar. 
        
        If they are exactly similar and bForcePaste is false then we quit. If they are exactly similar
        and bForcePaste is true then we will paste the layer. It will have a derived name though. e.g 
        suppose we want to copy layer foo, then the name of the new layer that will be pasted will 
        be foo(1). Both of them will have the same fixes. We will also do this if the names are similar 
        but the contents of the two layers are different.
        
        Under no circumstance will we allow two layers to have the same name in a database
        
        If there already exists a layer with the same name then we always make a new layer with a derived
        name. e.g suppose we want to copy layer foo, then the name of the new layer that 
        will be pasted will be foo(1)
        
    Notes:  This function is used when we copy-paste a layer from one db to another and also when we
            copy an entry from one database that is fixed with a custom layer. bForcePaste will be true
            if we are copying a layer from one database to another, but false if the routine is 
            getting called because we are trying to copy-paste an entry.
--*/                                        
{
    PLAYER_FIX  pLayerFound = NULL;
    INT         iReturn = -1;
    CSTRING     strName = plf->strName;
    CSTRING     strEvent;
    TCHAR       szNewLayerName[MAX_PATH];
                                                         
    //
    // Check if we have a layer with the same name in the target database or in 
    // the system database
    //
    pLayerFound = (PLAYER_FIX)FindFix(LPCTSTR(strName), FIX_LAYER, pDataBaseTo);

    if (pLayerFound) {
        //
        // Now we check if *plf is exactly same as *pLayerFound
        //
        if (pplfNewInserted) {
            *pplfNewInserted = pLayerFound;
        }

        if (!bForcePaste && CompareLayers(plf, pLayerFound)) {
            //
            // The layer already exists, do nothing
            //
            return 0;

        } else {
            //
            // Dissimilar or we want to force a paste, Get the unique name
            //
            *szNewLayerName = 0;
            strName = GetUniqueName(pDataBaseTo, 
                                    plf->strName, 
                                    szNewLayerName, 
                                    ARRAYSIZE(szNewLayerName),
                                    FIX_LAYER);
        }
    }

    //
    // Add this new layer for the second database.
    //
    PLAYER_FIX pLayerNew = new LAYER_FIX(TRUE);

    if (pLayerNew == NULL) {
        MEM_ERR;
        return -1;
    }

    //
    // Overloaded operator. Copy all the fields from plf to pLayerNew. Then we will
    // change the fields that need to be changed
    //
    *pLayerNew = *plf;

    //
    // Set the name of the layer. This might need to be changed, if we already had a layer
    // by the same name in the target database
    //
    pLayerNew->strName = strName;

    pLayerNew->pNext         = pDataBaseTo->pLayerFixes;
    pDataBaseTo->pLayerFixes = pLayerNew;

    if (pplfNewInserted) {
        *pplfNewInserted = pLayerNew;
    }

    if (plf->bCustom == FALSE) {
        //
        // System layer. We will have to add the event that a system layer had to be 
        // renamed
        //
        strEvent.Sprintf(GetString(IDS_EVENT_SYSTEM_RENAME), 
                         plf->strName.pszString,
                         szNewLayerName,
                         pDataBaseTo->strName.pszString);

       AppendEvent(EVENT_SYSTEM_RENAME, NULL, strEvent.pszString);

    } else {

        //
        // We will show the name of the layer as it is shown in the target database.
        // It  might have got changed in case there was a conflict
        //
        strEvent.Sprintf(GetString(IDS_EVENT_LAYER_COPYOK), 
                         plf->strName.pszString,
                         pDataBaseTo->strName.pszString,
                         pLayerNew->strName.pszString,
                         pDataBaseTo->strName.pszString);

        AppendEvent(EVENT_LAYER_COPYOK, NULL, strEvent.pszString);

    }

    DBTree.AddNewLayer(pDataBaseTo, pLayerNew, bShow);
    return 0;
}


BOOL
PasteMultipleLayers(
    IN   PDATABASE pDataBaseTo
    )
/*++
    PasteMultipleLayers

	Desc:	Pastes the layers that are copied to the clipboard to another database 

	Params:
        IN   PDATABASE pDataBaseTo: The database to copy the layers to

	Return:
        TRUE:   Success
        FALSE:  Error
        
    Notes:  The difference between PasteMultipleLayers and PasteAllLayers is that
            PasteMultipleLayers will only paste layers which are in the clipboard. 
            But PasteAllLayers will  copy all layers of the "From" database. So 
            PasteAllLayers only checks which database is the "From" database.
            
            PasteMultipleLayers is used when we select multiple items from the contents list
            (RHS). PasteAllLayers is used when we have selected the "Compatibility Modes" node
            in the db tree (LHS) while copying
            
--*/
{
    CopyStruct* pCopyTemp = gClipBoard.pClipBoardHead;

    //
    // Copy all the layers in the clipboard
    //
    while (pCopyTemp) {

        INT iRet = PasteLayer((PLAYER_FIX)pCopyTemp->lpData, 
                              pDataBaseTo, 
                              TRUE, 
                              NULL, 
                              FALSE);

        if (iRet == -1) {
            return FALSE;
        }

        pCopyTemp = pCopyTemp->pNext;
    }

    if (pDataBaseTo->hItemAllLayers) {

        TreeView_Expand(DBTree.m_hLibraryTree, pDataBaseTo->hItemAllLayers, TVE_EXPAND);
        TreeView_SelectItem(DBTree.m_hLibraryTree, pDataBaseTo->hItemAllLayers);
    }

    return TRUE;
}

BOOL
ShimFlagExistsInLayer(
    IN  LPVOID      lpData,
    IN  PLAYER_FIX  plf,
    IN  TYPE        type
    )
/*++
    
    ShimFlagExistsInLayer

    Desc:   Checks if the specified shim / flag pData is present in the layer plf.
            We just check if the layer contains this shim or flag, i.e. there is a 
            pointer in the PSHIM_FIX_LIST or PFLAG_FIX_LIST of the layer to the
            shim or flag
    
    Params:
        IN  LPVOID      lpData: The pointer to shim or flag that we want to look for
        IN  PLAYER_FIX  plf:    The layer in which we should be looking
        IN  TYPE        type:   One of a) FIX_SHIM b) FIX_FLAG
        
    Return:
        TRUE:   The fix exists in the layer
        FALSE:  Otherwise
--*/
{
    if (lpData == NULL || plf == NULL) {
        assert(FALSE);
        return FALSE;
    }

    //
    // First test for shims
    //
    if (type == FIX_SHIM) {

        PSHIM_FIX_LIST  psflInLayer = plf->pShimFixList;

        while (psflInLayer) {

            if (psflInLayer->pShimFix == (PSHIM_FIX)lpData) {
                return TRUE;
            }

            psflInLayer = psflInLayer->pNext;
        }

    } else if (type == FIX_FLAG) {

        //
        // Test for flags
        //
        PFLAG_FIX_LIST  pfflInLayer = plf->pFlagFixList;

        while (pfflInLayer) {

            if (pfflInLayer->pFlagFix == (PFLAG_FIX)lpData) {
                return TRUE;
            }

            pfflInLayer = pfflInLayer->pNext;
        }

    } else {

        //
        // Invalid type
        //
        assert(FALSE);
        return FALSE;
    }

    return FALSE;
}

BOOL
PasteShimsFlags(
    IN  PDATABASE pDataBaseTo
    )
/*++
    
    PasteShimsFlags
    
    Desc:   Copies the shims selected from the global database into the presently selected working
            database's presently selected layer
            If this shim is already present in the layer we do not 
            copy the shims, otherwise we copy this shim
            
            The layer in which we want to copy the shims/flags is the layer associated with the 
            presently selected hItem in the db tree
            
    Params:
        IN  PDATABASE pDataBaseTo: The database containing the layer in which we want to paste
            the copied shims to.
        
--*/
{
    CopyStruct* pCopyTemp       = gClipBoard.pClipBoardHead;
    HTREEITEM   hItemSelected   = TreeView_GetSelection(DBTree.m_hLibraryTree);
    LPARAM      lParam          = NULL;
    PLAYER_FIX  plf             = NULL;
    TYPE        type            = TYPE_UNKNOWN;
    LVITEM      lvitem          = {0};

    //
    // hItemSelected should be a layer, so that we can paste the shims into it
    //
    if (hItemSelected == NULL) {
        assert(FALSE);
        return FALSE;
    }

    if (!DBTree.GetLParam(hItemSelected, &lParam)) {
        assert(FALSE);
        return FALSE;
    }

    type = GetItemType(DBTree.m_hLibraryTree, hItemSelected);
    
    if (type != FIX_LAYER) {
        //
        // A layer should have been selected if we want to copy-paste shims
        //
        if (type == TYPE_GUI_LAYERS && GetFocus() == g_hwndContentsList) {
            //
            // We had the focus on the contents list view. Now lets us get the 
            // item that has the selection mark in the list view pretend that the user 
            // wants to paste the fixes in that tree item for the corresponding list view
            // item in the db tree
            //
            lvitem.mask     = LVIF_PARAM;
            lvitem.iItem    = ListView_GetSelectionMark(g_hwndContentsList);
            lvitem.iSubItem = 0;

            if (ListView_GetItem(g_hwndContentsList, &lvitem)) {
                //
                // Since the focus is at the contents list and type == TYPE_GUI_LAYERS and
                // we are going to  paste fixes we must be having the "Compatibility Modes" 
                // tree item selected in the db tree
                //
                hItemSelected = DBTree.FindChild(hItemSelected, 
                                                 lvitem.lParam);

                if (hItemSelected == NULL) {
                    assert(FALSE);
                    return FALSE;
                }

                //
                // Must set the lParam local variable to that of the list view item's lParam. The
                // list view item for a layer and the corresponding tree view item
                // in the db tree have the same lParam
                //
                lParam = lvitem.lParam;

            } else {
                //
                // could not get the lparam for the list item
                //
                assert(FALSE);
                return FALSE;
            }
            
        } else {
            //
            // We cannot paste fixes here
            //
            assert(FALSE);
            return FALSE;
        }
    }

    plf = (PLAYER_FIX)lParam;

    while (pCopyTemp) {

        //
        // First we check if this shim is already present in the layer, if yes then we do not 
        // copy this, otherwise we copy this shim
        //
        TYPE typeFix = ConvertLpVoid2Type(pCopyTemp->lpData);

        if (ShimFlagExistsInLayer(pCopyTemp->lpData, plf, typeFix)) {
            goto next_shim;
        }

        //
        // Now copy this shim or flag
        //
        if (typeFix == FIX_SHIM) {

            PSHIM_FIX_LIST psfl = new SHIM_FIX_LIST;
            PSHIM_FIX psfToCopy = (PSHIM_FIX)pCopyTemp->lpData;
        
            if (psfl == NULL) {
                MEM_ERR;
                return FALSE;
            }

            psfl->pShimFix      = psfToCopy;
            psfl->pNext         = plf->pShimFixList;
            plf->pShimFixList   = psfl;

            //
            // [Note:] We are not copying the parameters for the shim or flag because the shim or flag can be 
            // only selected from the system database. We need to change this if we allow copying of 
            // shims and layers from anywhere else except the system database.
            //

        } else if (typeFix == FIX_FLAG) {

            PFLAG_FIX_LIST pffl = new FLAG_FIX_LIST;
        
            if (pffl == NULL) {
                MEM_ERR;
                return FALSE;
            }

            pffl->pFlagFix      = (PFLAG_FIX)pCopyTemp->lpData;
            pffl->pNext         = plf->pFlagFixList;
            plf->pFlagFixList   = pffl;
        }

next_shim:
        pCopyTemp = pCopyTemp->pNext;
    }

    //
    // Now update this layer
    //
    DBTree.RefreshLayer(pDataBaseTo, plf);
    return TRUE;
}

BOOL
PasteAllLayers(
    IN   PDATABASE pDataBaseTo
    )
/*++
    PasteAllLayers
    
    Desc:   Copies the layers that are in the clipboard to some other database
            
    Params:
        IN  PDATABASE pDataBaseTo: The database in which we want to paste the modes
    
    Return:
        TRUE:   Success
        FALSE:  Error
        
    Notes:  The difference between PasteMultipleLayers and PasteAllLayers is that
            PasteMultipleLayers will only paste layers which are in the clipboard. But 
            PasteAllLayers will copy all layers of the "From" database. So 
            PasteAllLayers only checks which database is the "From" database.
            
            PasteMultipleLayers is used when we select multiple items from the contents list
            (RHS). PasteAllLayers is used when we have selected the "Compatibility Modes" node
            in the db tree (LHS) while copying
--*/
{

    PLAYER_FIX plf = gClipBoard.pDataBase->pLayerFixes;

    while (plf) {

        if (PasteLayer(plf, pDataBaseTo, TRUE, NULL, FALSE) == -1) {
            return FALSE;
        }

        plf = plf->pNext;
    }

    if (pDataBaseTo->hItemAllLayers) {

        TreeView_Expand(DBTree.m_hLibraryTree, pDataBaseTo->hItemAllLayers, TVE_EXPAND);
        TreeView_SelectItem(DBTree.m_hLibraryTree, pDataBaseTo->hItemAllLayers);
    }
    
    return TRUE;
    
}

void
FreeAppHelp(
    PAPPHELP_DATA pData
    )
{
    // bugbug: Do we need to free the strings with PAPPHELP_DATA <TODO>
}

INT
PasteSingleApp(
    IN  PDBENTRY  pApptoPaste,
    IN  PDATABASE pDataBaseTo,
    IN  PDATABASE pDataBaseFrom,   
    IN  BOOL      bAllExes,
    IN  PCTSTR    szNewAppNameIn //def = NULL       
    )
/*++
    Desc:   Pastes a single app into the database
    
    Params:
        IN  PDBENTRY  pApptoPaste:              App to paste
        IN  PDATABASE pDataBaseTo:              Database in which to paste
        IN  PDATABASE pDataBaseFrom:            Database from where we obtained the pApptoPaste
        IN  BOOL      bAllExes:                 Should we paste all exes for this app or only the entry 
            for pApptoPaste
            
        IN  PCTSTR    szNewAppNameIn (NULL):    If non null then the app name for the entries  should be 
            changed to this name
    
    Note:   We save the Previous value of the m_nMAXHELPID of the TO database. 
            The function PasteAppHelpMessage will modify that while pasting the 
            entries, we will again make use of this so that the entries point 
            to the correct apphelp messages in the database and also they contain 
            the correct HTMLHELPids.
            
    Return: 
        -1: There was some problem
        1:  Successful
--*/
{
    HCURSOR     hCursor             = GetCursor();
    UINT        uPrevMaxHtmldIdTo   = pDataBaseTo->m_nMAXHELPID; 
    CSTRING     strAppName          = pApptoPaste->strAppName;
    CSTRING     strNewname          = pApptoPaste->strAppName;
    PDBENTRY    pEntryToPaste       = pApptoPaste;
    PDBENTRY    pApp                = NULL;
    PDBENTRY    pEntryNew           = NULL;
    INT         iRet                = 0;
    BOOL        bConflictFound      = FALSE;
    CSTRING     strEvent; 
    INT         iReturn             = 1;

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Copy the layers
    //
    while (pEntryToPaste) {

        PDBENTRY    pEntryMatching       = NULL, pAppOfEntry = NULL;
        BOOL        bRepaint             = FALSE; //ReDraw the entry tree only if the entry to be deleted is in that!

        // The entry that we want to ignore while looking for conflicts. This variable
        // is used when we are doing a cut-paste on the same database, at that time we will like to ignore 
        // the entry that has been cut, during checking for conflicts
        //
        PDBENTRY    pEntryIgnoreMatching = NULL; 

        if (!bAllExes && g_bIsCut && pDataBaseFrom == pDataBaseTo && gClipBoard.SourceType == ENTRY_TREE) {

            pEntryIgnoreMatching = pApptoPaste;
        }

        if (CheckIfConflictingEntry(pDataBaseTo, 
                                    pEntryToPaste, 
                                    pEntryIgnoreMatching, 
                                    &pEntryMatching, 
                                    &pAppOfEntry)) {

           if (g_bEntryConflictDonotShow == FALSE) {
           
               *g_szData = 0;

               StringCchPrintf(g_szData, 
                               ARRAYSIZE(g_szData),
                               GetString(IDS_ENTRYCONFLICT), 
                               pEntryMatching->strExeName.pszString,
                               pEntryMatching->strAppName.pszString);

               iRet = DialogBoxParam(g_hInstance,
                                     MAKEINTRESOURCE(IDD_CONFLICTENTRY),
                                     g_hDlg,
                                     HandleConflictEntry,
                                     (LPARAM)g_szData);
        
               if (iRet == IDNO) {
                   goto NextEntry;
               }
               
               strEvent.Sprintf(GetString(IDS_EVENT_CONFLICT_ENTRY), 
                                pEntryMatching->strExeName.pszString,
                                pEntryMatching->strAppName.pszString,
                                pDataBaseTo->strName.pszString);

               AppendEvent(EVENT_CONFLICT_ENTRY, NULL, strEvent.pszString);
               bConflictFound   = TRUE;
           }
           
           //
           // Now copy the entry
           //
           HTREEITEM hItemSelected = DBTree.GetSelection();

           if (GetItemType(DBTree.m_hLibraryTree, hItemSelected) == TYPE_ENTRY) {

               LPARAM lParam;

               if (DBTree.GetLParam(hItemSelected, &lParam) && (PDBENTRY)lParam == pAppOfEntry) {
                   //
                   // The entry tree for the correct app is already visible. So we can paste directly there
                   //
                   bRepaint = TRUE;
               }
           }
        }

        pEntryNew = new DBENTRY;

        if (pEntryNew == NULL) {
            iRet = -1;
            goto End;
        }

        *pEntryNew = *pEntryToPaste;
        
        GUID Guid;

        CoCreateGuid(&Guid);

        StringCchPrintf(pEntryNew->szGUID,
                        ARRAYSIZE(pEntryNew->szGUID),
                        TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                        Guid.Data1,
                        Guid.Data2,
                        Guid.Data3,
                        Guid.Data4[0],
                        Guid.Data4[1],
                        Guid.Data4[2],
                        Guid.Data4[3],
                        Guid.Data4[4],
                        Guid.Data4[5],
                        Guid.Data4[6],
                        Guid.Data4[7]);
        //
        // Now set the flags as per the entry being copied.
        //
        SetDisabledStatus(HKEY_LOCAL_MACHINE, 
                          pEntryNew->szGUID, 
                          pEntryToPaste->bDisablePerMachine);

        //
        // Unfortunately, now the custom layers in the custom layer list for the entry
        // point to the custom layers in the From database, so correct that !
        //
        DeleteLayerFixList(pEntryNew->pFirstLayer);
        pEntryNew->pFirstLayer = NULL;

        PLAYER_FIX plfNewInserted = NULL; // The layer inserted by PasteLayer

        PLAYER_FIX_LIST plflExisting = pEntryToPaste->pFirstLayer;

        while (plflExisting) {

            assert(plflExisting->pLayerFix);

            PLAYER_FIX_LIST plflNew = new LAYER_FIX_LIST;

            if (plflExisting->pLayerFix->bCustom) {

                INT iRetLayerPaste = PasteLayer(plflExisting->pLayerFix, 
                                                pDataBaseTo, 
                                                FALSE, 
                                                &plfNewInserted, 
                                                FALSE);

                if (iRetLayerPaste == -1) {
                    
                    if (plflNew) {
                        delete plflNew;
                    }

                    if (pEntryNew) {
                        delete pEntryNew;
                    }

                    iRet = -1;
                    goto End;
                }

                plflNew->pLayerFix = plfNewInserted;

            } else {
                plflNew->pLayerFix = plflExisting->pLayerFix;
            }

            //
            // Add this layer list for the entry.
            //
            plflNew->pNext         = pEntryNew->pFirstLayer;
            pEntryNew->pFirstLayer = plflNew;

            plflExisting = plflExisting->pNext;
        }
        
        //
        // Now get the apphelp message as well.
        //
        PAPPHELP pAppHelpInLib = NULL;

        if (pDataBaseFrom->type != DATABASE_TYPE_GLOBAL && pEntryToPaste->appHelp.bPresent) {
            
            if (!PasteAppHelpMessage(pEntryToPaste->appHelp.pAppHelpinLib, 
                                     pDataBaseTo, 
                                     &pAppHelpInLib)) {

                iRet = -1;
                goto End;
            }

            pEntryNew->appHelp.HTMLHELPID    = ++uPrevMaxHtmldIdTo;
            assert(pAppHelpInLib);
            pEntryNew->appHelp.pAppHelpinLib = pAppHelpInLib;

        } else if (pDataBaseFrom->type == DATABASE_TYPE_GLOBAL && pEntryToPaste->appHelp.bPresent) {

            APPHELP_DATA AppHelpData;
            ZeroMemory(&AppHelpData, sizeof(AppHelpData));

            AppHelpData.dwHTMLHelpID = pEntryToPaste->appHelp.HTMLHELPID;

            if (!PasteSystemAppHelp(pEntryToPaste, &AppHelpData, pDataBaseTo, &pAppHelpInLib)) {
                //
                // We cannot copy apphelp in win2k
                //
                pEntryNew->appHelp.bPresent = FALSE;
                FreeAppHelp(&AppHelpData);

            } else {
                pEntryNew->appHelp.HTMLHELPID    = ++uPrevMaxHtmldIdTo;
                assert(pAppHelpInLib);
                pEntryNew->appHelp.pAppHelpinLib = pAppHelpInLib;
    
                FreeAppHelp(&AppHelpData);
            }
        }

        //
        // If We were passed the app name use that.
        //
        if (szNewAppNameIn != NULL) {
            pEntryNew->strAppName = szNewAppNameIn;

        }

        BOOL bNew;
        pApp = AddExeInApp(pEntryNew, &bNew, pDataBaseTo);

        if (bNew == TRUE) {
            pApp = NULL;
        }
        
        if (bConflictFound == FALSE) {
            //
            // We have been able to copy entry without any conflicts
            //
            strEvent.Sprintf(GetString(IDS_EVENT_ENTRY_COPYOK), 
                             pEntryNew->strExeName.pszString,
                             pEntryNew->strAppName.pszString,
                             pDataBaseFrom->strName.pszString,
                             pDataBaseTo->strName.pszString);

           AppendEvent(EVENT_ENTRY_COPYOK, NULL, strEvent.pszString);
        }

NextEntry:
        //
        // Copy all other entries only if asked.
        //
        pEntryToPaste = (bAllExes) ? pEntryToPaste->pSameAppExe: NULL;
    }

    if (pEntryNew) {
        DBTree.AddApp(pDataBaseTo, pEntryNew, TRUE);
    }

End:
    SetCursor(hCursor);

    return iRet;
}

BOOL
PasteMultipleApps(
    IN   PDATABASE pDataBaseTo
    )
/*++
    
    PasteMultipleApps
    
    Desc:   Copies multiple apps that have been copied to the clipboard
    
    Params:
        IN   PDATABASE pDataBaseTo:  The database to copy to
        
    Return:
        TRUE:   Success
        FALSE:  Error
--*/
{           
    CopyStruct* pCopyTemp   = gClipBoard.pClipBoardHead;
    int         iRet        = 0;

    while (pCopyTemp ) {
        
        iRet = PasteSingleApp((PDBENTRY) pCopyTemp->lpData, 
                              pDataBaseTo,
                              gClipBoard.pDataBase, 
                              TRUE);

        if (iRet == IDCANCEL || iRet == -1) {
            break;
        }

        pCopyTemp = pCopyTemp->pNext;
    }

    SendMessage(g_hwndEntryTree, WM_SETREDRAW, TRUE, 0);

    return iRet != -1 ? TRUE : FALSE;
}


BOOL
PasteAllApps(
    IN   PDATABASE pDataBaseTo
    )
/*++
    
    PasteAllApps
    
    Desc:   Copies all apps from one database to another. This routine is called when the user
            had pressed copy when the focus was on the "Applications" tree item for a database
    
    Params:
        IN   PDATABASE pDataBaseTo:  The database to copy to
        
    Return:
        TRUE:   Success
        FALSE:  Error
--*/
{
    if (gClipBoard.pDataBase == NULL) {
        assert(FALSE);
        return FALSE;
    }

    PDBENTRY pApp = gClipBoard.pDataBase->pEntries;

    int iRet = 0;

    while (pApp) {

        iRet = PasteSingleApp(pApp, pDataBaseTo, gClipBoard.pDataBase, TRUE);

        if (iRet == IDCANCEL || iRet == -1) {
            break;
        }

        pApp = pApp->pNext;
    }

    SendMessage(g_hwndEntryTree,
                WM_SETREDRAW,
                TRUE,
                0);

    return (iRet != -1) ? TRUE : FALSE;
}

void
ValidateClipBoard(
    IN  PDATABASE pDataBase, 
    IN  LPVOID    lpData
    )
/*++ 

    ValidateClipBoard
    
    Desc:   If the database is being closed and we have something from that database in the 
            clipboard Then the clipboard should be emptied.
            
            If we have some other data in the clipboard such as an entry or some layer in 
            the clipboard and that is removed we have to remove it from the clipboard as 
            well.
            
    Params: 
        IN  PDATABASE pDataBase:    Database being closed
        IN  LPVOID    lpData:       The entry or layer being removed
--*/

{
    if (pDataBase && pDataBase == gClipBoard.pDataBase) {
        gClipBoard.RemoveAll();
    } else if (lpData) {
        gClipBoard.CheckAndRemove(lpData);
    }
}

BOOL
RemoveApp(
    IN  PDATABASE   pDataBase,
    IN  PDBENTRY    pApp
    )
/*++

    RemoveApp
    
	Desc:	Removes the application pApp and all the entries of this app from pDataBase

	Params:
        IN   PDATABASE pDataBase:    The database in which pApp resides
        IN   PDBENTRY pApp:          The app to remove

	Return:
        void
--*/ 
{
    if (!pDataBase || !pApp) {
        assert(FALSE);
        return FALSE;
    }

    PDBENTRY pAppInDataBase = pDataBase->pEntries;
    PDBENTRY pAppPrev = NULL;

    //
    // Find the previous pointer of the app, so that we can remove this app
    //
    while (pAppInDataBase) { 

        if (pAppInDataBase == pApp) {
            break;
        }

        pAppPrev = pAppInDataBase;
        pAppInDataBase = pAppInDataBase->pNext;
    }

    if (pAppInDataBase) {
        //
        // We found the app
        //
        if (pAppPrev) {
            pAppPrev->pNext = pAppInDataBase->pNext;
        } else {
            //
            // The first app of the database matched
            //
            pDataBase->pEntries = pAppInDataBase->pNext;
        }
    }

    PDBENTRY pEntryTemp = pAppInDataBase;
    PDBENTRY pTempNext  = NULL;

    //
    // Delete all the entries of this app.
    //
    while (pEntryTemp) {

        pTempNext = pEntryTemp->pSameAppExe;

        ValidateClipBoard(NULL, pEntryTemp);
        delete pEntryTemp;
        pEntryTemp = pTempNext;
    }

    --pDataBase->uAppCount;

    return TRUE;
}

void
RemoveAllApps(
    IN  PDATABASE pDataBase
    )
/*++

    RemoveAllApps
    
	Desc:	Removes all the applications and all the entries from pDataBase. This will be invoked 
            when the user presses delete after when the focus was on the "Applications" 
            tree item for a database. Or when we want to cut all the applications

	Params:
        IN   PDATABASE pDataBase:    The database from which to remove all the entries

	Return:
        void
--*/
{
    while (pDataBase->pEntries) {
        //
        // pDataBase->pEntries will get modified in the following function, as it is the first element
        //
        RemoveApp(pDataBase, pDataBase->pEntries);
    }
}
    
BOOL
CheckForSDB(
    void
    )
/*++
    CheckForSDB

    Desc:    Attempts to locate sysmain.sdb in the apppatch directory.

--*/
{
    HANDLE  hFile;
    TCHAR   szSDBPath[MAX_PATH * 2];
    BOOL    fResult = FALSE;
    UINT    uResult = 0;

    uResult = GetSystemWindowsDirectory(szSDBPath, MAX_PATH);

    if (uResult == 0 || uResult >= MAX_PATH) {
        assert(FALSE);
        return FALSE;
    }

    ADD_PATH_SEPARATOR(szSDBPath, ARRAYSIZE(szSDBPath));

    StringCchCat(szSDBPath, ARRAYSIZE(szSDBPath), TEXT("apppatch\\sysmain.sdb"));
    
    hFile = CreateFile(szSDBPath,
                       GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (INVALID_HANDLE_VALUE != hFile) {
        CloseHandle(hFile);
        fResult = TRUE;
    } else {
        fResult = FALSE;
    }

    return (fResult);
}

BOOL
CheckIfInstalledDB(
    IN  PCTSTR  szGuid
    )
/*++

    CheckIfInstalledDB
    
    Desc:   Tests whether the szGuid matches with one of an installed database.
            This function assumes that all the installed databases are currently in 
            InstalledDataBaseList
    
    Params:        
        IN  PCTSTR  szGuid: The guid of the database that we want to check
        
    Return:
        TRUE:   If installed
        FALSE:  Otherwise
        
    Warn:   Do not do EnterCriticalSection(g_csInstalledList) in CheckIfInstalledDB()
            because CheckIfInstalledDB() is called by Qyery db as well when it tries
            to evaluate expressions and it might already have done a 
            EnterCriticalSection(g_csInstalledList)
            and then we will get a deadlock
--*/

{
    PDATABASE pDatabase = NULL;

    //
    // Was this a system database ?
    //
    if (!lstrcmpi(szGuid, GlobalDataBase.szGUID) 
        || !lstrcmpi(szGuid, GUID_APPHELP_SDB) 
        || !lstrcmpi(szGuid, GUID_SYSTEST_SDB) 
        || !lstrcmpi(szGuid, GUID_MSI_SDB) 
        || !lstrcmpi(szGuid, GUID_DRVMAIN_SDB)) {

        return TRUE;
    }

    pDatabase = InstalledDataBaseList.pDataBaseHead;

    while (pDatabase) {

        if (!lstrcmpi(pDatabase->szGUID, szGuid)) {
            return TRUE;
        }

        pDatabase = pDatabase->pNext;
    }

    return FALSE;
}


INT
GetLayerCount(
    IN  LPARAM lp,
    IN  TYPE   type
    )
/*++
    
    GetLayerCount    

	Desc:	Gets the number of layers applied to a entry or present in a database

	Params:   
        IN  LPARAM lp:      The pointer to an entry or a database
        IN  TYPE   type:    The type, either an entry (TYPE_ENTRY) or one of the DATABASE_TYPE_*

	Return:
        -1:         Error
        #Layers:    Otherwise
--*/
{   
    PLAYER_FIX_LIST plfl;
    PLAYER_FIX      plf;
    INT             iCount      = 0;
    PDATABASE       pDatabase   = NULL;
    PDBENTRY        pEntry      = NULL;

    if (lp == NULL) {
        assert(FALSE);
        return -1;
    }

    if (type == TYPE_ENTRY) {

        pEntry = (PDBENTRY)lp;

        plfl = pEntry->pFirstLayer;

        while (plfl) {

            ++iCount;
            plfl = plfl->pNext;
        }

        return iCount;
    }

    if (type == DATABASE_TYPE_GLOBAL 
        || type == DATABASE_TYPE_INSTALLED 
        || type == DATABASE_TYPE_WORKING) {

        pDatabase = (PDATABASE)lp;
        plf = pDatabase->pLayerFixes;

        while (plf) {

            ++iCount;
            plf = plf->pNext;
        }
    }

    return iCount;
}

INT
GetPatchCount(
    IN  LPARAM lp,
    IN  TYPE   type
    )
/*++
    
    GetPatchCount    

	Desc:	Gets the number of patches applied to a entry or present in a database

	Params:   
        IN  LPARAM lp:      The pointer to an entry or a database
        IN  TYPE   type:    The type, either an entry (TYPE_ENTRY) or one of the DATABASE_TYPE_*

	Return:
        -1:         Error
        #Patches:   Otherwise
--*/

{   
    PPATCH_FIX_LIST ppfl;
    PPATCH_FIX      ppf;
    INT             iCount = 0;

    if (lp == NULL) {
        return -1;
    }

    if (type == TYPE_ENTRY) {

        PDBENTRY pEntry = (PDBENTRY)lp;

        ppfl = pEntry->pFirstPatch;

        while (ppfl) {
            ++iCount;
            ppfl = ppfl->pNext;
        }

        return iCount;
    }

    if (type == DATABASE_TYPE_GLOBAL || type == DATABASE_TYPE_INSTALLED || type == DATABASE_TYPE_WORKING) {

        PDATABASE pDatabase = (PDATABASE)lp;
        ppf = pDatabase->pPatchFixes;

        while (ppf) { 
            ++iCount;
            ppf = ppf->pNext;
        }
    }

    return iCount;
}


INT
GetShimFlagCount(
    IN  LPARAM lp,
    IN  TYPE   type
    )
/*++
    
    GetShimFlagCount    

	Desc:	Gets the number of shims and flags applied to a entry or present in a database

	Params:   
        IN  LPARAM lp:      The pointer to an entry or a database
        IN  TYPE   type:    The type, either an entry (TYPE_ENTRY) or one of the DATABASE_TYPE_*, 
                            Or FIX_LAYER

	Return:
        -1:                 Error
        #shims and flags:   Otherwise
--*/

{   
    PSHIM_FIX_LIST  psfl    = NULL;
    PSHIM_FIX       psf     = NULL;
    PFLAG_FIX_LIST  pffl    = NULL;
    PFLAG_FIX       pff     = NULL;
    INT             iCount  = 0;

    if (lp == NULL) {
        assert(FALSE);
        return -1;
    }

    if (type == TYPE_ENTRY) {

        PDBENTRY pEntry = (PDBENTRY)lp;

        psfl = pEntry->pFirstShim;

        while (psfl) {

            ++iCount;
            psfl = psfl->pNext;
        }

        pffl = pEntry->pFirstFlag;
        
        while (pffl) {

            ++iCount;
            pffl = pffl->pNext;
        } 

        return iCount;

    } else if (type == DATABASE_TYPE_GLOBAL || type == DATABASE_TYPE_INSTALLED || type == DATABASE_TYPE_WORKING) {

        PDATABASE pDatabase = (PDATABASE)lp;
        psf = pDatabase->pShimFixes;

        while (psf) {
            
            ++iCount;
            psf = psf->pNext;
        }

        pff = pDatabase->pFlagFixes;

        while (pff) {
            
            ++iCount;
            pff = pff->pNext;
        }

        return iCount;

    } else if (type == FIX_LAYER) {

        PLAYER_FIX plf = (PLAYER_FIX)lp;
        psfl = plf->pShimFixList;

        while (psfl) {
            ++iCount;
            psfl = psfl->pNext;
        }

        pffl = plf->pFlagFixList;

        while (pffl) {
            
            ++iCount;
            pffl = pffl->pNext;
        }
    } else {
        assert(FALSE);
    }

    return iCount;
}

INT
GetMatchCount(
    IN  PDBENTRY pEntry
    )
/*++
    
    GetMatchCount
    
    Desc:   Returns the number of matching files used by an entry
    
    Params:
        IN  PDBENTRY pEntry: The entry whose number of matching files we want to get
        
    Return:
        -1: If error
        number of matching files: if success
    
--*/    
{
    if (pEntry == NULL) {
        assert(FALSE);
        return -1;
    }

    PMATCHINGFILE   pMatch  = pEntry->pFirstMatchingFile;
    INT             iCount  = 0;

    while (pMatch) {
        
        iCount++;
        pMatch = pMatch->pNext;
    }

    return iCount;
}

BOOL
IsUnique(
    IN  PDATABASE   pDatabase,
    IN  PCTSTR      szName,
    IN  UINT        uType
    )
/*++
    IsUnique
    
    Desc:   Tests whether the passed string already exists as an appname 
            or a layer name in the database pDatabase
            
    Params:
        IN  PDATABASE   pDatabase:  The database in which to search
        IN  PCTSTR      szName:     The string to search for
        IN  UINT        uType:      One of: 
        
            a) FIX_LAYER:   If it is FIX_LAYER, we should check if a 
                layer with the name szName already exists in the database. 
            
            b) TYPE_ENTRY:  If it is TYPE_ENTRY we should check if an app with the strAppName of szName 
                already exists in the database
--*/
{
    PLAYER_FIX plf      = NULL;
    PDBENTRY   pEntry   = NULL;

    if (pDatabase == NULL || szName == NULL) {

        assert(FALSE);
        return FALSE;
    }

    if (uType == FIX_LAYER) {

        plf = pDatabase->pLayerFixes;

        while (plf) {

            if (plf->strName == szName) {

                return FALSE;
            }

            plf = plf->pNext;
        }

        return TRUE;

    } else if (uType == TYPE_ENTRY) {

        pEntry = pDatabase->pEntries;

        while (pEntry) {

            if (pEntry->strAppName == szName) {

                return FALSE;
            }

            pEntry = pEntry->pNext;
        }   

        return TRUE;

    } else {

        //
        // Invalid TYPE
        //
        assert(FALSE);
    }

    return FALSE;
}

PTSTR
GetUniqueName(
    IN  PDATABASE   pDatabase,
    IN  PCTSTR      szExistingName,
    OUT PTSTR       szBuffer,
    IN  INT         cchBufferCount,
    IN  TYPE        type
    )
/*++
    GetUniqueName

	Desc:	Gets a unique name for a layer or an app

	Params:
        IN  PDATABASE   pDatabase:      The database in which to search
        IN  PCTSTR      szExistingName: The existing layer or app name
        OUT PTSTR       szBuffer:       The buffer where we put in the name
        IN  INT         cchBufferCount: The size of the buffer szBuffer in TCHARs
        IN  TYPE        type:           One of: a) FIX_LAYER b) TYPE_ENTRY:

	Return: Pointer to szBuffer. This will contain the new name   
--*/
{
    CSTRING     strNewname;
    TCHAR       szName[MAX_PATH];
    BOOL        bValid  = FALSE;
    UINT        uIndex  = 0;

    if (szBuffer == NULL) {
        assert(FALSE);
        return TEXT("X");
    }

    *szBuffer   = 0;
    *szName     = 0;

    SafeCpyN(szName, szExistingName, ARRAYSIZE(szName));
    
    //
    // Extract any number that occurs between () in the string, and increment that
    //
    TCHAR *pch = szName + lstrlen(szName);

    while (pch > szName) {

        if (*pch == TEXT(')')) {

            *pch = TEXT('\0');

        } else if (*pch == TEXT('(')) {

            *pch = TEXT('\0');

            uIndex = Atoi(pch + 1, &bValid);

            if (bValid) {
                ++uIndex;
            } else {
                SafeCpyN(szName, szExistingName, ARRAYSIZE(szName));
            }

            break;
        }
        --pch;
    }

    if (uIndex == 0) {

        uIndex = 1;
    }

    while (TRUE) {

        strNewname.Sprintf(TEXT("%s(%u)"), szName, uIndex);

        if (IsUnique(pDatabase, strNewname, type) == TRUE) {
            break;
        }

        uIndex++;
    }

    SafeCpyN(szBuffer, strNewname, cchBufferCount);
    return szBuffer;
}

PDBENTRY
GetAppForEntry(
    IN  PDATABASE   pDatabase,
    IN  PDBENTRY    pEntryToCheck
    )
/*++
    GetAppForEntry
    
    Desc:   Gets the app for the entry.
    
    Params:
        IN  PDATABASE   pDatabase:      The database in which to look
        IN  PDBENTRY    pEntryToCheck:  The entry whose app we need to find
    
    
    Return: The First PDBENTRY in the link list where this entry occurs, if it 
            occurs in the database
            
            NULL otherwise    
--*/
{
    PDBENTRY    pApp    = pDatabase->pEntries;
    PDBENTRY    pEntry  = pApp;

    while (pApp) {

        pEntry = pApp;

        while (pEntry) {
            if (pEntry == pEntryToCheck) {
                goto End;
            }

            pEntry = pEntry->pSameAppExe;
        }

        pApp = pApp->pNext;
    }

End:
    return pApp;
}

BOOL
GetDbGuid(
    OUT     PTSTR   pszGuid,
    IN      INT     cchpszGuid,
    IN      PDB     pdb
    )
/*++

    GetDbGuid
    
    Desc:   Gets the guid of the database specified by pdb in pszGuid
    
    OUT TCHAR*  pszGuid:    The guid will be stored in this
    IN  PDB     pdb:        The pdb of the database whose guid we want 
    
    Return: 
        TRUE:   Success
        FALSE:  Error
--*/
{
    
    BOOL    bOk         = FALSE;
    TAGID   tiDatabase  = NULL;
    TAGID   tName       = NULL;
    
    if (pszGuid == NULL || cchpszGuid == 0) {

        assert(FALSE);
        return FALSE;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == 0) {
        Dbg(dlError, "Cannot find TAG_DATABASE\n");
        bOk = FALSE;
        goto End;
    }

    tName = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);

    if (0 != tName) {

        GUID* pGuid;

        TAGID tiGuid = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);

        pGuid = (GUID*)SdbGetBinaryTagData(pdb, tiGuid);

        //BUGBUG: What about freeing this ?

        *pszGuid = 0;

        if (pszGuid != NULL) {
            StringCchPrintf(pszGuid,
                            cchpszGuid,
                            TEXT ("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                            pGuid->Data1,
                            pGuid->Data2,
                            pGuid->Data3,
                            pGuid->Data4[0],
                            pGuid->Data4[1],
                            pGuid->Data4[2],
                            pGuid->Data4[3],
                            pGuid->Data4[4],
                            pGuid->Data4[5],
                            pGuid->Data4[6],
                            pGuid->Data4[7]);

            bOk = TRUE;
        }
    }
End:
    return bOk;
}

BOOL
IsShimInEntry(
    IN  PCTSTR      szShimName,
    IN  PDBENTRY    pEntry
    )
/*++

    IsShimInEntry
    
    Desc:   Checks if the entry has the specified shim.
            We only check if the shim name matches, we do not check for parameters
            
    Params:
        IN  PCTSTR      szShimName: Name of the shim that we want to check for
        IN  PDBENTRY    pEntry:     Entry that we want to check in
--*/
{
    PSHIM_FIX_LIST psfl = NULL;

    if (pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    psfl = pEntry->pFirstShim;

    while (psfl) {
        if (psfl->pShimFix->strName == szShimName) {
            return TRUE;
        }

        psfl = psfl->pNext;
    }

    return FALSE;
}

BOOL
IsShimInlayer(
    IN  PLAYER_FIX      plf,
    IN  PSHIM_FIX       psf,
    IN  CSTRING*        pstrCommandLine,
    IN  CSTRINGLIST*    pstrlInEx
    )
/*++
    IsShimInlayer
    
    Desc:   Checks if the shim psf is present in the layer plf
    
    Params:
        IN  PLAYER_FIX      plf:                The layer to check in
        IN  PSHIM_FIX       psf:                The shim to check for
        IN  CSTRING*        pstrCommandLine:    Any command line for the shim
        IN  CSTRINGLIST*    pstrlInEx:          The pointer to the include-exclude list for the shim
    
    Return: TRUE if present
          : FALSE if not present  
--*/
{
    PSHIM_FIX_LIST psflInLayer = plf->pShimFixList;

    while (psflInLayer) {

        if (psflInLayer->pShimFix == psf) {
     
            if (pstrCommandLine && psflInLayer->strCommandLine != *pstrCommandLine) {
                goto Next_Loop;
            }

            if (pstrlInEx && *pstrlInEx != psflInLayer->strlInExclude) {
                goto Next_Loop;
            }

            return TRUE;
        }

Next_Loop:
    psflInLayer = psflInLayer->pNext;

    }

    return FALSE;
}

BOOL
IsFlagInlayer(
    PLAYER_FIX      plf,
    PFLAG_FIX       pff,
    CSTRING*        pstrCommandLine
    )
/*++
    IsFlagInlayer
    
    Desc:   Checks if the flag psf is present in the layer plf
    
    Params:
        IN  PLAYER_FIX      plf:                The layer to check in
        IN  PFLAG_FIX       pff:                The flag to check for
        IN  CSTRING*        pstrCommandLine:    Any command line for the flag
    
    Return: TRUE if present
          : FALSE if not present  
--*/
{
    PFLAG_FIX_LIST pfflInLayer = plf->pFlagFixList;

    while (pfflInLayer) {

        if (pfflInLayer->pFlagFix == pff) {
            if (pstrCommandLine && *pstrCommandLine != pff->strCommandLine) {
                goto Next_Loop;
            } else {
                return TRUE;
            }
        }
Next_Loop:
        pfflInLayer = pfflInLayer->pNext;
    }

    return FALSE;
}

void
PreprocessForSaveAs(
    IN  PDATABASE pDatabase
    )
/*++

    PreprocessForSaveAs 
    
    Desc:   This routine replaces the db guid and the entry guids with fresh guids.
            This routine is called just before we do a save as. This routine, 
            also makes sure that if there is a entry that is disabled then the 
            new guid for the entry also is set to disabled in the registry.
            
    Params:
        IN PDATABASE pDatabase: The database that we are going to save
--*/
{
    GUID        Guid;
    PDBENTRY    pEntry = NULL, pApp = NULL;
    
    if (pDatabase == NULL) {
        assert(FALSE);
        return;
    }

    CoCreateGuid(&Guid);

    StringCchPrintf(pDatabase->szGUID,
                    ARRAYSIZE(pDatabase->szGUID),
                    TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                    Guid.Data1,
                    Guid.Data2,
                    Guid.Data3,
                    Guid.Data4[0],
                    Guid.Data4[1],
                    Guid.Data4[2],
                    Guid.Data4[3],
                    Guid.Data4[4],
                    Guid.Data4[5],
                    Guid.Data4[6],
                    Guid.Data4[7]);

    pEntry = pDatabase->pEntries, pApp = pDatabase->pEntries;

    while (pEntry) {

        CoCreateGuid(&Guid);

        StringCchPrintf(pEntry->szGUID,
                        ARRAYSIZE(pEntry->szGUID),
                        TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                        Guid.Data1,
                        Guid.Data2,
                        Guid.Data3,
                        Guid.Data4[0],
                        Guid.Data4[1],
                        Guid.Data4[2],
                        Guid.Data4[3],
                        Guid.Data4[4],
                        Guid.Data4[5],
                        Guid.Data4[6],
                        Guid.Data4[7]);

        //
        // Now set the flags as per the entry being copied.
        //
        SetDisabledStatus(HKEY_LOCAL_MACHINE, 
                          pEntry->szGUID, 
                          pEntry->bDisablePerMachine);

        if (pEntry->pSameAppExe) {
            pEntry = pEntry->pSameAppExe;
        } else {
            pApp   = pApp->pNext; 
            pEntry = pApp;
        }
    }
}

void
ShowShimLog(
    void
    )
/*++
    
    ShowShimLog
        
    Desc:   Show the shim log file in notepad.

--*/
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR               szLogPath[MAX_PATH * 2];
    CSTRING             strCmd;
    CSTRING             strNotePadpath;
    UINT                uResult = 0;

    *szLogPath = 0;

    uResult = GetSystemWindowsDirectory(szLogPath, MAX_PATH);

    if (uResult == 0 || uResult >= MAX_PATH) {
        assert(FALSE);
        return;
    }

    ADD_PATH_SEPARATOR(szLogPath, ARRAYSIZE(szLogPath));

    StringCchCat(szLogPath, ARRAYSIZE(szLogPath), TEXT("AppPatch\\") SHIM_FILE_LOG_NAME);

    if (GetFileAttributes(szLogPath) == -1) {
        //
        // The log file does not exist
        //
        MessageBox(g_hDlg,
                   GetString(IDS_NO_LOGFILE),
                   g_szAppName,
                   MB_ICONEXCLAMATION | MB_OK);
        return;
    }
    
    strNotePadpath.GetSystemDirectory();
    strNotePadpath += TEXT("notepad.exe");
    //
    // Note the space at the end
    //
    strCmd.Sprintf(TEXT("\"%s\" "), (LPCTSTR)strNotePadpath, szLogPath);

    strCmd.Strcat(szLogPath);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    if (!CreateProcess(NULL,
                       (LPTSTR)strCmd,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {

        MessageBox(g_hDlg, GetString(IDS_NO_NOTEPAD), g_szAppName, MB_ICONEXCLAMATION);
        return;
    }

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
}

INT 
CopyShimFixList(
    IN  OUT PSHIM_FIX_LIST* ppsflDest,
    IN      PSHIM_FIX_LIST* ppsflSrc
    )
/*++
    Copy
    
    Desc:   Copies the *ppsflSrc to *ppsflDest. Removes any existing
            shims first
            
    Params:
        IN  OUT PSHIM_FIX_LIST* ppsflDest:  The pointer to shim fix list in which we want to copy
        IN      PSHIM_FIX_LIST* ppsflSrc:   The pointer to shim fix list from which we want to copy    
            
    Return: Number of shims copied
--*/
{   
    PSHIM_FIX_LIST  psflDestination = NULL;
    PSHIM_FIX_LIST  psflSrc         = NULL;
    PSHIM_FIX_LIST  psflTemp        = NULL;    
    INT             iCount          = 0;

    if (ppsflDest == NULL || ppsflSrc == NULL) {
        assert(FALSE);
        goto End;
    }
        
    psflDestination = *ppsflDest;
    psflSrc         = *ppsflSrc;

    //
    // Remove all the shims for this
    //
    DeleteShimFixList(psflDestination);
    psflDestination = NULL;

    //
    // Now do the copy
    //  
    //
    // Loop over the shims for psflSrc and add them to the destination shim fix list
    //
    while (psflSrc) {
        
        psflTemp = new SHIM_FIX_LIST;

        if (psflTemp == NULL) {
            MEM_ERR;
            goto End;
        }

        //
        // copy all the members for psflSrc
        //
        if (psflSrc->pLuaData) {
            //
            // Source has lua data so we need to get that
            //
            psflTemp->pLuaData = new LUADATA;

            if (psflTemp == NULL) {
                MEM_ERR;
                break;
            }

            psflTemp->pLuaData->Copy(psflSrc->pLuaData);
        }

        psflTemp->pShimFix          = psflSrc->pShimFix;
        psflTemp->strCommandLine    = psflSrc->strCommandLine;
        psflTemp->strlInExclude     = psflSrc->strlInExclude;

        if (psflDestination == NULL) {
            //
            // First item
            //
            psflDestination = psflTemp;

        } else {
            //
            // Insert at the beginning
            //
            psflTemp->pNext = psflDestination;
            psflDestination = psflTemp;
        }

        ++iCount; 

        psflSrc = psflSrc->pNext;
    } 

End:
    if (ppsflDest) {
        *ppsflDest = psflDestination;
    }

    return iCount;
}

BOOL
IsValidAppName(
    IN  PCTSTR  pszAppName
    )
/*++
    ValidAppName
    
    Desc:   Checks if the name can be used for an app. Since LUA wizard uses the app name
            to create directories, we should not allow the chars that are not allowed in file
            names
            
    Params:     
        IN  PCTSTR  pszAppName: The name that we want to check
        
    Return:
        TRUE:   The app name is valid
        FDALSE: Otherwise
--*/
{
    PCTSTR  pszIndex = pszAppName;

    if (pszIndex == NULL) {
        assert(FALSE);
        return FALSE;
    }

    while (*pszIndex) {
        if (_tcschr(TEXT("\\/?:*<>|\""), *pszIndex)) {
            return FALSE;
        }

        ++pszIndex;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\utils.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    Various utility functions
    
Author:

    kinshu created  July 2, 2001
    
Revision History:

--*/

#include "precomp.h"
#include "uxtheme.h"    // needed for tab control theme support

extern "C" {
BOOL ShimdbcExecute(LPCWSTR lpszCmdLine);
}

//////////////////////// Extern variables /////////////////////////////////////

extern TAG          g_Attributes[];
extern HANDLE       g_arrhEventNotify[]; 
extern HANDLE       g_hThreadWait;
extern HKEY         g_hKeyNotify[];
extern HWND         g_hDlg;
extern HINSTANCE    g_hInstance;
extern TCHAR        g_szAppPath[MAX_PATH];
extern BOOL         g_bDeletingEntryTree; 

///////////////////////////////////////////////////////////////////////////////

///////////////////////// Defines And Typedefs ////////////////////////////////

typedef void (CALLBACK *PFN_SHIMFLUSHCACHE)(HWND, HINSTANCE, LPSTR, int);

///////////////////////////////////////////////////////////////////////////////

///////////////////////// Function Declarations //////////////////////////////

BOOL 
WriteXML(
    CSTRING&        szFilename,
    CSTRINGLIST*    pString
    );

///////////////////////////////////////////////////////////////////////////////

///////////////////////// Global variables ////////////////////////////////////

// Process handle of the running exe. Set in InvokeExe
HANDLE  g_hTestRunExec;

// The name of the program file that is to be executed
CSTRING g_strTestFile;

// Commandline for the program file that has to be executed
CSTRING g_strCommandLine;

///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK
TestRunWait(
    IN  HWND    hWnd, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++

    TestRunWait
    
    Desc:   Handler for the Test Run Wait Dialog. This is the dialog that
            says "Waiting for Application to Finish"
    
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam: 0 we do not want to show the wait dialog
        
    Return: Standard dialog handler return
--*/
{
    switch (uMsg) {
    case WM_INITDIALOG:
        if (lParam == 0) {

            //
            // We do not wish to show the wait dialog
            //
            SendMessage(hWnd, WM_USER_TESTRUN_NODIALOG, 0, 0);
            ShowWindow(hWnd, SW_HIDE);

        } else {

            ShowWindow(hWnd, SW_SHOWNORMAL);
            SetTimer(hWnd, 0, 50, NULL);
        }

        return TRUE;

    case WM_TIMER:
        {
            //
            // Check if the app being test-run has terminated, if yes close the dialog
            //
            DWORD dwResult = WaitForSingleObject(g_hTestRunExec, 10);

            if (dwResult == WAIT_OBJECT_0) {
               KillTimer(hWnd, 0);
               EndDialog(hWnd, 0);
            }

            break;
        }

    case WM_USER_TESTRUN_NODIALOG:
        {
            
            //
            // Wait till the app being test run is running and then close the dialog
            //
            WaitForSingleObject(g_hTestRunExec, INFINITE);
            EndDialog(hWnd, 0);
        }

        break;        
    }

    return FALSE;
}


BOOL
InvokeEXE(
    IN  PCTSTR  szEXE, 
    IN  PCTSTR  szCommandLine, 
    IN  BOOL    bWait, 
    IN  BOOL    bDialog, 
    IN  BOOL    bConsole,
    IN  HWND    hwndParent = NULL
    )
/*++
    InvokeEXE

	Desc:	Creates the process and shows the wait dialog box

	Params:
    IN  PCTSTR  szEXE:                  Name of the program that is being executed
    IN  PCTSTR  szCommandLine:          Exe name and the command-line for the exe
    IN  BOOL    bWait:                  Should we wait till the app finishes?
    IN  BOOL    bDialog:                Should we show the wait dialog?
    IN  BOOL    bConsole:               If true, then we do not show any window
    IN  HWND    hwndParent (NULL):      The parent of the wait window, if it is created
        If this is NULL, then we set the main app window as the parent

	Return: 
        TRUE:   ShellExecuteEx was successful
        FALSE:  Otherewise
        
    Notes:  If bWait is FALSE, then this function will return immediately, otherwise it will 
            return when the new process has terminated
    
--*/
{
    BOOL                bCreate;
    SHELLEXECUTEINFO    shEx;

    ZeroMemory(&shEx, sizeof(SHELLEXECUTEINFO));

    if (hwndParent == NULL) {
        hwndParent = g_hDlg;
    }

    //
    // We need to disable the main window. After CreateProcess() the wizard that was 
    // modal till now starts behaving like a modeless wizard. We do not want the user to change
    // selections on the main dialog or start up some other wizard.
    //
    ENABLEWINDOW(g_hDlg, FALSE);

    shEx.cbSize         = sizeof(SHELLEXECUTEINFO);
    shEx.fMask          = SEE_MASK_NOCLOSEPROCESS;
    shEx.hwnd           = hwndParent;
    shEx.lpVerb         = TEXT("open");
    shEx.lpFile         = szEXE;
    shEx.lpParameters   = szCommandLine;
    shEx.nShow          = SW_SHOWNORMAL;


    bCreate = ShellExecuteEx(&shEx);
    
    if (bCreate && bWait) {
        //
        // We need to wait till the process has terminated
        //
        g_hTestRunExec = shEx.hProcess;

        //
        // If we have to show the wait dialog, bDialog should be TRUE
        //
        DialogBoxParam(g_hInstance,
                       MAKEINTRESOURCE(IDD_WAIT),
                       hwndParent,
                       TestRunWait,
                       (LPARAM)bDialog);    
        //
        // Now the app has terminated
        //
        if (shEx.hProcess) {
            CloseHandle(shEx.hProcess);
        }
    }

    //
    // Since the process has terminated let us now Enable the main window again
    //
    ENABLEWINDOW(g_hDlg, TRUE);

    return bCreate ? TRUE : FALSE;
}

BOOL
InvokeCompiler(
    IN  CSTRING& szInCommandLine
    )
/*++
    InvokeCompiler

	Desc:	Runs the database compiler: shimdbc. Shimdbc.dll is statically linked
            into CompatAdmin.exe

	Params:
        IN  CSTRING& szInCommandLine: Commandline to the compiler    

	Return:
        TRUE:   The compiler was executed successfully
        FALSE:  Otherwise
--*/
{
    CSTRING szCommandLine = szInCommandLine;
    
    szCommandLine.Sprintf(TEXT("shimdbc.exe %s"), (LPCTSTR)szInCommandLine);
    
    if (!ShimdbcExecute(szCommandLine)) {
        
        MessageBox(NULL,
                   CSTRING(IDS_COMPILER_ERROR),
                   g_szAppName,
                   MB_ICONERROR);
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
TestRunDlg(
    IN  HWND    hWnd, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++

    TestRunWait
    
    Desc:   Dialog proc for the test run dialog box. This dialog box, takes the 
            name of the program to execute and the commandlines 
    
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam: The PDBENTRY for then entry being test run
        
    Return: 
        TRUE:   Pressed OK
        FALSE:  Pressed Cancel
--*/
{
    static  CSTRING s_strExeName;

    switch (uMsg) {
    case WM_INITDIALOG:

        s_strExeName.Release();

        if ((PDBENTRY)lParam) {
            s_strExeName = ((PDBENTRY)lParam)->strExeName;
        }

        //
        // Set the file name of the program. g_strTestFile is set in TestRun() 
        //
        SetWindowText(GetDlgItem(hWnd, IDC_EXE), g_strTestFile);

        //
        // Change the OK button status properly
        //
        SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDC_EXE, EN_CHANGE), 0);

        SHAutoComplete(GetDlgItem(hWnd, IDC_EXE), AUTOCOMPLETE);

        //
        // Limit the length of the exe path
        //
        SendMessage(GetDlgItem(hWnd, IDC_EXE),
                    EM_LIMITTEXT,
                    (WPARAM)MAX_PATH - 1,
                    (LPARAM)0);

        SendMessage(GetDlgItem(hWnd, IDC_COMMANDLINE),
                    EM_LIMITTEXT,
                    (WPARAM)MAX_PATH - 1,
                    (LPARAM)0);

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_EXE:
            {
                if (EN_CHANGE == HIWORD(wParam)) {

                    HWND    hwndOkButton    = GetDlgItem(hWnd, IDOK);
                    INT     iLength         = 0;
                    TCHAR   szExeName[MAX_PATH];

                    *szExeName = 0;

                    //
                    // Disable the OK button if we do not have the complete path
                    //
                    GetDlgItemText(hWnd, IDC_EXE, szExeName, ARRAYSIZE(szExeName));
                    iLength = CSTRING::Trim(szExeName);

                    if (iLength < 3) {
                        //
                        // Cannot be a proper path
                        //
                        ENABLEWINDOW(hwndOkButton , FALSE);
                    } else {
                        //
                        // Ok button should be enabled if we have a 
                        // Local path or network path
                        //
                        if (NotCompletePath(szExeName)) {
                            ENABLEWINDOW(hwndOkButton, FALSE);
                        } else {
                            ENABLEWINDOW(hwndOkButton, TRUE);
                        }
                    }
                }
            }

            break;

        case IDC_BROWSE:
            {
                HWND    hwndFocus = GetFocus();
                CSTRING szFilename;
                TCHAR   szBuffer[MAX_PATH] = TEXT("");

                GetString(IDS_EXEFILTER, szBuffer, ARRAYSIZE(szBuffer));

                if (GetFileName(hWnd,
                                CSTRING(IDS_FINDEXECUTABLE),
                                szBuffer,
                                g_strTestFile,
                                TEXT(""),
                                OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
                                TRUE,
                                szFilename)) {

                    g_strTestFile = szFilename;

                    SetWindowText(GetDlgItem(hWnd, IDC_EXE), g_strTestFile);
                }
                
                SetFocus(hwndFocus);
                break;
            }

        case IDOK:
            {
                TCHAR szBuffer[MAX_PATH];

                *szBuffer = 0;

                GetWindowText(GetDlgItem(hWnd, IDC_EXE), szBuffer, ARRAYSIZE(szBuffer));

                //
                // Check if we are test running the correct file
                //
                if (s_strExeName != PathFindFileName(szBuffer)) {
                    //
                    // User did not give the complete path of the program being fixed.
                    //
                    MessageBox(hWnd, GetString(IDS_DOESNOTMATCH), g_szAppName, MB_ICONWARNING);
                    break;
                }

                g_strTestFile = szBuffer;

                *szBuffer = 0;
                GetWindowText(GetDlgItem(hWnd, IDC_COMMANDLINE), szBuffer, ARRAYSIZE(szBuffer));

                g_strCommandLine = szBuffer;

                EndDialog(hWnd, 1);
                break;
            }
        
        case IDCANCEL:
            EndDialog(hWnd, 0);
            break;
        }
    }

    return FALSE;
}

void
FlushCache(
    void
    )
/*++
    FlushCache

	Desc:	Calls FlushCache from apphelp.dll to flush the shim cache. We should flush the 
            cache before doing a test run

--*/
{
    PFN_SHIMFLUSHCACHE  pShimFlushCache;
    TCHAR               szLibPath[MAX_PATH * 2];
    HMODULE             hAppHelp    = NULL;
    UINT                uResult     = 0;
    K_SIZE              k_size      = MAX_PATH;

    *szLibPath = 0;

    uResult = GetSystemDirectory(szLibPath, k_size);

    if (uResult == 0 || uResult >= k_size) {

        Dbg(dlError, "%s - Failed to Execute GetSystemDirectory. Result was %d", __FUNCTION__, uResult);

        return;
    }

    ADD_PATH_SEPARATOR(szLibPath, ARRAYSIZE(szLibPath));

    StringCchCat(szLibPath, ARRAYSIZE(szLibPath), TEXT("apphelp.dll"));

    hAppHelp = LoadLibrary(szLibPath);

    if (hAppHelp) {
        pShimFlushCache = (PFN_SHIMFLUSHCACHE)GetProcAddress(hAppHelp, 
                                                             "ShimFlushCache");

        if (pShimFlushCache) {
            pShimFlushCache(NULL, NULL, NULL, 0);
        }

        FreeLibrary(hAppHelp);
    }
}

BOOL
TestRun(
    IN      PDBENTRY        pEntry, 
    IN  OUT CSTRING*        pszFile, 
    IN      CSTRING*        pszCommandLine,
    IN      HWND            hwndParent,
    IN      CSTRINGLIST*    pstrlXML    //(NULL)
    )
/*++

    TestRun

	Desc:	Pops up the test run dialog that lets users to test run programs. This is 
            interface for test running programs

	Params:
        IN  PDBENTRY            pEntry:             The entry that has to be test-run. We need this variable
            because we need to call GetXML which takes this as a param. If pszFile is NULL, then we get 
            the name of the program file from pEntry->strExeName
            
        IN  OUT CSTRING*        pszFile:            The file name of the program that has to be test-run
        IN      CSTRING*        pszCommandLine:     The command line for the program that has to be test-run
        IN      HWND            hwndParent:         The intended parent for the actual test-run dialog
        IN      CSTRINGLIST*    pstrlXML (NULL):    LUA wizard likes to give the XML generated using 
            LuapGenerateTrackXML

	Return: 
        TRUE:   Success
        FALSE:  There was some error or the user pressed CANCEL in the test run dialog
    
    Notes:  pEntry will be NULL if we have to run an app from the disk search window, 
            but we no longer allow that.
            
--*/
{
    CSTRING     strCommandLine, strFile, strSdbPath;
    CSTRINGLIST strlXMLTemp;
    TCHAR       szSystemDir[MAX_PATH * 2];
    TCHAR       szLogPath[MAX_PATH * 2];
    HWND        hwndFocus   = GetFocus();
    BOOL        bResult     = FALSE;
    UINT        uResult     = 0;
    
    g_strTestFile.Release();
    g_strCommandLine.Release();

    *szSystemDir = 0;

    if (pszFile && pszFile->Length()) {

        //
        // Set the name of the program that has to be executed. This will be used by the test-run dialog
        //
        g_strTestFile = *pszFile;

    } else {
        
        //
        // We have not been given the complete path, so we should get the name of the exe
        // from pEntry
        //
        if (pEntry == NULL) {
            goto End;
        }
        //
        // Set the name of the program that has to be executed. This will be used by the test-run dialog
        //
        g_strTestFile = pEntry->strExeName;
    }

    if (pszCommandLine && pszCommandLine->Length()) {
        
        //
        // Set the name of the command line for the program that has to be executed. 
        // This will be used by the test-run dialog
        //
        g_strCommandLine = *pszCommandLine;
    }

    //
    // Show the test run dialog
    //
    if (0 == DialogBoxParam(g_hInstance,
                            MAKEINTRESOURCE(IDD_TESTRUN),
                            hwndParent,
                            TestRunDlg,
                            (LPARAM)pEntry)) {
        //
        // Cancel pressed
        //
        goto End;
    }

    *szLogPath = 0;

    uResult = GetSystemWindowsDirectory(szLogPath, MAX_PATH);

    if (uResult == 0 || uResult >= MAX_PATH) {
        assert(FALSE);
        Dbg(dlError, "TestRun", "GetSystemWindowsDirectory failed");
        bResult = FALSE;
        goto End;
    }
    
    //
    // Set the SHIM_FILE_LOG env. variable so that we can show the shim log
    //
    ADD_PATH_SEPARATOR(szLogPath, ARRAYSIZE(szLogPath));

    StringCchCat(szLogPath, ARRAYSIZE(szLogPath), TEXT("AppPatch\\") SHIM_FILE_LOG_NAME);

    //
    // Delete previous log file if any
    //
    DeleteFile(szLogPath);

    SetEnvironmentVariable(TEXT("SHIM_FILE_LOG"), SHIM_FILE_LOG_NAME);

    //
    // If this is a system database, we do not need to create/install an sdb
    // OR If we are calling this TestRun from the disk search window also then we do not 
    // need to get any xml If we are calling TestRun from the disk search window, 
    // then we will already have the complete path (but not the pointer to the entry) 
    // and in that case pEtnry can be NULL
    //
    if ((g_pPresentDataBase && g_pPresentDataBase->type == DATABASE_TYPE_GLOBAL)
         || pEntry == NULL) {
        
        //
        // Flush the shim cache, so that we do not get the previous fixes. We are flushing it here
        // because we are not installing the test database as the entry resides in the system database
        //
        FlushCache();

        if (!InvokeEXE((LPCTSTR)g_strTestFile, (LPCTSTR)g_strCommandLine, TRUE, TRUE, TRUE, hwndParent)) {
            
            MessageBox(g_hDlg,
                       CSTRING(IDS_ERROREXECUTE),
                       g_szAppName,
                       MB_ICONERROR);

            bResult = FALSE;
            goto EXIT;
        }

        //
        // We are done, now eject...
        //
        return TRUE;
    }

    if (pstrlXML == NULL) {
        
        //
        // LUA wizard will provides its own XML, for other cases we must get that
        //
        BOOL bReturn =  GetXML(pEntry, FALSE, &strlXMLTemp, g_pPresentDataBase);
        
        if (!bReturn) {
            assert(FALSE);
            return FALSE;
        }

        pstrlXML = &strlXMLTemp;
    }

    uResult = GetSystemWindowsDirectory(szSystemDir, MAX_PATH);

    if (uResult == 0 || uResult >= MAX_PATH) {
        assert(FALSE);
        goto End;
    }

    //
    // Write the XML into AppPatch\\Test.XML
    //
    ADD_PATH_SEPARATOR(szSystemDir, ARRAYSIZE(szSystemDir));

    strFile.Sprintf(TEXT("%sAppPatch\\Test.XML"), szSystemDir);

    if (!WriteXML(strFile, pstrlXML)) {

        MessageBox(g_hDlg,
                   CSTRING(IDS_UNABLETOSAVETEMP),
                   g_szAppName,
                   MB_OK);

        goto End;
    }

    strCommandLine.Sprintf(TEXT("custom  \"%sAppPatch\\Test.XML\" \"%sAppPatch\\Test.SDB\""),
                          szSystemDir,
                          szSystemDir);
    
    if (!InvokeCompiler(strCommandLine)) {

        MessageBox(g_hDlg,
                   CSTRING(IDS_ERRORCOMPILE),
                   g_szAppName,
                   MB_ICONERROR);
        goto End;
    }
    
    //
    // No need to flush the shim cache, it is done when we install a database,
    // sdbinst.exe does it for us.
    //

    // Note the space after AppPatch\\Test.SDB 
    strSdbPath.Sprintf(TEXT("%sAppPatch\\Test.SDB  "),(LPCTSTR)szSystemDir);

    //
    // Install the test database
    //
    if (!InstallDatabase(strSdbPath, TEXT("-q"), FALSE)) {

        MessageBox(g_hDlg,
                    CSTRING(IDS_ERRORINSTALL),
                    g_szAppName,
                    MB_ICONERROR);
        goto EXIT;
    }

    //
    // Now execute the app to be test run
    //
    if (!InvokeEXE((LPCTSTR)g_strTestFile, (LPCTSTR)g_strCommandLine, TRUE, TRUE, TRUE, hwndParent)) {
        
        MessageBox(g_hDlg,
                   CSTRING(IDS_ERROREXECUTE),
                   g_szAppName,
                   MB_ICONERROR);

        goto EXIT;
    }
    
    //
    // Uninstall the test database
    //
    if (!InstallDatabase(strSdbPath, TEXT("-q -u"), FALSE)) {
        
        MessageBox(g_hDlg,
                   CSTRING(IDS_ERRORUNINSTALL),
                   g_szAppName,
                   MB_ICONERROR);
        goto EXIT;
    }

    bResult = TRUE;


EXIT:

    strCommandLine.Sprintf(TEXT("%sAppPatch\\Test.XML"), szSystemDir);
    DeleteFile(strCommandLine);

    strCommandLine.Sprintf(TEXT("%sAppPatch\\Test.SDB"), szSystemDir);
    DeleteFile(strCommandLine);

    //
    // If caller wants it, then return the app path that we executed. Caller might need it
    // because he was not having the compete path
    //
    if (bResult && pszFile) {
        *pszFile = g_strTestFile;
    }

End:
    
    return bResult;
}

VOID
FormatVersion(
    IN  ULONGLONG   ullBinVer,
    OUT PTSTR       pszText,
    IN  INT         chBuffSize    
    )
/*++

    FormatVersion

	Desc:	Formats a LARGE_INTEGER into a.b.c.d format

	Params:
        IN  LARGE_INTEGER   liBinVer:   The LARGE_INTEGER to format
        OUT LPTSTR          pszText:    The buffer that will store the complete formatted string
        IN  INT             chBuffSize: The size of the buffer in characters

	Return:
        void
--*/
{
    WORD    dwWord = 0;
    TCHAR   szTemp[10];

    if (chBuffSize < 16) {
        assert(FALSE);
        return;
    }

    *szTemp = 0;

    dwWord = WORD(ullBinVer >> 48);

    StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%d"), dwWord);
    StringCchCat(pszText, chBuffSize, szTemp);

    dwWord = (WORD)(ullBinVer >> 32);

    if (dwWord == 0xFFFF) {
        return;
    }
    
    StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT(".%d"), dwWord);
    StringCchCat(pszText, chBuffSize, szTemp);

    dwWord = (WORD)(ullBinVer >> 16);

    if (dwWord == 0xFFFF) {
        return;
    }

    StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT(".%d"), dwWord);
    StringCchCat(pszText, chBuffSize, szTemp);

    dwWord = (WORD)(ullBinVer);

    if (dwWord == 0xFFFF) {
        return;
    }

    StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT(".%d"), dwWord);
    StringCchCat(pszText, chBuffSize, szTemp);
}

BOOL
InstallDatabase(
    IN  CSTRING&    strPath,
    IN  PCTSTR      szOptions,
    IN  BOOL        bShowDialog
    )
/*++

    InstallDatabase

	Desc:	Installs or Uninstalls a database using sdbinst.exe. This guy lives in the system32 dir.

	Params:
        IN  CSTRING&    strPath:        The path of the database (.sdb) file
        IN  PCTSTR      szOptions:      The options to be passed to sdbinst.exe
        IN  BOOL        bShowDialog:    Should we show the dialog after the install/uninstall is over?
            We do not want to show that when we are doing a test run and we have to install the database

	Return:
        TRUE:   Success
        FALSE:  There was some error
--*/
{
    TCHAR   szSystemDir[MAX_PATH];
    CSTRING strSdbInstCommandLine;
    CSTRING strSdbInstExe;
    UINT    uResult = 0;

    *szSystemDir = 0;

    uResult = GetSystemDirectory(szSystemDir, MAX_PATH);

    if (uResult == 0 || uResult >= MAX_PATH) {
        assert(FALSE);
        return FALSE;
    }

    ADD_PATH_SEPARATOR(szSystemDir, ARRAYSIZE(szSystemDir));

    strSdbInstExe.Sprintf(TEXT("%ssdbinst.exe"), szSystemDir);

    strSdbInstCommandLine.Sprintf(TEXT("%s \"%s\"  "),
                                  szOptions,
                                  strPath.pszString);

    BOOL bOk = TRUE;

    HWND hwndFocus = GetFocus();

    //
    // We do not want the installed database list and tree items to get refreshed 
    // when we are (un)installing 
    // a database because of Test Run. If user is actually (un)installing a database 
    // then we manually refresh the list in the handler for the corresonding WM_COMMAND
    //
    g_bUpdateInstalledRequired = FALSE;
    
    //
    // Stall the thread that refreshes the installed databases list and tree items
    //
    while (SuspendThread(g_hThreadWait) == -1) {
        ;
    }

    //
    // Call sdbinst.exe
    //
    if (!InvokeEXE((LPCTSTR)strSdbInstExe, (LPCTSTR)strSdbInstCommandLine, TRUE, FALSE, FALSE, g_hDlg)) {

        MessageBox(g_hDlg,
                   CSTRING(IDS_ERRORINSTALL),
                   g_szAppName,
                   MB_ICONERROR);    

        bOk = FALSE;

    } else {

        //
        // Show the Dialog only if quiet mode is off
        //
        if (bShowDialog) {

            CSTRING strMessage;

            if (_tcschr(szOptions, TEXT('u')) || _tcschr(szOptions, TEXT('g'))) {
                //
                // Uninstalling database
                //
                strMessage.Sprintf(GetString(IDS_UINSTALL), 
                                   g_pPresentDataBase->strName);

            } else {
                //
                // Installing database
                //
                strMessage.Sprintf(GetString(IDS_INSTALL), 
                                   g_pPresentDataBase->strName);
            }

            MessageBox(g_hDlg, strMessage.pszString, g_szAppName, MB_ICONINFORMATION);
        }
    }

    //
    // Listen for app compat regsitry changes
    //
    RegNotifyChangeKeyValue(g_hKeyNotify[IND_ALLUSERS],
                            TRUE, 
                            REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
                                REG_NOTIFY_CHANGE_LAST_SET,
                            g_arrhEventNotify[IND_ALLUSERS],
                            TRUE);

    RegNotifyChangeKeyValue(g_hKeyNotify[IND_ALLUSERS], 
                            TRUE, 
                            REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
                                REG_NOTIFY_CHANGE_LAST_SET,
                            g_arrhEventNotify[IND_PERUSER],
                            TRUE);

    SetFocus(hwndFocus);

    //
    // Resume the thread that refreshes the installed databases list and tree items
    //
    ResumeThread(g_hThreadWait);

    return bOk;
}

void
CenterWindow(
    IN  HWND hParent,
    IN  HWND hWnd
    )
/*++

    CenterWindow

	Desc:	Centers a dialog wrt to its parent

	Params: 
        IN  HWND hParent:   The parent of the dialog to center
        IN  HWND hWnd:      The dialog to center

	Return:
        void
--*/
{

    RECT    rRect;
    RECT    rParentRect;
    
    GetWindowRect(hWnd, &rRect);
    GetWindowRect(hParent, &rParentRect);
    
    //
    // Compute actual width and height
    //
    rRect.right     -= rRect.left;
    rRect.bottom    -= rRect.top;
    
    rParentRect.right   -= rParentRect.left;
    rParentRect.bottom  -= rParentRect.top;
    
    int     nX;
    int     nY;
    
    //
    // Resolve X, Y location required to center whole window.
    //
    nX = (rParentRect.right - rRect.right) / 2;
    nY = (rParentRect.bottom - rRect.bottom) / 2;
    
    //
    // Move the window to the center location.
    //
    MoveWindow(hWnd,
               rRect.left + nX,
               rRect.top + nY,
               rRect.right,
               rRect.bottom,
               TRUE);

}

int
CDECL
MSGF(
    IN  HWND    hwndParent,
    IN  PCTSTR  pszCaption,
    IN  UINT    uType,
    IN  PCTSTR  pszFormat,
    ...
    )
/*++

    MSGF
    
	Desc:	Variable argument MessageBox

	Params: 
        IN  HWND    hwndParent: The parent for the message box
        IN  PCTSTR  pszCaption: The caption for the message box
        IN  UINT    uType:      The messagebox type param
        IN  PCTSTR  pszFormat:  The format string

	Return: Whatever MessageBox() returns
--*/
{
    TCHAR szBuffer[1024];

    *szBuffer = 0;

    va_list pArgList;
    va_start(pArgList, pszFormat);

    StringCchVPrintf(szBuffer, ARRAYSIZE(szBuffer), pszFormat, pArgList);

    va_end(pArgList);

    return MessageBox(hwndParent,
                      szBuffer,
                      pszCaption,
                      uType);

}

void
EnableTabBackground(
    IN  HWND hDlg
    )
/*++

    EnableTabBackground

	Desc:	Makes the back ground of a dialog blend with the tab background. Enables the texture

	Params:
        IN  HWND hDlg:  The dialog box to whose back ground we want to change

	Return:
        void
--*/
{
    PFNEnableThemeDialogTexture pFnEnableThemeDialogTexture;
    HMODULE                     hUxTheme;
    TCHAR                       szThemeManager[MAX_PATH * 2];
    UINT                        uResult = 0;

    *szThemeManager = 0;

    uResult = GetSystemDirectory(szThemeManager, MAX_PATH);

    if (uResult == 0 || uResult >= MAX_PATH) {
        assert(FALSE);
        return;
    }

    ADD_PATH_SEPARATOR(szThemeManager, ARRAYSIZE(szThemeManager));

    StringCchCat(szThemeManager, ARRAYSIZE(szThemeManager), _T("uxtheme.dll"));
    
    hUxTheme = (HMODULE)LoadLibrary(szThemeManager);

    if (hUxTheme) {
        pFnEnableThemeDialogTexture = (PFNEnableThemeDialogTexture)
                                            GetProcAddress(hUxTheme, "EnableThemeDialogTexture");
        if (pFnEnableThemeDialogTexture) {
            pFnEnableThemeDialogTexture(hDlg, 4 /*ETDT_USETABTEXTURE*/);
        }
        
        FreeLibrary(hUxTheme);
    }
}

int
TagToIndex(
    IN  TAG tag
    )
/*++
    TagToIndex
    
    Desc:   Gets the The index in the attribute info array (g_rgAttributeTags)
    
    Return: The index in the attribute info array (g_rgAttributeTags), if found.
            -1: Otherwise
            
    Note:   
--*/
{
    int i;
    int iAttrCount = (int)ATTRIBUTE_COUNT;

    for (i = 0; i < iAttrCount; i++) {
        if (tag == g_Attributes[i]) {
            return i;
        }
    }

    return -1;
}

PTSTR
GetString(
    IN  UINT    iResource,
    OUT PTSTR   pszStr,     //(NULL)
    IN  INT     nLength     //(0) bytes
    )
/*++

    GetString

	Desc:	Wrapper for LoadString. If pszStr == NULL, then loads the resouce string in a static
            TCHAR[1024] and returns the pointer to that. 

	Params:
        IN  UINT    iResource:          The string resource ID
        OUT PTSTR   pszStr (NULL):      The buffer in which we might need to read 
            in the string resource
            
        IN  INT     nLength (0) bytes:  If pszStr is not NULL then this will contain 
            the size of the buffer in bytes.
            
	Return:
        The pointer to the string read.
--*/
{
    static TCHAR s_szString[1024];

    if (NULL == pszStr) {

        *s_szString = 0;
        LoadString(g_hInstance, iResource, s_szString, ARRAYSIZE(s_szString));
        return s_szString;
    }

    *pszStr = 0;
    LoadString(g_hInstance, iResource, pszStr, nLength);

    return pszStr;
}

DWORD 
WIN_MSG(
    void
    )
/*++

    WIN_MSG

	Desc:	Shows up the message for the last Windows error   

--*/

{
    LPVOID  lpMsgBuf = NULL;
    DWORD   returnVal;

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM
                  | FORMAT_MESSAGE_IGNORE_INSERTS,
                  NULL,
                  returnVal = GetLastError(),
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                  (PTSTR) &lpMsgBuf,
                  0,
                  NULL);

    //
    // Prefix :-(
    // 
    if (lpMsgBuf) {
        MessageBox(NULL, (LPCTSTR)lpMsgBuf, TEXT("Error"), MB_OK | MB_ICONINFORMATION);
    }

    if (lpMsgBuf) {
        LocalFree(lpMsgBuf);
        lpMsgBuf = NULL;
    }

    return returnVal;

}
    
INT
Atoi(
    IN  PCTSTR pszStr,
    OUT BOOL*  pbValid
    )
/*++
    Atoi

	Desc:	Converts a string into a integer.

	Params:
        IN  PCTSTR pszStr:  The string to convert into a integer
        OUT BOOL*  pbValid: Will be FALSE, if the string was not an integer e.g. "foo", 
            otherwise this will be TRUE

	Return:
        The integer representation of the string
--*/
{
    BOOL    bNegative   = FALSE;
    INT     result      = 0, iIndex = 0;

    if (pszStr == NULL) {

        if (pbValid) {
            *pbValid = FALSE;
        }

        return 0;
    }
    
    if (pbValid) {
        *pbValid = TRUE;
    }

    while (isspace(*pszStr)) {
        pszStr++;
    }

    if (*pszStr == TEXT('-')) {
        bNegative = TRUE;
        ++pszStr;
    }

    while (isspace(*pszStr)) {
        pszStr++;
    }

    while (*pszStr) {

        if (*pszStr >= TEXT('0') && *pszStr <= TEXT('9')) {
            result = 10 * result + (*pszStr) - TEXT('0');
        } else {

            if (pbValid) {
                *pbValid = FALSE;
            }

            return 0;
        }

        ++pszStr;
    }

    if (bNegative) {
        return 0 - result;
    }

    return result;
}

BOOL
NotCompletePath(
    IN  PCTSTR pszFileName
    )
/*++
    
    NotCompletePath
    
	Desc:	Checks if we have the complete path or just the file name

	Params:
        IN  PCTSTR pszFileName: The file-name to check

	Return:
        TRUE:   pszFileName is not a complete path
        FALSE:  Otherwise
--*/
{
    if (!pszFileName) {
        assert(FALSE);
        return TRUE;
    }

    if (lstrlen(pszFileName) < 3) {
        assert(FALSE);
        return FALSE;
    }
    
    if ((isalpha(pszFileName[0]) && pszFileName[1] == TEXT(':'))
        || (pszFileName[0] == TEXT('\\') && pszFileName[1] == TEXT('\\'))) {

        return FALSE;
    } else {
        return TRUE;
    }
}

void
TreeDeleteAll(
    IN  HWND hwndTree
    )
/*++
    
    TreeDeleteAll

	Desc:	Deletes all the items from this tree

	Params:
        IN  HWND hwndTree:  The handle to the tree view

	Return:
        void
--*/
{
    SendMessage(hwndTree, WM_SETREDRAW, FALSE, 0);

    if (hwndTree == g_hwndEntryTree) {
        g_bDeletingEntryTree = TRUE;
    }

    TreeView_DeleteAllItems(hwndTree);

    if (hwndTree == g_hwndEntryTree) {
        g_bDeletingEntryTree = FALSE;
    }

    SendMessage(hwndTree, WM_SETREDRAW, TRUE, 0);
    SendMessage(hwndTree, WM_NCPAINT, 1, 0);
}


BOOL
FormatDate(
    IN  PSYSTEMTIME pSysTime,
    OUT PTSTR       pszDate,
    IN  UINT        cchDate
    )
/*++

    FormatDate
    
    Desc:   Formats a PSYSTEMTIME to a format that can be displayed.
            The format is the form of day , month date, year, hr:minutes:seconds AM/PM
    
    Params:        
        IN  PSYSTEMTIME pSysTime:   The time that we want to format
        OUT PTSTR       pszDate:    The buffer that will hold the formatted string
        IN  UINT        cchDate:    The size of the buffer in characters
--*/
{
    TCHAR szDay[128], szMonth[128];
    
    if (pSysTime == NULL || pszDate == NULL) {

        assert(FALSE);
        return FALSE;
    }

    *szDay = *pszDate = *szMonth = 0;

    GetString(IDS_DAYS + pSysTime->wDayOfWeek, szDay, ARRAYSIZE(szDay));
    GetString(IDS_MONTHS + pSysTime->wMonth - 1, szMonth, ARRAYSIZE(szMonth));

    StringCchPrintf(pszDate, 
                    cchDate - 3,
                    TEXT("%s, %s %02d, %02d, %02d:%02d:%02d "), 
                    szDay, 
                    szMonth, 
                    pSysTime->wDay, 
                    pSysTime->wYear,
                    (pSysTime->wHour % 12) == 0 ? 12 : pSysTime->wHour % 12,
                    pSysTime->wMinute, pSysTime->wSecond);

    if (pSysTime->wHour >= 12) {
        StringCchCat(pszDate, cchDate, GetString(IDS_PM));
    } else {
        StringCchCat(pszDate, cchDate, GetString(IDS_AM));
    }

    return TRUE;
}

BOOL
GetFileContents(
    IN  PCTSTR  pszFileName,
    OUT PWSTR* ppwszFileContents
    )
/*++ 
    GetFileContents
    
    Desc:   Given a file name, this function gets the contents in a unicode buffer.
    
    Params:
        IN  PCTSTR  pszFileName:        The name of the file
        OUT PWSTR* ppwszFileContents:   The buffer in which to store the contents

    Return: 
        TRUE:   If we successfully copied the concents into a unicode buffer.
        FALSE:  Otherwise.
--*/
{
    BOOL    bIsSuccess          = FALSE;
    LPSTR   pszFileContents     = NULL;
    LPWSTR  pwszFileContents    = NULL;

    if (ppwszFileContents) {
        *ppwszFileContents = 0;
    }

    HANDLE hFile = CreateFile(pszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    DWORD cSize = 0;

    // The file is small so we don't care about the high-order
    // word of the file.
    if ((cSize = GetFileSize(hFile, NULL)) == -1) {
        Dbg(dlError, "[GetFileContents] Opening file %S failed: %d", 
            pszFileName, GetLastError());
        goto EXIT;
    } else {
        DWORD cNumberOfBytesRead = 0;
        pszFileContents = new CHAR [cSize];
        
        if (pszFileContents) {
            if (ReadFile(hFile, pszFileContents, cSize, &cNumberOfBytesRead, NULL)) {
                // Convert to unicode.
                DWORD cSizeUnicode = MultiByteToWideChar(CP_ACP,
                                                         0,
                                                         pszFileContents,
                                                         cNumberOfBytesRead,
                                                         0,
                                                         0);

                pwszFileContents = new WCHAR [cSizeUnicode + 1];

                if (pwszFileContents) {
                    MultiByteToWideChar(CP_ACP,
                                        0,
                                        pszFileContents,
                                        cNumberOfBytesRead,
                                        pwszFileContents,
                                        cSizeUnicode);

                    pwszFileContents[cSizeUnicode] = L'\0';

                    if (ppwszFileContents) {
                        *ppwszFileContents = pwszFileContents;
                    } else {
                        Dbg(dlError, "[GetFileContents] ppwszFileContents is NULL");
                    }
                    bIsSuccess = TRUE;
                } else {
                    Dbg(dlError, "[GetFileContents] Error allocating memory");

                    goto EXIT;
                }
            } else {
                Dbg(dlError, "[GetFileContents] Error reading the file contents: %d",
                    GetLastError());

                goto EXIT;
            }
        } else {
            Dbg(dlError, "[GetFileContents] Error allocating memory");

            goto EXIT;
        }
    }

EXIT:

    CloseHandle(hFile);
    
    if (pszFileContents) {
        delete [] pszFileContents;
    }

    if (bIsSuccess == FALSE) {

        if (pwszFileContents) {

            delete[] pwszFileContents;
            pwszFileContents = NULL;

            if (ppwszFileContents) {
                *ppwszFileContents = NULL;
            }
        }
    }

    return bIsSuccess;
}

void
TrimLeadingSpaces(
    IN  OUT LPCWSTR& pwsz
    )
/*++

    TrimLeadingSpaces
    
	Desc:	Removes the leading tabs and spaces

	Params: 
        IN  OUT LPCWSTR& pwsz:   The string to be trimmed

	Return:
        void
--*/

{
    if (pwsz) {
        pwsz += wcsspn(pwsz, L" \t");
    }
}

void
TrimTrailingSpaces(
    IN  OUT LPWSTR pwsz
    )
/*++

    TrimTrailingSpaces
    
	Desc:	Removes the trailing tabs and spaces

	Params: 
        IN  OUT LPWSTR pwsz:   The string to be trimmed

	Return:
        void
--*/
{
    if (pwsz) {
        DWORD   cLen = wcslen(pwsz);
        LPWSTR  pwszEnd = pwsz + cLen - 1;

        while (pwszEnd >= pwsz && (*pwszEnd == L' ' || *pwszEnd == L'\t')) {
            --pwszEnd;
        }

        *(++pwszEnd) = L'\0';
    }
}

LPWSTR 
GetNextLine(
    IN  LPWSTR pwszBuffer
    )
/*++
    
    GetNextLine
    
    Desc:   Given a buffer, get the contents up until "\r\n" or EOF.
            Usage is the same as strtok.

    Params:
        IN  LPWSTR pwszBuffer:  Buffer to get next line from.

    Return: Pointer to beginning of next line.
    
--*/
{
    static  LPWSTR pwsz;
    LPWSTR  pwszNextLineStart;

    if (pwszBuffer) {
        pwsz = pwszNextLineStart = pwszBuffer;
    }

    while (TRUE) {
        // If we are at the end of the line, go to the next line
        // if there's any.
        if (*pwsz == L'\r') {
            pwsz = pwsz + 2;
            continue;
        }
        
        if (*pwsz == L'\0') {
            return NULL;
        }

        pwszNextLineStart = pwsz;

        while (*pwsz != L'\r' && *pwsz != L'\0') {
            ++pwsz;
        }
        
        if (*pwsz) {
            // Set the end of the line.
            *pwsz = L'\0';
            pwsz = pwsz + 2;
        }

        return pwszNextLineStart;
    }

    return NULL;
}

LPWSTR GetNextToken(
    IN  OUT  LPWSTR pwsz
    )
/*++

Desc:   Parse the commandline argument for the LUA shims using ' ' as the delimiter.
        If a token has spaces, use double quotes around it. Use this function the 
        same way you use strtok except you don't have to specify the delimiter.

 Params:
    IN  OUT  LPWSTR pwsz:   The string to parse.

 Return Value:  Pointer to the next token.

--*/
{
    static LPWSTR pwszToken;
    static LPWSTR pwszEndOfLastToken;

    if (!pwsz) {
        pwsz = pwszEndOfLastToken;
    }

    // Skip the white space.
    while (*pwsz && *pwsz == ' ') {
        ++pwsz;
    }

    pwszToken = pwsz;

    BOOL fInsideQuotes = 0;

    while (*pwsz) {
        switch(*pwsz) {
        case L'"':
            fInsideQuotes ^= 1;

            if (fInsideQuotes) {
                ++pwszToken;
            }

        case L' ':
            if (!fInsideQuotes) {
                goto EXIT;
            }

        default:
            ++pwsz;
        }
    }

EXIT:
    if (*pwsz) {
        *pwsz = L'\0';
        pwszEndOfLastToken = ++pwsz;
    } else {
        pwszEndOfLastToken = pwsz;
    }
    
    return pwszToken;
}

int CALLBACK
CompareItemsEx(
    IN  LPARAM lParam1,
    IN  LPARAM lParam2, 
    IN  LPARAM lParam
    )
/*++
    
    CompareItemsEx

	Desc:	Used to sort items in the list view for a column

	Params:
        IN  LPARAM lParam1: Index of the first item
        IN  LPARAM lParam2: Index of the second item
        IN  LPARAM lParam:  ListView_SortItemEx's lParamSort parameter. This is a COLSORT*

	Return: Return a negative value if the first item should precede the second, 
            a positive value if the first item should follow the second, 
            or zero if the two items are equivalent.
            
    Notes:  Our comparison is case-INsensitive. The COLSORT contains the handle of the list view,
            the index of the column for which we are doing the sort and a bit array. The
            bit arrays helps us to determine, which columns are sorted in which way and this 
            function should reverse the sort order. Initially we will assume that the cols
            are sorted in ascending order (they might not be actually) and when we click on the
            column for the first time, we will sort them in descending order.
        
--*/
{
    COLSORT*    pColSort = (COLSORT*)lParam;
    TCHAR       szBufferOne[512], szBufferTwo[512];
    LVITEM      lvi;
    HWND        hwndList = pColSort->hwndList;
    CSTRING     strExeNameOne, strExeNameTwo;
    INT         nVal = 0;

    *szBufferOne = *szBufferTwo = 0;

    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask        = LVIF_TEXT;
    lvi.iItem       = (INT)lParam1;
    lvi.iSubItem    = pColSort->iCol;
    lvi.pszText     = szBufferOne;
    lvi.cchTextMax  = ARRAYSIZE(szBufferOne);

    if (!ListView_GetItem(hwndList, &lvi)) {

        assert(FALSE);
        return -1;
    }
    
    lvi.mask        = LVIF_TEXT;
    lvi.iItem       = (INT)lParam2;
    lvi.iSubItem    = pColSort->iCol;
    lvi.pszText     = szBufferTwo;
    lvi.cchTextMax  = ARRAYSIZE(szBufferTwo);

    if (!ListView_GetItem(hwndList, &lvi)) {

        assert(FALSE);
        return -1;
    }

    nVal = lstrcmpi(szBufferOne, szBufferTwo);

    if (nVal == 0) {
        return 0;
    }

    if ((pColSort->lSortColMask & (1L << pColSort->iCol)) == 0) {
        
        // This is in ascending order right now, sort in descending order
        nVal == -1 ? nVal = 1 : nVal = -1;
    }

    return nVal;
}

BOOL
SaveListViewToFile(
    IN  HWND    hwndList,
    IN  INT     iCols,
    IN  PCTSTR  pszFile,
    IN  PCTSTR  pszHeader
    )
/*++
    
    SaveListViewToFile
    
    Desc:   Saves the contents of list view to a file in tab separated form. Also prints the header
            before writing the contents
            
    Params:
        IN  HWND    hwndList:   The handle to the list view
        IN  INT     iCols:      Number of columns in the list view
        IN  PCTSTR  pszFile:    The path of the file in which we want to save the contents
        IN  PTSTR   pszHeader:  Any header to be written in the file before writing the contents
        
    Return:
        TRUE:   Success
        FALSE:  Error
--*/
{
    FILE*       fp = _tfopen(pszFile, TEXT("w"));
    TCHAR       szBuffer[256];
    LVCOLUMN    lvCol;
    LVITEM      lvi;

    *szBuffer = 0;

    if (fp == NULL) {
        return FALSE;
    }

    if (pszHeader) {
        fwprintf(fp, TEXT("%s\n\r"), pszHeader);
    }

    //
    // Print the column names first
    //
    ZeroMemory(&lvCol, sizeof(lvCol));

    lvCol.mask          = LVCF_TEXT;
    lvCol.pszText       = szBuffer;
    lvCol.cchTextMax    = sizeof(szBuffer)/sizeof(szBuffer[0]);

    for (INT iIndex = 0; iIndex < iCols; ++iIndex) {

        *szBuffer = 0;
        ListView_GetColumn(hwndList, iIndex, &lvCol);
        fwprintf(fp, TEXT("%s\t"), lvCol.pszText);
    }

    fwprintf(fp, TEXT("\n\n"));

    INT iRowCount = ListView_GetItemCount(hwndList);

    ZeroMemory(&lvi, sizeof(lvi));

    for (INT iRowIndex = 0; iRowIndex < iRowCount; ++ iRowIndex) {
        for (INT iColIndex = 0; iColIndex < iCols; ++iColIndex) {
            
            *szBuffer = 0;

            lvi.mask        = LVIF_TEXT;
            lvi.pszText     = szBuffer;
            lvi.cchTextMax  = sizeof(szBuffer)/sizeof(szBuffer[0]);
            lvi.iItem       = iRowIndex;
            lvi.iSubItem    = iColIndex;

            if (!ListView_GetItem(hwndList, &lvi)) {
                assert(FALSE);
            }

            fwprintf(fp, TEXT("%s\t"), szBuffer);
        }

        fwprintf(fp, TEXT("\n"));
    }
    
    fclose(fp);
    return TRUE;
}

BOOL
ReplaceChar(
    IN  OUT PTSTR   pszString,
    IN      TCHAR   chCharToFind,
    IN      TCHAR   chReplaceBy
    )
/*++

    ReplaceChar
    
	Desc:	Replaces all occurences of chCharToFind in pszString by chReplaceBy

	Params:
        IN  OUT PTSTR   pszString:      The string in which the replace has to be made
        IN      TCHAR   chCharToFind:   The char to look for
        IN      TCHAR   chReplaceBy:    All occurences of chCharToFind will be replaced by this

	Return:
        TRUE:   At least one replacement was done.
        FALSE:  Otherwise
--*/
{
    BOOL bChanged = FALSE; // Did the string change?

    while (*pszString) {

        if (*pszString == chCharToFind) {
            *pszString = chReplaceBy;
            bChanged = TRUE;
        }

        ++pszString;
    }

    return bChanged;
}

INT
Tokenize(
    IN  PCTSTR          szString,
    IN  INT             cchLength,
    IN  PCTSTR          szDelims,
    OUT CSTRINGLIST&    strlTokens
    )
/*++

    Tokenize
    
    Desc:   Tokenizes the string szString based on delimiters szDelims and puts the individual
            tokens in strlTokens
            
    Params:
        IN  PCTSTR          szString:   The string to tokenize
        IN  INT             cchLength:  The length of szString. Note that this is the length obtained using lstrlen
        IN  PCTSTR          szDelims:   The delimiter string        
        OUT CSTRINGLIST&    strlTokens: Will contain the tokens
        
    Return:
        The count of tokens produced
        
    Note: Please note that the tokens are always trimmed, so we cannot have a token that begins
          or ends with a tab or a space
--*/
{
    TCHAR*  pszCopyBeg  = NULL; // Pointer to the pszCopy so that we can free it
    TCHAR*  pszCopy     = NULL; // Will contain the copy of szString
    TCHAR*  pszEnd      = NULL; // Pointer to end of token
    INT     iCount      = 0;    // Total tokens found    
    BOOL    bNullFound  = FALSE;
    CSTRING strTemp;
    K_SIZE  k_pszCopy   = (cchLength + 1);

    strlTokens.DeleteAll();

    pszCopy = new TCHAR[k_pszCopy];

    if (pszCopy == NULL) {
        MEM_ERR;
        goto End;
    }

    SafeCpyN(pszCopy, szString, k_pszCopy);
    pszCopyBeg = pszCopy;

    //
    // Search for tokens
    //
    while (TRUE) {

        //
        // Ignore leading delimiters
        //
        while (*pszCopy && _tcschr(szDelims, *pszCopy)) {
            pszCopy++;
        }

        if (*pszCopy == NULL) {
            break;
        }

        //
        // Find the end of the token
        //
        pszEnd = pszCopy + _tcscspn(pszCopy, szDelims);

        if (*pszEnd == 0) {
            //
            // No more tokens will be found, we have found the last token
            //
            bNullFound = TRUE;
        }

        *pszEnd = 0;

        ++iCount;

        strTemp = pszCopy;
        strTemp.Trim();

        strlTokens.AddString(strTemp);

        if (bNullFound == FALSE) {
            //
            // There might be still some tokens that we will get
            //
            pszCopy = pszEnd + 1;
        } else {
            break;
        }
    }

End:

    if (pszCopyBeg) {
        delete[] pszCopyBeg;
        pszCopyBeg = NULL;
    }

    return iCount;
}

void
ShowInlineHelp(
    IN  LPCTSTR pszInlineHelpHtmlFile
    )
/*++
    ShowInlineHelp
    
    Desc:
        Shows in line help by loading the specified html file
    
    Params: 
        IN  LPCTSTR pszInlineHelpHtmlFile: The html file that contained the 
            help
            
    Return:
        void
--*/
{
    TCHAR   szPath[MAX_PATH * 2], szDir[MAX_PATH], szDrive[MAX_PATH * 2]; 
    INT     iType = 0;

    if (pszInlineHelpHtmlFile == NULL) {
        return;
    }

    *szDir = *szDrive = 0;

    _tsplitpath(g_szAppPath, szDrive, szDir, NULL, NULL);

    StringCchPrintf(szPath, 
                    ARRAYSIZE(szPath), 
                    TEXT("%s%sCompatAdmin.chm::/%s"), 
                    szDrive,
                    szDir,
                    pszInlineHelpHtmlFile);

    HtmlHelp(GetDesktopWindow(), szPath, HH_DISPLAY_TOPIC, 0);
}

PTSTR
GetSpace(
    IN  OUT PTSTR   pszSpace, 
    IN      INT     iSpaces, 
    IN      INT     iBuffSize
    )
/*++
    GetSpace
    
    Desc:
        Fills in pszSpace with iSpaces number of spaces
    
    Params: 
        IN  OUT PTSTR   pszSpace:   The buffer that will be filled with spaces
        IN      INT     iSpaces:    The number of spaces to fill    
        IN      INT     iBuffSize:  Size of buffer in TCHARS
        
            
    Return:
        The modified buffer
--*/
{
    if (pszSpace == NULL) {
        //
        // Error..
        //
        goto End;
    }

    //
    // Fill the buffer with spaces
    //
    for (INT iLoop = 0; iLoop < min(iSpaces, iBuffSize - 1); ++iLoop) {

        *(pszSpace + iLoop) = TEXT(' ');
    }

    //
    // Put the terminating NULL
    //
    *(pszSpace + min(iSpaces, iBuffSize - 1)) = 0;

End:
    return pszSpace;

}

BOOL
ValidInput(
    IN PCTSTR  pszStr
    )
/*++
    ValidInput
    
    Desc:   Checks if the input contains chars other than space, tab, new line and carriage return
    
    Params:
        IN PCTSTR  pszStr: The input that we want to check for validity
        
    Return:
        TRUE:   Valid input
        FALSE:  Otherwise
--*/
{
    BOOL bOk = FALSE;

    if (pszStr == NULL) {
        bOk = FALSE;
        goto End;
    }

    while (*pszStr) {
        if (*pszStr != TEXT(' ') && *pszStr != TEXT('\t') && *pszStr != TEXT('\n') && *pszStr != TEXT('\r')) {
            bOk = TRUE;
            goto End;
        }

        ++pszStr;
    }

End:
    return bOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\querydb_ui.cpp ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    QueryDB_UI.cpp

Abstract:

    GUI for the Query Databases option
    
Author:

    kinshu created  October 12, 2001
    
Notes:

    The query dialog box performs two types of searches. One is when it actually makes a SQL
    query and passes it to the SQL driver and shows the results in the result list view.
    The lParam of the list view then are pointers to RESULT_ITEM objects. (1,2,4) tab pages
    
    Second is the case when we are doing a query for some shims, like show all the shims that have 'x'
    in their desc. text. (3rd tab page). In this case the query is not passed to the sql driver
    and we do the query on our own. The SQL driver can execute queries where the result is some
    fixed program entry (and the database that it lives in, please see RESULT_ITEM). 
    In this case the lparam of the list view is pointers to the individual shims in the system database
    
    We do not free anything from the lParam of the list view. In the case when the query is of type 
    1 as mentioned above, the RESULT_ITEM are freed when we close the Statement.
    In case of queries of type 2, the shims themseleves should not be freed, they belong to the database
    they live in (The system database).
--*/

#include "precomp.h"


//////////////////////// Defines ///////////////////////////////////////////////

// Number of pages in the tab
#define PAGE_COUNT 4

// ID for the first tab page 
#define QDB_PAGE1   0

// ID for the second tab page 
#define QDB_PAGE2   1

// ID for the third tab page 
#define QDB_PAGE3   2

// ID for the fourth tab page 
#define QDB_PAGE4   3

// We want to search all the databases
#define DATABASE_ALL 0

// Indexes into DatabasesMapping
#define IND_SYSTDB   0
#define IND_INSTDB   1
#define IND_CUSTDB   2

// Maximum for the progress bar
#define MAX_PROGRESS 2000

//
// Maximum buffer size to be allocated for the string that will store 
// search string in the third wizard page, where the user tries to search for
// fixes that have specific words in their description text
#define MAX_FIXDESC_SEARCH 1024

// Maximum number fof tchars that can come in the SELECT clause. 
#define MAX_SELECT      512

// Maximum number fof tchars that can come in the WHERE clause. 
#define MAX_WHERE       1022

// Width of a column in the result list view when searching for entries
#define COLUMN_WIDTH    20

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Externs ////////////////////////////////////////////// 

extern HWND                             g_hwndEntryTree;
extern HINSTANCE                        g_hInstance;
extern BOOL                             g_bSomeWizardActive;
extern struct _tagAttributeShowMapping  AttributeShowMapping[];
extern struct _tagAttributeMatchMapping AttributeMatchMapping[];
extern struct _tagDatabasesMapping      DatabasesMapping[3];

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Global Variables /////////////////////////////////////

// The statement
Statement stmt;

// The width of the query db Dialog
int     g_cWidthQuery = 0;

// The height of the query db Dialog
int     g_cHeightQuery = 0;

// The handle to the main dialog
HWND    g_hdlgQueryDB;

// The type of search we did last time
INT     g_iLastSearchType;

// The bit array that describes what columns are sorted in what manner
static  LONG    s_lColumnSort;

// Do we have a empty column header that we have to remove
static  BOOL    s_bEmptyHeader = TRUE;

// The thread that performs the query
static  HANDLE  s_hThread;

// The handle to the wait window. This window will pop up if we are trying to close the 
// qdb window when the thread is busy.
static  HWND    s_hWaitDialog;

// Code for any error that occur while collecting info from the GUI.
// If this is non-zero then we display some error and SQL query is not executed
static  INT     s_iErrorCode;

///////////////////////////////////////////////////////////////////////////////


//////////////////////// Typedefs/Enums ///////////////////////////////////////

typedef enum {

    QDB_SEARCH_ANYWORD  = 0,
    QDB_SEARCH_ALLWORDS = 1

} QDB_SEARCH_TYPE;

typedef struct _tagDialogData
{
    HANDLE      hMainThread;
    HWND        hdlg;

}DIALOG_DATA;

typedef struct tag_dlghdr {

    HWND    hwndTab;       // tab control 
    HWND    hwndPages[PAGE_COUNT]; 
    INT     iPresentTabIndex;
    RECT    rcDisplay;

    tag_dlghdr()
    {
        ZeroMemory(hwndPages, sizeof(hwndPages));
        iPresentTabIndex = -1;
    }

} DLGHDR;

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Function Declarations ////////////////////////////////

INT_PTR CALLBACK
QdbWaitDlg(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void
GotoQdbEntry(
    HWND    hdlg,
    LPARAM  lParam
    );

void
SaveResultsQdb(
    HWND    hdlg
    );

void
DoNewQdb(
    HWND    hdlg
    );

void
OnSearch(
    HWND    hdlg
    );

void
HandleQueryDBSizing(
    HWND    hDlg
    );

void
Start(
    HWND hdlg
    );

void
HandleListNotification(
    HWND    hdlg,
    LPARAM  lParam
    );

DWORD WINAPI
QueryDBThread(
    LPVOID pVoid
    );

VOID 
WINAPI 
OnChildDialogInit(
    HWND hwndDlg
    );

VOID 
WINAPI 
OnChildDialogInit(
    HWND hwndDlg
    );

VOID
WINAPI 
OnSelChanged(
    HWND hwndDlg
    );

INT_PTR
CALLBACK
SearchOnAppDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
SearchOnFixDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR
CALLBACK
AdvancedSearchDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    ); 

INT_PTR
CALLBACK
SearchFixDescDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void
HandleTabNotification(
    HWND   hdlg,
    LPARAM lParam
    );

void
HandleAdvancedListNotification(
    HWND    hdlg,
    LPARAM  lParam
    );

void
DeleteAll(
    HWND    hdlg
    );

///////////////////////////////////////////////////////////////////////////////


void
LoadDatabaseTypes(
    IN  HWND hdlg
    )
/*++
    
    LoadDatabaseTypes
    
    Desc:   Loads the database types in the combo box
    
    Params:
        IN  HWND hdlg:  The query dialog box
        
    Return:
        void
        
--*/
{
    HWND hwndCombo = GetDlgItem(hdlg, IDC_COMBO);

    //
    // All databases
    //
    INT iIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_ALLDATABASES));
    SendMessage(hwndCombo, CB_SETITEMDATA, iIndex, (LPARAM)DATABASE_ALL);

    //
    // System database
    //
    iIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_SYSDB));
    SendMessage(hwndCombo, CB_SETITEMDATA, iIndex, (LPARAM)DATABASE_TYPE_GLOBAL);

    //
    // Installed databases
    //
    iIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_INSTALLEDDB));
    SendMessage(hwndCombo, CB_SETITEMDATA, iIndex, (LPARAM)DATABASE_TYPE_INSTALLED);

    //
    // Custom databases
    //
    iIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_WORKDB));
    SendMessage(hwndCombo, CB_SETITEMDATA, iIndex, (LPARAM)DATABASE_TYPE_WORKING);

    //
    // Select the first string
    //
    SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);
}

INT_PTR CALLBACK
QueryDBDlg(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++
    QueryDBDlg
    
    Desc:   Dialog Proc for the main Query database dialog.
    
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
        
--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
        
    case WM_INITDIALOG:
        {
            DLGHDR* pHdr = NULL;
            TCITEM  tie;
            RECT    r;

            //
            // Limit the text field for the hidden text box. Please note that
            // we will concatenate the results of the select and the where text fields 
            // and put the actual SQL in the form of 'SELECT .. FROM .. [WHERE ..]' in this 
            // text field
            //
            SendMessage(GetDlgItem(hdlg, IDC_SQL),
                        EM_LIMITTEXT,
                        (WPARAM)MAX_SQL_LENGTH - 1,
                        (LPARAM)0);

            g_hdlgQueryDB = hdlg;
            s_lColumnSort = 0;   

            ListView_SetExtendedListViewStyleEx(GetDlgItem(hdlg, IDC_LIST), 
                                                0,
                                                LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT); 
            
            SetStatus(GetDlgItem(hdlg, IDC_STATUSBAR), TEXT("")); 

            LoadDatabaseTypes(hdlg);

            Animate_OpenEx(GetDlgItem(hdlg, IDC_ANIMATE),
                           g_hInstance,
                           MAKEINTRESOURCE(IDA_SEARCH));
            
            //
            // Set up the tab control
            //
            pHdr = new DLGHDR;

            if (pHdr == NULL) {
                MEM_ERR;
                break;
            }

            pHdr->hwndTab = GetDlgItem(hdlg, IDC_TAB);

            GetWindowRect(pHdr->hwndTab, &pHdr->rcDisplay);

            SendMessage(pHdr->hwndTab, WM_SETREDRAW, TRUE, 0);

            SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pHdr);

            ZeroMemory(&tie, sizeof(tie));

            tie.mask    = TCIF_TEXT; 
            tie.pszText = GetString(IDS_APP_PROPERTIES); 
            TabCtrl_InsertItem(pHdr->hwndTab, QDB_PAGE1, &tie);

            tie.pszText = GetString(IDS_FIX_PROPERTIES); 
            TabCtrl_InsertItem(pHdr->hwndTab, QDB_PAGE2, &tie); 

            tie.pszText = GetString(IDS_ADVANCED); 
            TabCtrl_InsertItem(pHdr->hwndTab, QDB_PAGE4, &tie); 

            tie.pszText = GetString(IDS_FIX_DESCRIPTION); 
            TabCtrl_InsertItem(pHdr->hwndTab, QDB_PAGE3, &tie); 

            
            //
            // The page where we select apps by name
            //
            pHdr->hwndPages[QDB_PAGE1] = CreateDialog(g_hInstance,
                                                      MAKEINTRESOURCE(IDD_QDB_PAGE1),
                                                      hdlg,
                                                      SearchOnAppDlgProc);

            //
            // The page where we select apps by the fixes applied
            //
            pHdr->hwndPages[QDB_PAGE2] = CreateDialog(g_hInstance,
                                                      MAKEINTRESOURCE(IDD_QDB_PAGE2),
                                                      hdlg,
                                                      SearchOnFixDlgProc);

            
            //
            // The page where we search by the words in the descriptipon of the fix or in the name
            //
            pHdr->hwndPages[QDB_PAGE3] = CreateDialog(g_hInstance,
                                                      MAKEINTRESOURCE(IDD_QDB_PAGE3),
                                                      hdlg,
                                                      SearchFixDescDlgProc);
            
            //
            // The advanced page
            //
            pHdr->hwndPages[QDB_PAGE4] = CreateDialog(g_hInstance,
                                                      MAKEINTRESOURCE(IDD_QDB_PAGE4),
                                                      hdlg,
                                                      AdvancedSearchDlgProc);

            //
            // Set the background properly and position the pages in the tab control
            //
            OnChildDialogInit(pHdr->hwndPages[QDB_PAGE1]);
            OnChildDialogInit(pHdr->hwndPages[QDB_PAGE2]);
            OnChildDialogInit(pHdr->hwndPages[QDB_PAGE3]);
            OnChildDialogInit(pHdr->hwndPages[QDB_PAGE4]);

            //
            // Select the first page
            //
            OnSelChanged(hdlg);

            //
            // Get the height and width so that we can properly resize the dialog box
            //
            GetWindowRect(hdlg, &r);

            g_cWidthQuery   = r.right - r.left;
            g_cHeightQuery  = r.bottom - r.top;

            InsertColumnIntoListView(GetDlgItem(hdlg, IDC_LIST), TEXT(""), 0, 100);

            s_bEmptyHeader = TRUE;

            break;
        }

    case WM_GETMINMAXINFO:
        {
            //
            // Limit the min width and height of the dialog box
            //
            MINMAXINFO* pmmi = (MINMAXINFO*)lParam;

            pmmi->ptMinTrackSize.x = 550;
            pmmi->ptMinTrackSize.y = 365;
            
            return 0;
            break;
        }

    case WM_SIZE:

        if (wParam != SIZE_MINIMIZED) {
            HandleQueryDBSizing(hdlg);
        }

        break;

    case WM_COMMAND:
        {
            switch (wCode) {
            case ID_SEARCH:
                {       
                    DLGHDR* pHdr    = (DLGHDR*)GetWindowLongPtr(g_hdlgQueryDB, GWLP_USERDATA);
                    HWND hwndList   = GetDlgItem(hdlg, IDC_LIST);

                    if (pHdr == NULL) {
                        assert(FALSE);
                        break;
                    }

                    g_iLastSearchType = pHdr->iPresentTabIndex;

                    //
                    // When the user will click on some column for the first time, we will now
                    // sort that in ascending order
                    //
                    s_lColumnSort = -1;

                    if (GetFocus() == hwndList
                        && ListView_GetNextItem(hwndList, -1, LVNI_SELECTED) != -1) {
    
                        //
                        // We will get this message when we press enter in the list box,
                        // as ID_SEARCH is the default button.
                        // So in this case we have to pretend as the user double clicked in the list
                        // view
                        //
                        SendNotifyMessage(hdlg, WM_COMMAND, (WPARAM)ID_VIEWCONTENTS, 0);
    
                    } else if (pHdr->iPresentTabIndex == QDB_PAGE3) {
                        //
                        // We are trying to do a search on fix description
                        //
                        SendMessage(pHdr->hwndPages[QDB_PAGE3], WM_USER_DOTHESEARCH, 0, 0);

                    } else {
                        //
                        // Normal SQL query
                        //
                        OnSearch(hdlg);
                    }
                }

                break;

            case ID_VIEWCONTENTS:
                {
                    //
                    // The user wishes to see the contents. We must now find and select
                    // the correct entry in the db tree and the entry tree
                    //
                    HWND    hwndList    = GetDlgItem(hdlg, IDC_LIST);
                    INT     iSelection  = ListView_GetSelectionMark(hwndList);
    
                    if (iSelection == -1) {
                        break;
                    }
        
                    LVITEM          lvi;
                    PMATCHEDENTRY   pmMatched;
    
                    ZeroMemory(&lvi, sizeof(lvi));
        
                    lvi.iItem = iSelection;
                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
        
                    if (ListView_GetItem(hwndList, &lvi)) {
                        GotoQdbEntry(hdlg, lvi.lParam);
                    }

                    break;
                }

            case IDCANCEL:

                if (s_hThread) {
                    //
                    // Need to wait for thread to terminate if it is running
                    //
                    if (!s_hWaitDialog) {

                        s_hWaitDialog = CreateDialog(g_hInstance, 
                                                     MAKEINTRESOURCE(IDD_QDBWAIT), 
                                                     g_hdlgQueryDB, 
                                                     QdbWaitDlg);

                        ShowWindow(s_hWaitDialog, SW_NORMAL);
                    }

                    break;
                }

                Animate_Close(GetDlgItem(hdlg, IDC_ANIMATE));
                stmt.Close();
                DestroyWindow(hdlg);
                break;

            case IDC_NEWSEARCH:
                DoNewQdb(hdlg);
                break;  

            case IDC_SAVE:
                SaveResultsQdb(hdlg);
                break;

            case ID_QDB_HELP:

                ShowInlineHelp(TEXT("using_the_query_tool.htm"));
                break;
            
            default:
                return FALSE;

            }
        }

        break;

    case WM_DESTROY:
        {
            DLGHDR *pHdr = (DLGHDR*)GetWindowLongPtr(hdlg, GWLP_USERDATA);

            //
            // Destroy the individual modeless dialog boxes
            //
            DestroyWindow(pHdr->hwndPages[QDB_PAGE1]);
            DestroyWindow(pHdr->hwndPages[QDB_PAGE2]);
            DestroyWindow(pHdr->hwndPages[QDB_PAGE3]);
            DestroyWindow(pHdr->hwndPages[QDB_PAGE4]);
    
            if (pHdr) {
                delete pHdr;
                pHdr = NULL;
            }

            stmt.Close();
            g_hdlgQueryDB = NULL;

            PostMessage(g_hDlg, WM_USER_ACTIVATE, 0, 0);
            break;
        }
        

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR)lParam;
            
            if (lpnmhdr && lpnmhdr->idFrom == IDC_LIST) {
                HandleListNotification(hdlg, lParam);    
            } else if (lpnmhdr && lpnmhdr->idFrom == IDC_TAB) {
                HandleTabNotification(hdlg, lParam);
            }

            break;
        }
    
    default: return FALSE;
    }

    return TRUE;
}
        
void
Start(
    IN  HWND hdlg
    )
/*++
    
    Start
        
    Desc:   Creates the thread that will do the actual search.
    
    Params:
        IN  HWND hdlg:  Handle to the query dialog box.
    
    Return:
        void
    
--*/
{
    DWORD dwID; // Will contain the thread id.

    ENABLEWINDOW(GetDlgItem(hdlg, ID_SEARCH), FALSE);
    ENABLEWINDOW(GetDlgItem(hdlg, IDC_NEWSEARCH), FALSE);
    ENABLEWINDOW(GetDlgItem(hdlg, IDC_SAVE), FALSE);
    ENABLEWINDOW(GetDlgItem(hdlg, IDC_STATIC_CAPTION), FALSE);

    SetStatus(GetDlgItem(hdlg, IDC_STATUSBAR), TEXT("")); 

    s_hThread =  (HANDLE)_beginthreadex(NULL, 0, (PTHREAD_START)QueryDBThread, (PVOID)hdlg, 0, (unsigned int*)&dwID);
}


DWORD WINAPI
QueryDBThread(
    IN  LPVOID pVoid
    )
/*++

    QueryDBThread

	Desc:	The thread routine that does the actual search

	Params:
        IN  LPVOID pVoid:   The handle to the query dialog
        
	Return:
        0
--*/
{
    HWND        hdlg = (HWND)pVoid;
    CSTRING     strStatus;
    TCHAR       szBuffer[32];
    INT         iTotalResults;
    ResultSet*  prs = NULL;
    static  TCHAR   s_szSQL[MAX_SQL_LENGTH] = TEXT("");

    GetWindowText(GetDlgItem(hdlg, IDC_SQL), s_szSQL, ARRAYSIZE(s_szSQL) - 1);

    s_szSQL[ARRAYSIZE(s_szSQL) - 1] = 0;

    if (CSTRING::Trim(s_szSQL) == 0) {

        MessageBox(hdlg, 
                   GetString(IDS_ERROR_SELECT_NOTFOUND), 
                   g_szAppName, 
                   MB_ICONERROR);
        goto End;
    }

    Animate_Play(GetDlgItem(hdlg, IDC_ANIMATE), 0, -1, -1);

    //
    // We do not want the user to make changes in the databases, when we are running the 
    // query. 
    //
    ENABLEWINDOW(g_hDlg, FALSE);

    prs = stmt.ExecuteSQL(hdlg, s_szSQL);

    //
    // Do not forget to enable the main window again
    //
    ENABLEWINDOW(g_hDlg, TRUE);

    //
    // Now first of all add the columns to the listview
    //
    PNODELIST pShowList = stmt.GetShowList();

    if (pShowList == NULL) {
        goto End;
    }

    UINT uCols = pShowList->m_uCount;

    HWND hwndList = GetDlgItem(hdlg, IDC_LIST);

    TCHAR szColumnName[64];

    PNODE pNodeShow = pShowList->m_pHead;

    if (pNodeShow) {
        //
        // If the empty header is still there, must get rid of it.
        //
        if (s_bEmptyHeader) {
            ListView_DeleteColumn(hwndList, 0);
            s_bEmptyHeader = FALSE;
        }
    }  

    INT iIndex = 0;

    //
    // Add all the columns for the clauses in SELECT in the list view
    //
    while (pNodeShow) {

        *szColumnName = 0;
        InsertColumnIntoListView(hwndList, 
                                 pNodeShow->ToString(szColumnName, ARRAYSIZE(szColumnName)),
                                 iIndex, COLUMN_WIDTH);

        pNodeShow = pNodeShow->pNext;
        ++iIndex;
    }
    
    LVITEM  lvi;
    TCHAR   szString[MAX_PATH];
    int     iIndexDesired = 0;

    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    if (uCols > 0) {

        while (prs && prs->GetNext()) {

            PNODE   pNodeRow = new NODE[uCols];

            if (pNodeRow == NULL) {
                MEM_ERR;
                goto End;
            }

            //
            // Create the new list view item for this row of results
            //
            prs->GetCurrentRow(pNodeRow);
            *szString     = 0;

            lvi.pszText   = pNodeRow[0].ToString(szString, ARRAYSIZE(szString));
            lvi.iSubItem  = 0;
            lvi.lParam    = (LPARAM)prs->GetCursor();
            lvi.iItem     = iIndexDesired;

            INT iRowIndex = ListView_InsertItem(hwndList, &lvi);

            //
            // Put values for all other sub-columns
            //
            for (UINT iColIndex = 1; iColIndex < uCols; ++iColIndex) {

                *szString     = 0;
                pNodeRow[iColIndex].ToString(szString, ARRAYSIZE(szString));

                ListView_SetItemText(hwndList, iRowIndex, iColIndex, szString);
            }

            iIndexDesired++;

            if (pNodeRow) {
                delete[] pNodeRow;
                pNodeRow = NULL;
            }
        }
    }
   
End:
    ENABLEWINDOW(GetDlgItem(hdlg, ID_SEARCH), TRUE);
    ENABLEWINDOW(GetDlgItem(hdlg, IDC_NEWSEARCH), TRUE);
    ENABLEWINDOW(GetDlgItem(hdlg, IDC_SAVE), TRUE);

    iTotalResults = (prs) ? prs->GetCount() : 0;

    *szBuffer = 0;

    strStatus.Sprintf(GetString(IDS_QDB_COUNT),
                      _itot(iTotalResults, 
                            szBuffer, 
                            10));
    
    SetStatus(GetDlgItem(hdlg, IDC_STATUSBAR), strStatus); 
    
    //
    // Stop the animation.
    //
    Animate_Stop(GetDlgItem(hdlg, IDC_ANIMATE));
    CloseHandle(s_hThread);
    s_hThread = NULL;
    
    ENABLEWINDOW(GetDlgItem(hdlg, IDC_STATIC_CAPTION), iTotalResults > 0);

    SetActiveWindow(g_hdlgQueryDB);
    SetFocus(g_hdlgQueryDB);

    return 0;
}

void
ProcessItemChanged(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++
    
    ProcessItemChange
    
    Desc:   Processes the LVN_ITEMCHANGED message for the search list
            Please note that we process this message only when we did a shim search
            
    Params:
        IN  HWND    hdlg:   The query dialog box
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY
--*/
{

    LVITEM          lvItem;
    TYPE            type;
    LPNMLISTVIEW    pnmlv;
    CSTRING         strDescription;
    HWND            hwndList;
    HWND            hwndFixDesc;
    DLGHDR*         pHdr            = NULL;

    //
    // If we have searched for shims last time then we must set the description text for the
    // shim in the description window of the shim search page
    //
    if (g_iLastSearchType != QDB_PAGE3) {
        goto End;
    }

    pHdr = (DLGHDR*)GetWindowLongPtr(g_hdlgQueryDB, GWLP_USERDATA); 

    if (pHdr == NULL) {
        assert(FALSE);
        goto End;
    }

    hwndList    = GetDlgItem(hdlg, IDC_LIST);
    hwndFixDesc = GetDlgItem(pHdr->hwndPages[QDB_PAGE3], IDC_DESC);

    pnmlv = (LPNMLISTVIEW)lParam;

    if (pnmlv && (pnmlv->uChanged & LVIF_STATE)) {
        //
        // State changed
        //
        if (pnmlv->uNewState & LVIS_SELECTED) {
            //
            // New item is selected
            //
            lvItem.mask         = TVIF_PARAM;
            lvItem.iItem        = pnmlv->iItem;
            lvItem.iSubItem     = 0;

            if (!ListView_GetItem(hwndList, &lvItem)) {
                goto End;
            }

            type = ConvertLparam2Type(lvItem.lParam);

            if (type == FIX_FLAG || type == FIX_SHIM) {
                //
                // We only process this message when the item in the list view is shim or a flag
                //
                GetDescriptionString(lvItem.lParam,
                                     strDescription,
                                     NULL,
                                     NULL,
                                     NULL,
                                     hwndList,
                                     pnmlv->iItem);

                if (strDescription.Length() > 0) {
                    //
                    // For some fixes, we do not have a desc. but we did find one for the 
                    // presently selected fix
                    //
                    SetWindowText(hwndFixDesc, (LPCTSTR)strDescription);

                } else {
                    //
                    // No description is available for this fix
                    //
                    SetWindowText(hwndFixDesc, GetString(IDS_NO_DESC_AVAILABLE));
                }
            } else {
                assert(FALSE);
            }
        }
    }

End: ;
}

void
HandleListNotification(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++
    
    HandleListNotification

	Desc:	Handles the notification messages for the search results list view

	Params:
        IN  HWND    hdlg:   The query dialog box
        IN  LPARAM  lParam: The LPARAM of WM_NOTIFY

	Return:
        void
--*/
{

    HWND    hwndList    = GetDlgItem(hdlg, IDC_LIST);
    LPNMHDR lpnmhdr     = (LPNMHDR)lParam;

    if (lpnmhdr == NULL) {
        return;
    }
    
    switch (lpnmhdr->code) {
    case LVN_COLUMNCLICK:
        {
            LPNMLISTVIEW    pnmlv = (LPNMLISTVIEW)lParam;
            COLSORT         colSort;
    
            colSort.hwndList        = hwndList;
            colSort.iCol            = pnmlv->iSubItem;
            colSort.lSortColMask    = s_lColumnSort;
    
            ListView_SortItemsEx(hwndList, CompareItemsEx, &colSort);
    
            if ((s_lColumnSort & 1L << colSort.iCol) == 0) {
                //
                // Was in ascending order
                //
                s_lColumnSort |= (1L << colSort.iCol);
            } else {
                s_lColumnSort &= (~(1L << colSort.iCol));
            }
    
            break;
        }

    case NM_DBLCLK:
        {   
            LPNMITEMACTIVATE    lpnmitem    = (LPNMITEMACTIVATE)lParam;
            LVITEM              lvItem      = {0};

            if (lpnmitem == NULL) {
                break;
            }

            lvItem.mask     = TVIF_PARAM;
            lvItem.iItem    = lpnmitem->iItem;
            lvItem.iSubItem = 0;

            if (!ListView_GetItem(hwndList, &lvItem)) {
                break;
            }

            GotoQdbEntry(hdlg, lvItem.lParam);
            break;
        }

    case LVN_ITEMCHANGED:
    
        ProcessItemChanged(hdlg, lParam);
        break;
    }
}

VOID WINAPI 
OnSelChanged(
    IN  HWND hwndDlg
    ) 
/*++
    OnSelChanged
     
    Desc:   Handles the change of the tab. Hides the present tab and shows the 
            next tab.
            
    Params:
        IN  HWND hwndDlg: The query dialog box    
    
    Return:
        void
--*/

{ 
    DLGHDR* pHdr = (DLGHDR*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA); 

    if (pHdr == NULL || hwndDlg == NULL) {
        assert(FALSE);
        return;
    }

    int     iSel = TabCtrl_GetCurSel(pHdr->hwndTab); 
    HWND    hwndCombo;

    hwndCombo = GetDlgItem(hwndDlg, IDC_COMBO);
    
    if (iSel != -1 && pHdr->iPresentTabIndex != -1) {
        
        ShowWindow(pHdr->hwndPages[pHdr->iPresentTabIndex], SW_HIDE);
    }

    pHdr->iPresentTabIndex = iSel;

    ShowWindow(pHdr->hwndPages[iSel], SW_SHOWNORMAL);

    //
    // Set the focus to the first child that has tab set
    //
    switch (iSel) {
    case QDB_PAGE1: 

        ENABLEWINDOW(hwndCombo, TRUE);
        SetFocus(GetDlgItem(pHdr->hwndPages[iSel], IDC_APPNAME));
        break;

    case QDB_PAGE2: 

        ENABLEWINDOW(hwndCombo, TRUE);
        SetFocus(GetDlgItem(pHdr->hwndPages[iSel], IDC_NAME));
        break;

    case QDB_PAGE3:

        ENABLEWINDOW(hwndCombo, FALSE);
        SetFocus(GetDlgItem(pHdr->hwndPages[iSel], IDC_TEXT));
        break;

    case QDB_PAGE4: 

        ENABLEWINDOW(hwndCombo, TRUE);
        SetFocus(GetDlgItem(pHdr->hwndPages[iSel], IDC_SELECT));
        break;
    
    }
} 

VOID 
WINAPI 
OnChildDialogInit(
    IN  HWND hwndDlg
    ) 
/*++
    
    OnChildDialogInit
        
    Desc:   This routine is called when a page of the tab is first loaded.
            This routine sets the background properly for the tab
            and positions the page
            
    Params:
        IN  HWND hwndDlg: The query dialog box
        
    Return:
        void
--*/
{ 
    HWND    hwndParent  = GetParent(hwndDlg); 
    DLGHDR* pHdr        = (DLGHDR*)GetWindowLongPtr(hwndParent, GWLP_USERDATA); 
    HWND    hwndTab     = pHdr->hwndTab;
    RECT    rcTab;

    EnableTabBackground(hwndDlg);
    GetWindowRect(hwndTab, &rcTab);

    TabCtrl_AdjustRect(hwndTab, FALSE, &rcTab);

    MapWindowPoints(NULL, GetParent(hwndTab), (LPPOINT)&rcTab, 2);

    SetWindowPos(hwndDlg, 
                 HWND_TOP,
                 rcTab.left, 
                 rcTab.top,
                 rcTab.right - rcTab.left,
                 rcTab.bottom - rcTab.top,
                 SWP_HIDEWINDOW);
    return;
}

void
SearchOnAppOnGetSql(
    IN      HWND    hdlg,
    IN      WPARAM  wParam,
    IN  OUT LPARAM  lParam
    )
/*++

    SearchOnAppOnGetUserSql
    
	Desc:	Processes the WM_USER_GETSQL for the first tab page

	Params:
        IN      HWND    hdlg:   The handle to the First page of the tab
        IN      WPARAM  wParam: The length of the string buffer that is in lParam. The length is in
            TCHARs
            
        IN  OUT LPARAM  lParam: The pointer to the string. This will contain the "FROM" clause.
            The completed SQL will be returned in this.

	Return:
        void
--*/
{   
    TCHAR   szFrom[260];
    TCHAR   szAppName[260];
    TCHAR   szEntryName[MAX_PATH];
    CSTRING strSelectClauses;
    CSTRING strWhereClauses;
    TCHAR*  pszSQL          = (TCHAR*)lParam;
    BOOL    bPreFixAdded    = FALSE; // Whether we have added the 'AND (' prefix for this part of the SQL
    
    if (pszSQL == NULL) {
        assert(FALSE);
        return;
    }
    
    //
    // Set the attributes that we are always going to show
    //
    strSelectClauses = TEXT("APP_NAME, PROGRAM_NAME");

    *szFrom = 0;

    SafeCpyN(szFrom, pszSQL, ARRAYSIZE(szFrom));

    //
    // We will now create the sql.
    //
    *szEntryName = *szAppName = 0;

    GetDlgItemText(hdlg, IDC_APPNAME, szAppName, ARRAYSIZE(szAppName));

    //
    // Get rid of quotes if the user puts them
    //
    ReplaceChar(szAppName, TEXT('\"'), TEXT(' '));

    if (CSTRING::Trim(szAppName) == 0) {
        //
        // Field was empty, replace with wild-card
        //
        SetDlgItemText(hdlg, IDC_APPNAME, TEXT("%"));

        szAppName[0] = TEXT('%');
        szAppName[1] = TEXT('\0');
    }

    GetDlgItemText(hdlg, IDC_ENTRYNAME, szEntryName, ARRAYSIZE(szEntryName));

    ReplaceChar(szEntryName, TEXT('\"'), TEXT(' '));

    if (CSTRING::Trim(szEntryName) == 0) {
        //
        // Field was empty, replace with wild-card
        //
        SetDlgItemText(hdlg, IDC_ENTRYNAME, TEXT("%"));

        szEntryName[0] = TEXT('%');
        szEntryName[1] = TEXT('\0');
    }

    //
    // Set the default where clause for this page
    //
    strWhereClauses.Sprintf(TEXT("APP_NAME = \"%s\" AND PROGRAM_NAME = \"%s\" "),
                            szAppName,
                            szEntryName);

    //
    // Check if the layer check box is selected
    //
    if (SendMessage(GetDlgItem(hdlg, IDC_LAYERS), BM_GETCHECK, 0, 0) == BST_CHECKED) {

        //
        // We now need to show the count and the names of the layers
        //
        strSelectClauses.Strcat(TEXT(", MODE_COUNT, MODE_NAME "));

        //
        // Add the where clauses for the layers
        //
        bPreFixAdded = TRUE;
        strWhereClauses.Strcat(TEXT(" AND ( MODE_COUNT > 0 "));
    }

    //
    // check if the shim check box is selected
    //
    if (SendMessage(GetDlgItem(hdlg, IDC_SHIMS), BM_GETCHECK, 0, 0) == BST_CHECKED) {

        //
        // We now need to show the count and the names of the shims
        //
        strSelectClauses.Strcat(TEXT(", FIX_COUNT, FIX_NAME"));

        //
        // Add the where clauses for the shims
        //
        if (bPreFixAdded == FALSE) {
            strWhereClauses.Strcat(TEXT(" AND ( "));
            bPreFixAdded = TRUE;
        } else {
            strWhereClauses.Strcat(TEXT(" AND "));
        }

        strWhereClauses.Strcat(TEXT(" FIX_COUNT > 0 "));
    }

    //
    // check if the apphelp check box is selected
    //
    if (SendMessage(GetDlgItem(hdlg, IDC_APPHELP), BM_GETCHECK, 0, 0) == BST_CHECKED) {

        if (bPreFixAdded == FALSE) {

            strWhereClauses.Strcat(TEXT(" AND ( "));
            bPreFixAdded = TRUE;

        } else {
            strWhereClauses.Strcat(TEXT(" AND "));
        }

        strWhereClauses.Strcat(TEXT(" PROGRAM_APPHELPUSED = TRUE "));
    }

    if (bPreFixAdded) {

        //
        // Must close the parenthesis
        //
        strWhereClauses.Strcat(TEXT(")"));
    }

    if (StringCchPrintf(pszSQL, 
                        wParam,
                        TEXT("SELECT %s FROM %s WHERE %s"),
                        (LPCTSTR)strSelectClauses,
                        szFrom,
                        (LPCTSTR)strWhereClauses) != S_OK) {

        assert(FALSE);
        Dbg(dlError, "SearchOnAppOnGetSql", "Inadequate buffer size");
    }
}

void
SearchOnFixOnGetSql(
    IN      HWND    hdlg,
    IN      WPARAM  wParam,
    IN  OUT LPARAM  lParam
    )
/*++

    SearchOnAppOnGetUserSql
    
	Desc:	Processes the WM_USER_GETSQL for the first tab page

	Params:
        IN      HWND    hdlg:   The handle to the First page of the tab
        IN      WPARAM  wParam: The length of the string buffer that is in lParam. The length is in
            TCHARs
            
        IN  OUT LPARAM  lParam: The pointer to the string. This will contain the "FROM" clause.
            The completed SQL will be returned in this.

	Return:
        void
--*/

{
    TCHAR*  pszSQL = (TCHAR*)lParam;
    TCHAR   szFrom[MAX_PATH];
    TCHAR   szName[MAX_PATH]; // The string that will take in the contents of the text field
    CSTRING strSelectClauses;
    CSTRING strWhereClauses;
    BOOL    bPreFixAdded    = FALSE; // Whether we have added the 'AND ' prefix for this part of the SQL
    BOOL    bValid          = FALSE; // Did the user select some check box

    if (pszSQL == NULL) {

        assert(FALSE);
        return;
    }

    //
    // Set the attributes that we are always going to show
    //
    strSelectClauses = TEXT("APP_NAME, PROGRAM_NAME");

    *szFrom = 0;
    SafeCpyN(szFrom, pszSQL, ARRAYSIZE(szFrom));

    GetDlgItemText(hdlg, IDC_NAME, szName, ARRAYSIZE(szName));

    //
    // Get rid of quotes if the user puts them
    //
    ReplaceChar(szName, TEXT('\"'), TEXT(' '));

    if (CSTRING::Trim(szName) == 0) {

        //
        // Field was empty, replace with wild-card
        //
        SetDlgItemText(hdlg, IDC_NAME, TEXT("%"));
        szName[0] = TEXT('%');
        szName[1] = TEXT('\0');
    }

    //
    // check if the shim check box is selected
    //
    if (SendMessage(GetDlgItem(hdlg, IDC_SHIM), BM_GETCHECK, 0, 0) == BST_CHECKED) {

        bPreFixAdded = TRUE;

        //
        // We now need to show the names of the fixes
        //
        strSelectClauses.Strcat(TEXT(", FIX_NAME "));

        //
        // Add the where clauses for the fixes
        //
        strWhereClauses.Strcat(TEXT(" FIX_NAME HAS \""));
        strWhereClauses.Strcat(szName);
        strWhereClauses.Strcat(TEXT("\""));

        bValid = TRUE;
    }

    //
    // check if the layer check box is selected
    //
    if (SendMessage(GetDlgItem(hdlg, IDC_MODE), BM_GETCHECK, 0, 0) == BST_CHECKED) {
        //
        // We now need to show the names of the fixes
        //
        strSelectClauses.Strcat(TEXT(", MODE_NAME "));
        
        if (bPreFixAdded) {
            strWhereClauses.Strcat(TEXT(" AND "));
        }

        //
        // Add the where clauses for the layers
        //
        strWhereClauses.Strcat(TEXT(" MODE_NAME HAS \""));
        strWhereClauses.Strcat(szName);
        strWhereClauses.Strcat(TEXT("\""));

        bValid = TRUE;
    }

    if (bValid == FALSE) {
        s_iErrorCode = ERROR_GUI_NOCHECKBOXSELECTED;
    }

    if (StringCchPrintf(pszSQL, 
                        wParam,
                        TEXT("SELECT %s FROM %s WHERE %s"),
                        (LPCTSTR)strSelectClauses,
                        szFrom,
                        (LPCTSTR)strWhereClauses) != S_OK) {

        assert(FALSE);
        Dbg(dlError, "SearchOnFixOnGetSql", "Inadequate buffer space");
    }
}

void
HandleTabNotification(
    IN  HWND   hdlg,
    IN  LPARAM lParam
    )
/*++
    
    HandleTabNotification

	Desc:	Handles the notification messages for the tab control in the query dialog

	Params:
        IN  HWND    hdlg:   The query dialog box
        IN  LPARAM  lParam: The LPARAM of WM_NOTIFY

	Return:
        void
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;
    int     ind = 0;

    switch (pnm->code) {

    // Handle mouse clicks and keyboard events
    case TCN_SELCHANGE:
        OnSelChanged(hdlg);
        break;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Dialog Procs for the pages of the Tab
//
//

INT_PTR CALLBACK
SearchOnAppDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++

    SearchOnAppDlgProc
    
    Desc:   Dialog proc for the first tab page. This page handles searches
            based on the application information.
            
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
        
--*/
{
    int wCode       = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    
    case WM_INITDIALOG:
        {
            //
            // Restrict the  length of the text fields
            //
            SendMessage(GetDlgItem(hdlg, IDC_APPNAME),
                        EM_LIMITTEXT,
                        (WPARAM)LIMIT_APP_NAME,
                        (LPARAM)0);

            SendMessage(GetDlgItem(hdlg, IDC_ENTRYNAME),
                        EM_LIMITTEXT,
                        (WPARAM)MAX_PATH - 1,
                        (LPARAM)0);

            break;
        }

    case WM_USER_NEWQDB:

        SetDlgItemText(hdlg, IDC_APPNAME, TEXT(""));
        SetDlgItemText(hdlg, IDC_ENTRYNAME, TEXT(""));

        SendMessage(GetDlgItem(hdlg, IDC_LAYERS), BM_SETCHECK, BST_UNCHECKED, 0);
        SendMessage(GetDlgItem(hdlg, IDC_SHIMS), BM_SETCHECK, BST_UNCHECKED, 0);
        SendMessage(GetDlgItem(hdlg, IDC_APPHELP), BM_SETCHECK, BST_UNCHECKED, 0);

        DeleteAll(GetParent(hdlg));

        break;

    case WM_USER_GETSQL:
        
        SearchOnAppOnGetSql(hdlg, wParam, lParam);
        break;
        

    default: return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
SearchOnFixDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++
    
    SearchOnFixDlgProc
    
    Desc:   Dialog proc for the second tab page. This page handles searches
            based on the layer/shim name contained in the entries
            
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
--*/
{
    int wCode       = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    
    case WM_INITDIALOG:
        {
            SendMessage(GetDlgItem(hdlg, IDC_NAME),
                        EM_LIMITTEXT,
                        (WPARAM)LIMIT_APP_NAME,
                        (LPARAM)0);
            break;
        }

    case WM_USER_NEWQDB:
        
        SetDlgItemText(hdlg, IDC_NAME, TEXT(""));
        SendMessage(GetDlgItem(hdlg, IDC_SHIM), BM_SETCHECK, BST_UNCHECKED, 0);
        SendMessage(GetDlgItem(hdlg, IDC_MODE), BM_SETCHECK, BST_UNCHECKED, 0);
        DeleteAll(GetParent(hdlg));

        break;

    case WM_USER_GETSQL:
        {
            SearchOnFixOnGetSql(hdlg, wParam, lParam);
            break;
        }

    default: return FALSE;

    }

    return TRUE;
}

void
LoadSelectList(
    IN  HWND    hdlg
    )
/*++
    
    LoadSelectList
    
    Desc:   Loads the list of attributes in the SELECT clause list view. This is used in 
            the advanced tab page
            
    Params:
        IN  HWND    hdlg: The query dialog box
        
    Return:
        void
--*/
{
    HWND    hwndList    = GetDlgItem(hdlg, IDC_SELECT_LIST);
    LVITEM  lvi;
    INT     iIndex      = 0;

    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);
    
    InsertColumnIntoListView(hwndList, 0, 0, 97);

    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    for (iIndex = 0; iIndex < GetSelectAttrCount() ; ++iIndex) {

        lvi.pszText   = AttributeShowMapping[iIndex].szAttribute;
        lvi.iSubItem  = 0;
        lvi.lParam    = iIndex;
        lvi.iItem     = iIndex;

        ListView_InsertItem(hwndList, &lvi);
    }

    //
    // We have to add the "*" separately. Do NOT have this in the AttributeMatchMapping
    //
    lvi.lParam  = iIndex;
    lvi.iItem   = iIndex;
    lvi.pszText = TEXT("*");

    ListView_InsertItem(hwndList, &lvi);

    InvalidateRect(hwndList, NULL, TRUE);

    UpdateWindow(hwndList);
}

void
LoadWhereList(
    HWND hdlg
    )
{
/*++
    LoadWhereList
    
    Desc:   Loads the list of "where" attributes. This is used in 
            the advanced tab page
            
    Params:
        IN  HWND    hdlg: The query dialog box
        
    Return:
        void
--*/ 

    HWND    hwndList    = GetDlgItem(hdlg, IDC_WHERE_LIST);
    LVITEM  lvi         = {0};
    INT     iIndex      = 0;

    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);
    
    InsertColumnIntoListView(hwndList, 0, 0, 97);

    lvi.mask        = LVIF_TEXT | LVIF_PARAM;
    lvi.iSubItem    = 0;

    for (iIndex = 0; iIndex < GetMatchAttrCount(); ++iIndex) {

        lvi.pszText   = AttributeMatchMapping[iIndex].szAttribute;
        lvi.lParam    = iIndex;
        lvi.iItem     = iIndex;

        ListView_InsertItem(hwndList, &lvi);
    }

    InvalidateRect(hwndList, NULL, TRUE);
    UpdateWindow(hwndList);
}

INT_PTR CALLBACK
AdvancedSearchDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++

    AdvancedSearchDlgProc
    
    Desc:   Dialog proc for the fourth tab page. This page handles the advanced
            search option.
            
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
    
--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    
    case WM_INITDIALOG:
        {
            
            SendMessage(GetDlgItem(hdlg, IDC_SELECT), EM_LIMITTEXT,(WPARAM)MAX_SELECT, (LPARAM)0);
            SendMessage(GetDlgItem(hdlg, IDC_WHERE), EM_LIMITTEXT,(WPARAM)MAX_WHERE, (LPARAM)0);

            //
            // Populate the list views with the search and the where attributes
            //
            LoadSelectList(hdlg);
            LoadWhereList(hdlg);
            break;
        }

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR)lParam;
            
            if (lpnmhdr && (lpnmhdr->idFrom == IDC_SELECT_LIST 
                            || lpnmhdr->idFrom == IDC_WHERE_LIST)) {

                HandleAdvancedListNotification(hdlg, lParam);
            }

            break;
        }

    case WM_USER_NEWQDB:

        SetDlgItemText(hdlg, IDC_SELECT, TEXT(""));
        SetDlgItemText(hdlg, IDC_WHERE, TEXT(""));
        DeleteAll(GetParent(hdlg));
        break;

    case WM_USER_GETSQL:
        {
            //
            // lParam:  the pointer to the string. 
            //          This will contain the "FROM" clause.
            //          The completed SQL will be retuned in this.

            // wParam:  the length of the string

            TCHAR*  pszSQL = (TCHAR*) lParam;
            TCHAR   szFrom[MAX_PATH];
            TCHAR   szSelect[1024], szWhere[1024];

            *szSelect = *szWhere = 0;

            if (pszSQL == NULL) {

                assert(FALSE);
                break;
            }

            *szFrom = 0;
            SafeCpyN(szFrom, pszSQL, ARRAYSIZE(szFrom));

            GetDlgItemText(hdlg, IDC_SELECT, szSelect, ARRAYSIZE(szSelect));
            GetDlgItemText(hdlg, IDC_WHERE, szWhere, ARRAYSIZE(szWhere));

            if (CSTRING::Trim(szWhere) != 0) {

                StringCchPrintf(pszSQL, 
                                wParam,
                                TEXT("SELECT %s FROM %s WHERE %s "), 
                                szSelect, 
                                szFrom, 
                                szWhere);

            } else {

                StringCchPrintf(pszSQL, 
                                wParam,
                                TEXT("SELECT %s FROM %s "), 
                                szSelect, 
                                szFrom);
            }

            break;
        }

    default: return FALSE;
    }

    return TRUE;
}

void
HandleAdvancedListNotification(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++
    
    HandleAdvancedListNotification
    
    Desc:   Handles the list notifications for the advanced page of the tab. i.e.
            the SELECT list view and the WHERE list view
    
            This will add the SELECT parameters to the SELECT text box
            if we double click on the "SELECT" list box.
            
            If we double click on the "Where" list box, this routine will
            add the selected param to the WHERE text box
            
    Params:
        IN  HWND    hdlg:   The query dialog box
        IN  LPARAM  lParam: The LPARAM for WM_NOTIFY.
        
    Return:
        void
        
--*/    
{
    LPNMHDR lpnmhdr = (LPNMHDR)lParam;

    if (lpnmhdr == NULL) {
        return;
    }

    switch (lpnmhdr->code) {
    case NM_DBLCLK:
        {   
            HWND                hwndList;           // Handle to either the IDC_SELECT_LIST or the IDC_WHERE_LIST
            BOOL                bEmpty = FALSE;     // Whether the text box was empty. This is needed to determine if we should add a leading ',' 
            HWND                hwndText;
            LVITEM              lvItem;
            TCHAR               szBuffer[MAX_PATH];
            TCHAR               szTextBoxContents[2096];
            LPNMITEMACTIVATE    lpnmitem    = (LPNMITEMACTIVATE) lParam;
            INT                 iLength     = 0;

            if (lpnmitem == NULL) {
                break;
            }
            
            *szBuffer = *szTextBoxContents = 0;

            if (lpnmhdr->idFrom == IDC_SELECT_LIST) {

                hwndList    = GetDlgItem(hdlg, IDC_SELECT_LIST);
                hwndText    = GetDlgItem(hdlg, IDC_SELECT);
                iLength     = MAX_SELECT;

            } else {

                hwndList    = GetDlgItem(hdlg, IDC_WHERE_LIST);
                hwndText    = GetDlgItem(hdlg, IDC_WHERE);
                iLength     = MAX_WHERE;
            }

            lvItem.mask         = LVIF_TEXT;
            lvItem.iItem        = lpnmitem->iItem;
            lvItem.iSubItem     = 0;
            lvItem.pszText      = szBuffer;
            lvItem.cchTextMax   = ARRAYSIZE(szBuffer);

            if (!ListView_GetItem(hwndList, &lvItem)) {
                break;
            }

            GetWindowText(hwndText, szTextBoxContents, iLength);

            if ((lstrlen(szTextBoxContents) + lstrlen(szBuffer) + 3) >= iLength) { // 3 because we might append a " = "
                //
                // We might exceed the limitation that we set using WM_LIMITTEXT, do not allow that.
                //
                MessageBeep(MB_ICONASTERISK);
                break;
            }

            if (CSTRING::Trim(szTextBoxContents) == 0) {
                bEmpty = TRUE;
            }

            if (bEmpty == FALSE) {

                if (lpnmhdr->idFrom == IDC_SELECT_LIST) {
                    StringCchCat(szTextBoxContents, ARRAYSIZE(szTextBoxContents), TEXT(", "));
                } else {
                    StringCchCat(szTextBoxContents, ARRAYSIZE(szTextBoxContents), TEXT(" "));
                }
            }

            StringCchCat(szTextBoxContents, ARRAYSIZE(szTextBoxContents), szBuffer);

            if (lpnmhdr->idFrom == IDC_WHERE_LIST) {
                StringCchCat(szTextBoxContents, ARRAYSIZE(szTextBoxContents), TEXT(" = "));
            }

            SetWindowText(hwndText, szTextBoxContents);

            //
            // Let us now position the caret at the end of the text box
            // We send the text box a VK_END key down message
            //
            SendMessage(hwndText, WM_KEYDOWN, (WPARAM)(INT)VK_END, (LPARAM)0);
            break;
        }
    }
}

void
HandleQueryDBSizing(
    IN  HWND hDlg
    )
/*++
    HandleQueryDBSizing
    
    Desc:   Handles the sizing of the Query db dialog
    
    Params:
        IN  HWND hDlg: The query dialog box    
        
    Return:
        void
--*/
{
    int     nWidth;
    int     nHeight;
    int     nStatusbarTop;
    RECT    rDlg;
    HWND    hwnd;
    RECT    r;

    if (g_cWidthQuery == 0 || g_cWidthQuery == 0) {
        return;
    }
    
    GetWindowRect(hDlg, &rDlg);

    nWidth = rDlg.right - rDlg.left;
    nHeight = rDlg.bottom - rDlg.top;

    int deltaW = nWidth - g_cWidthQuery;
    int deltaH = nHeight - g_cHeightQuery;

    //
    // The status bar
    //
    hwnd = GetDlgItem(hDlg, IDC_STATUSBAR);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left,
               nStatusbarTop = r.top + deltaH,
               r.right - r.left + deltaW,
               r.bottom - r.top,
               TRUE);

    //
    // The List
    //
    hwnd = GetDlgItem(hDlg, IDC_LIST);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left,
               r.top,
               r.right - r.left + deltaW,
               nStatusbarTop - r.top,
               TRUE);


    //
    // The search button
    //
    hwnd = GetDlgItem(hDlg, ID_SEARCH);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left + deltaW,
               r.top,
               r.right - r.left,
               r.bottom - r.top,
               TRUE);


    //
    // The save button
    //
    hwnd = GetDlgItem(hDlg, IDC_SAVE);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left + deltaW,
               r.top,
               r.right - r.left,
               r.bottom - r.top,
               TRUE);

    //
    // The animate control
    //
    hwnd = GetDlgItem(hDlg, IDC_ANIMATE);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left + deltaW,
               r.top,
               r.right - r.left,
               r.bottom - r.top,
               TRUE);
    
    //
    // The cancel button
    //
    hwnd = GetDlgItem(hDlg, IDC_STOP);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left + deltaW,
               r.top,
               r.right - r.left,
               r.bottom - r.top,
               TRUE);
    
    //
    // The new search button
    //
    hwnd = GetDlgItem(hDlg, IDC_NEWSEARCH);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left + deltaW,
               r.top,
               r.right - r.left,
               r.bottom - r.top,
               TRUE);

    //
    // The help button
    //
    hwnd = GetDlgItem(hDlg, ID_QDB_HELP);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left + deltaW,
               r.top,
               r.right - r.left,
               r.bottom - r.top,
               TRUE);


        
    g_cWidthQuery   = nWidth;
    g_cHeightQuery  = nHeight;

}

void
OnSearch(
    IN  HWND hdlg
    )
/*++

    OnSearch

	Desc:	Handles the pressing of the Find Now button

	Params:
        IN  HWND hdlg:  The query dialog box

	Return:
        void
        
    Notes:  We will obtain the query string from the active tab page and 
            then set the text of IDC_SQL (this is an invisible control) to the SQL
            The query processing routines i.e the SQLDriver will read the string 
            from IDC_SQL. This approach is needed to avoid global variables
--*/
{
    TCHAR szSQL[2096];

    //
    // Remove any existing results...
    //
    DeleteAll(hdlg);

    stmt.Close();
    stmt.Init();
    stmt.SetWindow(hdlg);

    //
    // Prepare the FROM string
    //
    *szSQL = 0;

    INT iIndex = SendMessage(GetDlgItem(hdlg, IDC_COMBO), CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR) {
        return;
    }

    LPARAM lParam = SendMessage(GetDlgItem(hdlg, IDC_COMBO), CB_GETITEMDATA, iIndex, 0);

    if (lParam == CB_ERR) {
        return;
    }

    switch (lParam) {
    case DATABASE_ALL:

        StringCchPrintf(szSQL,
                        ARRAYSIZE(szSQL),
                        TEXT("%s, %s ,%s"),
                        DatabasesMapping[IND_SYSTDB].szDatabaseType,
                        DatabasesMapping[IND_INSTDB].szDatabaseType,
                        DatabasesMapping[IND_CUSTDB].szDatabaseType);
        break;
    
    case DATABASE_TYPE_GLOBAL:

        SafeCpyN(szSQL, DatabasesMapping[IND_SYSTDB].szDatabaseType, ARRAYSIZE(szSQL));
        break;

    case DATABASE_TYPE_INSTALLED:

        SafeCpyN(szSQL, DatabasesMapping[IND_INSTDB].szDatabaseType, ARRAYSIZE(szSQL));
        break;

    case DATABASE_TYPE_WORKING:

        SafeCpyN(szSQL, DatabasesMapping[IND_CUSTDB].szDatabaseType, ARRAYSIZE(szSQL));
        break;
    }

    DLGHDR *pHdr = (DLGHDR*)GetWindowLongPtr(hdlg, GWLP_USERDATA);

    if (pHdr == NULL) {
        assert(FALSE);
        return;
    }

    s_iErrorCode = 0;

    SendMessage(pHdr->hwndPages[pHdr->iPresentTabIndex], 
                WM_USER_GETSQL, 
                (WPARAM)ARRAYSIZE(szSQL), 
                (LPARAM)szSQL);

    if (!s_iErrorCode) {

        SetDlgItemText(hdlg, IDC_SQL, szSQL);
        Start(hdlg);

    } else {

        //
        // Display the proper error
        //
        TCHAR   szErrormsg[512];

        *szErrormsg = 0;

        switch (s_iErrorCode) {
        case ERROR_GUI_NOCHECKBOXSELECTED:

            SafeCpyN(szErrormsg, 
                     GetString(IDS_ERROR_GUI_NOCHECKBOXSELECTED), 
                     ARRAYSIZE(szErrormsg));
            break;
        }

        MessageBox(hdlg, szErrormsg, g_szAppName, MB_ICONINFORMATION);
    }
}

void
DoNewQdb(
    IN  HWND hdlg
    )
/*++
    
    DoNewQdb
    
	Desc:	Handles the pressing of the New Search button

	Params:
        IN  HWND hdlg:  The query dialog box

	Return:
        void
--*/        
{
    DLGHDR *pHdr = (DLGHDR*)GetWindowLongPtr(hdlg, GWLP_USERDATA);

    if (pHdr == NULL) {
        assert(FALSE);
        return;
    }

    //
    // Request the active tab page to clear its contents
    //
    SendMessage(pHdr->hwndPages[pHdr->iPresentTabIndex], WM_USER_NEWQDB, 0, 0);
}

void
DeleteAll(
    IN  HWND hdlg
    )
/*++
    
    DeleteAll

	Desc:	Deletes all the results items from the query dialog's search result
            list view
            
	Params: 
        IN  HWND hdlg: The query dialog box

	Return:
        void
    
    Notes:  We do not try to free the pointers in the lParam of the list view items. 
    
            If we have done a SQL query:
            The lParam of the list view will be pointers to items of type PRESULT_ITEM
            which are freed when we close the statement. (Closing the statement closes
            the ResultSet of the statement)
                
            If we have done a special database query like searching for fixes that 
            have some words in their description then the lParam will point to the
            FIX_SHIM in the database and we do not want to free that
--*/
{
    HWND    hwndList    = GetDlgItem(hdlg, IDC_LIST);
    UINT    uColCount   = stmt.GetShowList()->m_uCount;
    INT     iIndex      = 0;

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);

    if (s_bEmptyHeader == FALSE) {

        for (iIndex = uColCount; iIndex >= 0; --iIndex) {
            ListView_DeleteColumn(hwndList, iIndex);
        }

        InsertColumnIntoListView(hwndList, TEXT(""), 0, 100);
        s_bEmptyHeader = TRUE;
    }

    ListView_DeleteAllItems(hwndList);

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

    SetStatus(GetDlgItem(hdlg, IDC_STATUSBAR), TEXT(""));

    UpdateWindow(hwndList);
}

void
SaveResultsQdb(
    IN  HWND hdlg
    )
/*++
    
    SaveResultsQdb

	Desc:	Saves all the results items from the query dialog's search result
            list view in a tab separated text file
            
	Params: 
        IN  HWND hdlg: The query dialog box

	Return:
        void
--*/

{
    CSTRING strFileName;
    TCHAR   szTitle[256], szFilter[128], szExt[8];

    *szTitle = *szFilter = *szExt = 0;

    BOOL bResult = GetFileName(hdlg, 
                               GetString(IDS_SAVE_RESULTS_TITLE, szTitle, ARRAYSIZE(szTitle)),
                               GetString(IDS_SAVE_RESULTS_FILTER, szFilter, ARRAYSIZE(szFilter)),
                               TEXT(""),
                               GetString(IDS_SAVE_RESULTS_EXT, szExt, ARRAYSIZE(szExt)),
                               OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
                               FALSE,
                               strFileName,
                               TRUE);

    if (bResult) {

        SetCursor(LoadCursor(NULL, IDC_WAIT));
        SaveListViewToFile(GetDlgItem(hdlg, IDC_LIST), 
                           stmt.GetShowList()->m_uCount, 
                           strFileName.pszString, 
                           NULL);

        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
}

void
GotoQdbEntry(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++

    GotoQdbEntry
    
    Desc:   Selects the entry in the entry tree.
            The lParam is the lParam of the list view row that specifies that entry.
            
    Params:
        IN  HWND    hdlg:   The query db dialog box
        IN  LPARAM  lParam: The list view item whose 'details' we want to see
--*/
{
    
    PRESULT_ITEM pResult;
    PDBENTRY     pApp;

    if (g_iLastSearchType == QDB_PAGE3) {
        //
        // We had performed a search for shims last time, so we do not have PRESULT_ITEM
        // items in the list view
        //
        goto End;
    }

    if (g_bSomeWizardActive) {
        //
        // We do not want that the focus should go to some other database, because
        // some wizard is active, which believes that he is modal.
        //
        MessageBox(g_hdlgQueryDB, 
                   GetString(IDS_SOMEWIZARDACTIVE), 
                   g_szAppName, 
                   MB_ICONINFORMATION);
        goto End;

    }
    
    pResult = (PRESULT_ITEM)lParam;
    pApp    = NULL;

    if (pResult == NULL) {
        assert(FALSE);
        goto End;
    }

    pApp = GetAppForEntry(pResult->pDatabase, pResult->pEntry);

    //
    // First select the app from in the db tree.
    //
    HTREEITEM hItemApp = DBTree.FindChild(pResult->pDatabase->hItemAllApps, (LPARAM)pApp);

    if (hItemApp == NULL) {
        MessageBox(hdlg, GetString(IDS_NOLONGEREXISTS), g_szAppName, MB_ICONWARNING);
        goto End;
    }

    TreeView_SelectItem(DBTree.m_hLibraryTree , hItemApp);

    //
    // Now from the entry tree select the particular entry
    //
    HTREEITEM hItemEntry = CTree::FindChild(g_hwndEntryTree, TVI_ROOT, (LPARAM)pResult->pEntry);

    if (hItemEntry == NULL) {

        MessageBox(hdlg, GetString(IDS_NOLONGEREXISTS), g_szAppName, MB_ICONWARNING);
        goto End;
    }

    TreeView_SelectItem(g_hwndEntryTree, hItemEntry);
    SetFocus(g_hwndEntryTree);

End: ;

}   

INT_PTR CALLBACK
QdbWaitDlg(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++
    
    QdbWaitDlg
    
    Desc:   Dialog Proc for the wait window which will pop up, 
            if we are trying to close the query window,
            when it the thread is still doing some useful work.
            
            This will be essentially true when we are trying to load the system 
            database or we are trying to populate the list view
            
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
    
--*/
{
    int     wCode       = LOWORD(wParam);
    int     wNotifyCode = HIWORD(wParam);
    static  HWND    s_hwndPB;

    switch (uMsg) {
        
    case WM_INITDIALOG:
        
        s_hwndPB = GetDlgItem(hdlg, IDC_PROGRESS);
        SendMessage(s_hwndPB, PBM_SETRANGE, 0, MAKELPARAM(0, 2000));  
        SendMessage(s_hwndPB, PBM_SETSTEP, (WPARAM) 1, 0); 
        SetTimer(hdlg, 0, 100, NULL);
        break;

    case WM_TIMER:

        if (s_hThread) {
            if (WAIT_OBJECT_0 == WaitForSingleObject(s_hThread, 0)) {
                
                //
                // The handle to the thread is closed and nulled when it is 
                // about to terminate
                //
                KillTimer(hdlg, 0);

                s_hThread       = NULL;
                s_hWaitDialog   = NULL;

                SendMessage(s_hwndPB, PBM_SETPOS, MAX_PROGRESS, 0); 
                SendMessage(g_hdlgQueryDB, WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), 0);
                
                DestroyWindow(hdlg);
            } else {
                SendMessage(s_hwndPB, PBM_STEPIT, 0, 0); 
            }

        } else {
            
            KillTimer(hdlg, 0);
            s_hWaitDialog   = NULL;

            SendMessage(s_hwndPB, PBM_SETPOS, MAX_PROGRESS, 0); 

            //
            // Let the user see that it is completed
            //
            Sleep(1000);

            SendMessage(g_hdlgQueryDB, WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), 0);
            DestroyWindow(hdlg);
        }

        break;

    case WM_COMMAND:

        switch (wCode) {
        case IDCANCEL:

            KillTimer(hdlg, 0);
            DestroyWindow(hdlg);
            break;

        default: return FALSE;
        }

        break;

    case WM_DESTROY:
        s_hWaitDialog = NULL;
        break;

    default: return FALSE;

    }

    return TRUE;
}

void
SearchAndAddToUIFixes(
    IN      CSTRINGLIST&    strlTokens,
    IN      QDB_SEARCH_TYPE searchtype,
    IN      PVOID           pShimOrFix,
    IN      TYPE            type
    )
/*++
    SearchAndAddToUIFixes
    
    Desc:   Typecasts pShimOrFix to either a shim or a flag pointer as per type and 
            then checks if it contains matches the tokens
    
    Params:
        IN  CSTRINGLIST&    strlTokens: The list of tokens
        IN  QDB_SEARCH_TYPE searchtype: The type of search to perform
        IN  PVOID           pShimOrFix: Pointer to a shim or a fix
        IN  TYPE            type:       Whether this is a shim or a fix
        
    Return:
        void
--*/
{
    PSTRLIST    pslListOfTokensLoop = strlTokens.m_pHead;
    BOOL        bFound              = FALSE;
    LVITEM      lvi;
    HWND        hwndSearchList      = NULL;
    PCTSTR      pszName             = NULL;
    PCTSTR      pszDescription      = NULL;

    if (pShimOrFix == NULL) {
        assert(FALSE);
        return;
    }

    pShimOrFix = (PSHIM_FIX)pShimOrFix;

    if (type == FIX_SHIM) {

        pszName         = (LPCTSTR)((PSHIM_FIX)pShimOrFix)->strName;
        pszDescription  = (LPCTSTR)((PSHIM_FIX)pShimOrFix)->strDescription;

    } else if (type ==  FIX_FLAG) {        

        pszName         = (LPCTSTR)((PFLAG_FIX)pShimOrFix)->strName;
        pszDescription  = (LPCTSTR)((PFLAG_FIX)pShimOrFix)->strDescription;

    } else {
        assert(FALSE);
        return;
    }

    hwndSearchList = GetDlgItem(g_hdlgQueryDB, IDC_LIST);

    //
    // Check if the present fix has the desired tokens. If we search type specifies
    // all tokens then we have to look for all tokens otherwise we can break 
    // when we find the first token that is present in the name of desc. of the shim
    //
    while (pslListOfTokensLoop) {

        //
        // Does the name of the fix has this token?
        //
        bFound = (StrStrI(pszName, 
                          (LPCTSTR)pslListOfTokensLoop->szStr)  == NULL) ? FALSE : TRUE ;

        if (!bFound) {
            //
            //  Name does not contain this token, so we must look in the description text
            //
            bFound = (StrStrI(pszDescription,
                              (LPCTSTR)pslListOfTokensLoop->szStr) == NULL) ? FALSE : TRUE;
        }

        if (searchtype == QDB_SEARCH_ALLWORDS && !bFound) {
            //
            // We wanted that all words should be found and we did not find this particular
            // word, search failed
            //
            break;
        }

        if (searchtype == QDB_SEARCH_ANYWORD && bFound) {
            //
            // We wanted that any word should match and this word was found, so 
            // search was successfull
            //
            break;
        }

        //
        // Search if the next token matches
        //
        pslListOfTokensLoop = pslListOfTokensLoop->pNext;
    }

    if (bFound) {
        //
        // This fix matched our criteria, so add this to the list view
        //
        lvi.mask        = LVIF_TEXT | LVIF_PARAM;
        lvi.lParam      = (LPARAM)pShimOrFix;
        lvi.pszText     = (LPTSTR)pszName;
        lvi.iSubItem    = 0;

        ListView_InsertItem(hwndSearchList, &lvi);
    }
}

void
DoTheFixesSearch(
    IN  HWND hdlg
    )
/*++
    
    DoTheFixesSearch
    
    Desc:   Searches for fixes in the system database that have the words that the user 
            wants to look for
            
    Params:
        IN  HWND hdlg:  The fix search page in the query db tab. This is the fourth page of the
            tab
            
    Return:
        void
--*/
{
    LPARAM          lParam;
    INT             iIndex;
    QDB_SEARCH_TYPE searchtype;
    TCHAR           szSearch[MAX_FIXDESC_SEARCH];
    HWND            hwndSearch  = GetDlgItem(hdlg, IDC_TEXT);
    HWND            hwndCombo   = GetDlgItem(hdlg, IDC_COMBO);
    HWND            hwndList    = GetDlgItem(g_hdlgQueryDB, IDC_LIST);
    PSHIM_FIX       psfLoop     = GlobalDataBase.pShimFixes;
    PFLAG_FIX       pffLoop     = GlobalDataBase.pFlagFixes;
    BOOL            bFound      = FALSE; 
    CSTRINGLIST     strlTokens;
    CSTRING         strStatus;
    TCHAR           szBuffer[32];
    INT             iTotalResults;
    
    //
    // Clear any existing results
    //
    DeleteAll(GetParent(hdlg));
    SetDlgItemText(hdlg, IDC_DESC, TEXT(""));

    //
    // Users cannot double click on the search list if we are showing shims, so 
    // we disable the text that says they can.
    //
    ENABLEWINDOW(GetDlgItem(GetParent(hdlg), IDC_STATIC_CAPTION), FALSE);
    
    if (s_bEmptyHeader) {
        //
        // If the empty column is still there, must get rid of it
        //
        ListView_DeleteColumn(hwndList, 0);
        s_bEmptyHeader = FALSE;
    }

    //
    // Insert the new column
    //
    InsertColumnIntoListView(hwndList,
                             GetString(IDS_COMPATFIXES),
                             0,
                             100);
    
    GetWindowText(hwndSearch, szSearch, ARRAYSIZE(szSearch));

    if (CSTRING::Trim(szSearch) == 0) {
        //
        // No text was typed in for search
        //
        MessageBox(hdlg,
                   GetString(IDS_QDB_NO_TEXTTO_SEARCH),
                   g_szAppName,
                   MB_ICONWARNING);
        goto End;
    }

    //
    // Get the search type
    // 
    iIndex = SendMessage(GetDlgItem(hdlg, IDC_COMBO), CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR) {
        assert(FALSE);
        goto End;
    }

    lParam = SendMessage(hwndCombo, CB_GETITEMDATA, iIndex, 0);

    if (lParam == CB_ERR) {
        assert(FALSE);
        goto End;
    }

    searchtype = (QDB_SEARCH_TYPE)lParam;

    //
    // The search string is comma separated, get the individual tokens and search for that token 
    // first in the name of the fix and then in the description. As for now we do not do any
    // rating on the search. We show results as they come
    //

    //
    // Fist get the tokens
    //
    if (Tokenize(szSearch, lstrlen(szSearch), TEXT(","), strlTokens)) {
        //
        // We found some tokens, now for each token let us see if it is in the fix name 
        // or the fix description
        //

        //
        // Search in the shims and add to the list view
        //
        while (psfLoop) {

            if (psfLoop->bGeneral || g_bExpert) {
                //
                // In non-expert mode we should only show the general shims
                //
                SearchAndAddToUIFixes(strlTokens, searchtype, psfLoop, FIX_SHIM); 
            }

            psfLoop = psfLoop->pNext;
        }

        //
        // Search in the flags and add it to the list view
        //
        while (pffLoop) {

            if (pffLoop->bGeneral || g_bExpert) {
                //
                // In non-expert mode we should only show the general flags
                //
                SearchAndAddToUIFixes(strlTokens, searchtype, pffLoop, FIX_FLAG); 
            }
            
            pffLoop = pffLoop->pNext;
        }
    }

End:

    //
    // Set the status bar text to how many results we have found
    //
    *szBuffer = 0;
    
    iTotalResults = ListView_GetItemCount(hwndList);

    strStatus.Sprintf(GetString(IDS_QDB_COUNT),
                      _itot(iTotalResults, szBuffer, 10));

    SetStatus(GetDlgItem(GetParent(hdlg), IDC_STATUSBAR), strStatus); 

}

INT_PTR
SearchFixDescDlgProcOnInitDialog(
    IN  HWND hdlg
    )
/*++
    
    SearchFixDescDlgProcOnInitDialog

	Desc:	The handler of WM_INITDIALOG for the third qdb tab page. This page
            searches for fixes based on key words that are searached in the description
            text of the fix

	Params:
        IN  HWND hDlg: The third wizard page

	Return:
        TRUE
--*/
{
    
    INT     iIndex      = 0;
    HWND    hwndSearch  = GetDlgItem(hdlg, IDC_TEXT);
    HWND    hwndCombo   = GetDlgItem(hdlg, IDC_COMBO);

    //
    // Restrict the  length of the text
    //
    SendMessage(hwndSearch, EM_LIMITTEXT, (WPARAM)MAX_FIXDESC_SEARCH - 1, (LPARAM)0);

    //
    // Add the search type strings
    //
    iIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_QDB_ANYWORD));
    SendMessage(hwndCombo, CB_SETITEMDATA, iIndex, (LPARAM)QDB_SEARCH_ANYWORD);

    iIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_QDB_ALLWORDS));
    SendMessage(hwndCombo, CB_SETITEMDATA, iIndex, (LPARAM)QDB_SEARCH_ALLWORDS);

    //
    // Select the first string
    //
    SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);
    
    return TRUE;
}

INT_PTR CALLBACK
SearchFixDescDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++

    SearchFixDescDlgProc
    
    Desc:   Dialog proc for the third tab page. This page finds fixes that have specific 
            words in their description text or in their names
            
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
        
--*/
{
    int wCode       = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    
    case WM_INITDIALOG:

        SearchFixDescDlgProcOnInitDialog(hdlg);
        break;

    case WM_USER_NEWQDB:

        SetDlgItemText(hdlg, IDC_TEXT, TEXT(""));
        SetDlgItemText(hdlg, IDC_DESC, TEXT(""));

        DeleteAll(GetParent(hdlg));
        break;

    case WM_USER_DOTHESEARCH:

        SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoTheFixesSearch(hdlg);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        break;

    default: return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\wizard.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    wizard.cpp

Abstract:

    Code for the Fix Wizard
    
Author:

    kinshu created  July 2, 2001
    
Notes:

    1. Whenever we are using Delete*****, please make sure that after return the 
    arg passed is nulled as well.
    
Revision History:

--*/

#include "precomp.h"

//////////////////////// Extern variables /////////////////////////////////////

extern HINSTANCE        g_hInstance;
extern HIMAGELIST       g_hImageList;
extern struct DataBase  GlobalDataBase;

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Defines //////////////////////////////////////////////

// The tree in the matching file page of the wizard has its own imagelist. This is the index of
// the attribute  image in that imagelist
#define IMAGE_ATTRIBUTE_MATCHTREE   1;


// These are the various pages of the wizard

// The first page, we get the app info here
#define PAGE_APPNAME                0

// The second page, we get the layers to be applied here
#define PAGE_LAYERS                 1

// The third page, we get the shims to be applied here
#define PAGE_SHIMS                  2

// The fourth page, we get the mathcing files for the entry here
#define PAGE_MATCH                  3

// Total number of pages in the wizard
#define NUM_PAGES                   4

// The first column in the get params dialog list view. The type of module, include or exclude
#define COLUMN_TYPE                 0

// The second column in the get params dialog. The  name of the module
#define COLUMN_NAME                 1 

//
// maximum number of matching files that we should be considered. Note that this does
// not mean that an entry can have MAX_FILES matching files. From MAX_FILES files we will
// select the largest MAX_AUTO_MATCH files
#define MAX_FILES                   100

// The length of the module name in chars. This does not include the terminating NULL
#define MAX_MODULE_NAME             (MAX_PATH - 1)

// The length of the command line in chars. This does not include the terminating NULL
#define MAX_COMMAND_LINE            (511)

///////////////////////////////////////////////////////////////////////////////


//////////////////////// Global Variables /////////////////////////////////////

//
// Should we test for the checking  off of the check boxes? We do it only if this variable is TRUE
// Otherwise when we show all the items in ShowItems(), we might get the prompt even then
// This is a hack and needs to be corrected <TODO>
BOOL    g_bNowTest = FALSE;

/*++
    WARNING:    Do not change the position of these strings, they should match 
                with the dialog IDD_LAYERS radio buttons
--*/

// The names of the various OS layers as they are in the system db: sysmain.sdb
TCHAR *s_arszOsLayers[] = {
    TEXT("Win95"),
    TEXT("NT4SP5"),
    TEXT("Win98"),
    TEXT("Win2000")
};

// The layers have changed since the last time we have populated the shims list 
BOOL g_bLayersChanged = FALSE; 

//
// The LUA layer needs to be treated specially - when the user selects it
// on the select layer page, we only check the checkbox but really add the
// shims in the layer to the shim fix list instead of add the layer to the 
// layer fix list. This allows us to later change the lua data around in 
// the DBENTRY without affect the layer globally.
BOOL g_bIsLUALayerSelected = FALSE;

//
// Used for indicating whether the LUA wizard should start when the app fix wizard
// is completed
BOOL g_bShouldStartLUAWizard = FALSE;

// The pointer to the current wizard object
CShimWizard*        g_pCurrentWizard = NULL;

// The handle to the matching file tree
static HWND         s_hwndTree = NULL;

// The handle to the tool tip control associated with the list view in the shims page
static HWND         s_hwndToolTipList;

// The image list for the tree in the matching files page
static HIMAGELIST s_hMatchingFileImageList;

// This will be true if we change some stuff in the shim page.
static BOOL         s_bLayerPageRefresh;

// The handle to the layer list view in the second wizard page
static HWND         s_hwndLayerList;

// The handle to the fixes list view in the second wizard page
static HWND s_hwndShimList;

// Are we showing all the shims or only the selected shims
static BOOL s_bAllShown = TRUE;


///////////////////////////////////////////////////////////////////////////////


//////////////////////// Function Declarations ////////////////////////////////

INT_PTR
GetAppNameDlgOnCommand(
    HWND    hDlg,
    WPARAM  wParam
    );

INT_PTR
GetAppNameDlgOnInitDialog(
    HWND hDlg
    );

INT_PTR
GetAppNameDlgOnNotify(
    HWND    hDlg,
    LPARAM  lParam
    );


INT_PTR
SelectLayerDlgOnCommand(
    HWND    hDlg,
    WPARAM  wParam
    );

INT_PTR
SelectLayerDlgOnDestroy(
    void
    );

INT_PTR
SelectLayerDlgOnNotify(
    HWND    hDlg,
    LPARAM  lParam
    );

INT_PTR
SelectLayerDlgOnInitDialog(
    HWND hDlg
    );

INT_PTR
SelectShimsDlgOnNotify(
    HWND    hDlg,
    LPARAM  lParam
    );

INT_PTR
SelectShimsDlgOnInitDialog(
    HWND hDlg
    );

INT_PTR
SelectFilesDlgOnInitDialog(
    HWND hDlg
    );

INT_PTR
SelectFilesDlgOnCommand(
    HWND    hDlg,
    WPARAM  wParam
    );

INT_PTR
SelectFilesDlgOnMatchingTreeRefresh(
    IN  HWND hDlg
    );

INT_PTR
SelectFilesDlgOnNotify(
    HWND    hDlg,
    LPARAM  lParam
    );

INT_PTR
SelectShimsDlgOnCommand(
    HWND    hDlg,
    WPARAM  wParam
    );

INT_PTR
SelectShimsDlgOnTimer(
    HWND hDlg
    );

INT_PTR
SelectShimsDlgOnDestroy(
    void
    );

BOOL
AddLuaShimsInEntry(
    PDBENTRY        pEntry,
    CSTRINGLIST*    pstrlShimsAdded = NULL
    );

void
ShowParams(
    HWND    hDlg,
    HWND    hwndList
    );

void 
AddMatchingFileToTree(
    HWND            hwndTree,
    PMATCHINGFILE   pMatch,
    BOOL            bAddToMatchingList
    );

INT_PTR
CALLBACK 
SelectShims(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void
HandleShowAllAtrr(
    HWND hdlg
    );

void
ChangeShimIcon(
    LPCTSTR pszItem
    );

void
HandleAddMatchingFile(
    HWND        hdlg,
    CSTRING&    strFilename,
    CSTRING&    strRelativePath, 
    DWORD       dwMask = DEFAULT_MASK
    );

BOOL
HandleAttributeTreeNotification(
    HWND   hdlg,
    LPARAM lParam
    );

///////////////////////////////////////////////////////////////////////////////


BOOL
LayerPresent(
    IN  PLAYER_FIX          plf, 
    IN  PDBENTRY            pEntry,
    OUT PLAYER_FIX_LIST*    ppLayerFixList
    )
/*++

    LayerPresent

    Desc:	Checks if the entry pEntry is fixed with layer plf. 
            If yes and ppLayerFixList is not NULL, stores the corresponding pointer to layer-fix 
            list for plf in pEntry in ppLayerFixList

    Params:
        IN  PLAYER_FIX          plf             : The layer to search
        IN  PDBENTRY            pEntry          : The entry in which to search
        OUT PLAYER_FIX_LIST*    ppLayerFixList  : If the layer is present in pEntry and 
            ppLayerFixList is not NULL, stores the corresponding pointer to layer-fix 
            list for plf in pEntry in ppLayerFixList

    Return:
        TRUE    : pEntry is fixed with plf
        FALSE   : Otherwise
--*/
{
    if (pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    PLAYER_FIX_LIST plfl = pEntry->pFirstLayer;

    //
    // For all layers applied to this entry, check if one of them is the one that we
    // are looking for
    //
    while (plfl) {

        if (plfl->pLayerFix == plf) {

            if (ppLayerFixList) {
                *ppLayerFixList = plfl;
            }

            return TRUE;
        }

        plfl = plfl->pNext;
    }

    return FALSE;
}

BOOL
ShimPresent(
    IN  PSHIM_FIX        psf, 
    IN  PDBENTRY         pEntry,
    OUT PSHIM_FIX_LIST*  ppShimFixList
    )
/*++

    ShimPresent

    Desc:	Checks if the entry pEntry is fixed with shim psf. 
            If yes and ppShimFixList is not NULL, stores the corresponding pointer to shim-fix 
            list for psf in pEntry in ppShimFixList

    Params:
        IN  PSHIM_FIX           psf:            The shim to search
        IN  PDBENTRY            pEntry:         The entry in which to search
        OUT PSHIM_FIX_LIST*    ppShimFixList:   If the shim is present in pEntry and 
            ppShimFixList is not NULL, stores the corresponding pointer to shim-fix 
            list for psf in pEntry in ppShimFixList

    Return:
        TRUE:   pEntry is fixed with psf
        FALSE:  Otherwise
--*/
{

    if (pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    PSHIM_FIX_LIST psfList = pEntry->pFirstShim;

    //
    // For all the shims applied to this entry check if,one of them is the one we are lookign for 
    //
    while (psfList) {

        if (psfList->pShimFix)

            if (psfList->pShimFix == psf) {

                if (ppShimFixList) {
                    *ppShimFixList = psfList;
                }

                return TRUE;
            }

        psfList = psfList->pNext;
    }

    return FALSE;
}


BOOL
FlagPresent(
    IN  PFLAG_FIX       pff, 
    IN  PDBENTRY        pEntry,
    OUT PFLAG_FIX_LIST* ppFlagFixList
    )
/*++

    FlagPresent

    Desc:	Checks if the entry pEntry is fixed with flag pff. 
            If yes and ppFlagFixList is not NULL, stores the corresponding pointer to flag-fix 
            list for pff in pEntry in ppFlagFixList

    Params:
        IN  PFLAG_FIX           pff:            The flag to search
        IN  PDBENTRY            pEntry:         The entry in which to search
        OUT PFLAG_FIX_LIST*    ppFlagFixList:   If the flag is present in pEntry and 
            ppFlagFixList is not NULL, stores the corresponding pointer to flag-fix 
            list for pff in pEntry in ppFlagFixList

    Return:
        TRUE    : pEntry is fixed with pff
        FALSE   : Otherwise
--*/

{
    if (pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    PFLAG_FIX_LIST pffList = pEntry->pFirstFlag;

    //
    // For all the flags applied to this entry check if,one of them is the one 
    // we are looking for 
    //
    while (pffList) {

        if (pffList->pFlagFix)

            if (pffList->pFlagFix == pff) {

                if (ppFlagFixList) {
                    *ppFlagFixList = pffList;
                }

                return TRUE;
            }

        pffList = pffList->pNext;
    }

    return FALSE;
}

CShimWizard::CShimWizard()
/*++

    CShimWizard::CShimWizard

    Desc:	Constructor for CShimWizard
         
--*/
{
    dwMaskOfMainEntry = DEFAULT_MASK;
}

BOOL
CShimWizard::CheckAndSetLongFilename(
    IN  HWND    hDlg,
    IN  INT     iStrID
    )
/*++
    CShimWizard::CheckAndSetLongFilename

    Desc:	If we do not have the complete path of the present entry being fixed, 
            prompts for that and pops up a open common dialog box to select the file, and
            to get the complete path

    Params:
        IN  HWND    hDlg:   Parent for the open common dialog  or any messagebox
        IN  INT     iStrID: String resource id for the prompt message asking for 
            the complete path of the file being fixed 

    Return:
        TRUE:   The complete path has been successfully set
        FALSE:  Otherwise
--*/
{
    TCHAR   chTemp;
    CSTRING strFilename;
    CSTRING strExename;
    TCHAR   szBuffer[512] = TEXT("");

    if (g_pCurrentWizard->m_Entry.strFullpath.Length() == 0) {
        g_pCurrentWizard->m_Entry.strFullpath = TEXT("XXXXXX");
    }

    if (g_pCurrentWizard->m_Entry.strFullpath.GetChar(1, &chTemp)) {

        if (chTemp != TEXT(':')) {
            //
            // Check if the file is on a network. filenames will begin with "\\"
            //
            if (chTemp == TEXT('\\')) {
                g_pCurrentWizard->m_Entry.strFullpath.GetChar(0, &chTemp);

                if (chTemp == TEXT('\\')) {
                    return TRUE;
                }
            }

            //
            // We do not have the complete path.
            //
            MessageBox(hDlg,
                       CSTRING(iStrID),
                       g_szAppName,
                       MB_OK | MB_ICONINFORMATION);

            //
            // Get the long file name. The g_pCurrentWizard->m_Entry.strFullpath has been
            // set in the first page. So if we are editing and we do not have the complete
            // path, g_pCurrentWizard->m_Entry.strFullpath will have at least have 
            // the exe name 
            //
            strExename = g_pCurrentWizard->m_Entry.strFullpath;
            strExename.ShortFilename();

            GetString(IDS_EXEFILTER, szBuffer, ARRAYSIZE(szBuffer));

            //
            // Prompt the user to give us the complete path for the file being fixed
            // We need the complete path, so that we can get the relative paths for
            // any matching files that we might add
            //
            while (1) {

                if (GetFileName(hDlg,
                                CSTRING(IDS_GETLONGNAME),
                                szBuffer,
                                TEXT(""),
                                CSTRING(IDS_EXE_EXT),
                                OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
                                TRUE,
                                strFilename)) {

                    CSTRING strTemp = strFilename;

                    strTemp.ShortFilename();

                    if (strExename != strTemp) {
                        //
                        // The user gave us the path of some file, whose file and exe components
                        // do not match the program file being fixed
                        //
                        MessageBox(hDlg,
                                   CSTRING(IDS_DOESNOTMATCH),
                                   g_szAppName,
                                   MB_ICONWARNING);
                        //
                        // So we ask the user to try again
                        //
                        continue;
                    }

                    //
                    // We now have the complete path for the file being fixed
                    //
                    m_Entry.strFullpath = strFilename;

                    return TRUE;

                } else {
                    return FALSE;
                }
            }
        }

    } else {
        //
        // There was some error
        //
        assert(FALSE);
        return FALSE;
    }

    return TRUE;
}


BOOL
IsOsLayer(
    IN  PCTSTR pszLayerName
    )
/*++

    IsOsLayer
    
	Desc:	Is the passed layer name an OS layer?

	Params:
        IN  TCHAR *pszLayerName: The layer name to check for

	Return:
        TRUE:   If this is the name of an OS  layer
        FALSE:  Otherwise
--*/
{
    INT iTotalOsLayers = sizeof (s_arszOsLayers) / sizeof(s_arszOsLayers[0]);

    for (int iIndex = 0; 
         iIndex < iTotalOsLayers; 
         ++iIndex) {

        if (lstrcmpi(s_arszOsLayers[iIndex], pszLayerName) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
CShimWizard::BeginWizard(
    IN  HWND        hParent,
    IN  PDBENTRY    pEntry,
    IN  PDATABASE   pDatabase,
    IN  PBOOL       pbShouldStartLUAWizard
    )
/*++

    CShimWizard::BeginWizard

	Desc:	Starts up the wizard

	Params:
        IN  HWND        hParent:    The parent of the wizard
        IN  PDBENTRY    pEntry:     The entry which has to be editted. If this is NULL, then we
            want to create a new fix entry.
            
        IN  PDATABASE   pDatabase:  The present database. 

	Return:
        TRUE:   If the user presses FINISH
        FALSE:  Otherwise
--*/
{
    PROPSHEETPAGE   Pages[11] = {0};

    g_bIsLUALayerSelected   = FALSE;
    g_bShouldStartLUAWizard = FALSE;

    m_pDatabase = pDatabase;

    ZeroMemory(Pages, sizeof(Pages));

    if (pEntry == NULL) {
        //
        // Create a new fix.
        //
        ZeroMemory(&m_Entry, sizeof(m_Entry));

        GUID Guid;

        CoCreateGuid(&Guid);

        StringCchPrintf(m_Entry.szGUID,
                        ARRAYSIZE(m_Entry.szGUID),
                        TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                        Guid.Data1,
                        Guid.Data2,
                        Guid.Data3,
                        Guid.Data4[0],
                        Guid.Data4[1],
                        Guid.Data4[2],
                        Guid.Data4[3],
                        Guid.Data4[4],
                        Guid.Data4[5],
                        Guid.Data4[6],
                        Guid.Data4[7]);

        m_bEditing = FALSE;

    } else {
        //
        // Edit the passed fix.
        //
        m_bEditing = TRUE;

        //
        // Make a copy of the fix that we are going to edit
        //
        m_Entry = *pEntry;
    }

    //
    // Setup wizard variables
    //
    g_pCurrentWizard = this;

    //
    // We are in fix wizard and not in AppHelp wizard
    //
    m_uType = TYPE_FIXWIZARD;

    //
    // Begin the wizard
    //
    PROPSHEETHEADER Header = {0};

    Header.dwSize           = sizeof(PROPSHEETHEADER);
    Header.dwFlags          = PSH_WIZARD97 | PSH_HEADER |  PSH_WATERMARK | PSH_PROPSHEETPAGE;
    Header.hwndParent       = hParent;
    Header.hInstance        = g_hInstance;
    Header.nStartPage       = 0;
    Header.ppsp             = Pages;
    Header.nPages           = NUM_PAGES;
    Header.pszbmHeader      = MAKEINTRESOURCE(IDB_WIZBMP);
    Header.pszbmWatermark   = MAKEINTRESOURCE(IDB_TOOL);

    if (m_bEditing) {
        Header.dwFlags |= PSH_WIZARDHASFINISH;
    }

    Pages[PAGE_APPNAME].dwSize                = sizeof(PROPSHEETPAGE);
    Pages[PAGE_APPNAME].dwFlags               = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE ;
    Pages[PAGE_APPNAME].hInstance             = g_hInstance;
    Pages[PAGE_APPNAME].pszTemplate           = MAKEINTRESOURCE(IDD_FIXWIZ_APPINFO);
    Pages[PAGE_APPNAME].pfnDlgProc            = GetAppName;
    Pages[PAGE_APPNAME].pszHeaderTitle        = MAKEINTRESOURCE(IDS_GIVEAPPINFO);
    Pages[PAGE_APPNAME].pszHeaderSubTitle     = MAKEINTRESOURCE(IDS_GIVEAPPINFOSUBHEADING);

    Pages[PAGE_LAYERS].dwSize                 = sizeof(PROPSHEETPAGE);
    Pages[PAGE_LAYERS].dwFlags                = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    Pages[PAGE_LAYERS].hInstance              = g_hInstance;
    Pages[PAGE_LAYERS].pszTemplate            = MAKEINTRESOURCE(IDD_FIXWIZ_MODES);
    Pages[PAGE_LAYERS].pfnDlgProc             = SelectLayer;
    Pages[PAGE_LAYERS].pszHeaderTitle         = MAKEINTRESOURCE(IDS_SELECTLAYERS);
    Pages[PAGE_LAYERS].pszHeaderSubTitle      = MAKEINTRESOURCE(IDS_SELECTLAYERS_SUBHEADING);

    Pages[PAGE_SHIMS].dwSize                  = sizeof(PROPSHEETPAGE);
    Pages[PAGE_SHIMS].dwFlags                 = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    Pages[PAGE_SHIMS].hInstance               = g_hInstance;
    Pages[PAGE_SHIMS].pszTemplate             = MAKEINTRESOURCE(IDD_FIXWIZ_SHIMS);
    Pages[PAGE_SHIMS].pfnDlgProc              = SelectShims;
    Pages[PAGE_SHIMS].pszHeaderTitle          = MAKEINTRESOURCE(IDS_COMPATFIXES);
    Pages[PAGE_SHIMS].pszHeaderSubTitle       = MAKEINTRESOURCE(IDS_SELECTSHIMS_SUBHEADING);

    Pages[PAGE_MATCH].dwSize                  = sizeof(PROPSHEETPAGE);
    Pages[PAGE_MATCH].dwFlags                 = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    Pages[PAGE_MATCH].hInstance               = g_hInstance;
    Pages[PAGE_MATCH].pszTemplate             = MAKEINTRESOURCE(IDD_FIXWIZ_MATCHINGINFO);
    Pages[PAGE_MATCH].pfnDlgProc              = SelectFiles;
    Pages[PAGE_MATCH].pszHeaderTitle          = MAKEINTRESOURCE(IDS_MATCHINFO);
    Pages[PAGE_MATCH].pszHeaderSubTitle       = MAKEINTRESOURCE(IDS_MATCHINFO_SUBHEADING);

    BOOL bReturn = FALSE;

    if (0 < PropertySheet(&Header)) {
        //
        // The user pressed finish in the wizard
        //
        bReturn = TRUE;

    } else {
        //
        // The user pressed cancel in the wizard
        //
        bReturn = FALSE;
    }

    ENABLEWINDOW(g_hDlg, TRUE);

    *pbShouldStartLUAWizard = g_bShouldStartLUAWizard;
    return bReturn;
}

INT_PTR
CALLBACK
GetAppName(
    IN  HWND    hDlg, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++

    GetAppName
    
	Desc:	Dialog proc for the first page of the wizard. Gets the app info and also sets the
            Full path of the entry

	Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
    
--*/

{
    INT_PTR ipReturn = 0;

    switch (uMsg) {
    case WM_INITDIALOG:

        ipReturn = GetAppNameDlgOnInitDialog(hDlg);
        break;

    case WM_NOTIFY:

        ipReturn = GetAppNameDlgOnNotify(hDlg, lParam);
        break;

    case WM_COMMAND:

        ipReturn = GetAppNameDlgOnCommand(hDlg, wParam);
        break;

    default: ipReturn = 0;

    }

    return ipReturn;
}
    
INT_PTR
CALLBACK 
SelectLayer(
    IN  HWND hDlg, 
    IN  UINT uMsg, 
    IN  WPARAM wParam, 
    IN  LPARAM lParam
    )
/*++

    SelectLayer
    
	Desc:	Dialog proc for the second page of the wizard. Gets the layers that have to be 
            applied to the entry

	Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
    
--*/
{
    INT_PTR ipReturn = 0;

    switch (uMsg) {
    case WM_INITDIALOG:

        ipReturn = SelectLayerDlgOnInitDialog(hDlg);
        break;

    case WM_DESTROY:

        ipReturn = SelectLayerDlgOnDestroy();
        break;

    case WM_COMMAND:

        ipReturn = SelectLayerDlgOnCommand(hDlg, wParam);
        break;   

    case WM_NOTIFY:
        
        ipReturn = SelectLayerDlgOnNotify(hDlg, lParam);
        break;

    default: ipReturn = FALSE;

    }

    return ipReturn;
}

BOOL 
CALLBACK 
SelectShims(
    IN  HWND    hDlg, 
    IN  UINT    uMsg,
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++

    SelectShims
    
	Desc:	Dialog proc for the third page of the wizard. Gets the shims that have to be 
            applied to the entry

	Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
    
--*/
{   
    INT_PTR ipReturn = 0;

    switch (uMsg) {
    case WM_INITDIALOG:

        ipReturn =  SelectShimsDlgOnInitDialog(hDlg);
        break;

    case WM_COMMAND:

        ipReturn = SelectShimsDlgOnCommand(hDlg, wParam);
        break;

    case WM_TIMER:

        ipReturn = SelectShimsDlgOnTimer(hDlg);
        break;

    case WM_DESTROY:

        ipReturn = SelectShimsDlgOnDestroy();
        break;

    case WM_NOTIFY:

        ipReturn = SelectShimsDlgOnNotify(hDlg, lParam);
        break;

    default:
        return FALSE;
    }

    return ipReturn;
}

INT_PTR
CALLBACK 
SelectFiles(
    IN  HWND    hDlg, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++
    
    SelectFiles
    
    Desc:	Dialog proc for the matching files page of the wizard. This page is
            common to both the fix wizard and the apphelp wizard

	Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
--*/
{   
    INT ipReturn = 0;

    switch (uMsg) {
    case WM_INITDIALOG:

        ipReturn = SelectFilesDlgOnInitDialog(hDlg);
        break;

    case WM_DESTROY:
        
        ImageList_Destroy(s_hMatchingFileImageList);
        s_hMatchingFileImageList = NULL;
        ipReturn = TRUE;
        break;

    case WM_USER_MATCHINGTREE_REFRESH:

        ipReturn = SelectFilesDlgOnMatchingTreeRefresh(hDlg);
        break;

    case WM_NOTIFY:

        ipReturn = SelectFilesDlgOnNotify(hDlg, lParam);
        break;

    case WM_COMMAND:

        ipReturn = SelectFilesDlgOnCommand(hDlg, wParam);
        break;

    default:
        return FALSE;
        
    }

    return ipReturn;
}

void
FileTreeToggleCheckState(
    IN  HWND      hwndTree,
    IN  HTREEITEM hItem
    )
/*++
    FileTreeToggleCheckState

    Desc:    Changes the check state on the attributes tree.
    
    Params:
        IN  HWND      hwndTree: The handle to the attribute tree (In the matching files page)
        IN  HTREEITEM hItem:    The tree item whose check state we want to change
        IN  int       uMode:    
--*/
{
    BOOL bSate = TreeView_GetCheckState(hwndTree, hItem) ? TRUE:FALSE; 

    TreeView_SetCheckState(hwndTree, hItem, !bSate);
}

void 
AddMatchingFileToTree(
    IN HWND            hwndTree,
    IN PMATCHINGFILE   pMatch,
    IN BOOL            bAddToMatchingList
    )
/*++

    AddMatchingFileToTree

	Desc:	Creates a new tree item for pMatch and adds it to the matching tree. If bAddToMatchingList
            is TRUE, also adds it to the PMATCHINGFLE for the entry

	Params:
        IN  HWND            hwndTree:           The matching tree
        IN  PMATCHINGFILE   pMatch:             The PMATCHINGFILE to add to the tree
        IN  BOOL            bAddToMatchingList: This will be false, when we are 
            populating for edit. The pMatch is already in the list and we do not want to 
            add it again
            
	Return:
        void
--*/

{
    TVINSERTSTRUCT is;
    TCHAR*         pszFileNameForImage =  NULL;

    if (g_pCurrentWizard == NULL || pMatch == NULL) {
        assert(FALSE);
        return;
    }
    
    if (bAddToMatchingList) {
        //
        // Now add this pMatch to the list for this entry.
        //
        pMatch->pNext =  g_pCurrentWizard->m_Entry.pFirstMatchingFile;
        g_pCurrentWizard->m_Entry.pFirstMatchingFile = pMatch;
    }

    if (g_pCurrentWizard->m_Entry.strFullpath.Length() 
        && (pMatch->strFullName == g_pCurrentWizard->m_Entry.strFullpath)) {

        pMatch->strMatchName = TEXT("*");
    }

    is.hParent      = TVI_ROOT;
    is.item.lParam  = (LPARAM)pMatch;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;

    if (pMatch->strMatchName == TEXT("*")) {

        TCHAR szTemp[MAX_PATH + 100]; // 100 is for any text that we might need to add to the file. Such as "Program being fixed"

        *szTemp = 0;
        StringCchPrintf(szTemp, 
                        ARRAYSIZE(szTemp),  
                        TEXT("%s ( %s )"), 
                        GetString(IDS_MAINEXE), 
                        g_pCurrentWizard->m_Entry.strExeName.pszString);

        is.item.pszText = szTemp;
        is.hInsertAfter = TVI_FIRST;

        if (pMatch->strFullName.Length()) {
            pszFileNameForImage = pMatch->strFullName.pszString;
        } else {
            pszFileNameForImage = g_pCurrentWizard->m_Entry.strExeName.pszString;
        }

    } else {

        is.item.pszText = pMatch->strMatchName;
        is.hInsertAfter = TVI_LAST;

        if (pMatch->strFullName.Length()) {
            pszFileNameForImage = pMatch->strFullName.pszString;
        } else {
            pszFileNameForImage = pMatch->strMatchName.pszString;
        }
    }

    is.item.iImage = LookupFileImage(s_hMatchingFileImageList, 
                                     pszFileNameForImage, 
                                     0, 
                                     0, 
                                     0);

    is.item.iSelectedImage = is.item.iImage;

    HTREEITEM hParent = TreeView_InsertItem(hwndTree, &is);

    is.hInsertAfter         = TVI_LAST;
    is.hParent              = hParent;
    is.item.mask            = TVIF_TEXT | TVIF_PARAM | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    is.item.iSelectedImage  = is.item.iImage = IMAGE_ATTRIBUTE_MATCHTREE;

    TCHAR szItem[260];

    PATTRINFO_NEW pAttr = pMatch->attributeList.pAttribute;

    for (DWORD dwIndex = 0; dwIndex < ATTRIBUTE_COUNT; ++dwIndex) {

        *szItem = 0;

        if (pAttr[dwIndex].dwFlags & ATTRIBUTE_AVAILABLE) {

            if (!SdbFormatAttribute(&pAttr[dwIndex], szItem, ARRAYSIZE(szItem))) {
                continue;
            }
            
            int iPos = TagToIndex(pAttr[dwIndex].tAttrID);

            if (iPos == -1) {
                continue;
            }

            if (pMatch->dwMask & (1 << (iPos + 1))) {
                is.item.state   = INDEXTOSTATEIMAGEMASK(2); //Selected
            } else {
                is.item.state   = INDEXTOSTATEIMAGEMASK(1); //Unselected
            }

            is.item.stateMask   = TVIS_STATEIMAGEMASK;
            is.item.pszText     = szItem;
            is.item.lParam      = pAttr[dwIndex].tAttrID;
            is.item.iImage      = is.item.iSelectedImage =  IMAGE_ATTRIBUTE_MATCHTREE;

            TreeView_InsertItem(hwndTree, &is);
        }
    }

    TreeView_Expand(hwndTree, hParent, TVE_EXPAND);
    TreeView_SelectItem(hwndTree, hParent);
}

PMATCHINGFILE
GetMatchingFileFromAttributes(
    IN  CSTRING&    strFullPath,
    IN  CSTRING&    strRelativePath,
    IN  PATTRINFO   pAttrInfo
    )
/*++

    GetMatchingFileFromAttributes

	Desc:   This function takes a PATTRINFO and makes a PMATCHINGFILE out of it and returns that

	Params:
        IN  CSTRING     &strFullPath:       The full path of the matching file
        IN  CSTRING     &strRelativePath:   The relative path of the matching file w.r.t the program
            file being fixed
            
        IN  PATTRINFO   pAttrInfo:          The pointer to the array of attributes

	Return:
        The newly created PMATCHINGFILE if successful
        NULL otherwise
--*/
{
    PMATCHINGFILE pMatch = new MATCHINGFILE;

    if (pMatch == NULL) {
        MEM_ERR;
        goto error_handler;
    }

    pMatch->strFullName     = strFullPath;
    pMatch->strMatchName    = strRelativePath;
    pMatch->attributeList   = pAttrInfo;

    return pMatch;

error_handler:

    if (pMatch) {
        delete pMatch;
    }

    return NULL;
}

void
HandleAddMatchingFile(
    IN  HWND        hdlg,
    IN  CSTRING&    strFilename,
    IN  CSTRING&    strRelativePath, 
    IN  DWORD       dwMask //(DEFAULT_MASK)
    )
/*++

    HandleAddMatchingFile

	Desc:	This is the interface function that should be called when we have a matching file and
            want to add it. 
            
            This routine calls SdbGetFileAttributes() to get the attributes for
            the file and then calls GetMatchingFileFromAttributes() to get a PMATCHINGFILE
            and AddMatchingFileToTree() to add this PMATCHINGFILE to the tree and to the entry.
            
	Params:
        IN  HWND    hdlg:                   The matching file wizard page
        IN  CSTRING &strFilename:           The complete path of the matching file       
        IN  CSTRING &strRelativePath:       The relative path w.r.t to the program file being fixed
        IN  DWORD   dwMask (DEFAULT_MASK):  This is helpful when we are updating the
            attributes (showing all attributes) during editing. 
            This then will contain the previous flags and once the attribute tree is refreshed, 
            will help us in selecting them, 

	Return:
        void
--*/
{   
    DWORD           dwAttrCount;
    BOOL            bAlreadyExists  = FALSE;
    HWND            hwndTree        = GetDlgItem(hdlg, IDC_FILELIST);
    PMATCHINGFILE   pMatch          = NULL;
    PATTRINFO       pAttrInfo       = NULL;
    CSTRING         strMessage;

    if (g_pCurrentWizard == NULL) {
        assert(NULL);
        return;
    }

    pMatch = g_pCurrentWizard->m_Entry.pFirstMatchingFile;

    while (pMatch) {

        if (pMatch->strMatchName == strRelativePath) {
            //
            // Already exists .. do not allow
            //
            bAlreadyExists = TRUE;
            break;

        } else if (pMatch->strMatchName == TEXT("*") 
                   && strFilename == g_pCurrentWizard->m_Entry.strFullpath) {
            //
            // This function is also called to add the matching file info for the 
            // program file being fixed. So we do not make a check in the beginning 
            // if the full path is same as the the program being fixed
            //
            bAlreadyExists = TRUE;
            break;
        }

        pMatch = pMatch->pNext;
    }                     

    if (bAlreadyExists == TRUE) {

        MessageBox(hdlg,
                   CSTRING(IDS_MATCHFILEEXISTS),
                   g_szAppName,
                   MB_ICONWARNING);

        return;
    }

    //
    // Call the attribute manager to get all the attributes for this file. 
    //
    if (SdbGetFileAttributes(strFilename, &pAttrInfo, &dwAttrCount)) {

        pMatch = GetMatchingFileFromAttributes(strFilename,
                                           strRelativePath, 
                                           pAttrInfo);

        if (pMatch) {
            pMatch->dwMask = dwMask;
        } else {
            assert(FALSE);
        }
    
        if (pAttrInfo) {
            SdbFreeFileAttributes(pAttrInfo);
        }
    
        SendMessage(s_hwndTree, WM_SETREDRAW, FALSE, 0);
        AddMatchingFileToTree(hwndTree, pMatch, TRUE);  
        SendMessage(s_hwndTree, WM_SETREDRAW, TRUE, 0);

    } else {
        //
        // We could not get the Attributes... Probably the file was deleted
        //
        strMessage.Sprintf(GetString(IDS_MATCHINGFILE_DELETED), (LPCTSTR)strFilename);
        MessageBox(hdlg, (LPCTSTR) strMessage, g_szAppName, MB_ICONWARNING);
    }
}

BOOL
HandleAttributeTreeNotification(
    IN  HWND   hdlg,
    IN  LPARAM lParam
    )
/*++
    HandleAttributeTreeNotification

    Desc:    Handle all the notifications we care about for the matching file tree.
    
    Params:
        IN  HWND   hdlg:    The mathching file wizard page
        IN  LPARAM lParam:  the lParam that comes with WM_NOTIFY
        
    Return:
        void
        
--*/
{
    HWND        hwndTree    = GetDlgItem(hdlg, IDC_FILELIST);
    LPNMHDR     pnm         = (LPNMHDR)lParam;
    HWND        hwndButton;

    switch (pnm->code) {
    case NM_CLICK:
        {
            TVHITTESTINFO   HitTest;
            HTREEITEM       hItem;

            GetCursorPos(&HitTest.pt);
            ScreenToClient(hwndTree, &HitTest.pt);

            TreeView_HitTest(hwndTree, &HitTest);

            if (HitTest.flags & TVHT_ONITEMSTATEICON) {
                FileTreeToggleCheckState(hwndTree, HitTest.hItem);

            } else if (HitTest.flags & TVHT_ONITEMLABEL) {

                hItem = TreeView_GetParent(hwndTree, HitTest.hItem);
                //
                // Enable Remove Files button only if we are on a matching file item and not on
                // an attribute item
                //
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_REMOVEFILES), 
                             hItem == NULL);

            }

            break;
        }

    case TVN_KEYDOWN:
        {

            LPNMTVKEYDOWN lpKeyDown = (LPNMTVKEYDOWN)lParam;
            HTREEITEM     hItem;

            if (lpKeyDown->wVKey == VK_SPACE) {
                hItem = TreeView_GetSelection(hwndTree);

                if (hItem != NULL) {
                    FileTreeToggleCheckState(hwndTree, hItem);
                }
            }

            break;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

void 
CShimWizard::WipeEntry(
    IN  BOOL bMatching, 
    IN  BOOL bShims, 
    IN  BOOL bLayer, 
    IN  BOOL bFlags
    )
/*++
    WipeEntry

	Desc:	Removes stuff from m_Entry

	Params:
        IN  BOOL bMatching: Should we remove all the matching files from m_Entry
        IN  BOOL bShims:    Should we remove all the shims from m_Entry
        IN  BOOL bLayer:    Should we remove all the layers from m_Entry
        IN  BOOL bFlags:    Should we remove all the flags from m_Entry 

	Return:
        void
--*/

{
    //
    // Delete mathcing files, if asked to
    //
    if (bMatching) {
        DeleteMatchingFiles(m_Entry.pFirstMatchingFile);
        m_Entry.pFirstMatchingFile = NULL;
    }

    //
    // Delete shims, if asked to
    //
    if (bShims) {
        DeleteShimFixList(m_Entry.pFirstShim);
        m_Entry.pFirstShim = NULL;
    }

    //
    // Delete layers, if asked to
    //
    if (bLayer) {
        DeleteLayerFixList(m_Entry.pFirstLayer);
        m_Entry.pFirstLayer = NULL;
    }

    //
    // Delete flags, if asked to
    //
    if (bFlags) {
        DeleteFlagFixList(m_Entry.pFirstFlag);
        m_Entry.pFirstFlag = NULL;
    }
}

void
AddToMatchingFilesList(
    IN  OUT PMATCHINGFILE*  ppMatchListHead, 
    IN      CSTRING&        strFileName, 
    IN      CSTRING&        strRelativePath
    )
/*++

    AddToMatchingFilesList    
    
    Desc:   Adds a PMATCHINGFILE for strFileName, strRelativePath and adds it to ppMatchListHead
    
    Params:
        IN  OUT PMATCHINGFILE *ppMatchListHead: Pointer to head of a list of PMATCHINGFILE
        IN      CSTRING &strFileName:           Full path of the matching file
        IN      CSTRING &strRelativePath:       Relative path of the matching file w.r.t
            to the program file being fixed
        
    
    Notes:  This function is used, when we are using the auto-generate feature.
            The WalkDirectory(..) gets the different files from the various directories 
            and then calls this function. 
            This function creates a PMATCHINGFILE from the name of the file and then it 
            adds the  PMATCHINGFILE to a list. The list is sorted on the basis of the 
            non-inc. size of the matching file found.
            
            When WalkDirectory finally returns to GrabMatchingInfo, it takes the first n number of 
            PMATCHINGFILE (they are the largest ones) and adds them to the tree.
--*/
{
    PATTRINFO       pAttrInfo   = NULL;
    DWORD           dwAttrCount = 0;
    PMATCHINGFILE   pMatch      = NULL;
    PATTRINFO_NEW   pAttr       = NULL;
    DWORD           dwSize      = 0;
    DWORD           dwSizeOther = 0;
    PMATCHINGFILE   pMatchPrev  = NULL;
    PMATCHINGFILE   pMatchTemp  = NULL;

    if (!SdbGetFileAttributes(strFileName, &pAttrInfo, &dwAttrCount)) {
        ASSERT(FALSE);
        return;
    }

    pMatch = GetMatchingFileFromAttributes(strFileName,
                                           strRelativePath, 
                                           pAttrInfo);

    if (pMatch == NULL) {
        return;
    }

    pAttr = pMatch->attributeList.pAttribute;

    //
    // Get the size attribute, we need this so that we can sort files based on their size
    //
    GET_SIZE_ATTRIBUTE(pAttr, dwAttrCount, dwSize);

    //
    // Is the list empty ?
    //
    if (*ppMatchListHead == NULL) {
        *ppMatchListHead = pMatch;
        return;
    }

    //
    // Is the first element in the list smaller than this one ?
    //
    pAttr = (*ppMatchListHead)->attributeList.pAttribute;

    GET_SIZE_ATTRIBUTE(pAttr, dwAttrCount, dwSizeOther);

    if (dwSize > dwSizeOther) {

        pMatch->pNext       = *ppMatchListHead;
        *ppMatchListHead    = pMatch;
        return;
    }

    //
    // Else insert at the proper position.
    //
    pMatchPrev = *ppMatchListHead;
    pMatchTemp = pMatchPrev->pNext;

    //
    // Look at all the matching files in the list headed by *ppMatchListHead
    // and add this matching file in its correct position so that the list is 
    // sorted in non-increasing order of size
    //
    while (pMatchTemp) {

        pAttr = pMatchTemp->attributeList.pAttribute;

        GET_SIZE_ATTRIBUTE(pAttr, dwAttrCount, dwSizeOther);

        if (dwSize > dwSizeOther) {
            //
            // We have found the position where we need to insert.
            //
            break;
        }

        pMatchPrev = pMatchTemp;
        pMatchTemp = pMatchTemp->pNext;
    }

    pMatch->pNext       = pMatchTemp;
    pMatchPrev->pNext   = pMatch;
}

void
CShimWizard::WalkDirectory(
    IN OUT  PMATCHINGFILE*  ppMatchListHead,
    IN      LPCTSTR         pszDir,
    IN      int             nDepth
    )
/*++

    CShimWizard::WalkDirectory
    
	Desc:	Walks the specified directory and gets matching files when using the AutoGenerate feature
            Takes a pointer to pointer to a PMATCHING and pouplates it with the matching files found.
            This function is called only by GrabMatchingInfo

	Params:
    IN OUT  PMATCHINGFILE* ppMatchListHead: Pointer to head of a list of PMATCHINGFILE
    IN      LPCTSTR pszDir:                  The dir from where we should start
    IN      int nDepth                      The depth of sub-directories to look into

	Return:
        void
        
    Notes:  We restrict the depth till where we should recurse and so there will be no stack overflow
    
--*/

{
    HANDLE          hFile;
    WIN32_FIND_DATA Data;
    TCHAR           szCurrentDir[MAX_PATH_BUFFSIZE + 1];
    TCHAR           szDirectory[MAX_PATH];
    CSTRING         szShortName;
    CSTRING         strFileName;
    CSTRING         strRelativePath;
    int             nFiles      = 0;
    DWORD           dwResult    = 0;


    *szCurrentDir = *szDirectory = 0;

    SafeCpyN(szDirectory, pszDir, ARRAYSIZE(szDirectory));

    ADD_PATH_SEPARATOR(szDirectory, ARRAYSIZE(szDirectory));

    //
    // This is to allow recursion and only look into only 2 level subdirs.
    //
    if (nDepth >= 2) {
        return;
    }

    szShortName = m_Entry.strFullpath;
    szShortName.ShortFilename();

    //
    // Save the current directory
    //
    dwResult = GetCurrentDirectory(MAX_PATH, szCurrentDir);

    if (dwResult == 0 || dwResult >= MAX_PATH) {
        assert(FALSE);
        Dbg(dlError, "WalkDirectory", "GetCurrentDirectory returned %d", dwResult);
        return;
    }

    ADD_PATH_SEPARATOR(szCurrentDir, ARRAYSIZE(szCurrentDir));

    //
    // Set to the new directory
    //
    SetCurrentDirectory(szDirectory);

    
    hFile = FindFirstFile(TEXT("*.*"), &Data);

    if (INVALID_HANDLE_VALUE == hFile) {
        SetCurrentDirectory(szCurrentDir);
        return;
    }

    //
    // Generate automated matching file information.
    //
    do {

        if (0 == (Data.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))) {
            //
            // Hidden or system files are not included when we do a auto-generate matching info
            //
            if (FILE_ATTRIBUTE_DIRECTORY == (Data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                //
                // We found a directory
                //
                if (TEXT('.') != Data.cFileName[0]) {
                    //
                    // Let us get the matching files from this directory
                    //
                    WalkDirectory(ppMatchListHead, Data.cFileName, nDepth + 1);
                }
                    
            } else {
                //
                // This is a file and we should now try to add it
                //
                ++nFiles;

                if (nFiles >= MAX_FILES) {
                    //
                    // We have found enough files, later we should take the largest MAX_AUTO_MATCH from these
                    //
                    break; 
                }

                if (0 == (Data.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))) {

                    if (szDirectory[0] == TEXT('.')) {

                        strFileName.Sprintf(TEXT("%s%s"),
                                            szCurrentDir,
                                            Data.cFileName);

                    } else {

                        strFileName.Sprintf(TEXT("%s%s%s"),
                                            szCurrentDir,
                                            szDirectory,
                                            Data.cFileName);
                    }       

                    strRelativePath = strFileName;

                    strRelativePath.RelativeFile(g_pCurrentWizard->m_Entry.strFullpath);

                    //
                    // The main exe has been added before calling WalkDirectory()
                    //
                    if (strFileName != g_pCurrentWizard->m_Entry.strFullpath) {
                        //
                        // Add this to the list of matching files. Finally we will choose the 
                        // largest MAX_AUTO_MATCH from them, to serve as the matching files for the present
                        // entry
                        //
                        AddToMatchingFilesList(ppMatchListHead, 
                                               strFileName, 
                                               strRelativePath);
                    }
                }
            }
        }
            
    } while (FindNextFile(hFile, &Data));

    FindClose(hFile);

    //
    // Restore old directory
    //
    SetCurrentDirectory(szCurrentDir);
}

void
CShimWizard::GrabMatchingInfo(
    IN  HWND hdlg
    )
/*++
    
    CShimWizard::GrabMatchingInfo

	Desc:	Handles the pressinG of "Auto-Generate button. Removes all the existing matching files
            for m_Entry

	Params:   
        IN  HWND hdlg:  The matching file wizard page

	Return:
        void
--*/
{   
    PMATCHINGFILE   pMatchTemp;
    PMATCHINGFILE   pMatchNext;
    TCHAR*          pchTemp;
    TCHAR           szCurrentDir[MAX_PATH];
    TCHAR           szDir[MAX_PATH];            // The directory of the file being fixed
    PMATCHINGFILE   pMatchingFileHead   = NULL;
    int             iCount              = 0;
    DWORD           dwResult            = 0;

    *szCurrentDir = *szDir = 0;

    dwResult = GetCurrentDirectory(ARRAYSIZE(szCurrentDir), szCurrentDir);
    
    if (dwResult == 0 || dwResult >= ARRAYSIZE(szCurrentDir)) {
        assert(FALSE);
        Dbg(dlError, "[CShimWizard::GrabMatchingInfo]: GetCurrentDirectory failed");
        return;
    }
    
    //
    // Get the complete path of the program file being fixed, so that
    // we can generate relative file paths for the matching files
    //
    if (g_pCurrentWizard->CheckAndSetLongFilename(hdlg, IDS_GETCOMPLETEPATH) == FALSE) {
        return;
    }

    //
    // Remove any matching if present.
    //
    TreeDeleteAll(s_hwndTree);

    g_pCurrentWizard->WipeEntry(TRUE, FALSE, FALSE, FALSE);
    
    *szDir = 0;

    SafeCpyN(szDir,  (LPCTSTR)g_pCurrentWizard->m_Entry.strFullpath, ARRAYSIZE(szDir));

    pchTemp = _tcsrchr(szDir, TEXT('\\'));

    if (pchTemp) {
        //
        // Make sure that we get the trailing slash. Otherwise we migth have problems if we haev file 
        // names as c:\abc.exe 
        //
        *pchTemp = 0;
    } else {
        //
        // g_pCurrentWizard->m_Entry.strFullpath did not have a complete path!!
        // We should not have come in this function in the first place
        //
        assert(FALSE);
        Dbg(dlError, "[CShimWizard::GrabMatchingInfo]: Did not have a complete path for g_pCurrentWizard->m_Entry.strFullpath");
        return;
    }

    SetCurrentDirectory(szDir);
    
    //
    // Generate automated matching file information. pMatchingFileHead will
    // be the head of a linked list of all the matching files that we found
    //
    WalkDirectory(&pMatchingFileHead, TEXT("."), 0);

    //
    // Now, take the first MAX_AUTO_MATCH entries and discard the rest.
    //
    SendMessage(s_hwndTree, WM_SETREDRAW, FALSE, 0);

    while (iCount < MAX_AUTO_MATCH && pMatchingFileHead) {

        pMatchNext = pMatchingFileHead->pNext;

        //
        // NOTE:    AddMatchingFileToTree() will change the pMatchingFileHead->pNext, 
        //          when it adds it to the list of matching files for the entry !!!.
        //          So we have saved the pMatchingFileHead->pNext earlier.
        //
        AddMatchingFileToTree(s_hwndTree, pMatchingFileHead, TRUE);
        ++iCount;
        pMatchingFileHead = pMatchNext; 
    }

    SendMessage(s_hwndTree, WM_SETREDRAW, TRUE, 0);

    //
    // Remove the other ones.
    //
    while (pMatchingFileHead) {

        pMatchTemp = pMatchingFileHead->pNext;
        delete pMatchingFileHead;
        pMatchingFileHead = pMatchTemp;
    }

    if (g_pCurrentWizard) {
        //
        // Add the file being fixed.
        //
        HandleAddMatchingFile(hdlg,
                              g_pCurrentWizard->m_Entry.strFullpath,
                              g_pCurrentWizard->m_Entry.strExeName);
    }

    SetCurrentDirectory(szCurrentDir);
}

void
AddModuleToListView(
    IN  PTSTR   pszModuleName,
    IN  UINT    uOption,
    IN  HWND    hwndModuleList
    )
/*++
    AddModuleToListView

    Desc:    Adds the specified module to the list view.
    
    Params:
        IN  PTSTR   pszModuleName:  Name of the module to be included or excluded
        IN  UINT    uOption:        Either INCLUDE or EXCLUDE
        IN  HWND    hwndModuleList: Handle to the list view
        
    Return;
        void
--*/
{
    LVITEM  lvi;
    int     nIndex;

    lvi.mask     = LVIF_TEXT | LVIF_PARAM;
    lvi.lParam   = uOption == INCLUDE ? 1 : 0;
    lvi.pszText  = uOption == INCLUDE ? GetString(IDS_INCLUDE) : GetString(IDS_EXCLUDE);
    lvi.iItem    = ListView_GetItemCount(hwndModuleList);
    lvi.iSubItem = COLUMN_TYPE;

    nIndex = ListView_InsertItem(hwndModuleList, &lvi);

    ListView_SetItemText(hwndModuleList,
                         nIndex,
                         COLUMN_NAME,
                         pszModuleName);
}

void
HandleModuleListNotification(
    IN  HWND   hdlg,
    IN  LPARAM lParam
    )
/*++
    HandleModuleListNotification

    Desc:   Handle all the notifications we care about for the list in the params
            dialog
                    
    Params:
        IN  HWND   hdlg:    The handle to the Params Dialog Box
        IN  LPARAM lParam:  lParam that comes with WM_NOTIFY
        
    Return:
        void
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;
    HWND    hwndModuleList = GetDlgItem(hdlg, IDC_MOD_LIST);

    switch (pnm->code) {
    case NM_CLICK:
        {
            LVHITTESTINFO lvhti;

            GetCursorPos(&lvhti.pt);
            ScreenToClient(hwndModuleList, &lvhti.pt);

            ListView_HitTest(hwndModuleList, &lvhti);

            //
            // If the user clicked on a list view item,
            // enable the Remove button 
            //
            if (lvhti.flags & LVHT_ONITEMLABEL) {
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_REMOVEFROMLIST), TRUE);
            } else {
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_REMOVEFROMLIST), FALSE);
            }

            break;
        }

    default:
        break;
    }
}

INT_PTR CALLBACK
ParamsDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++
    OptionsDlgProc

    Description:    Handles messages for the options dialog.
    
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return    

--*/
{
    TCHAR   szTitle[MAX_PATH];
    int     wCode           = LOWORD(wParam);
    int     wNotifyCode     = HIWORD(wParam);
    static  TYPE    s_type  = TYPE_UNKNOWN;

    HWND hwndModuleList = GetDlgItem(hdlg, IDC_MOD_LIST);

    switch (uMsg) {
    case WM_INITDIALOG:
        {   
            s_type = ConvertLparam2Type(lParam);

            SetWindowLongPtr(hdlg, DWLP_USER, lParam);

            ENABLEWINDOW(GetDlgItem(hdlg, IDC_REMOVEFROMLIST), FALSE);

            InsertColumnIntoListView(hwndModuleList, GetString(IDS_TYPE), COLUMN_TYPE, 30);
            InsertColumnIntoListView(hwndModuleList, GetString(IDS_MODULENAME), COLUMN_NAME, 70);
            ListView_SetExtendedListViewStyle(hwndModuleList, LVS_EX_LABELTIP |LVS_EX_FULLROWSELECT);

            //
            // Restrict the length of the command line to MAX_COMMAND_LINE chars
            //
            SendMessage(GetDlgItem(hdlg, IDC_SHIM_CMD_LINE), 
                        EM_LIMITTEXT, 
                        (WPARAM)MAX_COMMAND_LINE, 
                        (LPARAM)0);

            //
            // Restrict the length of the module name to MAX_MODULE_NAME
            //
            SendMessage(GetDlgItem(hdlg, IDC_MOD_NAME), 
                        EM_LIMITTEXT, 
                        (WPARAM)MAX_MODULE_NAME, 
                        (LPARAM)0);


            if (s_type == FIX_LIST_SHIM) {

                PSHIM_FIX_LIST psfl = (PSHIM_FIX_LIST)lParam;

                if (psfl->pShimFix == NULL) {
                    assert(FALSE);
                    break;
                }

                StringCchPrintf(szTitle, 
                                ARRAYSIZE(szTitle), 
                                GetString(IDS_OPTIONS), 
                                psfl->pShimFix->strName);

                SetWindowText(hdlg, szTitle);

                if (psfl->strCommandLine.Length()) {
                    SetDlgItemText(hdlg, IDC_SHIM_CMD_LINE, psfl->strCommandLine);
                }

                CheckDlgButton(hdlg, IDC_INCLUDE, BST_CHECKED);

                //
                // Add any modules to the list view
                //
                PSTRLIST  strlTemp = psfl->strlInExclude.m_pHead;

                while (strlTemp) {

                    AddModuleToListView(strlTemp->szStr, 
                                        strlTemp->data, 
                                        hwndModuleList);

                    strlTemp = strlTemp->pNext;
                }
                
            } else {

                PFLAG_FIX_LIST pffl = (PFLAG_FIX_LIST)lParam;

                if (pffl->pFlagFix == NULL) {
                    assert(FALSE);
                    break;
                }

                StringCchPrintf(szTitle, 
                                ARRAYSIZE(szTitle), 
                                GetString(IDS_PRAMS_DLGCAPTION), 
                                pffl->pFlagFix->strName);

                SetWindowText(hdlg, szTitle);

                if (pffl->strCommandLine.Length()) {
                    SetDlgItemText(hdlg, IDC_SHIM_CMD_LINE, pffl->strCommandLine);
                }

                ENABLEWINDOW(GetDlgItem(hdlg, IDC_MOD_NAME), FALSE);
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_INCLUDE), FALSE);
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_EXCLUDE), FALSE);
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_ADDTOLIST), FALSE);
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_REMOVEFROMLIST), FALSE);
            }

            SendMessage(hdlg,
                        WM_COMMAND,
                        MAKEWPARAM(IDC_MOD_NAME, EN_CHANGE),
                        0);

            break;
        }

    case WM_NOTIFY:

        HandleModuleListNotification(hdlg, lParam);
        break;

    case WM_COMMAND:

        switch (wCode) {
        case IDC_MOD_NAME:
            {

                if (EN_CHANGE == HIWORD(wParam)) {

                    TCHAR szModName[MAX_MODULE_NAME + 1];

                    GetDlgItemText(hdlg, IDC_MOD_NAME, szModName, ARRAYSIZE(szModName));

                    if (CSTRING::Trim(szModName)) {

                        ENABLEWINDOW(GetDlgItem(hdlg, IDC_ADDTOLIST), TRUE);
                    } else {
                        ENABLEWINDOW(GetDlgItem(hdlg, IDC_ADDTOLIST), FALSE);
                    }
                }

                break;
            }

        case IDC_ADDTOLIST:
            {
                TCHAR   szModName[MAX_MODULE_NAME + 1] = _T("");
                UINT    uInclude, uExclude;

                GetDlgItemText(hdlg, IDC_MOD_NAME, szModName, ARRAYSIZE(szModName));

                CSTRING::Trim(szModName);

                uInclude = IsDlgButtonChecked(hdlg, IDC_INCLUDE);
                uExclude = IsDlgButtonChecked(hdlg, IDC_EXCLUDE);

                if ((BST_CHECKED == uInclude) || (BST_CHECKED == uExclude)) {

                    AddModuleToListView(szModName, uInclude, hwndModuleList);
                    SetDlgItemText(hdlg, IDC_MOD_NAME, _T(""));
                    SetFocus(GetDlgItem(hdlg, IDC_MOD_NAME));

                } else {
                    SetFocus(GetDlgItem(hdlg, IDC_INCLUDE));
                }

                break;
            }

        case IDC_REMOVEFROMLIST:
            {
                int nIndex;

                nIndex = ListView_GetSelectionMark(hwndModuleList);

                ListView_DeleteItem(hwndModuleList, nIndex);

                ENABLEWINDOW(GetDlgItem(hdlg, IDC_REMOVEFROMLIST), FALSE);

                SetFocus(GetDlgItem(hdlg, IDC_MOD_NAME));

                break;
            }

        case IDOK:
            {
                //
                // Now add the commandline 
                //
                if (s_type == FIX_LIST_SHIM) {
                    PSHIM_FIX_LIST psfl = (PSHIM_FIX_LIST)GetWindowLongPtr(hdlg, DWLP_USER);
                    TCHAR szTemp[MAX_COMMAND_LINE + 1];

                    psfl->strCommandLine.Release();
                    psfl->strlInExclude.DeleteAll();

                    

                    *szTemp = 0;

                    GetDlgItemText(hdlg,
                                   IDC_SHIM_CMD_LINE,
                                   szTemp,
                                   ARRAYSIZE(szTemp));

                    if (CSTRING::Trim(szTemp)) {
                        psfl->strCommandLine = szTemp;
                    }

                    //
                    // Add the InExclude
                    //
                    int iTotal = ListView_GetItemCount(hwndModuleList);

                    for (int iIndex = 0; iIndex < iTotal; ++iIndex) {

                        LVITEM  lvi;

                        lvi.mask     = LVIF_PARAM;
                        lvi.iItem    = iIndex;
                        lvi.iSubItem = 0;

                        if (!ListView_GetItem(hwndModuleList, &lvi)) {
                            assert(FALSE);
                            continue;
                        }

                        ListView_GetItemText(hwndModuleList, iIndex, 1, szTemp, ARRAYSIZE(szTemp));

                        if (CSTRING::Trim(szTemp)) {
                            psfl->strlInExclude.AddString(szTemp, lvi.lParam);
                        }
                    }

                } else {

                    PFLAG_FIX_LIST  pffl = (PFLAG_FIX_LIST)GetWindowLongPtr(hdlg, DWLP_USER);
                    TCHAR           szTemp[MAX_COMMAND_LINE + 1];

                    pffl->strCommandLine.Release();

                    *szTemp = 0;

                    GetDlgItemText(hdlg,
                                   IDC_SHIM_CMD_LINE,
                                   szTemp,
                                   ARRAYSIZE(szTemp));

                    if (CSTRING::Trim(szTemp)) {
                        pffl->strCommandLine = szTemp;
                    }
                }

                EndDialog(hdlg, TRUE);
                break;
            }

        case IDCANCEL:

            EndDialog(hdlg, FALSE);
            break;

        default:
            return FALSE;
        }

        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void 
ShowParams(
    IN  HWND    hDlg, 
    IN  HWND    hwndList
    )
/*++

    ShowParams

	Desc:	Pops up the params dialog

	Params:
        IN  HWND    hDlg:       The dialog box that contains the list box that shows the params
        IN  HWND    hwndList:   The list box that shows the params
        
    Notes:  The same function is called for both configuring the params in the shim wizard and
            the custom layer proc
            We can show and customize  params only in the expert mode

	Return:
        void
--*/
{                                          
    if (!g_bExpert) {
        return;
    }

    int iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    if (iSelected == -1) {
        return;
    }

    LVITEM lvi;

    lvi.mask     = LVIF_PARAM;
    lvi.iItem    = iSelected;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(hwndList, &lvi)) {
        return;
    }

    if (lvi.lParam == NULL) {
        assert(FALSE);
        return;
    }

    TYPE type = ((PDS_TYPE)lvi.lParam)->type; 

    //
    // We want to process this only for shims and flags.
    //
    PSHIM_FIX_LIST  psfl = NULL;
    PFLAG_FIX_LIST  pffl = NULL;

    if (type == FIX_LIST_SHIM) {
        psfl = (PSHIM_FIX_LIST)lvi.lParam;

    } else if (type == FIX_LIST_FLAG) {
        pffl = (PFLAG_FIX_LIST)lvi.lParam;

    } else {
        assert(FALSE);
        return;
    }

    if (DialogBoxParam(g_hInstance,                                                                                     
                       MAKEINTRESOURCE(IDD_OPTIONS),                                                                           
                       hDlg,                                                                                                    
                       ParamsDlgProc,                                                                                      
                       (LPARAM)lvi.lParam)) {

        if (type == FIX_LIST_SHIM) {

            ListView_SetItemText(hwndList, iSelected, 1, psfl->strCommandLine);

            if (psfl->strlInExclude.IsEmpty()) {
                ListView_SetItemText(hwndList, iSelected, 2, GetString(IDS_NO));

            } else {
                ListView_SetItemText(hwndList, iSelected, 2, GetString(IDS_YES));
            }

        } else {

            ListView_SetItemText(hwndList, iSelected, 1, pffl->strCommandLine);
            ListView_SetItemText(hwndList, iSelected, 2, GetString(IDS_NO));
        }
    }
}

void
HandleShowAllAtrr(
    IN  HWND hdlg
    )
/*++

    HandleShowAllAtrr

	Desc:	Shows all the attributes of all the matching files.
            When we save a database, only the attributes that are in selected are in the XML
            So we might need to see all the other attributes if we wish to add some new
            attributes

	Params:
        IN  HWND hdlg:  The matching file wizard page

	Return:
        void
--*/
{
    
    TCHAR           szDir[MAX_PATH];
    PMATCHINGFILE   pMatchTemp;
    HWND            hwndTree    = GetDlgItem(hdlg, IDC_FILELIST);
    PATTRINFO       pAttrInfo;
    PTCHAR          pchTemp     = NULL;

    //
    // Get the long file name of the file being fixed.
    //  
    if (g_pCurrentWizard->CheckAndSetLongFilename(hdlg, IDS_GETCOMPLETEPATH) == FALSE) {
        //
        // User pressed cancel there or there was some error
        //
        return;
    }

    //
    // Get the directory of the exe being fixed
    //
    *szDir = 0;
    SafeCpyN(szDir, g_pCurrentWizard->m_Entry.strFullpath, ARRAYSIZE(szDir));

    pchTemp = _tcsrchr(szDir, TEXT('\\'));

    if (pchTemp && pchTemp < (szDir + ARRAYSIZE(szDir) - 1)) {
        *(++pchTemp) = 0;
    }
    
    TreeDeleteAll(hwndTree);

    pMatchTemp = g_pCurrentWizard->m_Entry.pFirstMatchingFile;

    //
    // For all the matching files that are associated with the entry,
    // get their complete attributes
    //
    while (pMatchTemp) {

        CSTRING strFullName = szDir;

        //
        // Get the full path of the matching file
        //
        strFullName.Strcat(pMatchTemp->strMatchName);

        if (pMatchTemp->strMatchName == TEXT("*")) {
            pMatchTemp->strFullName = g_pCurrentWizard->m_Entry.strFullpath;
        } else {
            pMatchTemp->strFullName = strFullName;
        }

        if (SdbGetFileAttributes(pMatchTemp->strFullName, &pAttrInfo, NULL)) {
            //
            // SdbGetFileAttributes can fail if the file does not exist on the target
            // machine
            //
            pMatchTemp->attributeList = pAttrInfo;
        }

        pMatchTemp = pMatchTemp->pNext;
    }

    //
    // Refresh the list now.
    //
    SendMessage(hdlg, WM_USER_MATCHINGTREE_REFRESH, 0, 0);
}

void
SetMask(
    IN  HWND hwndTree
    )
/*++
    SetMask
        
    Desc:   Checks which attributes are selected in the matching files tree and sets the 
            dwMask of PMATCHINGFILE accordingly
            
    Params:
        IN  HWND hwndTree:  The matching file tree
--*/
{   
    LPARAM lParam;

    HTREEITEM hItemMatch = TreeView_GetRoot(hwndTree), hItemAttr;
    PMATCHINGFILE pMatch = NULL;

    while (hItemMatch) {

        TVITEM  Item;

        Item.mask = TVIF_PARAM;
        Item.hItem = hItemMatch;

        if (!TreeView_GetItem(hwndTree, &Item)) {
            assert(FALSE);
            goto Next_Match;
        }

        lParam = Item.lParam;

        pMatch = (PMATCHINGFILE)lParam;

        pMatch->dwMask = 0;
        //
        // Now Traverse this tree and then set the mask properly
        //
        hItemAttr =  TreeView_GetChild(hwndTree, hItemMatch);

        while (hItemAttr) {

            Item.mask   = TVIF_PARAM;
            Item.hItem  = hItemAttr;

            if (!TreeView_GetItem(hwndTree, &Item)) {
                assert(FALSE);
                goto Next_Attr;
            }

            lParam = Item.lParam;

            int iPos = TagToIndex((TAG)lParam); 

            if (iPos != -1 && TreeView_GetCheckState(hwndTree, hItemAttr) == 1) {

                pMatch->dwMask |= 1 << (iPos + 1);
            }

            Next_Attr:
            hItemAttr = TreeView_GetNextSibling(hwndTree, hItemAttr);
        }

        Next_Match:
        hItemMatch = TreeView_GetNextSibling(hwndTree, hItemMatch);
    }
}


BOOL
HandleLayersNext(
    IN  HWND            hdlg,
    IN  BOOL            bCheckAndAddLua,
    OUT CSTRINGLIST*    pstrlAddedLuaShims //(NULL)
    )
/*++

    HandleLayersNext

	Desc:	Handles the pressing of Next/Finish button for the layers wizard page

	Params:
        IN  HWND            hdlg:                   The layers wizard page
        IN  BOOL            bCheckAndAddLua:        Should we check if the user has selected LUA layer and add
            the shims if he has. 
            
        OUT CSTRINGLIST*    pstrlShimsAdded(NULL):  This is passed to AddLuaShimsInEntry. See the description
            in that routine to see how this is used

	Return:
        FALSE: If there is some error, or the entry contains no shim, flag or layer
        TRUE: Otherwise
        
--*/    
{
    g_bIsLUALayerSelected = FALSE;

    g_pCurrentWizard->WipeEntry(FALSE, FALSE, TRUE, FALSE);  

    HWND hwndRadio = GetDlgItem(hdlg, IDC_RADIO_NONE);

    //
    // Get the Selected Layers
    //
    if (SendMessage(hwndRadio, BM_GETCHECK, 0, 0) != BST_CHECKED) {

        PLAYER_FIX_LIST plfl = new LAYER_FIX_LIST;

        if (plfl == NULL) {
            MEM_ERR;
            return FALSE;
        }

        hwndRadio = GetDlgItem(hdlg, IDC_RADIO_95);

        if (SendMessage(hwndRadio, BM_GETCHECK, 0, 0) == BST_CHECKED) {
            plfl->pLayerFix = (PLAYER_FIX)FindFix(s_arszOsLayers[0], FIX_LAYER);
            goto LAYER_RADIO_DONE;
        }

        hwndRadio = GetDlgItem(hdlg, IDC_RADIO_NT);

        if (SendMessage(hwndRadio, BM_GETCHECK, 0, 0) == BST_CHECKED) {
            plfl->pLayerFix = (PLAYER_FIX)FindFix(s_arszOsLayers[1], FIX_LAYER);
            goto LAYER_RADIO_DONE;
        }
            
        hwndRadio = GetDlgItem(hdlg, IDC_RADIO_98);

        if (SendMessage(hwndRadio, BM_GETCHECK, 0, 0) == BST_CHECKED) {
            plfl->pLayerFix = (PLAYER_FIX)FindFix(s_arszOsLayers[2], FIX_LAYER);
            goto LAYER_RADIO_DONE;
        }

        hwndRadio = GetDlgItem(hdlg, IDC_RADIO_2K);

        if (SendMessage(hwndRadio, BM_GETCHECK, 0, 0) == BST_CHECKED) {
            plfl->pLayerFix = (PLAYER_FIX)FindFix(s_arszOsLayers[3], FIX_LAYER);
            goto LAYER_RADIO_DONE;
        }

    LAYER_RADIO_DONE:
        //
        // Add the selected Layer
        //
        g_pCurrentWizard->m_Entry.pFirstLayer = plfl;
    }
    //
    // Now add the layers selected in the List View
    //
    UINT            uIndex;
    UINT            uLayerCount = ListView_GetItemCount(s_hwndLayerList);
    PLAYER_FIX_LIST plflInList  = NULL;

    for (uIndex = 0 ; uIndex < uLayerCount; ++uIndex) {

        LVITEM  Item;

        Item.mask     = LVIF_PARAM;
        Item.iItem    = uIndex;
        Item.iSubItem = 0;               

        if (!ListView_GetItem(s_hwndLayerList, &Item)) {
            assert(FALSE);
            continue;
        }

        if (ListView_GetCheckState(s_hwndLayerList, uIndex)) {

            plflInList = (PLAYER_FIX_LIST)Item.lParam;
            assert(plflInList);                        

            //
            // If the layer is LUA, we need to add the shims individually because
            // when we pass a PDBENTRY around, we don't want to change the PLUADATA
            // in the shim of the layer (which will be global).
            //
            if (plflInList->pLayerFix->strName == TEXT("LUA")) {
                g_bIsLUALayerSelected = TRUE;
            } else {

                PLAYER_FIX_LIST plfl = new LAYER_FIX_LIST;

                if (plfl == NULL) {
                    MEM_ERR;
                    return FALSE;
                }

                plfl->pLayerFix = plflInList->pLayerFix;

                plfl->pNext = g_pCurrentWizard->m_Entry.pFirstLayer;
                g_pCurrentWizard->m_Entry.pFirstLayer = plfl;
            }
        }
    }

    //
    // If have seleted LUA layer and we have pressed the Finish button, that means
    // that we are in editing mode and we want to add LUA layer and close the dialog
    // In this case we must check if the LUA shims exist and if not then we must add 
    // the lua shims ourselves
    //
    if (g_bIsLUALayerSelected && bCheckAndAddLua) {
        AddLuaShimsInEntry(&g_pCurrentWizard->m_Entry, pstrlAddedLuaShims);
    }

    PDBENTRY pEntry = &g_pCurrentWizard->m_Entry;

    if (pEntry && pEntry->pFirstFlag || pEntry->pFirstLayer || pEntry->pFirstShim) {
        //
        // The entry contains some fix or layer
        //
        return TRUE;
    }

    return FALSE;
}

BOOL
HandleShimsNext(
    IN  HWND hdlg
    )
/*++

    HandleShimsNext

	Desc:	Handles the pressing of Next/Finish button for the shims wizard page

	Params:
        IN  HWND hdlg:  The shims wizard page

	Return:
        FALSE: If there is some error, or the entry contains no shim, flag or layer
        TRUE: Otherwise
--*/
{
    
    PLAYER_FIX_LIST     plfl            = NULL;
    HWND                hwndShimList    = NULL;
    UINT                uShimCount      = 0;

    g_pCurrentWizard->WipeEntry(FALSE, TRUE, FALSE, TRUE);

    hwndShimList    = GetDlgItem(hdlg, IDC_SHIMLIST);
    uShimCount      = ListView_GetItemCount(hwndShimList);

    for (UINT uIndex = 0 ; uIndex < uShimCount; ++uIndex) {

        LVITEM  Item;

        Item.lParam   = 0;
        Item.mask     = LVIF_PARAM;
        Item.iItem    = uIndex;
        Item.iSubItem = 0;

        if (!ListView_GetItem(hwndShimList, &Item)) {
            assert(FALSE);
        }

        if (ListView_GetCheckState(hwndShimList, uIndex)) {

            TYPE type = ((PDS_TYPE)Item.lParam)->type;

            if (type == FIX_LIST_SHIM) {

                PSHIM_FIX_LIST psfl= (PSHIM_FIX_LIST)Item.lParam;

                assert(psfl);

                //
                // Check if this is already part of some layer.
                //
                plfl = g_pCurrentWizard->m_Entry.pFirstLayer;

                while (plfl) {

                    if (IsShimInlayer(plfl->pLayerFix, psfl->pShimFix, &psfl->strCommandLine, &psfl->strlInExclude)) {
                        break;
                    }

                    plfl = plfl->pNext;
                }

                if (plfl) {

                    //
                    // This shim is a part of some mode
                    //
                    continue;
                }

                PSHIM_FIX_LIST psflNew = new SHIM_FIX_LIST;

                if (psflNew == NULL) {
                    MEM_ERR;
                    return FALSE;
                }

                psflNew->pShimFix       = psfl->pShimFix;
                psflNew->strCommandLine = psfl->strCommandLine;
                psflNew->strlInExclude  = psfl->strlInExclude;

                if (psfl->pLuaData) {
                    psflNew->pLuaData = new LUADATA;

                    if (psflNew->pLuaData) {
                        psflNew->pLuaData->Copy(psfl->pLuaData);
                    }
                }

                psflNew->pNext = g_pCurrentWizard->m_Entry.pFirstShim;
                g_pCurrentWizard->m_Entry.pFirstShim = psflNew;

            } else if (type == FIX_LIST_FLAG) {

                PFLAG_FIX_LIST pffl = (PFLAG_FIX_LIST)Item.lParam;
                assert(pffl);

                plfl = g_pCurrentWizard->m_Entry.pFirstLayer;

                while (plfl) {

                    if (IsFlagInlayer(plfl->pLayerFix, pffl->pFlagFix, &pffl->strCommandLine)) {
                        break;
                    }

                    plfl = plfl->pNext;
                }

                if (plfl) {

                    //
                    // This flag is a part of some layer
                    //
                    continue;
                }

                PFLAG_FIX_LIST pfflNew = new FLAG_FIX_LIST;

                if (pfflNew == NULL) {
                    MEM_ERR;
                    return FALSE;
                }

                pfflNew->pFlagFix       = pffl->pFlagFix;
                pfflNew->strCommandLine = pffl->strCommandLine;

                pfflNew->pNext = g_pCurrentWizard->m_Entry.pFirstFlag;
                g_pCurrentWizard->m_Entry.pFirstFlag = pfflNew;
            }
        }
    }

    PDBENTRY pEntry = &g_pCurrentWizard->m_Entry;

    if (pEntry->pFirstFlag || pEntry->pFirstLayer || pEntry->pFirstShim) {
        return TRUE;
    }

    return FALSE;
}

void
ShowSelected(
    IN  HWND hdlg
    )
/*++

    ShowSelected
    
    Desc:   Show only the checked shims/flags. Deletes the shims/flags that are not checked.
            This function is called from the SelectShims(...)
            
    Params:
        IN  HWND hdlg:  The shims wizard page
        
--*/
{
    HWND    hwndShimList    = GetDlgItem(hdlg, IDC_SHIMLIST);
    UINT    uShimCount      = ListView_GetItemCount(hwndShimList);
    INT     uCheckedCount   = 0;
    LVITEM  lvi = {0};

    uCheckedCount = uShimCount;

    SendMessage(hwndShimList, WM_SETREDRAW, FALSE, 0);

    for (INT iIndex = uShimCount - 1 ; iIndex >= 0 ; --iIndex) {

        LVITEM  Item;

        Item.lParam = 0;
        Item.mask     = LVIF_PARAM;
        Item.iItem    = iIndex;
        Item.iSubItem = 0;

        if (!ListView_GetItem(hwndShimList, &Item)) {
            assert(FALSE);
        }

        if (!ListView_GetCheckState(hwndShimList, iIndex)) {

            TYPE type = ((PDS_TYPE)Item.lParam)->type;

            if (type == FIX_LIST_SHIM) {

                DeleteShimFixList((PSHIM_FIX_LIST)Item.lParam);

            } else if (type == FIX_LIST_FLAG) {

                DeleteFlagFixList((PFLAG_FIX_LIST)Item.lParam);
            }

            ListView_DeleteItem(hwndShimList, iIndex);
            --uCheckedCount;
        }
    }    

    SendMessage(hwndShimList, WM_SETREDRAW, TRUE, 0);
    UpdateWindow(hwndShimList);

    s_bAllShown = FALSE;
    SetDlgItemText(hdlg, IDC_SHOW, GetString(IDS_SHOW_BUTTON_ALL));

    if (ListView_GetSelectedCount(hwndShimList) > 0) {
        ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS), TRUE);
    } else {
        ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS), FALSE);
    }

    //
    // Select the first item.
    //
    if (uCheckedCount) {

        //
        // If the first shim is part of a layer, then the parms button will
        // get disabled in the handler for LVN_ITEMCHANGED.
        //
        ListView_SetSelectionMark(hwndShimList, 0);
        ListView_SetItemState(hwndShimList, 
                              0, 
                              LVIS_FOCUSED | LVIS_SELECTED , 
                              LVIS_FOCUSED | LVIS_SELECTED);

        lvi.mask        = LVIF_IMAGE;
        lvi.iItem       = 0;
        lvi.iSubItem    = 0;

        //
        // The above does not work always. We will disable the param button if the shim is part of 
        // a layer
        //
        if (ListView_GetItem(hwndShimList, &lvi)) {
            if (lvi.iImage == IMAGE_SHIM) {
                //
                // This shim is not part of a layer
                //
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS), TRUE);
            } else {
                //
                // This shim is part of a layer, we must now allow to change paramters for this
                //
                ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS), FALSE);
            }
        } else {
            ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS), FALSE);
        }

    } else {
        //
        // There are no shims, better disable the params button.
        //
        ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS), FALSE);
    }
}

void
ShowItems(
    IN  HWND hdlg
    )
/*++

    ShowItems

	Desc:	Populates the fixes list view in the shims wizard page

	Params:
        IN  HWND hdlg:  The shims wizard page

	Return:
        void
--*/
{
    g_bNowTest              = FALSE;

    HWND        hwndList    = GetDlgItem(hdlg, IDC_SHIMLIST);
    PSHIM_FIX   psf         = GlobalDataBase.pShimFixes; 

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Read the shims.
    //
    LVFINDINFO  lvfind;
    LVITEM      lvi;
    UINT        uCount = 0;

    while (psf) {

        if (psf->bGeneral || g_bExpert) {

            PSHIM_FIX_LIST  psflAsInLayer = NULL; 
            BOOL            bShimInLayer  =  ShimPresentInLayersOfEntry(&g_pCurrentWizard->m_Entry, 
                                                                        psf, 
                                                                        &psflAsInLayer);

            BOOL bLUAShimInLayer = 
            (g_bIsLUALayerSelected && 
             (psf->strName == TEXT("LUARedirectFS") ||
              psf->strName == TEXT("LUARedirectReg")));
            //
            // Check if the shim is already present in the list.
            // 
            lvfind.flags = LVFI_STRING;
            lvfind.psz   = psf->strName.pszString;

            INT iIndex = ListView_FindItem(hwndList, -1, &lvfind);

            if (-1 == iIndex) {

                PSHIM_FIX_LIST pShimFixList = new SHIM_FIX_LIST;

                if (pShimFixList == NULL) {
                    MEM_ERR;
                    break;
                }

                //
                // This will contain a ptr to the shimlist, if there is a layer 
                // that has this shim and the layer has been applied to the entry 
                //
                pShimFixList->pShimFix = psf;

                //
                // If this is present in some selected layer, set the param for this just as they are in the layer
                //
                if (psflAsInLayer) {

                    pShimFixList->strCommandLine= psflAsInLayer->strCommandLine;
                    pShimFixList->strlInExclude = psflAsInLayer->strlInExclude;
                }

                ZeroMemory(&lvi, sizeof(lvi));

                lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                lvi.pszText   = psf->strName;
                lvi.iItem     = uCount;
                lvi.iSubItem  = 0;
                lvi.iImage    = (bShimInLayer || bLUAShimInLayer) ?  IMAGE_LAYERS : IMAGE_SHIM;
                lvi.lParam    = (LPARAM)pShimFixList;

                iIndex = ListView_InsertItem(hwndList, &lvi);

                ListView_SetCheckState(hwndList, 
                                       iIndex, 
                                       bShimInLayer || bLUAShimInLayer);

                //
                // If we are in edit mode, then select the used ones and set the params appropriately
                //
                PSHIM_FIX_LIST psflFound = NULL; // the pshimfix list found in the entry. This is used for populating the previous commandline etc.

                if (g_pCurrentWizard->m_bEditing && ShimPresent(psf, &g_pCurrentWizard->m_Entry, &psflFound)) {

                    ListView_SetCheckState(hwndList, iIndex, TRUE);

                    //
                    // Add the commandline for this shim
                    //
                    if (psflFound && psflFound->strCommandLine.Length() > 0) {

                        pShimFixList->strCommandLine = psflFound->strCommandLine;
                    }

                    //
                    // Add the include exclude for this shim
                    //
                    if (psflFound && !psflFound->strlInExclude.IsEmpty()) {

                        pShimFixList->strlInExclude = psflFound->strlInExclude;
                    }

                    //
                    // Add the LUA data for this shim
                    //
                    if (psflFound && psflFound->pLuaData) {

                        pShimFixList->pLuaData = new LUADATA;

                        if (pShimFixList->pLuaData) {
                            pShimFixList->pLuaData->Copy(psflFound->pLuaData);
                        } else {
                            MEM_ERR;
                        }
                    }
                }

                if (g_bExpert) {

                    ListView_SetItemText(hwndList, iIndex, 1, pShimFixList->strCommandLine);
                    CSTRING strModulePresent;

                    strModulePresent= pShimFixList->strlInExclude.IsEmpty() ? GetString(IDS_NO) : GetString(IDS_YES);
                    ListView_SetItemText(hwndList, iIndex, 2, strModulePresent);
                }

            } else {

                PSHIM_FIX_LIST pShimFixList = NULL;

                //
                // We might need to change the state of some of the existing shims.
                //
                ZeroMemory(&lvi, sizeof(lvi));

                lvi.mask        = LVIF_IMAGE | LVIF_PARAM;
                lvi.iItem       = iIndex;
                lvi.iSubItem    = 0;

                if (!ListView_GetItem(hwndList, &lvi)) {
                    assert(FALSE);
                    return;
                }

                pShimFixList = (PSHIM_FIX_LIST)lvi.lParam;

                if (pShimFixList == NULL) {
                    assert(FALSE);
                    return;
                }

                INT iPrevImage = lvi.iImage, iNewImage = 0;

                iNewImage = lvi.iImage = (bShimInLayer || bLUAShimInLayer) ?  IMAGE_LAYERS : IMAGE_SHIM;
                ListView_SetItem(hwndList, &lvi);

                //
                // If this is present in some selected layer, set the param for this just as they are in the layer
                //
                if (bShimInLayer) {

                    if (psflAsInLayer) {
                        pShimFixList->strCommandLine= psflAsInLayer->strCommandLine;
                        pShimFixList->strlInExclude = psflAsInLayer->strlInExclude;
                    } else {
                        assert(FALSE);
                    }
                }

                if (iPrevImage != iNewImage) {

                    ListView_SetCheckState(hwndList, 
                                           iIndex, 
                                           bShimInLayer || bLUAShimInLayer);
                    //
                    // if this shim was earlier a part of layer, we must change the param. Remove All
                    //
                    if (iPrevImage != IMAGE_SHIM) {
                        pShimFixList->strCommandLine = TEXT("");
                        pShimFixList->strlInExclude.DeleteAll();
                    }
                }

                //
                // Must now refresh the params in the list box.
                //
                if (g_bExpert) {

                    ListView_SetItemText(hwndList, iIndex, 1, pShimFixList->strCommandLine);
                    CSTRING strModulePresent;

                    strModulePresent= pShimFixList->strlInExclude.IsEmpty() ? GetString(IDS_NO) : GetString(IDS_YES);
                    ListView_SetItemText(hwndList, iIndex, 2, strModulePresent);
                }
            }

            ++uCount;
        }

        psf = psf->pNext;
    }

    //
    // Now read in the flags as well.
    //
    PFLAG_FIX pff =  GlobalDataBase.pFlagFixes;

    while (pff) {

        if (pff->bGeneral || g_bExpert) {

            PFLAG_FIX_LIST  pfflAsInLayer = NULL; 
            BOOL            bFlagInLayer  =  FlagPresentInLayersOfEntry(&g_pCurrentWizard->m_Entry, 
                                                                        pff, 
                                                                        &pfflAsInLayer);
            //
            // Check if the flag is already present in the list.
            // 
            lvfind.flags = LVFI_STRING;
            lvfind.psz   = pff->strName.pszString;

            INT iIndex = ListView_FindItem(hwndList, -1, &lvfind);

            if (-1 == iIndex) {

                PFLAG_FIX_LIST pFlagFixList = new FLAG_FIX_LIST;

                if (pFlagFixList == NULL) {
                    MEM_ERR;
                    break;
                }

                pFlagFixList->pFlagFix = pff;

                ZeroMemory(&lvi, sizeof(lvi));
                lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;                                 
                lvi.pszText   = pff->strName;
                lvi.iItem     = uCount;                                                
                lvi.iSubItem  = 0;                                                     
                lvi.iImage    = bFlagInLayer ? IMAGE_LAYERS : IMAGE_SHIM;
                lvi.lParam    = (LPARAM)pFlagFixList;

                INT iIndexInserted = ListView_InsertItem(hwndList, &lvi);

                ListView_SetCheckState(hwndList, iIndexInserted, bFlagInLayer);

                ListView_SetItemText(hwndList, iIndexInserted, 2, GetString(IDS_NO));

                //
                // If we are in edit mode, then select the used ones and set the params appropritely
                //
                //
                // the pflagfix list found in the entry. This is used for populating the previous commandline etc.
                //
                PFLAG_FIX_LIST pfflFound = NULL; 

                if (g_pCurrentWizard->m_bEditing && FlagPresent(pff, 
                                                                &g_pCurrentWizard->m_Entry, 
                                                                &pfflFound)) {

                    ListView_SetCheckState(hwndList, iIndexInserted, TRUE);

                    //
                    // Add the commandline for this flag
                    //
                    if (pfflFound && pfflFound->strCommandLine.Length() > 0) {

                        pFlagFixList->strCommandLine = pfflFound->strCommandLine;
                    }

                    //
                    // Refresh the command-line for this flag in the list view
                    //
                    if (g_bExpert) {

                        ListView_SetItemText(hwndList, iIndexInserted, 1, pFlagFixList->strCommandLine);
                        ListView_SetItemText(hwndList, iIndexInserted, 2, GetString(IDS_NO));
                    }
                }

            } else {
                //
                // We might need to change the state of some of the existing flags.
                //
                PFLAG_FIX_LIST pFlagFixList = NULL;

                ZeroMemory(&lvi, sizeof(lvi));

                lvi.mask        = LVIF_IMAGE | LVIF_PARAM;
                lvi.iItem       = iIndex;
                lvi.iSubItem    = 0;

                if (!ListView_GetItem(hwndList, &lvi)) {
                    assert(FALSE);
                    return;
                }

                pFlagFixList = (PFLAG_FIX_LIST)lvi.lParam;

                if (pFlagFixList == NULL) {
                    assert(FALSE);
                    return;
                }

                INT iPrevImage = lvi.iImage, iNewImage = 0;


                iNewImage = lvi.iImage = (bFlagInLayer) ? IMAGE_LAYERS : IMAGE_SHIM;
                ListView_SetItem(hwndList, &lvi);

                //
                // Set the commandline for this flag appropriately
                //
                if (bFlagInLayer) {
                    pFlagFixList->strCommandLine= pfflAsInLayer->strCommandLine;
                }

                if (iPrevImage != iNewImage) {
                    ListView_SetCheckState(hwndList, iIndex, bFlagInLayer);

                    //
                    // if this flag was earlier a part of layer, we must change the param. Remove it.
                    //
                    if (iPrevImage != IMAGE_SHIM) {
                        pFlagFixList->strCommandLine = TEXT("");
                    }
                }

                //
                // Refresh the command-line for this flag in the list view
                //
                if (g_bExpert) {

                    ListView_SetItemText(hwndList, iIndex, 1, pFlagFixList->strCommandLine);
                    ListView_SetItemText(hwndList, iIndex, 2, GetString(IDS_NO));
                }
            }

            ++uCount;
        }

        pff = pff->pNext;
    }

    SetCursor(LoadCursor(NULL, IDC_ARROW));
    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
    UpdateWindow(hwndList);

    s_bAllShown = TRUE;
    SetDlgItemText(hdlg, IDC_SHOW, GetString(IDS_SHOW_BUTTON_SEL));

    if (ListView_GetSelectionMark(hwndList) != -1) {
        ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS), TRUE);
    } else {
        ENABLEWINDOW(GetDlgItem(hdlg, IDC_PARAMS), FALSE);
    }

    //
    // Set the column width of the last column in the list view appropriately to 
    // cover the width of the list view
    // Assumption:  The list view has only one column or 3 cloumns depending upon 
    // whether we are in expert mode or not.
    //
    if (g_bExpert) {
        ListView_SetColumnWidth(hwndList, 2, LVSCW_AUTOSIZE_USEHEADER);
    } else {
        ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE_USEHEADER);
    }


    g_bNowTest = TRUE;
}

BOOL
ShimPresentInLayersOfEntry(
    IN  PDBENTRY            pEntry,
    IN  PSHIM_FIX           psf,
    OUT PSHIM_FIX_LIST*     ppsfList, // (NULL) 
    OUT PLAYER_FIX_LIST*    pplfList  // (NULL)
    )
/*++
    
    ShimPresentInLayersOfEntry

    Desc:   Checks if the shim psf occurs in any any of the layers that have 
            been applied to pEntry.
            
    Params:
        IN  PDBENTRY            pEntry:             The entry for which the check has to be made
        IN  PSHIM_FIX           psf:                The shim to check for
        OUT PSHIM_FIX_LIST*     ppsfList (NULL):    Pointer to the shim fix list in the layer
            So that we might get the params for this shim in the layer
            
        OUT PLAYER_FIX_LIST*    pplfList (NULL):    Pointer to the layer fix list
        
--*/
{
    PLAYER_FIX_LIST plfl = pEntry->pFirstLayer;
    PLAYER_FIX      plf;
    PSHIM_FIX_LIST  psfl;

    while (plfl) {

        plf  = plfl->pLayerFix;
        psfl = plf->pShimFixList;

        while (psfl) {

            if (psfl->pShimFix == psf) {

                if (ppsfList) {
                    *ppsfList = psfl;
                }

                if (pplfList) {
                    *pplfList = plfl;
                }

                return TRUE;
            }

            psfl = psfl->pNext;
        }

        plfl = plfl->pNext;
    }

    return FALSE;
}

BOOL
FlagPresentInLayersOfEntry(
    IN  PDBENTRY            pEntry,
    IN  PFLAG_FIX           pff,
    OUT PFLAG_FIX_LIST*     ppffList,   // (NULL)
    OUT PLAYER_FIX_LIST*    pplfl       // (NULL)
    )
/*++
    
    FlagPresentInLayersOfEntry

    Desc:   Checks if the flag psf occurs in any any of the layers that have 
            been applied to pEntry.
            
    Params:
        IN  PDBENTRY            pEntry:             The entry for which the check has to be made
        IN  PFLAG_FIX           pff:                The flag to check for
        OUT PFLAG_FIX_LIST*     ppffList (NULL):    Pointer to the flag fix list in the layer
            So that we might get the params for this flag in the layer
            
        OUT PLAYER_FIX_LIST*    pplfList (NULL):    Pointer to the layer fix list
        
--*/
{
    PLAYER_FIX_LIST plfl = pEntry->pFirstLayer;
    PLAYER_FIX      plf;
    PFLAG_FIX_LIST  pffl;
              
    while (plfl) {

        plf  = plfl->pLayerFix;
        pffl = plf->pFlagFixList;

        while (pffl) {

            if (pffl->pFlagFix == pff) {

                if (ppffList) {
                    *ppffList = pffl;
                }

                if (pplfl) {
                    *pplfl = plfl;
                }

                return TRUE;
            }

            pffl = pffl->pNext;
        }

        plfl = plfl->pNext;
    }

    return FALSE;
}

void
CheckLayers(
    IN  HWND    hDlg
    )
/*++
    CheckLayers
    
    Desc:   Deselects all the radio buttons and then checks the one that is appropriate.
            For the layers in the list view, only checks the layers that have been 
            applied for the present entry.
            
    Params:
        IN  HWND    hDlg:   The layer wizard page
        
    Return:
        void
--*/
{

    INT             id = -1;
    LVFINDINFO      lvfind;
    HWND            hwndList = GetDlgItem(hDlg, IDC_LAYERLIST);
    PLAYER_FIX_LIST plfl = g_pCurrentWizard->m_Entry.pFirstLayer;
    INT             iTotal = ListView_GetItemCount(hwndList);
    INT             iIndex = 0;

    CheckDlgButton(hDlg, IDC_RADIO_95,   BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_RADIO_NT,   BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_RADIO_98,   BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_RADIO_2K,   BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_RADIO_NONE, BST_UNCHECKED);

    for (iIndex = 0; iIndex < iTotal; ++ iIndex) {
        ListView_SetCheckState(hwndList, iIndex, FALSE);
    }


    ZeroMemory(&lvfind, sizeof(lvfind));

    lvfind.flags = LVFI_STRING;

    id = -1;

    //
    // Take care of the LUA layer first.
    //
    if (g_bIsLUALayerSelected) {

        lvfind.psz   = TEXT("LUA");

        if ((iIndex = ListView_FindItem(hwndList, -1, &lvfind)) != -1) {
            ListView_SetCheckState(hwndList, iIndex, TRUE);
        }
    }

    while (plfl) {

        assert(plfl->pLayerFix);

        if (id == -1) {

            if (lstrcmpi(plfl->pLayerFix->strName, s_arszOsLayers[0]) == 0) {
                id = IDC_RADIO_95;

            } else if (lstrcmpi(plfl->pLayerFix->strName, s_arszOsLayers[1]) == 0) {
                id = IDC_RADIO_NT;

            } else if (lstrcmpi(plfl->pLayerFix->strName, s_arszOsLayers[2]) == 0) {
                id = IDC_RADIO_98;

            } else if (lstrcmpi(plfl->pLayerFix->strName, s_arszOsLayers[3]) == 0) {
                id = IDC_RADIO_2K;
            }

            if (id != -1) {
                CheckDlgButton(hDlg, id, BST_CHECKED);
                goto Next_loop;
            }
        }

        lvfind.flags = LVFI_STRING;
        lvfind.psz   = plfl->pLayerFix->strName;
        iIndex       = ListView_FindItem(hwndList, -1, &lvfind);

        if (iIndex != -1) {
            ListView_SetCheckState(hwndList, iIndex, TRUE);
        }

    Next_loop:
        plfl = plfl->pNext;
    }

    if (id == -1) {
        //
        // None of the OS layers were selected
        //
        CheckDlgButton(hDlg, IDC_RADIO_NONE, BST_CHECKED);
    }   
}

BOOL
HandleLayerListNotification(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++

    HandleLayerListNotification
    
    Params:
        IN  HWND    hdlg:   The layers wizard page
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY
        
    Desc:   Handles the notification messages for the layer list.
    
    Return: TRUE: If the message was handled
            FALSE: Otherwise
--*/
{
    HWND    hwndList    = GetDlgItem(hdlg, IDC_LAYERLIST);
    LPNMHDR pnm         = (LPNMHDR)lParam;

    switch (pnm->code) {
    case NM_CLICK:
        {
            LVHITTESTINFO lvhti;

            GetCursorPos(&lvhti.pt);
            ScreenToClient(s_hwndLayerList, &lvhti.pt);

            ListView_HitTest(s_hwndLayerList, &lvhti);

            //
            // If the check box state has changed toggle the selection
            //
            if (lvhti.flags & LVHT_ONITEMSTATEICON) {

                INT iPos = ListView_GetSelectionMark(s_hwndLayerList);

                if (iPos != -1) {

                    //
                    // De-select it.
                    //
                    ListView_SetItemState(s_hwndLayerList,
                                          iPos,
                                          0,
                                          LVIS_FOCUSED | LVIS_SELECTED);
                }
            }

            ListView_SetItemState(s_hwndLayerList,
                                  lvhti.iItem,
                                  LVIS_FOCUSED | LVIS_SELECTED,
                                  LVIS_FOCUSED | LVIS_SELECTED);

            ListView_SetSelectionMark(s_hwndLayerList, lvhti.iItem);

            break;
        }

    default: return FALSE;

    }

    return TRUE;
}

BOOL
HandleShimDeselect(
    IN  HWND    hdlg,
    IN  INT     iIndex
    )
/*++
    
    HandleShimDeselect
    
    Desc:   This function prompts the user if he is unchecking a shim that is part of
            some mode. If the user selects OK then we remove all the layers that 
            have this shim and for all the shims in all those layes, we change their icons
            
    Params:
        IN  HWND    hdlg:   The shims wizard page
        IN  INT     iIndex: The index of the list view item where all the action is     
            
    Return: TRUE, if the user agrees to remove the previous layer. 
            FALSE, otherwise
            
--*/
{
    HWND            hwndList = GetDlgItem(hdlg, IDC_SHIMLIST);
    LVITEM          lvi;
    PSHIM_FIX       psf = NULL;
    PSHIM_FIX_LIST  psfl = NULL;
    PFLAG_FIX_LIST  pffl = NULL;
    PLAYER_FIX_LIST plfl = NULL;
    TYPE            type;
    BOOL            bFoundInLayer = FALSE;

    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask        = LVIF_PARAM | LVIF_IMAGE;
    lvi.iItem       = iIndex;
    lvi.iSubItem    = 0;

    if (ListView_GetItem(hwndList, &lvi)) {
        type = ConvertLparam2Type(lvi.lParam);
    } else {
        assert(FALSE);
        return FALSE;
    }
    
    if (lvi.iImage != IMAGE_LAYERS) {
        return TRUE;
    }

    if (type == FIX_LIST_FLAG) {
        pffl = (PFLAG_FIX_LIST) lvi.lParam;

    } else if (type == FIX_LIST_SHIM) {
        psfl = (PSHIM_FIX_LIST) lvi.lParam;
    }

    if (psfl) {
        psf = psfl->pShimFix;

        //
        // We take care of it here if it's a LUA shim because we didn't add it to
        // the layer fix list.
        //
        if (psf->strName == TEXT("LUARedirectFS") ||
            psf->strName == TEXT("LUARedirectReg")) {

            if (g_bIsLUALayerSelected) {

                if (IDYES == MessageBox(hdlg, GetString(IDS_SHIMINLAYER), g_szAppName, MB_ICONWARNING | MB_YESNO)) {

                    // 
                    // The only thing we need to do is changing the icon back to the shim
                    // icon. We need to change this for both shims in the layer.
                    //
                    ChangeShimIcon(TEXT("LUARedirectFS"));
                    ChangeShimIcon(TEXT("LUARedirectReg"));

                    g_bIsLUALayerSelected = FALSE;
                } else {
                    return FALSE;
                }
            }

            return TRUE;
        }

        //
        // Othewise just go through the normal path.
        //
        bFoundInLayer = ShimPresentInLayersOfEntry(&g_pCurrentWizard->m_Entry, 
                                                   psf, 
                                                   NULL, 
                                                   &plfl);
    } else if (pffl) {

        bFoundInLayer = FlagPresentInLayersOfEntry(&g_pCurrentWizard->m_Entry, 
                                                   pffl->pFlagFix, 
                                                   NULL, 
                                                   &plfl);
    }

    if (bFoundInLayer) {

        if (IDYES == MessageBox(hdlg, GetString(IDS_SHIMINLAYER), g_szAppName, MB_ICONWARNING | MB_YESNO)) {

            s_bLayerPageRefresh = TRUE;

            //
            // For all the layers that have this shim, 
            // 1. Change the icons,
            // 2. As for now, we retain the params just as the that in the layer
            // 3. Remove the layer from the entry
            //
            PLAYER_FIX_LIST plflTemp        = g_pCurrentWizard->m_Entry.pFirstLayer; 
            PLAYER_FIX_LIST plflTempPrev    = NULL;
            PLAYER_FIX_LIST plflTempNext    = NULL;

            //
            // Go to the first layer that has this shim or flag
            //
            while (plflTemp) {

                if (plflTemp == plfl) {
                    break;

                } else {
                    plflTempPrev = plflTemp;
                }

                plflTemp = plflTemp->pNext;
            }

            while (plflTemp) {
                //
                // Now for all the layers following and including this layer,
                // check if it has the selected shim or flag.
                // If it has then, we change the icons of all the shims and flags that are present in this layer
                // and remove it from the list of layers applied to this entry
                //
                bFoundInLayer = FALSE;

                if (psfl) {
                    bFoundInLayer = IsShimInlayer(plflTemp->pLayerFix, psfl->pShimFix, NULL, NULL);
                } else if (pffl) {
                    bFoundInLayer = IsFlagInlayer(plflTemp->pLayerFix, pffl->pFlagFix, NULL);
                }

                if (bFoundInLayer) {

                    ChangeShimFlagIcons(hdlg, plflTemp);

                    if (plflTempPrev == NULL) {
                        g_pCurrentWizard->m_Entry.pFirstLayer = plflTemp->pNext;
                    } else {
                        plflTempPrev->pNext = plflTemp->pNext;
                    }

                    plflTempNext    = plflTemp->pNext;

                    //
                    // Do not do a DeleteLayerFixList here as this will remove 
                    // all layer fix lists following this as well.
                    //
                    delete plflTemp;
                    plflTemp        = plflTempNext;

                } else {

                    plflTempPrev  = plflTemp;
                    plflTemp = plflTemp->pNext;
                }
            }

        } else {

            return FALSE;
        }
    }

    return TRUE;
}


void
ChangeShimIcon(
    IN  LPCTSTR pszItem
    )
/*++
    ChangeShimIcon
        
    Desc:   Changes the icon of the shim/flag with the name pszItem to a shim icon.
    
    Params:
        IN  LPCTSTR pszItem:    The name of the shim  or flag
    
--*/
{
    LVFINDINFO      lvfind;
    LVITEM          lvi;
    INT             iIndex      = -1;

    ZeroMemory(&lvfind, sizeof(lvfind));

    lvfind.flags = LVFI_STRING;
    lvfind.psz   = pszItem;

    if ((iIndex = ListView_FindItem(s_hwndShimList, -1, &lvfind)) != -1) {

        ZeroMemory(&lvi, sizeof(lvi));

        lvi.mask        = LVIF_IMAGE;
        lvi.iItem       = iIndex;
        lvi.iSubItem    = 0;
        lvi.iImage      = IMAGE_SHIM;

        ListView_SetItem(s_hwndShimList, &lvi);
    }
}

void
ChangeShimFlagIcons(
    IN  HWND            hdlg,
    IN  PLAYER_FIX_LIST plfl
    )
/*++
    
    ChangeShimFlagIcons
    
    Desc:   For All the shims and flags that are present in plfl, 
            this routine changes their icons to indicate that they
            are no longer part of some layer
            
    Params:
        IN  HWND            hdlg:   The shims wizard page
        IN  PLAYER_FIX_LIST plfl:   The layer for which is abou to be removed, so we need to 
            change the icons for all the shims and flags that are part of this layer. 
            
    Return:
        void
        
--*/
{
    PSHIM_FIX_LIST  psfl        = plfl->pLayerFix->pShimFixList;
    PFLAG_FIX_LIST  pffl        = plfl->pLayerFix->pFlagFixList;

    //
    // First for the shims
    //
    while (psfl) {

        assert(psfl->pShimFix);
        ChangeShimIcon(psfl->pShimFix->strName.pszString);
        psfl= psfl->pNext;
    }

    //
    // Now for the flags
    //
    while (pffl) {

        assert(pffl->pFlagFix);
        ChangeShimIcon(pffl->pFlagFix->strName.pszString);
        pffl = pffl->pNext;
    }
}

BOOL
AddLuaShimsInEntry(
    IN  PDBENTRY        pEntry,
    OUT CSTRINGLIST*    pstrlShimsAdded //(NULL)
    )
/*++

    AddLuaShimsInEntry

	Desc:	Adds the lua shims which are present in LUA layer to an entry. First checks
            if the shim is already present, if yes does not add it.

	Params:
        IN  PDBENTRY        pEntry:                 The entry to which we want to add the lua shims
        OUT CSTRINGLIST*    pstrlShimsAdded(NULL):  The names of the lua shims that this routine has added
            We need this because if we are doing a test run then after the test-run is over, we
            will have to remove these shims

	Return:
        TRUE:   Success
        FALSE:  Otherwise
--*/
{
    
    PLAYER_FIX      plfLua      = NULL;
    PSHIM_FIX_LIST  psflInLua   = NULL;
    PSHIM_FIX_LIST  psflNew     = NULL;

    if (pEntry == NULL) {
        assert(FALSE);
        return FALSE;
    }

    plfLua = (PLAYER_FIX)FindFix(TEXT("LUA"), FIX_LAYER, &GlobalDataBase);

    if (plfLua == NULL) {
        assert(FALSE);
        return FALSE;
    } else {
        //
        // For all the shims in LUA add them to this entry. But first check if that 
        // shim is already present in the entry
        //
        psflInLua = plfLua->pShimFixList;

        while (psflInLua) {

            //
            // Do not add a shim that is already present
            //
            if (!IsShimInEntry(psflInLua->pShimFix->strName, 
                               pEntry)) {

                psflNew = new SHIM_FIX_LIST;

                if (psflNew == NULL) {
                    MEM_ERR;
                    break;
                }

                psflNew->pShimFix = psflInLua->pShimFix;

                //
                // Add this to the entry
                //
                psflNew->pNext      = pEntry->pFirstShim;
                pEntry->pFirstShim  = psflNew;
                
                //
                // Keep track of what lua shims we have added
                //
                if (pstrlShimsAdded) {
                    pstrlShimsAdded->AddString(psflInLua->pShimFix->strName);
                }
            }

            psflInLua = psflInLua->pNext;
        }
    }

    return TRUE;
}

INT_PTR
GetAppNameDlgOnInitDialog(
    IN  HWND hDlg
    )
/*++
    
    GetAppNameDlgOnInitDialog

	Desc:	The handler of WM_INITDIALOG for the first wizard page

	Params:
        IN  HWND hDlg: The first wizard page

	Return:
        TRUE
--*/
{
    HWND hwndParent = GetParent(hDlg);

    //
    // Center the wizard window with respect to the main app window
    //
    CenterWindow(GetParent(hwndParent), hwndParent);

    if (g_pCurrentWizard->m_bEditing 
        && (g_pCurrentWizard->m_Entry.pFirstFlag 
            || g_pCurrentWizard->m_Entry.pFirstLayer
            || g_pCurrentWizard->m_Entry.pFirstShim
            || g_pCurrentWizard->m_Entry.pFirstPatch)) {
        //
        // Edit an application fix. Some fixes already exist.
        //
        SetWindowText(hwndParent, CSTRING(IDS_WIZ_EDITFIX));
    } else if (g_pCurrentWizard->m_bEditing) {

        //
        // There are no fixes but still we are editting. This means the entry contains 
        // an apphelp. We have to "add" a fix
        //
        SetWindowText(hwndParent, CSTRING(IDS_WIZ_ADDFIX));
    } else {

        //
        // Create a new fix
        //
        SetWindowText(hwndParent, CSTRING(IDS_WIZ_CREATEFIX));
    }

    SendMessage(GetDlgItem(hDlg, IDC_NAME), EM_LIMITTEXT, (WPARAM)LIMIT_APP_NAME, (LPARAM)0);
    SendMessage(GetDlgItem(hDlg, IDC_VENDOR), EM_LIMITTEXT, (WPARAM)LIMIT_APP_NAME, (LPARAM)0);
    SendMessage(GetDlgItem(hDlg, IDC_EXEPATH), EM_LIMITTEXT, (WPARAM)MAX_PATH-1, (LPARAM)0);

    SHAutoComplete(GetDlgItem(hDlg, IDC_EXEPATH), AUTOCOMPLETE);

    if (g_pCurrentWizard->m_bEditing) {

        //
        // Make the App. text field and the exe name read only
        //
        SendMessage(GetDlgItem(hDlg, IDC_NAME),
                    EM_SETREADONLY,
                    TRUE,
                    0);

        SendMessage(GetDlgItem(hDlg, IDC_EXEPATH),
                    EM_SETREADONLY,
                    TRUE,
                    0);

        ENABLEWINDOW(GetDlgItem(hDlg, IDC_BROWSE), FALSE);

    }

    if (0 == g_pCurrentWizard->m_Entry.strAppName.Length()) {
        g_pCurrentWizard->m_Entry.strAppName = GetString(IDS_DEFAULT_APP_NAME);
    }

    SetDlgItemText(hDlg, IDC_NAME, g_pCurrentWizard->m_Entry.strAppName);

    if (g_pCurrentWizard->m_Entry.strVendor.Length() == 0) {
        g_pCurrentWizard->m_Entry.strVendor = GetString(IDS_DEFAULT_VENDOR_NAME);
    }   

    SetDlgItemText(hDlg, IDC_VENDOR, g_pCurrentWizard->m_Entry.strVendor);

    if (g_pCurrentWizard->m_bEditing) {
        SetDlgItemText(hDlg, IDC_EXEPATH, g_pCurrentWizard->m_Entry.strExeName);
    }

    SendMessage(GetDlgItem(hDlg, IDC_NAME), EM_SETSEL, 0,-1);

    //
    // Force proper Next button state.
    //
    SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_NAME, EN_CHANGE), 0);

    return TRUE;
}

INT_PTR
GetAppNameDlgOnNotifyOnFinish_Next(
    IN  HWND hDlg
    )
/*++
    GetAppNameDlgOnNotifyOnFinish_Next
    
    Desc:   Handles the pressing of the next or the finish button in the first page of the wizard
    
    Params:
        IN  HWND hDlg:  The first page of the wizard
        
    Return:
        -1: Do not allow to comlete finish or navigate away from this page
            There was some error (No shims, flags or layers have been selected) 
        0:  Otherwise 
        
--*/
{

    TCHAR   szTemp[MAX_PATH];
    INT_PTR ipReturn = 0;
    CSTRING strTemp;

    GetDlgItemText(hDlg, IDC_NAME, szTemp, ARRAYSIZE(szTemp));

    CSTRING::Trim(szTemp);

    if (!IsValidAppName(szTemp)) {
        //
        // The app name contains invalid chars
        //
        DisplayInvalidAppNameMessage(hDlg);


        SetFocus(GetDlgItem(hDlg, IDC_NAME));
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT,-1);
        ipReturn = -1;
        goto End;
    }   

    g_pCurrentWizard->m_Entry.strAppName = szTemp;

    GetDlgItemText(hDlg, IDC_EXEPATH, szTemp, MAX_PATH);

    strTemp = szTemp;

    CSTRING::Trim(szTemp);

    //
    // Set the exe name and the long file name
    //
    if (!g_pCurrentWizard->m_bEditing) {

        //
        // Test if the file exists
        //
        HANDLE hFile = CreateFile(szTemp,
                                  0,
                                  0,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

        if (INVALID_HANDLE_VALUE == hFile) {
            //
            // The file name could not be located
            //
            MessageBox(hDlg,
                       GetString(IDS_INVALIDEXE),
                       g_szAppName,
                       MB_ICONWARNING);

            //
            // We do not allow to go to the next page
            //
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT,-1);
            ipReturn = -1;
            goto End;
        }

        CloseHandle(hFile);

        //
        // Set the full path
        //
        g_pCurrentWizard->m_Entry.strFullpath = szTemp;
        g_pCurrentWizard->m_Entry.strFullpath.ConvertToLongFileName();

        //
        // Set the default mask for the matching attributes to be used
        //
        g_pCurrentWizard->dwMaskOfMainEntry = DEFAULT_MASK;

        //
        // Set the exe name that will be written in the xml
        //
        SafeCpyN(szTemp, (LPCTSTR)g_pCurrentWizard->m_Entry.strFullpath, ARRAYSIZE(szTemp));
        PathStripPath(szTemp);
        g_pCurrentWizard->m_Entry.strExeName= szTemp;

    } else if (g_pCurrentWizard->m_Entry.strFullpath.Length() == 0) {

        //
        // This SDB was loaded from the disk
        //
        g_pCurrentWizard->m_Entry.strFullpath = szTemp;
    }

    //
    // Set the vendor information
    //
    GetDlgItemText(hDlg, IDC_VENDOR, szTemp, ARRAYSIZE(szTemp));

    if (CSTRING::Trim(szTemp)) {
        g_pCurrentWizard->m_Entry.strVendor = szTemp;
    } else {
        g_pCurrentWizard->m_Entry.strVendor = GetString(IDS_DEFAULT_VENDOR_NAME);
    }

End:
    
    return ipReturn;
}


INT_PTR
GetAppNameDlgOnNotify(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++
    
    GetAppNameDlgOnNotify

	Desc:	The handler of WM_NOTIFY for the first wizard page

	Params:
        IN  HWND hDlg:      The first wizard page
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY    

	Return: Please see the return types for the notification messages
            Handler for PSN_* messages return -1 if the message should not be accepted
            and 0 if the message has been handled properly
            For other notification messages we return TRUE if we processed the message, FALSE otherwise
--*/
{

    NMHDR*  pHdr        = (NMHDR*)lParam;
    INT_PTR ipReturn    = FALSE;

    if (pHdr == NULL) {
        return FALSE;
    }

    switch (pHdr->code) {
    case PSN_SETACTIVE:

        SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_NAME, EN_CHANGE), 0);
        ipReturn = 0;
        break;

    case PSN_WIZFINISH:
    case PSN_WIZNEXT:

        ipReturn = GetAppNameDlgOnNotifyOnFinish_Next(hDlg);
        break;

    default: ipReturn = 0;

    }

    return ipReturn;
}

INT_PTR
GetAppNameDlgOnCommand(
    IN  HWND    hDlg,
    IN  WPARAM  wParam
    )
/*++
    
    GetAppNameDlgOnCommand

	Desc:	The handler of WM_COMMAND for the first wizard page

	Params:
        IN  HWND    hDlg:   The first wizard page
        IN  WPARAM  wParam: The wParam that comes with WM_COMMAND

	Return:
        TRUE:   We processed the message
        FALSE:  Otherwise
--*/

{
    INT_PTR ipReturn = TRUE;

    switch (LOWORD(wParam)) {
    case IDC_VENDOR:
    case IDC_NAME:
    case IDC_EXEPATH:

        if (EN_CHANGE == HIWORD(wParam)) {

            TCHAR   szText[MAX_PATH_BUFFSIZE];
            DWORD   dwFlags;
            BOOL    bEnable;

            *szText = 0;

            GetWindowText(GetDlgItem(hDlg, IDC_NAME), szText, ARRAYSIZE(szText));

            bEnable = ValidInput(szText);

            GetWindowText(GetDlgItem(hDlg, IDC_EXEPATH), szText, MAX_PATH);
            bEnable &= ValidInput(szText);

            dwFlags  =  0;

            if (bEnable) {

                dwFlags |= PSWIZB_NEXT;

                if (g_pCurrentWizard->m_bEditing) {
                    dwFlags |= PSWIZB_FINISH;
                }

            } else {

                if (g_pCurrentWizard->m_bEditing) {
                    dwFlags |= PSWIZB_DISABLEDFINISH;
                }
            }

            SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, dwFlags);
        }

        break;
        
    case IDC_BROWSE:
        {
            CSTRING szFilename;

            HWND    hwndFocus       = GetFocus();
            TCHAR   szBuffer[512]   = TEXT("");

            GetString(IDS_EXEFILTER, szBuffer, ARRAYSIZE(szBuffer));

            if (GetFileName(hDlg,
                            CSTRING(IDS_FINDEXECUTABLE),
                            szBuffer,
                            TEXT(""),
                            GetString(IDS_EXE_EXT),
                            OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
                            TRUE,
                            szFilename)) {

                SetDlgItemText(hDlg, IDC_EXEPATH, szFilename);
                
                //
                // Force proper Next button state.
                //
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_EXEPATH, EN_CHANGE), 0);
            }

            SetFocus(hwndFocus);
            break;
        }

    default: ipReturn = FALSE;

    }

    return ipReturn;
}
    
INT_PTR
SelectLayerDlgOnInitDialog(
    IN  HWND hDlg
    )
/*++
    
    SelectLayerDlgOnInitDialog

	Desc:	The handler of WM_INITDIALOG for the second wizard page

	Params:
        IN  HWND hDlg: The second wizard page

	Return:
        TRUE:   Message Handled
        FALSE:  There was some error. (Memory could not be allocated)
--*/
{
    
    HWND hwndRadio;

    //
    // If we are creating a new fix then we choose WIN 95 layer by default
    //
    if (g_pCurrentWizard->m_bEditing == FALSE) {
        hwndRadio = GetDlgItem(hDlg, IDC_RADIO_95);
    } else {
        hwndRadio = GetDlgItem(hDlg, IDC_RADIO_NONE);
    }

    SendMessage(hwndRadio, BM_SETCHECK, BST_CHECKED, 0);

    s_hwndLayerList = GetDlgItem(hDlg, IDC_LAYERLIST);

    ListView_SetImageList(s_hwndLayerList, g_hImageList, LVSIL_SMALL);

    ListView_SetExtendedListViewStyleEx(s_hwndLayerList,
                                        0,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP |  LVS_EX_CHECKBOXES);
    //
    // Add the Sytem Layers.
    //
    InsertColumnIntoListView(s_hwndLayerList, 0, 0, 100);

    LVITEM lvi;

    lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvi.iSubItem  = 0;
    lvi.iImage    = IMAGE_LAYERS;

    UINT uCount   = 0;

    PLAYER_FIX plf = GlobalDataBase.pLayerFixes;

    while (plf) {

        if (!IsOsLayer(plf->strName)) {

            PLAYER_FIX_LIST plfl = new LAYER_FIX_LIST;

            if (plfl == NULL) {
                MEM_ERR;
                return FALSE;
            }

            plfl->pLayerFix      = plf;

            lvi.pszText   = plf->strName;
            lvi.iItem     = uCount;
            lvi.lParam    = (LPARAM)plfl;

            INT iIndex  = ListView_InsertItem(s_hwndLayerList, &lvi);

            if (g_pCurrentWizard->m_bEditing) {

                PLAYER_FIX_LIST plflExists = NULL;

                if (LayerPresent (plf, &g_pCurrentWizard->m_Entry, &plflExists)) {

                    assert(plflExists);

                    ListView_SetCheckState(s_hwndLayerList, iIndex, TRUE);
                }
            }

            uCount++;

        } else if (g_pCurrentWizard->m_bEditing) {

            if (LayerPresent (plf, &g_pCurrentWizard->m_Entry, NULL)) {

                //
                // Set the correct Radio Button
                //
                INT id = 0;


                //
                // DeSelect All
                //
                CheckDlgButton(hDlg, IDC_RADIO_95, BST_UNCHECKED);
                CheckDlgButton(hDlg, IDC_RADIO_NT, BST_UNCHECKED);
                CheckDlgButton(hDlg, IDC_RADIO_98, BST_UNCHECKED);
                CheckDlgButton(hDlg, IDC_RADIO_2K, BST_UNCHECKED);
                CheckDlgButton(hDlg, IDC_RADIO_NONE, BST_UNCHECKED);


                if (lstrcmpi(plf->strName, s_arszOsLayers[0]) == 0) {

                    id = IDC_RADIO_95;

                } else if (lstrcmpi(plf->strName, s_arszOsLayers[1]) == 0) {

                    id = IDC_RADIO_NT;

                } else if (lstrcmpi(plf->strName, s_arszOsLayers[2]) == 0) {

                    id = IDC_RADIO_98;

                } else if (lstrcmpi(plf->strName, s_arszOsLayers[3]) == 0) {

                    id = IDC_RADIO_2K;

                }

                CheckDlgButton(hDlg, id, BST_CHECKED);
            }
        }

        plf = plf->pNext;
    }

    //
    // Add the Custom Layers
    //
    plf = (g_pCurrentWizard->m_pDatabase->type == DATABASE_TYPE_WORKING) ? 
          g_pCurrentWizard->m_pDatabase->pLayerFixes : NULL;

    while (plf) {

        PLAYER_FIX_LIST  plfl = new LAYER_FIX_LIST;

        if (plfl == NULL) {
            MEM_ERR;
            return FALSE;
        }

        plfl->pLayerFix = plf;

        lvi.pszText   = plf->strName;
        lvi.iItem     = uCount;
        lvi.lParam    = (LPARAM)plfl;

        INT iIndex = ListView_InsertItem(s_hwndLayerList, &lvi);

        PLAYER_FIX_LIST plflExists = NULL;

        if (g_pCurrentWizard->m_bEditing && LayerPresent(plf, 
                                                         &g_pCurrentWizard->m_Entry, 
                                                         &plflExists)) {

            assert(plflExists);
            ListView_SetCheckState(s_hwndLayerList, iIndex, TRUE);
        }

        uCount++;

        plf = plf->pNext;
    }

    return TRUE;
}

INT_PTR
SelectLayerDlgOnDestroy(
    void
    )
/*++
    
    SelectLayerDlgOnDestroy

	Desc:	The handler of WM_DESTROY for the second wizard page
            The list view of this page contains pointers to LAYER_FIX_LIST objects
            and these have to be freed here

	Params:
        IN  HWND hDlg: The second wizard page

	Return:
        TRUE
--*/
{
    UINT uCount = ListView_GetItemCount(s_hwndLayerList);

    for (UINT uIndex = 0; uIndex < uCount; ++uIndex) {

        LVITEM  Item;

        Item.mask     = LVIF_PARAM;
        Item.iItem    = uIndex;
        Item.iSubItem = 0;               

        if (!ListView_GetItem(s_hwndLayerList, &Item)) {
            assert(FALSE);
            continue;
        }

        TYPE type = ((PDS_TYPE)Item.lParam)->type ;

        if (type == FIX_LIST_LAYER) {
            delete ((PLAYER_FIX_LIST)Item.lParam);
        } else {
            assert(FALSE);
        }
    }

    return TRUE;
}

void
DoLayersTestRun(
    IN  HWND hDlg
    )
/*++
    DoLayersTestRun
    
    Desc:   Does the test run when we are on the layers page
    
    Params:
        IN  HWND hDlg: The layer page in the wizard
    
    Return:
        void
--*/
{
    CSTRINGLIST     strlAddedLuaShims;
    PSHIM_FIX_LIST  psfl                = NULL;
    PSHIM_FIX_LIST  psflNext            = NULL;
    PSHIM_FIX_LIST  psflPrev            = NULL;
    INT             iCountAddedLuaShims = 0;

    if (g_bAdmin == FALSE) {
    
        //
        // Test run will need to call sdbinst.exe which will not run if we are
        // not an admin
        //
        MessageBox(hDlg, 
                   GetString(IDS_ERRORNOTADMIN), 
                   g_szAppName, 
                   MB_ICONINFORMATION);
        goto End;
    
    }
    
    if (!HandleLayersNext(hDlg, TRUE, &strlAddedLuaShims)) {
        //
        // There were no layers, shims, patches for this entry 
        //
        MessageBox(hDlg, CSTRING(IDS_SELECTFIX), g_szAppName, MB_ICONWARNING);
        goto End;
    }
    
    //
    // Invoke test run dialog. Please make sure that this function does not return till the
    // app has finished executing.
    //
    TestRun(&g_pCurrentWizard->m_Entry,
            &g_pCurrentWizard->m_Entry.strFullpath,
            NULL, 
            hDlg);

    //
    // <HACK>This is a hack!!!. TestRun launches a process using CreateProcess
    // and then the modal wizard starts behaving like a modeless wizard
    //
    ENABLEWINDOW(g_hDlg, FALSE);
    
    //
    // Now test run is over. So we should now check if we had to add any lua shims 
    // and if yes, we must remove those shims
    //   
    for (PSTRLIST    pslist  = strlAddedLuaShims.m_pHead;
         pslist != NULL;
         pslist = pslist->pNext) {
    
        psfl        = g_pCurrentWizard->m_Entry.pFirstShim;
        psflPrev    = NULL;
    
        //
        // For all the shims that are in the entry, check if it is 
        // same as the one in pslist, if yes remove it
        //
        while (psfl) {
    
            if (psfl->pShimFix->strName == pslist->szStr) {
    
                //
                // Found. We have to remove this shim list from this entry
                //
                if (psflPrev == NULL) {
                    g_pCurrentWizard->m_Entry.pFirstShim = psfl->pNext;
                } else {
                    psflPrev->pNext = psfl->pNext;
                }
    
                delete psfl;
                break;
    
            } else {
                //
                // Keep looking
                //
                psflPrev = psfl;
                psfl = psfl->pNext;
            }
        }
    }
    
End:

    SetActiveWindow(hDlg);
    SetFocus(hDlg);

}

INT_PTR
SelectLayerDlgOnCommand(
    IN  HWND    hDlg,
    IN  WPARAM  wParam
    )
/*++
    
    SelectLayerDlgOnCommand

	Desc:	The handler of WM_COMMAND for the second wizard page

	Params:
        IN  HWND    hDlg:   The second wizard page
        IN  WPARAM  wParam: The wParam that comes with WM_COMMAND

	Return:
        TRUE:   We processed the message
        FALSE:  Otherwise
--*/
{   
    INT_PTR         ipReturn            = TRUE;

    switch (LOWORD(wParam)) {
    case IDC_TESTRUN:

        DoLayersTestRun(hDlg);
        break;

    default: ipReturn = FALSE;

    }

    return ipReturn;
}
  
INT_PTR
SelectLayerDlgOnNotify(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++
    
    SelectLayerDlgOnNotify

	Desc:	The handler of WM_NOTIFY for the second wizard page

	Params:
        IN  HWND hDlg:      The second wizard page
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY    

	Return: Please see the return types for the notification messages
            Handler for PSN_* messages return -1 if the message should not be accepted
            and 0 if the message has been handled properly
            For other notification messages we return TRUE if we processed the message, 
            FALSE otherwise
--*/
{
   NMHDR*   pHdr      = (NMHDR*)lParam;
   LPARAM   buttons   = 0;
   INT_PTR  ipRet     = 0;  

    if (pHdr->hwndFrom == s_hwndLayerList) {
        return HandleLayerListNotification(hDlg, lParam);
    }

    switch (pHdr->code) {
    case PSN_SETACTIVE:
        
        buttons = PSWIZB_BACK | PSWIZB_NEXT;

        SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);

        if (s_bLayerPageRefresh) {
            CheckLayers(hDlg);
        }

        s_bLayerPageRefresh = FALSE;
        ipRet = 0;

        break;

    case PSN_WIZFINISH:
        
        HandleLayersNext(hDlg, TRUE);

        if (g_pCurrentWizard->m_Entry.pFirstLayer == NULL 
            && g_pCurrentWizard->m_Entry.pFirstShim == NULL 
            && g_pCurrentWizard->m_Entry.pFirstFlag == NULL) {

            //
            // No fix has been selected
            //
            MessageBox(hDlg,
                       CSTRING(IDS_SELECTFIX),
                       g_szAppName,
                       MB_ICONWARNING);

            SetWindowLongPtr(hDlg, DWLP_MSGRESULT,-1);
            ipRet = -1;

        } else {  
            ipRet = 0;
        }

        break;
        

    case PSN_WIZNEXT:
        
        HandleLayersNext(hDlg, FALSE);

        g_bLayersChanged = TRUE;
        ipRet= 0;
        break;

    default: ipRet = FALSE;

    }

    return ipRet;
}

INT_PTR
SelectShimsDlgOnInitDialog(
    IN  HWND hDlg
    )
/*++
    
    SelectShimsDlgOnInitDialog

	Desc:	The handler of WM_INITDIALOG for the third wizard page

	Params:
        IN  HWND hDlg: The third wizard page

	Return:
        TRUE
--*/
{
    UINT    uCount  = 0;
    LPARAM  uTime   = 32767;

    s_bAllShown = TRUE;

    s_hwndShimList = GetDlgItem(hDlg, IDC_SHIMLIST); 

    ListView_SetImageList(GetDlgItem(hDlg, IDC_SHIMLIST), g_hImageList, LVSIL_SMALL);

    ListView_SetExtendedListViewStyleEx(s_hwndShimList,
                                        0,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP |  LVS_EX_CHECKBOXES); 

    //
    // Add the columns
    //
    InsertColumnIntoListView(s_hwndShimList, 
                             CSTRING(IDS_COL_FIXNAME), 
                             0, 
                             g_bExpert ? 50 : 100);

    if (g_bExpert) {
        InsertColumnIntoListView(s_hwndShimList, CSTRING(IDS_COL_CMDLINE), 1, 30);
        InsertColumnIntoListView(s_hwndShimList, CSTRING(IDS_COL_MODULE),   2, 20);
    } else {
        ShowWindow(GetDlgItem(hDlg, IDC_PARAMS), SW_HIDE);
    }

    ShowItems(hDlg);

    SetTimer(hDlg, 0, 100, NULL);

    s_hwndToolTipList = ListView_GetToolTips(s_hwndShimList);

    SendMessage(s_hwndToolTipList, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAKELONG(uTime, 0));
    SendMessage(s_hwndToolTipList, TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM)0);
    SendMessage(s_hwndToolTipList, TTM_SETMAXTIPWIDTH, 0, 100);

    return TRUE;
}

void
DoShimTestRun(
    IN  HWND hDlg
    )
/*++
    DoShimTestRun
    
    Desc:   Does the test run when we are on the shims page
    
    Params:
        IN  HWND hDlg: The shim page in the wizard
    
    Return:
        void
--*/
{
    PSHIM_FIX_LIST psflInEntry = NULL;

    if (g_bAdmin == FALSE) {
        //
        // Only admins can do a test run because we need to call sdbinst.exe, which 
        // can run only in admin mode
        //
        MessageBox(hDlg, 
                   GetString(IDS_ERRORNOTADMIN), 
                   g_szAppName, 
                   MB_ICONINFORMATION);
        goto End;
    }

    //
    // We need to save the shims that have been applied to the entry
    // before we do a test run. Because we add the shims to the entry during test run,
    // when we will end doing test run we will wish to revert to the shims that were 
    // present in the entry. Otherwise if the user clears some of the shims and goes
    // to the layers page then we will still have the shims applied to the entry
    //
    if (g_pCurrentWizard->m_Entry.pFirstShim) {
        //
        // Get the applied shims
        //
        CopyShimFixList(&psflInEntry, &g_pCurrentWizard->m_Entry.pFirstShim);
    }

    if (!HandleShimsNext(hDlg)) {
        //
        // No fixes have been selected
        //
        MessageBox(hDlg,
                   CSTRING(IDS_SELECTFIX),
                   g_szAppName,
                   MB_ICONWARNING);

        goto End;
    }

    TestRun(&g_pCurrentWizard->m_Entry,
            &g_pCurrentWizard->m_Entry.strFullpath,
            NULL, 
            hDlg);

    //
    // <HACK>This is a hack!!!. TestRun launches a process using CreateProcess
    // and then the modal wizard starts behaving like a modeless wizard
    //
    ENABLEWINDOW(g_hDlg, FALSE);

    SetActiveWindow(hDlg);
    SetFocus(hDlg);

    //
    // Revert to the shims that were actually applied before we did a test run
    //
    CopyShimFixList(&g_pCurrentWizard->m_Entry.pFirstShim, &psflInEntry);

End:
    if (psflInEntry) {
        //
        // Some shims were already applied to this entry (g_pCurrentWizard->m_Entry) 
        // and we psflInEntry has 
        // been populated with them, we must free this linked list as we no longer
        // need it
        //
        DeleteShimFixList(psflInEntry);
        psflInEntry = NULL;
    }
}
    
INT_PTR
SelectShimsDlgOnCommand(
    IN  HWND    hDlg,
    IN  WPARAM  wParam
    )
/*++
    
    SelectShimsDlgOnCommand

	Desc:	The handler of WM_COMMAND for the second wizard page

	Params:
        IN  HWND    hDlg:   The second wizard page
        IN  WPARAM  wParam: The wParam that comes with WM_COMMAND

	Return:
        TRUE:   We processed the message
        FALSE:  Otherwise
--*/
{   
    UINT    uCount      = ListView_GetItemCount(s_hwndShimList);
    INT_PTR ipReturn    = TRUE;

    switch (LOWORD(wParam)) {
    case IDC_CLEARALL:
        
        for (UINT uIndex = 0; uIndex < uCount; ++uIndex) {
            ListView_SetCheckState(s_hwndShimList, uIndex, FALSE);
        }

        SetTimer(hDlg, 0, 100, NULL);
        break;
                  
    case IDC_SHOW:
        {
            if (s_bAllShown) {
                //
                // Now show only the selected shims
                //
                ShowSelected(hDlg); 
            } else {
                //
                // Now show all the shims
                //
                ShowItems(hDlg);
            }

            //
            // Select the first item. We need to do this so that, we can disable
            // the params button if the shim is a part of a layer.
            //
            SetFocus(s_hwndShimList);
            ListView_SetSelectionMark(s_hwndShimList, 0);

            LVITEM lvi;

            lvi.mask        = LVIF_STATE;
            lvi.iItem       = 0;
            lvi.iSubItem    = 0;
            lvi.stateMask   = LVIS_FOCUSED | LVIS_SELECTED;
            lvi.state       = LVIS_FOCUSED | LVIS_SELECTED;

            ListView_SetItem(s_hwndShimList, &lvi);
            SetTimer(hDlg, 0, 100, NULL);

            break;  
        }
        
    case IDC_PARAMS:
        
        ShowParams(hDlg, GetDlgItem(hDlg, IDC_SHIMLIST));
        break;

    case IDC_TESTRUN:
        
        DoShimTestRun(hDlg);
        break;

    default: ipReturn = FALSE;
    }

    return ipReturn;
}

INT_PTR
SelectShimsDlgOnTimer(
    IN  HWND hDlg
    )
/*++
    SelectShimsDlgOnTimer
    
    Desc:   Handles the WM_TIMER Message and shows the count of all the shims that have 
            been selected
            
    Params:
        IN  HWND hDlg:  The shim selection page. This is the third wizard page
        
    Return: TRUE
    
--*/
{
    UINT        uTotal      = 0;
    UINT        uSelected   = 0;
    UINT        uCount      = 0;
    CSTRING     szText;
    DWORD       dwFlags;
    

    KillTimer(hDlg, 0);

    //
    // Count the selected shims
    //
    uCount = ListView_GetItemCount(s_hwndShimList);

    for (UINT uIndex = 0; uIndex < uCount; ++uIndex) {

        if (ListView_GetCheckState(s_hwndShimList, uIndex)) {
            ++uSelected;
        }
    }

    ENABLEWINDOW(GetDlgItem(hDlg, IDC_CLEARALL), 
                 uSelected == 0 ? FALSE : TRUE);

    szText.Sprintf(TEXT("%s %d of %d"), GetString(IDS_SELECTED), uSelected, uCount);

    SetWindowText(GetDlgItem(hDlg, IDC_STATUS),(LPCTSTR)szText);

    dwFlags = PSWIZB_BACK | PSWIZB_NEXT;

    if (0 == uSelected  && !g_pCurrentWizard->m_Entry.pFirstLayer) {
        dwFlags &= ~PSWIZB_NEXT;
    }

    SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, dwFlags);

    return TRUE;
}         


INT_PTR
SelectShimsDlgOnDestroy(
    void
    )
/*++
    
    SelectShimsDlgOnDestroy

	Desc:	The handler of WM_DESTROY for the third wizard page
            The list view of this page contains pointers to SHIM_FIX_LIST and 
            FLAG_FIX_LIST objects and these have to be freed here

	Params:
        IN  HWND hDlg: The third wizard page

	Return:
        TRUE
--*/
{

    UINT    uCount = ListView_GetItemCount(s_hwndShimList);
    TYPE    type;
    LVITEM  Item;

    for (UINT uIndex = 0; uIndex < uCount; ++uIndex) {

        Item.mask     = LVIF_PARAM;
        Item.iItem    = uIndex;
        Item.iSubItem = 0;               

        if (!ListView_GetItem(s_hwndShimList, &Item)) {
            assert(FALSE);
            continue;
        }

        type = ((PDS_TYPE)Item.lParam)->type ;

        if (type == FIX_LIST_SHIM) {
            DeleteShimFixList((PSHIM_FIX_LIST)Item.lParam);
        } else if (type == FIX_LIST_FLAG) {
            DeleteFlagFixList((PFLAG_FIX_LIST)Item.lParam);
        }
    }

    return TRUE;
}

INT_PTR
SelectShimsDlgOnNotifyFinish_Next(
    IN  HWND hDlg
    )
/*++
    SelectShimsDlgOnNotifyFinish_Next
    
    Desc: Handles the pressing of the next or finish button in the shim page
    
    Params:
        IN  HWND hdlg: The shim page in the wizard
        
    Return:
        -1: Do not allow to comlete finish or navigate away from this page
            There was some error (No shims, flags or layers have been selected) 
        0:  Otherwise    
--*/
{
    INT ipReturn = 0;

    HandleShimsNext(hDlg);

    if (g_pCurrentWizard->m_Entry.pFirstLayer   == NULL && 
        g_pCurrentWizard->m_Entry.pFirstShim    == NULL && 
        g_pCurrentWizard->m_Entry.pFirstFlag    == NULL) {
        //
        // No shim, flags or layers have been selected
        //
        MessageBox(hDlg,
                   CSTRING(IDS_SELECTFIX),
                   g_szAppName,
                   MB_ICONWARNING);

        SetWindowLongPtr(hDlg, DWLP_MSGRESULT,-1);
        ipReturn = -1;
        goto End;

    } else {
        ipReturn = 0;
    }

End:
    
    return ipReturn;
}

INT_PTR
SelectShimsDlgOnNotifyOnSetActive(
    IN  HWND hDlg
    )
/*++
    SelectShimsDlgOnNotifyOnSetActive
    
    Desc:   Handles the PSN_SETACTIVE notification in the shim page. Sets the focus 
            to the list view and selects the first item in that.
    
    Params:
        IN  HWND hdlg: The shim page in the wizard
        
    Return:
        0
--*/
{
    INT_PTR ipReturn = 0;

    //
    // If we are coming from the layers page, then we might need to again refresh
    // the list of shims, as it is possible that some of them might have been in the
    // layers chosen. (Some might get removed as well, because the layer was de-selected)
    //
    if (g_bLayersChanged) {

        SetCursor(LoadCursor(NULL, IDC_WAIT));
        ShowItems(hDlg);
        SetTimer(hDlg, 0, 100, NULL);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }

    LPARAM buttons = PSWIZB_BACK | PSWIZB_NEXT;
    SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);
    
    //
    // Select the first item. We need to do this so that, we can disable
    // the params button if the shim is a part of a layer.
    //
    SetFocus(s_hwndShimList);

    ListView_SetSelectionMark(s_hwndShimList, 0);

    LVITEM lvi;

    lvi.mask        = LVIF_STATE;
    lvi.iItem       = 0;
    lvi.iSubItem    = 0;
    lvi.stateMask   = LVIS_FOCUSED | LVIS_SELECTED;
    lvi.state       = LVIS_FOCUSED | LVIS_SELECTED;

    ListView_SetItem(s_hwndShimList, &lvi);

    return ipReturn;
}

INT_PTR
SelectShimsDlgOnNotifyOnClick(
    IN  HWND hDlg
    )
/*++
    SelectShimsDlgOnNotifyOnClick
    
    Desc:   Handles the NM_CLICK notification in the shim page. This actually changes
            the state of the check box in in the shim list view
    
    Params:
        IN  HWND hdlg: The shim page in the wizard
        
    Return:
        TRUE
--*/
{
    INT_PTR ipReturn = TRUE;

    LVHITTESTINFO lvhti;

    GetCursorPos(&lvhti.pt);
    ScreenToClient(s_hwndShimList, &lvhti.pt);

    ListView_HitTest(s_hwndShimList, &lvhti);

    //
    // If the check box state has changed,
    // toggle the selection. 
    //
    if (lvhti.flags & LVHT_ONITEMSTATEICON) {

        INT iPos = ListView_GetSelectionMark(s_hwndShimList);

        if (iPos != -1) {
            //
            // De-select it.
            //
            ListView_SetItemState(s_hwndShimList,
                                  iPos,
                                  0,
                                  LVIS_FOCUSED | LVIS_SELECTED);
        }
    }

    ListView_SetItemState(s_hwndShimList,
                          lvhti.iItem,
                          LVIS_FOCUSED | LVIS_SELECTED,
                          LVIS_FOCUSED | LVIS_SELECTED);

    ListView_SetSelectionMark(s_hwndShimList, lvhti.iItem);

    SetTimer(hDlg, 0, 100, NULL);

    if (ListView_GetSelectedCount(s_hwndShimList) == 0) {
        ENABLEWINDOW(GetDlgItem(hDlg, IDC_PARAMS), FALSE);
    }

    ipReturn = TRUE;

    return ipReturn;
}

INT_PTR
SelectShimsDlgOnNotifyOnLVItemChanged(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++
    SelectShimsDlgOnNotifyOnLVItemChanged
    
    Desc:   Handles the LVN_ITEMCHANGED notification in the shim page. We handle
            this mesage so that we can enable disable the 'Parameters'button that 
            is visible when we are in expert mode
    
    Params:
        IN  HWND    hdlg:   The shim page in the wizard
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY. This is typecasted
            to a LPNMLISTVIEW.
        
    Return:
        TRUE
--*/
{   
    LPNMLISTVIEW    lpnmlv;
    INT_PTR         ipReturn = 0;

    if (s_hwndToolTipList) {
        SendMessage(s_hwndToolTipList, TTM_UPDATE, 0, 0);
    }

    lpnmlv = (LPNMLISTVIEW)lParam;

    if (lpnmlv && (lpnmlv->uChanged & LVIF_STATE)) {

        if (lpnmlv->uNewState & LVIS_SELECTED) {
            //
            // For Shims or flags that are part of layers we should not be 
            // able to customize the parameters.
            // We check if it is a part of a layer by checking the icon
            // If the icon type is IMAGE_SHIM then that  is not a part of a layer
            //
            LVITEM  lvi;

            lvi.mask        = LVIF_IMAGE;
            lvi.iItem       = lpnmlv->iItem;
            lvi.iSubItem    = 0;

            if (ListView_GetItem(s_hwndShimList, &lvi)) {
                if (lvi.iImage == IMAGE_SHIM) {
                    ENABLEWINDOW(GetDlgItem(hDlg, IDC_PARAMS), TRUE);
                } else {
                    ENABLEWINDOW(GetDlgItem(hDlg, IDC_PARAMS), FALSE);
                }
            } else {
                assert(FALSE);
                ENABLEWINDOW(GetDlgItem(hDlg, IDC_PARAMS), FALSE);
            }
        }

        if ((lpnmlv->uChanged & LVIF_STATE) 
            && (((lpnmlv->uNewState ^ lpnmlv->uOldState) >> 12) != 0)
            && !ListView_GetCheckState(s_hwndShimList, lpnmlv->iItem)
            && g_bNowTest) {

            if (!HandleShimDeselect(hDlg, lpnmlv->iItem)) {
                ListView_SetCheckState(s_hwndShimList, lpnmlv->iItem, TRUE);
            }
        }
    }

    ipReturn = TRUE;

    return ipReturn;
}

INT_PTR
SelectShimsDlgOnNotifyOnLV_Tip(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++
    SelectShimsDlgOnNotifyOnLV_Tip
    
    Desc:   Handles the LVN_GETINFOTIP notification in the shim page. Generates the
            tool tip showing the description of the shim or flag
    
    Params:
        IN  HWND    hdlg:   The shim page in the wizard
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY. This is typecasted
            to a LPNMLVGETINFOTIP.
        
    Return:
        TRUE
--*/
{   
    LPNMLVGETINFOTIP    lpGetInfoTip    = (LPNMLVGETINFOTIP)lParam; 
    INT_PTR             ipReturn        = TRUE;
    TCHAR               szText[256];
    LVITEM              lvItem;
    CSTRING             strToolTip;

    *szText = 0;

    if (lpGetInfoTip) {
        //
        // Get the lParam and the text of the item.
        //
        lvItem.mask         = LVIF_PARAM | LVIF_TEXT;
        lvItem.iItem        = lpGetInfoTip->iItem;
        lvItem.iSubItem     = 0;
        lvItem.pszText      = szText;
        lvItem.cchTextMax   = ARRAYSIZE(szText);

        if (!ListView_GetItem(s_hwndShimList, &lvItem)) {
            assert(FALSE);
            goto End;
        }

        GetDescriptionString(lvItem.lParam, 
                             strToolTip, 
                             s_hwndToolTipList, 
                             lvItem.pszText, 
                             NULL, 
                             s_hwndShimList, 
                             lpGetInfoTip->iItem);

        if (strToolTip.Length() > 0) {

            SafeCpyN(lpGetInfoTip->pszText, 
                     strToolTip.pszString, 
                     lpGetInfoTip->cchTextMax);
        }
    }

End:

    ipReturn = TRUE;

    return ipReturn;
}

INT_PTR
SelectShimsDlgOnNotify(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++
    
    SelectShimsDlgOnNotify

	Desc:	The handler of WM_NOTIFY for the second wizard page

	Params:
        IN  HWND hDlg:      The second wizard page
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY    

	Return: Please see the return types for the notification messages
            Handler for PSN_* messages return -1 if the message should not be accepted
            and 0 if the message has been handled properly
            For other notification messages we return TRUE if we processed the message, 
            FALSE otherwise
--*/
{   
    NMHDR*  pHdr        = (NMHDR*)lParam;
    INT_PTR ipReturn    =  FALSE;

    switch (pHdr->code) {
    
    case PSN_WIZFINISH:
    case PSN_WIZNEXT:

        ipReturn = SelectShimsDlgOnNotifyFinish_Next(hDlg);
        g_bLayersChanged = FALSE;
        break;

    case PSN_SETACTIVE:

        ipReturn = SelectShimsDlgOnNotifyOnSetActive(hDlg);
        break;

    case NM_CLICK:

        ipReturn = SelectShimsDlgOnNotifyOnClick(hDlg);
        break; 

    case LVN_KEYDOWN:
        {
            LPNMLVKEYDOWN plvkd = (LPNMLVKEYDOWN)lParam ;

            if (plvkd->wVKey == VK_SPACE) {
                SetTimer(hDlg, 0, 100, NULL);
            }

            ipReturn = TRUE;
            break;
        }

    case LVN_ITEMCHANGED:

        ipReturn = SelectShimsDlgOnNotifyOnLVItemChanged(hDlg, lParam);
        break;

    case LVN_GETINFOTIP:

        ipReturn = SelectShimsDlgOnNotifyOnLV_Tip(hDlg, lParam);
        break;

    default:
        ipReturn = FALSE;
    }

    return ipReturn;
}

INT_PTR
SelectFilesDlgOnInitDialog(
    IN  HWND hDlg
    )
/*++
    
    SelectFilesDlgOnInitDialog

	Desc:	The handler of WM_INITDIALOG for the matching files wizard page.
            This page is shared both by the fix wizard and the app help wizard
            Also initializes s_hwndTree to the handle of the matching files tree

	Params:
        IN  HWND hDlg: The matching files wizard page

	Return:
        TRUE
--*/
{
    s_hwndTree =  GetDlgItem(hDlg, IDC_FILELIST);

    s_hMatchingFileImageList = ImageList_Create(16, 16, ILC_COLOR32 | ILC_MASK, 7, 1);
    ImageList_AddIcon(s_hMatchingFileImageList, 
                      LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_FILE)));

    ImageList_AddIcon(s_hMatchingFileImageList, 
                      LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ATTRIBUTE)));

    TreeView_SetImageList(s_hwndTree, s_hMatchingFileImageList, TVSIL_NORMAL);

    HIMAGELIST hImage = ImageList_LoadImage(g_hInstance,
                                            MAKEINTRESOURCE(IDB_CHECK),
                                            16,
                                            0,
                                            CLR_DEFAULT,
                                            IMAGE_BITMAP,
                                            LR_LOADTRANSPARENT);

    if (hImage != NULL) {

        TreeView_SetImageList(s_hwndTree, 
                              hImage, 
                              TVSIL_STATE);
    }

    PostMessage(hDlg, WM_USER_MATCHINGTREE_REFRESH, 0, 0);

    //
    // The "Show all attributes" button should be visible only if we are
    // in editing mode
    //
    ShowWindow(GetDlgItem(hDlg, IDC_SHOWALLATTR), 
               (g_pCurrentWizard->m_bEditing) ? SW_SHOW : SW_HIDE);

    return TRUE;
}

INT_PTR
CheckLUADlgOnNotifyOnFinish(
    IN  HWND hDlg
    )
/*++
    CheckLUADlgOnNotifyOnFinish
    
    Desc:   Handles the pressing of the finish button in the fifth page of the wizard
    
    Params:
        IN  HWND hDlg:  The fifth page of the wizard
        
    Return:
        -1: Do not allow to comlete finish or navigate away from this page
        0:  Otherwise 
        
--*/
{
    INT_PTR ipReturn = 0;

    if (IsDlgButtonChecked(hDlg, IDC_FIXWIZ_CHECKLUA_YES) == BST_CHECKED) {
        g_bShouldStartLUAWizard = TRUE;
    }
    
    return ipReturn;
}

INT_PTR
CheckLUADlgOnNotify(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++
    
    CheckLUADlgOnNotify

	Desc:	The handler of WM_NOTIFY for the fifth wizard page

	Params:
        IN  HWND hDlg:      The fifth wizard page
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY    

	Return: Please see the return types for the notification messages
            Handler for PSN_* messages return -1 if the message should not be accepted
            and 0 if the message has been handled properly
            For other notification messages we return TRUE if we processed the message, FALSE otherwise
--*/
{
    NMHDR*  pHdr        = (NMHDR*)lParam;
    INT_PTR ipReturn    = FALSE;

    if (pHdr == NULL) {
        return FALSE;
    }

    switch (pHdr->code) {
    case PSN_SETACTIVE:
        {
            LPARAM buttons = PSWIZB_BACK | PSWIZB_FINISH;

            SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);
            //
            // We processed the message and everything is OK. The value should be FALSE
            //
            ipReturn = 0;
        }
        break;

    case PSN_WIZFINISH:
        ipReturn = CheckLUADlgOnNotifyOnFinish(hDlg);
        break;

    default: ipReturn = 0;

    }

    return ipReturn;
}

INT_PTR
CALLBACK
CheckLUA(
    IN  HWND    hDlg, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++

    CheckLUA
    
	Desc:	Dialog proc for the last page of the wizard. 

	Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
    
--*/
{
    INT_PTR ipReturn = 0;

    switch (uMsg) {
    case WM_INITDIALOG:
        //
        // We want to set the default to Yes because we want the user to customize LUA now.
        //
        CheckDlgButton(hDlg, IDC_FIXWIZ_CHECKLUA_YES, BST_CHECKED);

        return TRUE;

    case WM_NOTIFY:
        
        CheckLUADlgOnNotify(hDlg, lParam);
        break;

    default: ipReturn = 0;

    }

    return ipReturn;
}

BOOL
AddCheckLUAPage(
    HWND hwndWizard
    )
{
    PROPSHEETPAGE PageCheckLUA;

    ZeroMemory(&PageCheckLUA, sizeof(PROPSHEETPAGE));

    PageCheckLUA.dwSize                = sizeof(PROPSHEETPAGE);
    PageCheckLUA.dwFlags               = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    PageCheckLUA.hInstance             = g_hInstance;
    PageCheckLUA.pszTemplate           = MAKEINTRESOURCE(IDD_FIXWIZ_CHECKLUA);
    PageCheckLUA.pfnDlgProc            = CheckLUA;
    PageCheckLUA.pszHeaderTitle        = MAKEINTRESOURCE(IDS_CHECKLUA);
    PageCheckLUA.pszHeaderSubTitle     = MAKEINTRESOURCE(IDS_CHECKLUASUBHEADING);

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&PageCheckLUA);

    if (hPage == NULL) {
        return FALSE;
    } else {
        return PropSheet_AddPage(hwndWizard, hPage);
    }
}

INT_PTR
SelectFilesDlgOnNotify(
    IN  HWND    hDlg,
    IN  LPARAM  lParam
    )
/*++
    
    SelectFilesDlgOnNotify

	Desc:	The handler of WM_NOTIFY for the matching files wizard page

	Params:
        IN  HWND hDlg:      The matching files wizard page
        IN  LPARAM  lParam: The lParam that comes with WM_NOTIFY    

	Return: Please see the return types for the notification messages
            Handler for PSN_* messages return -1 if the message should not be accepted
            and 0 if the message has been handled properly
            For other notification messages we return TRUE if we processed the message, 
            FALSE otherwise
--*/
{
    NMHDR*  pHdr        = (NMHDR*)lParam;
    INT_PTR ipReturn    = FALSE;
    static  BOOL s_bIsLUARedirectFSPresent;

    if (pHdr->idFrom == IDC_FILELIST) {
        //
        // Messages for the matching files tree
        //
        return HandleAttributeTreeNotification(hDlg, lParam);
    }

    switch (pHdr->code) {
    case PSN_SETACTIVE:
        {
            SendMessage(hDlg, WM_USER_MATCHINGTREE_REFRESH, 0, 0);

            LPARAM buttons = PSWIZB_BACK;
            s_bIsLUARedirectFSPresent = FALSE;

            if (TYPE_APPHELPWIZARD == g_pCurrentWizard->m_uType) {
                buttons |= PSWIZB_NEXT;
            } else {
                
                //
                // Check if the user has selected either the LUA layer or the LUARedirectFS 
                // shim; if so we need to ask if he wants to customize LUA settings now.
                //
                if (IsLUARedirectFSPresent(&g_pCurrentWizard->m_Entry)) {
                    buttons |= PSWIZB_NEXT;
                    s_bIsLUARedirectFSPresent = TRUE;
                } else {
                    buttons |= PSWIZB_FINISH;
                }
            }

            SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, buttons);
            //
            // We processed the message and everything is OK. The value should be FALSE
            //
            ipReturn = FALSE;
        }

        break;

    case PSN_WIZBACK:
        {

            CSTRING szFile = g_pCurrentWizard->m_Entry.strFullpath;
            
            szFile.ShortFilename();
            SetMask(s_hwndTree);
            
            //
            // Remove the matching info for the current file if it exists. Otherwise,
            // it's possible that if the file is changed, we'll have bogus information
            // about it.
            //
            PMATCHINGFILE pWalk = g_pCurrentWizard->m_Entry.pFirstMatchingFile;
            PMATCHINGFILE pPrev = NULL;

            while (NULL != pWalk && !g_pCurrentWizard->m_bEditing) { // Only if not in editing mode
                
                if (pWalk->strMatchName == szFile || pWalk->strMatchName == TEXT("*")) {
                    //
                    // Remove this entry.
                    //
                    if (pWalk == g_pCurrentWizard->m_Entry.pFirstMatchingFile) {
                        g_pCurrentWizard->m_Entry.pFirstMatchingFile = g_pCurrentWizard->m_Entry.pFirstMatchingFile->pNext;
                    } else {
                        assert(pPrev);
                        pPrev->pNext = pWalk->pNext;
                    }

                    g_pCurrentWizard->dwMaskOfMainEntry = pWalk->dwMask;

                    delete (pWalk);
                    break;
                }

                pPrev = pWalk;
                pWalk = pWalk->pNext;
            }

            ipReturn = FALSE;
        }     

        break;
        
    case PSN_WIZFINISH:
    case PSN_WIZNEXT:
        {
            PMATCHINGFILE     pMatch = NULL;

            ipReturn = FALSE;
            //
            // Set the mask for all the matching files. 
            //
            SetMask(s_hwndTree);

            if (TYPE_APPHELPWIZARD == g_pCurrentWizard->m_uType) {
                ipReturn = TRUE;
                break;
            }

            if (s_bIsLUARedirectFSPresent) {
                ipReturn = !AddCheckLUAPage(pHdr->hwndFrom);
            }

            break;
        }
    }

    return ipReturn;
}

INT_PTR
SelectFilesDlgOnCommand(
    IN  HWND    hDlg,
    IN  WPARAM  wParam
    )
/*++
    
    SelectFilesDlgOnCommand

	Desc:	The handler of WM_COMMAND for the matching files wizard page

	Params:
        IN  HWND    hDlg:   The matching files wizard page
        IN  WPARAM  wParam: The wParam that comes with WM_COMMAND

	Return:
        TRUE:   We processed the message
        FALSE:  Otherwise
--*/
{
    INT_PTR ipReturn = TRUE;
    
    switch (LOWORD(wParam)) {
    case IDC_GENERATE:
        {
            HCURSOR hRestore;

            hRestore = SetCursor(LoadCursor(NULL, IDC_WAIT));

            //
            // Do the actual task of generating the matching files
            //
            g_pCurrentWizard->GrabMatchingInfo(hDlg);

            SetCursor(hRestore);

            break;
        }
                  
    case IDC_ADDFILES:
        {
            CSTRING szFilename;
            HWND    hwndFocus       = GetFocus();
            TCHAR   szBuffer[512]   = TEXT("");

            GetString(IDS_EXEALLFILTER, szBuffer, ARRAYSIZE(szBuffer));

            if (g_pCurrentWizard->CheckAndSetLongFilename(hDlg, IDS_GETPATH_ADD) == FALSE) {
                break;
            }

            if (GetFileName(hDlg,
                            CSTRING(IDS_FINDMATCHINGFILE),
                            szBuffer,
                            TEXT(""),
                            GetString(IDS_EXE_EXT),
                            OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
                            TRUE,
                            szFilename)) {

                szFilename.ConvertToLongFileName();

                CSTRING szCheck = szFilename;

                //
                // Is this on the same drive as the original file
                //
                if (szCheck.RelativeFile(g_pCurrentWizard->m_Entry.strFullpath) == FALSE) {
                    //
                    // The matching file is not on the same drive as the program
                    // file being fixed
                    //
                    MessageBox(hDlg, 
                               GetString(IDS_NOTSAMEDRIVE), 
                               g_szAppName, 
                               MB_ICONWARNING);
                    break;

                }

                HandleAddMatchingFile(hDlg, szFilename, szCheck);
            }

            SetFocus(hwndFocus);
        }

        break;

    case IDC_REMOVEALL:
        {
            PMATCHINGFILE   pMatch  = NULL;
            TVITEM          Item;
            HTREEITEM       hItem;
            HTREEITEM       hItemNext;

            g_pCurrentWizard->m_Entry.pFirstMatchingFile;
            
            SendMessage(s_hwndTree, WM_SETREDRAW, FALSE, 0);

            hItem = TreeView_GetChild(s_hwndTree, TVI_ROOT), hItemNext;

            while (hItem) {

                hItemNext = TreeView_GetNextSibling(s_hwndTree, hItem);

                Item.mask   = TVIF_PARAM;
                Item.hItem  = hItem;

                if (!TreeView_GetItem(s_hwndTree, &Item)) {
                    assert(FALSE);
                    goto Next;
                }
                
                pMatch = (PMATCHINGFILE)Item.lParam;

                if (pMatch == NULL) {
                    assert(FALSE);
                    Dbg(dlError, "SelectFilesDlgOnCommand", "pMatch == NULL");
                    break;
                }

                if (pMatch->strMatchName != TEXT("*")) {
                    //
                    // Must not delete the entry for the exe being fixed
                    //
                    TreeView_SelectItem(s_hwndTree, hItem);
                    SendMessage(hDlg, WM_COMMAND, IDC_REMOVEFILES, 0);
                }

            Next:
                hItem = hItemNext;
            }

            SendMessage(s_hwndTree, WM_SETREDRAW, TRUE, 0);
        }

        break;

    case IDC_REMOVEFILES:
        {   
            PMATCHINGFILE   pWalk;
            PMATCHINGFILE   pHold;
            PMATCHINGFILE   pMatch;
            HTREEITEM       hItem = TreeView_GetSelection(GetDlgItem(hDlg, IDC_FILELIST));
            TVITEM          Item;

            //
            // To be a matching file an item should be a root element,
            // otherwise it is an attribute
            //
            if (NULL != hItem && TreeView_GetParent(s_hwndTree, hItem) == NULL) {

                Item.mask   = TVIF_PARAM;
                Item.hItem  = hItem;

                if (!TreeView_GetItem(GetDlgItem(hDlg, IDC_FILELIST), &Item)) {
                    break;
                }
                
                pMatch = (PMATCHINGFILE)Item.lParam;

                assert(pMatch);

                if (pMatch->strMatchName == TEXT("*")) {
                    //
                    // This is the program file being fixed. This cannot be removed
                    //
                    MessageBox(hDlg,
                               CSTRING(IDS_REQUIREDFORMATCHING),
                               g_szAppName, 
                               MB_ICONINFORMATION);
                    break;
                }

                pWalk = g_pCurrentWizard->m_Entry.pFirstMatchingFile;

                //
                // NOTE: The lparam for the items in the tree should be to the corresponding PMATCHINGFILE
                //
                while (NULL != pWalk) {

                    if (pWalk == (PMATCHINGFILE)Item.lParam) {
                        break;
                    }

                    pHold = pWalk;
                    pWalk = pWalk->pNext;
                }


                if (pWalk == g_pCurrentWizard->m_Entry.pFirstMatchingFile) {
                    //
                    // Delete first matching file
                    //
                    g_pCurrentWizard->m_Entry.pFirstMatchingFile = pWalk->pNext;

                } else {
                    pHold->pNext = pWalk->pNext;
                }

                delete pWalk;

                TreeView_DeleteItem(s_hwndTree, hItem);

            } else {
                //
                // No matching file has been selected, need to select one for deletion
                //
                MessageBox(hDlg,
                            CSTRING(IDS_SELECTMATCHFIRST),
                            g_szAppName,
                            MB_ICONWARNING);
            }
        }

        break;

    case IDC_SELECTALL:
    case IDC_UNSELECTALL:
        {
            BOOL        bSelect = (LOWORD(wParam) == IDC_SELECTALL);
            HTREEITEM   hItem   = TreeView_GetSelection(s_hwndTree);
            HTREEITEM   hItemParent;

            if (hItem == NULL) {
                //
                // No matching file has been selected
                //
                MessageBox(hDlg,
                           CSTRING(IDS_SELECTMATCHFIRST),
                           g_szAppName,
                           MB_ICONWARNING);
                break;
            }

            hItemParent = TreeView_GetParent(s_hwndTree, hItem);

            if (hItemParent != NULL) {
                hItem = hItemParent;
            }

            hItemParent = hItem; // So that we can expand this one.

            //
            // Now for all the attributes of this matching file
            //
            hItem = TreeView_GetChild(s_hwndTree, hItem);

            while (hItem) {
                TreeView_SetCheckState(s_hwndTree, hItem, bSelect);
                hItem = TreeView_GetNextSibling(s_hwndTree, hItem);
            }

            TreeView_Expand(s_hwndTree, hItemParent, TVM_EXPAND);
        }

        break;

    case IDC_SHOWALLATTR:
        
        if (!g_pCurrentWizard->m_bEditing) {
            break;
        }

        //
        // Show all the attributes of all the files
        //
        HandleShowAllAtrr(hDlg);
        break;

    default:
        ipReturn =  FALSE;
    }

    return ipReturn;
}

INT_PTR
SelectFilesDlgOnMatchingTreeRefresh(
    IN  HWND hDlg
    )
/*++
    SelectFilesDlgOnMatchingTreeRefresh
    
    Desc:   Refreshes the matching tree
    
    Params:
        IN  HWND hDlg:  The matching files wizard page
        
    Return: 
        TRUE

--*/
{   
    PMATCHINGFILE pMatch    = g_pCurrentWizard->m_Entry.pFirstMatchingFile;
    BOOL bMainFound         = FALSE;

    SendMessage(s_hwndTree, WM_SETREDRAW, FALSE, 0);
    
    TreeView_DeleteAllItems(s_hwndTree);

    while (NULL != pMatch) {

        if (pMatch->strMatchName == TEXT("*")) {
            bMainFound = TRUE;
        }

        AddMatchingFileToTree(s_hwndTree, pMatch, FALSE);
        pMatch = pMatch->pNext;
    }

    if (bMainFound == FALSE) {
        //
        // The matching file for program being fixed is not there, let us add it
        //
        HandleAddMatchingFile(hDlg,
                              g_pCurrentWizard->m_Entry.strFullpath,
                              g_pCurrentWizard->m_Entry.strExeName,
                              g_pCurrentWizard->dwMaskOfMainEntry);
    }

    SendMessage(s_hwndTree, WM_SETREDRAW, TRUE, 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\dll\dll.c ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Dll.c

  Abstract:

    Used by the Demo Application to illustrate IgnoreFreeLibrary.

  Notes:

    ANSI only - must run on Win9x.

  History:

    03/09/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/
#include <windows.h>
#include "dll.h"

/*++

  Routine Description:

    Similiar to WinMain - entry point for the dll.

  Arguments:

    hModule     -       Handle to the DLL.
    fdwReason   -       The reason we were called.
    lpReserved  -       Indicates an implicit or explicit load.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
WINAPI 
DllMain(
    IN HANDLE hModule,
    IN DWORD  fdwReason,
    IN LPVOID lpReserved
    )
{
	switch (fdwReason) {   
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }
	
    return TRUE;
}

/*++

  Routine Description:

    Our exported sample function.

  Arguments:

    dwParam     -   Not used.

  Return Value:

    None.

--*/
void
WINAPI 
DemoAppExp(
    IN DWORD* dwParam
    )
{
    DWORD   dwLocal = 0;

    dwLocal = *dwParam;
}

/*++

  Routine Description:

    This function is exported so that the EXE can call it.
    In turn, the DLL will display a message box that will
    not be ignored unless the user utilizes the include/exclude
    functionality in QFixApp.

  Arguments:

    hWnd    -   Handle to the parent window.

  Return Value:

    None.

--*/
void 
WINAPI 
DemoAppMessageBox(
    IN HWND hWnd
    )
{
    MessageBox(hWnd,
               "This message box is displayed for the include/exclude test.",
               MAIN_APP_TITLE,
               MB_ICONINFORMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\sqldriver.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    SQLDriver.cpp

Abstract:

    Code for the core SQLEngine.
    
Author:

    kinshu created  Oct. 26, 2001
    
Algo:   From the sql string passed to the driver, we first of all create the show list
        (Statment::AttributeShowList), which is the list of attributes which are in 
        SELECT clause. We then create a prefix expression, from the prefix we create a 
        post fix and for every entry in the databases for which we wish to run the 
        query we see if the entry satsifies this postfix notation, if it does then we 
        make a result item(RESULT_ITEM) comprising of the entry and the database and 
        add this result item in the result set.
        
        Once we have obtained the result set, for every entry and database combination in the 
        result set we then obtain the values of the various attributes in the show list by 
        giving the database and the entry. A row is actually an array of PNODE type
        This will be a row of results.
        
        All operators of our SQL are binary
--*/

#include "precomp.h"

//////////////////////// Externs //////////////////////////////////////////////

extern BOOL             g_bMainAppExpanded;
extern CRITICAL_SECTION g_csInstalledList;

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Defines //////////////////////////////////////////////

//*******************************************************************************
#define CHECK_OPERAND_TYPE(bOk,End)                                             \
{                                                                               \
    if (pOperandLeft->dtType != pOperandRight->dtType) {                        \
                                uErrorCode = ERROR_OPERANDS_DONOTMATCH;         \
                                bOk = FALSE;                                    \
                                goto End;                                       \
    }                                                                           \
}
//*******************************************************************************                           


///////////////////////////////////////////////////////////////////////////////

//////////////////////// Global Variables /////////////////////////////////////

// All the attributes that can be in SELECT clause of SQL
struct _tagAttributeShowMapping AttributeShowMapping[] = {
    
    TEXT("APP_NAME"),               ATTR_S_APP_NAME,                IDS_ATTR_S_APP_NAME,            
    TEXT("PROGRAM_NAME"),           ATTR_S_ENTRY_EXEPATH,           IDS_ATTR_S_ENTRY_EXEPATH,       
    TEXT("PROGRAM_DISABLED"),       ATTR_S_ENTRY_DISABLED,          IDS_ATTR_S_ENTRY_DISABLED,      
    TEXT("PROGRAM_GUID"),           ATTR_S_ENTRY_GUID,              IDS_ATTR_S_ENTRY_GUID,          
    TEXT("PROGRAM_APPHELPTYPE"),    ATTR_S_ENTRY_APPHELPTYPE,       IDS_ATTR_S_ENTRY_APPHELPTYPE,   
    TEXT("PROGRAM_APPHELPUSED"),    ATTR_S_ENTRY_APPHELPUSED,       IDS_ATTR_S_ENTRY_APPHELPUSED,   
                                                                                            
    TEXT("FIX_COUNT"),              ATTR_S_ENTRY_SHIMFLAG_COUNT,    IDS_ATTR_S_ENTRY_SHIMFLAG_COUNT,
    TEXT("PATCH_COUNT"),            ATTR_S_ENTRY_PATCH_COUNT,       IDS_ATTR_S_ENTRY_PATCH_COUNT,   
    TEXT("MODE_COUNT"),             ATTR_S_ENTRY_LAYER_COUNT,       IDS_ATTR_S_ENTRY_LAYER_COUNT,   
    TEXT("MATCH_COUNT"),            ATTR_S_ENTRY_MATCH_COUNT,       IDS_ATTR_S_ENTRY_MATCH_COUNT,   
                                                                                                
    TEXT("DATABASE_NAME"),          ATTR_S_DATABASE_NAME,           IDS_ATTR_S_DATABASE_NAME,       
    TEXT("DATABASE_PATH"),          ATTR_S_DATABASE_PATH,           IDS_ATTR_S_DATABASE_PATH,       
    TEXT("DATABASE_INSTALLED"),     ATTR_S_DATABASE_INSTALLED,      IDS_ATTR_S_DATABASE_INSTALLED,  
    TEXT("DATABASE_GUID"),          ATTR_S_DATABASE_GUID,           IDS_ATTR_S_DATABASE_GUID,       
                                                                                                
    TEXT("FIX_NAME"),               ATTR_S_SHIM_NAME,               IDS_ATTR_S_SHIM_NAME,           
    TEXT("MATCHFILE_NAME"),         ATTR_S_MATCHFILE_NAME,          IDS_ATTR_S_MATCHFILE_NAME,      
    TEXT("MODE_NAME"),              ATTR_S_LAYER_NAME,              IDS_ATTR_S_LAYER_NAME,          
    TEXT("PATCH_NAME"),             ATTR_S_PATCH_NAME,              IDS_ATTR_S_PATCH_NAME           

};

// All the attributes that can be in WHERE clause of SQL
struct _tagAttributeMatchMapping AttributeMatchMapping[] = {

    TEXT("APP_NAME"),               ATTR_M_APP_NAME,
    TEXT("PROGRAM_NAME"),           ATTR_M_ENTRY_EXEPATH,
    TEXT("PROGRAM_DISABLED"),       ATTR_M_ENTRY_DISABLED,
    TEXT("PROGRAM_GUID"),           ATTR_M_ENTRY_GUID,
    TEXT("PROGRAM_APPHELPTYPE"),    ATTR_M_ENTRY_APPHELPTYPE,
    TEXT("PROGRAM_APPHELPUSED"),    ATTR_M_ENTRY_APPHELPUSED,

    TEXT("FIX_COUNT"),              ATTR_M_ENTRY_SHIMFLAG_COUNT,
    TEXT("PATCH_COUNT"),            ATTR_M_ENTRY_PATCH_COUNT,
    TEXT("MODE_COUNT"),             ATTR_M_ENTRY_LAYER_COUNT,
    TEXT("MATCH_COUNT"),            ATTR_M_ENTRY_MATCH_COUNT,
                                    
    TEXT("DATABASE_NAME"),          ATTR_M_DATABASE_NAME,      
    TEXT("DATABASE_PATH"),          ATTR_M_DATABASE_PATH,      
    TEXT("DATABASE_INSTALLED"),     ATTR_M_DATABASE_INSTALLED, 
    TEXT("DATABASE_GUID"),          ATTR_M_DATABASE_GUID,
                                    
    TEXT("FIX_NAME"),               ATTR_M_SHIM_NAME,           
    TEXT("MATCHFILE_NAME"),         ATTR_M_MATCHFILE_NAME,
    TEXT("MODE_NAME"),              ATTR_M_LAYER_NAME,
    TEXT("PATCH_NAME"),             ATTR_M_PATCH_NAME
};                                  

//
// Map the sql database names to the database types
// Check for references to DatabasesMapping before changing order
struct _tagDatabasesMapping DatabasesMapping[3] = {
    TEXT("SYSTEM_DB"),      DATABASE_TYPE_GLOBAL,
    TEXT("INSTALLED_DB"),   DATABASE_TYPE_INSTALLED,
    TEXT("CUSTOM_DB"),      DATABASE_TYPE_WORKING
};

// All our SQL operators
struct _tagOperatorMapping OperatorMapping[] = {

    TEXT(">"),              OPER_GT,        4,
    TEXT("<"),              OPER_LT,        4,
    TEXT(">="),             OPER_GE,        4,
    TEXT("<="),             OPER_LE,        4,

    TEXT("<>"),             OPER_NE,        4,
    TEXT("="),              OPER_EQUAL,     4,
    TEXT("CONTAINS"),       OPER_CONTAINS,  4,
    TEXT("HAS"),            OPER_HAS,       4,
                                  
    TEXT("OR"),             OPER_OR,        3,
    TEXT("AND"),            OPER_AND,       3
};

// The SQL constants
struct _tagConstants Constants[] = {

    TEXT("TRUE"),           DT_LITERAL_BOOL, 1,
    TEXT("FALSE"),          DT_LITERAL_BOOL, 0,
    TEXT("BLOCK"),          DT_LITERAL_INT,  APPTYPE_INC_HARDBLOCK,
    TEXT("NOBLOCK"),        DT_LITERAL_INT,  APPTYPE_INC_NOBLOCK

};

//////////////////////// Function Declarations ////////////////////////////////

///////////////////////////////////////////////////////////////////////////////

void
Statement::SetWindow(
    IN  HWND hWnd
    )
/*++
    Statement::SetWindow
    
    Desc:   Associates a window with the Statement. This will be the UI window, so that
            we can change some status from the methods of the statement class
            
    Params:
        IN  HWND hWnd: The handle to the query db window. This is the GUI for the 
            SQL driver    
--*/
{
    m_hdlg = hWnd;
}

BOOL
Statement::CreateAttributesShowList(
    IN  OUT TCHAR*  pszSQL,
    OUT     BOOL*   pbFromFound  
    )
/*++
    
    Statement::CreateAttributesShowList    

	Desc:	Creates the show list for the sql. The show list is the list of nodes that 
            should be shown in the result. This routine creates the AttributeShowList
            for the present Statement using the attributes in the SELECT clause.

	Params:
        IN  OUT TCHAR*  pszSQL:         The complete SQL
        OUT     BOOL*   pbFromFound:    Did we find a FROM in the SQL

	Return:
        TRUE:   Everything OK, we created a valid show-list
        FALSE:  Otherwise
        
    Notes:  SELECT * is allowed, if we do SELECT x,* all the attributes will
            still be shown just once.
--*/
{
    BOOL    bOk         = TRUE;
    TCHAR*  pszCurrent  = NULL; // Pointer to the present token
    PNODE   pNode       = NULL;
    BOOL    fFound      = FALSE;  

    pszCurrent = _tcstok(pszSQL, TEXT(" ,\t\n"));

    if (lstrcmpi(pszCurrent, TEXT("SELECT")) != 0) {
        //
        // Error: Select not found.
        //
        this->uErrorCode = ERROR_SELECT_NOTFOUND;
        bOk = FALSE;
        goto Cleanup;
    }

    //
    //  Warning:    strtok family of  functions uses a static variable for parsing the string into tokens. 
    //              If multiple or simultaneous calls are made to the same function, 
    //              a high potential for data corruption and inaccurate results exists. 
    //              Therefore, do not attempt to call the same function simultaneously for 
    //              different strings and be aware of calling one of these function from within a loop 
    //              where another routine may be called that uses the same function.  
    //              However, calling this function simultaneously from multiple threads 
    //              does not have undesirable effects.

    //
    // Now we create the strlAttributeShowList properly.
    //
    while (pszCurrent = _tcstok(NULL, TEXT(" ,\t\n"))) {

        fFound = FALSE;

        for (UINT uIndex = 0; uIndex < ARRAYSIZE(AttributeShowMapping); ++uIndex) {

            if (lstrcmpi(AttributeShowMapping[uIndex].szAttribute, pszCurrent) == 0) {

                pNode = new NODE(DT_ATTRSHOW, AttributeShowMapping[uIndex].attr);

                if (pNode == NULL) {

                    MEM_ERR;
                    bOk = FALSE;
                    goto Cleanup;
                }

                AttributeShowList.AddAtEnd(pNode);
                fFound = TRUE;
            }
        }

        if (fFound == FALSE) {

            if (lstrcmp(pszCurrent, TEXT("*")) == 0) {

                SelectAll();
                fFound = TRUE;

            } else if (lstrcmpi(pszCurrent, TEXT("FROM")) == 0) {

                *pbFromFound = TRUE;
                bOk = TRUE;
                fFound = TRUE;
                goto Cleanup;
            }
        }

        if (fFound == FALSE) {

            uErrorCode = ERROR_INVALID_SELECTPARAM;
            bOk = FALSE;
            goto Cleanup;
        }
    }

Cleanup:

    if (AttributeShowList.m_uCount == 0) {

        uErrorCode = ERROR_INVALID_SELECTPARAM;
        bOk = FALSE;
    }

    if (bOk == FALSE) {
        AttributeShowList.RemoveAll();
    }

    return bOk;
}

ResultSet*
Statement::ExecuteSQL(
    IN      HWND    hdlg,
    IN  OUT PTSTR   pszSQL
    )
/*++
    
    Statement::ExecuteSQL

	Desc:	Executes the SQL string

	Params:
        IN      HWND    hdlg:   The parent of any messagebox
        IN  OUT PTSTR   pszSQL: The SQL to be executed

	Return:
        The pointer to ResultSet of this Statement. This will NOT be NULL
        even if there are errors
--*/
{
    PNODELIST   pInfix          = NULL, pPostFix = NULL;
    BOOL        bOk             = FALSE;
    TCHAR*      pszCurrent      = NULL; // The current token
    BOOL        bFromFound      = FALSE;
    CSTRING     strError;
    TCHAR*      pszSQLCopy      = NULL;
    K_SIZE      k_size          = lstrlen(pszSQL) + 1;
    
    pszSQLCopy = new TCHAR[k_size];
    
    if (pszSQLCopy == NULL) {
        MEM_ERR;
        goto End;
    }

    *pszSQLCopy = 0;

    SafeCpyN(pszSQLCopy, pszSQL, k_size);

    if (CSTRING::Trim(pszSQLCopy) == 0) {

        uErrorCode = ERROR_SELECT_NOTFOUND;
        goto End;
    }

    if (!CreateAttributesShowList(pszSQLCopy, &bFromFound)) {
        goto End;
    } 

    resultset.SetShowList(&AttributeShowList);

    if (!bFromFound) {
        this->uErrorCode = ERROR_FROM_NOTFOUND;
        goto End;
    }

    if (!ProcessFrom(&pszCurrent)) {

        //
        // The error code has been set in the function
        //
        goto End;
    }

    //
    // We have  got a 'where' and now we have to  filter the results.
    //
    if (pszCurrent == NULL) {

        //
        // There was no where statement, this means all the entries have to be shown in FROM
        //
        pPostFix = new NODELIST;

        if (pPostFix == NULL) {
            MEM_ERR;
            goto End;
        }

        pPostFix->AddAtBeg(new NODE(DT_LITERAL_BOOL, TRUE));

    } else {
        //
        // We have a WHERE clause and we must filter the results now. 
        //

        // Position the pointer just after WHERE.
        pszCurrent = pszCurrent + lstrlen(TEXT("WHERE"));

        pszCurrent++; // Get to the position where the delimiter was.
        
        pInfix = CreateInFix(pszSQL + (pszCurrent - pszSQLCopy));

        if (pInfix == NULL || uErrorCode != ERROR_NOERROR) {
            goto End;
        }

        pPostFix = CreatePostFix(pInfix);

        if (pPostFix == NULL || uErrorCode != ERROR_NOERROR) {
            goto End;
        }
    }

    bOk = EvaluatePostFix(pPostFix);

End:
    if (pszSQLCopy) {

        delete[] pszSQLCopy;
    }

    if (pPostFix) {

        pPostFix->RemoveAll();
        delete pPostFix;
        pPostFix = NULL;
    }

    if (pInfix) {

        pInfix->RemoveAll();
        delete pInfix;
        pInfix = NULL;
    }

    if (uErrorCode != ERROR_NOERROR) {
        
        GetErrorMsg(strError);        
        MessageBox(hdlg, (LPCTSTR)strError, g_szAppName, MB_ICONERROR);
    }

    return &resultset;
}

PNODELIST
Statement::CreateInFix(
    IN  OUT TCHAR* pszWhereString
    )
/*++
    
    Statement::CreateInFix
    
	Desc:	Parse the SQL string after the "where" to create the infix expression

	Params: 
        IN  OUT TCHAR* pszWhereString: SQL string After the WHERE ends

	Return:
        The Infix nodelist: If successful
        NULL: if Error
--*/

{
    TCHAR*      pszCurrent      = NULL; // The present token being checked
    TCHAR*      pszTemp         = NULL;   
    PNODE       pNode           = NULL;     
    PNODELIST   pInfix          = NULL;
    BOOL        bOk             = TRUE;
    UINT        uIndex          = 0, uSize = 0;
    INT         iParenthesis    = 0;
    BOOL        bFound          = FALSE;
    TCHAR*      pszNewWhere     = NULL;

    //
    // Now we parse the SQL string after the "where" to create the infix expression
    //
    if (pszWhereString == NULL || CSTRING::Trim(pszWhereString) == 0) {

        uErrorCode = ERROR_IMPROPERWHERE_FOUND;
        return NULL;
    }                                       

    uSize = lstrlen(pszWhereString) * 2;

    pszNewWhere = new TCHAR[uSize];

    if (pszNewWhere == NULL) {
        MEM_ERR;
        return NULL;
    }

    *pszNewWhere    = 0;
    pszCurrent      = pszWhereString;

    //
    // Prefix
    //
    try{
        pInfix = new NODELIST;
    } catch(...) {
        pInfix = NULL;
    }

    if (pInfix == NULL) {
        MEM_ERR;

        if (pszNewWhere) {
            delete[] pszNewWhere;
            pszNewWhere = NULL;
        }

        return NULL;
    }
    
    //
    // Insert spaces as necessary so that it is easy to parse.
    //
    while (*pszWhereString && uIndex < uSize) {
        
        switch (*pszWhereString) {
        case TEXT(' '):
            
            if (uIndex < uSize) {
                pszNewWhere[uIndex++] = TEXT(' ');
            }

            while (pszWhereString && *pszWhereString == TEXT(' ')) {
                pszWhereString++;
            }
            
            break;

        case TEXT('\"'):
            
            pszNewWhere[uIndex++] = *pszWhereString;

            while (uIndex < uSize && *pszWhereString) {
                
                pszWhereString++;
                pszNewWhere[uIndex++] = *pszWhereString;

                if (*pszWhereString == 0 || *pszWhereString == TEXT('\"')) {
                    break;
                }
            }

            if (*pszWhereString != TEXT('\"')) {

                uErrorCode = ERROR_STRING_NOT_TERMINATED;
                bOk = FALSE;
                break;

            } else {
                ++pszWhereString;
            }
            
            break;

        case TEXT('<'):
                
            pszNewWhere[uIndex++] = TEXT(' ');
            pszNewWhere[uIndex++] = *pszWhereString;
            ++pszWhereString;
            
            if (*pszWhereString == TEXT('>') || *pszWhereString == TEXT('=')) {
                pszNewWhere[uIndex++] = *pszWhereString;
                ++pszWhereString;
            }

            pszNewWhere[uIndex++] = TEXT(' ');
            
            break;

        case TEXT('>'):
                
            pszNewWhere[uIndex++] = TEXT(' ');

            pszNewWhere[uIndex++] = *pszWhereString;
            ++pszWhereString;
            
            if (*pszWhereString == TEXT('=')) {
                pszNewWhere[ uIndex++ ] = *pszWhereString;
                ++pszWhereString;
            }

            pszNewWhere[uIndex++] = TEXT(' ');
            
            break;

        
        case TEXT('='):
        case TEXT(')'):
        case TEXT('('):
            
            if (*pszWhereString == TEXT('(')) {
                ++iParenthesis;
            } else if (*pszWhereString == TEXT(')')) {
                --iParenthesis;
            }
            
            pszNewWhere[uIndex++] = TEXT(' ');
            pszNewWhere[uIndex++] = *pszWhereString;
            pszNewWhere[uIndex++] = TEXT(' ');

            pszWhereString++;
            break;

        default:
            
            pszNewWhere[uIndex++] = *pszWhereString;
            ++pszWhereString;
            break;
        }
    }

    if (iParenthesis != 0) {

        uErrorCode  = ERROR_PARENTHESIS_COUNT;
        bOk         = FALSE;
        goto End;
    }

    pszNewWhere[uIndex] = 0; // Do not forget the NULL at the end.
    
    if (bOk == FALSE) {
        goto End;
    }

    //
    // Now parse this string and create the Infix expression
    //
    pszCurrent = _tcstok(pszNewWhere, TEXT(" "));

    pNode  = NULL;
    bFound = FALSE;

    while (pszCurrent) {

        if (*pszCurrent == TEXT('\"')) {
            //
            // String literal.
            //
            pszCurrent++; // Skip the leading "
                        
            if (*(pszCurrent + lstrlen(pszCurrent) -1) != TEXT('\"') && *pszCurrent != 0) {
                //
                // _tcstok has put a '\0' at the end, it was a space earlier, make it a space
                // again so that we can tokenize on \"
                // e.g "hello world"
                //
                *(pszCurrent + lstrlen(pszCurrent)) = TEXT(' ');
                pszCurrent = _tcstok(pszCurrent, TEXT("\""));

            } else if (*pszCurrent == 0) {
                //
                // The character after the \" was a space earlier. This was made 0 by _tcstok
                // make it a space again so that we can tokenize on \"
                // e.g " hello"
                //
                *pszCurrent = TEXT(' ');
                pszCurrent = _tcstok(pszCurrent, TEXT("\""));

            } else {
                //
                // e.g. "hello"
                //
                *(pszCurrent + lstrlen(pszCurrent) -1) = 0; // Remove the triling \"
            }

            pNode = new NODE(DT_LITERAL_SZ, (LPARAM)pszCurrent);
            
            if (pNode == NULL) {
                MEM_ERR;
                break;
            }

        } else if (*pszCurrent == TEXT('(')) {

            pNode = new NODE(DT_LEFTPARANTHESES, 0);

            if (pNode == NULL) {
                MEM_ERR;
                break;
            }

        } else if (*pszCurrent == TEXT(')')) {

            pNode = new NODE(DT_RIGHTPARANTHESES, 0);

            if (pNode == NULL) {
                MEM_ERR;
                break;
            }

        } else {
            //
            // Now we have to handle the cases when the token can be a ATTR_M_* or a operator or 
            // a integer literal or constant (TRUE/FALSE/NOBLOCK/BLOCK).
            //

            // First check if the token is a ATTR_M_*
            bFound = FALSE;

            for (UINT uIndexAttrMatch = 0; uIndexAttrMatch < ARRAYSIZE(AttributeMatchMapping); ++uIndexAttrMatch) {

                if (lstrcmpi(pszCurrent, AttributeMatchMapping[uIndexAttrMatch].szAttribute) == 0) {

                    pNode = new NODE(DT_ATTRMATCH, AttributeMatchMapping[uIndexAttrMatch].attr);
                    
                    if (pNode == NULL) {
                        MEM_ERR;
                        break;
                    }

                    bFound = TRUE;
                    break;
                }
            }

            if (bFound == FALSE) {
                //
                // Now check if that is an operator.
                //
                for (UINT uIndexOperator = 0; 
                     uIndexOperator < ARRAYSIZE(OperatorMapping); 
                     uIndexOperator++) {

                    if (lstrcmpi(pszCurrent, 
                                 OperatorMapping[uIndexOperator].szOperator) == 0) {

                        pNode = new NODE;

                        if (pNode == NULL) {
                            MEM_ERR;
                            break;
                        }

                        pNode->dtType           = DT_OPERATOR;
                        pNode->op.operator_type = OperatorMapping[uIndexOperator].op_type;
                        pNode->op.uPrecedence   = OperatorMapping[uIndexOperator].uPrecedence;
                        
                        bFound = TRUE;
                        break;
                    }
                }
            }

            if (bFound == FALSE) {
               //
               // Now it can only be a integer literal or one of the constants.
               //
               pNode = CheckAndAddConstants(pszCurrent);

               if (pNode == NULL) {

                   BOOL bValid;
                   
                   INT iResult = Atoi(pszCurrent, &bValid);

                   if (bValid) {

                       pNode = new NODE(DT_LITERAL_INT, iResult);

                       if (pNode == NULL) {

                           MEM_ERR;
                           bOk = FALSE;
                           goto End;
                       }

                   } else {
                       //
                       // Some crap string was there, invalid SQL
                       //
                       uErrorCode = ERROR_IMPROPERWHERE_FOUND;
                       bOk = FALSE;
                       goto End;
                   }
               }
            }
        }

        pInfix->AddAtEnd(pNode);
        pszCurrent = _tcstok(NULL, TEXT(" "));
    }
End:
    if (bOk == FALSE) {

        if (pInfix) {
            pInfix->RemoveAll();
            pInfix = NULL;
        }
    }

    if (pszNewWhere) {
        delete[] pszNewWhere;
        pszNewWhere = NULL;
    }

    return pInfix;
}

PNODELIST
Statement::CreatePostFix(
    IN  OUT PNODELIST pInfix
    )
/*++

    Statement::CreatePostFix
    
	Desc:   Creates a post fix nodelist from infix nodelist
  
    Params:
        IN  PNODELIST pInfix: The infix nodelist

	Return:
        The PostFix Nodelist: If Success
        NULL:   If error
        
    Algo:   Suppose INFIX is a SQL expression in infix notation. This algorith finds
            the equivalent postfix notation in POSTFIX. STACK is a user defined stack data
            structure
            
            1. Push '(' into STACK and add ')' to the end of INFIX
            
            2. Scan INFIX from left to right and repeat steps 3 tp 6 for each element
                of INFIX untill the STACK becomes empty
                
            3. If an operand is encountered, add it to POSTFIX
            
            4. If a left parenthesis is encountered, push it onto STACK
            
            5. If an operator $ is encountered then:
                
                a) Repeatedly pop from STACK and add to POSTFIX each operator
                    (from the top of the STACK) which has the same precedence as or 
                    higher than $
                    
                b) Add $ to STACK
                
            6. If a right parenthesis is encountered, then:
            
                a) Repeatedly pop from STACK and add to POSTFIX each operator (on the top of STACK),
                    untill a left parenthesis is encountered
                    
                b) Remove the left parenthesis. (Do not add the left parenthesis to POSTFIX)
                
            7. Exit
        
    Notes:  This routine, uses the nodes of the infix nodelist to create the post fix
            nodelist, so the infix nodelist effectively gets destroyed
--*/
{
    BOOL        bOk         = TRUE;
    PNODELIST   pPostFix    = NULL;
    PNODE       pNodeTemp   = NULL, pNodeInfix = NULL;
    NODELIST    Stack;

    if (pInfix == NULL) {
        assert(FALSE);
        Dbg(dlError, "CreatePostFix", "pInfix == NULL");
        bOk = FALSE;
        goto End;
    }

    pPostFix = new NODELIST;

    if (pPostFix == NULL) {
        bOk = FALSE;
        goto End;
    }

    pNodeTemp = new NODE;

    if (pNodeTemp == NULL) {
        bOk = FALSE;
        goto End;
    }

    pNodeTemp->dtType = DT_LEFTPARANTHESES;

    //
    // Push a initial left parenthesis in the stack.
    //
    Stack.Push(pNodeTemp);
    //
    // Add a right parenthesis to the end of pInfix
    //
    pNodeTemp = new NODE;

    if (pNodeTemp == NULL) {
        bOk = FALSE;
        goto End;
    }

    pNodeTemp->dtType = DT_RIGHTPARANTHESES;
    pInfix->AddAtEnd(pNodeTemp);
    
    while (pNodeInfix = pInfix->Pop()) {

        switch (pNodeInfix->dtType) {

        case DT_LEFTPARANTHESES:
            
            Stack.Push(pNodeInfix);
            break;
        
        case DT_OPERATOR:
            
            //
            // Repeatedly pop from stack and add to pPostFix each operator (on the top of stack)
            // that has the same precedence as or higher than the present operator
            //
            while (Stack.m_pHead && 
                   Stack.m_pHead->dtType == DT_OPERATOR && 
                   Stack.m_pHead->op.uPrecedence >= pNodeInfix->op.uPrecedence) {

                pNodeTemp = Stack.Pop();

                if (pNodeTemp == NULL) {

                    uErrorCode = ERROR_IMPROPERWHERE_FOUND;
                    bOk = FALSE;
                    goto End;

                } else {
                    pPostFix->AddAtEnd(pNodeTemp);
                }
            }// while

            Stack.Push(pNodeInfix);
            break;
            
        case DT_RIGHTPARANTHESES:
            
            //
            // Repeatedly pop from the stack and add to pPosFix each operator (on the top of STACK)
            // untill a left paranthesis is encountered. 
            //
            // Remove the left parenthesis, do not add it to pPostFix
            //

            while (Stack.m_pHead && 
                   Stack.m_pHead->dtType == DT_OPERATOR) {

                pNodeTemp = Stack.Pop();
                pPostFix->AddAtEnd(pNodeTemp);
            }

            if (Stack.m_pHead && Stack.m_pHead->dtType != DT_LEFTPARANTHESES) {

                //
                // Inavalid SQL
                //
                uErrorCode = ERROR_IMPROPERWHERE_FOUND;
                bOk = FALSE;
                goto End;
            }

            pNodeTemp = Stack.Pop(); // This is the left parenthesis

            if (pNodeTemp) {
                delete pNodeTemp;
            }

            if (pNodeInfix) {
                delete pNodeInfix;       // Delete the right parenthesis in the infix expression.
            }

            break;

        case DT_UNKNOWN: 
            
            assert(FALSE);
            bOk = FALSE;
            goto End;
            break;

        default:
            
            //
            // The operands
            //
            pPostFix->AddAtEnd(pNodeInfix);
            break;
        }   
    }

End:
    if (!bOk && pPostFix) {
        pPostFix->RemoveAll();
        pPostFix = NULL;
    }

    return pPostFix;
}


BOOL
Statement::EvaluatePostFix(
    IN  PNODELIST pPostFix
    )
/*++
    Statement::EvaluatePostFix
    
    Desc:   This function takes the post-fix expression and then adds only 
            the entries that match the expression to the result-set.
            
    Params:
        IN  PNODELIST pPostFix: The postfix expression to be actually executed to populate
            the result set
            
    Return:
        TRUE:   The function executed successfully
        FALSE:  There was some error
        
        
--*/
{
    PDATABASE   pDataBase;
    PDBENTRY    pEntry, pApp;  
    BOOL        bOk = FALSE;

    //
    // For the global database
    //
    if (m_uCheckDB & DATABASE_TYPE_GLOBAL) {

        
        pDataBase = &GlobalDataBase;

        if (g_bMainAppExpanded == FALSE) {

            SetStatus(GetDlgItem(m_hdlg, IDC_STATUSBAR), IDS_LOADINGMAIN);

            SetCursor(LoadCursor(NULL, IDC_WAIT));

            ShowMainEntries(g_hDlg);

            SetCursor(LoadCursor(NULL, IDC_ARROW));

            SetStatus(GetDlgItem(m_hdlg, IDC_STATUSBAR), TEXT(""));
        }

        pApp = pEntry = pDataBase ? pDataBase->pEntries : NULL;
        
        while (pEntry) {

            FilterAndAddToResultSet(pDataBase, pEntry, pPostFix);

            if (uErrorCode) {
                goto End;
            }

            pEntry = pEntry->pSameAppExe;

            if (pEntry == NULL) {

                pEntry = pApp = pApp->pNext;
                
            }
        }
    }

    //
    // For the installed database
    //
    if (m_uCheckDB & DATABASE_TYPE_INSTALLED) {

        //
        // We need to protect the access to the installed database data, because
        // that can get updated if some database is installed or uninstalled. The updating
        // will take place in a different (the main) thread and this will make the data
        // structure inconsistent
        //
        EnterCriticalSection(&g_csInstalledList);

        pDataBase = InstalledDataBaseList.pDataBaseHead;
           
        while (pDataBase) {

            pApp =  pEntry = (pDataBase) ? pDataBase->pEntries : NULL;

            while (pEntry) {
                
                FilterAndAddToResultSet(pDataBase, pEntry, pPostFix);
                
                if (uErrorCode) {

                    LeaveCriticalSection(&g_csInstalledList);
                    goto End;
                }

                pEntry = pEntry->pSameAppExe;

                if (pEntry == NULL) {
                    pEntry = pApp = pApp->pNext;
                }
            }

            pDataBase = pDataBase->pNext;
        }

        LeaveCriticalSection(&g_csInstalledList);
    }

    //
    // For the custom databases
    //
    if (m_uCheckDB & DATABASE_TYPE_WORKING) {

        pDataBase = DataBaseList.pDataBaseHead;
        
        while (pDataBase) {

            pApp = pEntry = pDataBase ? pDataBase->pEntries : NULL;

            while (pEntry) {

                FilterAndAddToResultSet(pDataBase, pEntry, pPostFix);

                if (uErrorCode) {
                    goto End;
                }
                
                pEntry = pEntry->pSameAppExe;

                if (pEntry == NULL) {
                    pEntry = pApp = pApp->pNext;
                }
            }

            pDataBase = pDataBase->pNext;
        }
    }

    bOk = TRUE;
End:

    return bOk;
}

BOOL
Statement::FilterAndAddToResultSet(
    IN  PDATABASE pDatabase,
    IN  PDBENTRY  pEntry,
    IN  PNODELIST pPostfix
    )
{
/*++
    
    Statement::FilterAndAddToResultSet    

    Desc:   This function checks if the pEntry in database pDatabase actually 
            satisfies pPostFix  if it does, then it adds the entry into the resultset.
            
    Params:
        IN  PDATABASE pDatabase:    The database in which pEntry resides
        IN  PDBENTRY  pEntry:       The entry that we want to check whether it satisfies pPostfix
        IN  PNODELIST pPostfix:     The postfix nodelist
    
    Return: 
        TRUE:   The pEntry in pDatabase satisfies the post-fix expression pPostfix
        FALSE:  Otherwise.
        
    Algo:   Algorithm to find the result of a SQL expression in POSTFIX. The result
            is calculated for attribute values of PDBENTRY  pEntry that lives in PDATABASE pDatabase
            
            1. While there are some elements in POSTFIX do
                
                1.1 If an operand is encountered, put it on STACK 
                
                1.2 If an operator $ is encountered then:
                
                    a) Remove the top twp elements of STACK, where A is the top 
                        element and B is the next to top element
                        
                    b) Evaluate B $ A
                    
                    c) Place the result of (b) on STACK
                    
            2. The value of the expression is the value that is on top of the stack
        
    Notes:  We need to make a copy of pPostFix and work on that.
        
--*/

    PNODE       pNodeTemp, pNodeOperandLeft, pNodeOperandRight, pNodeResult;
    BOOL        bResult = FALSE;
    NODELIST    nlCopyPostFix;
    NODELIST    Stack;
    PNODE       pNodePostfixHead = pPostfix->m_pHead;

    pNodeResult = pNodeTemp = pNodeOperandLeft = pNodeOperandRight = NULL;

    //
    // Make a copy of the post-fix expression. While evaluating the expression the 
    // postix expression gets modified, so we have to work on a copy as we 
    // need the original postfix expression to persist till we have checked 
    // all the entries.
    //
    while (pNodePostfixHead) {

        pNodeTemp = new NODE();

        if (pNodeTemp == NULL) {

            MEM_ERR;
            bResult = FALSE;
            goto End;
        }

        pNodeTemp->dtType = pNodePostfixHead->dtType;


        switch (pNodePostfixHead->dtType) {
        
        case DT_LITERAL_BOOL:

            pNodeTemp->bData = pNodePostfixHead->bData;
            break;
        
        case DT_LITERAL_INT:

            pNodeTemp->iData = pNodePostfixHead->iData;
            break;

        case DT_LITERAL_SZ:

            pNodeTemp->SetString(pNodePostfixHead->szString);
            break;

        case DT_OPERATOR:

            pNodeTemp->op.operator_type = pNodePostfixHead->op.operator_type;
            pNodeTemp->op.uPrecedence = pNodePostfixHead->op.uPrecedence;
            break;

        case DT_ATTRMATCH:

            pNodeTemp->attrMatch = pNodePostfixHead->attrMatch;
            break;
        }

        nlCopyPostFix.AddAtEnd(pNodeTemp);
        pNodePostfixHead = pNodePostfixHead->pNext;
    }

    while (pNodeTemp = nlCopyPostFix.Pop()) {

        if (pNodeTemp->dtType == DT_OPERATOR) {

            pNodeOperandRight = Stack.Pop();
            pNodeOperandLeft  = Stack.Pop();

            if (pNodeOperandRight == NULL || pNodeOperandLeft == NULL) {
                uErrorCode = ERROR_WRONGNUMBER_OPERANDS;
                bResult = FALSE;
                goto End;
            }

            pNodeResult =  Evaluate(pDatabase, 
                                    pEntry, 
                                    pNodeOperandLeft, 
                                    pNodeOperandRight, 
                                    pNodeTemp);

            if (pNodeResult == NULL) {
                
                bResult = FALSE;
                goto End;
            }

            Stack.Push(pNodeResult);

            if (pNodeOperandLeft) {
                delete pNodeOperandLeft;
            }

            if (pNodeOperandRight) {
                delete pNodeOperandRight;
            }

            delete pNodeTemp;

        } else {

            Stack.Push(pNodeTemp);
        }
    }

    pNodeTemp = Stack.Pop();

    if (pNodeTemp == NULL || pNodeTemp->dtType != DT_LITERAL_BOOL) {
        
        uErrorCode = ERROR_IMPROPERWHERE_FOUND;
        bResult = FALSE;
        goto End;
    }

    bResult = pNodeTemp->bData;

    if (pNodeTemp) {
        delete pNodeTemp;
    }

    if (bResult) {
        //
        // Entry satisfies the postfix
        //
        resultset.AddAtLast(new RESULT_ITEM(pDatabase, pEntry));
    }

End:
    
    // Stack and nlCopyPostFix contents are removed through their desctructors.
    return bResult;
}

PNODE
Statement::Evaluate(
    IN  PDATABASE   pDatabase,
    IN  PDBENTRY    pEntry,  
    IN  PNODE       pOperandLeft,
    IN  PNODE       pOperandRight,
    IN  PNODE       pOperator
    )
/*++
    
    Statement::Evaluate
        
    Desc:   This function evaluates a binary expression
    
    Params:
        IN  PDATABASE   pDatabase:      The database in which pEntry resides
        IN  PDBENTRY    pEntry:         The entry that is being currently checked, to
            see if it satisfies the post fix
            
        IN  PNODE       pOperandLeft:   The left operand
        IN  PNODE       pOperandRight:  The right operand
        IN  PNODE       pOperator:      The operator to be applied to the above operands
    
    Return: The result of applying the operator on the left and right operands
    
--*/
{
    BOOL  bOk           = TRUE;           
    PNODE pNodeResult   = new NODE;

    if (pNodeResult == NULL) {

        MEM_ERR;
        return NULL;
    }

    pNodeResult->dtType = DT_LITERAL_BOOL;

    if (pOperandLeft == NULL 
        || pOperandRight == NULL 
        || pDatabase == NULL 
        || pEntry == NULL
        || pOperator == NULL) {

        bOk = FALSE;
        assert(FALSE);
        Dbg(dlError, "Statement::Evaluate", "Invalid arguments to function");
        goto End;
    }

    //
    // We will have to set the values appropriately for the attributes so that we can
    // apply the operator on them 
    //
    if (!SetValuesForOperands(pDatabase, pEntry, pOperandLeft)) {

        bOk = FALSE;
        goto End;
    }

    if (!SetValuesForOperands(pDatabase, pEntry, pOperandRight)) {

        bOk = FALSE;
        goto End;
    } 

    //
    // Now both the left and the right operands have proper values (except operands with ATTR_M_LAYER/SHIMFLAG/PATCH/MATCHINGFILE _NAME type) 
    //
    switch (pOperator->op.operator_type) {
    
    case OPER_AND:
        
        //
        // Both operands should be boolean
        //
        if (pOperandLeft->dtType != DT_LITERAL_BOOL || pOperandRight->dtType != DT_LITERAL_BOOL) {

            uErrorCode = ERROR_INVALID_AND_OPERANDS;
            bOk = FALSE;
            goto End;

        } else {
            
            pNodeResult->bData  = pOperandLeft->bData && pOperandRight->bData;
        }
    
        break;

    case OPER_OR:
        
        //
        // Both operands should be boolean
        //
        if (pOperandLeft->dtType != DT_LITERAL_BOOL || pOperandRight->dtType != DT_LITERAL_BOOL) {

            uErrorCode = ERROR_INVALID_OR_OPERANDS;
            bOk = FALSE;
            goto End;

        } else {
            
            pNodeResult->bData  = pOperandLeft->bData || pOperandRight->bData;
        }
        
        break;

    case OPER_EQUAL:
        
        CHECK_OPERAND_TYPE(bOk,End);

        switch (pOperandLeft->dtType) {
        case DT_LITERAL_BOOL:

            pNodeResult->bData = pOperandLeft->bData == pOperandRight->bData;
            break;

        case DT_LITERAL_INT:

            pNodeResult->bData = pOperandLeft->iData == pOperandRight->iData;
            break;

        case DT_LITERAL_SZ:
            pNodeResult->bData = CheckIfContains(pOperandLeft->szString, pOperandRight->szString);
            break;
        }
        
        break;

    case OPER_GE:
        
        CHECK_OPERAND_TYPE(bOk,End);
        
        switch (pOperandLeft->dtType) {
        case DT_LITERAL_BOOL:

            uErrorCode = ERROR_INVALID_GE_OPERANDS;
            bOk = FALSE;
            goto End;
            break;

        case DT_LITERAL_INT:

            pNodeResult->bData = pOperandLeft->iData >= pOperandRight->iData;
            break;

        case DT_LITERAL_SZ:
            pNodeResult->bData = lstrcmpi(pOperandLeft->szString, pOperandRight->szString) >= 0 ? TRUE : FALSE;
            break;
        }
        
        break;

    case OPER_GT:
        
        CHECK_OPERAND_TYPE(bOk,End);

        switch (pOperandLeft->dtType) {
        case DT_LITERAL_BOOL:

            uErrorCode = ERROR_INVALID_GT_OPERANDS;
            bOk = FALSE;
            goto End;
            break;

        case DT_LITERAL_INT:

            pNodeResult->bData = pOperandLeft->iData > pOperandRight->iData;
            break;

        case DT_LITERAL_SZ:
            pNodeResult->bData = lstrcmpi(pOperandLeft->szString, pOperandRight->szString) > 0 ? TRUE : FALSE;
            break;
        }
        
        break;

    case OPER_LE:
        
        CHECK_OPERAND_TYPE(bOk,End);

        switch (pOperandLeft->dtType) {
        case DT_LITERAL_BOOL:

            uErrorCode = ERROR_INVALID_LE_OPERANDS;
            bOk = FALSE;
            goto End;
            break;

        case DT_LITERAL_INT:

            pNodeResult->bData = pOperandLeft->iData <= pOperandRight->iData;
            break;

        case DT_LITERAL_SZ:
            pNodeResult->bData = lstrcmpi(pOperandLeft->szString, pOperandRight->szString) <= 0 ? TRUE : FALSE;
            break;
        }
        
        break;

    case OPER_LT:
        
        CHECK_OPERAND_TYPE(bOk,End);

        switch (pOperandLeft->dtType) {
        case DT_LITERAL_BOOL:

            uErrorCode = ERROR_INVALID_LE_OPERANDS;
            bOk = FALSE;
            goto End;
            break;

        case DT_LITERAL_INT:

            pNodeResult->bData = pOperandLeft->iData < pOperandRight->iData;
            break;

        case DT_LITERAL_SZ:
            pNodeResult->bData = lstrcmpi(pOperandLeft->szString, pOperandRight->szString) < 0 ? TRUE : FALSE;
            break;
        }
        
        break;

    case OPER_NE:
        
        CHECK_OPERAND_TYPE(bOk,End);

        switch (pOperandLeft->dtType) {
        case DT_LITERAL_BOOL:

            pNodeResult->bData = pOperandLeft->bData != pOperandRight->bData;
            break;

        case DT_LITERAL_INT:

            pNodeResult->bData = pOperandLeft->iData != pOperandRight->iData;
            break;

        case DT_LITERAL_SZ:

            pNodeResult->bData = !CheckIfContains(pOperandLeft->szString, pOperandRight->szString);
            break;
        }
        
        break;

    case OPER_CONTAINS:
        
        //
        // Valid only for string operands. Order of operands is important
        //
        if (pOperandLeft == NULL
            || pOperandRight == NULL
            || pOperandLeft->dtType != DT_LITERAL_SZ 
            || pOperandRight->dtType != DT_LITERAL_SZ) {

            uErrorCode = ERROR_INVALID_CONTAINS_OPERANDS;
            bOk = FALSE;
            goto End;
        }

        pNodeResult->bData = CheckIfContains(pOperandLeft->szString, 
                                             pOperandRight->szString);
        
        break;

    case OPER_HAS:
        
        //
        // This operator is valid only for multi-valued attributes of the entry. Like layers, shims, pathces
        // This operator is used in this context: "Which entry has the layer Win95"
        //
        if (pOperandRight->dtType == DT_LITERAL_SZ 
            && pOperandLeft->dtType == DT_ATTRMATCH 
            && (pOperandLeft->attrMatch == ATTR_M_LAYER_NAME 
                || pOperandLeft->attrMatch == ATTR_M_MATCHFILE_NAME 
                || pOperandLeft->attrMatch == ATTR_M_PATCH_NAME 
                || pOperandLeft->attrMatch == ATTR_M_SHIM_NAME)) {

            pNodeResult->bData = ApplyHasOperator(pEntry, 
                                                  pOperandLeft, 
                                                  pOperandRight->szString);

        } else {
            uErrorCode = ERROR_INVALID_HAS_OPERANDS;
            goto End;
        }
        
        break;

    }
    
End:
    if (!bOk) {

        if (pNodeResult) {
            delete pNodeResult;
            pNodeResult = NULL;
        }
    }

    return pNodeResult;
}

void
Statement::SelectAll(
    void
    )
{
/*++
    
    Statement::SelectAll
    
    Desc:   This function is called when we have encountered a '*' while creating 
            the AttributeShowList. As a result of this all the attributes in  
            AttributeMatchMapping  have to be added to the AttributeShowList 
     
    Notes:  If this function is called twice or more for a SQL expression,
            say we have SELECT *,*,* all the attributes will still be shown just once.
--*/  

    PNODE pNode = NULL;

    AttributeShowList.RemoveAll();

    for (UINT uIndex = 0; uIndex < ARRAYSIZE(AttributeShowMapping); ++uIndex) {
        pNode = new NODE(DT_ATTRSHOW, AttributeShowMapping[uIndex].attr);

        if (pNode == NULL) {
            MEM_ERR;
            break;
        }

        AttributeShowList.AddAtEnd(pNode);
    }
}

BOOL
Statement::ProcessFrom(
    OUT TCHAR** ppszWhere
    )
/*++

    Statement::ProcessFrom    

    Desc:   This function starts immeditely from where FROM ends in the SQL 
            and then it sets which databases system, installed or custom, 
            (There can be combinations as well) have to be checked for 
            entries that match the where condition.
    
    Params:
        OUT TCHAR** ppszWhere:  The pointer to WHERE in the SQL
        
    Return:
        FALSE:  If the tokens after FROM are invalid
        TRUE:   Otherwise        
        
    Warn:   We should NOT have called _tcstok after getting the AttributeShowList
            using [ CreateAttributesShowList() ] and before we call this routine. 
            This routine assumes that the static pointer of _tcstok is poised 
            just after FROM in the SQL
--*/             
{
    TCHAR* pszCurrentToken  = NULL;
    BOOL   bOk              = TRUE, bFound = FALSE; 
    
    if (ppszWhere == NULL) {
        assert(FALSE);
        return FALSE;
    }

    *ppszWhere = NULL;

    pszCurrentToken = _tcstok(NULL, TEXT(" ,"));

    if (pszCurrentToken == NULL) {

        bOk = FALSE;
        uErrorCode = ERROR_INVALID_DBTYPE_INFROM;
        goto End;
    }

    m_uCheckDB = 0;

    while (pszCurrentToken) {

        bFound = FALSE;

        for (UINT uIndex = 0; uIndex < ARRAYSIZE(DatabasesMapping); ++uIndex) {

            if (lstrcmpi(DatabasesMapping[uIndex].szDatabaseType, pszCurrentToken) == 0) {

                m_uCheckDB |= DatabasesMapping[uIndex].dbtype;
                bFound = TRUE;
                break;
            }
        }

        if (bFound == FALSE) {

            if (lstrcmpi(TEXT("WHERE"), pszCurrentToken) == 0) {

                *ppszWhere = pszCurrentToken;
                goto End;

                //
                // We do not change the bOk here. If even one valid db type has been found
                // bOk will remain true unless we find a invalid db type.
                //
            }

            //
            // Some crap string, not a valid db-type
            //
            uErrorCode = ERROR_INVALID_DBTYPE_INFROM;
            bOk = FALSE;
            goto End;
        }

        pszCurrentToken = _tcstok(NULL, TEXT(" ,"));
    }
End:

    if (m_uCheckDB == 0) {

        uErrorCode = ERROR_INVALID_DBTYPE_INFROM;
        bOk = FALSE;
    }
    
    return bOk;
}

void
GetFixesAppliedToEntry(
    IN  PDBENTRY    pEntry, 
    OUT CSTRING&    strFixes
    )
/*++

    GetShimsAppliedToEntry

	Desc:	Makes a string of all the shims and flags that are applied to an entry
            and assigns that to strFixes

	Params:
        IN  PDBENTRY    pEntry:     The entry whose shims and flags we want to get 
        OUT CSTRING     strTemp:    The string in which the result will be stored

	Return:
        void
--*/
{
    PSHIM_FIX_LIST  psflIndex = NULL;
    PFLAG_FIX_LIST  pfflIndex = NULL;
    CSTRING         strTemp;

    if (pEntry == NULL) {
        assert(FALSE);
        goto End;
    }

    psflIndex = pEntry->pFirstShim;
    strFixes = TEXT("");

    //
    // Loop through all the shims for this entry and add their names to the string
    //
    while (psflIndex) {

        if (psflIndex->pShimFix) {
            strTemp.Sprintf(TEXT("%s, "), (LPCTSTR)psflIndex->pShimFix->strName);
            strFixes.Strcat(strTemp);
        } else {
            assert(FALSE);
        }

        psflIndex = psflIndex->pNext;
    }

    pfflIndex = pEntry->pFirstFlag;

    //
    // Loop through all the flags for this entry and add their names to the string
    //
    while (pfflIndex) {

        if (pfflIndex->pFlagFix) {
            strTemp.Sprintf(TEXT("%s, "), (LPCTSTR)pfflIndex->pFlagFix->strName);
            strFixes.Strcat(strTemp);
        } else {
            assert(FALSE);
        }

        pfflIndex = pfflIndex->pNext;
    }

    //
    // Remove the last ,\s pair. (\s means a space character);
    //
    strFixes.SetChar(strFixes.Length() - 2, 0);

End:
    return;
}

void
GetLayersAppliedToEntry(
    IN  PDBENTRY    pEntry, 
    OUT CSTRING&    strFixes
    )
/*++

    GetLayersAppliedToEntry

	Desc:	Makes a string of all the layers that are applied to an entry
            and assigns that to strFixes

	Params:
        IN  PDBENTRY    pEntry:     The entry whose shims and flags we want to get 
        OUT CSTRING     strTemp:    The string in which the result will be stored

	Return:
        void
--*/
{
    PLAYER_FIX_LIST plflIndex = NULL;
    CSTRING         strTemp;

    if (pEntry == NULL) {
        assert(FALSE);
        goto End;
    }

    plflIndex = pEntry->pFirstLayer;
    strFixes = TEXT("");

    //
    // Loop through all the layers for this entry and add their names to the string
    //
    while (plflIndex) {

        if (plflIndex->pLayerFix) {
            strTemp.Sprintf(TEXT("%s, "), (LPCTSTR)plflIndex->pLayerFix->strName);
            strFixes.Strcat(strTemp);
        } else {
            assert(FALSE);
        }

        plflIndex = plflIndex->pNext;
    }

    //
    // Remove the last ,\s pair. (\s means a space character);
    //
    strFixes.SetChar(strFixes.Length() - 2, 0);

End:
    return;
}

void
GetPatchesAppliedToEntry(
    IN  PDBENTRY    pEntry, 
    OUT CSTRING&    strFixes
    )
/*++

    GetPatchesAppliedToEntry

	Desc:	Makes a string of all the patches that are applied to an entry
            and assigns that to strFixes

	Params:
        IN  PDBENTRY    pEntry:     The entry whose shims and flags we want to get 
        OUT CSTRING     strTemp:    The string in which the result will be stored

	Return:
        void
--*/
{
    PPATCH_FIX_LIST ppflIndex = NULL;
    CSTRING         strTemp;

    if (pEntry == NULL) {
        assert(FALSE);
        goto End;
    }

    ppflIndex = pEntry->pFirstPatch;
    strFixes = TEXT("");

    //
    // Loop through all the patches for this entry and add their names to the string
    //
    while (ppflIndex) {

        if (ppflIndex->pPatchFix) {
            strTemp.Sprintf(TEXT("%s, "), (LPCTSTR)ppflIndex->pPatchFix->strName);
            strFixes.Strcat(strTemp);
        } else {
            assert(FALSE);
        }

        ppflIndex = ppflIndex->pNext;
    }

    //
    // Remove the last ,\s pair. (\s means a space character);
    //
    strFixes.SetChar(strFixes.Length() - 2, 0);

End:
    return;
}

void
GetMatchingFilesForEntry(
    IN  PDBENTRY    pEntry, 
    OUT CSTRING&    strMatchingFiles
    )
/*++

    GetMatchingFilesForEntry

	Desc:	Makes a string of all the matching files that are used for identifying
            this entry and assigns that to strMatchingFiles

	Params:
        IN  PDBENTRY    pEntry:     The entry whose shims and flags we want to get 
        OUT CSTRING     strTemp:    The string in which the result will be stored

	Return:
        void
--*/
{
    PMATCHINGFILE   pMatchIndex = NULL;
    CSTRING         strTemp;

    if (pEntry == NULL) {
        assert(FALSE);
        goto End;
    }

    pMatchIndex = pEntry->pFirstMatchingFile;
    strMatchingFiles = TEXT("");

    //
    // Loop through all the matching files for this entry and add their names to the string
    //
    while (pMatchIndex) {

        if (pMatchIndex->strMatchName == TEXT("*")) {
            //
            // The program being fixed. Get its file name
            //
            strTemp.Sprintf(TEXT("%s, "), (LPCTSTR)pEntry->strExeName);
        } else {
            strTemp.Sprintf(TEXT("%s, "), (LPCTSTR)pMatchIndex->strMatchName);
        }

        strMatchingFiles.Strcat(strTemp);

        pMatchIndex = pMatchIndex->pNext;
    }

    //
    // Remove the last ,\s pair. (\s means a space character);
    //
    strMatchingFiles.SetChar(strMatchingFiles.Length() - 2, 0);

End:
    return;
}
                                                                               
BOOL
SetValuesForOperands(
    IN      PDATABASE pDatabase,
    IN      PDBENTRY  pEntry,
    IN  OUT PNODE     pOperand
    )
/*++

    SetValuesForOperands

	Desc:   Sets the values for the various attributes after getting them from the 
            database or the entry. Sets the values in pOperand, also sets the type in 
            pOperand

	Params:
        IN      PDATABASE pDatabase:    The entry for which we want to get the values 
            of some of the attributes resides in this database
            
        IN      PDBENTRY  pEntry:       The entry for which we want to get the values 
            of some of the attributes
            
        IN  OUT PNODE     pOperand:     The value and the type of the value will be stored
            here
        

	Return:
        TRUE:   If the value has been successfully oobtained and set
        FALSE:  Otherwise
--*/

{
    CSTRING strTemp;

    if (!pOperand || !pDatabase || !pOperand) {
        assert(FALSE);
        return FALSE;
    }
    
    if (pOperand->dtType == DT_ATTRMATCH || pOperand->dtType == DT_ATTRSHOW) {

        switch (pOperand->attrMatch) {
        
        case ATTR_S_APP_NAME:
        case ATTR_M_APP_NAME:
                
            pOperand->SetString(pEntry->strAppName);
            break;

        case ATTR_S_DATABASE_GUID:
        case ATTR_M_DATABASE_GUID:
                
            pOperand->SetString(pDatabase->szGUID);
            break;

        case ATTR_S_DATABASE_INSTALLED:
        case ATTR_M_DATABASE_INSTALLED:
            
            pOperand->dtType = DT_LITERAL_BOOL;
            pOperand->bData  = CheckIfInstalledDB(pDatabase->szGUID);

            break;

        case ATTR_S_DATABASE_NAME:
        case ATTR_M_DATABASE_NAME:
            pOperand->SetString(pDatabase->strName);
            break;

        case ATTR_S_DATABASE_PATH:
        case ATTR_M_DATABASE_PATH:
            pOperand->SetString(pDatabase->strPath);
            break;

        case ATTR_S_ENTRY_APPHELPTYPE:
        case ATTR_M_ENTRY_APPHELPTYPE:

            pOperand->dtType = DT_LITERAL_INT;
            pOperand->iData  = pEntry->appHelp.severity; // BUGBUG: do we set the severity properly
            break;

        case ATTR_S_ENTRY_APPHELPUSED:
        case ATTR_M_ENTRY_APPHELPUSED:

            pOperand->dtType = DT_LITERAL_BOOL;
            pOperand->bData  = pEntry->appHelp.bPresent;

            break;

        case ATTR_S_ENTRY_DISABLED:
        case ATTR_M_ENTRY_DISABLED:

            pOperand->dtType = DT_LITERAL_BOOL;
            pOperand->bData  = pEntry->bDisablePerMachine || pEntry->bDisablePerUser;
            break;

        case ATTR_S_ENTRY_EXEPATH:
        case ATTR_M_ENTRY_EXEPATH:

            pOperand->SetString(pEntry->strExeName);
            break;

        case ATTR_S_ENTRY_GUID:
        case ATTR_M_ENTRY_GUID:

            pOperand->SetString(pEntry->szGUID);
            break;

        case ATTR_S_ENTRY_LAYER_COUNT:
        case ATTR_M_ENTRY_LAYER_COUNT:

            pOperand->dtType = DT_LITERAL_INT;
            pOperand->iData  = GetLayerCount((LPARAM) pEntry, TYPE_ENTRY);
            break;

        case ATTR_S_ENTRY_MATCH_COUNT:
        case ATTR_M_ENTRY_MATCH_COUNT:

            pOperand->dtType = DT_LITERAL_INT;
            pOperand->iData  = GetMatchCount(pEntry);
            break;

        case ATTR_S_ENTRY_PATCH_COUNT:
        case ATTR_M_ENTRY_PATCH_COUNT:

            pOperand->dtType = DT_LITERAL_INT;
            pOperand->iData  = GetPatchCount((LPARAM) pEntry, TYPE_ENTRY);
            break;

        case ATTR_S_ENTRY_SHIMFLAG_COUNT:
        case ATTR_M_ENTRY_SHIMFLAG_COUNT:

            pOperand->dtType = DT_LITERAL_INT;
            pOperand->iData  = GetShimFlagCount((LPARAM) pEntry, TYPE_ENTRY);
            break;

        case ATTR_S_SHIM_NAME:
            
            GetFixesAppliedToEntry(pEntry, strTemp);
            pOperand->SetString((PCTSTR)strTemp);
            break;

        case ATTR_S_LAYER_NAME:

            GetLayersAppliedToEntry(pEntry, strTemp);
            pOperand->SetString((PCTSTR)strTemp);
            break;

        case ATTR_S_MATCHFILE_NAME:

            GetMatchingFilesForEntry(pEntry, strTemp);
            pOperand->SetString((PCTSTR)strTemp);
            break;

        case ATTR_S_PATCH_NAME:

            GetPatchesAppliedToEntry(pEntry, strTemp);
            pOperand->SetString((PCTSTR)strTemp);
            break;

        }
    }

    return TRUE;
}

BOOL
Statement::ApplyHasOperator(
    IN      PDBENTRY    pEntry,
    IN      PNODE       pOperandLeft,
    IN  OUT PTSTR       pszName   
    )
/*++
    Statement::ApplyHasOperator
    
    Params:
        IN      PDBENTRY    pEntry:         The entry which is being checked to see if it
            satisfies the post fix expression.
            
        IN      PNODE       pOperandLeft:   The left operand of the HAS operator
        IN  OUT PCTSTR      pszName:        The right operand of the HAS operator. We will
            trim this so it will get modified
    
    Desc:   Applies the "HAS" operator.
    
    Notes:  The HAS operator is required because there can be some attributes which are multi-valued
            For these attributes, we might wish to know, if it 'has' a particular string
            The attributes for which the HAS operator can be applied are:
            layer name, shim name and matching file name. Trying to use any other operand as the
            left side operand will give a sql error
--*/

{
    BOOL    bFound = FALSE;

    if (pEntry == NULL || pOperandLeft == NULL || pszName == NULL) {
        assert(FALSE);
        return FALSE;
    }

    switch (pOperandLeft->attrMatch) {
    case ATTR_M_LAYER_NAME:
        {
            PLAYER_FIX_LIST plfl;

            plfl = pEntry->pFirstLayer;

            while (plfl) {

                assert (plfl->pLayerFix);

                if (CheckIfContains(plfl->pLayerFix->strName, pszName)) {
                    bFound = TRUE;
                    break;
                }

                plfl = plfl->pNext;
            }
        }

        break;

    case ATTR_M_MATCHFILE_NAME:
        {
            PMATCHINGFILE   pMatch;

            pMatch = pEntry->pFirstMatchingFile;

            while (pMatch) {

                if (CheckIfContains(pMatch->strMatchName, pszName)) {
                    bFound = TRUE;
                    break;
                }

                pMatch = pMatch->pNext;
            }
        }

        break;

    case ATTR_M_PATCH_NAME:
        {
            PPATCH_FIX_LIST ppfl;

            ppfl = pEntry->pFirstPatch;

            while (ppfl) {

                assert(ppfl->pPatchFix);

                if (CheckIfContains(ppfl->pPatchFix->strName, pszName)) {
                    bFound = TRUE;
                    break;
                }

                ppfl = ppfl->pNext;
            }
        }

        break;

    case ATTR_M_SHIM_NAME:
        {
            //
            // For both shims and flags
            //
            PSHIM_FIX_LIST  psfl;

            psfl = pEntry->pFirstShim;

            while (psfl) {

                assert(psfl->pShimFix);

                if (CheckIfContains(psfl->pShimFix->strName, pszName)) {
                    bFound = TRUE;
                    break;
                }

                psfl = psfl->pNext;
            }

            if (bFound == FALSE) {
                //
                // Now look in flags
                //
                PFLAG_FIX_LIST  pffl;
                
                pffl = pEntry->pFirstFlag;

                while (pffl) {

                    assert(pffl->pFlagFix);

                    if (CheckIfContains(pffl->pFlagFix->strName, pszName)) {
                        bFound = TRUE;
                        break;
                    }

                    pffl = pffl->pNext;
                }
            }
        }

        break;
    }
    
    return bFound;
}

PNODE
Statement::CheckAndAddConstants(
    IN  PCTSTR  pszCurrent
    )
/*++

    Statement::CheckAndAddConstants

    Desc:   Checks if the string passed is one of the constants and if yes, then it 
            makes a node and adds it to the passed infix nodelist.
            
    Params:
        IN  PCTSTR  pszCurrent: The string that we want to check for a constant
    
    Return:
        TRUE:   The passed string was a constant and it was added to the infix nodelist
        FALSE:  Otherwise.
--*/

{
    BOOL    bFound  = FALSE; 
    PNODE   pNode   = NULL;

    for (UINT uIndex = 0; uIndex < ARRAYSIZE(Constants); ++uIndex) {

        if (lstrcmpi(Constants[uIndex].szName, pszCurrent) == 0) {
            pNode = new NODE(Constants[uIndex].dtType, Constants[uIndex].iValue);

            if (pNode == NULL) {
                MEM_ERR;
            }

            break;
        }
    }

    return pNode;
}

PNODELIST
Statement::GetShowList(
    void
    )
/*++

    Statement::GetShowList

	Desc:   Returns the attribute show list associated with a statement object
    
--*/
{
    return &AttributeShowList;
}


void
Statement::Close(
    void
    )
/*++

    Statement::Close

	Desc:   Closes the statement, removes elements from the AttributeList and closes
            the result set
    
--*/
{
    PNODE pNodeTemp = NULL;
    
    //
    // Free the show list
    //
    while (AttributeShowList.m_pHead) {

        pNodeTemp = AttributeShowList.m_pHead->pNext;
        delete AttributeShowList.m_pHead;
        AttributeShowList.m_pHead = pNodeTemp;
    }

    AttributeShowList.m_pTail = NULL;
    AttributeShowList.m_uCount = 0;

    //
    // Free the resultSelt
    //
    resultset.Close();

}
INT 
Statement::GetErrorCode(
    void
    )
/*++

    Statement::GetErrorCode

	Desc:   Returns the sql error code
    
--*/
{
    return uErrorCode;
}

void
Statement::GetErrorMsg(
    OUT CSTRING &strErrorMsg
    )
/*++

    Statement::GetErrorMsg

	Desc:   Gets the error message associated with the present error

	Params:
        OUT CSTRING &strErrorMsg

	Return: 
        void
        
--*/
{
    UINT uError = uErrorCode;

    switch (uError) {
    case ERROR_FROM_NOTFOUND:

        strErrorMsg = GetString(IDS_ERROR_FROM_NOTFOUND);
        break;

    case ERROR_IMPROPERWHERE_FOUND:
        
        strErrorMsg = GetString(IDS_ERROR_IMPROPERWHERE_FOUND);
        break;

    case ERROR_INVALID_AND_OPERANDS:
        
        strErrorMsg = GetString(IDS_ERROR_INVALID_AND_OPERANDS);
        break;

    case ERROR_INVALID_CONTAINS_OPERANDS:
        
        strErrorMsg = GetString(IDS_ERROR_INVALID_CONTAINS_OPERANDS);
        break;

    case ERROR_INVALID_DBTYPE_INFROM:
        
        strErrorMsg = GetString(IDS_ERROR_INVALID_DBTYPE_INFROM);
        break;

    case ERROR_INVALID_GE_OPERANDS:
        
        strErrorMsg = GetString(IDS_ERROR_INVALID_GE_OPERANDS);
        break;

    case ERROR_INVALID_GT_OPERANDS:
        
        strErrorMsg = GetString(IDS_ERROR_INVALID_GT_OPERANDS);
        break;

    case ERROR_INVALID_HAS_OPERANDS:
        
        strErrorMsg = GetString(IDS_ERROR_INVALID_HAS_OPERANDS);
        break;

    case ERROR_INVALID_LE_OPERANDS:

        strErrorMsg = GetString(IDS_ERROR_INVALID_LE_OPERANDS);
        break;

    case ERROR_INVALID_LT_OPERANDS:

        strErrorMsg = GetString(IDS_ERROR_INVALID_LT_OPERANDS);
        break;
    case ERROR_INVALID_OR_OPERANDS:

        strErrorMsg = GetString(IDS_ERROR_INVALID_OR_OPERANDS);
        break;

    case ERROR_INVALID_SELECTPARAM:

        strErrorMsg = GetString(IDS_ERROR_INVALID_SELECTPARAM);
        break;

    case ERROR_OPERANDS_DONOTMATCH:

        strErrorMsg = GetString(IDS_ERROR_OPERANDS_DONOTMATCH);
        break;

    case ERROR_SELECT_NOTFOUND:

        strErrorMsg = GetString(IDS_ERROR_SELECT_NOTFOUND);
        break;

    case ERROR_STRING_NOT_TERMINATED:

        strErrorMsg = GetString(IDS_ERROR_STRING_NOT_TERMINATED);
        break;

    case ERROR_PARENTHESIS_COUNT:

        strErrorMsg = GetString(IDS_ERROR_PARENTHESIS_COUNT);
        break;

    case ERROR_WRONGNUMBER_OPERANDS:

        strErrorMsg = GetString(IDS_ERROR_WRONGNUMBER_OPERANDS);
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// 
//
//  The ResultSet Class member functions
//
//
///////////////////////////////////////////////////////////////////////////////

void
ResultSet::AddAtLast(
    IN  PRESULT_ITEM pNew
    )
/*++

    ResultSet::AddAtLast

	Desc:   Adds a new PRESULT_ITEM to the end of the result-set

	Params:
        IN  PRESULT_ITEM pNew: The PRESULT_ITEM to add

	Return:
        void
        
--*/
{
    if (pNew == NULL) {
        assert(FALSE);
        return;
    }

    pNew->pNext = NULL;

    if (m_pResultLast) {

        pNew->pPrev = m_pResultLast;
        m_pResultLast->pNext = pNew;
        m_pResultLast = pNew;

    } else {

        m_pResultHead = m_pResultLast = pNew;
    }

    m_uCount++;
}

void
ResultSet::AddAtBeg(
    PRESULT_ITEM pNew
    )
/*++

    ResultSet::AddAtBeg

	Desc:   Adds a new PRESULT_ITEM to the beginning of the result-set

	Params:
        IN  PRESULT_ITEM pNew: The PRESULT_ITEM to add

	Return:
        void
        
--*/
{
    if (m_pResultHead) {

        m_pResultHead->pPrev = pNew;
    }

    pNew->pNext = m_pResultHead;
    m_pResultHead = pNew;

    if (m_pResultLast == NULL) {
        m_pResultLast = pNew;
    }

    m_uCount++;
}

INT
ResultSet::GetRow(
    IN  PRESULT_ITEM pResultItem,
    OUT PNODE        pArNodes
    )
/*++

    ResultSet::GetRow
    
    Desc:   For the pResultItem, gets the row of the values.
            Caller must free that after use.
    
    Params:        
        IN  PRESULT_ITEM pResultItem:   The PRESULT_ITEM for which we want the row
        OUT PNODE        pArNodes:      The pointer to an array of Statement::AttributeShowList::m_uCount
            nodes. (This is the number of attributes that are in the SELECT clause)
    
    Return: Number of items in the row. This should be equal to the number of attributes that 
            are in the SELECT clause 
    
--*/
{
    PNODE   pNodeTemp   = NULL;
    UINT    uIndex      = 0;

    if (m_pShowList == NULL || m_pShowList->m_uCount == 0) {

        assert(FALSE);
        return 0;
    }

   for (uIndex = 0, pNodeTemp = m_pShowList->m_pHead;
        pNodeTemp; 
        pNodeTemp = pNodeTemp->pNext, ++uIndex) {

        pArNodes[uIndex].dtType     = DT_ATTRSHOW;
        pArNodes[uIndex].attrShow   = pNodeTemp->attrShow;

        SetValuesForOperands(pResultItem->pDatabase, 
                             pResultItem->pEntry, 
                             &pArNodes[uIndex]);
    }

    assert(uIndex == m_pShowList->m_uCount);
    return m_pShowList->m_uCount;
}

void
ResultSet::SetShowList(
    IN  PNODELIST pShowList
    )
/*++

    ResultSet::SetShowList

	Desc:   Sets the show attributes list pointer for the result set. This in fact
            points to the show attributes list of the statement
            
	Params: 
        IN  PNODELIST pShowList: Pointer to the show attributes list

	Return:
        void
--*/
{
    m_pShowList = pShowList;
}

PRESULT_ITEM
ResultSet::GetCursor(
    void
    )
/*++

    ResultSet::GetCursor

	Desc:   The present cursor. The result set comprises  of PRESULT_ITEM, this function
            returns the present PRESULT_ITEM
    
--*/

{
    return m_pCursor;
}

INT
ResultSet::GetCurrentRow(
    OUT PNODE   pArNodes
    )
/*++

    ResultSet::GetCurrentRow

	Desc:   Gets the row (values for the attributes in the show list), 
            for the present cursor. The result set comprises  of PRESULT_ITEM, 
            this function returns the values of the attributes in the SELECT clause
            (the show list) for the present PRESULT_ITEM

	Params:
        OUT PNODE   pArNodes:   The pointer to an array of 
            Statement::AttributeShowList::m_uCount nodes. 
            (This is the number of attributes that are in the SELECT clause) 

	Return: Number of items in the row. This should be equal to the number of attributes that 
            are in the SELECT clause 
    
--*/
{
    
    return GetRow(m_pCursor, pArNodes);
}

PRESULT_ITEM
ResultSet::GetNext(
    void
    )
/*++

    ResultSet::GetNext

	Desc:   The next cursor if cursor is not NULL, otherwise sets cursor to the first
            item in the result set and returns it

	Notes:  Initially the cursor is NULL, meaning parked before the first result 
            item. Result items are of type PRESULT_ITEM
--*/
{

    if (m_pCursor) {

        m_pCursor =  m_pCursor->pNext;
        return m_pCursor;

    } else {
        return m_pCursor = m_pResultHead;
    }
}

void
ResultSet::Close(
    void
    )
/*++

    ResultSet::Close

	Desc:   Deletes all the items in the result set
    
--*/
{
    PRESULT_ITEM pResult;

    while (m_pResultHead) {

        pResult = m_pResultHead->pNext;
        delete m_pResultHead;
        m_pResultHead = pResult;
    }

    m_pCursor = m_pResultHead = m_pResultLast = NULL;
    m_uCount = 0;
}

INT
ResultSet::GetCount(
    void
    )
/*++

    ResultSet::GetCount

	Desc:   Returns the number of results in the result set
   
	Return: The number of results in the result set
--*/
{
    return m_uCount;
}


///////////////////////////////////////////////////////////////////////////////
// 
//
// NODE functions
//
//
///////////////////////////////////////////////////////////////////////////////


TCHAR*
NODE::ToString(
    OUT TCHAR* pszBuffer,
    IN  UINT   chLength 
    )
/*++

    NODE::ToString

	Desc:   Converts the data for a node into a string type, so that we can display
            that in a list view

	Params:
        OUT TCHAR* pszBuffer:   The buffer in which we wanwt to put the string
        IN  UINT   chLength:    Length of the buffer in characters

	Return: Pointer to pszBuffer
--*/

{
    switch (dtType) {
    case DT_LITERAL_SZ:

        SafeCpyN(pszBuffer, szString, chLength);
        break;

    case DT_LITERAL_BOOL:

        if (bData) {
            SafeCpyN(pszBuffer, GetString(IDS_YES), chLength);
        } else {
            SafeCpyN(pszBuffer, GetString(IDS_NO), chLength);
        }

        break;

    case DT_LITERAL_INT:

        assert(chLength > 32);
        _itot(iData, pszBuffer, 10);
        break;

    case DT_ATTRSHOW:
        
        for (UINT uIndex = 0; uIndex < ARRAYSIZE(AttributeShowMapping); ++uIndex) {

            if (AttributeShowMapping[uIndex].attr == attrShow) {
                GetString(AttributeShowMapping[uIndex].iResourceId, pszBuffer, chLength);
                break;
            }
        }
        
        break;

    case DT_ATTRMATCH:
        
        for (UINT uIndex = 0; uIndex < ARRAYSIZE(AttributeMatchMapping); ++uIndex) {

            if (AttributeMatchMapping[uIndex].attr == attrShow) {

                SafeCpyN(pszBuffer, 
                         AttributeMatchMapping[uIndex].szAttribute, 
                         chLength);
                break;
            }
        }
        
        break;
    }

    return pszBuffer;
}

INT
GetSelectAttrCount(
    void
    )
/*++
    
    GetSelectAttrCount
    
    Desc:   Gets the count of total available attributes that can be put in the SELECT clause of SQL
    
    Return: The count of total available attributes that can be put in the SELECT clause of SQL 
--*/
{
    return ARRAYSIZE(AttributeShowMapping);
}

INT
GetMatchAttrCount(
    void
    )
/*++

    GetMatchAttrCount
    
    Desc:   Gets the count of total available attributes that can be put in the WHERE clause of SQL
    
    Return: The count of total available attributes that can be put in the WHERE clause of SQL
--*/
{
    return ARRAYSIZE(AttributeMatchMapping);
}


BOOL
CheckIfContains(
    IN      PCTSTR  pszString,
    IN  OUT PTSTR   pszMatch
    )
/*++
    CheckIfContains

	Desc:	Checks if string pszMatch is contained in string pszString. 
            Use wild cards for specifying sub-string matching
            The wild card character is %. So if we do CheckIfContains(L"Hello world", "Hello") this 
            will be false, but if we do CheckIfContains(L"Hello world", "Hello%") this 
            will be true

	Params:
        IN      PCTSTR pszString:   The string to search into
        IN  OUT PCTSTR pszMatch:    The string to search for in the above string    

	Return:
        TRUE:   pszMatch exists in pszString
        FALSE:  Otherwise
        
    Note:   Comparison is NOT case sensitive
    
--*/
{

    if (pszString == NULL) {
        return FALSE;
    }

    if (pszMatch == NULL) {
        assert(FALSE);
        return FALSE;
    }

    if (*pszMatch == NULL) {
        return TRUE;
    }

    BOOL    fCheckSuffix    = FALSE, fCheckPrefix = FALSE, fResult = FALSE;
    TCHAR*  pchLastPosition = NULL;
    TCHAR*  pszTempMatch    = NULL;
    K_SIZE  k_size          = lstrlen(pszMatch) + 1;

    pszTempMatch = new TCHAR[k_size];

    if (pszTempMatch == NULL) {
        MEM_ERR;
        return FALSE;
    }

    SafeCpyN(pszTempMatch, pszMatch, k_size);
    
    CSTRING::Trim(pszTempMatch);

    fCheckSuffix = (pszTempMatch[0] == TEXT('%'));

    //
    // Only % ?
    //
    if (fCheckSuffix && pszTempMatch[1] == 0) {
        fResult = TRUE;
        goto End;
    }
    
    pchLastPosition = _tcschr(pszTempMatch + 1, TEXT('%'));

    if (pchLastPosition) {  
        fCheckPrefix = TRUE;
        *pchLastPosition = 0; // Remove the last %
    }

    if (fCheckPrefix && !fCheckSuffix) {
        fResult = CSTRING::StrStrI(pszString, pszTempMatch) == pszString ? TRUE : FALSE;

    } else if (fCheckSuffix && !fCheckPrefix) {
        fResult = CSTRING::EndsWith(pszString, pszTempMatch + 1);

    } else if (fCheckPrefix && fCheckSuffix) { 
        fResult = CSTRING::StrStrI(pszString, pszTempMatch + 1) != NULL ? TRUE : FALSE;

    } else {                                   
        fResult = lstrcmpi(pszString, pszTempMatch) == 0 ? TRUE : FALSE;
    }
    
    if (fCheckPrefix) {
        //
        // Revert back the last character, the match string might be used for further searches 
        //
        *pchLastPosition = TEXT('%'); 
    }

End:
    if (pszTempMatch) {
        delete[] pszTempMatch;
        pszTempMatch = NULL;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\wizard.h ===
#ifndef __WIZARD_H
#define __WIZARD_H


#include "resource.h"    

//////////////////////// Defines //////////////////////////////////////////////

// The maximum number of files that can be added when we are using auto-generate
#define MAX_AUTO_MATCH      7

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Enums /////////////////////////////////////////////

/*++

    The types of wizards for making fixes or apphelp
    
--*/
enum {
    TYPE_FIXWIZARD      = 0,    // The wizard is used for creating an app-fix
    TYPE_APPHELPWIZARD          // The wizard is used for creatign an app help
};

///////////////////////////////////////////////////////////////////////////////

/*++

    class CShimWizard
    
	Desc:	    The shim wizard. The apphelp wizard is subclasses from this.
                Make a object of this and call BeginWizard() to start the wizard

	Members:
        UINT        m_uType:            The type of the wizard, one of TYPE_FIXWIZARD or TYPE_APPHELPWIZARD
        DBENTRY     m_Entry:            This will be entry on which the wizard works.
            If we are creating a new fix, then after the wizard ends, we create a new entry and assign m_Entry
            to that. If we are editing an existing wizard we first of all assign the entry being
            edited to m_Entry. The assignment operator for DBENTRY is overloaded
                
        BOOL        m_bEditing:         Are we creating a new entry or editing an existing one?
        DWORD       dwMaskOfMainEntry:  Matching attributes used for the main entry
        PDATABASE   m_pDatabase:        The presently selected database. The entry being
            edited lives here or if we are creatign a new fix or apphelp then the new
            entry will be placed here 

--*/

class CShimWizard {
public:
    
    UINT        m_uType;                
    DBENTRY     m_Entry;                
    BOOL        m_bEditing;
    DWORD       dwMaskOfMainEntry;
    PDATABASE   m_pDatabase;

public:

    void     WipeEntry(BOOL bMatching, BOOL bShims, BOOL bLayers, BOOL bFlags);
    void     GrabMatchingInfo(HWND hdlg);
    void     WalkDirectory(PMATCHINGFILE* pMatchileFileListHead,LPCTSTR szDirectory, int nDepth);
    BOOL     BeginWizard(HWND hParent, PDBENTRY pEntry, PDATABASE pDatabase, PBOOL pbShouldStartLUAWizard);
    BOOL     CheckAndSetLongFilename(HWND hDlg, INT iStrID);

    CShimWizard();
};


BOOL
CALLBACK
GetAppName(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    );

BOOL 
CALLBACK 
GetFixes(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    );


INT_PTR
CALLBACK
SelectFiles(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    );

INT_PTR 
CALLBACK 
ParamsDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void
ShowSelected(
    HWND hdlg
    );

BOOL
HandleShimsNext(
    HWND hdlg
    );


BOOL
ShimPresentInLayersOfEntry(
    PDBENTRY            pEntry,
    PSHIM_FIX           psf,
    PSHIM_FIX_LIST*     ppsfList = NULL,
    PLAYER_FIX_LIST*    pplfList = NULL
    );

BOOL
FlagPresentInLayersOfEntry(
    PDBENTRY            pEntry,
    PFLAG_FIX           pff,
    PFLAG_FIX_LIST*     ppffList = NULL, 
    PLAYER_FIX_LIST*    pplfl    = NULL
    );

void
ShowItems(
    HWND hDlg
    );

INT_PTR
CALLBACK 
SelectLayer(
           HWND hDlg, 
           UINT uMsg, 
           WPARAM wParam, 
           LPARAM lParam
           );

BOOL
HandleLayersNext(
    HWND            hdlg,
    BOOL            bCheckAndAddLua,
    CSTRINGLIST*    pstrlShimsAdded = NULL
    );

void
SetMask(
    HWND hwndTree
    );
void
CheckLayers(
    HWND    hwndList
    );

void
ChangeShimFlagIcons(
    HWND            hdlg,
    PLAYER_FIX_LIST plfl
    );

BOOL
HandleShimDeselect(
    HWND    hdlg,
    INT     iIndex
    );

BOOL
HandleLayerListNotification(
    HWND    hdlg,
    LPARAM  lParam
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\sqldriver.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    SQLDriver.h

Abstract:

    Header for the core sql driver: SQLDriver.cpp
        
Author:

    kinshu created  Oct. 26, 2001

--*/


#ifndef _SQLDRIVER_H

#define _SQLDRIVER_H

extern struct DataBase  GlobalDataBase;    

/*++

  The different data types used in sql
 
--*/
typedef enum
{
    DT_UNKNOWN = 0,         // This is an erroneous data type
    DT_LITERAL_SZ,          // String data type
    DT_LITERAL_INT,         // Integer data type
    DT_LITERAL_BOOL,        // Boolean data type
    DT_ATTRMATCH,           // Attributes that appear in the WHERE clause
    DT_ATTRSHOW,            // Attributes that appear in the SELECT clause
    DT_LEFTPARANTHESES,     // The left parenthesis
    DT_RIGHTPARANTHESES,    // The right parenthesis
    DT_OPERATOR             // An operator

}DATATYPE;

/*++

    The different types operators allowed in our SQL

--*/
typedef enum{

    OPER_GT = 0,            // >
    OPER_LT,                // <
    OPER_GE,                // >=
    OPER_LE,                // <=

    OPER_NE,                // <>
    OPER_EQUAL,             // =
    OPER_CONTAINS,          // This is not used

    OPER_OR,                // OR
    OPER_AND,               // AND

    OPER_HAS                // HAS operaor. The HAS operator is required because there can be some attributes which are multi-valued
                            // For these attributes, we might wish to know, if it 'has' a particular string
                            // The attributes for which the HAS operator can be applied are:
                            // layer name, shim name and matching file name. Trying to use any other operand as the
                            // left side operand will give a sql error

} OPERATOR_TYPE;

/*++

    The various errors that we might encounter

--*/
typedef enum{

    ERROR_NOERROR = 0,                  // There is no error
    ERROR_SELECT_NOTFOUND,              // SQL does not have SELECT
    ERROR_FROM_NOTFOUND,                // SQL does not have FROM
    ERROR_IMPROPERWHERE_FOUND,          // Improper WHERE clause
    ERROR_STRING_NOT_TERMINATED,        // A string was not terminated with ". e.g "Hello
    ERROR_OPERANDS_DONOTMATCH,          // For some operator the operand types do not match 
    ERROR_INVALID_AND_OPERANDS,         // One or both of the operands is not boolean
    ERROR_INVALID_OR_OPERANDS,          // One or both of the operands is not boolean
    ERROR_INVALID_GE_OPERANDS,          // One or both of the operands are of type boolean
    ERROR_INVALID_GT_OPERANDS,          // One or both of the operands are of type boolean
    ERROR_INVALID_LE_OPERANDS,          // One or both of the operands are of type boolean
    ERROR_INVALID_LT_OPERANDS,          // One or both of the operands are of type boolean
    ERROR_INVALID_HAS_OPERANDS,         // The rhs of HAS should be a string and the lhs should be one of: 
                                        // layer name, shim name or matching file name

    ERROR_INVALID_CONTAINS_OPERANDS,    // Both operands of contains should be strings. Contains in not supported as yet
    ERROR_INVALID_SELECTPARAM,          // Unknown attribute used in SELECT clause
    ERROR_INVALID_DBTYPE_INFROM,        // Unknown database type in FROM clause
    ERROR_PARENTHESIS_COUNT,            // The parenthesis count do not match
    ERROR_WRONGNUMBER_OPERANDS,         // We found an operator but not sufficient number of operands for that
    ERROR_GUI_NOCHECKBOXSELECTED        // This is a gui error and will come before we even start with SQL. 
                                        // This particular error means that in the in the second tab page, 
                                        // user did not select any check boxes

}ERROR_CODES;

/*++

    An operator is actually described by its type and its precedence

--*/
typedef struct _tagOperator
{
    OPERATOR_TYPE operator_type;
    UINT          uPrecedence;
} OPERATOR;


/*++

    All the attributes that can come with the SELECT clause.
    See struct _tagAttributeShowMapping AttributeShowMapping in SQLDriver.cpp
    for the actual names of the attributes

--*/
typedef enum { 

    ATTR_S_APP_NAME = 100,              // The name of the app e.g "Caesar"

    ATTR_S_ENTRY_EXEPATH,               // The name of the entry e.g. "Setup.exe"
    ATTR_S_ENTRY_DISABLED,              // Whether this entry is disabled
    ATTR_S_ENTRY_GUID,                  // The guid for the entry
    ATTR_S_ENTRY_APPHELPTYPE,           // The type of apphelp.
    ATTR_S_ENTRY_APPHELPUSED,           // Whether this entry has been app-helped
    ATTR_S_ENTRY_SHIMFLAG_COUNT,        // Number of shims and flags that have applied to an entry
    ATTR_S_ENTRY_PATCH_COUNT,           // Number of patches that have been applied to an entry
    ATTR_S_ENTRY_LAYER_COUNT,           // Number of layers that have been applied to an entry
    ATTR_S_ENTRY_MATCH_COUNT,           // Number of matching files for an entry

    ATTR_S_DATABASE_NAME,               // Name of the database
    ATTR_S_DATABASE_PATH,               // The path of the database
    ATTR_S_DATABASE_INSTALLED,          // Whether this database is installed
    ATTR_S_DATABASE_GUID,               // Guid for the database

    ATTR_S_SHIM_NAME,                   // Multivalued-attribute: Shims applied to an entry
    ATTR_S_MATCHFILE_NAME,              // Multivalued-attribute: Matching files for an entry
    ATTR_S_LAYER_NAME,                  // Multivalued-attribute: layers applied to an entry
    ATTR_S_PATCH_NAME                   // Multivalued-attribute: Patches applied to an entry


} ATTRIBUTE_SHOW;

/*++

    All the attributes that can come with the SELECT clause.
    See struct _tagAttributeShowMapping AttributeShowMapping in SQLDriver.cpp
    for the actual names of the attributes

--*/
typedef enum{

    ATTR_M_APP_NAME = 0,                // The name of the app e.g "Caesar"                          
                                                                                                   
    ATTR_M_ENTRY_EXEPATH,               // The name of the entry e.g. "Setup.exe"                    
    ATTR_M_ENTRY_DISABLED,              // Whether this entry is disabled                            
    ATTR_M_ENTRY_GUID,                  // The guid for the entry                                    
    ATTR_M_ENTRY_APPHELPTYPE,           // The type of apphelp.                                      
    ATTR_M_ENTRY_APPHELPUSED,           // Whether this entry has been app-helped                    
    ATTR_M_ENTRY_SHIMFLAG_COUNT,        // Number of shims and flags that have applied to an entry   
    ATTR_M_ENTRY_PATCH_COUNT,           // Number of patches that have been applied to an entry      
    ATTR_M_ENTRY_LAYER_COUNT,           // Number of layers that have been applied to an entry       
    ATTR_M_ENTRY_MATCH_COUNT,           // Number of matching files for an entry                     

    // These are the 4 attributes that can come on the LHS of HAS operator

    ATTR_M_SHIM_NAME,                   // The name of a shim/flag
    ATTR_M_MATCHFILE_NAME,              // Name of a matching file
    ATTR_M_LAYER_NAME,                  // Name of a layer
    ATTR_M_PATCH_NAME,                  // Name of a patch

    ATTR_M_DATABASE_NAME,               // Name of the database               
    ATTR_M_DATABASE_PATH,               // The path of the database           
    ATTR_M_DATABASE_INSTALLED,          // Whether this database is installed 
    ATTR_M_DATABASE_GUID                // Guid for the database              

} ATTRIBUTE_MATCH;

/*++

    Maps the string name of an SELECT attribute with its type
  
--*/
struct _tagAttributeShowMapping
{
    TCHAR*          szAttribute;        // The name of the attribute as in our  SQL
    ATTRIBUTE_SHOW  attr;               // The id of this attribute
    INT             iResourceId;        // The display name of this attribute
}; 

/*++

    Maps the string name of an WHERE attribute with its type
  
--*/
struct _tagAttributeMatchMapping
{
    TCHAR*          szAttribute;        // The name of the attribute as in our  SQL
    ATTRIBUTE_MATCH attr;               // The id of this attribute
};

/*++

    Maps the string name of an operator with its type and precedence

--*/
struct _tagOperatorMapping
{
    TCHAR*          szOperator;     // The name of this operator
    OPERATOR_TYPE   op_type;        // The id of this operator
    UINT            uPrecedence;    // Precedence of this operator
};


/*++
    Maps the string name of the database types with proper db TYPE which are:

    DATABASE_TYPE_GLOBAL,   
    DATABASE_TYPE_INSTALLED,
    DATABASE_TYPE_WORKING   

--*/
struct _tagDatabasesMapping
{
    TCHAR* szDatabaseType;      // The name of the database type as in our SQL
    TYPE   dbtype;              // The id of this database type
};

/*++

    The constants used in our SQL

--*/
struct _tagConstants
{
    TCHAR*      szName; // The name of the constant, e.g TRUE, FALSE
    DATATYPE    dtType; // The type of the contant
    INT         iValue; // The value ofthe contant, e.g TRUE = 1, FALSE = 0
};

/*++

 A node. The prefix and post fix expressions are linked lists of this type. Also a row
 of results will be an array of this type

--*/
typedef struct _tagNode
{
    //
    // The type of data that this node contains. Based on this filed, one of the 
    // fields in the anonymouse union should be used
    //
    DATATYPE    dtType;

    union{

        int             iData;      // Integer data
        BOOL            bData;      // Boolean data
        ATTRIBUTE_MATCH attrMatch;  // An attribute that might appear in the WHERE clause
        ATTRIBUTE_SHOW  attrShow;   // An attribute that might appear in the SELECT clause 

        OPERATOR        op;         // An operator
        TCHAR*          szString;   // A string
    };
    struct _tagNode* pNext;

    TCHAR*
    ToString(
        TCHAR* szBuffer,
        UINT   chLength
        );


    _tagNode()
    {
        dtType      = DT_UNKNOWN;
        szString    = NULL;

    }

    ~_tagNode()
    {
        if (dtType == DT_LITERAL_SZ && szString) {

            delete[] szString;
        }
    }
    _tagNode(
        DATATYPE    dtTypeParam, 
        LPARAM      lParam
        )
    {

        switch (dtTypeParam) {    
        case DT_OPERATOR:
            {
                op = *(OPERATOR *)lParam;
                break;
            }
        case DT_ATTRMATCH:
            {
                this->attrMatch = (ATTRIBUTE_MATCH)lParam;
                break;
            }
        case DT_ATTRSHOW:
            {
                this->attrShow = (ATTRIBUTE_SHOW)lParam;
                break;
            }

        case DT_LEFTPARANTHESES:
        case DT_RIGHTPARANTHESES:

            break;
        case DT_LITERAL_INT:
            {
                this->iData = (INT)lParam;
                break;
            }
        case DT_LITERAL_BOOL:
            {
                this->bData = (BOOL)lParam;
                break;
            }

        case DT_LITERAL_SZ:
            {
                K_SIZE  k_size_szString = lstrlen((TCHAR*)lParam) + 1;

                szString = new TCHAR [k_size_szString];

                if (szString) {
                    SafeCpyN(szString, (TCHAR*)lParam, k_size_szString);
                } else {
                    MEM_ERR;
                    Dbg(dlError, "_tagNode Unable to allocate memory");
                }
                
                break;
            }

        default:
            assert(FALSE);
        }

        dtType = dtTypeParam;
    }

    void
    SetString(
        PCTSTR  pszDataParam
        )
    {
        K_SIZE k_size_szString = lstrlen(pszDataParam) + 1;

        if (dtType == DT_LITERAL_SZ &&  szString) {
            delete[] szString;
            szString = NULL;
        }

        szString = new TCHAR[k_size_szString];

        if (szString == NULL) {
            MEM_ERR;
            return;
        }

        SafeCpyN(szString, pszDataParam, k_size_szString);

        dtType = DT_LITERAL_SZ; 
    }

} NODE, *PNODE;


BOOL
Filter(
    IN PDBENTRY pEntry,
    PNODE       m_pHead
    );

/*++

    List of nodes. PostFix expressions, PreFix Expressions and the Stack are of this tyye

--*/
typedef struct _tagNODELIST
{
    PNODE m_pHead;      // The head of the list
    PNODE m_pTail;      // The tail of the list
    UINT  m_uCount;     // The number of elements in the list

    _tagNODELIST()
    {
        m_pHead = m_pTail = NULL;
        m_uCount = 0;
    }

    ~_tagNODELIST()
    {
        RemoveAll();
    }

    void
    RemoveAll()
    {
        PNODE pTemp = NULL;

        while (m_pHead) {

            pTemp = m_pHead->pNext;
            delete m_pHead;
            m_pHead = pTemp;
        }

        m_pTail = NULL;
        m_uCount = 0;
    }

    void
    AddAtBeg(
        PNODE pNew
        )
    {
        if (pNew == NULL) {
            assert(FALSE);
            return;
        }

        pNew->pNext = m_pHead;
        m_pHead = pNew;

        if (m_uCount == 0) {
            m_pTail = m_pHead;
        }

        ++m_uCount;
    }

    void
    AddAtEnd(
        PNODE pNew
        )
    {
        if (pNew == NULL) {
            assert(FALSE);
            return;
        }

        pNew->pNext = NULL;
        if (m_pTail) {

            m_pTail->pNext = pNew;
            m_pTail = pNew;
        }else{

            m_pHead = m_pTail = pNew;
        }

        ++m_uCount;
    }

    void
    Push(
        PNODE pNew
        )
    {
        AddAtBeg(pNew);
    }

    PNODE
    Pop(
        void
        )
    {
        PNODE pHeadPrev = m_pHead;

        if (m_pHead) {

            m_pHead = m_pHead->pNext;
            --m_uCount;
        }

        if (m_pHead == NULL) {
            m_pTail = NULL;
        }

        return pHeadPrev;
    }


   
}NODELIST, *PNODELIST;


/*++
    struct _tagResultItem
    
    Desc:   A result item list. After we have checked that an entry (PDBENTRY) in a database 
            (PDATABASE) satisfies the post fix expression:
            We make a RESULT_ITEM from the entry and the database and add this to the 
            Statement::resultSet so the resultset actually contains only two things the 
            pointer to the entry and the pointer to the database. When we actually need 
            the values of the various attributes in the show list
            (The show list is the linked list of PNDOE, created from the attributes in the 
            SELECT clause), we call GetRow(), giving it the pointer to the result-item and
            a pointer to an array of PNODE (It should be large enough to hold all the attributes
            as in the show list), Get Row will populate the array with the proper values for
            all the attributes in the show list
            
            The result item list is implemented as a double linked list
--*/

typedef struct _tagResultItem
{
    PDATABASE               pDatabase;   // The database for this result item
    PDBENTRY                pEntry;      // The entry for this result item
    struct _tagResultItem*  pNext;       // The next result item
    struct _tagResultItem*  pPrev;       // The previous result item

    _tagResultItem()
    {
        pDatabase = NULL;
        pEntry    = NULL;
        pNext = pPrev = NULL;
    }

    _tagResultItem(
        PDATABASE pDatabase,
        PDBENTRY  pEntry
        )
    {
        this->pDatabase = pDatabase;
        this->pEntry    = pEntry;

        pNext = pPrev = NULL;
    }

}RESULT_ITEM, *PRESULT_ITEM;

/*++
    class ResultSet
    
    Desc:   The result set contains the pointer to the show list (set of attributes in the SELECT clause),
            and the pointers to the first and the last result items
--*/

class ResultSet
{
    PNODELIST    m_pShowList;       // Items that are to be shown.
    PRESULT_ITEM m_pResultHead;     // Pointer to the first result item
    PRESULT_ITEM m_pResultLast;     // Pointer to the first result item
    UINT         m_uCount;          // Number of results
    PRESULT_ITEM m_pCursor;         // Pointer to the present result-item

public:
    ResultSet()
    {
        m_pResultLast = m_pResultHead = NULL;
        m_pCursor     = NULL;
        m_pShowList   = NULL;  
        m_uCount      = 0;
    }

    INT
    GetCount(
        void
        );

    void
    AddAtLast(
        PRESULT_ITEM pNew
        );

    void
    AddAtBeg(
        PRESULT_ITEM pNew
        );

    PRESULT_ITEM
    GetNext(
        void
        );

    INT
    GetRow(
        PRESULT_ITEM pResultItem,
        PNODE        pArNodes
        );
    INT
    GetCurrentRow(
        PNODE pArNodes
        );

    PRESULT_ITEM    
    GetCursor(
        void
        );


    void
    SetShowList(
        PNODELIST pShowList
        );

    void
    Close(
        void
        );
    

};

/*++
    class Statement
    
    Desc:   The statement. This is the interface to the sqldriver and we execute a SQL string
            by calling Statement::ExecuteSQL(), which will return a pointer to the internal
            ResultSet.
            
            Please call Statement.Init() before starting and call Statement.Close() when you have
            finished with using the results
--*/

class Statement
{
    NODELIST    AttributeShowList;  // The show list(set of attributes in the SELECT clause)
    UINT        m_uCheckDB;         // Which databases have to be checked. Will be a value 
                                    // -made up ORing the DATABASE_TYPE_*

    UINT        uErrorCode;         // The error codes         
    ResultSet   resultset;          // The result set obtained by executing the sql.

    BOOL 
    CreateAttributesShowList(
        TCHAR* szSQL,
        BOOL*  pbFromFound
        );

    PNODELIST
    CreateInFix(
        LPTSTR szWhere
        );

    PNODELIST
    CreatePostFix(
        PNODELIST pInfix
        );

    BOOL
    EvaluatePostFix(
        PNODELIST pPostFix
        );

    BOOL
    FilterAndAddToResultSet(
        PDATABASE pDatabase,
        PDBENTRY  pEntry,
        PNODELIST pPostfix
        );

    BOOL
    ApplyHasOperator(
        PDBENTRY    pEntry,
        PNODE       pOperandLeft,
        PTSTR       pszName
        );

    PNODE
    CheckAndAddConstants(
        PCTSTR  pszToken
        );

    PNODE
    Evaluate(
        PDATABASE   pDatbase,
        PDBENTRY    pEntry,  
        PNODE       pOperandLeft,
        PNODE       pOperandRight,
        PNODE       pOperator
        );

    BOOL
    ProcessFrom(
        TCHAR** ppszWhere
        );

    void
    SelectAll(
        void
        );

public:

    HWND        m_hdlg;

    Statement()
    {
        Init();
    }

    void
    SetWindow(
        HWND hWnd
        );
    
    void
    Init(
        void
        )
    {
        m_uCheckDB = 0;
        m_hdlg     = NULL;     
        uErrorCode = ERROR_NOERROR;

        resultset.Close();
        AttributeShowList.RemoveAll();
    }

    ResultSet*
    ExecuteSQL(
        HWND    hdlg,
        PTSTR   szSQL
        );

    PNODELIST
    GetShowList(
        void
        );

    void
    Close(
        void
        );

    inline
    INT 
    GetErrorCode(
        void
        );
    
    void
    GetErrorMsg(
        CSTRING &strErrorMsg
        );

};


BOOL
SetValuesForOperands(
    PDATABASE pDatabase,
    PDBENTRY  pEntry,
    PNODE     pOperand
    );

INT
GetSelectAttrCount(
    void
    );

INT 
GetMatchAttrCount(
    void
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CompatAdmin.rc
//
#define IDI_APPICON                     11
#define IDI_SEARCH_DRIVE                46
#define IDD_DIALOG                      101
#define IDR_MENU                        103
#define IDI_FIXES                       104
#define IDI_HELP                        109
#define IDD_OPTIONS                     109
#define IDI_MODE                        110
#define IDD_MSGBOX_SDB                  111
#define IDI_EXCLAIM                     112
#define IDI_PATCHES                     114
#define IDI_MATCHGROUP                  117
#define IDD_CUSTOMLAYER                 119
#define IDD_TESTRUN                     120
#define IDD_WAIT                        121
#define IDD_FIXWIZ_MODES                123
#define IDD_FIXWIZ_APPINFO              124
#define IDI_INCLUDE                     125
#define IDI_EXCLUDE                     126
#define IDD_FIXWIZ_SHIMS                128
#define IDD_FIXWIZ_MATCHINGINFO         130
#define IDI_GLOBAL                      133
#define IDI_LOCAL                       134
#define IDB_WIZBMP                      135
#define IDD_SELECTLAYER                 135
#define IDI_NEWFIX                      137
#define IDD_HELPWIZ_TYPE                145
#define IDR_CONTEXT                     146
#define IDD_HELPWIZ_MESSAGE             146
#define IDI_REPLACE                     146
#define IDD_HELPWIZ_APPINFO             147
#define IDI_NEWMODE                     151
#define IDI_RUN                         160
#define IDS_OPEN                        177
#define IDS_SAVE                        178
#define IDS_CUSTOMAPPHELP               179
#define IDS_GIVEAPPINFO                 180
#define IDS_GIVEAPPINFOSUBHEADING       181
#define IDS_MESSAGETYPE                 182
#define IDS_MESSAGEINFO                 183
#define IDD_SEARCH                      184
#define IDS_APPHELPCREATED              184
#define IDS_PATHENTERED1                185
#define IDS_NONAME                      186
#define IDS_ERROR_NOFILE                187
#define IDS_UNKNOWN                     188
#define IDS_NONE                        189
#define IDB_SEARCH                      190
#define IDS_FINDEXECUTABLE              190
#define IDS_NOBLOCK                     191
#define IDS_HARDBLOCK                   192
#define IDS_MINORPROBLEM                193
#define IDB_TOOL                        194
#define IDS_REINSTALL                   194
#define IDS_COMPATADMIN                 195
#define IDS_SYSDB                       196
#define IDS_APPS                        197
#define IDI_INSTALLED                   198
#define IDS_WORKDB                      198
#define IDS_COMPATMODES                 199
#define IDI_DATABASE                    200
#define IDS_INSTALLEDDB                 200
#define IDS_COMMANDLINE                 201
#define IDS_COMPATFIXES                 202
#define IDI_DISABLED                    203
#define IDS_NEWDATABASE                 203
#define IDS_CHANGEDBNAME                204
#define IDI_SINGLEAPP                   205
#define IDS_DEFCAPTION                  205
#define IDI_CMDLINE                     206
#define IDS_COMPATPATCHES               206
#define IDS_MATCHINGFILES               207
#define IDI_APP                         208
#define IDS_ASKSAVE                     208
#define IDS_CAPTION2                    209
#define IDS_OPENDATABASE                210
#define IDS_FILTER                      211
#define IDS_LAYERCONFLICT               212
#define IDS_PATHENTERED2                213
#define IDB_CHECK                       214
#define IDS_CAPTION3                    214
#define IDS_UNABLETO_OPEN               215
#define IDS_DISABLE                     216
#define IDS_ENABLE                      217
#define IDS_DATABASETOREMOVE            218
#define IDS_ERRORUNINSTALL              219
#define IDS_EXISTS                      220
#define IDS_COULDNOTREMOVE              221
#define IDS_ONENTRYDISABLED             222
#define IDS_ONENTRYENABLED              223
#define IDS_NOTSAVEDBEFOREINSTALL       224
#define IDS_COULDNOTINSTALL             225
#define IDS_APPHELP_DESC_HARDBLOCK      226
#define IDS_APPHELP_DESC_NONE           227
#define IDS_CANNOTBECLOSED              228
#define ID_EDIT_COPY                    228
#define IDS_NEEDTOBEADMIN               229
#define ID_EDIT_PASTE                   229
#define IDS_PROGRAMBEINGFIXED           230
#define ID_EDIT_DELETE                  230
#define ID_EDIT_RENAME                  231
#define IDS_MODIFY                      231
#define IDS_APPHELP_DESC_SOFTBLOCK      232
#define IDS_HASBEENDISABLED             233
#define IDR_ACCL                        233
#define IDS_DESC_APPHELP1               234
#define ID_EDIT_CUT                     234
#define IDS_DESC_APPHELP2               235
#define IDI_OPEN                        235
#define IDS_DESC_PRESENTLYOPENDB        236
#define IDS_DESC_INSTALLED              237
#define IDS_ERROROPEN                   238
#define ID_MODIFY_APPLICATIONFIX        238
#define IDS_DBTOINSTALL                 239
#define ID_MODIFY_APPHELPMESSAGE        239
#define ID_MODIFY_COMPATIBILITYMODE     240
#define IDS_STA_TYPE_ENTRY              240
#define IDS_AFFECTED_FILE               241
#define IDS_PATH                        242
#define IDS_APP                         243
#define IDS_ACTION                      244
#define IDS_DATABASE                    245
#define IDS_ERRORINSTALL                246
#define IDS_GLOBAL                      247
#define IDS_LOCAL                       248
#define IDS_TEST                        249
#define IDS_APPHELPS                    250
#define IDS_FLAGS                       251
#define IDS_MODES                       252
#define IDS_PATCHES                     253
#define IDS_FIXES                       254
#define IDS_PATHERROR                   255
#define IDS_EXEFILTER                   256
#define IDS_EXE_EXT                     257
#define IDS_SDB_EXT                     258
#define IDS_SEARCHCOMPLETE              259
#define IDS_SELECTDIR                   260
#define IDS_ENTRIESFOUND                261
#define IDS_DETAILS_CANNOT_BE_VIEWED    262
#define IDS_LAYEREXISTS                 263
#define IDS_INVALID_LAYER_NAME          264
#define IDS_MODE_COPY                   265
#define IDS_MODE_EDIT                   266
#define IDS_MODE_REMOVE                 267
#define IDS_UNABLETOREMOVE_MODE         268
#define IDI_NEWAPPHELP                  268
#define IDS_INCLUDEMODULE               269
#define IDS_ERROR_SYSDB                 270
#define IDS_COMPILER_ERROR              271
#define IDS_UNABLETOSAVETEMP            272
#define IDS_ERROREXECUTE                273
#define IDS_GETCOMPLETEPATH             274
#define IDS_GETLONGNAME                 275
#define IDS_DOESNOTMATCH                276
#define IDS_SELECTLAYERS                277
#define IDS_SELECTLAYERS_SUBHEADING     278
#define IDS_MATCHINFO                   279
#define IDS_MATCHINFO_SUBHEADING        280
#define IDS_FIXCREATED                  281
#define IDS_FIXCREATED_SUBHEADING       282
#define IDS_EDITFIX                     283
#define IDS_CREATEFIX                   284
#define IDS_INVALIDEXE                  285
#define IDS_DEF_DBNAME                  286
#define IDS_COL_FIXNAME                 287
#define IDS_COL_CMDLINE                 288
#define IDS_COL_MODULE                  289
#define IDS_NO                          290
#define IDS_YES                         291
#define IDS_SELECTED                    292
#define IDS_STRING293                   293
#define IDS_MAINEXE                     294
#define IDS_MATCHFILEEXISTS             295
#define IDS_FINDMATCHINGFILE            296
#define IDS_REQUIREDFORMATCHING         297
#define IDS_SELECTMATCHFIRST            298
#define IDS_SELECTFIX                   299
#define IDS_DEF_FILENAME                300
#define IDS_APPHELP                     301
#define IDS_INVALIDNAME                 302
#define IDS_CANNOT_LOAD_APPHELPED_ENTRY 303
#define IDS_APPCONFLICTMESSAGE          304
#define IDS_ASKFOR_OVERWRITE_EXE        305
#define IDS_EDITCUSTOMCOMPATDLG         306
#define IDS_SAMEAPPEXISTS               307
#define IDS_CANNOTSAVE                  308
#define IDI_SAVE                        308
#define IDS_EDITAPPHELP                 309
#define IDS_CREATEAPPHELP               310
#define IDS_NEWAPPNAME_MSG              311
#define IDS_DETAILS                     312
#define IDS_INVALIDOS                   313
#define IDS_PERUSER                     314
#define IDS_XP_NO_SDB                   315
#define IDS_W2K_NO_SDB                  316
#define IDS_SP2_SDB                     317
#define IDS_MSG_LINK                    318
#define IDS_DELETE_VERIFY               319
#define IDS_TRYOPENINSTALLED            320
#define IDS_NOTIFYINSTALLED             321
#define IDS_NOTIFYPERUSER               322
#define IDS_STA_ENTRYCOUNT              323
#define IDS_STA_POPCONTENTS_GUI_APPS    324
#define IDS_STA_POPCONTENTS_GUI_LAYERS  325
#define IDS_STA_POPCONTENTS_GUI_SHIMS   326
#define IDS_STA_ENABLED                 327
#define IDS_STA_DISABLED                328
#define IDI_ICONALLUSERS                329
#define IDS_STA_INSTALLED               329
#define IDI_ICONSINGLEUSER              330
#define IDS_STA_WORKING                 330
#define IDS_STA_PERUSER                 331
#define IDS_STA_WORKINGDB               332
#define ID_EDIT_SELECTALL               333
#define IDS_STA_TYPE_APPHELP            333
#define IDS_STA_FIX_LAYER               334
#define IDS_STA_FIX_SHIM                335
#define ID_EDIT_INVERTSELECTION         336
#define IDS_STA_FIX_PATCH               336
#define IDS_STA_FIX_LAYERS              337
#define IDI_FILE                        337
#define IDS_MESSAGETYPE_SUBHEADING      338
#define IDS_STA_FIX_SHIMS               339
#define IDS_STA_MATCHINGFILE            340
#define IDS_STA_MATCHINGATTRIBUTE       341
#define IDI_ATTRIBUTE                   341
#define IDS_STA_MATCHINGFILES           342
#define IDS_STA_FIX_PATCHES             343
#define IDI_SEARCH                      343
#define IDS_STA_SHIM                    344
#define IDS_STA_INCLUDE                 345
#define IDS_STA_EXCLUDE                 346
#define IDS_STA_COMMANDLINE             347
#define IDS_MESSAGEINFO_SUBHEADING      348
#define IDS_CUSTOMAPPHELP_EDIT          349
#define IDS_NOTSAMEDRIVE                350
#define IDS_TB_NEW                      351
#define IDS_TB_OPEN                     352
#define IDS_TB_SAVE                     353
#define IDS_NOTSAVED                    354
#define IDS_FIX_PROPERTIES              355
#define IDS_TB_RUN                      356
#define IDS_TB_CREATEFIX                357
#define IDS_TB_CREATEAPPHELP            358
#define IDS_APP_PROPERTIES              359
#define IDS_ADVANCED                    360
#define IDS_TB_SEARCH                   361
#define IDS_ALLDATABASES                362
#define IDS_TB_CREATEMODE               363
#define IDS_ERROR_FRIENDLYNAME          364
#define IDS_ERROR_DEFAULTNAME           364
#define IDS_SELECTSHIMS_SUBHEADING      365
#define IDS_SHOW_BUTTON_SEL             366
#define IDS_SHOW_BUTTON_ALL             367
#define IDS_ERROR_FROM_NOTFOUND         368
#define IDS_ERROR_IMPROPERWHERE_FOUND   369
#define IDS_ERROR_INVALID_AND_OPERANDS  370
#define IDS_ERROR_INVALID_CONTAINS_OPERANDS 371
#define IDS_ERROR_INVALID_DBTYPE_INFROM 372
#define IDS_ERROR_INVALID_GE_OPERANDS   373
#define IDS_ERROR_INVALID_GT_OPERANDS   374
#define IDS_ERROR_INVALID_HAS_OPERANDS  375
#define IDS_ERROR_INVALID_LE_OPERANDS   376
#define IDS_ERROR_INVALID_LT_OPERANDS   377
#define ID_EDIT_CONFIGURELUA            378
#define ID_EDIT_CUSTOMIZELUA            378
#define IDS_ERROR_INVALID_OR_OPERANDS   378
#define IDS_ERROR_INVALID_SELECTPARAM   379
#define IDS_ERROR_OPERANDS_DONOTMATCH   380
#define IDD_QDB                         381
#define IDS_ERROR_SELECT_NOTFOUND       381
#define ID_SEARCH_QUERYDATABASE         382
#define IDS_ERROR_STRING_NOT_TERMINATED 382
#define IDS_NOLONGEREXISTS              383
#define IDS_LUA_TRACK_FILES             384
#define IDS_MAINLOADED                  385
#define IDS_LUA_ERROR_FIND              386
#define IDS_LUA_EDIT_FILE_LIST          387
#define IDS_LUA_EDIT_FILE_LIST_SUBHEADING 388
#define IDS_LUA_ERROR_TRACK             389
#define IDD_DBPROPERTIES                389
#define IDS_LUA_FILEDIR_NAME            390
#define ID_FILE_PROPERTIES              390
#define IDS_LUA_REDIRECT                391
#define IDD_QDB_PAGE1                   391
#define IDS_LUA_RDIR_PERUSER            392
#define IDI_EV_WARNING                  392
#define IDS_LUA_RDIR_ALLUSER            393
#define IDI_EV_ERROR                    393
#define IDS_LUA_TRACK_FILES_SUBHEADING  394
#define IDI_EV_INFO                     394
#define IDS_TB_TT_NEW                   395
#define ID_VIEW_EVENTS                  395
#define IDS_TB_TT_SEARCH                396
#define IDS_TB_TT_CREATEFIX             397
#define IDI_NEW                         397
#define IDS_TB_TT_OPEN                  398
#define IDS_TB_TT_EXIT                  399
#define IDS_TB_TT_UNINSTALL             400
#define IDS_TB_TT_SAVE                  401
#define IDS_TB_TT_RUN                   402
#define IDS_TB_TT_INSTALL               403
#define IDS_TB_TT_REFRESH               404
#define IDS_TB_TT_CLOSE                 405
#define IDS_MODECONFLICTMESSAGE         406
#define IDS_NEWMODENAME_MSG             407
#define IDS_EVENT_CONFLICT_ENTRY        408
#define IDS_LUA_ERROR_CM                409
#define IDS_LOADINGMAIN                 410
#define IDS_QDB_COUNT                   411
#define IDS_DAYS                        412
#define IDS_STRING359                   413
#define IDS_STRING360                   414
#define IDS_STRING362                   415
#define IDS_STRING409                   416
#define IDS_STRING410                   417
#define IDS_STRING411                   418
#define IDS_MONTHS                      419
#define IDS_STRING420                   420
#define IDS_STRING421                   421
#define IDS_STRING422                   422
#define IDS_STRING423                   423
#define IDS_STRING424                   424
#define IDS_STRING425                   425
#define IDS_STRING426                   426
#define IDS_STRING427                   427
#define IDS_STRING428                   428
#define IDS_STRING429                   429
#define IDS_STRING430                   430
#define IDS_AM                          431
#define IDS_PM                          432
#define IDS_READONLY                    433
#define IDS_LUA_CM_SELECT               434
#define IDS_CONFLICT_CREATE_EDIT        435
#define IDS_EVENT_ENTRY_COPYOK          436
#define IDS_LUA_CM_DESELECT             437
#define IDS_ERRORCOMPILE                438
#define IDS_LUA_CM_REDIRECT_ALLUSER     439
#define IDS_LUA_CM_REDIRECT_PERUSER     440
#define IDS_LUA_SELECT_PERUSER_DIR      441
#define IDS_LUA_SELECT_ALLUSER_DIR      442
#define IDS_NODESC                      443
#define IDS_EVENT_SYSTEM_RENAME         444
#define IDS_EVENT_LAYER_COPYOK          445
#define IDS_EVENT_COL_TIME              446
#define IDS_EVENT_COL_MSG               447
#define IDS_SAVE_RESULTS_EXT            448
#define IDS_UINSTALL                    449
#define IDS_INSTALL                     450
#define IDS_NOTCREATED                  451
#define IDS_LUA_TRACKXML                452
#define IDS_MENU_UINSTALL               453
#define IDS_MENU_INSTALL                454
#define IDS_LUA_GET_TRACK_RESULT        455
#define IDS_LATEST_TOOLKIT              456
#define IDS_LUA_INIT_OLD_LISTS          457
#define IDS_LUA_DUP_ITEM                458
#define IDS_LUA_ARROW_FONT              459
#define IDS_LUA_MERGE_LIST              460
#define IDS_LUA_TOO_MANY_SELECTED       461
#define IDS_LUA_WIZARD_TITLE            462
#define IDS_ERROR_PARENTHESIS_COUNT     463
#define IDS_EXCEPTION                   464
#define IDI_MATCHHEAD                   465
#define IDS_ERRORNOTADMIN               465
#define IDS_SHIMINLAYER                 466
#define IDS_SAVE_RESULTS_TITLE          467
#define IDS_SAVE_RESULTS_FILTER         468
#define IDS_EXEALLFILTER                469
#define IDS_CUSTOMAPPHELP_ADD           470
#define IDS_LUA_DESC_NODATA             471
#define IDS_LUA_DESC_DATA               472
#define IDD_LUA_EXCLUSION               473
#define IDS_ERROR_WRONGNUMBER_OPERANDS  473
#define IDS_WIZ_EDITFIX                 474
#define IDB_TOOLBAR                     474
#define IDS_WIZ_ADDFIX                  475
#define IDB_TOOLBAR_HOT                 475
#define IDS_WIZ_CREATEFIX               476
#define IDS_TRYINGTOSTOP_QUERY          477
#define IDS_STA_ALL_EXCLUDED            478
#define IDS_STA_EXE_EXCLUDED            479
#define IDS_STA_ALL_INCLUDED            480
#define IDS_STA_EXE_INCLUDED            481
#define IDS_ENTRYCONFLICT               482
#define IDS_DEF_HELPSEARCH              483
#define IDS_SOMEWIZARDACTIVE            484
#define IDS_NO_LOGFILE                  485
#define IDS_NO_NOTEPAD                  486
#define IDS_SOMESEARCHWINDOW            487
#define IDS_ERROR_GUI_NOCHECKBOXSELECTED 488
#define IDS_INCLUDE                     489
#define IDS_EXCLUDE                     490
#define IDS_TYPE                        491
#define IDS_MODULENAME                  492
#define IDS_OPTIONS                     493
#define IDS_PRAMS_DLGCAPTION            494
#define IDS_ATTR_S_APP_NAME             495
#define IDS_ATTR_S_ENTRY_EXEPATH        496
#define IDS_ATTR_S_ENTRY_DISABLED       497
#define IDS_ATTR_S_ENTRY_GUID           498
#define IDS_ATTR_S_ENTRY_APPHELPTYPE    499
#define IDS_ATTR_S_ENTRY_APPHELPUSED    500
#define IDS_ATTR_S_ENTRY_SHIMFLAG_COUNT 501
#define IDS_ATTR_S_ENTRY_PATCH_COUNT    502
#define IDS_ATTR_S_ENTRY_LAYER_COUNT    503
#define IDS_ATTR_S_ENTRY_MATCH_COUNT    504
#define IDS_ATTR_S_SHIM_NAME            505
#define IDS_ATTR_S_MATCHFILE_NAME       506
#define IDS_ATTR_S_LAYER_NAME           507
#define IDS_ATTR_S_PATCH_NAME           508
#define IDS_FIX_DESCRIPTION             509
#define IDS_QDB_NO_TEXTTO_SEARCH        510
#define IDS_QDB_ALLWORDS                511
#define IDS_QDB_ANYWORD                 512
#define IDS_ATTR_S_DATABASE_NAME        513
#define IDS_ATTR_S_DATABASE_PATH        514
#define IDS_ATTR_S_DATABASE_INSTALLED   515
#define IDS_ATTR_S_DATABASE_GUID        516
#define IDS_NO_DESC_AVAILABLE           517
#define IDS_TOO_MANYFILES               518
#define IDS_GETPATH_ADD                 519
#define IDS_DEFAULT_APP_NAME            520
#define IDS_DEFAULT_VENDOR_NAME         521
#define IDS_INVALID_APPHELP_MESSAGE	522
#define IDS_MATCHINGFILE_DELETED	523
#define IDB_256NORMAL                   551
#define IDB_256HOT                      552
#define IDS_CHECKLUA                    553
#define IDS_CHECKLUASUBHEADING          554
#define IDD_DBRENAME                    555
#define IDC_LIST                        1000
#define IDC_ENTRY                       1001
#define IDC_MOD_LIST                    1001
#define IDC_LIBRARY                     1012
#define IDC_URL                         1013
#define IDC_BROWSE                      1014
#define IDC_GENERATE                    1019
#define IDC_VENDOR                      1019
#define IDC_UNSELECTALL                 1021
#define IDC_LAYERLIST                   1022
#define IDC_SHIM_CMD_LINE               1023
#define IDC_SHIMLIST                    1025
#define IDC_PATH                        1025
#define IDC_CHKAPP                      1028
#define IDC_CHKSHI                      1029
#define IDC_CHKLAY                      1030
#define IDC_TESTRUN                     1032
#define IDC_MOD_NAME                    1032
#define IDC_NAME                        1034
#define IDC_STOP                        1034
#define IDC_INCLUDE                     1038
#define IDC_ADD                         1039
#define IDC_EXCLUDE                     1039
#define IDC_REMOVE                      1040
#define IDC_COPY                        1041
#define IDC_REMOVEALL                   1043
#define IDC_SEARCH                      1043
#define IDC_MESSAGE                     1043
#define IDC_SHOWALLATTR                 1044
#define IDC_MSG_LINK                    1044
#define IDC_COMMANDLINE                 1047
#define IDC_STATUSBAR                   1047
#define IDC_SELECTALL                   1051
#define IDC_CONTENTSLIST                1051
#define IDC_TITLE                       1052
#define IDC_STATUS                      1053
#define IDC_FILELIST                    1054
#define IDC_REMOVEFILES                 1055
#define IDC_ADDFILES                    1056
#define IDC_RADIO_95                    1058
#define IDC_RADIO_NT                    1059
#define IDC_RADIO_98                    1060
#define IDC_CLEARALL                    1061
#define IDC_RADIO_2K                    1061
#define IDC_EXE                         1062
#define IDC_BLOCK                       1064
#define IDC_RADIO_NONE                  1064
#define IDC_NOBLOCK                     1065
#define IDC_MSG_SUMMARY                 1076
#define IDC_COMBO                       1086
#define IDC_SHOW                        1097
#define IDC_LUA_FILE_LIST               1100
#define ID_UPDATE                       1101
#define IDC_PARAMS                      1103
#define IDC_SQL                         1104
#define IDC_LUA_PERUSER_DIR             1104
#define ID_SEARCH                       1105
#define IDC_LUA_ALLUSER_DIR             1105
#define IDC_LUA_RDIR                    1106
#define IDC_NEWSEARCH                   1108
#define IDC_GROUP                       1109
#define IDC_LUA_OVERRIDE                1110
#define IDC_SAVE                        1110
#define IDC_LUA_MODIFY_DATA             1113
#define IDC_LUA_RUN_PROGRAM             1114
#define IDC_LUA_FILE_EDIT               1115
#define IDC_LUA_COPY                    1116
#define IDC_ENTRYNAME                   1117
#define IDC_GUID                        1121
#define IDC_STATIC_BAR2                 1126
#define IDC_STATIC_BAR3                 1127
#define IDC_PIC                         1128
#define IDC_STATIC_BAR4                 1129
#define IDC_DATE_MODIFIED               1130
#define IDC_DATE_ACCESSED               1131
#define IDC_APP_COUNT                   1132
#define IDC_ENTRY_COUNT                 1133
#define IDC_MODE_COUNT                  1134
#define IDC_STATIC_BAR5                 1135
#define IDC_DATE_CREATED                1136
#define IDC_INSTALLED                   1137
#define IDC_ANIMATE                     1138
#define IDC_LAYERS                      1141
#define IDC_SHIMS                       1142
#define IDC_APPHELP                     1143
#define IDC_SHIM                        1144
#define IDC_MODE                        1145
#define IDC_SELECT_LIST                 1146
#define IDC_WHERE_LIST                  1147
#define IDC_SELECT                      1148
#define IDC_WHERE                       1149
#define IDC_LUA_UNTOK                   1150
#define IDC_TAB                         1155
#define IDC_DESCRIPTION                 1157
#define IDC_CONFLICT_MSG                1158
#define IDC_LUA_UP                      1162
#define IDC_CANCEL                      1162
#define IDC_LUA_DOWN                    1163
#define IDC_LUA_EDIT_BROWSE             1164
#define IDC_LUA_EXTS                    1166
#define IDC_PROGRESS                    1170
#define IDC_STATIC_CAPTION              1172
#define IDC_TEXT                        1173
#define IDC_DESC                        1175
#define ID_QDB_HELP                     1176
#define IDC_SEARCH_HELP                 1177
#define IDC_FIXWIZ_CHECKLUA_YES         1178
#define IDC_FIXWIZ_CHECKLUA_NO          1179
#define IDC_ADDTOLIST                   2003
#define IDC_REMOVEFROMLIST              2004
#define IDD_LUA_ACTION                  2379
#define IDD_LUA_COMMON_PATHS            2380
#define IDD_LUA_TRACKED_FILES           2381
#define IDD_CONFLICTENTRY               2382
#define IDD_QDB_PAGE2                   2383
#define IDD_QDB_PAGE4                   2384
#define IDD_EVENTS                      2385
#define IDD_QDBWAIT                     2386
#define IDD_QDB_PAGE5                   2387
#define IDD_QDB_PAGE3                   2387
#define IDD_FIXWIZ_CHECKLUA             2388
#define IDC_APPNAME                     6001
#define IDC_EXEPATH                     6002
#define IDA_SEARCH                      6003
#define IDC_LUA_EXE                     11033
#define ID_FILE_NEW                     40001
#define ID_FILE_OPEN                    40002
#define ID_FILE_EXIT                    40003
#define ID_HELP_ABOUT                   40004
#define ID_FILE_SAVE                    40119
#define ID_FIX_CREATEANAPPLICATIONFIX   40136
#define ID_FIX_CREATENEWLAYER           40137
#define IDS_TB_TT_CREATEMODE            40137
#define ID_FILE_SAVEAS                  40141
#define ID_FIX_EXECUTEAPPLICATION       40144
#define ID_FIX_CHANGEENABLESTATUS       40145
#define ID_VIEW_DESCRIPTION             40147
#define ID_DATABASE_INSTALL_UNINSTALL   40149
#define ID_CHANGEFOCUS                  40151
#define ID_FOCUSREV                     40152
#define ID_HELP_TOPICS                  40153
#define ID_HELP_INDEX                   40154
#define ID_HELP_SEARCH                  40155
#define ID_VIEW_LOG                     40156
#define ID_TOOLS_SEARCHFORFIXES         40180
#define ID_VIEWCONTENTS                 40181
#define ID_FIX_CREATEANEWAPPHELPMESSAGE 40191
#define IDS_TB_TT_CREATEAPPHELP         40191
#define IDS_TB_QUERY                    40192
#define IDS_TB_TT_QUERY                 40193
#define IDS_LUA_COMMON_PATHS_SUBHEADING 40194
#define IDS_LUA_COMMON_PATHS_HEADING    40195
#define IDS_APPLICATION_NAME            40196
#define IDS_LUA_EXCLUSION_HEADING       40197
#define IDS_LUA_EXCLUSION_SUBHEADING    40198
#define IDS_GUEST                       40199
#define ID_DATABASE_CLOSE               40210
#define ID_DATABASE_CLOSEALL            40211
#define ID_DATABASE_SAVEALL             40212

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        556
#define _APS_NEXT_COMMAND_VALUE         40157
#define _APS_NEXT_CONTROL_VALUE         1181
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by demodll.rc
//
#define IDB_W2K_SPLASH                  105
#define IDR_VERSION_EXE                 105
#define IDB_W2K_SPLASH_256              106
#define IDB_XP_SPLASH                   111
#define IDB_XP_SPLASH_256               112

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\dll\dll.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Dll.h

  Abstract:

    Used by the Demo Application to illustrate IgnoreFreeLibrary.

  Notes:

    ANSI only - must run on Win9x.

  History:

    03/09/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/

#define MAIN_APP_TITLE  "Application Compatibiltiy Demo"

//
// Prototypes of functions that we're exporting.
//
void
WINAPI
DemoAppExp(
    IN DWORD* dwParam
    );

void
WINAPI
DemoAppMessageBox(
    IN HWND hWnd
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\badfunc.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Badfunc.cpp

  Abstract:

    Contains all the bad functions. These are the functions
    that will have Compatibility Fixes applied.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised
    02/13/02    rparsons    Use strsafe functions

--*/
#include "demoapp.h"

extern APPINFO g_ai;

//
// Pointer to the exported function that we get from our DLL.
//
LPFNDEMOAPPEXP DemoAppExpFunc;

/*++

  Routine Description:

    Determines if we're running Windows 95.

  Arguments:

    None.

  Return Value:

    TRUE if we are, FALSE otherwise.

--*/
BOOL
BadIsWindows95(
    void
    )
{
    //
    // Most applications perform some sort of version check when they first
    // begin. This is usually okay, assuming they perform the check properly.
    // The problem is that instead of doing a greater than comparison, they
    // do an equal/not equal to. In other words, they look just for Win9x,
    // not Win9x or greater. Usually the application will function properly
    // on NT/2K/XP, so this check can be hooked and we can return NT/2K/XP
    // version info.
    //
    OSVERSIONINFO   osvi;

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&osvi)) {
        return FALSE;
    }  

    //
    // Check for Windows 9x (don't do a greater than).
    //
    if ((osvi.dwMajorVersion == 4) &&
        (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
        return TRUE;
    }

    return FALSE;
}

/*++

  Routine Description:

    Displays a debug message - this only happens on NT/Windows 2000/XP.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
BadLoadBogusDll(
    void
    )
{
    //
    // Some applications will display a debug message under Windows NT/2000/XP.
    // For example, they try to locate a DLL that is available on Win9x, but
    // not on NT/2K/XP. If they don't find it, they'll complain, but will
    // most likely still work. In the example below, we try to find a function
    // in a DLL that would return TRUE on Win9x, but will fail on NT/2000/XP. 
    //    
    HRESULT     hr;
    HINSTANCE   hInstance;
    char        szDll[MAX_PATH];
    const char  szCvt32Dll[] = "cvt32.dll";
    
    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);    

    hr = StringCchPrintf(szDll,
                         sizeof(szDll),
                         "%hs\\%hs",
                         g_ai.szSysDir,
                         szCvt32Dll);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // This will fail on NT/2K/XP because cvt32.dll doesn't exist on
    // these platforms. It will fail on Win9x/ME if the FAT32 conversion
    // tools are not installed.
    //
    hInstance = LoadLibrary(szDll);

    if (!hInstance) {
        MessageBox(g_ai.hWndMain,
                   "Debug: Couldn't load CVT32.DLL.",
                   0,
                   MB_ICONERROR);
        goto exit;
    
    }    

    FreeLibrary(hInstance);

exit:

    SetErrorMode(0);
}

/*++

  Routine Description:

    Apps call EnumPrinters using the PRINTER_ENUM_LOCAL flag,
    but expect to get back network printers also. This was a
    ***design feature*** in Windows 9x, but not in Windows 2000/XP.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
BadEnumPrinters(
    void
    )
{
    BOOL                fReturn = FALSE;
    DWORD               dwBytesNeeded = 0;
    DWORD               dwNumReq = 0;     
    DWORD               dwLevel = 5;    
    LPPRINTER_INFO_5    pPrtInfo = NULL;    
    
    // 
    // Get the required buffer size.
    //
    if (!EnumPrinters(PRINTER_ENUM_LOCAL,
                      NULL,
                      dwLevel,
                      NULL,
                      0,
                      &dwBytesNeeded,
                      &dwNumReq)) {
        return FALSE;
    }
   
    pPrtInfo = (LPPRINTER_INFO_5)HeapAlloc(GetProcessHeap(),
                                           HEAP_ZERO_MEMORY,
                                           dwBytesNeeded);
    
    if (!pPrtInfo) {
        return FALSE;
    }
    
    //
    // Now perform the enumeration.
    //
    fReturn = EnumPrinters(PRINTER_ENUM_LOCAL,   // types of printer objects to enumerate       
                           NULL,                 // name of printer object                      
                           dwLevel,              // specifies type of printer info structure    
                           (LPBYTE)pPrtInfo,     // pointer to buffer to receive printer info structures                                  
                           dwBytesNeeded,        // size, in bytes, of array                    
                           &dwBytesNeeded,       // pointer to variable with no. of bytes copied (or required)                        
                           &dwNumReq);           // pointer to variable with no. of printer info. structures copied                     

    HeapFree(GetProcessHeap(), 0, pPrtInfo);
    
    return fReturn;
}

/*++

  Routine Description:

    Apps call printer APIs passing NULL.

  Arguments:

    None.

  Return Value:

    A handle if we opened the printer successfully.

--*/
HANDLE
BadOpenPrinter(
    void
    )
{
    HANDLE  hPrinter = NULL;
    
    OpenPrinter(NULL, &hPrinter, NULL);            
    
    return hPrinter;
}

/*++

  Routine Description:

    Attempts to delete a registry key that has subkeys.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
BadDeleteRegistryKey(
    void
    )
{
    //
    // This function demonstrates a difference in the RegDeleteKey API.
    // If an application running on Windows NT/2000/XP attempts to
    // delete a key that has subkeys, the call will fail. This is not
    // the case on Windows 9x/ME.
    //
    HKEY    hKey;
    HKEY    hSubKey;
    HKEY    hRootKey;
    LONG    lReturn;

    //
    // Create the key or open it if it already exists.
    //
    lReturn = RegCreateKeyEx(HKEY_CURRENT_USER,
                             DEMO_REG_APP_KEY,              // Software\Microsoft\DemoApp2
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, 
                             0,
                             &hKey,
                             NULL);
    
    if (ERROR_SUCCESS != lReturn) {        
        return FALSE;
    }

    //
    // Now create a subkey underneath the key was just created.
    //
    lReturn = RegCreateKeyEx(HKEY_CURRENT_USER,
                             DEMO_REG_APP_SUB_KEY,          // Software\Microsoft\DemoApp2\Sub
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, 
                             0,
                             &hSubKey,
                             NULL);

    if (ERROR_SUCCESS != lReturn) {        
        RegCloseKey(hKey);
        return FALSE;
    }

    RegCloseKey(hKey);
    RegCloseKey(hSubKey);

    //
    // Open the key up, but one level higher.
    //
    lReturn = RegOpenKeyEx(HKEY_CURRENT_USER,
                           DEMO_REG_APP_ROOT_KEY,           // Software\Microsoft
                           0,
                           KEY_ALL_ACCESS,
                           &hRootKey);

    if (ERROR_SUCCESS != lReturn) {
        return FALSE;
    }

    //
    // Now try to delete our key.
    //
    lReturn = RegDeleteKey(hRootKey, "DemoApp2");        

    RegCloseKey(hRootKey);

    return (lReturn == ERROR_SUCCESS ? TRUE : FALSE);
}

/*++

  Routine Description:

    Reboots the computer, if desired.

  Arguments:

    fReboot     -       A flag to indicate if the PC should be rebooted.

  Return Value:

    None.

--*/
void
BadRebootComputer(
    IN BOOL fReboot
    )
{
    //
    // On Windows 9x, there is essentially no security, so anyone is able
    // to reboot the computer. On Windows NT/2000/XP, things are a bit
    // more restrictive. If an application wants to do a reboot at the
    // end of a setup, it needs adjust the privileges of the user by
    // calling the AdjustTokenPrivileges API.
    // 
    // In this case, we evaluate the flag passed and decide if we should
    // adjust the privileges.
    //
    // Obviously applications should not do this (evaluate some kind of flag)
    // as this is just for demonstration purposes.
    //
    if (!fReboot) {    
        ExitWindowsEx(EWX_REBOOT, 0);    
    } else {
        ShutdownSystem(FALSE, TRUE);
    }
}

/*++

  Routine Description:

    Attempts to get available disk space.

  Arguments:

    None.

  Return Value:

    TRUE if enough disk space is available, FALSE otherwise.

--*/
BOOL
BadGetFreeDiskSpace(
    void
    )
{
    //
    // GetDiskFreeSpace returns a maximum total size and maximum free
    // size of 2GB. For example, if you have a 6GB volume and 5GB are
    // free, GetDiskFreeSpace reports that the drive's total size is 2GB
    // and 2GB are free. This limitation originated because the first version
    // of Windows 95 only supported volumes of up to 2GB in size. Windows 95
    // OSR2 and later versions, including Windows 98, support volumes larger
    // than 2GB. GetDiskFreeSpaceEx does not have a 2GB limitation, thus
    // it is preferred over GetDiskFreeSpace. GetDiskFreeSpace returns a
    // maximum of 65536 for the numbers of total clusters and free clusters
    // to maintain backward compatibility with the first version of Windows 95.
    // The first version of Windows 95 supports only the FAT16 file system,
    // which has a maximum of 65536 clusters. If a FAT32 volume has more than
    // 65536 clusters, the number of clusters are reported as 65536 and the
    // number of sectors per cluster are adjusted so that the size of volumes
    // smaller than 2GB may be calculated correctly. What this means is that
    // you should not use GetDiskFreeSpace to return the true geometry
    // information for FAT32 volumes. 
    //
    // In case you're wondering, always use the GetDiskFreeSpaceEx API
    // on Windows 2000/XP.
    //
    BOOL    fResult = FALSE;
    HRESULT hr;
    char    szWinDir[MAX_PATH];
    char*   lpDrive = NULL;
    
    DWORD   dwSectPerClust = 0,
            dwBytesPerSect = 0,
            dwFreeClusters = 0,
            dwTotalClusters = 0,
            dwTotalBytes = 0,
            dwFreeBytes = 0,
            dwFreeMBs = 0;

    //
    // Get the drive that windows is installed on and pass it
    // to the GetDiskFreeSpace call.
    //
    hr = StringCchCopy(szWinDir, sizeof(szWinDir), g_ai.szWinDir);

    if (FAILED(hr)) {
        return FALSE;
    }

    lpDrive = strstr(szWinDir, "\\");

    //
    // Make the buffer just 'C:\' (or whatever).
    //
    if (lpDrive) {
        *++lpDrive = '\0';
    }

    fResult = GetDiskFreeSpace(szWinDir,
                               &dwSectPerClust,
                               &dwBytesPerSect,
                               &dwFreeClusters,
                               &dwTotalClusters);

    if (fResult) {
        //
        // Normally we would use the __int64 data type,
        // but we want the calculations to fail for demonstration.
        //        
        dwTotalBytes = dwTotalClusters * dwSectPerClust * dwBytesPerSect;
        
        dwFreeBytes = dwFreeClusters * dwSectPerClust * dwBytesPerSect;

        dwFreeMBs = dwFreeBytes / (1024 * 1024);

        if (dwFreeMBs < 100) {
            return FALSE;
        }    
    }    

    return TRUE;
}

/*++

  Routine Description:

    Displays the readme, if desired.

  Arguments:

    fDisplay        -       A flag to indicate if the readme
                            should be displayed.

  Return Value:

    None.

--*/
void
BadDisplayReadme(
    IN BOOL fDisplay
    )
{
    // Windows NT/2000/XP contains a new registry data type, REG_EXPAND_SZ,
    // that was not found in Win9x. The type contains a variable that needs
    // to be expanded before it can be referred to. For example,
    // %ProgramFiles% would expand to something like C:\Program Files.
    // Most applications are unaware of this data type and therefore
    // don't handle it properly.
    //
    CRegistry   creg;
    HRESULT     hr;
    LPSTR       lpWordpad = NULL;
    char        szExpWordpad[MAX_PATH];
    char        szCmdLineArgs[MAX_PATH];
    
    lpWordpad = creg.GetString(HKEY_LOCAL_MACHINE,
                               REG_WORDPAD,
                               NULL);               // we want the (Default) value

    if (!lpWordpad) {
        return;
    }

    //    
    // At this point, the path looks something like this:
    // "%ProgramFiles%\Windows NT\Accessories\WORDPAD.EXE"
    // If the user wants to see the readme (bad functionality
    // is disabled), we're going to expand the variable to
    // get the true path, then launch wordpad
    // If not, we'll try to display the readme using the bogus
    // path.

    if (fDisplay) {
        //
        // Expand the environment strings, then build a path to our
        // readme file, then launch it.
        //
        ExpandEnvironmentStrings(lpWordpad, szExpWordpad, MAX_PATH);

        hr = StringCchPrintf(szCmdLineArgs,
                             sizeof(szCmdLineArgs),
                             "\"%hs\\demoapp.txt\"",
                             g_ai.szDestDir);

        if (FAILED(hr)) {
            goto exit;
        }

        BadCreateProcess(szExpWordpad, szCmdLineArgs, TRUE);
        
    } else {
        //
        // Do all the work above, but don't expand the data
        // We don't check the return of the CreateProcess call,
        // so the user simply doesn't get to see the readme,
        // and we don't display an error.
        // This is consistent with most setup applications.
        //
        hr = StringCchPrintf(szCmdLineArgs,
                             sizeof(szCmdLineArgs),
                             "\"%hs\\demoapp.txt\"",
                             g_ai.szDestDir);

        if (FAILED(hr)) {
            goto exit;
        }

        //
        // This will fail. See the BadCreateProcess
        // function for details.
        //
        BadCreateProcess(lpWordpad, szCmdLineArgs, FALSE);
    }

exit:

    if (lpWordpad) {
        creg.Free(lpWordpad);
    }
}

/*++

  Routine Description:

    Displays the help file, if desired.

  Arguments:

    fDisplay        -       A flag to indicate if the help file
                            should be displayed.

  Return Value:

    None.

--*/
void
BadLaunchHelpFile(
    IN BOOL fDisplay
    )
{
    char        szCmdLineArgs[MAX_PATH];
    char        szExeToLaunch[MAX_PATH];
    const char  szWinHlp[] = "winhelp.exe";
    const char  szWinHlp32[] = "winhlp32.exe";
    HRESULT     hr;

    if (fDisplay) {
        hr = StringCchPrintf(szExeToLaunch,
                             sizeof(szExeToLaunch),
                             "%hs\\%hs",
                             g_ai.szSysDir,
                             szWinHlp32);

        if (FAILED(hr)) {
            return;
        }          

        hr = StringCchPrintf(szCmdLineArgs,
                             sizeof(szCmdLineArgs),
                             "%hs\\demoapp.hlp",
                             g_ai.szCurrentDir);
        if (FAILED(hr)) {
            return;
        }
    } else {
        hr = StringCchPrintf(szExeToLaunch,
                             sizeof(szExeToLaunch),
                             "%hs\\%hs",
                             g_ai.szWinDir,
                             szWinHlp);

        if (FAILED(hr)) {
            return;
        }

        hr = StringCchPrintf(szCmdLineArgs,
                             sizeof(szCmdLineArgs),
                             "%hs\\demoapp.hlp",
                             g_ai.szCurrentDir);
        if (FAILED(hr)) {
            return;
        }
    }

    BadCreateProcess(szExeToLaunch, szCmdLineArgs, fDisplay);
}

/*++

  Routine Description:

    Creates a shortcut on the desktop, if desired.

  Arguments:

    fCorrectWay     -   Indicates whether the shortcut should be created.
    lpDirFileName   -   Directory and filename where the shortcut
                        points to.
    lpWorkingDir    -   Working directory (optional).
    lpDisplayName   -   Display name for the shortcut.                            

  Return Value:

    None.

--*/
void
BadCreateShortcut(
    IN BOOL   fCorrectWay,
    IN LPSTR  lpDirFileName,
    IN LPCSTR lpWorkingDir,
    IN LPSTR  lpDisplayName
    )
{
    //
    // Hard-coded paths are simply a bad practice. APIs are available that
    // return proper locations for common folders. Examples are the
    // Program Files, Windows, and Temp directories. SHGetFolderPath,
    // GetWindowsDirectory, and GetTempPath would provide the correct path
    // in each case. Hard-coded paths should never be used.
    //
    CShortcut   cs;        

    if (!fCorrectWay) {
        //
        // A hard-coded path is very bad! We should use SHGetFolderPath
        // to get the correct path.
        //
        const char szDirName[] = "C:\\WINDOWS\\DESKTOP";

        cs.CreateShortcut(szDirName,
                          lpDirFileName,
                          lpDisplayName,
                          "-runapp",
                          (LPCSTR)lpWorkingDir,
                          SW_SHOWNORMAL);

    } else {
        //
        // Create the shortcut properly.
        // Notice that we pass a CSIDL for the "common" desktop
        // directory. We want this to be displayed to All Users.
        //
        cs.CreateShortcut(lpDirFileName,
                          lpDisplayName,
                          "-runapp",
                          lpWorkingDir,
                          SW_SHOWNORMAL,
                          CSIDL_COMMON_DESKTOPDIRECTORY);
    }
}

#if 0
/*++

  Routine Description:

    Demonstrates an AV because we used a fixed-size
    buffer for a call to GetFileVersionInfo.
    

  Arguments:

    fCorrect        -       A flag to indicate if we should work properly.
         

  Return Value:

    None.

--*/
void
BadBufferOverflow(
    IN BOOL fCorrect
    )
{
    //
    // Although this problem has only been seen in one application, it's
    // worth mentioning here. On Win9x/ME, version resources on DLLs are much
    // smaller than ones on NT/2000/XP. Specifically, in the case below,
    // the Windows 2000/XP resource size is 6 times larger than the 9x/ME size!
    // One particular application used a stack-based buffer (which is fixed in
    // size) for the call to GetFileVersionInfo. This worked properly on
    // Win9x/ME because the required size was very small. But the required size
    // is larger on NT/2000/XP, thus the buffer gets overwritten, causing stack
    // corruption. The proper way is to call the GetFileVersionInfoSize API,
    // and then allocate a heap-based buffer of an approriate size.
    //
    //
    DWORD               cbReqSize = 0;
    DWORD               dwHandle = 0;
    DWORDLONG           dwVersion = 0;
    UINT                nLen = 0;    
    VS_FIXEDFILEINFO*   pffi;
    char                szDll[MAX_PATH];
    HRESULT             hr;
    PVOID               pBadBlock = NULL;
    PVOID               pVersionBlock = NULL;
    HANDLE              hHeap = NULL;
    SYSTEM_INFO         si;

    hr = StringCchPrintf(szDll,
                         sizeof(szDll),
                         "%hs\\%hs",
                         g_ai.szSysDir,
                         szDll);

    if (FAILED(hr)) {
        return;
    }

    //
    // Get the size of the buffer that will be required for a call to
    // GetFileVersionInfo.
    //
    cbReqSize = GetFileVersionInfoSize(szDll, &dwHandle);

    if (!cbReqSize == 0) {
        return;
    }

    if (fCorrect) {
        //
        // If we're doing this properly, allocate memory from the heap.
        //
        pVersionBlock = HeapAlloc(GetProcessHeap(),
                                  HEAP_ZERO_MEMORY,
                                  cbReqSize);

        if (!pVersionBlock) {
            return;
        }

        //
        // Get the version info and query the root block.
        //
        if (!GetFileVersionInfo(szDll,
                                dwHandle,
                                cbReqSize,
                                pVersionBlock)) {
            goto cleanup;
        }

        if (VerQueryValue(pVersionBlock,
                          "\\",
                          (LPVOID*)&pffi,
                          &nLen))
        {
                          
            dwVersion = (((DWORDLONG)pffi->dwFileVersionMS) << 32) + 
                         pffi->dwFileVersionLS;
        }
    } else {
        //
        // Use a non-growable heap that's way too small.
        //
        GetSystemInfo(&si);

        //
        // Create a block and allocate memory from it.
        //
        hHeap = HeapCreate(0, 
                           si.dwPageSize,
                           504); // this was the size needed on Win9x                               

        if (!hHeap) {
            return;
        }

        pBadBlock = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 504);

        if (!pBadBlock) {
            HeapDestroy(hHeap);
            return;
        }

        //
        // Get the version info, passing the buffer (which is too small)
        // with a size argument that's incorrect.
        //
        if (!GetFileVersionInfo(szDll,
                                dwHandle,
                                3072,        // this is the size needed on Win2K/XP
                                pBadBlock))
        {
            goto cleanup;
        }

        if (VerQueryValue(pBadBlock,
                          "\\",
                          (LPVOID*)&pffi,
                          &nLen))
        { 
        
            dwVersion = (((DWORDLONG)pffi->dwFileVersionMS) << 32) +
                         pffi->dwFileVersionLS;
        }
    }

cleanup:

    if (pBadBlock) {
        HeapFree(hHeap, 0, pBadBlock);
    }

    if (pVersionBlock) {
        HeapFree(GetProcessHeap(), 0, pVersionBlock);
    }

    if (hHeap) {
        HeapDestroy(hHeap);
    }
}
#endif

/*++

  Routine Description:

    Demonstrates an AV because we used a non-growable heap
    during file operations.   

  Arguments:

    None.
         
  Return Value:

    None.

--*/
void
BadCorruptHeap(
    void
    )
{
    SYSTEM_INFO     SystemInfo;
    HANDLE          hHeap;
    HRESULT         hr;
    char*           pszBigBlock = NULL;
    char*           pszBigBlock1 = NULL;
    char*           pszTestInputFile = NULL;
    char*           pszTestOutputFile = NULL;
    FILE*           hFile = NULL;
    FILE*           hFileOut = NULL;
    DWORD           dwCount = 0;
    int             nCount = 0;
    const char      szAlpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
    const char      szMsg[] = "This is a corrupted heap -- Heap Overflow! Bad Programming!";

    //
    // Get system page size.
    //
    GetSystemInfo(&SystemInfo);

    //
    // Create a local, non-growable heap.
    //
    hHeap = HeapCreate(0, SystemInfo.dwPageSize, 0x7FFF8);

    if (!hHeap) {        
        return;
    }

    //
    // Allocate memory from the local heap.
    //
    pszBigBlock = (char*)HeapAlloc(hHeap, 0, 0x6FFF8);
    pszBigBlock1 = (char*)HeapAlloc(hHeap, 0, 0xFFF);
    pszTestInputFile = (char*)HeapAlloc(hHeap, 0, MAX_PATH);
    pszTestOutputFile = (char*)HeapAlloc(hHeap, 0, MAX_PATH);

    if (!pszBigBlock || !pszBigBlock1 || !pszTestInputFile || !pszTestOutputFile) {
        HeapDestroy(hHeap);
        return;
    }

    hr = StringCchCopy(pszBigBlock1, 0xFFF, szMsg);

    if (FAILED(hr)) {
        goto exit;
    }
    
    GetCurrentDirectory(MAX_PATH, pszTestInputFile);
    
    //
    // Set up the file names.
    //
    hr = StringCchCopy(pszTestOutputFile, MAX_PATH, pszTestInputFile);

    if (FAILED(hr)) {
        goto exit;
    }

    hr = StringCchCat(pszTestInputFile, MAX_PATH, "\\test.txt");

    if (FAILED(hr)) {
        goto exit;
    }

    hr = StringCchCat(pszTestOutputFile, MAX_PATH, "\\test_out.txt");

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Open the file for writing.
    //
    hFileOut = fopen(pszTestInputFile, "wt");    

    if (!hFileOut) {        
        goto exit;
    }

    //
    // Put some junk data in the file - about 1.5 MBs worth.
    //
    for (dwCount = 0; dwCount < 0xABCD; dwCount++) {
        fwrite(szAlpha, sizeof(char), 36, hFileOut);
    }

    fclose(hFileOut);

    //
    // Open the files for reading & writing.
    //
    hFileOut = fopen(pszTestInputFile, "r");

    if (!hFileOut) {
        goto exit;
    }

    hFile = fopen(pszTestOutputFile, "w");

    if (!hFile) {
        goto exit;
    }
    
    //
    // Read some data from the large file.
    //
    nCount = fread(pszBigBlock, sizeof(char), 0x6FFFF, hFileOut);
    
    if (!nCount) {        
        goto exit;
    }
    
    //
    // Write some test data to a separate file.
    //
    nCount = fwrite(pszBigBlock, sizeof(char), nCount, hFile);
    
exit:

    if (hFile) {
        fclose(hFile);
    }

    if (hFileOut) {
        fclose(hFileOut);
    }

    HeapFree(hHeap, 0, pszBigBlock);
    HeapFree(hHeap, 0, pszBigBlock1);
    HeapFree(hHeap, 0, pszTestInputFile);
    HeapFree(hHeap, 0, pszTestOutputFile);
    HeapDestroy(hHeap);
}

/*++

  Routine Description:

    Loads a library, frees it, then tries to call an exported
    function. This will cause an access violation.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
BadLoadLibrary(
    void
    )
{
    char        szDll[MAX_PATH];
    const char  szDemoDll[] = "demodll.dll";
    HINSTANCE   hInstance;
    HRESULT     hr;

    hr = StringCchPrintf(szDll,
                         sizeof(szDll),
                         "%hs\\%hs",
                         g_ai.szCurrentDir,
                         szDemoDll);

    if (FAILED(hr)) {
        return;
    }
    
    hInstance = LoadLibrary(szDll);

    if (!hInstance) {
        return;
    }

    //
    // Get the address of the function.
    //
    DemoAppExpFunc = (LPFNDEMOAPPEXP)GetProcAddress(hInstance, "DemoAppExp");

    FreeLibrary(hInstance);
}

/*++

  Routine Description:

    Uses the WriteFile API and passes NULL for lpBuffer.
    This is legal on Win9x, not on NT/2000/XP.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
BadWriteToFile(
    void
    )
{
    //
    // On Win9x/ME, applications could call the WriteFile API and pass
    // a NULL for the lpBuffer argument. This would be interpreted as
    // zeros. On NT/2000, this is not the case and this call will fail.    
    //
    char    szTempFile[MAX_PATH];
    char    szTempPath[MAX_PATH];
    UINT    uReturn;
    HANDLE  hFile;
    BOOL    fReturn = FALSE;
    DWORD   cbBytesWritten;
    DWORD   cchSize;
    
    cchSize = GetTempPath(sizeof(szTempPath), szTempPath);

    if (cchSize > sizeof(szTempPath) || cchSize == 0) {
        return FALSE;
    }

    //
    // Build a path to a temp file.
    //
    uReturn = GetTempFileName(szTempPath, "_dem", 0, szTempFile);

    if (!uReturn) {
        return FALSE;
    }

    //
    // Get a handle to the newly created file.
    // 
    hFile = CreateFile(szTempFile,
                       GENERIC_WRITE,
                       FILE_SHARE_WRITE | FILE_SHARE_READ,
                       NULL,
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        return FALSE;
    }

    //
    // Try to write some data to the file, but pass a NULL buffer.
    //
    fReturn = WriteFile(hFile, NULL, 10, &cbBytesWritten, NULL);

    CloseHandle(hFile);

    return fReturn;
}

/*++

  Routine Description:

    Wrapper function for CreateProcess. Doesn't initialize the
    STARTUPINFO structure properly, causing the process not to
    be launched.

  Arguments:

    lpApplicationName   -   Application name to launch.
    lpCommandLine       -   Command line arguments to pass to the EXE.
    fLaunch             -   A flag to indicate if we should work properly.
    
  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
BadCreateProcess(
    IN LPSTR lpApplicationName,
    IN LPSTR lpCommandLine,
    IN BOOL  fLaunch
    )
{
    //
    // On Win9x/ME, the CreateProcess API isn't overly concerned with the
    // members of the STARTUPINFO structure. On NT/2000/XP, more parameter
    // validation is done, and if the parameters are bad or incorrect, the
    // call fails. This causes an application error message to appear.
    //
    BOOL                fReturn = FALSE;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    if (!lpApplicationName) {
        return FALSE;
    }

    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    if (fLaunch) {
        fReturn = CreateProcess(lpApplicationName,
                                lpCommandLine,
                                NULL,
                                NULL,
                                FALSE,
                                0,
                                NULL,
                                NULL,
                                &si,
                                &pi);
    
    } else {
        //
        // Provide bad values for structure members.
        //
        si.lpReserved   =   "Never store data in reserved areas...";
        si.cbReserved2  =   1;
        si.lpReserved2  =   (LPBYTE)"Microsoft has these reserved for a reason...";
        si.lpDesktop    =   "Bogus desktop!!!!";

        fReturn = CreateProcess(lpApplicationName,
                                lpCommandLine,
                                NULL,
                                NULL,
                                FALSE,
                                0,
                                NULL,
                                NULL,
                                &si,
                                &pi);
    }

    if (pi.hThread) {
        CloseHandle(pi.hThread);
    }

    if (pi.hProcess) {
        CloseHandle(pi.hProcess);
    }
    
   return fReturn;
}

/*++

  Routine Description:

    Attempts to save/retrieve our position information to
    the registry. We perform this operation in HKLM, not
    HKCU. This demonstrates what happens when an application
    attempts to save information to the registry when the user
    does not have permissions to do so because they're not an
    administrator.

  Arguments:

    fSave   -   If true, indicates we're saving data.
    *lppt   -   A POINT structure that contains/receives our data.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
BadSaveToRegistry(
    IN     BOOL   fSave,
    IN OUT POINT* lppt
    )
{
    BOOL    bReturn = FALSE;
    HKEY    hKey;
    HKEY    hKeyRoot;
    DWORD   cbSize = 0, dwDisposition = 0;
    LONG    lRetVal;
    char    szKeyName[] = "DlgCoordinates";
    
    //
    // Initialize our coordinates in case there's no data there.
    //
    if (!fSave) {
        lppt->x = lppt->y = 0;
    }

    if (g_ai.fEnableBadFunc) {
        hKeyRoot = HKEY_LOCAL_MACHINE;
    } else {
        hKeyRoot = HKEY_CURRENT_USER;
    }

    //
    // Open the registry key (or create it if the first time being used).
    //
    lRetVal = RegCreateKeyEx(hKeyRoot,
                             REG_APP_KEY,
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_QUERY_VALUE | KEY_SET_VALUE,
                             0,
                             &hKey,
                             &dwDisposition);
    
    if (ERROR_SUCCESS != lRetVal) {
        return FALSE;
    }

    //
    // Save or retrieve our coordinates.
    //
    if (fSave) {
        lRetVal = RegSetValueEx(hKey,
                                szKeyName,
                                0,
                                REG_BINARY,
                                (const BYTE*)lppt,
                                sizeof(*lppt));

        if (ERROR_SUCCESS != lRetVal) {
            goto exit;
        }
    
    } else {
        cbSize = sizeof(*lppt);
        lRetVal = RegQueryValueEx(hKey,
                                  szKeyName,
                                  0,
                                  0,
                                  (LPBYTE)lppt,
                                  &cbSize);

        if (ERROR_SUCCESS != lRetVal) {
            goto exit;
        }
    }

    bReturn = TRUE;

exit:

    RegCloseKey(hKey);

    return bReturn;
}

/*++

  Routine Description:

    Attempts to create a temp file (that won't be used)
    in the Windows directory. We do this to demonstrate
    what happens when an application attempts to write
    to a directory that the user does not have access to
    because they are not an administrator.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
BadCreateTempFile(
    void
    )
{
    char    szTempFile[MAX_PATH];
    HANDLE  hFile;
    HRESULT hr;

    //
    // We return TRUE if these functions fail because returning
    // FALSE causes an error to be displayed, and Compatiblity
    // Fixes will not correct the error.
    //
    hr = StringCchPrintf(szTempFile,
                         sizeof(szTempFile),
                         "%hs\\demotemp.tmp",
                         g_ai.szWinDir);

    if (FAILED(hr)) {
        return TRUE;
    }
    
    hFile = CreateFile(szTempFile,
                       GENERIC_ALL,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                       NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        return FALSE;
    }

    CloseHandle(hFile);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\dialog.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Dialog.cpp

  Abstract:

    Implements the dialog procedures for the 
    application.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/
#include "demoapp.h"

extern APPINFO g_ai;

DWORD g_nCount = 0;

//
// Progress bar objects.
//
CProgress cprog;
CProgress cprg;

/*++

  Routine Description:

    Creates the extraction dialog box. This is the simple little progress
    dialog.

  Arguments:

    hInstance   -   Applicaiton instance handle.

  Return Value:

    On success, handle to the dialog.

--*/
HWND
CreateExtractionDialog(
    IN HINSTANCE hInstance
    )
{
    WNDCLASS    wndclass;
    RECT        rcDesktop;
    RECT        rcDialog;
    RECT        rcTaskbar;
    HWND        hWndTaskbar;
    int         nWidth = 0;
    int         nHeight = 0;
    int         nTaskbarHeight = 0;
    
    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC)ExtractionDialogProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = DLGEXTRACT_CLASS;

    if (!RegisterClass(&wndclass)) {
        return NULL;
    }
    
    g_ai.hWndExtractDlg = CreateDialog(hInstance,
                                       MAKEINTRESOURCE(IDD_EXTRACT),
                                       NULL,
                                       ExtractionDialogProc);

    if (!g_ai.hWndExtractDlg) {
        return NULL;
    }

    //
    // Get the coords of the desktop window and place the dialog.
    // Take into account the size of the taskbar.    
    //
    hWndTaskbar = FindWindow("Shell_TrayWnd", NULL);

    ZeroMemory(&rcTaskbar, sizeof(RECT));

    if (hWndTaskbar) {
        GetWindowRect(hWndTaskbar, &rcTaskbar);
    }

    GetWindowRect(GetDesktopWindow(), &rcDesktop);
    GetWindowRect(g_ai.hWndExtractDlg, &rcDialog);

    nWidth  = rcDialog.right - rcDialog.left;
    nHeight = rcDialog.bottom - rcDialog.top;
    
    if (rcTaskbar.top != 0) {
        nTaskbarHeight = rcTaskbar.bottom - rcTaskbar.top;
    }

    InflateRect(&rcDesktop, -5, -5);

    SetWindowPos(g_ai.hWndExtractDlg,
                 HWND_TOPMOST, 
                 rcDesktop.right - nWidth,
                 rcDesktop.bottom - nHeight - nTaskbarHeight,
                 0,
                 0,
                 SWP_NOSIZE | SWP_SHOWWINDOW);

    return g_ai.hWndExtractDlg;
}

/*++

  Routine Description:

    Runs the message loop for extraction dialog.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
ExtractionDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:
        //
        // Create the progress bar and enable the timer
        //
        cprog.Create(hWnd, g_ai.hInstance, "PROGBAR", 58, 73, 270, 20);
        cprog.SetMin(g_nCount);
        cprog.SetMax(100);
        cprog.SetPos(g_nCount);

        SetTimer(hWnd, IDC_TIMER, 35, NULL);
        break;

    case WM_TIMER:

        cprog.SetPos(++g_nCount);

        if (cprog.GetPos() == 100) {
            KillTimer(hWnd, IDC_TIMER);
            DestroyWindow(hWnd);
        }

        break;
        
    default:
        break;

    }

    return FALSE;
}

/*++

  Routine Description:

    Runs the message loop for welcome dialog.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
WelcomeDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:        

        SetWindowPos(hWnd, HWND_TOP, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);            
        SetForegroundWindow(hWnd);
        SetFocus(GetDlgItem(hWnd, IDOK));
        return FALSE;    

    case WM_CLOSE:
        //
        // Pop up the 'do you want to exit' dialog.
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_EXIT),
                  hWnd,
                  ExitSetupDialogProc);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            //
            // See if the left Ctrl key is down.
            //
            if (GetKeyState(VK_LCONTROL) & 0x80000000) {
                TestIncludeExclude(hWnd);
            } else {
                EndDialog(hWnd, 0);
            }
            
            break;

        case IDCANCEL:
            //
            // Pop up the 'do you want to exit' dialog.
            //
            DialogBox(g_ai.hInstance,
                      MAKEINTRESOURCE(IDD_EXIT),
                      hWnd,
                      ExitSetupDialogProc);
            break;

        default:
            break;
        }
        
    default:
        break;
    
    }

    return FALSE;
}

/*++

  Routine Description:

    Runs the message loop for exit setup dialog.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
ExitSetupDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 

    case WM_CLOSE:
    
        EndDialog(hWnd, 0);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_EXIT_RESUME:
        
            EndDialog(hWnd, 0);
            break;

        case IDC_EXIT_EXIT:
        
            g_ai.fClosing = TRUE;
            EndDialog(hWnd, 0);
            PostQuitMessage(0);
            break;

        default:
            break;
            
        }
        
    default:
        break;
        
    }

    return FALSE;
}

/*++

  Routine Description:

    Runs the message loop for the installed components dialog.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
CheckComponentDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:
    
        ShowWindow(hWnd, SW_SHOWNORMAL);
        UpdateWindow(hWnd);
        SetTimer(hWnd, IDC_TIMER, 3000, NULL);            
        break;

    case WM_TIMER:

        KillTimer(hWnd, IDC_TIMER);

        if (g_ai.fEnableBadFunc) {
            BadLoadBogusDll();
        }

        EndDialog(hWnd, 0);
        break;

    default:
        break;

    }

    return FALSE;
}

/*++

  Routine Description:

    Runs the message loop for the free disk space dialog.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
CheckFreeDiskSpaceDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:

        ShowWindow(hWnd, SW_SHOWNORMAL);
        UpdateWindow(hWnd);
        SetTimer(hWnd, IDC_TIMER, 3000, NULL);            
        break;

    case WM_TIMER:
    {
        BOOL    bReturn = FALSE;
        char    szError[MAX_PATH];

        KillTimer(hWnd, IDC_TIMER);

        if (g_ai.fEnableBadFunc) {
            bReturn = BadGetFreeDiskSpace();
                    
            if (!bReturn) {
                LoadString(g_ai.hInstance, IDS_NO_DISK_SPACE, szError, sizeof(szError));
                MessageBox(hWnd, szError, 0, MB_ICONERROR);
            }
            
            EndDialog(hWnd, 0);
        }
        break;
    }
    
    default:
        break;

    }

    return FALSE;
}

/*++

  Routine Description:

    Runs the message loop for the ready to copy dialog box.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
ReadyToCopyDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:
    
        SetFocus(GetDlgItem(hWnd, IDOK));            
        return FALSE;
        
    case WM_CLOSE:
        //
        // Pop up the 'do you want to exit' dialog
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_EXIT),
                  hWnd,
                  ExitSetupDialogProc);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        
            EndDialog(hWnd, 0);
            break;

        case IDCANCEL:
            //
            // Pop up the 'do you want to exit' dialog
            //
            DialogBox(g_ai.hInstance,
                      MAKEINTRESOURCE(IDD_EXIT),
                      hWnd,
                      ExitSetupDialogProc);

            break;

        default:
            break;
        }

    default:
        break;

    }

    return FALSE;
}

/*++

  Routine Description:

    Runs the message loop for the copy files dialog.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
CopyFilesDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:
        //
        // Create the progress bar and enable the timer
        //
        g_nCount = 0;
        cprg.Create(hWnd, g_ai.hInstance, "PROGBAR2", 10, 49, 415, 30);
        cprg.SetMin(g_nCount);
        cprg.SetMax(100);
        cprg.SetPos(g_nCount);            

        SetTimer(hWnd, IDC_TIMER, 35, NULL);

        SetDlgItemText(hWnd, IDT_COPY_LABEL, "Copying files...");
        
        //
        // The progress bar is for demonstration sake.
        // Copy the files to \Program Files\Compatibility Demo
        //
        CopyAppFiles(hWnd);            
            
        break;
        
    case WM_TIMER:
    
        cprg.SetPos(++g_nCount);

        if (cprg.GetPos() == 100) {
            KillTimer(hWnd, IDC_TIMER);
            EndDialog(hWnd, 0);
        }

        break;

    default:
        break;

    }

    return FALSE;
}

/*++

  Routine Description:

    Runs the message loop for the view readme dialog.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
ViewReadmeDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:
        //
        // Make the dialog "flash" -
        // ForceApplicationFocus will fix this.
        //
        SetForegroundWindow(hWnd);
        SetFocus(GetDlgItem(hWnd, IDOK));            
        break;
        
    case WM_CLOSE:
        //
        // Pop up the 'do you want to exit' dialog.
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_EXIT),
                  hWnd,
                  ExitSetupDialogProc);

        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            //
            // If the user has requested that the readme be displayed,
            // show it.
            //
            if (IsDlgButtonChecked(hWnd, IDR_VIEW_README)) {
                if (g_ai.fEnableBadFunc) {
                    BadDisplayReadme(FALSE);
                } else {
                    BadDisplayReadme(TRUE);
                }
            }
            
            EndDialog(hWnd, 0);
            break;

        default:
            break;
        }

    default:
        break;

    }

    return FALSE;
}

/*++

  Routine Description:

    Runs the message loop for the reboot dialog.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK 
RebootDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:
        //
        // Default to restart the computer.
        //
        CheckDlgButton(hWnd, IDR_RESTART_NOW, BST_CHECKED);
        SetFocus(GetDlgItem(hWnd, IDOK));            
        return FALSE;
        
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            //
            // If the user requested a reboot, do it.
            //
            if (IsDlgButtonChecked(hWnd, IDR_RESTART_NOW)) {
                if (g_ai.fEnableBadFunc) {
                    BadRebootComputer(FALSE);
                } else {
                    BadRebootComputer(TRUE);
                }
            }
            
            EndDialog(hWnd, 0);
            PostQuitMessage(0);

            break;

        default:
            break;
        }

    default:
        break;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\demoapp.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Demoapp.h

  Abstract:

    Contains constants, function prototypes, and
    structures used by both applications.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised
    02/13/02    rparsons    Use strsafe functions

--*/
#include <windows.h>
#include <winspool.h>
#include <commdlg.h>
#include <shellapi.h>
#include <process.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <stdio.h>

#include "splash.h"
#include "registry.h"
#include "progress.h"
#include "shortcut.h"
#include "badfunc.h"
#include "dialog.h"
#include "resource.h"

//
// Everything we do will be in cch not in cb.
//
#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>

//
// Application titles and classes.
//
#define MAIN_APP_TITLE  "Application Compatibility Demo"
#define SETUP_APP_TITLE "Application Compatibility Demo Setup"
#define MAIN_APP_CLASS  "MAINAPP"
#define SETUP_APP_CLASS "SETUPAPP"

//
// Our own control identifiers.
//
#define IDC_TIMER   100
#define IDC_EDIT    1010

//
// Registry keys that we need to refer to.
//
#define REG_APP_KEY             "Software\\Microsoft\\DemoApp"
#define PRODUCT_OPTIONS_KEY     "SYSTEM\\CurrentControlSet\\Control\\ProductOptions"
#define CURRENT_VERSION_KEY     "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"

//
// The directory that we should install our files to.
//
#define COMPAT_DEMO_DIR         "Compatibility Demo"

//
// Class for our extraction dialog.
//
#define DLGEXTRACT_CLASS        "DLGEXTRACT"

//
// Custom menu items only displayed in 'extended' mode.
//
#define IDM_ACCESS_VIOLATION    5010
#define IDM_EXCEED_BOUNDS       5011
#define IDM_FREE_MEM_TWICE      5012
#define IDM_FREE_INVALID_MEM    5013
#define IDM_PRIV_INSTRUCTION    5014
#define IDM_STACK_CORRUPTION    5015
#define IDM_HEAP_CORRUPTION     5016

//
// Custom menu items only displayed in 'internal' mode.
//
#define IDM_PROPAGATION_TEST    6010

//
// Resource IDs for our bitmaps contained in demodll.dll.
// Don't change!!!
//
#define IDB_XP_SPLASH_256       112
#define IDB_XP_SPLASH           111
#define IDB_W2K_SPLASH_256      106
#define IDB_W2K_SPLASH          105

//
// Macros
//
#define MALLOC(h,s)     HeapAlloc((h), HEAP_ZERO_MEMORY, (s))
#define FREE(h,b)       HeapFree((h), 0, (b))

//
// Function prototypes
//
void
LoadFileIntoEditBox(
    void
    );

void
ShowSaveDialog(
    void
    );

BOOL
CenterWindow(
    IN HWND hWnd
    );

void
IsWindows9x(
    void
    );

void
IsWindowsXP(
    void
    );

void
DisplayFontDlg(
    IN HWND hWnd
    );

BOOL
CreateShortcuts(
    IN HWND hWnd
    );

BOOL
CopyAppFiles(
    IN HWND hWnd
    );

BOOL
DemoAppInitialize(
    IN LPSTR lpCmdLine
    );

BOOL
ModifyTokenPrivilege(
    IN LPCSTR lpPrivilege,
    IN BOOL   fDisable
    );

BOOL
ShutdownSystem(
    IN BOOL fForceClose,
    IN BOOL fReboot
    );

BOOL
IsAppAlreadyInstalled(
    void
    );

HWND
CreateFullScreenWindow(
    void
    );

HWND
CreateExtractionDialog(
    IN HINSTANCE hInstance
    );

UINT
InitSetupThread(
    IN void* pArguments
    );

BOOL
InitMainApplication(
    IN HINSTANCE hInstance
    );

BOOL
InitSetupApplication(
    IN HINSTANCE hInstance
    );

BOOL
InitMainInstance(
    IN HINSTANCE hInstance,
    IN int       nCmdShow
    );

BOOL
InitSetupInstance(
    IN HINSTANCE hInstance,
    IN int       nCmdShow
    );

LRESULT
CALLBACK
MainWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

LRESULT
CALLBACK
SetupWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
PrintDemoText(
    IN HWND  hWnd,
    IN LPSTR lpTextOut
    );

void
AddExtendedItems(
    IN HWND hWnd
    );

void
AddInternalItems(
    IN HWND hWnd
    );

void
TestIncludeExclude(
    IN HWND hWnd
    );

void
AccessViolation(
    void
    );

void
ExceedArrayBounds(
    void
    );

void
FreeMemoryTwice(
    void
    );

void
FreeInvalidMemory(
    void
    );

void
PrivilegedInstruction(
    void
    );

void
HeapCorruption(
    void
    );

void
ExtractExeFromLibrary(
    IN  DWORD cchSize,
    OUT LPSTR pszOutputFile
    );

//
// The number of files we're installing.
//
#define NUM_FILES 4

//
// The number of shortcuts we're creating.
//
#define NUM_SHORTCUTS (NUM_FILES - 1)

//
// Contains information about shortcuts to be created.
//
typedef struct _SHORTCUT {
    char szFileName[MAX_PATH];      // file name for shortcut
    char szDisplayName[MAX_PATH];   // display name for shortcut
} SHORTCUT, *LPSHORTCUT;

//
// Contains all the information we'll need to access throughout the app.
//
typedef struct _APPINFO {
    HINSTANCE   hInstance;                  // app instance handle
    HWND        hWndExtractDlg;             // extraction dialog handle
    HWND        hWndMain;                   // main window handle
    HWND        hWndEdit;                   // edit window handle
    BOOL        fInternal;                  // indicates if internal behavior is enabled
    BOOL        fInsecure;                  // indicates if we should do things that might not be secure
    BOOL        fEnableBadFunc;             // indicates if bad functionality should be enabled
    BOOL        fRunApp;                    // indicates if we should run the app
    BOOL        fClosing;                   // indicates if the app is closing
    BOOL        fWin9x;                     // indicates if we're running on Win9x/ME (used internally)
    BOOL        fWinXP;                     // indicates if we're running on XP (used internally)
    BOOL        fExtended;                  // indicates if extended behavior is enabled
    UINT        cFiles;                     // count of shortcuts to create
    char        szDestDir[MAX_PATH];        // contains the full path where files will be stored
    char        szCurrentDir[MAX_PATH];     // contains the path that we're currently running from
    char        szWinDir[MAX_PATH];         // contains the path to %windir%
    char        szSysDir[MAX_PATH];         // contains the path to %windir%\System(32)
    SHORTCUT    shortcut[NUM_SHORTCUTS];    // struct that contains information about our shortcuts
} APPINFO, *LPAPPINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\badfunc.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Badfunc.h

  Abstract:

    Contains constants, function prototypes, and
    structures used by the bad functions.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/

#define REG_WORDPAD             "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\WORDPAD.EXE"
#define DEMO_REG_APP_ROOT_KEY   "Software\\Microsoft"
#define DEMO_REG_APP_KEY        "Software\\Microsoft\\DemoApp2"
#define DEMO_REG_APP_SUB_KEY    "Software\\Microsoft\\DemoApp2\\Sub"

typedef void (WINAPI *LPFNDEMOAPPEXP)(DWORD* dwParam);
typedef void (WINAPI *LPFNDEMOAPPMESSAGEBOX)(HWND hWnd);

BOOL
BadIsWindows95(
    void
    );

void
BadLoadBogusDll(
    void
    );

BOOL
BadEnumPrinters(
    void
    );

HANDLE
BadOpenPrinter(
    void
    );

BOOL
BadDeleteRegistryKey(
    void
    );

BOOL
BadGetFreeDiskSpace(
    void
    );

void
BadDisplayReadme(
    IN BOOL fDisplay
    );

void
BadRebootComputer(
    IN BOOL fReboot
    );

void
BadLaunchHelpFile(
    IN BOOL fDisplay
    );

void
BadCreateShortcut(
    IN BOOL   fCorrectWay,
    IN LPSTR  lpDirFileName,
    IN LPCSTR lpWorkingDir,
    IN LPSTR  lpDisplayName
    );

#if 0
void
BadBufferOverflow(
    IN BOOL fCorrect
    );
#endif

void
BadCorruptHeap(
    void
    );

void
BadLoadLibrary(
    void
    );

BOOL
BadWriteToFile(
    void
    );

BOOL
BadCreateProcess(
    IN LPSTR lpApplicationName,
    IN LPSTR lpCommandLine,
    IN BOOL  fLaunch
    );

BOOL
BadSaveToRegistry(
    IN     BOOL   fSave,
    IN OUT POINT* lppt
    );

BOOL
BadCreateTempFile(
    void
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\dialog.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Dialog.h

  Abstract:

    Contains constants, function prototypes, and
    structures used by the dialog boxes.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/

INT_PTR
CALLBACK 
RebootDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK 
ViewReadmeDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK 
CopyFilesDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK 
ReadyToCopyDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK 
CheckFreeDiskSpaceDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK 
CheckComponentDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK 
ExitSetupDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK 
WelcomeDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK 
ExtractionDialogProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\extend.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Extend.cpp

  Abstract:

    Contains a list of extended bad functions.
    These are not compatibility problems, but
    can be used for training purposes.

  Notes:

    ANSI only - must run on Win9x.

  History:

    05/16/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/
#include "demoapp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Performs a simple access violation.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
AccessViolation(
    void
    )
{
    // We could perform hundreds of different operations to get an
    // access violation. The one below attempts to copy the string
    // 'foo' to a NULL address.

    memcpy(NULL, "foo", 3);

    /* Here's another:

    WCHAR szArray[10];
    int nCount = 0;

    for (nCount = 0; nCount != 12; nCount++)
    {
        wcscpy((LPWSTR)szArray[nCount], L"A");
    }*/   
}

/*++

  Routine Description:

    Throws a EXCEPTION_ARRAY_BOUNDS_EXCEEDED exception.

  Arguments:

    None.

  Return Value:

    None.

--*/

//
// Disable the warning: 'frame pointer register 'ebp' modified by
// inline assembly code. We're doing this intentionally.
//
#pragma warning( disable : 4731 )

void
ExceedArrayBounds(
    void
    )
{
    _asm {
        
        push    ebp;                            // Save the base pointer
        mov     ebp, esp;                       // Set up the stack frame
        sub     esp, 8;                         // Adjust for 8 bytes worth of 
                                                // local variables
        push    ebx;                            // Save EBX for later
        mov     dword ptr [ebp-8], 1;           // Initialize a DWORD to 1
        mov     dword ptr [ebp-4], 2;           // Initialize a DWORD to 2
        mov     eax, 0;                         // Zero out EAX
        bound   eax, [ebp-8];                   // If [ebp-8] is out of EAX bounds,
                                                // an exception will occur
        xor     eax, eax;                       // Zero out EAX
        pop     ebx;                            // Restore EBX from earlier
        mov     esp, ebp;                       // Restore the stack frame
        pop     ebp;                            // Restore the base pointer
        ret;                                    // We're done
    }
}

#pragma warning( default : 4731 )

/*++

  Routine Description:

    Frees memory allocated from the heap twice.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
FreeMemoryTwice(
    void
    )
{
    LPSTR   lpMem = NULL;

    lpMem = (LPSTR)HeapAlloc(GetProcessHeap(), 0, MAX_PATH);

    if (!lpMem) {
        return;
    }

    HeapFree(GetProcessHeap(), 0, lpMem);
    HeapFree(GetProcessHeap(), 0, lpMem);
}

/*++

  Routine Description:

    Allocates memory from the heap, moves the pointer,
    then tries to free it.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
FreeInvalidMemory(
    void
    )
{
    LPSTR   lpMem = NULL;

    lpMem = (LPSTR)HeapAlloc(GetProcessHeap(), 0, MAX_PATH);

    if (!lpMem) {
        return;
    }

    lpMem++;
    lpMem++;

    HeapFree(GetProcessHeap(), 0, lpMem);
}

/*++

  Routine Description:

    Executes a privileged instruction, which causes an exception.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
PrivilegedInstruction(
    void
    )
{
    _asm {
        cli;
    }
}

/*++

  Routine Description:

    Allocates memory from the heap, then walks all over it.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
HeapCorruption(
    void
    )
{
    UINT    n, nTotalChars;
    char    szCorruptChars[] = {'B','A','D','A','P','P','#'};
    char*   pChar = NULL;
    
    //
    // Allocate a small block of heap to contain a string of length STRINGLENGTH.
    //
    pChar = (char*)GlobalAlloc(GPTR, 13);
    
    if (!pChar) {
        return;    
    } else {
        //
        // Determine the total number of chars to copy (including Corrupt Bytes)
        //
        nTotalChars = 12 + 1;
   
        //
        // Write a string of STRINGLENGTH length, plus some extra (common mistake).
        //
        for (n = 0; n < nTotalChars; n++) {
            //
            // Write the characters of CorruptChars into memory.
            //
            if (n < (UINT)12) {
                pChar[n] = szCorruptChars[n % 6];         
            } else {
                //
                // Corruption will be written with a nice pattern of # chars...
                //
                pChar[n] = szCorruptChars[6];	   
            }
        }

        //
        // Of course, we should NULL terminate the string.
        //
        pChar[n] = 0;

        GlobalFree((HGLOBAL)pChar);    
    }
}

/*++

  Routine Description:
  
    Launches a child process (version.exe) which is embedded
    within our DLL.
    
  Arguments:
  
    cchSize         -   Size of the output buffer in characters.
    pszOutputFile   -   Points to a buffer that will be filled
                        with the path to the output file.
    
  Return value:
  
    On success, pszOutputFile points to the file.
    On failure, pszOutputFile is NULL.
    
--*/
void
ExtractExeFromLibrary(
    IN  DWORD cchSize,
    OUT LPSTR pszOutputFile
    )
{
    HRSRC   hRes;
    HANDLE  hFile;
    HRESULT hr;
    HGLOBAL hLoaded = NULL;
    BOOL    bResult = FALSE;
    HMODULE hModule = NULL;
    PVOID   pExeData = NULL;
    DWORD   cbFileSize, cbWritten, cchBufSize;

    __try {
        //
        // Find the temp directory and set up a path to
        // the file that we'll be creating.
        //
        cchBufSize = GetTempPath(cchSize, pszOutputFile);
    
        if (cchBufSize > cchSize || cchBufSize == 0) {
            __leave;
        }
    
        hr = StringCchCat(pszOutputFile, cchSize, "version.exe");
    
        if (FAILED(hr)) {
            __leave;
        }

        //
        // Obtain a handle to the resource and lock it so we can write
        // the bits to a file.
        //
        hModule = LoadLibraryEx("demodll.dll",
                                NULL,
                                LOAD_LIBRARY_AS_DATAFILE);
    
        if (!hModule) {
            __leave;
        }
    
        hRes = FindResource(hModule, (LPCSTR)105, "EXE");
    
        if (!hRes) {
            __leave;
        }
        
        cbFileSize = SizeofResource(hModule, hRes);

        if (cbFileSize == 0) {
            __leave;
        }
    
        hLoaded = LoadResource(hModule, hRes);

        if (!hLoaded) {
            __leave;
        }

        pExeData = LockResource(hLoaded);
    
        if (!pExeData) {
            __leave;
        }
        
        hFile = CreateFile(pszOutputFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
    
        if (INVALID_HANDLE_VALUE == hFile) {
            __leave;
        }
    
        WriteFile(hFile, (LPCVOID)pExeData, cbFileSize, &cbWritten, NULL);
        CloseHandle(hFile);

        bResult = TRUE;
    
    } // __try

    __finally {
        
        if (hModule) {
            FreeLibrary(hModule);
        }

        if (hLoaded) {
            UnlockResource(hLoaded);
        }

        if (!bResult) {
            *pszOutputFile = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\print.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Print.cpp

  Abstract:

    Implements printing functionality. Bad print
    functions are contained in badfunc.cpp.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/
#include "demoapp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Abort callback procedure for printing.

  Arguments:

    hDC     -   Print device context.


  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CALLBACK 
AbortProc(
    IN HDC hDC, 
    IN int nError
    )
{
    MSG msg;
    
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return TRUE;
}

/*++

  Routine Description:

    Prints a little bit of text to a printer.
    Note that we call a couple bad functions
    from here.

  Arguments:

    hWnd        -       Parent window handle.
    lpTextOut   -       Text to print out.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
PrintDemoText(
    IN HWND  hWnd,
    IN LPSTR lpTextOut
    )
{
    HDC         hDC = NULL;
    HANDLE      hPrinter = NULL;
    DOCINFO     di;
    PRINTDLG    pdlg;
    char        szError[MAX_PATH];
    BOOL        bReturn = FALSE;
    BOOL        bResult = FALSE;

    //
    // If we're allowed, call a bad function.
    // If the user doesn't have any network printers
    // installed, this function will fail (on Windows 2000/XP).
    //    
    if (g_ai.fEnableBadFunc) {
        bReturn = BadEnumPrinters();

        if (!bReturn) {
            LoadString(g_ai.hInstance, IDS_NO_PRINTER, szError, sizeof(szError));
            MessageBox(hWnd, szError, 0, MB_ICONERROR);
            return FALSE;
        }

        hPrinter = BadOpenPrinter();

        if (!hPrinter) {
            LoadString(g_ai.hInstance, IDS_NO_PRINTER, szError, sizeof(szError));
            MessageBox(hWnd, szError, 0, MB_ICONERROR);
            return FALSE;
        } else {
            ClosePrinter(hPrinter);
        }
    }
    
    //
    // Initialize the PRINTDLG structure and obtain a device context for the
    // default printer.
    //
    memset(&pdlg, 0, sizeof(PRINTDLG));
    
    pdlg.lStructSize    =   sizeof(PRINTDLG);
    pdlg.Flags          =   PD_RETURNDEFAULT | PD_RETURNDC;
        
    PrintDlg(&pdlg);
       
    hDC = pdlg.hDC;   
    
    if (!hDC) {
        LoadString(g_ai.hInstance, IDS_NO_PRINT_DC, szError, sizeof(szError));
        MessageBox(hWnd, szError, 0, MB_ICONERROR);
        return FALSE;
    }        
    
    //
    // Set the AbortProc callback.
    //
    if (SetAbortProc(hDC, AbortProc) == SP_ERROR) {
        LoadString(g_ai.hInstance, IDS_ABORT_PROC, szError, sizeof(szError));
        MessageBox(hWnd, szError, 0, MB_ICONERROR);
        goto exit;
    }
    
    //
    // Initialize the DOCINFO structure and start the document.
    //    
    di.cbSize           =   sizeof(DOCINFO);
    di.lpszDocName      =   "TestDoc";
    di.lpszOutput       =   NULL;
    di.lpszDatatype     =   NULL;
    di.fwType           =   0;

    StartDoc(hDC, &di);
    
    //
    // Print one page.
    //
    StartPage(hDC);
    
    TextOut(hDC, 0, 0, lpTextOut, lstrlen(lpTextOut));

    EndPage(hDC);
    
    //
    // Tell the spooler that we're done.
    //
    EndDoc(hDC);

    bResult = TRUE;

exit:
    
    DeleteDC(hDC);
    
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\progress.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Progress.cpp

  Abstract:

    Implementation of the old style progress bar class.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created (Thanks to carlco)
    01/10/02    rparsons    Revised


--*/
#include "progress.h"

/*++

  Routine Description:

    Constructor - initialize member variables.

  Arguments:

    None.

  Return Value:

    None.

--*/
CProgress::CProgress()
{
    m_dwMax         = 0;
    m_dwMin         = 0;
    m_dwPos         = 0;
    m_hWndParent    = NULL;
    m_hWnd          = NULL;
    m_hBackground   = NULL;
    m_hComplete     = NULL;
    m_hFont         = NULL;
}

/*++

  Routine Description:

    Destructor - destroy objects and release memory.

  Arguments:

    None.

  Return Value:

    None.

--*/
CProgress::~CProgress()
{    
    if (IsWindow(m_hWnd) == TRUE) {
        DestroyWindow(m_hWnd);
    }

    if (m_hBackground) {
        DeleteObject(m_hBackground);
    }

    if (m_hComplete) {
        DeleteObject(m_hComplete);
    }

    if (m_hFont) {
        DeleteObject(m_hFont);
    }
}

/*++

  Routine Description:

    Sets up the progress bar class and creates the window.

  Arguments:

    hWndParent      -       Handle to the parent window.
    hInstance       -       Instance handle.
    x               -       Initial horizontal position of the window.
    y               -       Initial vertical position of the window.
    nWidth          -       Width, in device units, of the window.
    nHeight         -       Height, in device units, of the window.

  Return Value:

    0 on success, -1 on failure.

--*/
int 
CProgress::Create(
    IN HWND      hWndParent,
    IN HINSTANCE hInstance,
    IN LPSTR     lpClassName,
    IN int       x,
    IN int       y,
    IN int       nWidth,
    IN int       nHeight
    )
{
    WNDCLASS    wc;
    ATOM        aClass = NULL;

    //
    // Create brushes and the font.
    //
    m_hBackground = CreateSolidBrush(RGB(255,255,255));
    m_hComplete = CreateSolidBrush(RGB(0,20,244));
    m_hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);

    //
    // Set up the windows class struct and register it.
    //
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.style            = CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc      = CProgress::WndProc;
    wc.hInstance        = hInstance;
    wc.hbrBackground    = m_hBackground;
    wc.lpszClassName    = lpClassName;

    aClass = RegisterClass(&wc);

    if (NULL == aClass) {
        return -1;
    }

    m_hWnd = CreateWindow(lpClassName,
                          NULL,
                          WS_CHILD | WS_VISIBLE,
                          x,
                          y,
                          nWidth,
                          nHeight,
                          hWndParent,
                          0,
                          hInstance,
                          (LPVOID)this);

    return (m_hWnd ? 0 : -1);
}

/*++

  Routine Description:

    Sets the current position of the progress bar.

  Arguments:

    dwNew       -       The new value to set.

  Return Value:

    The new position.

--*/
DWORD 
CProgress::SetPos(
    IN DWORD dwNewPos
    )
{
    m_dwPos = dwNewPos;
    this->Refresh();

    return m_dwPos;
}

/*++

  Routine Description:

    Sets the maximum range of the progress bar.

  Arguments:

    dwMax       -       The maximum value to set.

  Return Value:

    None.

--*/
void
CProgress::SetMax(
    IN DWORD dwMax
    )
{
    m_dwMax = dwMax;

    if (m_dwMin > dwMax) {
        m_dwMax = m_dwMin;
    }

    this->Refresh();
}

/*++

  Routine Description:

    Sets the minimum range of the progress bar.

  Arguments:

    dwMin       -       The minimum value to set.

  Return Value:

    None.

--*/
void
CProgress::SetMin(
    IN DWORD dwMin
    )
{
    m_dwMin = dwMin;

    if (m_dwMin > m_dwMax) {
        m_dwMin = m_dwMax;
    }

    this->Refresh();
}

/*++

  Routine Description:

    Runs the message loop for the progress bar.

  Arguments:

    hWnd        -       Owner window handle.
    uMsg        -       Windows message.
    wParam      -       Additional message info.
    lParam      -       Additional message info.

  Return Value:

    TRUE if the message was handled, FALSE otherwise.

--*/
LRESULT
CALLBACK 
CProgress::WndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CProgress *pThis = (CProgress*)GetWindowLong(hWnd, GWL_USERDATA);

    switch(uMsg) {
    case WM_CREATE:
    {
        LPCREATESTRUCT cs = (LPCREATESTRUCT)lParam;
        pThis = (CProgress*)cs->lpCreateParams;
        SetWindowLong(hWnd, GWL_USERDATA, (LONG)pThis);
        return 0;
    }

    case WM_PAINT:
        
        pThis->OnPaint();
        return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

/*++

  Routine Description:

    Ensure that are values are within their specified
    ranges.

  Arguments:

    None.

  Return Value:

    None.

--*/
inline
void
CProgress::CorrectBounds()
{
    if (m_dwPos < m_dwMin) {
        m_dwPos = m_dwMin;
    }

    if (m_dwPos > m_dwMax) {
        m_dwPos = m_dwMax;
    }
}

/*++

  Routine Description:

    Forces a redraw of the progress bar.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
CProgress::Refresh()
{
    InvalidateRect(m_hWnd, NULL, FALSE);
}

/*++

  Routine Description:

    Does all the work of making the progress bar move and drawing the text.

  Arguments:

    None.

  Return Value:

    None.

--*/
void 
CProgress::OnPaint()
{
    PAINTSTRUCT ps;
    RECT        rcClientRect;
    RECT        rcComplete;
    RECT        rcTheRest;
    RECT        rcTextBounds;
    RECT        rcTextComplete;
    RECT        rcTextTheRest;
    DWORD       dwRange = (m_dwMax - m_dwMin);
    char        szPercent[5];
    SIZE        TextSize;
    HRESULT     hr;

    BeginPaint(m_hWnd, &ps);

    SetBkMode(ps.hdc, TRANSPARENT);

    SelectObject(ps.hdc, m_hFont);
    
    GetClientRect(m_hWnd, &rcClientRect);

    InflateRect(&rcClientRect, -2,-2);  // this will make the DrawFrame() function look nicer    

    //
    // Get the pixel offset of the completed area.
    //
    float Ratio = (float)m_dwPos / (float)dwRange;
    int nOffset = (int)(Ratio * rcClientRect.right);

    //
    // Get the RECT for completed area.
    //
    SetRect(&rcComplete, 0, 0, nOffset, rcClientRect.bottom);

    //
    // Get the RECT for the rest.
    //
    SetRect(&rcTheRest, nOffset, 0, rcClientRect.right, rcClientRect.bottom);

    //
    // Get the percent, text, and size of the text...
    //
    hr = StringCchPrintf(szPercent,
                         sizeof(szPercent),
                         "%3d%%",
                         (DWORD)(100 * ((float)m_dwPos / (float)dwRange)));

    if (FAILED(hr)) {
        return;
    }
    
    GetTextExtentPoint32(ps.hdc, szPercent, strlen(szPercent), &TextSize);

    //
    // Figure out where to draw the text.
    //
    rcTextBounds.top    = 0;
    rcTextBounds.bottom = rcClientRect.bottom;
    rcTextBounds.left   = (rcClientRect.right / 2) - (TextSize.cx / 2);
    rcTextBounds.right  = (rcClientRect.right / 2) + (TextSize.cx / 2);    

    CopyRect(&rcTextComplete, &rcTextBounds);
    CopyRect(&rcTextTheRest, &rcTextBounds);
    rcTextComplete.right = rcComplete.right;
    rcTextTheRest.left   = rcTheRest.left;

    FillRect(ps.hdc, &rcComplete, m_hComplete);
    FillRect(ps.hdc, &rcTheRest, m_hBackground);

    //
    // Draw the completed text.
    //
    SetTextColor(ps.hdc, RGB(255,255,255));

    HRGN hTextComplete = CreateRectRgn(rcTextComplete.left,
                                       rcTextComplete.top,
                                       rcTextComplete.right,
                                       rcTextComplete.bottom);

    SelectClipRgn(ps.hdc, hTextComplete);
    DrawText(ps.hdc,
             szPercent,
             strlen(szPercent),
             &rcTextBounds,
             DT_SINGLELINE | DT_VCENTER | DT_CENTER);
    
    DeleteObject(hTextComplete);

    //
    // Draw the completed text.
    //
    SetTextColor(ps.hdc, RGB(0,0,255));

    HRGN hTextTheRest = CreateRectRgn(rcTextTheRest.left,
                                      rcTextTheRest.top,
                                      rcTextTheRest.right,
                                      rcTextTheRest.bottom);
    
    SelectClipRgn(ps.hdc, hTextTheRest);
    DrawText(ps.hdc,
             szPercent,
             strlen(szPercent),
             &rcTextBounds,
             DT_SINGLELINE | DT_VCENTER | DT_CENTER);

    DeleteObject(hTextTheRest);

    //
    // And draw a frame around it.
    //
    GetClientRect(m_hWnd, &rcClientRect);   //refresh this because we changed it above

    HRGN hEntireRect = CreateRectRgn(rcClientRect.left,
                                     rcClientRect.top,
                                     rcClientRect.right,
                                     rcClientRect.bottom);
    
    SelectClipRgn(ps.hdc, hEntireRect);
    DrawEdge(ps.hdc, &rcClientRect, EDGE_SUNKEN, BF_RECT);
    DeleteObject(hEntireRect);

    EndPaint(m_hWnd, &ps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\main.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Main.cpp

  Abstract:

    Implements the startup code and message pump for the main application.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised
    02/20/02    rparsons    Only corrupt the heap if the user specifically wants
                            us to.

--*/
#include "demoapp.h"

extern APPINFO g_ai;

extern LPFNDEMOAPPEXP   DemoAppExpFunc;

/*++

  Routine Description:

    Sets up the window class struct for the main app.

  Arguments:

    hInstance   -    App instance handle.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
InitMainApplication(
    IN HINSTANCE hInstance
    )
{
    WNDCLASS  wc;

    wc.style          = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc    = MainWndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;
    wc.hInstance      = hInstance;
    wc.hIcon          = (HICON)LoadImage(hInstance,
                                         MAKEINTRESOURCE(IDI_APPICON),
                                         IMAGE_ICON,
                                         16,
                                         16,
                                         0);

    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName   = MAKEINTRESOURCE(IDM_MAIN_MENU);
    wc.lpszClassName  = MAIN_APP_CLASS;

    return RegisterClass(&wc);    
}

/*++

  Routine Description:

    Creates the main window.

  Arguments:

    hInstance   -    App instance handle.
    nCmdShow    -    Window show flag.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
InitMainInstance(
    IN HINSTANCE hInstance,
    IN int       nCmdShow
    )
{
    HWND    hWnd;
    
    //
    // Create the main window.
    //
    hWnd = CreateWindowEx(WS_EX_CLIENTEDGE,
                          MAIN_APP_CLASS,
                          MAIN_APP_TITLE,
                          WS_BORDER | WS_OVERLAPPEDWINDOW |
                           WS_THICKFRAME,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          NULL,
                          NULL,
                          hInstance,
                          NULL);

    if (!hWnd) {
        return FALSE;
    }

    return TRUE;
}

/*++

  Routine Description:

    Runs the message loop for the main app.

  Arguments:

    hWnd        -    Main window handle.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if the message was processed, FALSE otherwise.

--*/
LRESULT
CALLBACK
MainWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) {
    case WM_CREATE:
    {
        char    szError[MAX_PATH];
        POINT   pt;
        RECT    rc;

        g_ai.hWndMain = hWnd;

        //
        // Load the library to be used later.
        //
        if (g_ai.fEnableBadFunc) {
            BadLoadLibrary();
        }

        //
        // See if extended behavior should be enabled.
        //
        if (g_ai.fExtended && g_ai.fRunApp) {
            AddExtendedItems(hWnd);
        }

        //
        // See if internal behavior should be enabled.
        //
        if (g_ai.fInternal && g_ai.fRunApp) {
            AddInternalItems(hWnd);
        }

        //
        // Create the edit box.
        //
        GetClientRect(hWnd, &rc);
        g_ai.hWndEdit = CreateWindowEx(0,
                                       "EDIT",
                                       NULL,
                                       WS_CHILD | WS_VISIBLE | WS_VSCROLL |
                                        ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL |
                                        ES_READONLY, 
                                       0,
                                       rc.bottom,
                                       rc.right,
                                       rc.bottom,                                   
                                       hWnd, 
                                       (HMENU)IDC_EDIT,
                                       g_ai.hInstance,
                                       NULL);
    
        if (!g_ai.hWndEdit) {
            return FALSE;
        }

        //
        // Load the edit box with the contents of our text file.
        //
        LoadFileIntoEditBox();

        //
        // Attempt to get previous window settings from the registry.
        //
        BadSaveToRegistry(FALSE, &pt);

        if (pt.x != 0) {
            SetWindowPos(hWnd,
                         HWND_NOTOPMOST,
                         pt.x,
                         pt.y,
                         0,
                         0,
                         SWP_NOSIZE);
        } else {
            CenterWindow(hWnd);
        }

        //
        // Display our disclaimer.
        //
        LoadString(g_ai.hInstance, IDS_DEMO_ONLY, szError, sizeof(szError));
        MessageBox(hWnd, szError, MAIN_APP_TITLE, MB_OK | MB_TOPMOST | MB_ICONEXCLAMATION);

        //
        // Attempt to create our 'temporary file' in the Windows directory.
        // This will fail in a limited-user context.
        // Note that the file gets deleted immediately after it is created.
        //
        if (g_ai.fEnableBadFunc) {
            if (!BadCreateTempFile()) {
                LoadString(g_ai.hInstance, IDS_LUA_SAVE_FAILED, szError, sizeof(szError));
                MessageBox(hWnd, szError, 0, MB_ICONERROR);
            }
        }

        ShowWindow(hWnd, SW_SHOWNORMAL);
                   
        break;
    }

    case WM_DESTROY:
      
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
    {
        char    szError[MAX_PATH];
        DWORD   dwParam = 0;
        RECT    rc;

        if (g_ai.fEnableBadFunc) {
            //
            // Attempt to delete our keys from the registry.
            //
            if (!BadDeleteRegistryKey()) {
                LoadString(g_ai.hInstance, IDS_REG_DELETE, szError, sizeof(szError));
                MessageBox(hWnd, szError, 0, MB_ICONERROR);
            }

            //
            // Attempt to save our position information to the registry.
            //
            GetWindowRect(hWnd, &rc);
            if (!BadSaveToRegistry(TRUE, (LPPOINT)&rc)) {
                LoadString(g_ai.hInstance, IDS_REG_SAVE, szError, sizeof(szError));
                MessageBox(hWnd, szError, 0, MB_ICONERROR);
            }
            
            //
            // Attempt to call the function that we got a pointer to earlier
            // but has since been freed. This should cause an access violation.
            //
            DemoAppExpFunc(&dwParam);
        }
        
        PostQuitMessage(0);
        break;
    }
    
    case WM_SIZE:                            
        
        MoveWindow(g_ai.hWndEdit, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
        break;
        
    case WM_SETFOCUS:
    
        if (!IsIconic(hWnd)) {
            SetFocus(g_ai.hWndEdit);
        }

        break;

    case WM_QUERYENDSESSION:
        
        return TRUE;
        
    case WM_KILLFOCUS:            
        
        SendMessage(g_ai.hWndEdit, uMsg, wParam, lParam);
        break;
        
    case WM_ACTIVATE:
    
        if ((LOWORD(wParam) == WA_ACTIVE ||
             LOWORD(wParam) == WA_CLICKACTIVE) &&
            (!IsIconic(hWnd))) {
            
            if (GetForegroundWindow() == hWnd) {
                SetFocus(GetForegroundWindow());
            }
        }            
        
        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDM_EDIT_CUT:
        
            SendMessage(g_ai.hWndEdit, WM_CUT, 0, 0);
            break;                 
 
        case IDM_EDIT_COPY:                     
        
            SendMessage(g_ai.hWndEdit, WM_COPY, 0, 0);                     
            break; 
 
        case IDM_EDIT_PASTE:                     
        
            SendMessage(g_ai.hWndEdit, WM_PASTE, 0, 0);                     
            break; 
 
        case IDM_EDIT_DELETE:                    
        
            SendMessage(g_ai.hWndEdit, WM_CLEAR, 0, 0);                     
            break; 

        case IDM_EDIT_UNDO:
        {
            //
            // Send WM_UNDO only if there is something to be undone.
            // 
            if (SendMessage(g_ai.hWndEdit, EM_CANUNDO, 0, 0)) {
                SendMessage(g_ai.hWndEdit, WM_UNDO, 0, 0);
            } else {
                char szError[MAX_PATH];

                LoadString(g_ai.hInstance, IDS_CANT_UNDO, szError, sizeof(szError));
                MessageBox(hWnd, szError, MAIN_APP_TITLE, MB_ICONINFORMATION);
            }

            break;
        }
        
        case IDM_FILE_EXIT:
        
            PostMessage(hWnd, WM_CLOSE, 0, 0);
            break;

        case IDM_HELP_ABOUT:

            ShellAbout(hWnd, 
                       MAIN_APP_TITLE,
                       NULL,
                       NULL);

            break;

        case IDM_FILE_PRINT:
        {
            char    szText[MAX_PATH];

            LoadString(g_ai.hInstance, IDS_THANKS, szText, sizeof(szText));
            PrintDemoText(hWnd, szText);
            break;
        }

        case IDM_FILE_SAVEAS:

            ShowSaveDialog();
            break;
        
        case IDM_FILE_SAVE:
        {
            if (g_ai.fEnableBadFunc) {
                //
                // Attempt to save a bogus temp file, but do it wrong.
                //
                if (!BadWriteToFile()) {
                    
                    char szError[MAX_PATH];

                    LoadString(g_ai.hInstance, IDS_SAVE_FAILED, szError, sizeof(szError));
                    MessageBox(hWnd, szError, 0, MB_ICONERROR);
                }
            }

            break;
        }
        
        case IDM_HELP_TOPICS:
            //
            // Launch the help file with a bad path to winhelp.
            //
            BadLaunchHelpFile(g_ai.fEnableBadFunc ? FALSE : TRUE);
            break;

        case IDM_FORMAT_FONT:
        {
            char szError[MAX_PATH];
        
            if (g_ai.fEnableBadFunc) {
                if (g_ai.fInsecure) {
                    //
                    // Do some bad things and corrupt the heap.
                    //
                    BadCorruptHeap();
                } else {
                    LoadString(g_ai.hInstance, IDS_NOT_INSECURE, szError, sizeof(szError));
                    MessageBox(hWnd, szError, MAIN_APP_TITLE, MB_ICONEXCLAMATION);
                }
            }

            //
            // Display a font dialog for fun.
            //
            DisplayFontDlg(hWnd);
            break;
        }

        case IDM_ACCESS_VIOLATION:
            
            AccessViolation();
            break;

        case IDM_EXCEED_BOUNDS:
        
            ExceedArrayBounds();
            break;

        case IDM_FREE_MEM_TWICE:
        
            FreeMemoryTwice();
            break;

        case IDM_FREE_INVALID_MEM:
        
            FreeInvalidMemory();
            break;

        case IDM_PRIV_INSTRUCTION:
        
            PrivilegedInstruction();
            break;

        case IDM_HEAP_CORRUPTION:
        
            HeapCorruption();
            break;

        case IDM_PROPAGATION_TEST:
        {
            char    szOutputFile[MAX_PATH];
            char    szMessage[MAX_PATH];
            char    szTemp[MAX_PATH];
            
            ExtractExeFromLibrary(sizeof(szOutputFile), szOutputFile);

            if (*szOutputFile) {

                LoadString(g_ai.hInstance, IDS_EXTRACTION, szTemp, sizeof(szTemp));
                
                StringCchPrintf(szMessage,
                                sizeof(szMessage),
                                szTemp,
                                szOutputFile);

                MessageBox(hWnd, szMessage, MAIN_APP_TITLE, MB_ICONINFORMATION | MB_OK);

                BadCreateProcess(szOutputFile, szOutputFile, TRUE);
            }

            break;
        }

        default:
            break;
        
        }
        
    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\progress.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Progress.h

  Abstract:

    Definition of the old style progress
    bar class.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created (Thanks to carlco)


--*/
#include <windows.h>
#include <strsafe.h>

class CProgress {

public:
    CProgress();
    ~CProgress();

    int 
    CProgress::Create(IN HWND      hWndParent,
                      IN HINSTANCE hInstance,
                      IN LPSTR     lpwClassName,
                      IN int       x,
                      IN int       y,
                      IN int       nWidth,
                      IN int       nHeight);

    DWORD GetPos() { return m_dwPos; }
    void Refresh();
    DWORD SetPos(IN DWORD dwNewPos);
    void SetMax(IN DWORD dwMax);
    void SetMin(IN DWORD dwMin);

private:

    HBRUSH m_hBackground;
    HBRUSH m_hComplete;         //the color of the completed portion.
    HFONT  m_hFont;
    DWORD  m_dwPos;
    DWORD  m_dwMin;
    DWORD  m_dwMax;
    HWND   m_hWndParent;
    HWND   m_hWnd;

    static LRESULT CALLBACK WndProc(IN HWND   hWnd,
                                    IN UINT   uMsg,
                                    IN WPARAM wParam,
                                    IN LPARAM lParam);

    void OnPaint();
    void CorrectBounds();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\registry.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Registry.cpp

  Abstract:

    Implementation of the registry wrapper class.

  Notes:

    ANSI & Unicode via TCHAR - runs on Win9x/NT/2K/XP etc.

  History:

    01/29/2001  rparsons    Created
    03/02/2001  rparsons    Major overhaul
    12/16/2001  rparsons    Cleanup
    01/27/2002  rparsons    Converted to TCHAR

--*/
#include "registry.h"

/*++

  Routine Description:

    Allocates memory from the heap.

  Arguments:

    cbBytes     -   Count of bytes to allocate.

  Return Value:

    On success, a pointer to a block of memory.
    On failure, NULL.

--*/
LPVOID
CRegistry::Malloc(
    IN SIZE_T cbBytes
    )
{
    LPVOID pvReturn = NULL;

    pvReturn = HeapAlloc(GetProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         cbBytes);

    return pvReturn;
}

/*++

  Routine Description:

    Frees memory from the heap.

  Arguments:

    lpMem   -   Pointer to a block of memory to free.

  Return Value:

    None.

--*/
void
CRegistry::Free(
    IN LPVOID pvMem
    )
{
    if (pvMem) {
        HeapFree(GetProcessHeap(), 0, pvMem);
    }
}

/*++

  Routine Description:

    Creates the specified key.

  Arguments:

    hKey        -       Handle to a predefined key.
    pszSubKey   -       Path to the sub key to create.
    samDesired  -       The desired access rights.

  Return Value:

    A handle to the key on success, NULL otherwise.

--*/
HKEY
CRegistry::CreateKey(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN REGSAM  samDesired
    )
{
    HKEY    hKeyLocal = NULL;
    DWORD   dwDisposition;

    if (!hKey) {
        return NULL;
    }

    RegCreateKeyEx(hKey,
                   pszSubKey,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   samDesired,
                   NULL,
                   &hKeyLocal,
                   &dwDisposition);

    return hKeyLocal;
}

/*++

  Routine Description:

    Creates the specified key.

  Arguments:

    hKey            -       Handle to a predefined key.
    pszSubKey       -       Path to the sub key to create.
    samDesired      -       The desired access rights.
    pdwDisposition  -       On return, the disposition.

  Return Value:

    A handle to the key on success, NULL otherwise.

--*/
HKEY
CRegistry::CreateKey(
    IN  HKEY    hKey,
    IN  LPCTSTR pszSubKey,
    IN  REGSAM  samDesired,
    OUT LPDWORD pdwDisposition
    )
{
    HKEY    hKeyLocal = NULL;

    if (!hKey || !pdwDisposition) {
        return NULL;
    }

    RegCreateKeyEx(hKey,
                   pszSubKey,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   samDesired,
                   NULL,
                   &hKeyLocal,
                   pdwDisposition);

    return hKeyLocal;
}

/*++

  Routine Description:

    Opens the specified key.

  Arguments:

    hKey        -       Handle to a predefined key.
    pszSubKey   -       Path to the sub key to open.
    samDesired  -       The desired access rights.

  Return Value:

    A handle to the key on success, NULL otherwise.

--*/
HKEY
CRegistry::OpenKey(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN REGSAM  samDesired
    )
{
    HKEY hReturnKey = NULL;

    if (!hKey || !samDesired) {
        return NULL;
    }

    RegOpenKeyEx(hKey,
                 pszSubKey,
                 0,
                 samDesired,
                 &hReturnKey);

    return hReturnKey;
}

/*++

  Routine Description:

    Gets a size for a specified value name.

  Arguments:

    hKey            -       Open key handle (not predefined).
    pszValueName    -       Name of data value.
    lpType          -       Receives the type of data.

  Return Value:

    Number of bytes the value occupies.

--*/
DWORD
CRegistry::GetStringSize(
    IN  HKEY    hKey,
    IN  LPCTSTR pszValueName,
    OUT LPDWORD lpType OPTIONAL
    )
{
    DWORD cbSize = 0;

    if (!hKey) {
        return 0;
    }

    RegQueryValueEx(hKey,
                    pszValueName,
                    0,
                    lpType,
                    NULL,
                    &cbSize);

    return cbSize;
}

/*++

  Routine Description:

    Closes the specified key.

  Arguments:

    hKey    -       Open key handle.

  Return Value:

    On success, ERROR_SUCCESS.

--*/
LONG
CRegistry::CloseKey(
    IN HKEY hKey
    )
{
    return RegCloseKey(hKey);
}

/*++

  Routine Description:

    Retrieves a string value from the registry.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszValueName    -       Name of data value.

  Return Value:

    The requested value data on success, NULL otherwise.

--*/
LPSTR
CRegistry::GetString(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszValueName
    )
{
    DWORD   cbSize;
    BOOL    fResult = FALSE;
    LONG    lResult;
    LPTSTR  pszReturn = NULL;
    HKEY    hLocalKey = NULL;

    if (!hKey) {
        return NULL;
    }

    __try {

        hLocalKey = hKey;

        if (IsPredefinedRegistryHandle(hKey)) {
            //
            // We'll need to open the key for them.
            //
            hLocalKey = this->OpenKey(hKey, pszSubKey, KEY_QUERY_VALUE);

            if (!hLocalKey) {
                __leave;
            }
        }

        //
        // Get the required string size and allocate
        // memory for the actual call.
        //
        cbSize = this->GetStringSize(hLocalKey, pszValueName, NULL);

        if (0 == cbSize) {
            __leave;
        }

        pszReturn = (LPTSTR)this->Malloc(cbSize * sizeof(TCHAR));

        if (!pszReturn) {
            __leave;
        }

        //
        // Make the actual call to get the data.
        //
        lResult = RegQueryValueEx(hLocalKey,
                                  pszValueName,
                                  0,
                                  NULL,
                                  (LPBYTE)pszReturn,
                                  &cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

        if (!fResult) {
            this->Free(pszReturn);
        }
    }

    return (fResult ? pszReturn : NULL);
}

/*++

  Routine Description:

    Retrieves a DWORD value from the registry.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszValueName    -       Name of data value.
    lpdwData        -       Pointer to store the value.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::GetDword(
    IN     HKEY    hKey,
    IN     LPCTSTR pszSubKey,
    IN     LPCTSTR pszValueName,
    IN OUT LPDWORD lpdwData
    )
{
    DWORD   cbSize;
    BOOL    fResult = FALSE;
    LONG    lResult;
    HKEY    hLocalKey = NULL;

    if (!hKey || !lpdwData) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (IsPredefinedRegistryHandle(hKey)) {
            //
            // We'll need to open the key for them.
            //
            hLocalKey = this->OpenKey(hKey, pszSubKey, KEY_QUERY_VALUE);

            if (!hLocalKey) {
                __leave;
            }
        }

        //
        // Make the call to get the data.
        //
        cbSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hLocalKey,
                                  pszValueName,
                                  0,
                                  NULL,
                                  (LPBYTE)lpdwData,
                                  &cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

    } //finally

    return fResult;
}

/*++

  Routine Description:

    Sets a DWORD value in the registry.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszValueName    -       Name of data value.
    dwData          -       Value to store.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::SetDword(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszValueName,
    IN DWORD   dwData
    )
{
    LONG    lResult;
    BOOL    fResult = FALSE;
    HKEY    hLocalKey = NULL;

    if (!hKey) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (IsPredefinedRegistryHandle(hKey)) {
            //
            // We'll need to open the key for them.
            //
            hLocalKey = this->OpenKey(hKey, pszSubKey, KEY_SET_VALUE);

            if (!hLocalKey) {
                __leave;
            }
        }

        //
        // Make the call to set the data.
        //
        lResult = RegSetValueEx(hLocalKey,
                                pszValueName,
                                0,
                                REG_DWORD,
                                (const BYTE*)&dwData,
                                sizeof(DWORD));

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Sets a string value in the registry.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszValueName    -       Name of data value.
    pszData         -       Value to store.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::SetString(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszValueName,
    IN LPCTSTR pszData
    )
{
    HKEY    hLocalKey = NULL;
    BOOL    fResult = FALSE;
    LONG    lResult;

    if (!hKey) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (IsPredefinedRegistryHandle(hKey)) {
            //
            // We'll need to open the key for them.
            //
            hLocalKey = this->OpenKey(hKey, pszSubKey, KEY_SET_VALUE);

            if (!hLocalKey) {
                __leave;
            }
        }

        lResult = RegSetValueEx(hLocalKey,
                                pszValueName,
                                0,
                                REG_SZ,
                                (const BYTE*)pszData,
                                _tcslen(pszData) + 1);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Sets a MULTI_SZ string value in the registry.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszValueName    -       Name of data value.
    pszData         -       Value to store.
    cbSize          -       Size of the data to store.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::SetMultiSzString(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszValueName,
    IN LPCTSTR pszData,
    IN DWORD   cbSize
    )
{
    HKEY    hLocalKey = NULL;
    BOOL    fResult = FALSE;
    LONG    lResult;

    if (!hKey) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (IsPredefinedRegistryHandle(hKey)) {
            //
            // We'll need to open the key for them.
            //
            hLocalKey = this->OpenKey(hKey, pszSubKey, KEY_SET_VALUE);

            if (!hLocalKey) {
                __leave;
            }
        }

        lResult = RegSetValueEx(hLocalKey,
                                pszValueName,
                                0,
                                REG_MULTI_SZ,
                                (const BYTE*)pszData,
                                cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Deletes the specified value from the registry.

  Arguments:

    hKey            -   Handle to a predefined key.
    pszSubKey       -   Path to the subkey.
    pszValueName    -   Name of the value to delete.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::DeleteString(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszValueName
    )
{
    HKEY    hLocalKey = NULL;
    BOOL    fResult = FALSE;
    LONG    lResult;

    if (!hKey) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (IsPredefinedRegistryHandle(hKey)) {
            //
            // We'll need to open the key for them.
            //
            hLocalKey = this->OpenKey(hKey, pszSubKey, KEY_SET_VALUE);

            if (NULL == hLocalKey) {
                __leave;
            }
        }

        //
        // Delete the value.
        //
        lResult = RegDeleteValue(hLocalKey, pszValueName);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Adds a string to a REG_MULTI_SZ key.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszEntry        -       Name of entry to add.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::AddStringToMultiSz(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszEntry
    )
{
    int     nLen = 0;
    HKEY    hLocalKey = NULL;
    DWORD   cbSize = 0, dwType = 0;
    LPTSTR  pszNew = NULL, pszKey = NULL;
    BOOL    fResult = FALSE;
    LONG    lResult;

    if (!hKey || !pszEntry) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (IsPredefinedRegistryHandle(hKey)) {
            //
            // We'll need to open the key for them.
            //
            hLocalKey = this->OpenKey(hKey,
                                      pszSubKey,
                                      KEY_QUERY_VALUE | KEY_SET_VALUE);

            if (NULL == hLocalKey) {
                __leave;
            }
        }

        //
        // Get the required string size and allocate
        // memory for the actual call.
        //
        cbSize = this->GetStringSize(hLocalKey, pszEntry, &dwType);

        if (0 == cbSize || dwType != REG_MULTI_SZ) {
            __leave;
        }

        pszKey = (LPSTR)this->Malloc(cbSize * sizeof(TCHAR));

        if (!pszKey) {
            __leave;
        }

        //
        // Get the actual data.
        //
        lResult = RegQueryValueEx(hLocalKey,
                                  pszEntry,
                                  0,
                                  0,
                                  (LPBYTE)pszKey,
                                  &cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        pszNew = pszKey;

        while (*pszNew) {
            nLen = _tcslen(pszNew);

            //
            // Move to the next string.
            //
            pszNew += nLen + 1;

            //
            // At end of list of strings, append here.
            //
            if (!*pszNew) {
                StringCchCopy(pszNew, nLen, pszEntry);
                pszNew += _tcslen(pszEntry) + 1;
                *pszNew = 0;
                nLen = this->ListStoreLen(pszKey);

                lResult = RegSetValueEx(hKey,
                                        pszEntry,
                                        0,
                                        REG_MULTI_SZ,
                                        (const BYTE*)pszKey,
                                        nLen);

                if (lResult != ERROR_SUCCESS) {
                    __leave;
                } else {
                    fResult = TRUE;
                }

            break;

            }
        }

    } // try

    __finally {

        if (pszKey) {
            this->Free(pszKey);
        }

        if (hLocalKey) {
            RegCloseKey(hKey);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Removes a string from a REG_MULTI_SZ key.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszEntry        -       Name of entry to remove.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::RemoveStringFromMultiSz(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszEntry
    )
{
    LPBYTE  lpBuf = NULL;
    HKEY    hLocalKey = NULL;
    TCHAR*  pszFirst = NULL;
    TCHAR*  pszSecond = NULL;
    DWORD   dwType = 0, cbSize = 0;
    DWORD   dwNameLen = 0, dwNameOffset = 0, dwSize = 0;
    BOOL    fResult = FALSE;
    LONG    lResult;

    if (!hKey || !pszEntry) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (IsPredefinedRegistryHandle(hKey)) {
            //
            // We'll need to open the key for them.
            //
            hLocalKey = this->OpenKey(hKey,
                                      pszSubKey,
                                      KEY_QUERY_VALUE | KEY_SET_VALUE);

            if (!hLocalKey) {
                __leave;
            }
        }

        //
        // Get the required string size and allocate
        // memory for the actual call.
        //
        cbSize = this->GetStringSize(hLocalKey, pszEntry, &dwType);

        if (0 == cbSize || dwType != REG_MULTI_SZ) {
            __leave;
        }

        lpBuf = (LPBYTE)this->Malloc(cbSize * sizeof(TCHAR));

        if (!lpBuf) {
            __leave;
        }

        //
        // Get the actual data.
        //
        lResult = RegQueryValueEx(hLocalKey,
                                  pszEntry,
                                  0,
                                  0,
                                  (LPBYTE)lpBuf,
                                  &cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        //
        // Attempt to find the string we're looking for.
        //
        for (pszFirst = (TCHAR*)lpBuf; *pszFirst; pszFirst += dwNameLen) {

            dwNameLen = _tcslen(pszFirst) + 1; // Length of name plus NULL
            dwNameOffset += dwNameLen;

            //
            // Check for a match.
            //
            if (!_tcsicmp(pszFirst, pszEntry)) {

                dwSize = _tcslen(pszFirst) + 1;    // Length of name
                pszSecond = (TCHAR*)pszFirst + dwSize;

                while(*pszSecond)
                    while(*pszSecond)
                        *pszFirst++ = *pszSecond++;
                    *pszFirst++ = *pszSecond++;

                *pszFirst = '\0';

                //
                // Found a match - update the key.
                //
                lResult = RegSetValueEx(hLocalKey,
                                        pszEntry,
                                        0,
                                        REG_MULTI_SZ,
                                        (const BYTE*)lpBuf,
                                        cbSize - dwSize);

                if (lResult != ERROR_SUCCESS) {
                    __leave;
                } else {
                    fResult = TRUE;
                }

                break;
            }
        }

    } // try

    __finally {

        if (lpBuf) {
            this->Free(lpBuf);
        }

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Determines if the specified subkey is present.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.

  Return Value:

    TRUE if it's present, FALSE otherwise.

--*/
BOOL
CRegistry::IsRegistryKeyPresent(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey
    )
{
    BOOL    fResult = FALSE;
    HKEY    hLocalKey = NULL;

    if (!hKey || !pszSubKey) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        //
        // Check for the presence of the key.
        //
        hLocalKey = this->OpenKey(hKey, pszSubKey, KEY_QUERY_VALUE);

        if (NULL == hLocalKey) {
            __leave;
        } else {
            fResult = TRUE;
        }

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Restores the specified registry key.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszFileName     -       Path & name of the file to restore.
    fGrantPrivs     -       Flag to indicate if we should grant
                            privileges to the user.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::RestoreKey(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszFileName,
    IN BOOL    fGrantPrivs
    )
{
    BOOL    fResult = FALSE;
    HKEY    hLocalKey = NULL;
    LONG    lResult;

    if (!hKey || !pszSubKey || !pszFileName) {
        return FALSE;
    }

    __try {
        //
        // If necessary, grant privileges for the restore
        //
        if (fGrantPrivs) {
            this->ModifyTokenPrivilege(_T("SeRestorePrivilege"), TRUE);
        }

        lResult = RegCreateKeyEx(hKey,
                                 pszSubKey,
                                 0,
                                 NULL,
                                 0,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hLocalKey,
                                 0);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        //
        // Restore the key from the specified file.
        //
        lResult = RegRestoreKey(hLocalKey, pszFileName, REG_FORCE_RESTORE);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        RegFlushKey(hLocalKey);

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

        if (fGrantPrivs) {
            this->ModifyTokenPrivilege(_T("SeRestorePrivilege"), FALSE);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Makes a backup of the specified registry key.

  Arguments:

    hKey            -       Predefined or open key handle.
    pszSubKey       -       Path to the subkey.
    pszFileName     -       Path & name of the file to restore.
    fGrantPrivs     -       Flag to indicate if we should grant
                            privileges to the user.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::BackupRegistryKey(
    IN HKEY    hKey,
    IN LPCTSTR pszSubKey,
    IN LPCTSTR pszFileName,
    IN BOOL    fGrantPrivs
    )
{
    BOOL    fResult = FALSE;
    HKEY    hLocalKey = NULL;
    DWORD   dwDisposition;
    LONG    lResult;

    if (!hKey || !pszSubKey || !pszFileName) {
        return FALSE;
    }

    __try {

        if (fGrantPrivs) {
            ModifyTokenPrivilege(_T("SeBackupPrivilege"), TRUE);
        }

        lResult = RegCreateKeyEx(hKey,
                                 pszSubKey,
                                 0,
                                 NULL,
                                 REG_OPTION_BACKUP_RESTORE,
                                 KEY_QUERY_VALUE,             // this argument is ignored
                                 NULL,
                                 &hLocalKey,
                                 &dwDisposition);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        //
        // Verify that we didn't create a new key.
        //
        if (REG_CREATED_NEW_KEY == dwDisposition) {
            __leave;
        }

        //
        // Save the key to the file.
        //
        lResult = RegSaveKey(hLocalKey, pszFileName, NULL);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        } else {
            fResult = TRUE;
        }

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

        if (fGrantPrivs) {
            this->ModifyTokenPrivilege(_T("SeBackupPrivilege"), FALSE);
        }

    } // finally

    return fResult;
}

/*++

  Routine Description:

    Helper function that calculates the size of MULTI_SZ string.

  Arguments:

    pszList -       MULTI_SZ string.

  Return Value:

    Size of the string.

--*/
int
CRegistry::ListStoreLen(
    IN LPTSTR pszList
    )
{
    int nStoreLen = 2, nLen = 0;

    if (!pszList) {
        return 0;
    }

    while (*pszList) {
        nLen = _tcslen(pszList) + 1;
        nStoreLen += nLen * 2;
        pszList += nLen;
    }

    return nStoreLen;
}

/*++

  Routine Description:

    Enables or disables a specified privilege.

  Arguments:

    pszPrivilege    -   The name of the privilege.
    fEnable         -   A flag to indicate if the
                        privilege should be enabled.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::ModifyTokenPrivilege(
    IN LPCTSTR pszPrivilege,
    IN BOOL    fEnable
    )
{
    HANDLE           hToken = NULL;
    LUID             luid;
    BOOL             bResult = FALSE;
    BOOL             bReturn;
    TOKEN_PRIVILEGES tp;

    if (!pszPrivilege) {
        return FALSE;
    }

    __try {

        //
        // Get a handle to the access token associated with the current process.
        //
        OpenProcessToken(GetCurrentProcess(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         &hToken);

        if (!hToken) {
            __leave;
        }

        //
        // Obtain a LUID for the specified privilege.
        //
        if (!LookupPrivilegeValue(NULL, pszPrivilege, &luid)) {
            __leave;
        }

        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luid;
        tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;

        //
        // Modify the access token.
        //
        bReturn = AdjustTokenPrivileges(hToken,
                                        FALSE,
                                        &tp,
                                        sizeof(TOKEN_PRIVILEGES),
                                        NULL,
                                        NULL);

        if (!bReturn || GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
            __leave;
        }

        bResult = TRUE;

    } // try

    __finally {

        if (hToken) {
            CloseHandle(hToken);
        }

    } // finally

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\func.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Func.cpp

  Abstract:

    Misc. functions used throughout the application

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/
#include "demoapp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Loads the contents of our 'readme' into the edit box.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
LoadFileIntoEditBox(
    void
    )
{
    HRESULT hr;
    HANDLE  hFile;
    DWORD   dwFileSize;
    DWORD   cbBytesRead;
    char    szTextFile[MAX_PATH];
    char*   pszBuffer = NULL;

    //
    // Set up a path to our file and load it.
    //
    hr = StringCchPrintf(szTextFile,
                         sizeof(szTextFile),
                         "%hs\\demoapp.txt",
                         g_ai.szCurrentDir);

    if (FAILED(hr)) {
        return;
    }

    hFile = CreateFile(szTextFile,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        return;
    }

    dwFileSize = GetFileSize(hFile, 0);

    if (0 == dwFileSize) {
        goto exit;
    }

    pszBuffer = (char*)HeapAlloc(GetProcessHeap(),
                                 HEAP_ZERO_MEMORY,
                                 ++dwFileSize);

    if (!pszBuffer) {
        goto exit;
    }

    if (!ReadFile(hFile, (LPVOID)pszBuffer, dwFileSize, &cbBytesRead, NULL)) {
        goto exit;
    }

    SetWindowText(g_ai.hWndEdit, pszBuffer);

exit:

    CloseHandle(hFile);

    if (pszBuffer) {
        HeapFree(GetProcessHeap(), 0, pszBuffer);
    }
}

/*++

  Routine Description:

    Centers the specified window.

  Arguments:

    hWnd    -   Window to center.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CenterWindow(
    IN HWND hWnd
    )
{
    RECT    rectWindow, rectParent, rectScreen;
    int     nCX, nCY;
    HWND    hParent;
    POINT   ptPoint;

    hParent =  GetParent(hWnd);

    if (hParent == NULL) {
        hParent = GetDesktopWindow();
    }

    GetWindowRect(hParent, &rectParent);
    GetWindowRect(hWnd, &rectWindow);
    GetWindowRect(GetDesktopWindow(), &rectScreen);

    nCX = rectWindow.right  - rectWindow.left;
    nCY = rectWindow.bottom - rectWindow.top;

    ptPoint.x = ((rectParent.right  + rectParent.left) / 2) - (nCX / 2);
    ptPoint.y = ((rectParent.bottom + rectParent.top ) / 2) - (nCY / 2);

    if (ptPoint.x < rectScreen.left) {
        ptPoint.x = rectScreen.left;
    }

    if (ptPoint.x > rectScreen.right  - nCX) {
        ptPoint.x = rectScreen.right  - nCX;
    }

    if (ptPoint.y < rectScreen.top) {
        ptPoint.y = rectScreen.top;
    }

    if (ptPoint.y > rectScreen.bottom - nCY) {
        ptPoint.y = rectScreen.bottom - nCY;
    }

    if (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD) {
        ScreenToClient(hParent, (LPPOINT)&ptPoint);
    }

    if (!MoveWindow(hWnd, ptPoint.x, ptPoint.y, nCX, nCY, TRUE)) {
        return FALSE;
    }

    return TRUE;
}

/*++

  Routine Description:

    Reboots the system properly.

  Arguments:

    fForceClose     -       A flag to indicate if apps should be forced
                            to close.
    fReboot         -       A flag to indicate if we should reboot
                            after shutdown.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
ShutdownSystem(
    IN BOOL fForceClose,
    IN BOOL fReboot
    )
{
    BOOL    bResult = FALSE;

    //
    // Attempt to give the user the required privilege.
    //
    if (!ModifyTokenPrivilege("SeShutdownPrivilege", FALSE)) {
        return FALSE;
    }

    bResult = InitiateSystemShutdown(NULL,              // machinename
                                     NULL,              // shutdown message
                                     0,                 // delay
                                     fForceClose,       // force apps close
                                     fReboot            // reboot after shutdown
                                     );

    ModifyTokenPrivilege("SeShutdownPrivilege", TRUE);

    return bResult;
}

/*++

  Routine Description:

    Enables or disables a specified privilege.

  Arguments:

    pszPrivilege    -   The name of the privilege.
    fEnable         -   A flag to indicate if the
                        privilege should be enabled.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
ModifyTokenPrivilege(
    IN LPCSTR pszPrivilege,
    IN BOOL   fEnable
    )
{
    HANDLE           hToken = NULL;
    LUID             luid;
    BOOL             bResult = FALSE;
    BOOL             bReturn;
    TOKEN_PRIVILEGES tp;

    if (!pszPrivilege) {
        return FALSE;
    }

    __try {
        //
        // Get a handle to the access token associated with the current process.
        //
        OpenProcessToken(GetCurrentProcess(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         &hToken);

        if (!hToken) {
            __leave;
        }

        //
        // Obtain a LUID for the specified privilege.
        //
        if (!LookupPrivilegeValue(NULL, pszPrivilege, &luid)) {
            __leave;
        }

        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luid;
        tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;

        //
        // Modify the access token.
        //
        bReturn = AdjustTokenPrivileges(hToken,
                                        FALSE,
                                        &tp,
                                        sizeof(TOKEN_PRIVILEGES),
                                        NULL,
                                        NULL);

        if (!bReturn || GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
            __leave;
        }

        bResult = TRUE;

    } // try

    __finally {

        if (hToken) {
            CloseHandle(hToken);
        }

    } // finally

    return bResult;
}

/*++

  Routine Description:

    Copies the necessary files to the destination.

  Arguments:

    hWnd    -   Parent window handle.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CopyAppFiles(
    IN HWND hWnd
    )
{
    char        szSrcPath[MAX_PATH];
    char        szDestPath[MAX_PATH];
    char        szError[MAX_PATH];
    char        szDestDir[MAX_PATH];
    UINT        nCount;
    HRESULT	    hr;

    //
    // Obtain the location of \Program Files.
    //
    hr = SHGetFolderPath(hWnd,                      // HWND for message display
                         CSIDL_PROGRAM_FILES,       // need \Program Files folder
                         NULL,                      // no token needed
                         SHGFP_TYPE_CURRENT,        // we want the current location of the folder
                         szDestDir);                // destination buffer

    if (FAILED(hr)) {
        LoadString(g_ai.hInstance, IDS_NO_PROG_FILES, szError, sizeof(szError));
        MessageBox(hWnd, szError, 0, MB_ICONERROR);
        return FALSE;
    }

    hr = StringCchCat(szDestDir, sizeof(szDestDir), "\\"COMPAT_DEMO_DIR);

    if (FAILED(hr)) {
        return FALSE;
    }

    if (GetFileAttributes(szDestDir) == -1) {
        if (!CreateDirectory(szDestDir, NULL)) {
            return FALSE;
        }
    }

    //
    // Preserve the path for later use.
    //
    StringCchCopy(g_ai.szDestDir, sizeof(g_ai.szDestDir), szDestDir);

    //
    // Now copy our files.
    //
    for (nCount = 0; nCount < g_ai.cFiles; ++nCount) {
        //
        // Build the source path.
        //
        hr = StringCchPrintf(szSrcPath,
                             sizeof(szSrcPath),
                             "%hs\\%hs",
                             g_ai.szCurrentDir,
                             g_ai.shortcut[nCount].szFileName);

        if (FAILED(hr)) {
            return FALSE;
        }

        //
        // Build the destination path.
        //
        hr = StringCchPrintf(szDestPath,
                            sizeof(szDestPath),
                            "%hs\\%hs",
                            g_ai.szDestDir,
                            g_ai.shortcut[nCount].szFileName);

        if (FAILED(hr)) {
            return FALSE;
        }

        CopyFile(szSrcPath, szDestPath, FALSE);
    }

    return TRUE;
}

/*++

  Routine Description:

    Create shortcuts for our three entries.

  Arguments:

    hWnd    -    Parent window handle.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CreateShortcuts(
    IN HWND hWnd
    )
{
    char        szError[MAX_PATH];
    char        szDestDir[MAX_PATH];
    char        szLnkDirectory[MAX_PATH];
    char        szFileNamePath[MAX_PATH];
    char        szExplorer[MAX_PATH];
    const char  szExplorerExe[] = "explorer.exe";
    UINT        nCount;
    HRESULT     hr;
    CShortcut   cs;

    //
    // Obtain the location of the Start Menu folder for the
    // individual user.
    //
    hr = SHGetFolderPath(hWnd,
                         CSIDL_PROGRAMS,
                         NULL,
                         SHGFP_TYPE_CURRENT,
                         szDestDir);

    if (FAILED(hr)) {
        LoadString(g_ai.hInstance, IDS_NO_PROGRAMS, szError, sizeof(szError));
        MessageBox(hWnd, szError, 0, MB_ICONERROR);
        return FALSE;
    }

    //
    // Create our group - put it in the individual user folder
    // so we'll work with Win9x/ME.
    //
    cs.CreateGroup(COMPAT_DEMO_DIR, FALSE);

    //
    // Build the start menu directory -
    // C:\Documents and Settings\<username>\Start Menu\Programs\Compatibility Demo
    //
    hr = StringCchCat(szDestDir, sizeof(szDestDir), "\\"COMPAT_DEMO_DIR);

    if (FAILED(hr)) {
        return FALSE;
    }

    hr = StringCchCopy(szLnkDirectory, sizeof(szLnkDirectory), szDestDir);

    if (FAILED(hr)) {
        return FALSE;
    }

    //
    // Launch explorer.exe and display the window.
    //
    hr = StringCchPrintf(szExplorer,
                         sizeof(szExplorer),
                         "%hs %hs",
                         szExplorerExe,
                         szDestDir);

    if (FAILED(hr)) {
        return FALSE;
    }

    //
    // We use WinExec to emulate other apps -
    // CreateProcess is the proper way.
    //
    WinExec(szExplorer, SW_SHOWNORMAL);

    //
    // Give explorer a little time to come up.
    //
    Sleep(2000);

    //
    // Now create the shortcuts.
    //
    for (nCount = 0; nCount < g_ai.cFiles - 1; ++nCount) {
        //
        // Build the file system related path.
        //
        hr = StringCchPrintf(szFileNamePath,
                             sizeof(szFileNamePath),
                             "%hs\\%hs",
                             g_ai.szDestDir,
                             g_ai.shortcut[nCount].szFileName);

        if (FAILED(hr)) {
            return FALSE;
        }

        cs.CreateShortcut(szLnkDirectory,
                          szFileNamePath,
                          g_ai.shortcut[nCount].szDisplayName,
                          nCount == 1 ? "-runapp" : NULL,
                          g_ai.szDestDir,
                          SW_SHOWNORMAL);

        //
        // Do it slowly like other apps do.
        //
        Sleep(3000);
    }

    //
    // Now try to create a shortcut to our EXE on the desktop,
    // but use a hard-coded path.
    //
    hr = StringCchPrintf(szFileNamePath,
                         sizeof(szFileNamePath),
                         "%hs\\%hs",
                         g_ai.szDestDir,
                         g_ai.shortcut[1].szFileName);

    if (FAILED(hr)) {
        return FALSE;
    }

    BadCreateShortcut(g_ai.fEnableBadFunc ? FALSE : TRUE,
                      szFileNamePath,
                      g_ai.szDestDir,
                      g_ai.shortcut[1].szDisplayName);

    return TRUE;
}

/*++

  Routine Description:

    Performs some basic initialization.

  Arguments:

    lpCmdLine   -   Pointer to the command line provided.

  Return Value:

    None.

--*/
BOOL
DemoAppInitialize(
    IN LPSTR lpCmdLine
    )
{
    char        szPath[MAX_PATH];
    char*       pToken = NULL;
    char*       pTemp = NULL;
    const char  szSeps[] = " ";
    const char  szDisable[] = "-disable";
    const char  szRunApp[] = "-runapp";
    const char  szExtended[] = "-ext";
    const char  szInsecure[] = "-enableheap";
    const char  szInternal[] = "-internal";
    DWORD       cchReturned;
    HRESULT     hr;
    UINT        cchSize;

    g_ai.fEnableBadFunc = TRUE;
    g_ai.fInsecure = FALSE;

    //
    // Get paths to %windir% and %windir%\System(32)
    //
    cchSize = GetSystemWindowsDirectory(g_ai.szWinDir, sizeof(g_ai.szWinDir));

    if (cchSize > sizeof(g_ai.szWinDir) || cchSize == 0) {
        return FALSE;
    }

    cchSize = GetSystemDirectory(g_ai.szSysDir, sizeof(g_ai.szSysDir));

    if (cchSize > sizeof(g_ai.szSysDir) || cchSize == 0) {
        return FALSE;
    }

    //
    // Set up information for each of the shortcuts we'll be creating
    // and the files we're installing.
    //
    g_ai.cFiles = NUM_FILES;

    hr = StringCchCopy(g_ai.shortcut[0].szDisplayName,
                       sizeof(g_ai.shortcut[0].szDisplayName),
                       "Compatibility Demo Readme");

    if (FAILED(hr)) {
        return FALSE;
    }

    hr = StringCchCopy(g_ai.shortcut[0].szFileName,
                       sizeof(g_ai.shortcut[0].szFileName),
                       "demoapp.txt");

    if (FAILED(hr)) {
        return FALSE;
    }

    hr = StringCchCopy(g_ai.shortcut[1].szDisplayName,
                       sizeof(g_ai.shortcut[1].szDisplayName),
                       "Compatibility Demo");

    if (FAILED(hr)) {
        return FALSE;
    }

    hr = StringCchCopy(g_ai.shortcut[1].szFileName,
                       sizeof(g_ai.shortcut[1].szFileName),
                       "demoapp.exe");

    if (FAILED(hr)) {
        return FALSE;
    }

    hr = StringCchCopy(g_ai.shortcut[2].szDisplayName,
                       sizeof(g_ai.shortcut[2].szDisplayName),
                       "Compatibility Demo Help");

    if (FAILED(hr)) {
        return FALSE;
    }

    hr = StringCchCopy(g_ai.shortcut[2].szFileName,
                       sizeof(g_ai.shortcut[2].szFileName),
                       "demoapp.hlp");

    if (FAILED(hr)) {
        return FALSE;
    }

    hr = StringCchCopy(g_ai.shortcut[3].szFileName,
                       sizeof(g_ai.shortcut[3].szFileName),
                       "demodll.dll");

    if (FAILED(hr)) {
        return FALSE;
    }

    //
    // Save away the path that we're running from for later.
    //
    szPath[sizeof(szPath) - 1] = 0;
    cchReturned = GetModuleFileName(NULL, szPath, sizeof(szPath));

    if (szPath[sizeof(szPath) - 1] != 0 || cchReturned == 0) {
        return FALSE;
    }

    pTemp = strrchr(szPath, '\\');

    if (pTemp) {
        *pTemp = '\0';
    }

    StringCchCopy(g_ai.szCurrentDir, sizeof(g_ai.szCurrentDir), szPath);

    //
    // Check for Win9x - this won't get hooked by any VL.
    //
    IsWindows9x();

    //
    // Check for WinXP - this won't get hooked by any VL.
    //
    IsWindowsXP();

    //
    // Parse the command line, if one was provided.
    //
    if (lpCmdLine) {
        pToken = strtok(lpCmdLine, szSeps);

        while (pToken) {
            if (CompareString(LOCALE_USER_DEFAULT,
                              NORM_IGNORECASE,
                              pToken,
                              -1,
                              szDisable,
                              -1) == CSTR_EQUAL) {
                g_ai.fEnableBadFunc = FALSE;
            }

            else if (CompareString(LOCALE_USER_DEFAULT,
                                   NORM_IGNORECASE,
                                   pToken,
                                   -1,
                                   szRunApp,
                                   -1) == CSTR_EQUAL) {
                g_ai.fRunApp = TRUE;
            }

            else if (CompareString(LOCALE_USER_DEFAULT,
                                   NORM_IGNORECASE,
                                   pToken,
                                   -1,
                                   szExtended,
                                   -1) == CSTR_EQUAL) {
                g_ai.fExtended = TRUE;
            }

            else if (CompareString(LOCALE_USER_DEFAULT,
                                   NORM_IGNORECASE,
                                   pToken,
                                   -1,
                                   szInsecure,
                                   -1) == CSTR_EQUAL) {
                g_ai.fInsecure = TRUE;
            }

            else if (CompareString(LOCALE_USER_DEFAULT,
                                   NORM_IGNORECASE,
                                   pToken,
                                   -1,
                                   szInternal,
                                   -1) == CSTR_EQUAL) {
                g_ai.fInternal = TRUE;
            }

            pToken = strtok(NULL, szSeps);
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Displays a common font dialog.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
DisplayFontDlg(
    IN HWND hWnd
    )
{
    CHOOSEFONT      cf;
    static LOGFONT  lf;
    static DWORD    rgbCurrent;

    ZeroMemory(&cf, sizeof(CHOOSEFONT));

    cf.lStructSize  =   sizeof(CHOOSEFONT);
    cf.hwndOwner    =   hWnd;
    cf.lpLogFont    =   &lf;
    cf.rgbColors    =   rgbCurrent;
    cf.Flags        =   CF_SCREENFONTS | CF_EFFECTS;

    //
    // Display the dialog - user input isn't processed.
    //
    ChooseFont(&cf);
}

/*++

  Routine Description:

    Determines if we're truly running on Windows 9x.
    A version lie will not correct this call.

  Arguments:

    None.

  Return Value:

    None - sets a global flag.

--*/
void
IsWindows9x(
    void
    )
{
    CRegistry   creg;
    LPSTR       lpRet = NULL;

    //
    // Query a part of the registry that's specific to NT/2000/XP.
    // We use the result when we're making calls for demo purposes
    // that work differently on Win9x/ME (example: creating shortcuts).
    //
    lpRet = creg.GetString(HKEY_LOCAL_MACHINE,
                           PRODUCT_OPTIONS_KEY,
                           "ProductType");

    if (!lpRet) {
        g_ai.fWin9x = TRUE;
    } else {
        g_ai.fWin9x = FALSE;
        creg.Free(lpRet);
    }
}

/*++

  Routine Description:

    Determines if we're running on Windows XP.
    A version lie will not correct this call.

  Arguments:

    None.

  Return Value:

    None - sets a global flag.

--*/
void
IsWindowsXP(
    void
    )
{
    CRegistry   creg;
    LPSTR       lpBuild = NULL;
    int         nBuild = 0, nWin2K = 2195;

    //
    // This registry key should only exist for
    // Windows XP.
    //
    lpBuild = creg.GetString(HKEY_LOCAL_MACHINE,
                             CURRENT_VERSION_KEY,
                             "CurrentBuildNumber");

    //
    // Convert the string to an integer.
    //
    if (lpBuild) {
        nBuild = atoi(lpBuild);

        if (nWin2K < nBuild) {
            g_ai.fWinXP = TRUE;
        } else {
            g_ai.fWinXP = FALSE;
        }
    }

    if (lpBuild) {
        creg.Free(lpBuild);
    }
}

/*++

  Routine Description:

    Adds additional items to our menu.

  Arguments:

    hWnd    -   Handle to the parent window.

  Return Value:

    None.

--*/
void
AddExtendedItems(
    IN HWND hWnd
    )
{
    HMENU   hMenu, hSubMenu;

    //
    // Get menu handles, then add additional items.
    //
    hMenu = GetMenu(hWnd);

    if (!hMenu) {
        return;
    }

    hSubMenu = GetSubMenu(hMenu, 2);

    if (!hSubMenu) {
        return;
    }

    AppendMenu(hSubMenu, MF_ENABLED | MF_SEPARATOR, 1, NULL);

    AppendMenu(hSubMenu,
               MF_ENABLED | MF_STRING,
               IDM_ACCESS_VIOLATION,
               "Access Violation");

    AppendMenu(hSubMenu,
               MF_ENABLED | MF_STRING,
               IDM_EXCEED_BOUNDS,
               "Exceed Array Bounds");

    AppendMenu(hSubMenu,
               MF_ENABLED | MF_STRING,
               IDM_FREE_INVALID_MEM,
               "Free Invalid Memory");

    AppendMenu(hSubMenu,
               MF_ENABLED | MF_STRING,
               IDM_FREE_MEM_TWICE,
               "Free Memory Twice");

    AppendMenu(hSubMenu,
               MF_ENABLED | MF_STRING,
               IDM_HEAP_CORRUPTION,
               "Heap Corruption");

    AppendMenu(hSubMenu,
               MF_ENABLED | MF_STRING,
               IDM_PRIV_INSTRUCTION,
               "Privileged Instruction");

    DrawMenuBar(hWnd);
}

/*++

  Routine Description:

    Adds internal items to the menu bar.

  Arguments:

    hWnd    -   Handle to the parent window.

  Return Value:

    None.

--*/
void
AddInternalItems(
    IN HWND hWnd
    )
{
    HMENU   hMenu, hSubMenu;

    //
    // Get menu handles, then add additional items.
    //
    hMenu = GetMenu(hWnd);

    if (!hMenu) {
        return;
    }

    hSubMenu = GetSubMenu(hMenu, 2);

    if (!hSubMenu) {
        return;
    }

    AppendMenu(hSubMenu, MF_ENABLED | MF_SEPARATOR, 1, NULL);

    AppendMenu(hSubMenu,
               MF_ENABLED | MF_STRING,
               IDM_PROPAGATION_TEST,
               "Propagation Test");

    DrawMenuBar(hWnd);
}

/*++

  Routine Description:

    Obtains an address for an exported function,
    then calls it.
    Used to test the include/exclude functionality
    in QFixApp. Note that is not documented anywhere.

  Arguments:

    hWnd    -   Window handle to be passed to the function.

  Return Value:

    None.

--*/
void
TestIncludeExclude(
    IN HWND hWnd
    )
{
    HINSTANCE   hInstance;
    HRESULT     hr;
    char        szDll[MAX_PATH];
    const char  szDemoDll[] = "demodll.dll";

    LPFNDEMOAPPMESSAGEBOX   DemoAppMessageBox;

    hr = StringCchPrintf(szDll,
                         sizeof(szDll),
                         "%hs\\%hs",
                         g_ai.szCurrentDir,
                         szDemoDll);

    if (FAILED(hr)) {
        return;
    }

    hInstance = LoadLibrary(szDll);

    if (hInstance) {
        //
        // Get the address of the function.
        //
        DemoAppMessageBox = (LPFNDEMOAPPMESSAGEBOX)GetProcAddress(hInstance,
                                                                  "DemoAppMessageBox");

        if (!DemoAppMessageBox) {
            FreeLibrary(hInstance);
            return;
        }

        DemoAppMessageBox(hWnd);

        FreeLibrary(hInstance);
    }
}

/*++

  Routine Description:

    Saves the contents of the edit window to a file
    specified by the user.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
SaveContentsToFile(
    IN LPCSTR pszFileName
    )
{
    int     nLen = 0;
    DWORD   cbBytesWritten;
    HANDLE  hFile;
    LPSTR   pszData = NULL;
    char    szError[MAX_PATH];

    //
    // Determine how much space we need for the buffer, then allocate it.
    //
    nLen = GetWindowTextLength(g_ai.hWndEdit);

    if (nLen) {

        pszData = (LPTSTR)HeapAlloc(GetProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    nLen);

        if (!pszData) {
            LoadString(g_ai.hInstance, IDS_BUFFER_ALLOC_FAIL, szError, sizeof(szError));
            MessageBox(g_ai.hWndMain, szError, MAIN_APP_TITLE, MB_ICONERROR);
            return;
        }

        //
        // Get the text out of the text box and write it out to our file.
        //
        GetWindowText(g_ai.hWndEdit, pszData, nLen);

        hFile = CreateFile(pszFileName,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            LoadString(g_ai.hInstance, IDS_FILE_CREATE_FAIL, szError, sizeof(szError));
            MessageBox(g_ai.hWndMain, szError, MAIN_APP_TITLE, MB_ICONERROR);
            goto cleanup;
        }

        WriteFile(hFile, pszData, nLen, &cbBytesWritten, NULL);

        CloseHandle(hFile);

    }

cleanup:

    if (pszData) {
        HeapFree(GetProcessHeap(), 0, pszData);
    }
}

/*++

  Routine Description:

    Displays a common dialog to the user which allows
    them to save the contents of the edit box to a file.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
ShowSaveDialog(
    void
    )
{
    char            szFilter[MAX_PATH] = "";
    char            szTemp[MAX_PATH];
    OPENFILENAME    ofn = {0};

    *szTemp = 0;

    LoadString(g_ai.hInstance, IDS_SAVE_FILTER, szFilter, sizeof(szFilter));

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = g_ai.hWndMain;
    ofn.hInstance         = g_ai.hInstance;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szTemp;
    ofn.nMaxFile          = sizeof(szTemp);
    ofn.lpstrTitle        = NULL;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = NULL;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = "txt";
    ofn.lCustData         = 0;
    ofn.Flags             = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST |
                            OFN_HIDEREADONLY  | OFN_OVERWRITEPROMPT;

    if (GetSaveFileName(&ofn)) {
        SaveContentsToFile(szTemp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\registry.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Registry.h

  Abstract:

    Class definition for the registry API wrapper class.

  Notes:

    ANSI & Unicode via TCHAR - runs on Win9x/NT/2K/XP etc.
    
  History:

    01/29/2001  rparsons    Created
    03/02/2001  rparsons    Major overhaul
    01/27/2002  rparsons    Converted to TCHAR

--*/
#ifndef _CREGISTRY_H
#define _CREGISTRY_H

#include <windows.h>
#include <tchar.h>
#include <strsafe.h>

#define REG_FORCE_RESTORE           (0x00000008L)

//
// Macro that returns TRUE if the given registry handle is predefined.
//
#define IsPredefinedRegistryHandle(h)                                       \
    ((  ( h == HKEY_CLASSES_ROOT        )                                   \
    ||  ( h == HKEY_CURRENT_USER        )                                   \
    ||  ( h == HKEY_LOCAL_MACHINE       )                                   \
    ||  ( h == HKEY_USERS               )                                   \
    ||  ( h == HKEY_CURRENT_CONFIG      )                                   \
    ||  ( h == HKEY_PERFORMANCE_DATA    )                                   \
    ||  ( h == HKEY_DYN_DATA            ))                                  \
    ?   TRUE                                                                \
    :   FALSE )

class CRegistry {

public:
    HKEY CreateKey(IN  HKEY    hKey,
                   IN  LPCTSTR pszSubKey,
                   IN  REGSAM  samDesired);

    HKEY CreateKey(IN  HKEY    hKey,
                   IN  LPCTSTR pszSubKey,
                   IN  REGSAM  samDesired,
                   OUT LPDWORD pdwDisposition);

    LONG CloseKey(IN HKEY hKey);

    LPSTR GetString(IN HKEY    hKey,
                    IN LPCTSTR pszSubKey,
                    IN LPCTSTR pszValueName);

    BOOL GetDword(IN HKEY    hKey,
                  IN LPCTSTR pszSubKey,
                  IN LPCTSTR pszValueName,
                  IN LPDWORD lpdwData);

    BOOL SetString(IN HKEY    hKey,
                   IN LPCTSTR pszSubKey,
                   IN LPCTSTR pszValueName,
                   IN LPCTSTR pszData);

    BOOL SetMultiSzString(IN HKEY    hKey,
                          IN LPCTSTR pszSubKey,
                          IN LPCTSTR pszValueName,
                          IN LPCTSTR pszData,
                          IN DWORD   cbSize);

    BOOL SetDword(IN HKEY    hKey,
                  IN LPCTSTR pszSubKey,
                  IN LPCTSTR pszValueName,
                  IN DWORD   dwData);

    BOOL DeleteString(IN HKEY    hKey,
                      IN LPCTSTR pszSubKey,
                      IN LPCTSTR pszValueName);

    BOOL IsRegistryKeyPresent(IN HKEY    hKey,
                              IN LPCTSTR pszSubKey);

    void Free(IN LPVOID pvMem);

    BOOL AddStringToMultiSz(IN HKEY    hKey,
                            IN LPCTSTR pszSubKey,
                            IN LPCTSTR pszEntry);

    BOOL RemoveStringFromMultiSz(IN HKEY    hKey,
                                 IN LPCTSTR pszSubKey,
                                 IN LPCTSTR pszEntry);

    BOOL RestoreKey(IN HKEY    hKey,
                    IN LPCTSTR pszSubKey,
                    IN LPCTSTR pszFileName,
                    IN BOOL    fGrantPrivs);

    BOOL BackupRegistryKey(IN HKEY    hKey,
                           IN LPCTSTR pszSubKey,
                           IN LPCTSTR pszFileName,
                           IN BOOL    fGrantPrivs);
private:

    DWORD GetStringSize(IN     HKEY    hKey,
                        IN     LPCTSTR pszValueName,
                        IN OUT LPDWORD lpType OPTIONAL);

    LPVOID Malloc(IN SIZE_T cbBytes);

    HKEY OpenKey(IN HKEY    hKey,
                 IN LPCTSTR pszSubKey,
                 IN REGSAM  samDesired);

    int ListStoreLen(IN LPTSTR pszList);

    BOOL ModifyTokenPrivilege(IN LPCTSTR pszPrivilege,
                              IN BOOL    fEnable);
};

#endif // _CREGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\shortcut.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Shortcut.h

  Abstract:

    Class definition for the IShellLink wrapper class.

  Notes:

    ANSI & Unicode via TCHAR - runs on Win9x/NT/2K/XP etc.

  History:

    01/30/2001  rparsons    Created
    01/10/2002  rparsons    Revised
    01/27/2002  rparsons    Converted to TCHAR

--*/
#ifndef _CSHORTCUT_H
#define _CSHORTCUT_H

#include <windows.h>
#include <tchar.h>
#include <shlobj.h>
#include <stdio.h>
#include <strsafe.h>

#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))

class CShortcut {

public:

    HRESULT CreateShortcut(IN LPCTSTR pszFileNamePath,
                           IN LPTSTR  pszDisplayName,
                           IN LPCTSTR pszArguments OPTIONAL,
                           IN LPCTSTR pszStartIn OPTIONAL,
                           IN int     nCmdShow,
                           IN int     nFolder);

    HRESULT CreateShortcut(IN LPCTSTR pszLnkDirectory,
                           IN LPCTSTR pszFileNamePath,
                           IN LPTSTR  pszDisplayName,
                           IN LPCTSTR pszArguments OPTIONAL,
                           IN LPCTSTR pszStartIn OPTIONAL,
                           IN int     nCmdShow);

    HRESULT CreateGroup(IN LPCTSTR pszGroupName, 
                        IN BOOL    fAllUsers);

    HRESULT SetArguments(IN LPTSTR pszFileName,
                         IN LPTSTR pszArguments);

private:

    HRESULT BuildShortcut(IN LPCTSTR pszPath,
                          IN LPCTSTR pszArguments OPTIONAL,
                          IN LPCTSTR pszLocation,
                          IN LPCTSTR pszWorkingDir OPTIONAL,
                          IN int     nCmdShow);
};

#endif // _CSHORTCUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\splash.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Splash.h

  Abstract:

    Definition for the splash screen class.

  Notes:

    ANSI & Unicode via TCHAR - runs on Win9x/NT/2K/XP etc.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised
    01/27/02    rparsons    Converted to TCHAR

--*/
#ifndef _CSPLASH_H
#define _CSPLASH_H

#include <windows.h>
#include <tchar.h>

#define PALVERSION 0x300
#define MAXPALETTE 256

class CSplash {

public:
    CSplash();
    
    void Create(IN HINSTANCE hInstance,    
                IN DWORD     dwLoColorBitmapId,
                IN DWORD     dwHiColorBitmapId OPTIONAL,
                IN DWORD     dwDuration);    

private:

    HINSTANCE   m_hInstance;
    DWORD       m_dwDuration;
    DWORD       m_dwSplashId;

    BOOL InitSplashScreen(IN HINSTANCE hInstance);
    
    BOOL CreateSplashWindow();    

    HPALETTE CreateSpectrumPalette();

    HPALETTE CreatePaletteFromRGBQUAD(IN LPRGBQUAD rgbqPalette,
                                      IN WORD      cElements);

    void DisplayBitmap(IN HWND hWnd, IN DWORD dwResId);

    static LRESULT CALLBACK SplashWndProc(IN HWND   hWnd,
                                          IN UINT   uMsg,
                                          IN WPARAM wParam,
                                          IN LPARAM lParam);
};

#endif // _CSPLASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\shortcut.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Shortcut.cpp

  Abstract:

    Implementation of the IShellLink wrapper class.

  Notes:

    ANSI & Unicode via TCHAR - runs on Win9x/NT/2K/XP etc.

  History:

    01/29/2001  rparsons    Created
    01/10/2002  rparsons    Revised
    01/27/2002  rparsons    Converted to TCHAR

--*/
#include "shortcut.h"

/*++

  Routine Description:

    Creates a shortcut given a CSIDL.

  Arguments:

    pszFileNamePath     -   Name and path of the file that the shortcut points to.
    pszDisplayName      -   Shortcut display text.
    pszArguments        -   Arguments to be passed to the program.
    pszStartIn          -   The start-in directory for the program.
    nCmdShow            -   Dictates how the program will be displayed.
    nFolder             -   CSIDL that dictates where to place the shortcut.

  Return Value:

    S_OK on success, a failure code otherwise.

--*/
HRESULT
CShortcut::CreateShortcut(
    IN LPCTSTR pszFileNamePath,
    IN LPTSTR  pszDisplayName,
    IN LPCTSTR pszArguments OPTIONAL,
    IN LPCTSTR pszStartIn OPTIONAL,
    IN int     nCmdShow,
    IN int     nFolder
    )
{
    HRESULT hr;
    TCHAR   szDestFolder[MAX_PATH];
    TCHAR   szLocation[MAX_PATH];

    if (!pszFileNamePath || !pszDisplayName) {
        return E_INVALIDARG;
    }

    hr = SHGetFolderPath(NULL, nFolder, NULL, SHGFP_TYPE_CURRENT, szDestFolder);

    if (FAILED(hr)) {
        return hr;
    }

    hr = StringCchPrintf(szLocation,
                         ARRAYSIZE(szLocation),
                         "%s\\%s.lnk",
                         szDestFolder,
                         pszDisplayName);

    if (FAILED(hr)) {
        return hr;
    }

    //
    // Call the function to do the work of creating the shortcut.
    //
    hr = BuildShortcut(pszFileNamePath,
                       pszArguments,
                       szLocation,
                       pszStartIn,
                       nCmdShow);

    return hr;
}

/*++

  Routine Description:

    Creates a shortcut given a path.

  Arguments:

    lpLnkDirectory      -       Path that will contain the shortcut
    lpFileNamePath      -       Name and path of the file that the shortcut points to
    lpDisplayName       -       Shortcut display text
    lpArguments         -       Arguments to be passed to the program
    lpStartIn           -       The start-in directory for the program
    nCmdShow            -       Dictates how the program will be displayed


  Return Value:

    Calls BuildShortcut which returns an HRESULT.

--*/
HRESULT
CShortcut::CreateShortcut(
    IN LPCTSTR pszLnkDirectory,
    IN LPCTSTR pszFileNamePath,
    IN LPTSTR  pszDisplayName,
    IN LPCTSTR pszArguments OPTIONAL,
    IN LPCTSTR pszStartIn OPTIONAL,
    IN int     nCmdShow
    )
{
    HRESULT hr;
    TCHAR   szLocation[MAX_PATH];

    if (!pszLnkDirectory || !pszFileNamePath || !pszDisplayName) {
        return E_INVALIDARG;
    }

    hr = StringCchPrintf(szLocation,
                         ARRAYSIZE(szLocation),
                         "%s\\%s.lnk",
                         pszLnkDirectory,
                         pszDisplayName);

    if (FAILED(hr)) {
        return hr;
    }

    //
    // Call the function to do the work of creating the shortcut.
    //
    return BuildShortcut(pszFileNamePath,
                         pszArguments,
                         szLocation,
                         pszStartIn,
                         nCmdShow);

}

/*++

  Routine Description:

    Does the work of actually creating the shortcut.

  Arguments:

    pszPath             -       Path that the shortcut points to.
    pszArguments        -       Arguments to be passed to the program.
    pszLocation         -       Location of the shortcut and it's name.
    pszWorkingDir       -       The start-in directory for the program.
    nCmdShow            -       Dictates how the program will be displayed.

  Return Value:

    S_OK on success, an HRESULT code on failure.

--*/
HRESULT
CShortcut::BuildShortcut(
    IN LPCTSTR pszPath,
    IN LPCTSTR pszArguments OPTIONAL,
    IN LPCTSTR pszLocation,
    IN LPCTSTR pszWorkingDir OPTIONAL,
    IN int     nCmdShow
    )
{
    IShellLink*     pisl = NULL;
    IPersistFile*   pipf = NULL;
    HRESULT         hr = E_FAIL;
    WCHAR           wszLocation[MAX_PATH];

    if (!pszPath || !pszLocation) {
        return E_INVALIDARG;
    }

    //
    // Load the COM libraries.
    //
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if (FAILED(hr)) {
        return hr;
    }

    //
    // Get an IShellLink interface pointer.
    //
    hr = CoCreateInstance(CLSID_ShellLink,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IShellLink,
                          (LPVOID*)&pisl);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Get an IPersistFile interface pointer.
    //
    hr = pisl->QueryInterface(IID_IPersistFile, (LPVOID*)&pipf);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Set the path to the shortcut.
    //
    hr = pisl->SetPath(pszPath);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Set the arguments for the shortcut.
    //
    if (pszArguments) {
        hr = pisl->SetArguments(pszArguments);

        if (FAILED(hr)) {
            goto exit;
        }
    }

    //
    // Set the working directory.
    //
    if (pszWorkingDir) {
        hr = pisl->SetWorkingDirectory(pszWorkingDir);

        if (FAILED(hr)) {
            goto exit;
        }
    }

    //
    // Set the show flag.
    //
    hr = pisl->SetShowCmd(nCmdShow);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Convert from ANSI to UNICODE prior to the save.
    //
#ifndef UNICODE
    if (!MultiByteToWideChar(CP_ACP,
                             0,
                             pszLocation,
                             -1,
                             wszLocation,
                             MAX_PATH)) {
        hr = E_FAIL;
        goto exit;
    }
#else
    wcsncpy(wszLocation, pszLocation, MAX_PATH);
#endif // UNICODE

    //
    // Write the shortcut to disk.
    //
    hr = pipf->Save(wszLocation, TRUE);

    if (FAILED(hr)) {
        goto exit;
    }

exit:

    if (pisl) {
        pisl->Release();
    }

    if (pipf) {
        pipf->Release();
    }

    CoUninitialize();

    return hr;
}

/*++

  Routine Description:

    Creates a group on the start menu.

  Arguments:

    pszGroupName    -       Name of the group.
    fAllUsers       -       A flag to indicate if the group should
                            appear in the All Users folder. If false,
                            the group is created in the private user's folder.

  Return Value:

    S_OK on success, an HRESULT code on failure.

--*/
HRESULT
CShortcut::CreateGroup(
    IN LPCTSTR pszGroupName,
    IN BOOL    fAllUsers
    )
{
    LPITEMIDLIST    pidl;
    TCHAR           szProgramPath[MAX_PATH];
    TCHAR           szGroupPath[MAX_PATH];
    BOOL            bReturn = FALSE;
    HRESULT         hr;

    if (!pszGroupName) {
        return E_INVALIDARG;
    }

    //
    // Get the PIDL for the Programs folder in the shell namespace
    //
    hr = SHGetSpecialFolderLocation(NULL,
                                    fAllUsers ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                                    &pidl);

    if (FAILED(hr)) {
        return hr;
    }

    //
    // Get the path associated with the PIDL.
    //
    bReturn = SHGetPathFromIDList(pidl, szProgramPath);

    if (!bReturn) {
        goto exit;
    }

    //
    // Build the path for the new group.
    //
    hr = StringCchPrintf(szGroupPath,
                         ARRAYSIZE(szGroupPath),
                         "%s\\%s",
                         szProgramPath,
                         pszGroupName);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Create the directory (group) where shortcuts will reside.
    //
    if (!CreateDirectory(szGroupPath, NULL)) {
        goto exit;
    }

    //
    // Tell the shell that we changed something.
    //
    SHChangeNotify(SHCNE_MKDIR,
                   SHCNF_PATH,
                   (LPVOID)szGroupPath,
                   0);

    hr = S_OK;

exit:

    if (pidl) {
        CoTaskMemFree((LPVOID)pidl);
    }

    return hr;
}

/*++

  Routine Description:

    Sets arguments for a given shortcut.

  Arguments:

    pszFileName     -   Name of the file to set the arguments for.
    pszArguments    -   Arguments to apply to file.

  Return Value:

    S_OK on success, an HRESULT code on failure.

--*/
HRESULT
CShortcut::SetArguments(
    IN LPTSTR pszFileName,
    IN LPTSTR pszArguments
    )
{
    IShellLink*     pisl = NULL;
    IPersistFile*   pipf = NULL;
    HRESULT         hr = E_FAIL;
    WCHAR           wszFileName[MAX_PATH];

    if (!pszFileName || !pszArguments) {
        return E_INVALIDARG;
    }

    //
    // Load the COM libraries.
    //
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if (FAILED(hr)) {
        return hr;
    }

    //
    // Get an IShellLink interface pointer.
    //
    hr = CoCreateInstance(CLSID_ShellLink,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IShellLink,
                          (LPVOID*)&pisl);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Get an IPersistFile interface pointer.
    //
    hr = pisl->QueryInterface(IID_IPersistFile, (LPVOID*)&pipf);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Convert from ANSI to UNICODE.
    //
#ifndef UNICODE
    if (!MultiByteToWideChar(CP_ACP,
                             0,
                             pszFileName,
                             -1,
                             wszFileName,
                             MAX_PATH)) {
        hr = E_FAIL;
        goto exit;
    }
#else
    wcsncpy(wszFileName, pszFileName, MAX_PATH);
#endif

    //
    // Load the shortcut so we can change it.
    //
    hr = pipf->Load(wszFileName, STGM_READWRITE);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Set the arguments.
    //
    hr = pisl->SetArguments(pszArguments);

    if (FAILED(hr)) {
        goto exit;
    }

    //
    // Save the shortcut back to disk.
    //
    hr = pipf->Save(wszFileName, TRUE);

    if (FAILED(hr)) {
        goto exit;
    }

exit:

    if (pisl) {
        pisl->Release();
    }

    if (pipf) {
        pipf->Release();
    }

    CoUninitialize();


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\splash.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Splash.cpp

  Abstract:

    Implementation of the splash screen class.

  Notes:

    ANSI & Unicode via TCHAR - runs on Win9x/NT/2K/XP etc.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised
    01/27/02    rparsons    Converted to TCHAR

--*/
#include "splash.h"

/*++

  Routine Description:

    Constructor - init member variables.

  Arguments:

    None.

  Return Value:

    None.

--*/
CSplash::CSplash()
{
    m_dwDuration = 0;
    m_dwSplashId = 0;
}

/*++

  Routine Description:

    Does the work of creating the splash screen.

  Arguments:

    hInstance           -   Application instance handle.
    dwLoColorBitmapId   -   Low color bitmap identifier.
    dwHiColorBitmapId   -   Hight color bitmap identifier (OPTIONAL).
    dwDuration          -   Amount of time to display the splash screen (milliseconds).

  Return Value:

    None.

--*/
void
CSplash::Create(
    IN HINSTANCE hInstance,
    IN DWORD     dwLoColorBitmapId,
    IN DWORD     dwHiColorBitmapId OPTIONAL,
    IN DWORD     dwDuration
    )
{
    HDC     hDC;
    int     nBitsInAPixel = 0;

    m_hInstance = hInstance;

    //
    // Get a handle to the display driver context and determine
    // the number of bits in a pixel.
    //
    hDC = GetDC(0);

    nBitsInAPixel = GetDeviceCaps(hDC, BITSPIXEL);

    ReleaseDC(NULL, hDC);

    //
    // If there are more than 8 bits in a pixel, and the high color
    // bitmap is available, use it. Otherwise, use the low color one.
    //
    if (nBitsInAPixel > 8 && dwHiColorBitmapId) {
        m_dwSplashId = dwHiColorBitmapId;
    } else {
        m_dwSplashId = dwLoColorBitmapId;
    }

    m_dwDuration = dwDuration * 1000;

    CSplash::InitSplashScreen(hInstance);

    CSplash::CreateSplashWindow();
}

/*++

  Routine Description:

    Sets up the window class struct for splash screen.

  Arguments:

    hInstance       -    Application instance handle.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CSplash::InitSplashScreen(
    IN HINSTANCE hInstance
    )
{
    WNDCLASS  wc;

    wc.style          = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc    = SplashWndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;
    wc.hInstance      = hInstance;
    wc.hIcon          = NULL;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)GetStockObject(NULL_BRUSH);
    wc.lpszMenuName   = NULL;
    wc.lpszClassName  = _T("SPLASHWIN");

    return RegisterClass(&wc);
}

/*++

  Routine Description:

    Creates the splash screen for the setup app.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CSplash::CreateSplashWindow()
{
    HBITMAP hBitmap;
    BITMAP  bm;
    RECT    rect;
    HWND    hWnd;

    //
    // Load the bitmap and fill out a BITMAP structure for it.
    //
    hBitmap = LoadBitmap(m_hInstance, MAKEINTRESOURCE(m_dwSplashId));
    GetObject(hBitmap, sizeof(bm), &bm);
    DeleteObject(hBitmap);

    GetWindowRect(GetDesktopWindow(), &rect);

    //
    // Create the splash screen window.
    // Specifying WS_EX_TOOLWINDOW keeps us out of the
    // taskbar.
    //
    hWnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                          _T("SPLASHWIN"),
                          NULL,
                          WS_POPUP | WS_BORDER,
                          (rect.right  / 2) - (bm.bmWidth  / 2),
                          (rect.bottom / 2) - (bm.bmHeight / 2),
                          bm.bmWidth,
                          bm.bmHeight,
                          NULL,
                          NULL,
                          m_hInstance,
                          (LPVOID)this);

    if (hWnd) {
        ShowWindow(hWnd, SW_SHOWNORMAL);
        UpdateWindow(hWnd);
    }

    return (hWnd ? TRUE : FALSE);
}

/*++

  Routine Description:

    Runs the message loop for the splash screen.

  Arguments:

    hWnd        -    Window handle.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if the message was processed, FALSE otherwise.

--*/
LRESULT
CALLBACK
CSplash::SplashWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PAINTSTRUCT ps;
    HDC hdc;

    CSplash  *pThis = (CSplash*)GetWindowLong(hWnd, GWL_USERDATA);

    switch (uMsg) {
    case WM_CREATE:
    {
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
        pThis = (CSplash*)(lpcs->lpCreateParams);
        SetWindowLong(hWnd, GWL_USERDATA, (LONG)pThis);

        //
        // Enable the timer - this sets the amount
        // of time the screen will be displayed.
        //
        SetTimer(hWnd, 0, pThis->m_dwDuration, NULL);
        break;
    }

    //
    // Handle the palette messages in case another app takes
    // over the palette
    //
    case WM_PALETTECHANGED:

        if ((HWND) wParam == hWnd) {
            return 0;
        }

    case WM_QUERYNEWPALETTE:

        InvalidateRect(hWnd, NULL, FALSE);
        UpdateWindow(hWnd);

        return TRUE;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    case WM_TIMER:

        DestroyWindow(hWnd);
        break;

    case WM_PAINT:

        hdc = BeginPaint(hWnd, &ps);
        pThis->DisplayBitmap(hWnd, pThis->m_dwSplashId);
        EndPaint(hWnd, &ps);
        break;

    //
    // Override this message so Windows doesn't try
    // to calculate size for the caption bar and stuff.
    //
    case WM_NCCALCSIZE:

        return 0;

    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);

    }

    return FALSE;
}

/*++

  Routine Description:

    Builds a palette with a spectrum of colors.

  Arguments:

    None.

  Return Value:

    Handle to a spectrum palette on success
    or NULL on failure.

--*/
HPALETTE
CSplash::CreateSpectrumPalette()
{
    HPALETTE        hPal;
    LPLOGPALETTE    lplgPal = NULL;
    BYTE            red, green, blue;
    int             nCount = 0;

    lplgPal = (LPLOGPALETTE)HeapAlloc(GetProcessHeap(),
                                      HEAP_ZERO_MEMORY,
                                      sizeof(LOGPALETTE) +
                                      sizeof(PALETTEENTRY) *
                                      MAXPALETTE);
    if (!lplgPal) {
        return NULL;
    }

    //
    // Initialize members of the structure
    // and build the spectrum of colors.
    //
    lplgPal->palVersion     = PALVERSION;
    lplgPal->palNumEntries  = MAXPALETTE;

    red = green = blue = 0;

    for (nCount = 0; nCount < MAXPALETTE; nCount++) {
        lplgPal->palPalEntry[nCount].peRed   = red;
        lplgPal->palPalEntry[nCount].peGreen = green;
        lplgPal->palPalEntry[nCount].peBlue  = blue;
        lplgPal->palPalEntry[nCount].peFlags = 0;

        if (!(red += 32)) {
            if (!(green += 32)) {
                blue += 64;
            }
        }
    }

    hPal = CreatePalette(lplgPal);

    HeapFree(GetProcessHeap(), 0, lplgPal);

    return hPal;
}

/*++

  Routine Description:

    Builds a palette from an RGBQUAD structure.

  Arguments:

    rgbqPalette     -       Array of RGBQUAD structs.
    cElements       -       Number of elements in the array.

  Return Value:

    Handle to a palette on success or NULL on failure.

--*/
HPALETTE
CSplash::CreatePaletteFromRGBQUAD(
    IN LPRGBQUAD rgbqPalette,
    IN WORD      cElements
    )
{
    HPALETTE        hPal;
    LPLOGPALETTE    lplgPal = NULL;
    int             nCount = 0;

    lplgPal = (LPLOGPALETTE)HeapAlloc(GetProcessHeap(),
                                      HEAP_ZERO_MEMORY,
                                      sizeof(LOGPALETTE) +
                                      sizeof(PALETTEENTRY) *
                                      cElements);
    if (!lplgPal) {
        return NULL;
    }

    //
    // Initialize structure members and fill in palette colors.
    //
    lplgPal->palVersion    = PALVERSION;
    lplgPal->palNumEntries = cElements;

    for (nCount = 0; nCount < cElements; nCount++) {
        lplgPal->palPalEntry[nCount].peRed   = rgbqPalette[nCount].rgbRed;
        lplgPal->palPalEntry[nCount].peGreen = rgbqPalette[nCount].rgbGreen;
        lplgPal->palPalEntry[nCount].peBlue  = rgbqPalette[nCount].rgbBlue;
        lplgPal->palPalEntry[nCount].peFlags = 0;
    }

    hPal = CreatePalette(lplgPal);

    HeapFree(GetProcessHeap(), 0, lplgPal);

    return hPal;
}

/*++

  Routine Description:

    Displays the bitmap in the specified window.

  Arguments:

    hWnd        -       Handle to the destination window.
    dwResId     -       Resource identifier for the bitmap.

  Return Value:

    None.

--*/
void
CSplash::DisplayBitmap(
    IN HWND  hWnd,
    IN DWORD dwResId
    )
{
    HBITMAP     hBitmap;
    HPALETTE    hPalette;
    HDC         hdcMemory = NULL, hdcWindow = NULL;
    BITMAP      bm;
    RECT        rect;
    RGBQUAD     rgbq[256];

    CSplash *pThis = (CSplash*)GetWindowLong(hWnd, GWL_USERDATA);

    GetClientRect(hWnd, &rect);

    //
    // Load the resource as a DIB section.
    //
    hBitmap = (HBITMAP)LoadImage(pThis->m_hInstance,
                                 MAKEINTRESOURCE(dwResId),
                                 IMAGE_BITMAP,
                                 0,
                                 0,
                                 LR_CREATEDIBSECTION);

    GetObject(hBitmap, sizeof(BITMAP), (LPWSTR)&bm);

    hdcWindow = GetDC(hWnd);

    //
    // Create a DC to hold our surface and selct our surface into it.
    //
    hdcMemory = CreateCompatibleDC(hdcWindow);

    SelectObject(hdcMemory, hBitmap);

    //
    // Retrieve the color table (if there is one) and create a palette
    // that reflects it.
    //
    if (GetDIBColorTable(hdcMemory, 0, 256, rgbq)) {
        hPalette = CreatePaletteFromRGBQUAD(rgbq, 256);
    } else {
        hPalette = CreateSpectrumPalette();
    }

    //
    // Select and realize the palette into our window DC.
    //
    SelectPalette(hdcWindow, hPalette, FALSE);
    RealizePalette(hdcWindow);

    //
    // Display the bitmap.
    //
    SetStretchBltMode(hdcWindow, COLORONCOLOR);
    StretchBlt(hdcWindow,
               0,
               0,
               rect.right,
               rect.bottom,
               hdcMemory,
               0,
               0,
               bm.bmWidth,
               bm.bmHeight,
               SRCCOPY);

    //
    // Clean up our objects.
    //
    DeleteDC(hdcMemory);
    DeleteObject(hBitmap);
    ReleaseDC(hWnd, hdcWindow);
    DeleteObject(hPalette);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by demoapp.rc
//
#define IDC_RESUME                      1
#define IDC_WELCOME_NEXT                1
#define IDS_NOT_WIN95                   1
#define IDC_EXIT_RESUME                 1
#define IDC_FINISH                      1
#define IDC_README_NEXT                 1
#define IDC_EXIT_SETUP                  2
#define IDC_COPYFILES_CANCEL            2
#define IDC_EXTRACT_CANCEL              2
#define IDC_EXIT_EXIT                   2
#define IDS_NO_PRINT_DC                 2
#define IDS_ABORT_PROC                  3
#define IDS_NO_PRINTER                  4
#define IDS_NO_DISK_SPACE               5
#define IDS_REG_DELETE                  6
#define IDS_NO_PROG_FILES               7
#define IDS_DIR_CREATE_FAIL             8
#define IDC_WELCOME_CANCEL              9
#define IDS_NO_PROGRAMS                 9
#define IDS_SAVE_FAILED                 10
#define IDS_CANT_UNDO                   11
#define IDC_WELCOME_BACK                12
#define IDC_FINAL_BACK                  12
#define IDC_README_BACK                 12
#define IDS_THANKS                      12
#define IDS_NO_EXTRACT_DLG              13
#define IDS_DEMO_ONLY                   14
#define IDS_REG_SAVE                    15
#define IDS_LUA_SAVE_FAILED             16
#define IDS_SAVE_FILTER                 17
#define IDS_BUFFER_ALLOC_FAIL           18
#define IDS_FILE_CREATE_FAIL            19
#define IDS_NOT_INSECURE                20
#define IDS_EXTRACTION                  21
#define IDI_APPICON                     101
#define IDM_MAIN_MENU                   102
#define IDB_SETUP                       103
#define IDI_SETUP_APPICON               104
#define IDB_SPLASH                      105
#define IDB_W2K_SPLASH                  105
#define IDB_SPLASH_256                  106
#define IDB_W2K_SPLASH_256              106
#define IDD_DISKSPACE                   107
#define IDD_CHECK_INSTALL               108
#define IDB_XP_SPLASH                   111
#define IDB_XP_SPLASH_256               112
#define IDR_VERSION_EXE                 113
#define IDT_WELCOME_TEXT                202
#define IDT_EXIT_PROGS_TEXT             258
#define IDT_COPYRIGHT_TEXT              259
#define IDT_LEGAL_TEXT                  260
#define IDT_CANCEL_TEXT                 261
#define IDR_VIEW_README                 501
#define IDR_RESTART_WIN                 501
#define IDR_LAUNCH                      502
#define IDR_RESTART_NOW                 502
#define IDR_RESTART_LATER               503
#define IDT_READY_TEXT                  1000
#define IDT_READY_TEXT2                 1001
#define IDC_READY_NEXT                  1002
#define IDC_READY_BACK                  1003
#define IDC_READY_CANCEL                1004
#define IDP_FRAME                       1300
#define IDT_COPY_LABEL                  1400
#define IDT_COPY_PROG                   1450
#define IDC_PROGRESS                    1500
#define IDC_EXTRACT_PROG                1500
#define IDD_WELCOME                     10205
#define IDD_READYTO_COPY                10206
#define IDD_EXIT                        10300
#define IDD_EXTRACT                     10301
#define IDD_COPYFILES                   10313
#define IDD_REBOOT                      12031
#define IDD_README                      12032
#define IDM_FILE_EXIT                   40001
#define IDM_HELP_ABOUT                  40002
#define IDM_FILE_NEW                    40003
#define IDM_FILE_OPEN                   40004
#define IDM_FILE_SAVE                   40005
#define IDM_FILE_SAVEAS                 40006
#define IDM_FILE_PAGE_SETUP             40007
#define IDM_FILE_PRINT                  40008
#define IDM_EDIT_UNDO                   40009
#define IDM_EDIT_CUT                    40010
#define IDM_FILE_COPY                   40011
#define IDM_EDIT_COPY                   40011
#define IDM_EDIT_PASTE                  40012
#define IDM_EDIT_DELETE                 40013
#define IDM_EDIT_FIND                   40014
#define IDM_EDIT_FIND_NEXT              40015
#define IDM_EDIT_REPLACE                40016
#define IDM_EDIT_GOTO                   40017
#define IDM_EDIT_SELECT_ALL             40018
#define IDM_EDIT_TIME_DATE              40019
#define IDM_FORMAT_WORD_WRAP            40020
#define IDM_FORMAT_FONT                 40021
#define IDM_HELP_TOPICS                 40022
#define IDT_1STLEVEL                    65535
#define IDT_2NDLEVEL                    65535
#define IDT_3RDLEVEL                    65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40023
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\winmain.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Winmain.cpp

  Abstract:

    Implements the entry point for the application.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/
#include "demoapp.h"

//
// This structure contains everything we'll need throughout
// the application.
//
APPINFO g_ai;

/*++

  Routine Description:

    Application entry point.

  Arguments:

    hInstance       -    App instance handle.
    hPrevInstance   -    Always NULL.
    lpCmdLine       -    Pointer to the command line.
    nCmdShow        -    Window show flag.

  Return Value:

    The wParam member of the message structure.   

--*/
int 
APIENTRY
WinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPSTR     lpCmdLine,
    IN int       nCmdShow
    )
{
    MSG     msg;
    HWND    hWnd;
    HANDLE  hThread;
    char    szError[MAX_PATH];
    UINT    threadId = 0;    
    
    g_ai.hInstance = hInstance; 
    
    //
    // Do some init stuff.
    //
    if (!DemoAppInitialize(lpCmdLine)) {
        return 0;
    }

    //
    // Determine if we should run the normal app or the setup app.
    //
    if (g_ai.fRunApp) {
        // 
        // Create the main window and kick off the message loop.
        // 
        if (!InitMainApplication(hInstance)) {
            return 0;
        }

        if (!InitMainInstance(hInstance, nCmdShow)) {
            return 0;
        }
    } else {

        LoadString(g_ai.hInstance, IDS_DEMO_ONLY, szError, sizeof(szError));
        MessageBox(NULL,
                   szError,
                   MAIN_APP_TITLE,
                   MB_TOPMOST | MB_ICONEXCLAMATION);

        //
        // Create a thread to handle the splash screen and the extraction
        // dialog.
        // 
        hThread = (HANDLE)_beginthreadex(NULL,
                                         0,
                                         &InitSetupThread,
                                         NULL,
                                         0,
                                         &threadId);
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);

        //
        // If we're allowed, perform our version check!!!!
        //
        if (g_ai.fEnableBadFunc) {
            if (!BadIsWindows95()) {
                LoadString(g_ai.hInstance, IDS_NOT_WIN95, szError, sizeof(szError));
                MessageBox(NULL,
                           szError,
                           0,
                           MB_ICONERROR | MB_TOPMOST);
                return 0;
            }
        }

        //
        // Create our full screen window and paint the background teal.
        //
        hWnd = CreateFullScreenWindow();

        if (!hWnd) {
            return 0;
        }        

    }

    while (GetMessage(&msg, (HWND)NULL, 0, 0)) {
        if (!IsDialogMessage(hWnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\demoapp\exe\setup.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Setup.cpp

  Abstract:

    Displays the splash screen and runs the message loop
    for the setup app.

  Notes:

    ANSI only - must run on Win9x.

  History:

    01/30/01    rparsons    Created
    01/10/02    rparsons    Revised

--*/
#include "demoapp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Thread callback procedure.

  Arguments:

    None.

  Return Value:

    0 on failure.

--*/
UINT 
InitSetupThread(
    IN void* pArguments
    )
{
    MSG         msg;
    CSplash     splash;
    HWND        hDlg;
    HINSTANCE   hInstance;
    HRESULT     hr;
    char        szError[MAX_PATH];
    char        szDll[MAX_PATH];
    const char  szDemoDll[] = "demodll.dll";

    hr = StringCchPrintf(szDll,
                         sizeof(szDll),
                         "%hs\\%hs",
                         g_ai.szCurrentDir,
                         szDemoDll);

    if (FAILED(hr)) {
        return 0;
    }

    //
    // If the load fails, keep going. This just means we won't
    // show a splash screen to the user.
    //
    hInstance = LoadLibrary(szDll);

    if (g_ai.fWinXP) {
        //
        // Display the XP splash screen.
        //
        splash.Create(hInstance,
                      IDB_XP_SPLASH_256,
                      IDB_XP_SPLASH,
                      5);
    } else {
        //
        // Display the W2K splash screen.
        //
        splash.Create(hInstance,
                      IDB_W2K_SPLASH_256,
                      IDB_W2K_SPLASH,
                      5);
    }

    if (hInstance) {
        FreeLibrary(hInstance);
    }

    hDlg = CreateExtractionDialog(g_ai.hInstance);

    if (!hDlg) {
        LoadString(g_ai.hInstance, IDS_NO_EXTRACT_DLG, szError, sizeof(szError));
        MessageBox(NULL, szError, 0, MB_ICONERROR);
        return 0;
    }
    
    while (GetMessage(&msg, (HWND)NULL, 0, 0)) {
        if (!IsDialogMessage(hDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    _endthreadex(0);

    return (int)msg.wParam;
}

/*++

  Routine Description:

    Creates our full screen window.

  Arguments:

    None.

  Return Value:

    The window handle on success, NULL on failure.

--*/
HWND
CreateFullScreenWindow(
    void
    )
{
    WNDCLASS    wc;
    ATOM        aClass = NULL;
    RECT        rcDesktop;
    HBRUSH      hBrush;

    hBrush = CreateSolidBrush(RGB(0,80,80));

    wc.style          = CS_NOCLOSE;
    wc.lpfnWndProc    = SetupWndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;
    wc.hInstance      = g_ai.hInstance;
    wc.hIcon          = LoadIcon(g_ai.hInstance, MAKEINTRESOURCE(IDI_SETUP_APPICON));
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)hBrush; // teal
    wc.lpszMenuName   = NULL;
    wc.lpszClassName  = SETUP_APP_CLASS;

    aClass = RegisterClass(&wc);

    if (!aClass) {
        goto exit;
    }

    GetWindowRect(GetDesktopWindow(), &rcDesktop);

    g_ai.hWndMain = CreateWindowEx(0,
                                   SETUP_APP_CLASS,
                                   SETUP_APP_TITLE,
                                   WS_OVERLAPPEDWINDOW,
                                   0,
                                   0,
                                   rcDesktop.right - 15,
                                   rcDesktop.bottom - 15,
                                   NULL,
                                   NULL,
                                   g_ai.hInstance,
                                   NULL);
exit:
    
    DeleteObject(hBrush);

    return g_ai.hWndMain;
}

/*++

  Routine Description:

    Runs the message loop for main window.

  Arguments:

    hWnd        -    Window handle.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if the message was processed, FALSE otherwise.

--*/
LRESULT
CALLBACK
SetupWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{

    switch (uMsg) {
    case WM_CREATE:

        ShowWindow(hWnd, SW_SHOWMAXIMIZED);
        UpdateWindow(hWnd);

        //
        // Welcome dialog.
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_WELCOME),
                  hWnd,
                  WelcomeDialogProc);

        if (g_ai.fClosing) {
            break;
        }

        //
        // Checking for installed components dialog.
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_CHECK_INSTALL),
                  hWnd,
                  CheckComponentDialogProc);
        
        if (g_ai.fClosing) {
            break;
        }

        //
        // Checking for free disk space dialog.
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_DISKSPACE),
                  hWnd,
                  CheckFreeDiskSpaceDialogProc);
        
        if (g_ai.fClosing) {
            break;
        }

        //
        // Ready to copy files dialog
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_READYTO_COPY),
                  hWnd,
                  ReadyToCopyDialogProc);

        if (g_ai.fClosing) {
            break;
        }

        //
        // Copying files progress dialog.
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_COPYFILES),
                  hWnd,
                  CopyFilesDialogProc);

        if (g_ai.fClosing) {
            break;
        }

        //
        // Create the shortcuts - even the bad one.
        //
        CreateShortcuts(hWnd);

        //
        // Readme dialog.
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_README),
                  hWnd,
                  ViewReadmeDialogProc);

        if (g_ai.fClosing) {
            break;
        }

        //
        // Reboot dialog.
        //
        DialogBox(g_ai.hInstance,
                  MAKEINTRESOURCE(IDD_REBOOT),
                  hWnd,
                  RebootDialogProc);
            
        break;
    
    case WM_DESTROY:
    
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\grabmi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by grabmi.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\dumpsdb\dumpsdb.cpp ===
/*--

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dumpsdb.c

Abstract:

    code for a dump tool for shim db files

Author:

    dmunsil 02/02/2000

Revision History:

Notes:

    This program dumps a text representation of all of the data in a shim db file.

--*/

#define _UNICODE

#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _WINDOWS
#include <windows.h>
#include <stdio.h>

extern "C" {
#include "shimdb.h"
}


BOOL bDumpDB(PDB pdb, TAGID tiParent, WCHAR *szIndent, BOOL bWithTagIDs);
BOOL bGetTypeName(TAG tWhich, WCHAR *szName);

HANDLE  g_hOutputFile = INVALID_HANDLE_VALUE;
WCHAR*  g_pszOutputBuffer = NULL;
int     g_cbOutputBufferSize = 0;

int _cdecl Output(const WCHAR * fmt, ...)
{
    int cch = 0;
    va_list arglist;
    DWORD dwBytesWritten = 0;
    WCHAR* psz;
    WCHAR CRLF[2] = { 0x000D, 0x000A };

    if (g_hOutputFile != INVALID_HANDLE_VALUE) {
        va_start(arglist, fmt);
        cch = _vscwprintf(fmt, arglist);

        if ((cch + 1) * 2 > g_cbOutputBufferSize) {
            if (g_pszOutputBuffer) {
                LocalFree(g_pszOutputBuffer);
            }

            g_pszOutputBuffer = (WCHAR *) LocalAlloc(0, (cch + 1) * sizeof(WCHAR) * 2);
            
            if (g_pszOutputBuffer == NULL) {
                return 0;
            }

            g_cbOutputBufferSize = (cch + 1) * sizeof(WCHAR) * 2;
        }

        cch = _vsnwprintf(g_pszOutputBuffer, g_cbOutputBufferSize / sizeof(WCHAR), fmt, arglist);

        psz = g_pszOutputBuffer;
        while (*psz) {
            if (*psz == L'\n') {
                if (!WriteFile(g_hOutputFile, CRLF, 4, &dwBytesWritten, NULL)) {
                    return 0;
                }
            } else {
                if (!WriteFile(g_hOutputFile, psz, 2, &dwBytesWritten, NULL)) {
                    return 0;
                }
            }

            psz++;
        }

        va_end(arglist);
    } else {
        va_start(arglist, fmt);
        cch = vwprintf(fmt, arglist);
        va_end(arglist);
    }

    return cch;
}

extern "C" int __cdecl wmain(int argc, wchar_t *argv[])
{
    PDB    pdb = NULL;
    int    nReturn = 1;
    DWORD  dwMajor = 0, dwMinor = 0;
    LPWSTR szDB = NULL;
    LPWSTR szOutputFileName = NULL;

    BOOL bSuccess;
    BOOL bWithTagIDs = TRUE;

    WCHAR szIndent[500];
    WCHAR szArg[500];

    if (argc < 2 || (argv[1][1] == '?')) {
        Output(L"Usage:\n\n");
        Output(L"      dumpsdb [-d] foo.sdb > foo.txt     (dumps to console)\n\n");
        Output(L"or    dumpsdb [-d] foo.sdb -o foo.txt    (dumps to unicode file)\n\n");
        Output(L"   -d switch formats output to faciliate differencing of two output files.\n");
        return 1;
    }

    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '/' || argv[i][0] == '-') {
            if (argv[i][1] == 'd' || argv[i][1] == 'D') {
                bWithTagIDs = FALSE;
            } else if (argv[i][1] == 'o' || argv[i][1] == 'O') {
                szOutputFileName = argv[++i];
            }
        } else {
            szDB = argv[i];
        }
    }

    if (szOutputFileName) {
        g_hOutputFile = CreateFileW(
            szOutputFileName,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (g_hOutputFile == INVALID_HANDLE_VALUE) {
            LPVOID lpMsgBuf;
            FormatMessageW( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &lpMsgBuf,
                0,
                NULL 
            );
            wprintf(L"\n\nError creating output file:\n\n%s\n", lpMsgBuf);
            LocalFree(lpMsgBuf);
            goto eh;
        }

        BYTE BOM[2] = {0xFF, 0xFE};
        DWORD dwBytesWritten;
        if (!WriteFile(g_hOutputFile, BOM, 2, &dwBytesWritten, NULL)) {
            LPVOID lpMsgBuf;
            FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR) &lpMsgBuf,
                0,
                NULL 
            );
            wprintf(L"\n\nError writing byte-order-marker:\n\n%s\n", lpMsgBuf);
            LocalFree(lpMsgBuf);
            goto eh;
        }
    }

    // Open the DB.
    pdb = SdbOpenDatabase(szDB, DOS_PATH);

    if (pdb == NULL) {
        nReturn = 1;
        wprintf(L"Error: can't open DB \"%s\"\n", szDB);
        goto eh;
    }

    SdbGetDatabaseVersion(szDB, &dwMajor, &dwMinor);

    Output(L"Dumping DB \"%s. Version %d.%d.\"\n",
            szDB,
            dwMajor,
            dwMinor);

    wcscpy(szIndent, L"");

    bSuccess = bDumpDB(pdb, TAGID_ROOT, szIndent, bWithTagIDs);

    nReturn = 0;
eh:

    if (pdb) {
        Output(L"Closing DB.\n");
        SdbCloseDatabase(pdb);
    }

    if (g_hOutputFile != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hOutputFile);
    }

    return nReturn;
}

BOOL bGetTypeName(TAG tWhich, WCHAR *szName)
{
    DWORD i;

    LPCWSTR pName = SdbTagToString(tWhich);
    if (NULL != pName) {
        wcscpy(szName, pName);
        return TRUE;
    }

    swprintf(szName, L"!unknown_tag!");

    return TRUE;
}

BOOL bDumpDB(PDB pdb, TAGID tiParent, WCHAR *szIndent, BOOL bWithTagIDs)
{
    TAGID tiTemp;
    WCHAR szTemp[200];
    WCHAR szNewIndent[200];


    tiTemp = SdbGetFirstChild(pdb, tiParent);
    while (tiTemp) {
        TAG tWhich;
        TAG_TYPE ttType;
        DWORD dwData;
        LARGE_INTEGER liData;
        WCHAR szData[1000];

        tWhich = SdbGetTagFromTagID(pdb, tiTemp);
        if (!tWhich) {
            //
            // error
            //
            Output(L"Error: Can't get tag for TagID 0x%8.8X. Corrupt file.\n", tiTemp);
            break;
        }

        ttType = GETTAGTYPE(tWhich);

        if (!bGetTypeName(tWhich, szTemp)) {
            Output(L"Error getting Tag name. Tag: 0x%4.4X\n", (DWORD)tWhich);
            return FALSE;
        }

        if (bWithTagIDs) {
            Output(L"%s0x%8.8X | 0x%4.4X | %-13s ", szIndent, tiTemp, tWhich, szTemp);
        } else {
            Output(L"%s%-13s ", szIndent, szTemp);

            if (wcsstr(szTemp, L"_TAGID")) {
                Output(L"\n");
                tiTemp = SdbGetNextChild(pdb, tiParent, tiTemp);
                continue;
            }
        }

        switch (ttType) {
        case TAG_TYPE_NULL:
            Output(L" | NULL |\n");
            break;

        case TAG_TYPE_BYTE:
            dwData = SdbReadBYTETag(pdb, tiTemp, 0);
            Output(L" | BYTE | 0x%2.2X\n", dwData);
            break;

        case TAG_TYPE_WORD:
            dwData = SdbReadWORDTag(pdb, tiTemp, 0);
            if (tWhich == TAG_INDEX_KEY || tWhich == TAG_INDEX_TAG) {

                // for index tags and keys, we'd like to see what the names are
                if (!bGetTypeName((TAG)dwData, szTemp)) {
                    Output(L"Error getting Tag name. Tag: 0x%4.4X\n", dwData);
                    return FALSE;
                }
                Output(L" | WORD | 0x%4.4X (%s)\n", dwData, szTemp);
            } else {
                Output(L" | WORD | 0x%4.4X\n", dwData);
            }
            break;

        case TAG_TYPE_DWORD:
            dwData = SdbReadDWORDTag(pdb, tiTemp, 0);
            Output(L" | DWORD | 0x%8.8X\n", dwData);
            break;

        case TAG_TYPE_QWORD:
            liData.QuadPart = SdbReadQWORDTag(pdb, tiTemp, 0);
            Output(L" | QWORD | 0x%8.8X%8.8X\n", liData.HighPart, liData.LowPart);
            break;

        case TAG_TYPE_STRINGREF:
            if (!SdbReadStringTag(pdb, tiTemp, szData, ARRAYSIZE(szData))) {
                wcscpy(szData, L"(error)");
            }
            Output(L" | STRINGREF | %s\n", szData);
            break;

        case TAG_TYPE_STRING:
            dwData = SdbGetTagDataSize(pdb, tiTemp);
            if (!SdbReadStringTag(pdb, tiTemp, szData, ARRAYSIZE(szData))) {
                wcscpy(szData, L"(error)");
            }
            Output(L" | STRING | Size 0x%8.8X | %s\n", dwData, szData);
            break;

        case TAG_TYPE_BINARY:
            dwData = SdbGetTagDataSize(pdb, tiTemp);
            Output(L" | BINARY | Size 0x%8.8X", dwData);
            switch(tWhich) {
            case TAG_INDEX_BITS:
               {
                  char szKey[9];
                  DWORD dwRecords;
                  INDEX_RECORD *pRecords;
                  DWORD i;

                  Output(L"\n");
                  ZeroMemory(szKey, 9);
                  dwRecords = dwData / sizeof(INDEX_RECORD);
                  pRecords = (INDEX_RECORD *)SdbGetBinaryTagData(pdb, tiTemp);
                  for (i = 0; i < dwRecords; ++i) {
                     char *szRevKey;
                     int j;

                     szRevKey = (char *)&pRecords[i].ullKey;
                     for (j = 0; j < 8; ++j) {
                         szKey[j] = isprint(szRevKey[7-j]) ? szRevKey[7-j] : '.';
                     }
                     if (bWithTagIDs) {
                         Output(L"%s   Key: 0x%I64X (\"%-8S\"), TAGID: 0x%08X\n",
                             szIndent, pRecords[i].ullKey, szKey, pRecords[i].tiRef);
                     } else {
                         Output(L"%s   Key: 0x%I64X (\"%-8S\")\n",
                             szIndent, pRecords[i].ullKey, szKey);
                     }
                  }
               }
               break;
            case TAG_EXE_ID:
            case TAG_MSI_PACKAGE_ID:
            case TAG_DATABASE_ID:
               // this is exe id -- which happens to be GUID which we do understand
               {
                  GUID *pGuid;
                  UNICODE_STRING sGuid;

                  pGuid = (GUID*)SdbGetBinaryTagData(pdb, tiTemp);

                  // convert this thing to string
                  if (pGuid && NT_SUCCESS(RtlStringFromGUID(*pGuid, &sGuid))) {
                     Output(L" | %s", sGuid.Buffer);
                     RtlFreeUnicodeString(&sGuid);
                  }

                  Output(L"\n");
               }
               break;

            default:
               Output(L"\n");
               break;
            }
            break;

        case TAG_TYPE_LIST:
            dwData = SdbGetTagDataSize(pdb, tiTemp);
            Output(L" | LIST | Size 0x%8.8X\n", dwData);
            wcscpy(szNewIndent, szIndent);
            wcscat(szNewIndent, L"  ");
            bDumpDB(pdb, tiTemp, szNewIndent, bWithTagIDs);
            Output(L"%s-end- %s\n", szIndent, szTemp);
            break;

        default:
            dwData = SdbGetTagDataSize(pdb, tiTemp);
            Output(L" | UNKNOWN | Size 0x%8.8X\n", dwData);
            break;
        }

        tiTemp = SdbGetNextChild(pdb, tiParent, tiTemp);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\fcopy\fcopy.cpp ===
#include "windows.h"
#include <stdio.h>

BOOL
ForceCopy(
    LPCSTR lpszSourceFileName,
    LPCSTR lpszDestFileName
    )
/*++

  Params: lpszSourceFileName   Pointer to the source file.
          lpzDestFileName      Pointer to the destination file.

  Return: TRUE on success, FALSE otherwise.

  Desc:   Attempts to copy a file. If it's in use, move it and replace on reboot.

--*/
{
    char szTempPath[MAX_PATH];
    char szDelFileName[MAX_PATH];

    if (!CopyFileA(lpszSourceFileName, lpszDestFileName, FALSE)) {

        if (GetTempPathA(MAX_PATH, szTempPath) == 0) {
            printf("GetTempPath failed with 0x%x\n", GetLastError());
            return FALSE;
        }

        if (GetTempFileNameA(szTempPath, "DEL", 0, szDelFileName) == 0) {
            printf("GetTempFileName failed with 0x%x\n", GetLastError());
            return FALSE;
        }

        if (!MoveFileExA(lpszDestFileName, szDelFileName, MOVEFILE_REPLACE_EXISTING)) {
            printf("MoveFileEx failed with 0x%x\n", GetLastError());
            return FALSE;
        }

        if (!MoveFileExA(szDelFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
            printf("MoveFileEx failed with 0x%x\n", GetLastError());
            return FALSE;
        }

        if (!CopyFileA(lpszSourceFileName, lpszDestFileName, FALSE)) {
            printf("CopyFile failed with 0x%x\n", GetLastError());
            return FALSE;
        }
    }

    return TRUE;
}

int __cdecl
main(
    int   argc,
    CHAR* argv[]
    )
{
    int cchLen;

    if (argc != 3) {
        printf("Usage: fcopy SourceFile DestFile\n");
        return 0;
    }

    cchLen = lstrlen(argv[1]);

    if (cchLen > MAX_PATH) {
        printf("Source file path too long\n");
        return 0;
    }

    cchLen = lstrlen(argv[2]);

    if (cchLen > MAX_PATH) {
        printf("Dest file path too long\n");
        return 0;
    }

    return ForceCopy(argv[1], argv[2]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\grabmi\grabmi.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Grabmi.cpp

  Abstract:

    Contains the entry point & core code for the application.

  Notes:

    ANSI & Unicode via TCHAR - runs on Win9x/NT/2K/XP etc.

  History:

    07/18/00    jdoherty    Created
    12/16/00    jdoherty    Modified to use SDBAPI routines
    12/29/00    prashkud    Modified to take space in the filepath
    01/23/02    rparsons    Re-wrote existing code
    02/19/02    rparsons    Implemented strsafe functions

--*/
#include "grabmi.h"

//
// This structure contains all the data we'll need to access
// throughout the application.
//
APPINFO g_ai;

/*++

  Routine Description:

    Prints a formatted string to the debugger.

  Arguments:

    dwDetail    -   Specifies the level of the information provided.
    pszFmt      -   The string to be displayed.
    ...         -   A va_list of insertion strings.

  Return Value:

    None.

--*/
void
__cdecl
DebugPrintfEx(
    IN DEBUGLEVEL dwDetail,
    IN LPSTR      pszFmt,
    ...
    )
{
    char    szT[1024];
    va_list arglist;
    int     len;

    va_start(arglist, pszFmt);

    //
    // Reserve one character for the potential '\n' that we may be adding.
    //
    StringCchVPrintfA(szT, sizeof(szT) - 1, pszFmt, arglist);

    va_end(arglist);

    //
    // Make sure we have a '\n' at the end of the string
    //
    len = strlen(szT);

    if (len > 0 && szT[len - 1] != '\n')  {
        szT[len] = '\n';
        szT[len + 1] = 0;
    }

    switch (dwDetail) {
    case dlPrint:
        OutputDebugString("[MSG ] ");
        break;

    case dlError:
        OutputDebugString("[FAIL] ");
        break;

    case dlWarning:
        OutputDebugString("[WARN] ");
        break;

    case dlInfo:
        OutputDebugString("[INFO] ");
        break;

    default:
        OutputDebugString("[XXXX] ");
        break;
    }

    OutputDebugString(szT);
}

/*++

  Routine Description:

    Displays command-line syntax to the user.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
DisplayUsage(
    void
    )
{
    _tprintf(_T("Microsoft(R) Windows(TM) Grab Matching Information\n"));
    _tprintf(_T("Copyright (C) Microsoft Corporation. All rights reserved.\n"));

    _tprintf(_T("\nGrabMI can be used in one of the following ways:\n")
                        _T(" *** The following flags can be used with other flags:\n")
                        _T("     -f, -a, -n, and -h \n")
                        _T("     otherwise the last flag specified will be used.\n")
                        _T(" *** If no arguments are provided, matching information will be\n")
                        _T("     extracted from the current directory.\n\n")
                        _T("   grabmi [path to start generating info ie. c:\\progs]\n")
                        _T("      Grabs matching information from the path specified. Limits the\n")
                        _T("      information gathered to 10 miscellaneous files per directory,\n")
                        _T("      and includes all files with extensions .icd, .exe, .dll,\n")
                        _T("      .msi, ._mp. If a path is not specified, the directory that GrabMI\n")
                        _T("      was executed from is used.\n\n")
                        _T("   grabmi [-d]\n")
                        _T("      Grabs matching information from %%windir%%\\system32\\drivers.\n")
                        _T("      The format of the information is slightly different in this case\n")
                        _T("      and only information for *.sys files will be grabbed.\n\n")
                        _T("   grabmi [-f drive:\\filename.txt]\n")
                        _T("      The matching information is stored in a file specified by the user.\n")
                        _T("      If a full path is not specified and the -d flag is used, the file\n")
                        _T("      is stored in the %%windir%%\\system(32) directory. Otherwise, the file\n")
                        _T("      is stored in the directory that GrabMI was executed from.\n\n")
                        _T("   grabmi [-h or -?]\n")
                        _T("      Displays this help.\n\n")
                        _T("   grabmi [-o]\n")
                        _T("      Grabs information for the file specified.  If a file was not specified,\n")
                        _T("      the call will fail.  If the destination file exists, then the information\n")
                        _T("      will be concatenated to the end of the existing file.\n\n")
                        _T("   grabmi [-p]\n")
                        _T("      Grabs information for files with .icd, .exe, .dll, .msi, ._mp extensions\n")
                        _T("      only.\n\n")
                        _T("   grabmi [-q]\n")
                        _T("      Grabs matching information and does not display the file when completed.\n\n")
                        _T("   grabmi [-s]\n")
                        _T("      Grabs information for the following system files:\n")
                        _T("      advapi32.dll, gdi32.dll, ntdll.dll, kernel32.dll, winsock.dll\n")
                        _T("      ole32.dll, oleaut32.dll, shell32.dll, user32.dll, and wininet.dll\n\n")
                        _T("   grabmi [-v]\n")
                        _T("      Grabs matching information for all files. \n\n")
                        _T("   grabmi [-a]\n")
                        _T("      Appends new matching information to the existing matching\n")
                        _T("      information file. \n\n")
                        _T("   grabmi [-n]\n")
                        _T("      Allows to more information to be appended the file later (see -a). \n"));
}

/*++

  Routine Description:

    Initializes the application. Saves away common paths
    and other useful items for later.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
InitializeApplication(
    void
    )
{
    DWORD           cchReturned;
    UINT            cchSize;
    TCHAR*          pszTemp = NULL;
    OSVERSIONINFO   osvi;

    //
    // Initialize our defaults, determine where we're running
    // from, and get the version of the OS we're on.
    //
    *g_ai.szOutputFile = 0;
    *g_ai.szGrabPath   = 0;
    g_ai.dwFilter      = GRABMI_FILTER_NORMAL;
    g_ai.fDisplayFile  = TRUE;

    g_ai.szCurrentDir[ARRAYSIZE(g_ai.szCurrentDir) - 1] = 0;
    cchReturned = GetModuleFileName(NULL,
                                    g_ai.szCurrentDir,
                                    ARRAYSIZE(g_ai.szCurrentDir));

    if (g_ai.szCurrentDir[ARRAYSIZE(g_ai.szCurrentDir) - 1] != 0 ||
        cchReturned == 0) {
        DPF(dlError,
            "[InitializeApplication] 0x%08X Failed to get module filename",
            GetLastError());
        return FALSE;
    }

    pszTemp = _tcsrchr(g_ai.szCurrentDir, '\\');

    if (pszTemp) {
        *pszTemp = 0;
    }

    cchSize = GetSystemDirectory(g_ai.szSystemDir, ARRAYSIZE(g_ai.szSystemDir));

    if (cchSize > ARRAYSIZE(g_ai.szSystemDir) || cchSize == 0) {
        DPF(dlError,
            "[InitializeApplication] 0x%08X Failed to get system directory",
            GetLastError());
        return FALSE;
    }

    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&osvi)) {
        DPF(dlError,
            "[InitializeApplication] 0x%08X Failed to get version info",
            GetLastError());
        return FALSE;
    }

    //
    // Determine if we should use apphelp.dll, sdbapiu.dll, or sdbapi.dll.
    //
    if (osvi.dwMajorVersion >= 5 && osvi.dwMinorVersion >= 1) {
        //
        // Apphelp.dll is available on XP.
        //
        g_ai.dwLibraryFlags = GRABMI_FLAG_APPHELP;
    } else if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {
        //
        // Apphelp.dll is not available on Windows 2000, use sdbapiu.dll.
        //
        g_ai.dwLibraryFlags = GRABMI_FLAG_NT;
    } else {
        //
        // Downlevel platforms should use sdbapi.dll.
        //
        g_ai.dwLibraryFlags = 0;
    }

    return TRUE;
}

/*++

  Routine Description:

    Parses the command-line to determine our mode of operation.

  Arguments:

    argc    -   Number command-line of arguments provided by the user.
    argv[]  -   An array of command-line arguments.

  Return Value:

    TRUE if valid arguments were provided, FALSE otherwise.

--*/
BOOL
ParseCommandLine(
    IN int    argc,
    IN TCHAR* argv[]
    )
{
    int     nCount = 1;
    HRESULT hr;

    if (argc == 1) {
        return TRUE;
    }

    //
    // The first argument should be our starting directory.
    //
    if ((argv[nCount][0] != '-') && (argv[nCount][0] != '/')) {
        hr = StringCchCopy(g_ai.szGrabPath,
                           ARRAYSIZE(g_ai.szGrabPath),
                           argv[nCount]);

        if (FAILED(hr)) {
            DPF(dlError, "[ParseCommandLine] Buffer too small (1)");
            return FALSE;
        }
    }

    for (nCount = 1; nCount < argc; nCount++) {
      if ((argv[nCount][0] == '-') || (argv[nCount][0] == '/')) {
          switch (argv[nCount][1]) {

          case '?':
          case 'H':
          case 'h':
              return FALSE;

          case 'F':
          case 'f':
              //
              // Do a little work to figure out if a file was specified.
              //
              if (nCount < argc - 1) {
                  if ((argv[nCount + 1][0] == '-') || (argv[nCount + 1][0] == '/')) {
                      return FALSE;
                  } else {
                      //
                      // Grab the specified path.
                      //
                      hr = StringCchCopy(g_ai.szOutputFile,
                                         ARRAYSIZE(g_ai.szOutputFile),
                                         argv[nCount + 1]);

                      if (FAILED(hr)) {
                          DPF(dlError, "[ParseCommandLine] Buffer too small (2)");
                          return FALSE;
                      }
                  }
              }
              break;

          case 'D':
          case 'd':
              g_ai.dwFilter = GRABMI_FILTER_DRIVERS;
              break;

          case 'O':
          case 'o':
              g_ai.dwFilter = GRABMI_FILTER_THISFILEONLY;
              break;

          case 'V':
          case 'v':
              g_ai.dwFilter = GRABMI_FILTER_VERBOSE;
              break;

          case 'Q':
          case 'q':
              g_ai.fDisplayFile = FALSE;
              break;

          case 'P':
          case 'p':
              g_ai.dwFilter = GRABMI_FILTER_PRIVACY;
              break;

          case 'S':
          case 's':
              g_ai.dwFilter = GRABMI_FILTER_SYSTEM;
              break;

          case 'A':
          case 'a':
              g_ai.dwFilterFlags |= GRABMI_FILTER_APPEND;
              break;

          case 'N':
          case 'n':
              g_ai.dwFilterFlags |= GRABMI_FILTER_NOCLOSE;
              break;

          default:
              return FALSE;
          }
      }
    }

    return TRUE;
}

/*++

  Routine Description:

    Displays a home-grown "progress bar" to inform the user that
    the application is working.

  Arguments:

    See below.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CALLBACK
_GrabmiCallback(
    IN LPVOID    lpvCallbackParam,  // application-defined parameter
    IN LPCTSTR   lpszRoot,          // root directory path
    IN LPCTSTR   lpszRelative,      // relative path
    IN PATTRINFO pAttrInfo,         // attributes
    IN LPCWSTR   pwszXML            // resulting xml
    )
{
    static int State = 0;
    static TCHAR szIcon[] = _T("||//--\\\\");

    State = ++State % (ARRAYSIZE(szIcon) - 1);
    _tcprintf(_T("%c\r"), szIcon[State]);

    return TRUE;
}

/*++

  Routine Description:

    Obtains function pointers to the SDB APIs and makes the call
    that obtains the matching information.

  Arguments:

    pszOutputFile   -   Contains the path to the file we will save
                        the results to.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CallSdbAPIFunctions(
    IN LPCTSTR pszOutputFile
    )
{
    HMODULE hModule;
    BOOL    bResult = FALSE;
    TCHAR*  pszLibrary = NULL;
    TCHAR   szLibraryPath[MAX_PATH];
    WCHAR   wszGrabPath[MAX_PATH];
    WCHAR   wszOutputFile[MAX_PATH];
    HRESULT hr;

    PFNSdbGrabMatchingInfoExA   pfnSdbGrabMatchingInfoExA = NULL;
    PFNSdbGrabMatchingInfoExW   pfnSdbGrabMatchingInfoExW = NULL;

    if (!pszOutputFile) {
        DPF(dlError, "[CallSdbAPIFunctions] Invalid argument");
        return FALSE;
    }

    //
    // Attempt to load files from the current directory first.
    // If this fails, attempt to load from %windir%\system.
    // We don't call LoadLibrary without a full path because
    // it's a security risk.
    //
    switch (g_ai.dwLibraryFlags) {
    case GRABMI_FLAG_APPHELP:
        pszLibrary = APPHELP_LIBRARY;
        break;

    case GRABMI_FLAG_NT:
        pszLibrary = SDBAPIU_LIBRARY;
        break;

    default:
        pszLibrary = SDBAPI_LIBRARY;
        break;
    }

    hr = StringCchPrintf(szLibraryPath,
                         ARRAYSIZE(szLibraryPath),
                         "%s\\%s",
                         g_ai.szCurrentDir,
                         pszLibrary);

    if (FAILED(hr)) {
        DPF(dlError, "[CallSdbAPIFunctions] Buffer too small (1)");
        return FALSE;
    }

    hModule = LoadLibrary(szLibraryPath);

    if (!hModule) {
        DPF(dlWarning,
            "[CallSdbAPIFunctions] Attempt to load %s failed",
            szLibraryPath);

        //
        // Attempt to load from the system directory.
        //
        hr = StringCchPrintf(szLibraryPath,
                             ARRAYSIZE(szLibraryPath),
                             "%s\\%s",
                             g_ai.szSystemDir,
                             pszLibrary);

        if (FAILED(hr)) {
            DPF(dlError, "[CallSdbAPIFunctions] Buffer too small (2)");
            return FALSE;
        }

        hModule = LoadLibrary(szLibraryPath);

        if (!hModule) {
            DPF(dlError,
                "[CallSdbAPIFunctions] 0x%08X Attempt to load %s failed",
                GetLastError(),
                szLibraryPath);
            return FALSE;
        }
    }

    //
    // Get pointers to the functions that we'll be calling.
    //
    if (0 == g_ai.dwLibraryFlags) {
        pfnSdbGrabMatchingInfoExA =
            (PFNSdbGrabMatchingInfoExA)GetProcAddress(hModule, PFN_GMI);

        if (!pfnSdbGrabMatchingInfoExA) {
            DPF(dlError,
                "[CallSdbAPIFunctions] 0x%08X Failed to get Ansi function pointer",
                GetLastError());
            goto cleanup;
        }
    } else {
        pfnSdbGrabMatchingInfoExW =
            (PFNSdbGrabMatchingInfoExW)GetProcAddress(hModule, PFN_GMI);

        if (!pfnSdbGrabMatchingInfoExW) {
            DPF(dlError,
                "[CallSdbAPIFunctions] 0x%08X Failed to get Unicode function pointer",
                GetLastError());
            goto cleanup;
        }

    }

    //
    // If we're running on NT/W2K/XP, convert strings to Unicode before making
    // the function call.
    //
    if ((g_ai.dwLibraryFlags & GRABMI_FLAG_NT) ||
        (g_ai.dwLibraryFlags & GRABMI_FLAG_APPHELP)) {

        if (!MultiByteToWideChar(CP_ACP,
                                 0,
                                 g_ai.szGrabPath,
                                 -1,
                                 wszGrabPath,
                                 ARRAYSIZE(wszGrabPath))) {
            DPF(dlError,
                "[CallSdbAPIFunctions] 0x%08X Failed to convert %s",
                GetLastError(),
                g_ai.szGrabPath);
            goto cleanup;
        }

        if (!MultiByteToWideChar(CP_ACP,
                                 0,
                                 pszOutputFile,
                                 -1,
                                 wszOutputFile,
                                 ARRAYSIZE(wszGrabPath))) {
            DPF(dlError,
                "[CallSdbAPIFunctions] 0x%08X Failed to convert %s",
                GetLastError(),
                pszOutputFile);
            goto cleanup;
        }

    }

    if (0 == g_ai.dwLibraryFlags) {
        if (pfnSdbGrabMatchingInfoExA(g_ai.szGrabPath,
                                      g_ai.dwFilter | g_ai.dwFilterFlags,
                                      pszOutputFile,
                                      _GrabmiCallback,
                                      NULL) != GMI_SUCCESS) {
            DPF(dlError,
                "[CallSdbAPIFunctions] Failed to get matching information (Ansi)");
            goto cleanup;
        }
    } else {
        if (pfnSdbGrabMatchingInfoExW(wszGrabPath,
                                      g_ai.dwFilter | g_ai.dwFilterFlags,
                                      wszOutputFile,
                                      _GrabmiCallback,
                                      NULL) != GMI_SUCCESS) {
            DPF(dlError,
                "[CallSdbAPIFunctions] Failed to get matching information (Unicode)");
            goto cleanup;
        }
    }

    bResult = TRUE;

cleanup:

    FreeLibrary(hModule);

    return bResult;
}

/*++

  Routine Description:

    Displays the contents of the output file to the user.

  Arguments:

    pszOutputFile   -   Contains the path to the file we will show
                        to the user.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
DisplayOutputFile(
    IN LPTSTR pszOutputFile
    )
{
    const TCHAR szWrite[] = "write";
    const TCHAR szNotepad[] = "notepad";
    int         cchSize;
    TCHAR*      pszCmdLine = NULL;
    BOOL        bReturn;

    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    if (!pszOutputFile) {
        DPF(dlError, "[DisplayOuputFile] Invalid argument");
        return FALSE;
    }

    cchSize = _tcslen(pszOutputFile);
    cchSize += _tcslen(szNotepad);
    cchSize += 4; // space, two " marks, and a NULL

    pszCmdLine = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                   HEAP_ZERO_MEMORY,
                                   cchSize * sizeof(TCHAR));

    if (!pszCmdLine) {
        DPF(dlError, "[DisplayOutputFile] Failed to allocate memory");
        return FALSE;
    }

    StringCchPrintf(pszCmdLine,
                    cchSize,
                    "%s \"%s\"",
                    g_ai.dwLibraryFlags ? szNotepad : szWrite,
                    pszOutputFile);

    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    //
    // BUGBUG: Need to pass lpApplicationName also.
    //
    bReturn = CreateProcess(NULL,
                            pszCmdLine,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &si,
                            &pi);

    if (pi.hThread) {
        CloseHandle(pi.hThread);
    }

    if (pi.hProcess) {
        CloseHandle(pi.hProcess);
    }

    HeapFree(GetProcessHeap(), 0, pszCmdLine);

    return bReturn;
}

/*++

  Routine Description:

    Application entry point.

  Arguments:

    argc    -   Number command-line of arguments provided by the user.
    argv[]  -   An array of command-line arguments.

  Return Value:

    0 on failure, 1 on success.

--*/
int
__cdecl
main(
    IN int    argc,
    IN TCHAR* argv[]
    )
{
    TCHAR   szOutputFile[MAX_PATH];
    HRESULT hr;

    //
    // Perform some initialization.
    //
    if (!InitializeApplication()) {
        DPF(dlError, "[main] Failed to initialize the application");
        _tprintf("An error occured while initializing the application\n");
        return 0;
    }

    //
    // Parse the command-line and determine our mode of operation.
    //
    if (!ParseCommandLine(argc, argv)) {
        DPF(dlError, "[main] Invalid command-line arguments provided");
        DisplayUsage();
        return 0;
    }

    //
    // Sanity check here...can't specify a directory name and use the
    // -d flag (drivers) at the same time.
    //
    if (*g_ai.szGrabPath && g_ai.dwFilter == GRABMI_FILTER_DRIVERS) {
        _tprintf("Invalid syntax - can't use directory and -d flag together\n\n");
        DisplayUsage();
        return 0;
    }

    //
    // If the user did not specify a destination file, default to
    // %windir%\system32\matchinginfo.txt.
    //
    if (!*g_ai.szOutputFile) {
        hr = StringCchPrintf(szOutputFile,
                             ARRAYSIZE(szOutputFile),
                             "%s\\"MATCHINGINFO_FILENAME,
                             g_ai.szSystemDir);

        if (FAILED(hr)) {
            DPF(dlError, "[main] Buffer too small for output file");
            _tprintf("An error occured while formatting the output file location");
            return 0;
        }
    } else {
        hr = StringCchCopy(szOutputFile,
                           ARRAYSIZE(szOutputFile),
                           g_ai.szOutputFile);

        if (FAILED(hr)) {
            DPF(dlError, "[main] Buffer too small for specified output file");
            _tprintf("An error occured while formatting the output file location");
            return 0;
        }
    }

    //
    // If no starting path was specified, check the filter specified
    // and go to the system or current directory.
    //
    if (!*g_ai.szGrabPath) {
        if (GRABMI_FILTER_DRIVERS == g_ai.dwFilter) {
            hr = StringCchPrintf(g_ai.szGrabPath,
                                 ARRAYSIZE(g_ai.szGrabPath),
                                 "%s\\drivers",
                                 g_ai.szSystemDir);

            if (FAILED(hr)) {
                DPF(dlError, "[main] Buffer too small for grab path");
                _tprintf("An error occured while formatting the starting directory location");
                return 0;
            }
        } else {
            hr = StringCchCopy(g_ai.szGrabPath,
                               ARRAYSIZE(g_ai.szGrabPath),
                               g_ai.szCurrentDir);

            if (FAILED(hr)) {
                DPF(dlError, "[main] Buffer too small for specified grab path");
                _tprintf("An error occured while formatting the starting directory location");
                return 0;
            }
        }
    }

    //
    // Obtain pointers to functions within our libraries and perform
    // the grunt of the work.
    //
    if (!CallSdbAPIFunctions(szOutputFile)) {
        DPF(dlError, "[main] Failed to call the Sdb API functions");
        _tprintf("An error occured while attempting to get matching information");
        return 0;
    }

    //
    // Success - inform the user and display the file if requested.
    //
    _tprintf("Matching information retrieved successfully\n");

    if (g_ai.fDisplayFile) {
        if (!DisplayOutputFile(szOutputFile)) {
            DPF(dlError,
                "[main] Failed to display output file %s",
                szOutputFile);
            return 0;
        }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\fileversioninfo\fileversioninfo.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 2000
//
// File:        FileVersionInfo.cpp
//
// Contents:    Code for generating matching information for files in a given
//              directory and it's subdirectories.
//
// History:     18-Jul-00   jdoherty        Created.  
//              14-Mar-02   mnikkel         Modified to use strsafe.h
//
//---------------------------------------------------------------------------


#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <shlobj.h>
#include <strsafe.h>

                                                
BOOL MyStoreFileVersionInfo( CHAR *szFileName, CHAR *szFileOutName );
void CheckVerQueryStats ( LPVOID lpData );

// Needed by GetFileVersionInfo stubs
typedef struct StringTable 
{ 
    WORD wLength; 
    WORD wValueLength; 
    WORD wType; 
    CHAR szKey[8]; 
} ST; 

typedef struct StringFileInfo 
{ 
    WORD wLength; 
    WORD wValueLength; 
    WORD wType; 
    CHAR szKey[sizeof("StringFileInfo")]; 
    ST st; 
} SFI; 

typedef struct tagVERHEAD 
{
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         // always 0 
    CHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
    SFI sfi;
} VERHEAD;

int __cdecl main(int argc, CHAR* argv[])
{
    LPTSTR szCommandLine = {'\0'};

    if (argc > 3)
    {
        printf("The correct usage is:\n\tFileVerInfo.exe [filename including path]\n");
        getchar();
        return 0;
    }
    printf("Attempting to retrieve file version info for: %s\n", argv[1]);

    if(!MyStoreFileVersionInfo(argv[1], argv[2]))
    {
        printf("There was a problem retrieving the information.\n");
        getchar();
        return 0;
    }

    else
        szCommandLine = GetCommandLine();
        printf("The command line contained: %s\n", szCommandLine);
        printf("Operation completed successfully");

    getchar();

	return 0;
}

/*
    This function retrieves the version information for the file specified and stores the
    information on the users desktop, FileVerInfo.bin
*/
BOOL MyStoreFileVersionInfo ( CHAR *szFileName, CHAR *szFileOutName )
{
    LPDWORD lpdwHandle = 0;
    DWORD dwBytesToWrite = GetFileVersionInfoSizeA(szFileName, lpdwHandle);
    DWORD lpdwBytesWritten = 0;
    LPVOID lpData= malloc(dwBytesToWrite);
    CHAR lpPath[MAX_PATH*2] = {'\0'};
    HANDLE hfile;
    
    if( !dwBytesToWrite )
    {
        printf("There was a problem in GetFileVersionInfoSize()\n");
        printf("GLE reports error %d\n", GetLastError());
        return FALSE;
    }
    if ( !GetFileVersionInfoA(szFileName, NULL, dwBytesToWrite, lpData) )
    {
        printf("There was a problem in GetFileVersionInfo()\n");
        return FALSE;
    }

    CheckVerQueryStats(lpData);

    if(S_OK != StringCchCat(lpPath, MAX_PATH*2, ".\\"))
    {
        printf("Unable to add to path string!\n");
        return FALSE;
    }

    if ( szFileOutName )
    {
        if(S_OK != StringCchCat(lpPath, MAX_PATH*2, szFileOutName) ||
           S_OK != StringCchCat(lpPath, MAX_PATH*2, ".bin"))       
        {
            printf("Unable to add to path string!\n");
            return FALSE;
        }
    }
    else
    {
        if(S_OK != StringCchCat(lpPath, MAX_PATH*2, ".\\FileVerInfo.bin"))
        {
            printf("Unable to add to path string!\n");
            return FALSE;
        }
    }

    hfile = CreateFileA(lpPath, 
                        GENERIC_WRITE, 
                        0, 
                        NULL, 
                        CREATE_ALWAYS, 
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    
    if (hfile == INVALID_HANDLE_VALUE)
    {
        printf("There was a problem opening %s\n", lpPath);
        return FALSE;
    }

    printf("About to write to file: %s\n", lpPath);

    WriteFile( hfile, lpData, dwBytesToWrite, &lpdwBytesWritten, NULL );

    CloseHandle (hfile);

    return TRUE;
}

/*
    This function displays the minor version and the SFI version to the screen
*/
void CheckVerQueryStats ( LPVOID lpData )
{
    PUINT puLen = 0;

    printf("The minor version is: \t%x\n",((VERHEAD*) lpData)->vsf.dwFileVersionMS);
    printf("The SFI version is: \t%s\n",((VERHEAD*) lpData)->sfi.st.szKey);
    
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\grabmi\grabmi.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Grabmi.h

  Abstract:

    Contains function prototypes, constants, and other
    items used throughout the application.

  Notes:

    ANSI & Unicode via TCHAR - runs on Win9x/NT/2K/XP etc.

  History:

    07/18/00    jdoherty    Created
    12/16/00    jdoherty    Modified to use SDBAPI routines
    12/29/00    prashkud    Modified to take space in the filepath
    01/23/02    rparsons    Re-wrote existing code

--*/
#ifndef _GRABMI_H
#define _GRABMI_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <conio.h>      // _tcprintf
#include <stdio.h>
#include <stdlib.h>
#include <strsafe.h>

#include "resource.h"

//
// Function prototypes for our functions stored in the SDB libraries.
//
#ifdef __cplusplus
extern "C" {
#include "shimdb.h"
typedef
BOOL 
(SDBAPI 
*PFNSdbGrabMatchingInfoA)(
    LPCSTR szMatchingPath,
    DWORD  dwFilter,
    LPCSTR szFile
    );

typedef
BOOL 
(SDBAPI 
*PFNSdbGrabMatchingInfoW)(
    LPCWSTR szMatchingPath,
    DWORD   dwFilter,
    LPCWSTR szFile
    );
}
#endif // __cplusplus

typedef
GMI_RESULT
(SDBAPI
*PFNSdbGrabMatchingInfoExA)(
    LPCSTR                 szMatchingPath,      // path to begin gathering information
    DWORD                  dwFilterAndFlags,    // specifies the types of files to be added to matching
    LPCSTR                 szFile,              // full path to file where information will be stored
    PFNGMIProgressCallback pfnCallback,         // pointer to the callback function
    PVOID                  lpvCallbackParameter // an additional argument provided to the callback
    );

typedef
GMI_RESULT
(SDBAPI
*PFNSdbGrabMatchingInfoExW)(
    LPCWSTR                 szMatchingPath,         // path to begin gathering information
    DWORD                   dwFilterAndFlags,       // specifies the types of files to be added to matching
    LPCWSTR                 szFile,                 // full path to file where information will be stored
    PFNGMIProgressCallback  pfnCallback,            // pointer to the callback function
    LPVOID                  lpvCallbackParameter    // an additional argument provided to the callback
    );

BOOL
CALLBACK
_GrabmiCallback(
    LPVOID    lpvCallbackParam, // application-defined parameter
    LPCTSTR   lpszRoot,         // root directory path
    LPCTSTR   lpszRelative,     // relative path
    PATTRINFO pAttrInfo,        // attributes
    LPCWSTR   pwszXML           // resulting xml
    );

//
// Contains all the information we'll need to access throughout the app.
//
typedef struct _APPINFO {
    BOOL        fDisplayFile;               // indicates if we should display the file to the user
    TCHAR       szCurrentDir[MAX_PATH];     // contains the path that we're currently running from
    TCHAR       szSystemDir[MAX_PATH];      // contains the path to %windir%\system or %windir%\system32
    TCHAR       szOutputFile[MAX_PATH];     // contains the path to the output file (user-specified)
    TCHAR       szGrabPath[MAX_PATH];       // contains the path to the directory where we start scanning (user-specified)
    DWORD       dwFilter;                   // indicates the type of information to be grabbed
    DWORD       dwFilterFlags;              // indicates how the information should be filtered
    DWORD       dwLibraryFlags;             // flags that indicate which library to load
} APPINFO, *LPAPPINFO;

//
// Flags that determine which library is loaded on the current platform.
//
#define GRABMI_FLAG_NT          0x00000001
#define GRABMI_FLAG_APPHELP     0x00000002

//
// The name of our output file if the user doesn't specify one.
//
#define MATCHINGINFO_FILENAME   _T("matchinginfo.txt")

//
// The names of our libraries contaning Sdb API functions.
//
#define APPHELP_LIBRARY         _T("apphelp.dll")
#define SDBAPI_LIBRARY          _T("sdbapi.dll")
#define SDBAPIU_LIBRARY         _T("sdbapiu.dll")

//
// The name of the function that we're getting a pointer to.
//
#define PFN_GMI                 _T("SdbGrabMatchingInfoEx")

//
// DebugPrintf related stuff.
//
typedef enum {    
    dlNone     = 0,
    dlPrint,
    dlError,
    dlWarning,
    dlInfo
} DEBUGLEVEL;

void
__cdecl
DebugPrintfEx(
    IN DEBUGLEVEL dwDetail,
    IN LPSTR      pszFmt,
    ...
    );

#define DPF DebugPrintfEx

#endif // _GRABMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\infstrip\infstrip.cpp ===
#include <windows.h>
#include <stdio.h>

int _cdecl main(int argc, char** argv)
{
	if(argc != 3)
	{
		fprintf(stderr, "Usage: infstrip <filename> <token>\n");
		return -1;
	}

	HANDLE hFile;
	hFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Unable to open file %s\n", argv[1]);
		return -1;
	}

	HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY,0,0,
		NULL);
	if(!hMap)
	{
		fprintf(stderr, "Unable to open file %s\n", argv[1]);
		return -1;
	}

	void* pFile;

	pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if(!pFile)
	{
		fprintf(stderr, "Unable to open file %s\n", argv[1]);
		return -1;
	}

	char* pStart = reinterpret_cast<char*>(pFile);
	char* szSearchString = argv[2];
	DWORD dwSize = GetFileSize(hFile, NULL);
	char* pEnd = pStart + dwSize - 1;
	int iPos = strlen(szSearchString)-1;
	DWORD dwtruncationpoint = dwSize;


	for(; pEnd >= pStart; pEnd--)
	{
		if(*pEnd == szSearchString[iPos])
		{
			// Match.
			
			// Found the complete string.
			if(iPos == 0)
			{
				// Mark this as the truncation point.
				dwtruncationpoint = pEnd-pStart;
				iPos = strlen(szSearchString)-1;
				continue;
			}

			iPos--;
		}
		else
		{
			// Reset.
			iPos = strlen(szSearchString)-1;
		}
	}

	// Copy the file
	char* pNewFile = new char[dwtruncationpoint];
	memcpy(pNewFile, pStart, dwtruncationpoint);


	// Close the previous file.
	UnmapViewOfFile(pFile);
	CloseHandle(hMap);
	CloseHandle(hFile);

	// Truncate the file
	hFile = CreateFile(argv[1], GENERIC_WRITE, FILE_SHARE_READ,
		NULL, TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Error truncating file");
		return -1;
	}

	DWORD dwWritten = 0;
	if(!WriteFile(hFile, pNewFile, dwtruncationpoint, &dwWritten, NULL))
	{
		fprintf(stderr, "Error writing file");
		return -1;
	}
	CloseHandle(hFile);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\qfixapp\dbsupport.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    dbSupport.cpp

  Abstract:

    Contains code that allows us to read/create SDBs.

  Notes:

    ANSI & Unicode via TCHAR - runs on NT/2K/XP etc.

  History:

    02/16/00    clupu       Created
    02/20/02    rparsons    Implemented strsafe functions

--*/
#include "windows.h"
#include "commctrl.h"
#include "shlwapi.h"
#include <tchar.h>

#include "qfixapp.h"
#include "dbSupport.h"
#include "resource.h"
#include <strsafe.h>

#define _WANT_TAG_INFO

extern "C" {
#include "shimdb.h"

BOOL
ShimdbcExecute(
    LPCWSTR lpszCmdLine
    );
}

extern HINSTANCE g_hInstance;
extern HWND      g_hDlg;
extern TCHAR     g_szSDBToDelete[MAX_PATH];
extern BOOL      g_bSDBInstalled;
extern TCHAR     g_szAppTitle[64];
extern TCHAR     g_szWinDir[MAX_PATH];
extern TCHAR     g_szSysDir[MAX_PATH];

#define MAX_CMD_LINE         1024
#define MAX_SHIM_DESCRIPTION 1024
#define MAX_SHIM_NAME        128

#define MAX_BUFFER_SIZE      1024

#define SHIM_FILE_LOG_NAME  _T("QFixApp.log")

// Temp buffer to read UNICODE strings from the database.
TCHAR   g_szData[MAX_BUFFER_SIZE];

#define MAX_XML_SIZE        1024 * 16

//
// Buffers for display XML and SDB XML.
//
TCHAR   g_szDisplayXML[MAX_XML_SIZE];
TCHAR   g_szSDBXML[MAX_XML_SIZE];

TCHAR   g_szLayerName[] = _T("!#RunLayer");

INT_PTR
CALLBACK
ShowXMLDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    ShowXMLDlgProc

    Description:    Show the dialog with the XML for the current selections.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        //
        // By default we'll show the 'display XML'.
        //
        CheckDlgButton(hdlg, IDC_DISPLAY_XML, BST_CHECKED);
        SetDlgItemText(hdlg, IDC_XML, (LPTSTR)lParam);
        break;

    case WM_COMMAND:
        switch (wCode) {
        case IDC_DISPLAY_XML:
        case IDC_SDB_XML:
            if (BN_CLICKED == wNotifyCode) {
                if (IsDlgButtonChecked(hdlg, IDC_DISPLAY_XML)) {
                    SetDlgItemText(hdlg, IDC_XML, g_szDisplayXML);
                }
                else if (IsDlgButtonChecked(hdlg, IDC_SDB_XML)) {
                    SetDlgItemText(hdlg, IDC_XML, g_szSDBXML + 1);
                }
                SendDlgItemMessage(hdlg, IDC_XML, EM_SETSEL, 0, -1);
                SetFocus(GetDlgItem(hdlg, IDC_XML));
            }
            break;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        case IDC_SAVE_XML:
            DoFileSave(hdlg);
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

LPTSTR
ReadAndAllocateString(
    PDB   pdb,
    TAGID tiString
    )
{
    TCHAR*  psz = NULL;
    int     nLen;

    *g_szData = 0;

    SdbReadStringTag(pdb, tiString, g_szData, MAX_BUFFER_SIZE);

    if (!*g_szData) {
        DPF("[ReadAndAllocateString] Couldn't read the string");
        return NULL;
    }

    nLen = _tcslen(g_szData) + 1;

    psz = (LPTSTR)HeapAlloc(GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            nLen * sizeof(TCHAR));

    if (!psz) {
        return NULL;
    } else {
        StringCchCopy(psz, nLen, g_szData);
    }

    return psz;
}

BOOL
GetShimsFlagsForLayer(
    PDB     pdb,
    PFIX    pFixHead,
    PFIX*   parrShim,
    TCHAR** parrCmdLine,
    TAGID   tiLayer,
    BOOL    fGetShims
    )
/*++
    GetShimsFlagsForLayer

    Description:    Based on the flag, get the shims or flags for the given
                    layer and put them in the array.

--*/
{
    TAGID   tiTmp, tiName;
    int     nInd = 0;
    TCHAR   szName[MAX_SHIM_NAME] = _T("");

    //
    // If we're going to get flags, find the next available element
    // in the array so we can perform an insertion.
    //
    if (!fGetShims) {
        while (parrShim[nInd]) {
            nInd++;
        }
    }

    //
    // Based on the flag, find the first tag ID in the layer.
    //
    tiTmp = SdbFindFirstTag(pdb, tiLayer, fGetShims ? TAG_SHIM_REF : TAG_FLAG_REF);

    while (tiTmp != TAGID_NULL) {
        *szName = 0;
        PFIX  pFixWalk = NULL;

        tiName = SdbFindFirstTag(pdb, tiTmp, TAG_NAME);

        if (tiName == TAGID_NULL) {
            DPF("[GetShimsFlagForLayer] Failed to get the name of shim/flag");
            return FALSE;
        }

        SdbReadStringTag(pdb, tiName, szName, MAX_SHIM_NAME);

        if (!*szName) {
            DPF("[GetShimsFlagForLayer] Couldn't read the name of shim/flag");
            return FALSE;
        }

        pFixWalk = pFixHead;

        while (pFixWalk != NULL) {
            if (!(pFixWalk->dwFlags & FIX_TYPE_LAYER)) {
                if (_tcsicmp(pFixWalk->pszName, szName) == 0) {
                    parrShim[nInd] = pFixWalk;

                    if (fGetShims) {
                        //
                        // Now get the command line for this shim in the layer.
                        //
                        tiName = SdbFindFirstTag(pdb, tiTmp, TAG_COMMAND_LINE);

                        if (tiName != TAGID_NULL) {
                            parrCmdLine[nInd] = ReadAndAllocateString(pdb, tiName);
                        }
                    }

                    nInd++;
                    break;
                }
            }

            pFixWalk = pFixWalk->pNext;
        }

        tiTmp = SdbFindNextTag(pdb, tiLayer, tiTmp);
    }

    return TRUE;
}

PFIX
ParseTagFlag(
    PDB   pdb,
    TAGID tiFlag,
    BOOL  bAllFlags
    )
/*++
    ParseTagFlag

    Description:    Parse a Flag tag for the NAME, DESCRIPTION and MASK

--*/
{
    TAGID     tiFlagInfo;
    TAG       tWhichInfo;
    PFIX      pFix = NULL;
    TCHAR*    pszName = NULL;
    TCHAR*    pszDesc = NULL;
    DWORD     dwFlags = 0;
    BOOL      bGeneral = (bAllFlags ? TRUE : FALSE);

    tiFlagInfo = SdbGetFirstChild(pdb, tiFlag);

    while (tiFlagInfo != 0) {
        tWhichInfo = SdbGetTagFromTagID(pdb, tiFlagInfo);

        switch (tWhichInfo) {
        case TAG_GENERAL:
            bGeneral = TRUE;
            break;

        case TAG_NAME:
            pszName = ReadAndAllocateString(pdb, tiFlagInfo);
            break;

        case TAG_DESCRIPTION:
            pszDesc = ReadAndAllocateString(pdb, tiFlagInfo);
            break;

        case TAG_FLAGS_NTVDM1:
        case TAG_FLAGS_NTVDM2:
        case TAG_FLAGS_NTVDM3:
            dwFlags = FIX_TYPE_FLAGVDM;
            break;

        default:
            break;
        }

        tiFlagInfo = SdbGetNextChild(pdb, tiFlag, tiFlagInfo);
    }

    if (!bGeneral) {
        goto cleanup;
    }

    //
    // Done. Add the fix to the list.
    //
    pFix = (PFIX)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(FIX));

    if (pFix == NULL || pszName == NULL) {

cleanup:
        if (pFix != NULL) {
            HeapFree(GetProcessHeap(), 0, pFix);
        }

        if (pszName != NULL) {
            HeapFree(GetProcessHeap(), 0, pszName);
        }

        if (pszDesc != NULL) {
            HeapFree(GetProcessHeap(), 0, pszDesc);
        }

        return NULL;
    }

    pFix->pszName     = pszName;
    pFix->dwFlags    |= dwFlags | FIX_TYPE_FLAG;

    if (pszDesc) {
        pFix->pszDesc = pszDesc;
    } else {
        TCHAR* pszNone = NULL;

        pszNone = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);

        if (!pszNone) {
            return NULL;
        }

        *pszNone = 0;

        LoadString(g_hInstance, IDS_NO_DESCR_AVAIL, pszNone, MAX_PATH);
        pFix->pszDesc = pszNone;
    }

    return pFix;
}

PFIX
ParseTagShim(
    PDB   pdb,
    TAGID tiShim,
    BOOL  bAllShims
    )
/*++
    ParseTagShim

    Description:    Parse a Shim tag for the NAME, SHORTNAME, DESCRIPTION ...

--*/
{
    TAGID     tiShimInfo;
    TAG       tWhichInfo;
    PFIX      pFix = NULL;
    TCHAR*    pszName = NULL;
    TCHAR*    pszDesc = NULL;
    BOOL      bGeneral = (bAllShims ? TRUE : FALSE);

    tiShimInfo = SdbGetFirstChild(pdb, tiShim);

    while (tiShimInfo != 0) {
        tWhichInfo = SdbGetTagFromTagID(pdb, tiShimInfo);

        switch (tWhichInfo) {
        case TAG_GENERAL:
            bGeneral = TRUE;
            break;

        case TAG_NAME:
            pszName = ReadAndAllocateString(pdb, tiShimInfo);
            break;

        case TAG_DESCRIPTION:
            pszDesc = ReadAndAllocateString(pdb, tiShimInfo);
            break;

        default:
            break;
        }
        tiShimInfo = SdbGetNextChild(pdb, tiShim, tiShimInfo);
    }

    if (!bGeneral) {
        goto cleanup;
    }

    //
    // Done. Add the fix to the list.
    //
    pFix = (PFIX)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(FIX));

    if (pFix == NULL || pszName == NULL) {

cleanup:
        if (pFix != NULL) {
            HeapFree(GetProcessHeap(), 0, pFix);
        }

        if (pszName != NULL) {
            HeapFree(GetProcessHeap(), 0, pszName);
        }

        if (pszDesc != NULL) {
            HeapFree(GetProcessHeap(), 0, pszDesc);
        }

        return NULL;
    }

    pFix->pszName = pszName;
    pFix->dwFlags = FIX_TYPE_SHIM;

    //
    // If we didn't find a description, load it from the resource table.
    //
    if (pszDesc) {
        pFix->pszDesc = pszDesc;
    } else {
        TCHAR* pszNone;

        pszNone = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);

        if (!pszNone) {
            return NULL;
        }

        *pszNone = 0;

        LoadString(g_hInstance, IDS_NO_DESCR_AVAIL, pszNone, MAX_PATH);
        pFix->pszDesc = pszNone;
    }

    return pFix;
}

PFIX
ParseTagLayer(
    PDB   pdb,
    TAGID tiLayer,
    PFIX  pFixHead
    )
/*++
    ParseTagLayer

    Description:    Parse a LAYER tag for the NAME and the SHIMs that it contains.

--*/
{
    PFIX    pFix = NULL;
    TAGID   tiFlag, tiShim, tiName;
    int     nShimCount;
    TCHAR*  pszName = NULL;
    PFIX*   parrShim = NULL;
    TCHAR** parrCmdLine = NULL;

    tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);

    if (tiName == TAGID_NULL) {
        DPF("[ParseTagLayer] Failed to get the name of the layer");
        return NULL;
    }

    pszName = ReadAndAllocateString(pdb, tiName);

    //
    // Now loop through all the SHIMs that this LAYER consists of and
    // allocate an array to keep all the pointers to the SHIMs' pFix
    // structures. We do this in 2 passes. First we calculate how many
    // SHIMs are in the layer, then we lookup their appropriate pFix-es.
    //
    tiShim = SdbFindFirstTag(pdb, tiLayer, TAG_SHIM_REF);

    nShimCount = 0;

    while (tiShim != TAGID_NULL) {
        nShimCount++;
        tiShim = SdbFindNextTag(pdb, tiLayer, tiShim);
    }

    //
    // We have a count of the shims in the layer. Now we need to
    // add the flags that are included in this layer to the count.
    //
    tiFlag = SdbFindFirstTag(pdb, tiLayer, TAG_FLAG_REF);

    while (tiFlag != TAGID_NULL) {
        nShimCount++;
        tiFlag = SdbFindNextTag(pdb, tiLayer, tiFlag);
    }

    parrShim = (PFIX*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PFIX) * (nShimCount + 1));
    parrCmdLine = (TCHAR**)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(TCHAR*) * (nShimCount + 1));

    //
    // Done. Add the fix to the list.
    //
    pFix = (PFIX)HeapAlloc(GetProcessHeap(), 0, sizeof(FIX));

    if (pFix == NULL || parrCmdLine == NULL || pszName == NULL || parrShim == NULL) {

cleanup:
        if (pFix != NULL) {
            HeapFree(GetProcessHeap(), 0, pFix);
        }

        if (parrCmdLine != NULL) {
            HeapFree(GetProcessHeap(), 0, parrCmdLine);
        }

        if (parrShim != NULL) {
            HeapFree(GetProcessHeap(), 0, parrShim);
        }

        if (pszName != NULL) {
            HeapFree(GetProcessHeap(), 0, pszName);
        }

        DPF("[ParseTagLayer] Memory allocation error");
        return NULL;
    }

    //
    // Call the function that will fill in the array of PFIX
    // pointers and their corresponding command lines.
    // We do this for shims first.
    //
    if (!GetShimsFlagsForLayer(pdb,
                               pFixHead,
                               parrShim,
                               parrCmdLine,
                               tiLayer,
                               TRUE)) {

        DPF("[ParseTagLayer] Failed to get shims for layer");
        goto cleanup;
    }

    //
    // Now do the same thing for flags.
    //
    if (!GetShimsFlagsForLayer(pdb,
                               pFixHead,
                               parrShim,
                               NULL,
                               tiLayer,
                               FALSE)) {

        DPF("[ParseTagLayer] Failed to get flags for layer");
        goto cleanup;
    }

    pFix->pszName     = pszName;
    pFix->dwFlags     = FIX_TYPE_LAYER;
    pFix->parrShim    = parrShim;
    pFix->parrCmdLine = parrCmdLine;

    return pFix;
}

BOOL
IsSDBFromSP2(
    void
    )
/*++
    IsSDBFromSP2

    Description:    Determine if the SDB is from Service Pack 2.

--*/
{
    BOOL    fResult = FALSE;
    PDB     pdb;
    TAGID   tiDatabase;
    TAGID   tiLibrary;
    TAGID   tiChild;
    PFIX    pFix = NULL;;
    TCHAR   szSDBPath[MAX_PATH];
    HRESULT hr;

    hr = StringCchPrintf(szSDBPath,
                         ARRAYSIZE(szSDBPath) - 1,
                         _T("%s\\AppPatch\\sysmain.sdb"),
                         g_szWinDir);

    if (FAILED(hr)) {
        DPF("[IsSDBFromSP2] 0x%08X Buffer too small", HRESULT_CODE(hr));
        return FALSE;
    }

    //
    // Open the shim database.
    //
    pdb = SdbOpenDatabase(szSDBPath, DOS_PATH);

    if (!pdb) {
        DPF("[IsSDBFromSP2] Cannot open shim DB '%S'", szSDBPath);
        return FALSE;
    }

    //
    // Now browse the shim DB and look only for tags Shim within
    // the LIBRARY list tag.
    //
    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == TAGID_NULL) {
        DPF("[IsSDBFromSP2] Cannot find TAG_DATABASE under the root tag");
        goto cleanup;
    }

    //
    // Get TAG_LIBRARY.
    //
    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (tiLibrary == TAGID_NULL) {
        DPF("[IsSDBFromSP2] Cannot find TAG_LIBRARY under the TAG_DATABASE tag");
        goto cleanup;
    }

    //
    // Loop get the first shim in the library.
    //
    tiChild = SdbFindFirstTag(pdb, tiLibrary, TAG_SHIM);

    if (tiChild == NULL) {
        goto cleanup;
    }

    //
    // Get information about the first shim listed.
    //
    pFix = ParseTagShim(pdb, tiChild, TRUE);

    if (!pFix) {
        goto cleanup;
    }

    //
    // If the first shim listed is 2GbGetDiskFreeSpace, this is SP2.
    //
    if (!(_tcsicmp(pFix->pszName, _T("2GbGetDiskFreeSpace.dll")))) {
        fResult = TRUE;
    }

cleanup:
    SdbCloseDatabase(pdb);

    return fResult;
}

PFIX
ReadFixesFromSdb(
    LPTSTR pszSdb,
    BOOL   bAllFixes
    )
/*++
    ReadFixesFromSdb

    Description:    Query the database and enumerate all available shims fixes.

--*/
{
    PDB     pdb;
    TAGID   tiDatabase;
    TAGID   tiLibrary;
    TAGID   tiChild;
    PFIX    pFixHead = NULL;
    PFIX    pFix = NULL;
    TCHAR   szSDBPath[MAX_PATH];
    HRESULT hr;

    hr = StringCchPrintf(szSDBPath,
                         ARRAYSIZE(szSDBPath),
                         _T("%s\\AppPatch\\%s"),
                         g_szWinDir,
                         pszSdb);

    if (FAILED(hr)) {
        DPF("[ReadFixesFromSdb] 0x%08X Buffer too small", HRESULT_CODE(hr));
        return NULL;
    }

    //
    // Open the shim database.
    //
    pdb = SdbOpenDatabase(szSDBPath, DOS_PATH);

    if (!pdb) {
        DPF("[ReadFixesFromSdb] Cannot open shim DB '%S'", szSDBPath);
        return NULL;
    }

    //
    // Now browse the shim DB and look only for tags Shim within
    // the LIBRARY list tag.
    //
    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == TAGID_NULL) {
        DPF("[ReadFixesFromSdb] Cannot find TAG_DATABASE under the root tag");
        goto Cleanup;
    }

    //
    // Get TAG_LIBRARY.
    //
    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (tiLibrary == TAGID_NULL) {
        DPF("[ReadFixesFromSdb] Cannot find TAG_LIBRARY under the TAG_DATABASE tag");
        goto Cleanup;
    }

    //
    // Loop through all TAG_SHIM tags within TAG_LIBRARY.
    //
    tiChild = SdbFindFirstTag(pdb, tiLibrary, TAG_SHIM);

    while (tiChild != TAGID_NULL) {
        pFix = ParseTagShim(pdb, tiChild, bAllFixes);

        if (pFix != NULL) {
            pFix->pNext = pFixHead;
            pFixHead    = pFix;
        }

        tiChild = SdbFindNextTag(pdb, tiLibrary, tiChild);
    }

    //
    // Loop through all TAG_FLAG tags within TAG_LIBRARY.
    //
    tiChild = SdbFindFirstTag(pdb, tiLibrary, TAG_FLAG);

    while (tiChild != TAGID_NULL) {
        pFix = ParseTagFlag(pdb, tiChild, bAllFixes);

        if (pFix != NULL) {
            pFix->pNext = pFixHead;
            pFixHead    = pFix;
        }

        tiChild = SdbFindNextTag(pdb, tiLibrary, tiChild);
    }

    //
    // Loop through all TAG_LAYER tags within TAG_DATABASE.
    //
    tiChild = SdbFindFirstTag(pdb, tiDatabase, TAG_LAYER);

    while (tiChild != TAGID_NULL) {

        pFix = ParseTagLayer(pdb, tiChild, pFixHead);

        if (pFix != NULL) {
            pFix->pNext = pFixHead;
            pFixHead    = pFix;
        }

        tiChild = SdbFindNextTag(pdb, tiDatabase, tiChild);
    }

Cleanup:
    SdbCloseDatabase(pdb);

    return pFixHead;
}

#define ADD_AND_CHECK(cbSizeX, cbCrtSizeX, pszDst)                  \
{                                                                   \
    TCHAR* pszSrc = szBuffer;                                       \
                                                                    \
    while (*pszSrc != 0) {                                          \
                                                                    \
        if (cbSizeX - cbCrtSizeX <= 5) {                            \
            DPF("[ADD_AND_CHECK] Out of space");                    \
            return FALSE;                                           \
        }                                                           \
                                                                    \
        if (*pszSrc == _T('&') && *(pszSrc + 1) != _T('q')) {       \
            StringCbCopy(pszDst, cbSizeX, _T("&amp;"));             \
            pszDst += 5;                                            \
            cbCrtSizeX += 5;                                        \
        } else {                                                    \
            *pszDst++ = *pszSrc;                                    \
            cbCrtSizeX++;                                           \
        }                                                           \
        pszSrc++;                                                   \
    }                                                               \
    *pszDst = 0;                                                    \
    cbCrtSizeX++;                                                   \
}

BOOL
CollectShims(
	HWND    hListShims,
	LPTSTR  pszXML,
	int     cbSize
	)
/*++
    CollectShims

    Description:    Collects all the shims from the list view
                    and generates the XML in pszXML

--*/
{
    int     cShims = 0, nShimsApplied = 0, nIndex;
    int     cbCrtSize = 0;
    BOOL    fSelected = FALSE;
    LVITEM  lvi;
    TCHAR   szBuffer[1024];

    cShims = ListView_GetItemCount(hListShims);

    for (nIndex = 0; nIndex < cShims; nIndex++) {

        fSelected = ListView_GetCheckState(hListShims, nIndex);

        if (fSelected) {
            //
            // This shim is selected - add it to the XML.
            //
            lvi.mask     = LVIF_PARAM;
            lvi.iItem    = nIndex;
            lvi.iSubItem = 0;

            ListView_GetItem(hListShims, &lvi);

            PFIX pFix = (PFIX)lvi.lParam;
            PMODULE pModule = pFix->pModule;

            if (pFix->dwFlags & FIX_TYPE_FLAG) {
                if (NULL != pFix->pszCmdLine) {
                    StringCchPrintf(szBuffer,
                                    ARRAYSIZE(szBuffer),
                                    _T("            <FLAG NAME=\"%s\" COMMAND_LINE=\"%s\"/>\r\n"),
                                    pFix->pszName,
                                    pFix->pszCmdLine);
                } else {
                    StringCchPrintf(szBuffer,
                                    ARRAYSIZE(szBuffer),
                                    _T("            <FLAG NAME=\"%s\"/>\r\n"),
                                    pFix->pszName);
                }
            } else {
                //
                // Check for module include/exclude so we know how to open/close the XML.
                //
                if (NULL != pModule) {
                    if (NULL != pFix->pszCmdLine) {
                        StringCchPrintf(szBuffer,
                                        ARRAYSIZE(szBuffer),
                                        _T("            <SHIM NAME=\"%s\" COMMAND_LINE=\"%s\">\r\n"),
                                        pFix->pszName,
                                        pFix->pszCmdLine);

                    } else {
                        StringCchPrintf(szBuffer,
                                        ARRAYSIZE(szBuffer),
                                        _T("            <SHIM NAME=\"%s\">\r\n"),
                                        pFix->pszName);

                    }

                    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);

                    //
                    // Add the modules to the XML.
                    //
                    while (NULL != pModule) {
                        StringCchPrintf(szBuffer,
                                        ARRAYSIZE(szBuffer),
                                        _T("                <%s MODULE=\"%s\"/>\r\n"),
                                        pModule->fInclude ? _T("INCLUDE") : _T("EXCLUDE"),
                                        pModule->pszName);

                        pModule = pModule->pNext;

                        ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
                    }

                    //
                    // Close the SHIM tag.
                    //
                    StringCchPrintf(szBuffer,
                                    ARRAYSIZE(szBuffer),
                                    _T("            </SHIM>\r\n"));
                } else {
                    //
                    // No include/exclude was provided - just build the shim tag normally.
                    //
                    if (NULL != pFix->pszCmdLine) {
                        StringCchPrintf(szBuffer,
                                        ARRAYSIZE(szBuffer),
                                        _T("            <SHIM NAME=\"%s\" COMMAND_LINE=\"%s\"/>\r\n"),
                                        pFix->pszName,
                                        pFix->pszCmdLine);

                    } else {
                        StringCchPrintf(szBuffer,
                                        ARRAYSIZE(szBuffer),
                                        _T("            <SHIM NAME=\"%s\"/>\r\n"),
                                        pFix->pszName);

                    }
                }
            }

            ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);

            nShimsApplied++;
        }
    }

    DPF("[CollectShims] %d shim(s) selected", nShimsApplied);

    return TRUE;
}

BOOL
CollectFileAttributes(
    HWND    hTreeFiles,
    LPTSTR  pszXML,
    int     cbSize
    )
/*++
    CollectFileAttributes

    Description:    Collects the attributes of all the files in the tree
                    and generates the XML in pszXML.

--*/
{
    HTREEITEM hBinItem;
    HTREEITEM hItem;
    PATTRINFO pAttrInfo;
    UINT      State;
    TVITEM    item;
    int       cbCrtSize = 0;
    TCHAR     szItem[MAX_PATH];
    TCHAR     szBuffer[1024];

    //
    // First get the main EXE.
    //
    hBinItem = TreeView_GetChild(hTreeFiles, TVI_ROOT);

    item.mask       = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
    item.hItem      = hBinItem;
    item.pszText    = szItem;
    item.cchTextMax = MAX_PATH;

    TreeView_GetItem(hTreeFiles, &item);

    pAttrInfo = (PATTRINFO)(item.lParam);

    hItem = TreeView_GetChild(hTreeFiles, hBinItem);

    while (hItem != NULL) {
        item.mask  = TVIF_HANDLE | TVIF_PARAM | TVIF_STATE | TVIF_TEXT;
        item.hItem = hItem;

        TreeView_GetItem(hTreeFiles, &item);

        State = item.state & TVIS_STATEIMAGEMASK;

        if (State) {
            if (((State >> 12) & 0x03) == 2) {

                StringCchPrintf(szBuffer,
                                ARRAYSIZE(szBuffer),
                                _T(" %s"),
                                (LPTSTR)item.pszText);

                ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
            }
        }

        hItem = TreeView_GetNextSibling(hTreeFiles, hItem);
    }

    StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), _T(">\r\n"));

    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);

    //
    // Done with the main binary. Now enumerate the matching files.
    //
    hBinItem = TreeView_GetNextSibling(hTreeFiles, hBinItem);

    while (hBinItem != NULL) {

        item.mask       = TVIF_HANDLE | TVIF_PARAM | TVIF_STATE | TVIF_TEXT;
        item.hItem      = hBinItem;
        item.pszText    = szItem;
        item.cchTextMax = MAX_PATH;

        TreeView_GetItem(hTreeFiles, &item);

        pAttrInfo = (PATTRINFO)(item.lParam);

        StringCchPrintf(szBuffer,
                        ARRAYSIZE(szBuffer),
                        _T("            <MATCHING_FILE NAME=\"%s\""),
                        szItem);

        ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);

        hItem = TreeView_GetChild(hTreeFiles, hBinItem);

        while (hItem != NULL) {
            item.mask  = TVIF_HANDLE | TVIF_PARAM | TVIF_STATE | TVIF_TEXT;
            item.hItem = hItem;

            TreeView_GetItem(hTreeFiles, &item);

            State = item.state & TVIS_STATEIMAGEMASK;

            if (State) {
                if (((State >> 12) & 0x03) == 2) {

                    StringCchPrintf(szBuffer,
                                    ARRAYSIZE(szBuffer),
                                    _T(" %s"),
                                    (LPTSTR)item.pszText);

                    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
                }
            }

            hItem = TreeView_GetNextSibling(hTreeFiles, hItem);
        }

        StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), _T("/>\r\n"));

        ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);

        hBinItem = TreeView_GetNextSibling(hTreeFiles, hBinItem);
    }

    return TRUE;
}

BOOL
CreateSDBFile(
    LPCTSTR pszShortName,
    LPTSTR  pszSDBName
    )
/*++
    CreateSDBFile

    Description:    Creates the XML file on the user's hard drive and
                    generates the SDB using shimdbc.
--*/
{
    TCHAR*  psz = NULL;
    TCHAR   szShortName[MAX_PATH];
    TCHAR   szAppPatchDir[MAX_PATH];
    TCHAR   szSDBFile[MAX_PATH];
    TCHAR   szXMLFile[MAX_PATH];
    TCHAR   szCompiler[MAX_PATH];
    HANDLE  hFile;
    DWORD   cbBytesWritten;
    HRESULT hr;

    hr = StringCchPrintf(szAppPatchDir,
                         ARRAYSIZE(szAppPatchDir),
                         _T("%s\\AppPatch"),
                         g_szWinDir);

    if (FAILED(hr)) {
        DPF("[CreateSDBFile] 0x%08X Buffer too small (1)", HRESULT_CODE(hr));
        return FALSE;
    }

    SetCurrentDirectory(szAppPatchDir);

    hr = StringCchCopy(szShortName, ARRAYSIZE(szShortName), pszShortName);

    if (FAILED(hr)) {
        DPF("[CreateSDBFile] 0x%08X Buffer too small (2)", HRESULT_CODE(hr));
        return FALSE;
    }

    psz = PathFindExtension(szShortName);

    if (!psz) {
        return FALSE;
    } else {
        *psz = '\0';
    }

    hr = StringCchPrintf(szXMLFile,
                         ARRAYSIZE(szXMLFile),
                         _T("%s\\%s.xml"),
                         szAppPatchDir,
                         szShortName);

    if (FAILED(hr)) {
        DPF("[CreateSDBFile] 0x%08X Buffer too small (3)", HRESULT_CODE(hr));
        return FALSE;
    }

    hr = StringCchPrintf(szSDBFile,
                         ARRAYSIZE(szSDBFile),
                         _T("%s\\%s.sdb"),
                         szAppPatchDir,
                         szShortName);

    if (FAILED(hr)) {
        DPF("[CreateSDBFile] 0x%08X Buffer too small (4)", HRESULT_CODE(hr));
        return FALSE;
    }

    hFile = CreateFile(szXMLFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DPF("[CreateSDBFile] 0x%08X CreateFile '%S' failed",
            szXMLFile,
            GetLastError());
        return FALSE;
    }

    if (!(WriteFile(hFile,
                    g_szSDBXML,
                    _tcslen(g_szSDBXML) * sizeof(TCHAR),
                    &cbBytesWritten,
                    NULL))) {
        DPF("[CreateSDBFile] 0x%08X WriteFile '%S' failed",
            szXMLFile,
            GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    CloseHandle(hFile);

    hr = StringCchPrintf(szCompiler,
                         ARRAYSIZE(szCompiler),
                         _T("shimdbc.exe fix -q \"%s\" \"%s\""),
                         szXMLFile,
                         szSDBFile);

    if (FAILED(hr)) {
        DPF("[CreateSDBFile] 0x%08X Buffer too small (5)", HRESULT_CODE(hr));
        return FALSE;
    }

    if (!ShimdbcExecute(szCompiler)) {
        DPF("[CreateSDBFile] 0x%08X CreateProcess '%S' failed",
            szCompiler,
            GetLastError());
        return FALSE;
    }

    //
    // Give the SDB name back to the caller if they want it.
    //
    if (pszSDBName) {
        StringCchCopy(pszSDBName, MAX_PATH, szSDBFile);
    }

    return TRUE;
}

BOOL
BuildDisplayXML(
    HWND    hTreeFiles,
    HWND    hListShims,
    LPCTSTR pszLayerName,
    LPCTSTR pszShortName,
    DWORD   dwBinaryType,
    BOOL    fAddW2K
    )
/*++
    BuildDisplayXML

    Description:    Builds the XML that will be inserted into DBU.XML.

--*/
{
    TCHAR   szBuffer[1024];
    TCHAR*  pszXML = NULL;
    int     cbCrtXmlSize = 0, cbLength;
    int     cbXmlSize = MAX_XML_SIZE;

    //
    // Initialize our global and point to it.
    //
    *g_szDisplayXML = 0;
    pszXML = g_szDisplayXML;

    //
    // Build the header for the XML.
    //
    StringCchPrintf(szBuffer,
                    ARRAYSIZE(szBuffer),
                    _T("<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n")
                    _T("<DATABASE NAME=\"%s custom database\">\r\n"),
                    pszShortName);

    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    //
    // Add the APP and EXE elements to the XML.
    //
    StringCchPrintf(szBuffer,
                    ARRAYSIZE(szBuffer),
                    _T("    <APP NAME=\"%s\" VENDOR=\"Unknown\">\r\n")
                    _T("        <%s NAME=\"%s\""),
                    pszShortName,
                    (dwBinaryType == SCS_32BIT_BINARY ? _T("EXE") : _T("EXE - ERROR: 16-BIT BINARY")),
                    pszShortName);

    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    //
    // Add the matching files and their attributes to the XML.
    //
    if (!CollectFileAttributes(hTreeFiles,
                               pszXML,
                               cbXmlSize - cbCrtXmlSize)) {
        return FALSE;
    }

    cbLength = _tcslen(pszXML);
    pszXML += cbLength;
    cbCrtXmlSize += cbLength + 1;

    //
    // If a layer was provided, use it. Otherwise, build the list
    // of shims and add it to the XML.
    //
    if (pszLayerName) {
        StringCchPrintf(szBuffer,
                        ARRAYSIZE(szBuffer),
                        _T("            <LAYER NAME=\"%s\"/>\r\n"),
                        pszLayerName);
        ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);
    } else {
        if (!CollectShims(hListShims, pszXML, cbXmlSize - cbCrtXmlSize)) {
            return FALSE;
        }
        cbLength = _tcslen(pszXML);
        pszXML += cbLength;
        cbCrtXmlSize += cbLength + 1;
    }

    //
    // If this is Windows 2000, add Win2kPropagateLayer.
    //
    if (fAddW2K) {
        StringCchCopy(szBuffer,
                      ARRAYSIZE(szBuffer),
                      _T("            <SHIM NAME=\"Win2kPropagateLayer\"/>\r\n"));
        ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);
    }

    //
    // Finally, close the open tags.
    //
    StringCchCopy(szBuffer,
                  ARRAYSIZE(szBuffer),
                  _T("        </EXE>\r\n    </APP>\r\n</DATABASE>"));
    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    DPF("[BuildDisplayXML] XML:\n %S", g_szDisplayXML);

    return TRUE;
}

BOOL
BuildSDBXML(
    HWND    hTreeFiles,
    HWND    hListShims,
    LPCTSTR pszLayerName,
    LPCTSTR pszShortName,
    DWORD   dwBinaryType,
    BOOL    fAddW2K
    )
/*++
    BuildSDBXML

    Description:    Builds the XML that will be used for SDB generation.

--*/
{
    TCHAR   szBuffer[1024];
    TCHAR*  pszXML = NULL;
    WCHAR   wszUnicodeHdr = 0xFEFF;
    int     cbCrtXmlSize = 0, cbLength;
    int     cbXmlSize = MAX_XML_SIZE;

    //
    // Initialize our global and point to it.
    //
    g_szSDBXML[0] = 0;
    pszXML = g_szSDBXML;

    //
    // Build the header for the XML.
    //
    StringCchPrintf(szBuffer,
                    ARRAYSIZE(szBuffer),
                    _T("%lc<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n")
                    _T("<DATABASE NAME=\"%s custom database\">\r\n"),
                    wszUnicodeHdr,
                    pszShortName);

    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    //
    // If no layer was provided, this indicates that the user has
    // selected individual shims and we need to build our own layer.
    //
    if (!pszLayerName) {
        StringCchPrintf(szBuffer,
                        ARRAYSIZE(szBuffer),
                        _T("    <LIBRARY>\r\n        <LAYER NAME=\"%s\">\r\n"),
                        g_szLayerName + 2);
        ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

        if (!CollectShims(hListShims,
                          pszXML,
                          cbXmlSize - cbCrtXmlSize)) {
            return FALSE;
        }

        cbLength = _tcslen(pszXML);
        pszXML += cbLength;
        cbCrtXmlSize += cbLength + 1;

        //
        // If this is Windows 2000, add Win2kPropagateLayer.
        //
        if (fAddW2K) {
            StringCchCopy(szBuffer,
                          ARRAYSIZE(szBuffer),
                          _T("            <SHIM NAME=\"Win2kPropagateLayer\"/>\r\n"));
            ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);
        }

        //
        // Close the open tags.
        //
        StringCchCopy(szBuffer,
                      ARRAYSIZE(szBuffer),
                      _T("        </LAYER>\r\n    </LIBRARY>\r\n"));
        ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);
    }

    //
    // Add the APP and EXE elements to the XML.
    //
    StringCchPrintf(szBuffer,
                    ARRAYSIZE(szBuffer),
                    _T("    <APP NAME=\"%s\" VENDOR=\"Unknown\">\r\n")
                    _T("        <EXE NAME=\"%s\""),
                    pszShortName,
                    pszShortName);

    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    //
    // Add the matching files and their attributes to the XML.
    //
    if (!CollectFileAttributes(hTreeFiles,
                               pszXML,
                               cbXmlSize - cbCrtXmlSize)) {
        return FALSE;
    }

    cbLength = _tcslen(pszXML);
    pszXML += cbLength;
    cbCrtXmlSize += cbLength + 1;

    //
    // Add the LAYER element to the XML. This will either be a predefined
    // layer name or the special 'RunLayer' indicating we built our own.
    //
    if (!pszLayerName) {
        StringCchPrintf(szBuffer,
                        ARRAYSIZE(szBuffer),
                        _T("            <LAYER NAME=\"%s\"/>\r\n"),
                        g_szLayerName + 2);
    } else {
        StringCchPrintf(szBuffer,
                        ARRAYSIZE(szBuffer),
                        _T("            <LAYER NAME=\"%s\"/>\r\n"),
                        pszLayerName);
    }

    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    //
    // Finally, close the open tags.
    //
    StringCchCopy(szBuffer,
                  ARRAYSIZE(szBuffer),
                  _T("        </EXE>\r\n    </APP>\r\n</DATABASE>"));

    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    DPF("[BuildSDBXML] XML:\n %S", g_szSDBXML);

    return TRUE;
}

BOOL
CollectFix(
    HWND    hListLayers,
    HWND    hListShims,
    HWND    hTreeFiles,
    LPCTSTR pszShortName,
    LPCTSTR pszFullPath,
    DWORD   dwFlags,
    LPTSTR  pszFileCreated
    )
/*++
    CollectFix

    Description:    Adds the necessary support to apply shim(s) for
                    the specified app.
--*/
{
    BOOL      fAddW2K = FALSE;
    TCHAR     szError[MAX_PATH];
    TCHAR     szXmlFile[MAX_PATH];
    TCHAR*    pszLayerName = NULL;
    TCHAR     szLayer[128];
    DWORD     dwBinaryType = SCS_32BIT_BINARY;

    //
    // If the user has selected a predefined layer, we'll use that.
    // Otherwise, assign the 'RunLayer' name which has a special
    // meaning.
    //
    if (dwFlags & CFF_USELAYERTAB) {

        LRESULT lSel;

        lSel = SendMessage(hListLayers, LB_GETCURSEL, 0, 0);

        if (lSel == LB_ERR) {
            LoadString(g_hInstance, IDS_LAYER_SELECT, szError, ARRAYSIZE(szError));
            MessageBox(g_hDlg, szError, g_szAppTitle, MB_ICONEXCLAMATION);
            return TRUE;
        }

        SendMessage(hListLayers, LB_GETTEXT, lSel, (LPARAM)szLayer);

        pszLayerName = szLayer;
    }

    //
    // Determine the binary type.
    //
    GetBinaryType(pszFullPath, &dwBinaryType);

    //
    // If this is Windows 2000 and they're not using
    // a predefined layer, add Win2kPropagateLayer.
    //
    if ((dwFlags & CFF_ADDW2KSUPPORT) && !(dwFlags & CFF_USELAYERTAB)) {
        fAddW2K = TRUE;
    }

    //
    // Build the display version of the XML.
    //
    if (!BuildDisplayXML(hTreeFiles,
                         hListShims,
                         pszLayerName,
                         pszShortName,
                         dwBinaryType,
                         fAddW2K)) {
        DPF("Failed to build display XML");
        return FALSE;
    }

    //
    // Build the version of the XML that we'll use to generate the SDB.
    //
    if (!BuildSDBXML(hTreeFiles,
                     hListShims,
                     pszLayerName,
                     pszShortName,
                     dwBinaryType,
                     fAddW2K)) {
        DPF("Failed to build SDB XML");
        return FALSE;
    }

    //
    // Display the XML if the user wants to see it.
    //
    if (dwFlags & CFF_SHOWXML) {
        DialogBoxParam(g_hInstance,
                       MAKEINTRESOURCE(IDD_XML),
                       g_hDlg,
                       ShowXMLDlgProc,
                       (LPARAM)(g_szDisplayXML));
        return TRUE;
    }

    //
    // Create the SDB file for the user.
    //
    if (!(CreateSDBFile(pszShortName, pszFileCreated))) {
        return FALSE;
    }

    //
    // Delete the XML file that we created.
    //
    StringCchCopy(szXmlFile, ARRAYSIZE(szXmlFile), pszFileCreated);
    PathRenameExtension(szXmlFile, _T(".xml"));
    DeleteFile(szXmlFile);

    //
    // Set the SHIM_FILE_LOG env var.
    //
    if (dwFlags & CFF_SHIMLOG) {
        DeleteFile(SHIM_FILE_LOG_NAME);
        SetEnvironmentVariable(_T("SHIM_FILE_LOG"), SHIM_FILE_LOG_NAME);
    }

    return TRUE;
}

void
CleanupSupportForApp(
    TCHAR* pszShortName
    )
/*++
    CleanupSupportForApp

    Description:    Cleanup the mess after we're done with the specified app.

--*/
{
    TCHAR   szSDBPath[MAX_PATH];
    HRESULT hr;

    hr = StringCchPrintf(szSDBPath,
                         ARRAYSIZE(szSDBPath),
                         _T("%s\\AppPatch\\%s"),
                         g_szWinDir,
                         pszShortName);

    if (FAILED(hr)) {
        DPF("[CleanupSupportForApp] 0x%08X Buffer too small", HRESULT_CODE(hr));
        return;
    }

    //
    // Attempt to delete the XML file.
    //
    PathRenameExtension(szSDBPath, _T(".xml"));
    DeleteFile(szSDBPath);

    //
    // Remove the previous SDB file, if one exists.
    //
    // NTRAID#583475-rparsons Don't remove the SDB if the user
    // installed it.
    //
    //
    if (*g_szSDBToDelete && !g_bSDBInstalled) {
        InstallSDB(g_szSDBToDelete, FALSE);
        DeleteFile(g_szSDBToDelete);
    }
}

void
ShowShimLog(
    void
    )
/*++
    ShowShimLog

    Description:    Show the shim log file in notepad.

--*/
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR               szAppName[MAX_PATH];
    TCHAR               szCmdLine[MAX_PATH];
    TCHAR               szError[MAX_PATH];
    HRESULT             hr;

    hr = StringCchPrintf(szAppName,
                         ARRAYSIZE(szAppName),
                         _T("%s\\notepad.exe"),
                         g_szSysDir);

    if (FAILED(hr)) {
        DPF("[ShowShimLog] 0x%08X Buffer too small (1)", HRESULT_CODE(hr));
        return;
    }

    hr = StringCchPrintf(szCmdLine,
                         ARRAYSIZE(szCmdLine),
                         _T("%s\\AppPatch\\")SHIM_FILE_LOG_NAME,
                         g_szWinDir);

    if (FAILED(hr)) {
        DPF("[ShowShimLog] 0x%08X Buffer too small (2)", HRESULT_CODE(hr));
        return;
    }

    if (GetFileAttributes(szCmdLine) == -1) {
        LoadString(g_hInstance, IDS_NO_LOGFILE, szError, ARRAYSIZE(szError));
        MessageBox(NULL, szError, g_szAppTitle, MB_ICONEXCLAMATION);
        return;
    }

    hr = StringCchPrintf(szCmdLine,
                         ARRAYSIZE(szCmdLine),
                         _T("%s %s\\AppPatch\\")SHIM_FILE_LOG_NAME,
                         szAppName,
                         g_szWinDir);

    if (FAILED(hr)) {
        DPF("[ShowShimLog] 0x%08X Buffer too small (3)", HRESULT_CODE(hr));
        return;
    }

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    if (!CreateProcess(szAppName,
                       szCmdLine,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {

        DPF("[ShowShimLog] 0x%08X CreateProcess '%S %S' failed",
            szAppName,
            szCmdLine,
            GetLastError());
        return;
    }

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\qfixapp\dbsupport.h ===
#ifndef _SHIMWHISTLER_H
#define _SHIMWHISTLER_H

#include "qfixapp.h"

PFIX
ReadFixesFromSdb(
    LPTSTR  pszSdb,
    BOOL    bAllShims
    );

#define CFF_APPENDLAYER         0x00000001
#define CFF_SHOWXML             0x00000002
#define CFF_SHIMLOG             0x00000004
#define CFF_USELAYERTAB         0x00000008
#define CFF_ADDW2KSUPPORT       0x00000020

BOOL
CollectFix(
    HWND    hListLayers,
    HWND    hTreeShims,
    HWND    hTreeFiles,
    LPCTSTR pszShortName,
    LPCTSTR pszFullPath,
    DWORD   dwFlags,
    LPTSTR  pszFileCreated
    );

void
CleanupSupportForApp(
    TCHAR* pszShortName
    );

void
ShowShimLog(
    void
    );

BOOL
IsSDBFromSP2(
    void
    );

#endif // _SHIMWHISTLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\qfixapp\qfixapp.h ===
#ifndef _QSHIMAPP_H
#define _QSHIMAPP_H

typedef enum {
    uSelect     = 0,
    uDeselect,
    uReverse
} SELECTION;


#define MAX_COMMAND_LINE    1024

#define ACCESS_READ         0x01
#define ACCESS_WRITE        0x02

#define BML_ADDTOLISTVIEW   0x00000001
#define BML_DELFRLISTVIEW   0x00000002
#define BML_GETFRLISTVIEW   0x00000004

typedef struct tagModule {
    struct tagModule*   pNext;
    TCHAR*              pszName;
    BOOL                fInclude;
} MODULE, *PMODULE;

#define FIX_TYPE_LAYER      0x00000001
#define FIX_TYPE_FLAG       0x00000002
#define FIX_TYPE_FLAGVDM    0x00000004
#define FIX_TYPE_SHIM       0x00000008

typedef struct tagFIX {
    struct tagFIX*      pNext;
    DWORD               dwFlags;
    TCHAR*              pszName;
    TCHAR*              pszDesc;
    TCHAR*              pszCmdLine;
    struct tagFIX**     parrShim;
    struct tagModule*   pModule;
    TCHAR**             parrCmdLine;
} FIX, *PFIX;

#define NUM_TABS        2

typedef struct tag_DlgHdr {
    HWND        hTab;                   // tab control
    HWND        hDisplay[NUM_TABS];     // dialog box handles
    RECT        rcDisplay;              // display rectangle for each tab
    DLGTEMPLATE *pRes[NUM_TABS];        // DLGTEMPLATE structure
    DLGPROC     pDlgProc[NUM_TABS];
} DLGHDR, *PDLGHDR;

void
__cdecl
DebugPrintfEx(
    IN LPSTR pszFmt,
    ...
    );

#if DBG
    #define DPF DebugPrintfEx
#else
    #define DPF
#endif // DBG

void
HandleModuleListNotification(
    HWND   hdlg,
    LPARAM lParam
    );

void
DoFileSave(
    HWND hDlg
    );

BOOL
InstallSDB(
    TCHAR* pszFileName,
    BOOL   fInstall
    );

INT_PTR CALLBACK
FixesTabDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
LayersTabDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void
ShowAvailableFixes(
    HWND hList
    );

void
HandleShimListNotification(
    HWND   hdlg,
    LPARAM lParam
    );

#endif // _QSHIMAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\qfixapp\qfixapp.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    QFixApp.cpp

  Abstract:

    Contains the application entry point, user interface code,
    and some supporting functions.

  Notes:

    ANSI & Unicode via TCHAR - runs on NT/2K/XP etc.

  History:

    02/16/00    clupu       Created
    11/10/00    rparsons    Minor common dialog change
    11/23/00    rparsons    Added save XML file capability
    11/25/00    rparsons    Matching file on a different drive
                            can be selected
    05/19/01    rparsons    Added context menu for file tree.
                            Added URL for WU package/helpcenter.
                            Added Remove Matching File button.
                            Converted shim list to list view.
    07/06/01    rparsons    Static tab control -> child dialogs
    09/24/01    rparsons    Spawn a separate VDM when running apps
    10/09/01    rparsons    Flags have a command-line
    10/26/01    rparsons    No change - 476903.
    01/26/02    rparsons    Fix bug # 491301
    02/20/02    rparsons    Implemented strsafe functions
    03/22/02    rparsons    Fix bug # 583475

--*/
#include "afxwin.h"
#include "commctrl.h"
#include "commdlg.h"
#include "shlwapi.h"
#include "shellapi.h"
#include "shlobj.h"
#include "shlobjp.h"    // needed for Link Window support
#include "uxtheme.h"    // needed for tab control theme support
#include "resource.h"
#include <tchar.h>
#include <aclapi.h>
#include <strsafe.h>

#include "QFixApp.h"
#include "dbSupport.h"

extern "C" {
#include "shimdb.h"
}

CWinApp theApp;

/*
 * Global Variables
 */

HINSTANCE g_hInstance;
HWND      g_hDlg;
HWND      g_hLayersDlg;
HWND      g_hFixesDlg;

HWND      g_hwndTab;
HWND      g_hwndListLayers;

TCHAR     g_szAppTitle[64];

TCHAR     g_szWinDir[MAX_PATH];         // %windir%
TCHAR     g_szSysDir[MAX_PATH];         // %windir%\System32

TCHAR     g_szBinary[MAX_PATH];         // the full path of the main binary being shimmed
TCHAR     g_szShortName[128];           // the short name of the main EXE

TCHAR     g_szParentExeName[MAX_PATH];  // the short name of the parent EXE
TCHAR     g_szParentExeFullPath[MAX_PATH]; // the full path of the parent EXE

TCHAR     g_szSDBToDelete[MAX_PATH];    // the SDB file to delete from a previous 'Run'

int       g_nCrtTab;

HWND      g_hwndShimList;               // the handle to the list view control
                                        // containing all the shims available

HWND      g_hwndFilesTree;              // the handle to the tree view control
                                        // containing the matching files selected

HWND      g_hwndModuleList;             // the handle to the list view control
                                        // containing module information

BOOL      g_bSimpleEdition;             // simple or dev edition

BOOL      g_fW2K;                       // Win2K or XP

BOOL      g_fNETServer;                 // indicates if we're running on .NET Server

RECT      g_rcDlgBig, g_rcDlgSmall;     // rectangle of the simple and the dev edition
                                        // of the dialog

BOOL      g_bAllShims;                  // indicates if all shims should be displayed

BOOL      g_bShowXML;                   // indicates if we should hide the 'Show XML' button

BOOL      g_bSelectedParentExe;         // flag to indicate if a parent EXE has been
                                        // selected

BOOL      g_bSDBInstalled;              // flag to indicate if the user installed the SDB
                                        // associated with the current EXE

PFIX      g_pFixHead;

TCHAR     g_szXPUrl[] = _T("hcp://services/subsite?node=TopLevelBucket_4/")
                        _T("Fixing_a_problem&topic=MS-ITS%3A%25HELP_LOCATION")
                        _T("%25%5Cmisc.chm%3A%3A/compatibility_tab_and_wizard.htm")
                        _T("&select=TopLevelBucket_4/Fixing_a_problem/")
                        _T("Application_and_software_problems");

TCHAR     g_szNETUrl[] = _T("hcp://services/subsite?node=Troubleshooting_Strategies&")
                         _T("topic=MS-ITS%3A%25HELP_LOCATION%25%5Cmisc.chm%3A%3A/")
                         _T("compatibility_tab_and_wizard.htm");

TCHAR     g_szW2KUrl[] = _T("http://www.microsoft.com/windows2000/")
                         _T("downloads/tools/appcompat/");


#define ID_COUNT_SHIMS  1234

typedef HRESULT (*PFNEnableThemeDialogTexture)(HWND hwnd, DWORD dwFlags);

/*++

  Routine Description:

    Prints a formatted string to the debugger.

  Arguments:

    dwDetail    -   Specifies the level of the information provided.
    pszFmt      -   The string to be displayed.
    ...         -   A va_list of insertion strings.

  Return Value:

    None.

--*/
void
__cdecl
DebugPrintfEx(
    IN LPSTR pszFmt,
    ...
    )
{
    char    szT[1024];
    va_list arglist;
    int     len;

    va_start(arglist, pszFmt);

    //
    // Reserve one character for the potential '\n' that we may be adding.
    //
    StringCchVPrintfA(szT, sizeof(szT) - 1, pszFmt, arglist);

    va_end(arglist);

    //
    // Make sure we have a '\n' at the end of the string
    //
    len = strlen(szT);

    if (len > 0 && szT[len - 1] != '\n')  {
        szT[len] = '\n';
        szT[len + 1] = 0;
    }

    OutputDebugStringA(szT);
}

BOOL
SearchGroupForSID(
    IN  DWORD dwGroup,
    OUT BOOL* pfIsMember
    )
{
    PSID                     pSID;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {
        fRes = FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

BOOL
IsUserAnAdministrator(
    void
    )
/*++
    IsUserAnAdministrator

    Description:    Determine if the currently logged on user is an admin.

--*/
{
    BOOL fIsAdmin;

    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin)) {
        return FALSE;
    }

    return fIsAdmin;
}

BOOL
CheckForSDB(
    void
    )
/*++
    CheckForSDB

    Description:    Attempts to locate sysmain.sdb in the apppatch directory.

--*/
{
    TCHAR   szSDBPath[MAX_PATH];
    BOOL    fResult = FALSE;
    HRESULT hr;

    hr = StringCchPrintf(szSDBPath,
                         ARRAYSIZE(szSDBPath),
                         _T("%s\\AppPatch\\sysmain.sdb"),
                         g_szWinDir);

    if (FAILED(hr)) {
        DPF("[CheckForSDB] 0x%08X Buffer too small", HRESULT_CODE(hr));
        return FALSE;
    }

    if (GetFileAttributes(szSDBPath) != -1) {
        fResult = TRUE;
    }

    return fResult;
}

void
AddModuleToListView(
    TCHAR*  pModuleName,
    UINT    uOption
    )
/*++
    AddModuleToListView

    Description:    Adds the specified module to the list view.

--*/
{
    LVITEM  lvi;
    int     nIndex;
    TCHAR   szInclude[MAX_PATH];
    TCHAR   szExclude[MAX_PATH];

    LoadString(g_hInstance, IDS_INCLUDE_HDR, szInclude, ARRAYSIZE(szInclude));
    LoadString(g_hInstance, IDS_EXCLUDE_HDR, szExclude, ARRAYSIZE(szExclude));

    lvi.mask     = LVIF_TEXT | LVIF_PARAM;
    lvi.lParam   = uOption == BST_CHECKED ? 1 : 0;
    lvi.pszText  = uOption == BST_CHECKED ? szInclude : szExclude;
    lvi.iItem    = ListView_GetItemCount(g_hwndModuleList);
    lvi.iSubItem = 0;

    nIndex = ListView_InsertItem(g_hwndModuleList, &lvi);

    ListView_SetItemText(g_hwndModuleList,
                         nIndex,
                         1,
                         pModuleName);
}

void
BuildModuleListForShim(
    PFIX  pFix,
    DWORD dwFlags
    )
/*++
    BuildModuleListForShim

    Description:    Based on the flag, adds modules to the list view for
                    the specified shim or retrieves them and adds them
                    to the linked list.

--*/
{
    PMODULE pModule, pModuleTmp, pModuleNew;
    int     cItems, nIndex, nLen;
    LVITEM  lvi;
    TCHAR   szBuffer[MAX_PATH];

    if (dwFlags & BML_ADDTOLISTVIEW) {

        //
        // Walk the linked list and add the modules to the list view.
        //
        pModule = pFix->pModule;

        while (pModule) {

            AddModuleToListView(pModule->pszName,
                                pModule->fInclude ? BST_CHECKED : 0);

            pModule = pModule->pNext;
        }

    }

    if (dwFlags & BML_DELFRLISTVIEW) {

        pModule = pFix->pModule;

        while (NULL != pModule) {

            pModuleTmp = pModule->pNext;

            HeapFree(GetProcessHeap(), 0, pModule->pszName);
            HeapFree(GetProcessHeap(), 0, pModule);

            pModule = pModuleTmp;
        }

        pFix->pModule = NULL;

    }

    if (dwFlags & BML_GETFRLISTVIEW) {

        pModule = pFix->pModule;

        while (NULL != pModule) {

            pModuleTmp = pModule->pNext;

            HeapFree(GetProcessHeap(), 0, pModule->pszName);
            HeapFree(GetProcessHeap(), 0, pModule);

            pModule = pModuleTmp;
        }

        pFix->pModule = NULL;

        //
        // Get each module from the list view and add it to the linked list.
        //
        cItems = ListView_GetItemCount(g_hwndModuleList);

        if (cItems == 0) {
            return;
        }

        for (nIndex = cItems - 1; nIndex >= 0; nIndex--) {

            lvi.mask     = LVIF_PARAM;
            lvi.iItem    = nIndex;
            lvi.iSubItem = 0;

            ListView_GetItem(g_hwndModuleList, &lvi);

            ListView_GetItemText(g_hwndModuleList,
                                 nIndex,
                                 1,
                                 szBuffer,
                                 ARRAYSIZE(szBuffer));

            pModuleNew = (PMODULE)HeapAlloc(GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            sizeof(MODULE));

            if (!pModuleNew) {
                DPF("[BuildModuleListForShim] Couldn't allocate memory for node");
                return;
            }

            nLen = _tcslen(szBuffer) + 1;

            pModuleNew->pszName = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    nLen * sizeof(TCHAR));

            if (!pModuleNew->pszName) {
                DPF("[BuildModuleListForShim] Couldn't allocate memory to store module info");
                HeapFree(GetProcessHeap(), 0, pModuleNew);
                return;
            }

            StringCchCopy(pModuleNew->pszName, nLen, szBuffer);
            pModuleNew->fInclude = (BOOL)lvi.lParam;

            pModuleNew->pNext = pFix->pModule;
            pFix->pModule = pModuleNew;
        }
    }
}

int
CountShims(
    BOOL fCountSelected
    )
/*++
    CountShims

    Description:    Counts the number of selected shims in the list and
                    updates the text on the dialog.
--*/
{
    int     cShims = 0, nTotalShims, nShims = 0;
    BOOL    fReturn;
    TCHAR   szShims[MAX_PATH];
    TCHAR   szTemp[MAX_PATH];
    HRESULT hr;

    cShims = ListView_GetItemCount(g_hwndShimList);

    if (fCountSelected) {

        for (nTotalShims = 0; nTotalShims < cShims; nTotalShims++) {

            fReturn = ListView_GetCheckState(g_hwndShimList, nTotalShims);

            if (fReturn) {
                nShims++;
            }
        }
    }

    LoadString(g_hInstance, IDS_SEL_CAPTION, szTemp, ARRAYSIZE(szTemp));

    hr = StringCchPrintf(szShims,
                         ARRAYSIZE(szShims),
                         szTemp,
                         nShims,
                         cShims);

    if (FAILED(hr)) {
        DPF("[CountShims] 0x%08X Buffer too small", HRESULT_CODE(hr));
        return 0;
    }

    SetDlgItemText(g_hFixesDlg, IDC_SELECTED_SHIMS, szShims);

    return cShims;
}

void
DisplayAttrContextMenu(
    POINT* pt
    )
/*++
    DisplayAttrContextMenu

    Description:    Displays a popup menu for the attributes tree.

--*/

{
    HMENU hPopupMenu, hTrackPopup;

    //
    // Load the popup menu and display it.
    //
    hPopupMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_ATTR_POPUP));

    if (hPopupMenu == NULL) {
        return;
    }

    hTrackPopup = GetSubMenu(hPopupMenu, 0);

    TrackPopupMenu(hTrackPopup,
                   TPM_LEFTBUTTON | TPM_NOANIMATION | TPM_LEFTALIGN,
                   pt->x, pt->y, 0, g_hDlg, NULL);

    DestroyMenu(hPopupMenu);
}

void
InsertListViewColumn(
    HWND   hWndListView,
    LPTSTR lpColumnName,
    BOOL   fCenter,
    int    nColumnID,
    int    nSize
    )
/*++
    InsertListViewColumn

    Description:    Wrapper for ListView_InsertColumn.

--*/
{
    LV_COLUMN   lvColumn;

    if (fCenter) {
        lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
    } else {
        lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    }

    //
    // Fill in the structure and add the column.
    //
    lvColumn.fmt        =   LVCFMT_CENTER;
    lvColumn.cx         =   nSize;
    lvColumn.iSubItem   =   0;
    lvColumn.pszText    =   lpColumnName;
    ListView_InsertColumn(hWndListView, nColumnID, &lvColumn);
}

void
EnableTabBackground(
    HWND hDlg
    )
{
    PFNEnableThemeDialogTexture pFnEnableThemeDialogTexture;
    HMODULE                     hUxTheme;

    hUxTheme = (HMODULE)LoadLibrary(_T("uxtheme.dll"));
    if (hUxTheme) {
        pFnEnableThemeDialogTexture = (PFNEnableThemeDialogTexture)
                                            GetProcAddress(hUxTheme, "EnableThemeDialogTexture");
        if (pFnEnableThemeDialogTexture) {
            pFnEnableThemeDialogTexture(hDlg, ETDT_USETABTEXTURE);
        }

        FreeLibrary(hUxTheme);
    }
}

void
HandleLayersDialogInit(
    HWND hDlg
    )
{
    HWND    hParent;
    DLGHDR* pHdr;

    g_hLayersDlg = hDlg;

    hParent = GetParent(hDlg);

    pHdr = (DLGHDR*)GetWindowLongPtr(hParent, DWLP_USER);

    //
    // Position the dialog within the tab.
    //
    SetWindowPos(hDlg, HWND_TOP,
                 pHdr->rcDisplay.left,
                 pHdr->rcDisplay.top,
                 pHdr->rcDisplay.right - pHdr->rcDisplay.left,
                 pHdr->rcDisplay.bottom - pHdr->rcDisplay.top,
                 0);

    g_hwndListLayers = GetDlgItem(hDlg, IDC_LAYERS);

    EnableTabBackground(hDlg);
}

BOOL
HandleFixesDialogInit(
    HWND hDlg
    )
{
    HWND    hParent;
    DLGHDR* pHdr;
    int     nCount = 0;
    TCHAR   szColumn[MAX_PATH];

    g_hFixesDlg = hDlg;

    hParent = GetParent(hDlg);

    pHdr = (DLGHDR*)GetWindowLongPtr(hParent, DWLP_USER);

    //
    // Position the dialog within the tab.
    //
    SetWindowPos(hDlg, HWND_TOP,
                 pHdr->rcDisplay.left, pHdr->rcDisplay.top,
                 pHdr->rcDisplay.right - pHdr->rcDisplay.left,
                 pHdr->rcDisplay.bottom - pHdr->rcDisplay.top,
                 0);

    g_hwndShimList = GetDlgItem(hDlg, IDC_SHIMS);

    //
    // Set up the shim list.
    //
    LoadString(g_hInstance, IDS_FIXNAME_COLUMN, szColumn, ARRAYSIZE(szColumn));
    InsertListViewColumn(g_hwndShimList, szColumn, FALSE, 0, 200);
    LoadString(g_hInstance, IDS_CMDLINE_COLUMN, szColumn, ARRAYSIZE(szColumn));
    InsertListViewColumn(g_hwndShimList, szColumn, TRUE, 1, 59);
    LoadString(g_hInstance, IDS_MODULE_COLUMN, szColumn, ARRAYSIZE(szColumn));
    InsertListViewColumn(g_hwndShimList, szColumn, TRUE, 2, 52);

    ListView_SetExtendedListViewStyle(g_hwndShimList,
                                      LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

    //
    // Query the database and show the available general purpose fixes.
    //
    ShowAvailableFixes(g_hwndShimList);

    nCount = CountShims(FALSE);

    if (!nCount) {
        return FALSE;
    }

    ListView_SetItemCount(g_hwndShimList, nCount);

    EnableTabBackground(hDlg);

    return TRUE;
}

DLGTEMPLATE*
LockDlgRes(
    LPCTSTR lpResName
    )
{
    HRSRC hrsrc = FindResource(NULL, lpResName, RT_DIALOG);

    if (NULL == hrsrc) {
        return NULL;
    }

    HGLOBAL hglb = LoadResource(g_hInstance, hrsrc);

    if (NULL == hglb) {
        return NULL;
    }

    return (DLGTEMPLATE*)LockResource(hglb);
}

void
InitTabs(
    HWND hMainDlg,
    HWND hTab
    )
{
    DLGHDR* pHdr;
    TCITEM  tcitem;
    RECT    rcTab;
    int     nCount;
    TCHAR   szTabText[MAX_PATH];
    TCHAR   szError[MAX_PATH];

    pHdr = (DLGHDR*)HeapAlloc(GetProcessHeap(),
                              HEAP_ZERO_MEMORY,
                              sizeof(DLGHDR));

    if (NULL == pHdr) {
        LoadString(g_hInstance, IDS_TAB_SETUP_FAIL, szError, ARRAYSIZE(szError));
        MessageBox(hMainDlg, szError, g_szAppTitle, MB_ICONERROR);
        return;
    }

    //
    // Save away a pointer to the structure.
    //
    SetWindowLongPtr(hMainDlg, DWLP_USER, (LONG_PTR)pHdr);

    //
    // Save away the handle to the tab control.
    //
    pHdr->hTab = hTab;

    //
    // Add the tabs.
    //
    LoadString(g_hInstance, IDS_TAB_FIRST_TEXT, szTabText, ARRAYSIZE(szTabText));
    tcitem.mask     = TCIF_TEXT | TCIF_PARAM;
    tcitem.pszText  = szTabText;
    tcitem.lParam   = 0;
    TabCtrl_InsertItem(pHdr->hTab, 0, &tcitem);

    LoadString(g_hInstance, IDS_TAB_SECOND_TEXT, szTabText, ARRAYSIZE(szTabText));
    tcitem.pszText = szTabText;
    tcitem.lParam  = 1;
    TabCtrl_InsertItem(pHdr->hTab, 1, &tcitem);

    //
    // Lock the resources for two child dialog boxes.
    //
    pHdr->pRes[0] = LockDlgRes(MAKEINTRESOURCE(IDD_LAYERS_TAB));
    pHdr->pDlgProc[0] = LayersTabDlgProc;
    pHdr->pRes[1] = LockDlgRes(MAKEINTRESOURCE(IDD_FIXES_TAB));
    pHdr->pDlgProc[1] = FixesTabDlgProc;

    //
    // Determine the bounding rectangle for all child dialog boxes.
    //
    GetWindowRect(pHdr->hTab, &rcTab);
    TabCtrl_AdjustRect(pHdr->hTab, FALSE, &rcTab);
    InflateRect(&rcTab, 1, 1);
    rcTab.left -= 2;

    MapWindowPoints(NULL, hMainDlg, (LPPOINT)&rcTab, 2);

    pHdr->rcDisplay = rcTab;

    //
    // Create both dialog boxes.
    //
    for (nCount = 0; nCount < NUM_TABS; nCount++) {
        pHdr->hDisplay[nCount] = CreateDialogIndirect(g_hInstance,
                                                      pHdr->pRes[nCount],
                                                      hMainDlg,
                                                      pHdr->pDlgProc[nCount]);
    }
}

TCHAR*
GetRelativePath(
    TCHAR* pExeFile,
    TCHAR* pMatchFile
    )
/*++
    GetRelativePath

    Description:    Returns a relative path based on an EXE and a matching file.
                    The caller must free the memory using HeapFree.

--*/
{
    int     nLenExe = 0;
    int     nLenMatch = 0;
    TCHAR*  pExe    = NULL;
    TCHAR*  pMatch  = NULL;
    TCHAR*  pReturn = NULL;
    TCHAR   result[MAX_PATH] = { _T('\0') };
    TCHAR*  resultIdx = result;
    BOOL    bCommonBegin = FALSE; // Indicates if the paths have a common beginning

    pExe = _tcschr(pExeFile, _T('\\'));
    pMatch = _tcschr(pMatchFile, _T('\\'));

    while (pExe && pMatch) {

        nLenExe = (int)(pExe - pExeFile);
        nLenMatch = (int)(pMatch - pMatchFile);

        if (nLenExe != nLenMatch) {
            break;
        }

        if (!(_tcsnicmp(pExeFile, pMatchFile, nLenExe) == 0)) {
            break;
        }

        bCommonBegin = TRUE;
        pExeFile = pExe + 1;
        pMatchFile = pMatch + 1;

        pExe = _tcschr(pExeFile, _T('\\'));
        pMatch = _tcschr(pMatchFile, _T('\\'));
    }

    //
    // Walk the path and put '..\' where necessary
    //
    if (bCommonBegin) {

        while (pExe) {

            StringCchCopy(resultIdx, ARRAYSIZE(result), _T("..\\"));
            resultIdx = resultIdx + 3;
            pExeFile  = pExe + 1;
            pExe = _tcschr(pExeFile, _T('\\'));
        }

        StringCchCopy(resultIdx, ARRAYSIZE(result), pMatchFile);

        nLenExe = _tcslen(result) + 1;

        pReturn = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    nLenExe * sizeof(TCHAR));

        if (!pReturn) {
            return NULL;
        }

        StringCchCopy(pReturn, nLenExe, result);

        return pReturn;
    }

    return NULL;
}

void
SaveEntryToFile(
    HWND    hDlg,
    HWND    hEdit,
    LPCTSTR lpFileName
    )
/*++
    SaveEntryToFile

    Description:    Writes the XML out to a file.

--*/
{
    int     cchSize = 0;
    DWORD   cbBytesWritten;
    HANDLE  hFile = NULL;
    LPTSTR  lpData = NULL;
    TCHAR   szError[MAX_PATH];

    //
    // Determine how much space we need for the buffer, then allocate it.
    //
    cchSize = GetWindowTextLength(hEdit);

    if (cchSize) {
        //
        // Account for the additional byte & the NULL that we're storing
        // in the file.
        //
        cchSize += 2;
        lpData = (LPTSTR)HeapAlloc(GetProcessHeap(),
                                   HEAP_ZERO_MEMORY,
                                   cchSize * sizeof(TCHAR));

        if (!lpData) {
            LoadString(g_hInstance, IDS_BUFFER_ALLOC_FAIL, szError, ARRAYSIZE(szError));
            MessageBox(hDlg, szError, g_szAppTitle, MB_ICONERROR);
            return;
        }

        //
        // Ensure that the file is saved as Unicode.
        //
        lpData[0] = 0xFEFF;

        //
        // Get the text out of the text box and write it out to our file.
        //
        if (!GetWindowText(hEdit, lpData + 1, cchSize - 1)) {
            goto Cleanup;
        }

        hFile = CreateFile(lpFileName,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            LoadString(g_hInstance, IDS_FILE_CREATE_FAIL, szError, ARRAYSIZE(szError));
            MessageBox(hDlg, szError, g_szAppTitle, MB_ICONERROR);
            goto Cleanup;
        }

        WriteFile(hFile, lpData, cchSize * sizeof(TCHAR), &cbBytesWritten, NULL);

        CloseHandle(hFile);

    }

Cleanup:

    HeapFree(GetProcessHeap(), 0, lpData);

}

void
DoFileSave(
    HWND hDlg
    )
/*++
    DoFileSave

    Description:    Displays the common dialog allowing for file save.

--*/
{
    TCHAR           szFilter[MAX_PATH] = _T("");
    TCHAR           szTemp[MAX_PATH] = _T("");
    OPENFILENAME    ofn = {0};

    *szTemp = 0;

    LoadString(g_hInstance, IDS_SAVE_FILTER, szFilter, ARRAYSIZE(szFilter));

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = (LPTSTR)NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szTemp;
    ofn.nMaxFile          = sizeof(szTemp);
    ofn.lpstrTitle        = NULL;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = NULL;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = _T("xml");
    ofn.lCustData         = 0;
    ofn.Flags             = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST |
                            OFN_HIDEREADONLY  | OFN_OVERWRITEPROMPT;

    if (GetSaveFileName(&ofn)) {
        SaveEntryToFile(hDlg, GetDlgItem(hDlg, IDC_XML), szTemp);
    }
}

void
GetTopLevelWindowIntoView(
    HWND hwnd
    )
{
    RECT    rectWindow, rectScreen;
    int     nCx, nCy, nCxScreen, nCyScreen;
    int     dx = 0, dy = 0;
    HWND    hwndDesktop;

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD) {
        return;
    }

    hwndDesktop = GetDesktopWindow();

    GetWindowRect(hwnd, &rectWindow);
    GetWindowRect(hwndDesktop, &rectScreen);

    nCx = rectWindow.right  - rectWindow.left;
    nCy = rectWindow.bottom - rectWindow.top;

    nCxScreen = rectScreen.right  - rectScreen.left;
    nCyScreen = rectScreen.bottom - rectScreen.top;

    //
    // Make it fix on the x coord.
    //
    if (rectWindow.left < rectScreen.left) {
        dx = rectScreen.left - rectWindow.left;

        rectWindow.left += dx;
        rectWindow.right += dx;
    }

    if (rectWindow.right > rectScreen.right) {
        if (nCx < nCxScreen) {
            dx = rectScreen.right - rectWindow.right;

            rectWindow.left += dx;
            rectWindow.right += dx;
        }
    }

    //
    // Make it fix on the y coord.
    //
    if (rectWindow.top < rectScreen.top) {
        dy = rectScreen.top - rectWindow.top;

        rectWindow.top += dy;
        rectWindow.bottom += dy;
    }

    if (rectWindow.bottom > rectScreen.bottom) {
        if (nCy < nCyScreen) {
            dy = rectScreen.bottom - rectWindow.bottom;

            rectWindow.top += dy;
            rectWindow.bottom += dy;
        }
    }

    if (dx != 0 || dy != 0) {
        MoveWindow(hwnd, rectWindow.left, rectWindow.top, nCx, nCy, TRUE);
    }
}

void
ReplaceCmdLine(
    PFIX   pFix,
    TCHAR* pszNewCmdLine
    )
/*++
    ReplaceCmdLine

    Description:    Replaces the command line for a shim DLL.

--*/
{
    TCHAR   szError[MAX_PATH];
    int     nLen;

    if (pFix->pszCmdLine != NULL) {
        HeapFree(GetProcessHeap(), 0, pFix->pszCmdLine);
        pFix->pszCmdLine = NULL;
    }

    if (pszNewCmdLine == NULL) {
        return;

    } else if ((*pszNewCmdLine == '"') && (_tcslen(pszNewCmdLine) == 1)) {
        LoadString(g_hInstance, IDS_INVALID_CMD_LINE, szError, ARRAYSIZE(szError));
        MessageBox(g_hDlg, szError, g_szAppTitle, MB_ICONEXCLAMATION);
        return;
    }

    nLen = _tcslen(pszNewCmdLine) + 1;

    pFix->pszCmdLine = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                         HEAP_ZERO_MEMORY,
                                         nLen * sizeof(TCHAR));

    if (pFix->pszCmdLine != NULL) {
        StringCchCopy(pFix->pszCmdLine, nLen, pszNewCmdLine);
    } else {
        DPF("[ReplaceCmdLine] Failed to replace the cmd line for '%S'",
            pFix->pszName);
    }
}

void
DeselectAllShims(
    HWND hdlg
    )
/*++
    DeselectAllShims

    Description:    Removes selections for all shims listed.

--*/
{
    int     cShims, nIndex;
    LVITEM  lvi;

    //
    // Walk all the shims in the list view and deselect them.
    //
    ZeroMemory(&lvi, sizeof(lvi));

    cShims = ListView_GetItemCount(g_hwndShimList);

    for (nIndex = 0; nIndex < cShims; nIndex++) {

        PFIX pFix;

        lvi.iItem     = nIndex;
        lvi.mask      = LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = LVIS_STATEIMAGEMASK;

        ListView_GetItem(g_hwndShimList, &lvi);

        pFix = (PFIX)lvi.lParam;

        //
        // Clear the check box, removes the 'X', clear the command line,
        // and clear the modules.
        //
        ListView_SetItemText(g_hwndShimList, nIndex, 1, _T(""));
        ListView_SetItemText(g_hwndShimList, nIndex, 2, _T(""));
        ListView_SetCheckState(g_hwndShimList, nIndex, FALSE);
        ReplaceCmdLine(pFix, NULL);
        BuildModuleListForShim(pFix, BML_DELFRLISTVIEW);
    }

    //
    // Update the count of selected shims.
    //
    SetTimer(hdlg, ID_COUNT_SHIMS, 100, NULL);
}

void
AddMatchingFile(
    HWND    hdlg,
    LPCTSTR pszFullPath,
    LPCTSTR pszRelativePath,
    BOOL    bMainEXE
    )
/*++
    AddMatchingFile

    Description:    Adds a matching file and it's attributes to the tree.

--*/
{
    TVINSERTSTRUCT is;
    HTREEITEM      hParent;
    DWORD          dwCount;
    DWORD          dwAttrCount;
    TCHAR          szItem[MAX_PATH];
    PATTRINFO      pAttrInfo = NULL;

    //
    // Call the attribute manager to get all the attributes for this file.
    //
    if (!SdbGetFileAttributes(pszFullPath, &pAttrInfo, &dwAttrCount)) {
        DPF("[AddMatchingFile] Failed to get attributes for %S",
            pszFullPath);
        return;
    }

    is.hParent      = TVI_ROOT;
    is.hInsertAfter = TVI_LAST;
    is.item.lParam  = (LPARAM)pAttrInfo;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM;
    is.item.pszText = (LPTSTR)pszRelativePath;

    hParent = TreeView_InsertItem(g_hwndFilesTree, &is);

    is.hParent = hParent;

    is.item.mask    = TVIF_TEXT | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    is.item.pszText = szItem;

    is.item.iImage         = 0;
    is.item.iSelectedImage = 1;

    //
    // By default the attributes are not selected. To have them selected
    // by default you need to replace the following 1 with 2.
    //
    is.item.state          = INDEXTOSTATEIMAGEMASK(1);
    is.item.stateMask      = TVIS_STATEIMAGEMASK;

    //
    // Loop through all the attributes and show the ones that are available.
    //
    for (dwCount = 0; dwCount < dwAttrCount; dwCount++) {

        if (!SdbFormatAttribute(&pAttrInfo[dwCount], szItem, ARRAYSIZE(szItem))) {
            continue;
        }

        //
        // EXETYPE is a bogus attribute. Don't show it!
        //
        is.item.lParam = dwCount;
        TreeView_InsertItem(g_hwndFilesTree, &is);
    }

    TreeView_Expand(g_hwndFilesTree, hParent, TVE_EXPAND);
}

void
BrowseForApp(
    HWND hdlg
    )
/*++
    BrowseForApp

    Description:    Browse for the main executable for which a shim
                    will be applied.
--*/
{
    TCHAR           szFilter[MAX_PATH] = _T("");
    TCHAR           szTitle[MAX_PATH] = _T("");
    TCHAR           szExe[MAX_PATH] = _T("");
    TCHAR           szShortName[MAX_PATH] = _T("");
    OPENFILENAME    ofn = {0};
    HRESULT         hr;

    LoadString(g_hInstance, IDS_BROWSE_FILTER, szFilter, ARRAYSIZE(szFilter));
    LoadString(g_hInstance, IDS_BROWSE_TITLE, szTitle, ARRAYSIZE(szTitle));

    //
    // Use locals instead of globals because if the user cancels
    // the dialog without selecting, we'll ruin whatever app is
    // already selected.
    // rparsons - 14 Jan 02
    //
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = szExe;
    ofn.nMaxFile          = ARRAYSIZE(szExe);
    ofn.lpstrFileTitle    = szShortName;
    ofn.nMaxFileTitle     = ARRAYSIZE(szShortName);
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = _T("exe");

    if (GetOpenFileName(&ofn)) {

        TCHAR szMainEXE[128];

        g_bSDBInstalled = FALSE;

        StringCchCopy(g_szBinary, ARRAYSIZE(g_szBinary), szExe);
        StringCchCopy(g_szShortName, ARRAYSIZE(g_szShortName), szShortName);

        //
        // The parent exe defaults to the same as the EXE.
        //
        StringCchCopy(g_szParentExeName,
                      ARRAYSIZE(g_szParentExeName),
                      g_szShortName);

        StringCchCopy(g_szParentExeFullPath,
                      ARRAYSIZE(g_szParentExeFullPath),
                      g_szBinary);

        g_bSelectedParentExe = FALSE;

        SetDlgItemText(hdlg, IDC_BINARY, g_szBinary);

        EnableWindow(GetDlgItem(hdlg, IDC_ADD_MATCHING), TRUE);
        EnableWindow(GetDlgItem(hdlg, IDC_RUN), TRUE);
        EnableWindow(GetDlgItem(hdlg, IDC_CREATEFILE), TRUE);
        EnableWindow(GetDlgItem(hdlg, IDC_SHOWXML), TRUE);

        TreeView_DeleteAllItems(g_hwndFilesTree);

        hr = StringCchPrintf(szMainEXE,
                             ARRAYSIZE(szMainEXE),
                             _T("Main executable (%s)"),
                             g_szShortName);

        if (FAILED(hr)) {
            DPF("[BrowseForApp] 0x%08X Buffer too small", HRESULT_CODE(hr));
            return;
        }

        AddMatchingFile(hdlg, g_szBinary, szMainEXE, TRUE);
    }
}

void
PromptAddMatchingFile(
    HWND hdlg
    )
/*++
    PromptAddMatchingFile

    Description:    Show the open file dialog to allow the user
                    to add a matching file.
--*/
{
    TCHAR        szFullPath[MAX_PATH] = _T("");
    TCHAR        szShortName[MAX_PATH] = _T("");
    TCHAR        szFilter[MAX_PATH] = _T("");
    TCHAR        szTitle[MAX_PATH] = _T("");
    TCHAR        szParentTitle[MAX_PATH] = _T("");
    TCHAR        szInitialPath[MAX_PATH] = _T("");
    TCHAR        szDrive[_MAX_DRIVE] = _T("");
    TCHAR        szDir[_MAX_DIR] = _T("");
    TCHAR*       pMatch = NULL;
    TCHAR        szError[MAX_PATH];
    OPENFILENAME ofn = {0};

    *szInitialPath = 0;

    LoadString(g_hInstance, IDS_MATCH_FILTER, szFilter, ARRAYSIZE(szFilter));
    LoadString(g_hInstance, IDS_MATCH_TITLE, szTitle, ARRAYSIZE(szTitle));

    if (*g_szParentExeFullPath) {
        _tsplitpath(g_szParentExeFullPath, szDrive, szDir, NULL, NULL);

        StringCchCopy(szInitialPath, ARRAYSIZE(szInitialPath), szDrive);
        StringCchCat(szInitialPath, ARRAYSIZE(szInitialPath), szDir);
    }

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = szFullPath;
    ofn.nMaxFile          = ARRAYSIZE(szFullPath);
    ofn.lpstrFileTitle    = szShortName;
    ofn.nMaxFileTitle     = ARRAYSIZE(szShortName);
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = _T("exe");

    if (GetOpenFileName(&ofn)) {
        //
        // Determine if the matching file is on the same drive
        // as the EXE that was selected.
        //
        if (!PathIsSameRoot(szFullPath,
                            g_szParentExeFullPath) && !g_bSelectedParentExe) {

            TCHAR szParentFile[MAX_PATH];

            //
            // Prompt the user for the parent EXE.
            //
            *szParentFile = 0;
            *szInitialPath = 0;

            if (*szFullPath) {
                _tsplitpath(szFullPath, szDrive, szDir, NULL, NULL);
                StringCchCopy(szInitialPath, ARRAYSIZE(szInitialPath), szDrive);
                StringCchCat(szInitialPath, ARRAYSIZE(szInitialPath), szDir);
            }

            LoadString(g_hInstance,
                       IDS_PARENT_TITLE,
                       szParentTitle,
                       ARRAYSIZE(szParentTitle));

            ofn.lpstrTitle = szParentTitle;
            ofn.lpstrFile  = szParentFile;
            ofn.nMaxFile   = sizeof(szParentFile);

            if (GetOpenFileName(&ofn) == TRUE) {
                StringCchCopy(g_szParentExeName,
                              ARRAYSIZE(g_szParentExeName),
                              szShortName);

                StringCchCopy(g_szParentExeFullPath,
                              ARRAYSIZE(g_szParentExeFullPath),
                              szParentFile);

                g_bSelectedParentExe = TRUE;
            }
        }

        //
        // Check the drive letters to see which drive the match file is on
        // then calculate a relative path to the matching file.
        //
        if (PathIsSameRoot(szFullPath, g_szParentExeFullPath)) {

            pMatch = GetRelativePath(g_szParentExeFullPath, szFullPath);

        } else if (PathIsSameRoot(szFullPath, g_szBinary)) {

            pMatch = GetRelativePath(g_szBinary, szFullPath);

        } else {
            LoadString(g_hInstance, IDS_MATCH_PATH_NOT_RELATIVE, szError, ARRAYSIZE(szError));
            MessageBox(hdlg, szError, g_szAppTitle, MB_ICONEXCLAMATION);
            return;
        }

        if (pMatch) {
            //
            // Finally add the maching file and free the memory
            //
            AddMatchingFile(hdlg, szFullPath, pMatch, FALSE);

            HeapFree(GetProcessHeap(), 0, pMatch);
        }
    }
}

void
ShowAvailableFixes(
    HWND hList
    )
/*++
    ShowAvailableFixes

    Description:    Query the shim database and populate the
                    shim list with all the available shims.
--*/
{
    LVITEM lvitem;
    PFIX   pFix;
    TCHAR  szError[MAX_PATH];
    UINT   uCount = 0;

    g_pFixHead = ReadFixesFromSdb(_T("sysmain.sdb"), g_bAllShims);

    if (g_pFixHead == NULL) {
        LoadString(g_hInstance, IDS_SDB_READ_FAIL, szError, ARRAYSIZE(szError));
        MessageBox(NULL, szError, g_szAppTitle, MB_ICONERROR);
        return;
    }

    //
    // Walk the list and add all the fixes to the list view.
    //
    pFix = g_pFixHead;

    while (pFix != NULL) {

        if (pFix->dwFlags & FIX_TYPE_LAYER) {
            LPARAM lInd;

            lInd = SendMessage(g_hwndListLayers, LB_ADDSTRING, 0, (LPARAM)pFix->pszName);
            SendMessage(g_hwndListLayers, LB_SETITEMDATA, lInd, (LPARAM)pFix);
        } else {
            lvitem.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
            lvitem.lParam    = (LPARAM)pFix;
            lvitem.pszText   = pFix->pszName;
            lvitem.iItem     = ListView_GetItemCount(g_hwndShimList);
            lvitem.iSubItem  = 0;
            lvitem.state     = INDEXTOSTATEIMAGEMASK(1);
            lvitem.stateMask = LVIS_STATEIMAGEMASK;

            ListView_InsertItem(hList, &lvitem);
        }

        pFix = pFix->pNext;
    }
}

BOOL
InstallSDB(
    TCHAR* pszFileName,
    BOOL   fInstall
    )
/*++
    InstallSDB

    Description:    Launch sdbinst.exe to install or uninstall the specified SDB.

--*/
{
    HRESULT             hr;
    TCHAR               szAppName[MAX_PATH];
    TCHAR               szCmdLine[MAX_PATH];
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    //
    // Build a path to our application name and command-line.
    //
    hr = StringCchPrintf(szAppName,
                        ARRAYSIZE(szAppName),
                        _T("%s\\sdbinst.exe"),
                        g_szSysDir);

    if (FAILED(hr)) {
        DPF("[InstallSDB] 0x%08X Buffer too small (1)", HRESULT_CODE(hr));
        return FALSE;
    }

    hr = StringCchPrintf(szCmdLine,
                         ARRAYSIZE(szCmdLine),
                         fInstall ?
                          _T("\"%s\" -q \"%s\"") :
                          _T("\"%s\" -q -u \"%s\""),
                         szAppName,
                         pszFileName);

    if (FAILED(hr)) {
        DPF("[InstallSDB] 0x%08X Buffer too small (2)", HRESULT_CODE(hr));
        return FALSE;
    }

    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(si);

    DPF("[InstallSDB] AppName: %S  CmdLine: %S\n", szAppName, szCmdLine);

    if (!CreateProcess(szAppName,
                       szCmdLine,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {

        DPF("[InstallSDB] 0x%08X CreateProcess '%S %S' failed",
            szAppName,
            szCmdLine,
            GetLastError());
        return FALSE;
    }

    //
    // Wait for SDBInst to complete it's work.
    //
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return TRUE;
}

void
CreateSupportForApp(
    HWND hdlg
    )
/*++
    CreateSupportForApp

    Description:    Build an SDB for the application and offer the user
                    the chance to install it.
--*/
{
    BOOL    bok;
    TCHAR   szFileCreated[MAX_PATH];
    TCHAR   szError[MAX_PATH];
    TCHAR   szTemp[MAX_PATH];
    HRESULT hr;
    int     nAnswer;

    CleanupSupportForApp(g_szShortName);

    bok = CollectFix(g_hwndListLayers,
                     g_hwndShimList,
                     g_hwndFilesTree,
                     g_szShortName,
                     g_szBinary,
                     (g_nCrtTab == 0 ? CFF_USELAYERTAB : 0) |
                     (g_fW2K ? CFF_ADDW2KSUPPORT : 0),
                     szFileCreated);

    if (!bok) {
        LoadString(g_hInstance, IDS_FIX_CREATE_FAIL, szError, ARRAYSIZE(szError));
        MessageBox(hdlg, szError, g_szAppTitle, MB_ICONERROR);
    } else {
        LoadString(g_hInstance, IDS_CREATE_FIX, szTemp, ARRAYSIZE(szTemp));

        hr = StringCchPrintf(szError,
                             ARRAYSIZE(szError),
                             szTemp,
                             szFileCreated);

        if (FAILED(hr)) {
            DPF("[CreateSupportForApp] 0x%08X Buffer too small", HRESULT_CODE(hr));
            return;
        }

        nAnswer = MessageBox(hdlg, szError, g_szAppTitle, MB_YESNO | MB_ICONQUESTION);

        if (IDYES == nAnswer) {
            bok = InstallSDB(szFileCreated, TRUE);

            if (!bok) {
                LoadString(g_hInstance, IDS_INSTALL_FIX_FAIL, szError, ARRAYSIZE(szError));
                MessageBox(hdlg, szError, g_szAppTitle, MB_ICONERROR);
            } else {
                LoadString(g_hInstance, IDS_INSTALL_FIX_OK, szError, ARRAYSIZE(szError));
                MessageBox(hdlg, szError, g_szAppTitle, MB_ICONINFORMATION);
                g_bSDBInstalled = TRUE;
            }
        } else {
            //
            // NTRAID#583475-rparsons The user decided not to install the database.
            // Ensure that we do not remove the file that we created upon exit.
            //
            *g_szSDBToDelete = 0;
        }
    }
}

BOOL
ShowXML(
    HWND hdlg
    )
/*++
    ShowXML

    Description:    Show the XML for the current selections.

--*/
{
    BOOL    bok;
    TCHAR   szError[MAX_PATH];

    bok = CollectFix(g_hwndListLayers,
                     g_hwndShimList,
                     g_hwndFilesTree,
                     g_szShortName,
                     g_szBinary,
                     CFF_SHOWXML |
                     (g_nCrtTab == 0 ? CFF_USELAYERTAB : 0) |
                     (g_fW2K ? CFF_ADDW2KSUPPORT : 0),
                     NULL);

    if (!bok) {
        LoadString(g_hInstance, IDS_TOO_MANY_FILES, szError, ARRAYSIZE(szError));
        MessageBox(hdlg, szError, g_szAppTitle, MB_ICONEXCLAMATION);
    }

    return bok;
}

void
RunTheApp(
    HWND hdlg
    )
/*++
    RunTheApp

    Description:    Run the selected app.

--*/
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR               szFileCreated[MAX_PATH];
    TCHAR               szCmdLine[MAX_PATH];
    TCHAR               szFullCmdLine[MAX_PATH];
    TCHAR               szError[MAX_PATH];
    TCHAR               szRun[MAX_PATH];
    TCHAR*              pszCmd;
    TCHAR*              pszDir;
    TCHAR*              psz;
    BOOL                bok;
    HRESULT             hr;

    //
    // Cleanup for the previous app.
    //
    CleanupSupportForApp(g_szShortName);

    bok = CollectFix(g_hwndListLayers,
                     g_hwndShimList,
                     g_hwndFilesTree,
                     g_szShortName,
                     g_szBinary,
                     CFF_SHIMLOG |
                     CFF_APPENDLAYER |
                     (g_nCrtTab == 0 ? CFF_USELAYERTAB : 0) |
                     (g_fW2K ? CFF_ADDW2KSUPPORT : 0),
                     szFileCreated);

    if (!bok) {
        LoadString(g_hInstance, IDS_ADD_SUPPORT_FAIL, szError, ARRAYSIZE(szError));
        MessageBox(hdlg, szError, g_szAppTitle, MB_ICONERROR);
        return;
    }

    //
    // We need to install the fix for them.
    //
    if (!(InstallSDB(szFileCreated, TRUE))) {
        LoadString(g_hInstance, IDS_INSTALL_FIX_FAIL, szError, ARRAYSIZE(szError));
        MessageBox(g_hDlg, szError, g_szAppTitle, MB_ICONERROR);
        return;
    }

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    //
    // Get the command line, if there is one.
    //
    *szCmdLine = 0;
    *szFullCmdLine = 0;
    GetDlgItemText(hdlg, IDC_CMD_LINE, szCmdLine, ARRAYSIZE(szCmdLine));

    //
    // To have a proper command-line, we need to the module name.
    //
    if (*szCmdLine) {
        hr = StringCchPrintf(szFullCmdLine,
                             ARRAYSIZE(szFullCmdLine),
                             _T("%s %s"),
                             g_szBinary,
                             szCmdLine);

        if (FAILED(hr)) {
            DPF("[RunTheApp] 0x%08X Buffer too small", HRESULT_CODE(hr));
            LoadString(g_hInstance, IDS_RUNAPP_FAILED, szError, ARRAYSIZE(szError));
            MessageBox(g_hDlg, szError, g_szAppTitle, MB_ICONERROR);
            return;
        }
    }

    StringCchCopy(szRun, ARRAYSIZE(szRun), g_szBinary);

    pszCmd = szRun;
    pszDir = g_szBinary;

    //
    // We need to change the current directory or some apps won't run.
    //
    psz = pszDir + _tcslen(pszDir) - 1;

    while (psz > pszDir && *psz != _T('\\')) {
        psz--;
    }

    if (psz > pszDir) {
        *psz = 0;
        SetCurrentDirectory(pszDir);
        *psz = _T('\\');
    }

    DPF("[RunTheApp] AppName: %S  CmdLine: %S", szRun, szCmdLine);

    if (!CreateProcess(szRun,
                       *szFullCmdLine ? szFullCmdLine : NULL,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS | CREATE_SEPARATE_WOW_VDM,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {

        LoadString(g_hInstance, IDS_RUNAPP_FAILED, szError, ARRAYSIZE(szError));
        MessageBox(g_hDlg, szError, g_szAppTitle, MB_ICONERROR);
        DPF("[RunTheApp] CreateProcess failed 0x%08X", GetLastError());
    } else {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }

    //
    // Save this SDB for later so we can remove it.
    //
    StringCchCopy(g_szSDBToDelete, ARRAYSIZE(g_szSDBToDelete), szFileCreated);
}

void
ExpandCollapseDialog(
    HWND hdlg,
    BOOL bHide
    )
/*++
    ExpandCollapseDialog

    Description:    Change the current view of the dialog.

--*/
{
    TCHAR   szSimple[64];
    TCHAR   szAdvanced[64];
    int     i, nShow;
    DWORD   arrId[] = {IDC_ADD_MATCHING,
                       IDC_FILE_ATTRIBUTES_STATIC,
                       IDC_ATTRIBUTES,
                       IDC_CREATEFILE,
                       0};

    if (!bHide) {
        SetWindowPos(hdlg, NULL, 0, 0,
                     g_rcDlgBig.right - g_rcDlgBig.left,
                     g_rcDlgBig.bottom - g_rcDlgBig.top,
                     SWP_NOMOVE | SWP_NOZORDER);
        nShow = SW_SHOW;
        g_bSimpleEdition = FALSE;
        LoadString(g_hInstance, IDS_SIMPLE_TEXT, szSimple, ARRAYSIZE(szSimple));
        SetDlgItemText(hdlg, IDC_DETAILS, szSimple);
        SendDlgItemMessage(hdlg, IDC_CREATEFILE, BM_SETCHECK, BST_CHECKED, 0);

        //
        // Make sure the dialog is in view.
        //
        GetTopLevelWindowIntoView(hdlg);
    } else {
        nShow = SW_HIDE;
        g_bSimpleEdition = TRUE;
        LoadString(g_hInstance, IDS_ADVANCED_TEXT, szAdvanced, ARRAYSIZE(szAdvanced));
        SetDlgItemText(hdlg, IDC_DETAILS, szAdvanced);
        SendDlgItemMessage(hdlg, IDC_CREATEFILE, BM_SETCHECK, BST_UNCHECKED, 0);
    }

    for (i = 0; arrId[i] != 0; i++) {
        ShowWindow(GetDlgItem(hdlg, arrId[i]), nShow);
    }

    if (bHide) {
        SetWindowPos(hdlg, NULL, 0, 0,
                     g_rcDlgSmall.right - g_rcDlgSmall.left,
                     g_rcDlgSmall.bottom - g_rcDlgSmall.top,
                     SWP_NOMOVE | SWP_NOZORDER);
    }
}

void
LayerChanged(
    HWND hdlg
    )
/*++
    LayerChanged

    Description:    Changing the layer has the effect of selecting the
                    shims that the layer consists of.
--*/
{
    LRESULT   lSel;
    PFIX      pFix;
    LVITEM    lvi;
    int       nIndex, cShims = 0;

    lSel = SendMessage(g_hwndListLayers, LB_GETCURSEL, 0, 0);

    if (lSel == LB_ERR) {
        DPF("[LayerChanged] No layer selected");
        return;
    }

    pFix = (PFIX)SendMessage(g_hwndListLayers, LB_GETITEMDATA, lSel, 0);

    if (pFix->parrShim == NULL) {
        DPF("[LayerChanged] No array of DLLs");
        return;
    }

    // Remove any prior selections.
    DeselectAllShims(g_hFixesDlg);

    //
    // Loop through all the items in the shim list and make the
    // appropriate selections.
    //
    cShims = ListView_GetItemCount(g_hwndShimList);

    for (nIndex = 0; nIndex < cShims; nIndex++) {

        PFIX  pFixItem;
        int   nInd = 0;

        lvi.mask     = LVIF_PARAM;
        lvi.iItem    = nIndex;
        lvi.iSubItem = 0;

        ListView_GetItem(g_hwndShimList, &lvi);

        pFixItem = (PFIX)lvi.lParam;

        //
        // See if this shim DLL is in the array for the selected layer.
        //
        while (pFix->parrShim[nInd] != NULL) {

            if (pFix->parrShim[nInd] == pFixItem) {
                break;
            }

            nInd++;
        }

        //
        // Put a check next to this shim DLL. If he has a command line,
        // put an 'X' in the CmdLine subitem.
        //
        if (pFix->parrShim[nInd] != NULL) {
            ListView_SetCheckState(g_hwndShimList, nIndex, TRUE);
        } else {
            ListView_SetCheckState(g_hwndShimList, nIndex, FALSE);
        }

        if (pFix->parrCmdLine[nInd] != NULL) {
            ReplaceCmdLine(pFixItem, pFix->parrCmdLine[nInd]);
            ListView_SetItemText(g_hwndShimList, nIndex, 1, _T("X"));
        }

        ListView_SetItem(g_hwndShimList, &lvi);
    }

    //
    // Update the count of selected shims.
    //
    SetTimer(g_hFixesDlg, ID_COUNT_SHIMS, 100, NULL);
}

BOOL
InitMainDialog(
    HWND hdlg
    )
/*++
    InitMainDialog

    Description:    Init routine called during WM_INITDIALOG for
                    the main dialog of QFixApp.
--*/
{
    HICON      hIcon;
    RECT       rcList, rcTree;
    HIMAGELIST hImage;
    TCHAR      szText[MAX_PATH];

    //
    // Initialize globals.
    //
    g_bSDBInstalled = FALSE;
    g_szParentExeFullPath[0] = 0;
    g_szBinary[0] = 0;
    g_hDlg = hdlg;

    //
    // If we didn't get the proper command-line, disable the 'Show XML'
    // button.
    //
    if (!g_bShowXML) {
        ShowWindow(GetDlgItem(hdlg, IDC_SHOWXML), SW_HIDE);
    }

    //
    // The dialog has two views. Calculate the size of the smaller
    // view and show the simpler view by default.
    //
    GetWindowRect(hdlg, &g_rcDlgBig);

    GetWindowRect(GetDlgItem(hdlg, IDC_ATTRIBUTES), &rcList);
    GetWindowRect(GetDlgItem(hdlg, IDC_TAB_FIXES), &rcTree);

    g_rcDlgSmall.left   = g_rcDlgBig.left;
    g_rcDlgSmall.top    = g_rcDlgBig.top;
    g_rcDlgSmall.bottom = g_rcDlgBig.bottom;
    g_rcDlgSmall.right  = g_rcDlgBig.right -
                            (rcList.right - rcList.left) -
                            (rcList.left - rcTree.right);

    ExpandCollapseDialog(hdlg, TRUE);

    //
    // Disable a bunch of controls.
    //
    EnableWindow(GetDlgItem(hdlg, IDC_ADD_MATCHING), FALSE);
    EnableWindow(GetDlgItem(hdlg, IDC_REMOVE_MATCHING), FALSE);
    EnableWindow(GetDlgItem(hdlg, IDC_RUN), FALSE);
    EnableWindow(GetDlgItem(hdlg, IDC_CREATEFILE), FALSE);
    EnableWindow(GetDlgItem(hdlg, IDC_SHOWXML), FALSE);

    //
    // Show the app icon.
    //
    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));

    SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);

    g_hwndTab        = GetDlgItem(hdlg, IDC_TAB_FIXES);
    g_hwndFilesTree  = GetDlgItem(hdlg, IDC_ATTRIBUTES);

    //
    // Set up the tab control.
    //
    InitTabs(hdlg, g_hwndTab);

    hImage = ImageList_LoadImage(g_hInstance,
                                 MAKEINTRESOURCE(IDB_BMP_CHECK),
                                 16,
                                 0,
                                 CLR_DEFAULT,
                                 IMAGE_BITMAP,
                                 LR_LOADTRANSPARENT);

    if (hImage != NULL) {
        TreeView_SetImageList(g_hwndFilesTree, hImage, TVSIL_STATE);
    } else {
        DPF("[InitMainDialog] Failed to load imagelist");
    }

    //
    // Set the text for the link window.
    //
    LoadString(g_hInstance,
               g_fW2K ? IDS_W2K_LINK : IDS_XP_LINK,
               szText,
               ARRAYSIZE(szText));
    SetDlgItemText(g_hDlg, IDC_DOWNLOAD_WU, szText);

    //
    // Limit the amount of text that can be typed into the command-line
    // edit box for safety.
    //
    SendDlgItemMessage(hdlg,
                       IDC_CMD_LINE,
                       EM_LIMITTEXT,
                       (WPARAM)MAX_COMMAND_LINE,
                       0);

    //
    // Try selecting the Win95 layer.
    //
    SendMessage(g_hwndListLayers, LB_SELECTSTRING, (WPARAM)(-1), (LPARAM)_T("Win95"));

    LayerChanged(hdlg);

    TabCtrl_SetCurFocus(g_hwndTab, 0);
    ShowWindow(g_hLayersDlg, SW_SHOWNORMAL);

    return TRUE;
}

void
FileTreeToggleSelection(
    HTREEITEM hItem,
    int       uMode
    )
/*++
    FileTreeToggleSelection

    Description:    Changes the selection on the attributes tree.

--*/
{
    UINT   State;
    TVITEM item;

    switch (uMode)
    {
        case uSelect:
            State = INDEXTOSTATEIMAGEMASK(2);
            break;

        case uDeselect:
            State = INDEXTOSTATEIMAGEMASK(1);
            break;

        case uReverse:
        {
            item.mask      = TVIF_HANDLE | TVIF_STATE;
            item.hItem     = hItem;
            item.stateMask = TVIS_STATEIMAGEMASK;

            TreeView_GetItem(g_hwndFilesTree, &item);

            State = item.state & TVIS_STATEIMAGEMASK;

            if (State) {
                if (((State >> 12) & 0x03) == 2) {
                    State = INDEXTOSTATEIMAGEMASK(1);
                } else {
                    State = INDEXTOSTATEIMAGEMASK(2);
                }
            }
            break;
        }

        default:
            DPF("[FileTreeToggleSelection] Invalid mode %u", uMode);
            return;
    }

    item.mask      = TVIF_HANDLE | TVIF_STATE;
    item.hItem     = hItem;
    item.state     = State;
    item.stateMask = TVIS_STATEIMAGEMASK;

    TreeView_SetItem(g_hwndFilesTree, &item);
}

void
SelectAttrsInTree(
    BOOL fSelect
    )
/*++
    SelectAttrsInTree

    Description:    Walks each attribute in tree and reverses it's selection.

--*/
{
    HTREEITEM hItem, hChildItem;

    hItem = TreeView_GetSelection(g_hwndFilesTree);

    hChildItem = TreeView_GetChild(g_hwndFilesTree, hItem);

    FileTreeToggleSelection(hChildItem, fSelect ? uSelect : uDeselect);

    while (hChildItem) {
        hChildItem = TreeView_GetNextSibling(g_hwndFilesTree, hChildItem);
        FileTreeToggleSelection(hChildItem, fSelect ? uSelect : uDeselect);
    }
}

void
ShimListToggleSelection(
    int nItem,
    int uMode
    )
/*++
    ShimListToggleSelection

    Description:    Changes the selection on the shim list.

--*/
{
    UINT    uState;

    switch (uMode)
    {
        case uSelect:
            ListView_SetCheckState(g_hwndShimList, nItem, TRUE);
            break;

        case uDeselect:
            ListView_SetCheckState(g_hwndShimList, nItem, FALSE);
            break;

        case uReverse:

            uState = ListView_GetItemState(g_hwndShimList,
                                           nItem,
                                           LVIS_STATEIMAGEMASK);

            if (uState) {
                if (((uState >> 12) & 0x03) == 2) {
                    uState = INDEXTOSTATEIMAGEMASK(2);
                } else {
                    uState = INDEXTOSTATEIMAGEMASK(1);
                }
            }

            ListView_SetItemState(g_hwndShimList, nItem, uState,
                                  LVIS_STATEIMAGEMASK);

            break;
    }
}

void
HandleTabNotification(
    HWND   hdlg,
    LPARAM lParam
    )
/*++
    HandleTabNotification

    Description:    Handle all the notifications we care about for the tab.

--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;
    int     ind = 0;

    switch (pnm->code) {

    case TCN_SELCHANGE:
    {
        int nSel;

        DLGHDR *pHdr = (DLGHDR*)GetWindowLongPtr(hdlg, DWLP_USER);

        nSel = TabCtrl_GetCurSel(pHdr->hTab);

        if (-1 == nSel) {
            break;
        }

        g_nCrtTab = nSel;

        if (nSel == 0) {
            ShowWindow(pHdr->hDisplay[1], SW_HIDE);
            ShowWindow(pHdr->hDisplay[0], SW_SHOW);
        } else {
            ShowWindow(pHdr->hDisplay[0], SW_HIDE);
            ShowWindow(pHdr->hDisplay[1], SW_SHOW);
        }

        break;
    }

    default:
        break;
    }
}

INT_PTR CALLBACK
OptionsDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    OptionsDlgProc

    Description:    Handles messages for the options dialog.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
    {
        PFIX    pFix;
        TCHAR   szTitle[MAX_PATH];
        TCHAR   szTemp[MAX_PATH];
        TCHAR   szType[64];
        TCHAR   szModuleName[128];
        HRESULT hr;

        pFix = (PFIX)lParam;

        //
        // Limit the amount of text that can be typed into the command-line
        // and module name edit boxes for safety.
        //
        SendDlgItemMessage(hdlg,
                           IDC_SHIM_CMD_LINE,
                           EM_LIMITTEXT,
                           (WPARAM)SHIM_COMMAND_LINE_MAX_BUFFER,
                           0);

        SendDlgItemMessage(hdlg,
                           IDC_MOD_NAME,
                           EM_LIMITTEXT,
                           (WPARAM)MAX_PATH,
                           0);

        LoadString(g_hInstance, IDS_MOD_TYPE, szType, ARRAYSIZE(szType));
        LoadString(g_hInstance, IDS_MOD_NAME, szModuleName, ARRAYSIZE(szModuleName));
        LoadString(g_hInstance, IDS_OPTIONS_TITLE, szTemp, ARRAYSIZE(szTemp));

        SetWindowLongPtr(hdlg, DWLP_USER, lParam);

        EnableWindow(GetDlgItem(hdlg, IDC_REMOVE), FALSE);

        g_hwndModuleList = GetDlgItem(hdlg, IDC_MOD_LIST);

        InsertListViewColumn(g_hwndModuleList, szType, FALSE, 0, 75);
        InsertListViewColumn(g_hwndModuleList, szModuleName, FALSE, 1, 115);

        ListView_SetExtendedListViewStyle(g_hwndModuleList, LVS_EX_FULLROWSELECT);

        hr = StringCchPrintf(szTitle,
                             ARRAYSIZE(szTitle),
                             szTemp,
                             pFix->pszName);

        if (FAILED(hr)) {
            DPF("[OptionsDlgProc] 0x%08X Buffer too small", HRESULT_CODE(hr));
            return 0;
        }

        SetWindowText(hdlg, szTitle);

        if (NULL != pFix->pszCmdLine) {
            SetDlgItemText(hdlg, IDC_SHIM_CMD_LINE, pFix->pszCmdLine);
        }

        //
        // If this is a flag, disable the module include/exclude controls.
        //
        if (pFix->dwFlags & FIX_TYPE_FLAGVDM) {
            EnableWindow(g_hwndModuleList, FALSE);
            EnableWindow(GetDlgItem(hdlg, IDC_ADD), FALSE);
            EnableWindow(GetDlgItem(hdlg, IDC_REMOVE), FALSE);
            EnableWindow(GetDlgItem(hdlg, IDC_INCLUDE), FALSE);
            EnableWindow(GetDlgItem(hdlg, IDC_EXCLUDE), FALSE);
            EnableWindow(GetDlgItem(hdlg, IDC_MOD_NAME), FALSE);
        } else {
            CheckDlgButton(hdlg, IDC_INCLUDE, BST_CHECKED);

            // Add any modules to the list view.
            BuildModuleListForShim(pFix, BML_ADDTOLISTVIEW);
        }

        break;
    }

    case WM_NOTIFY:
        HandleModuleListNotification(hdlg, lParam);
        break;

    case WM_COMMAND:
        switch (wCode) {

        case IDC_ADD:
        {
            TCHAR   szModName[MAX_PATH];
            TCHAR   szError[MAX_PATH];
            UINT    uInclude, uExclude;

            GetDlgItemText(hdlg, IDC_MOD_NAME, szModName, ARRAYSIZE(szModName));

            if (*szModName == 0) {
                LoadString(g_hInstance, IDS_NO_MOD, szError, ARRAYSIZE(szError));
                MessageBox(hdlg, szError, g_szAppTitle, MB_ICONEXCLAMATION);
                SetFocus(GetDlgItem(hdlg, IDC_MOD_NAME));
                break;
            }

            uInclude = IsDlgButtonChecked(hdlg, IDC_INCLUDE);
            uExclude = IsDlgButtonChecked(hdlg, IDC_EXCLUDE);

            if ((BST_CHECKED == uInclude) || (BST_CHECKED == uExclude)) {
                AddModuleToListView(szModName, uInclude);
                SetDlgItemText(hdlg, IDC_MOD_NAME, _T(""));
                SetFocus(GetDlgItem(hdlg, IDC_MOD_NAME));
            } else {
                LoadString(g_hInstance, IDS_NO_INCEXC, szError, ARRAYSIZE(szError));
                MessageBox(hdlg, szError, g_szAppTitle, MB_ICONEXCLAMATION);
                SetFocus(GetDlgItem(hdlg, IDC_INCLUDE));
                break;
            }
            break;

        }
        case IDC_REMOVE:
        {   int nIndex;

            nIndex = ListView_GetSelectionMark(g_hwndModuleList);

            ListView_DeleteItem(g_hwndModuleList, nIndex);

            EnableWindow(GetDlgItem(hdlg, IDC_REMOVE), FALSE);

            SetFocus(GetDlgItem(hdlg, IDC_MOD_NAME));

            break;
        }
        case IDOK:
        {
            PFIX  pFix;
            TCHAR szCmdLine[1024] = _T("");

            pFix = (PFIX)GetWindowLongPtr(hdlg, DWLP_USER);

            GetDlgItemText(hdlg, IDC_SHIM_CMD_LINE, szCmdLine, 1023);

            if (*szCmdLine != 0) {
                ReplaceCmdLine(pFix, szCmdLine);
            } else {
                ReplaceCmdLine(pFix, NULL);
            }

            // Retrieve any modules from the list view.
            BuildModuleListForShim(pFix, BML_GETFRLISTVIEW);

            EndDialog(hdlg, TRUE);
            break;
        }
        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
MsgBoxDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    MsgBoxDlgProc

    Description:    Displays a message box dialog so we can use the hyperlink.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {

    case WM_INITDIALOG:
    {
        TCHAR   szLink[MAX_PATH];
        UINT    uNoSDB;

        uNoSDB = (UINT)lParam;

        //
        // Use the parameter to determine what text to display.
        //
        if (uNoSDB) {
            LoadString(g_hInstance, IDS_W2K_NO_SDB, szLink, ARRAYSIZE(szLink));
            SetDlgItemText(hdlg, IDC_MESSAGE, szLink);
        } else {
            LoadString(g_hInstance, IDS_SP2_SDB, szLink, ARRAYSIZE(szLink));
            SetDlgItemText(hdlg, IDC_MESSAGE, szLink);
        }

        LoadString(g_hInstance, IDS_MSG_LINK, szLink, ARRAYSIZE(szLink));
        SetDlgItemText(hdlg, IDC_MSG_LINK, szLink);

        break;
    }

    case WM_NOTIFY:
        if (wParam == IDC_MSG_LINK) {

            NMHDR* pHdr = (NMHDR*)lParam;

            if (pHdr->code == NM_CLICK || pHdr->code == NM_RETURN) {

                SHELLEXECUTEINFO sei = { 0 };

                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.fMask  = SEE_MASK_DOENVSUBST;
                sei.hwnd   = hdlg;
                sei.nShow  = SW_SHOWNORMAL;
                sei.lpFile = g_szW2KUrl;

                ShellExecuteEx(&sei);
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch (wCode) {

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
LayersTabDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    LayersTabDlgProc

    Description:    Handle messages for the layers tab.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        HandleLayersDialogInit(hdlg);
        break;

    case WM_COMMAND:

        if (wNotifyCode == LBN_SELCHANGE && wCode == IDC_LAYERS) {
            LayerChanged(hdlg);
            break;
        }

        switch (wCode) {

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
FixesTabDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    LayersDlgProc

    Description:    Handle messages for the fixes tab.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        if (!HandleFixesDialogInit(hdlg)) {
            EndDialog(g_hDlg, 0);
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_SHIMS) {
            HandleShimListNotification(hdlg, lParam);
        }
        break;

    case WM_TIMER:
        if (wParam == ID_COUNT_SHIMS) {
            KillTimer(hdlg, ID_COUNT_SHIMS);
            CountShims(TRUE);
        }
        break;

    case WM_COMMAND:
        switch (wCode) {

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        case IDC_CLEAR_SHIMS:
            DeselectAllShims(hdlg);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
HandleModuleListNotification(
    HWND   hdlg,
    LPARAM lParam
    )
/*++
    HandleModuleListNotification

    Description:    Handle all the notifications we care about for the
                    shim list.
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;

    switch (pnm->code) {

    case NM_CLICK:
    {
        LVHITTESTINFO lvhti;

        GetCursorPos(&lvhti.pt);
        ScreenToClient(g_hwndShimList, &lvhti.pt);

        ListView_HitTest(g_hwndShimList, &lvhti);

        //
        // If the user clicked on a list view item,
        // enable the Remove button.
        //
        if (lvhti.flags & LVHT_ONITEMLABEL) {
            EnableWindow(GetDlgItem(hdlg, IDC_REMOVE), TRUE);
        }

        break;
    }
    default:
        break;
    }
}

void
HandleShimListNotification(
    HWND   hdlg,
    LPARAM lParam
    )
/*++
    HandleShimListNotification

    Description:    Handle all the notifications we care about for the
                    shim list.
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;

    switch (pnm->code) {

    case NM_CLICK:
    {
        LVHITTESTINFO lvhti;

        GetCursorPos(&lvhti.pt);
        ScreenToClient(g_hwndShimList, &lvhti.pt);

        ListView_HitTest(g_hwndShimList, &lvhti);

        //
        // If the check box state has changed,
        // toggle the selection. Either way,
        // maintain selection as we go.
        //
        if (lvhti.flags & LVHT_ONITEMSTATEICON) {
            ShimListToggleSelection(lvhti.iItem, uReverse);
        }

        ListView_SetItemState(g_hwndShimList,
                              lvhti.iItem,
                              LVIS_FOCUSED | LVIS_SELECTED,
                              0x000F);

        SetTimer(hdlg, ID_COUNT_SHIMS, 100, NULL);
        break;
    }

    case NM_DBLCLK:
    {
        LVITEM  lvi;
        int     nItem;
        PFIX    pFix;

        nItem = ListView_GetSelectionMark(g_hwndShimList);

        if (-1 == nItem) {
            break;
        }

        lvi.mask  = LVIF_PARAM;
        lvi.iItem = nItem;

        ListView_GetItem(g_hwndShimList, &lvi);

        pFix = (PFIX)lvi.lParam;

        if ((pFix->dwFlags & FIX_TYPE_SHIM) || (pFix->dwFlags & FIX_TYPE_FLAGVDM)) {
            if (DialogBoxParam(g_hInstance,
                               MAKEINTRESOURCE(IDD_OPTIONS),
                               hdlg,
                               OptionsDlgProc,
                               (LPARAM)pFix)) {

                if (NULL != pFix->pszCmdLine) {
                    ListView_SetItemText(g_hwndShimList, nItem, 1, _T("X"));
                } else {
                    ListView_SetItemText(g_hwndShimList, nItem, 1, _T(""));
                }

                if (NULL != pFix->pModule) {
                    ListView_SetItemText(g_hwndShimList, nItem, 2, _T("X"));
                } else {
                    ListView_SetItemText(g_hwndShimList, nItem, 2, _T(""));
                }
            }
        }
        break;
    }

    case LVN_ITEMCHANGED:
    {
        LPNMLISTVIEW lpnmlv;
        PFIX         pFix;

        lpnmlv = (LPNMLISTVIEW)lParam;
        pFix = (PFIX)lpnmlv->lParam;

        //
        // Only change the text if our selection has changed.
        // If we don't do this, the text goes bye-bye when
        // the user clicks the Clear button.
        //
        if ((lpnmlv->uChanged & LVIF_STATE) &&
            (lpnmlv->uNewState & LVIS_SELECTED)) {
            SetDlgItemText(hdlg, IDC_SHIM_DESCRIPTION, pFix->pszDesc);
            ListView_SetSelectionMark(g_hwndShimList, lpnmlv->iItem);
        }
        break;
    }
    default:
        break;
    }
}

void
HandleAttributeTreeNotification(
    HWND   hdlg,
    LPARAM lParam
    )
/*++
    HandleAttributeTreeNotification

    Description:    Handle all the notifications we care about for the
                    file attributes tree.
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;

    switch (pnm->code) {

    case NM_CLICK:
    {
        TVHITTESTINFO HitTest;

        GetCursorPos(&HitTest.pt);
        ScreenToClient(g_hwndFilesTree, &HitTest.pt);

        TreeView_HitTest(g_hwndFilesTree, &HitTest);

        if (HitTest.flags & TVHT_ONITEMSTATEICON) {
            FileTreeToggleSelection(HitTest.hItem, uReverse);

        } else if (HitTest.flags & TVHT_ONITEMLABEL) {

            HWND        hwndButton;
            HTREEITEM   hItem, hRoot;

            hwndButton = GetDlgItem(hdlg, IDC_REMOVE_MATCHING);

            hItem = TreeView_GetParent(g_hwndFilesTree, HitTest.hItem);

            hRoot = TreeView_GetRoot(g_hwndFilesTree);

            //
            // If the selected item has no parent and it's not
            // the root, enable the remove matching button.
            //
            if ((NULL == hItem) && (hRoot != HitTest.hItem)) {
                EnableWindow(hwndButton, TRUE);
            } else {
                EnableWindow(hwndButton, FALSE);
            }
        }
        break;
    }

    case NM_RCLICK:
    {
        TVHITTESTINFO HitTest;
        POINT         pt;

        GetCursorPos(&HitTest.pt);

        pt.x = HitTest.pt.x;
        pt.y = HitTest.pt.y;

        ScreenToClient(g_hwndFilesTree, &HitTest.pt);

        TreeView_HitTest(g_hwndFilesTree, &HitTest);

        if (HitTest.flags & TVHT_ONITEMLABEL)
        {
            HTREEITEM hParentItem;

            TreeView_SelectItem(g_hwndFilesTree, HitTest.hItem);

            //
            // If the selected item has no parent, we assume that a
            // matching file was right-clicked.
            //
            hParentItem = TreeView_GetParent(g_hwndFilesTree, HitTest.hItem);

            if (NULL == hParentItem) {
                DisplayAttrContextMenu(&pt);
            }
        }
        break;
    }
    case TVN_KEYDOWN:
    {
        LPNMTVKEYDOWN lpKeyDown = (LPNMTVKEYDOWN)lParam;
        HTREEITEM     hItem;

        if (lpKeyDown->wVKey == VK_SPACE) {

            hItem = TreeView_GetSelection(g_hwndFilesTree);

            if (hItem != NULL) {
                FileTreeToggleSelection(hItem, uReverse);
            }
        } else if (lpKeyDown->wVKey == VK_DELETE) {

            HTREEITEM hParentItem;

            hItem = TreeView_GetSelection(g_hwndFilesTree);

            hParentItem = TreeView_GetParent(g_hwndFilesTree, hItem);

            if (hParentItem == NULL) {
                if (TreeView_GetPrevSibling(g_hwndFilesTree, hItem) != NULL) {
                    TreeView_DeleteItem(g_hwndFilesTree, hItem);
                }
            }
        }
        break;
    }
    default:
        break;
    }
}

INT_PTR CALLBACK
QFixAppDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    QFixAppDlgProc

    Description:    The dialog proc of QFixApp.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        if (!InitMainDialog(hdlg)) {
            EndDialog(hdlg, TRUE);
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_SHIMS) {
            HandleShimListNotification(hdlg, lParam);
        } else if (wParam == IDC_ATTRIBUTES) {
            HandleAttributeTreeNotification(hdlg, lParam);
        } else if (wParam == IDC_TAB_FIXES) {
            HandleTabNotification(hdlg, lParam);
        } else if (wParam == IDC_DOWNLOAD_WU) {

            NMHDR* pHdr = (NMHDR*)lParam;

            if (pHdr->code == NM_CLICK || pHdr->code == NM_RETURN) {

                SHELLEXECUTEINFO sei = { 0 };

                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.fMask  = SEE_MASK_DOENVSUBST;
                sei.hwnd   = hdlg;
                sei.nShow  = SW_SHOWNORMAL;

                if (g_fW2K) {
                    sei.lpFile = g_szW2KUrl;
                } else if (g_fNETServer) {
                    sei.lpFile = g_szNETUrl;
                } else {
                    sei.lpFile = g_szXPUrl;
                }

                ShellExecuteEx(&sei);
                break;
            }
        }
        break;

    case WM_DESTROY:
    {
        DLGHDR* pHdr;

        //
        // Destory the dialogs and remove any misc files.
        //
        pHdr = (DLGHDR*)GetWindowLongPtr(hdlg, DWLP_USER);

        DestroyWindow(pHdr->hDisplay[0]);
        DestroyWindow(pHdr->hDisplay[1]);

        CleanupSupportForApp(g_szShortName);

        break;
    }

    case WM_COMMAND:

        if (wNotifyCode == LBN_SELCHANGE && wCode == IDC_LAYERS) {
            LayerChanged(hdlg);
            break;
        }

        switch (wCode) {

        case IDC_RUN:
            RunTheApp(hdlg);
            break;

        case IDC_BROWSE:
            BrowseForApp(hdlg);
            break;

        case IDC_DETAILS:
            ExpandCollapseDialog(hdlg, !g_bSimpleEdition);
            break;

        case IDC_CREATEFILE:
            CreateSupportForApp(hdlg);
            break;

        case IDC_SHOWXML:
            ShowXML(hdlg);
            break;

        case IDC_ADD_MATCHING:
            PromptAddMatchingFile(hdlg);
            break;

        case IDC_VIEW_LOG:
            ShowShimLog();
            break;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        case IDM_SELECT_ALL:
            SelectAttrsInTree(TRUE);
            break;

        case IDM_CLEAR_ALL:
            SelectAttrsInTree(FALSE);
            break;

        case IDC_REMOVE_MATCHING:
        {
            HTREEITEM   hParentItem, hItem;
            TCHAR       szError[MAX_PATH];

            hItem = TreeView_GetSelection(g_hwndFilesTree);

            if (NULL == hItem) {
                LoadString(g_hInstance, IDS_NO_SELECTION, szError, ARRAYSIZE(szError));
                MessageBox(hdlg, szError, g_szAppTitle, MB_ICONEXCLAMATION);
                return TRUE;
            }

            hParentItem = TreeView_GetParent(g_hwndFilesTree, hItem);

            if (hParentItem == NULL) {
                if (TreeView_GetPrevSibling(g_hwndFilesTree, hItem) != NULL) {
                    TreeView_DeleteItem(g_hwndFilesTree, hItem);
                    EnableWindow(GetDlgItem(hdlg, IDC_REMOVE_MATCHING), FALSE);
                }
            }
            break;
        }

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
QFixAppInitialize(
    void
    )
/*++
    QFixAppInitialize

    Description:    Initializes common paths, etc.

--*/
{
    UINT                    cchSize;
    INITCOMMONCONTROLSEX    icex;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES | ICC_TAB_CLASSES;

    //
    // Initialize the common controls.
    //
    if (!InitCommonControlsEx(&icex)) {
        InitCommonControls();
    }

    //
    // Set up our hyperlink control.
    //
    LinkWindow_RegisterClass();

    //
    // Save away common paths for later use.
    //
    cchSize = GetSystemDirectory(g_szSysDir, ARRAYSIZE(g_szSysDir));

    if (cchSize > ARRAYSIZE(g_szSysDir) || cchSize == 0) {
        DPF("[QFixAppInitialize] 0x%08X Failed to get system directory",
            GetLastError());
        return FALSE;
    }

    cchSize = GetSystemWindowsDirectory(g_szWinDir, ARRAYSIZE(g_szWinDir));

    if (cchSize > ARRAYSIZE(g_szWinDir) || cchSize == 0) {
        DPF("[QFixAppInitialize] 0x%08X Failed to get windows directory",
            GetLastError());
        return FALSE;
    }

    return TRUE;
}

int WINAPI
wWinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPTSTR    lpszCmd,
    int       swShow
    )
/*++
    WinMain

    Description:    Application entry point.

--*/
{
    BOOL                    fSP2 = FALSE;
    TCHAR                   szError[MAX_PATH];
    OSVERSIONINFOEX         osviex;

    LoadString(g_hInstance, IDS_APP_TITLE, g_szAppTitle, ARRAYSIZE(g_szAppTitle));

    g_hInstance = hInst;

    osviex.dwOSVersionInfoSize = sizeof(osviex);

    GetVersionEx((OSVERSIONINFO*)&osviex);

    //
    // See if they're an administrator - bail if not.
    //
    if (!(IsUserAnAdministrator())) {
        LoadString(g_hInstance, IDS_NOT_ADMIN, szError, ARRAYSIZE(szError));
        MessageBox(NULL, szError, g_szAppTitle, MB_ICONERROR);
        return 0;
    }

    //
    // See if we're running on Windows 2000, then check for SP2, then
    // check for .NET Server.
    //
    if ((osviex.dwMajorVersion == 5 && osviex.dwMinorVersion == 0)) {
        g_fW2K = TRUE;
    }

    if (g_fW2K && (!_tcscmp(osviex.szCSDVersion, _T("Service Pack 2")))) {
        fSP2 = TRUE;
    }

    if (!(osviex.wProductType == VER_NT_WORKSTATION)) {
        g_fNETServer = TRUE;
    }

    //
    // Perform some necessary initialization.
    //
    if (!QFixAppInitialize()) {
        LoadString(g_hInstance, IDS_INIT_FAILED, szError, ARRAYSIZE(szError));
        MessageBox(GetDesktopWindow(), szError, g_szAppTitle, MB_ICONERROR);
        return 0;
    }

    //
    // Attempt to locate the SDB in the AppPatch directory.
    //
    if (!CheckForSDB()) {
        if (g_fW2K) {
            DialogBoxParam(hInst,
                           MAKEINTRESOURCE(IDD_MSGBOX_SDB),
                           GetDesktopWindow(),
                           MsgBoxDlgProc,
                           (LPARAM)1);
            return 0;
        } else {
            LoadString(g_hInstance, IDS_XP_NO_SDB, szError, ARRAYSIZE(szError));
            MessageBox(GetDesktopWindow(), szError, g_szAppTitle, MB_ICONEXCLAMATION);
            return 0;
        }
    }

    //
    // If this is SP2, and the SDB is older, bail out.
    //
    if (fSP2) {
        if (IsSDBFromSP2()) {
            DialogBoxParam(hInst,
                           MAKEINTRESOURCE(IDD_MSGBOX_SP2),
                           GetDesktopWindow(),
                           MsgBoxDlgProc,
                           (LPARAM)0);
            return 0;
        }
    }

    //
    // Check for command line options.
    //
    if (lpszCmd) {
        DPF("[WinMain] Command line '%S'", lpszCmd);

        while (*lpszCmd) {
            if (*lpszCmd == _T('a') || *lpszCmd == _T('A')) {
                g_bAllShims = TRUE;
            }
            else if (*lpszCmd == _T('x') || *lpszCmd == _T('X')) {
                g_bShowXML = TRUE;
            }

            lpszCmd++;
        }
    }

    DialogBox(hInst,
              MAKEINTRESOURCE(IDD_DIALOG),
              GetDesktopWindow(),
              QFixAppDlgProc);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\sdbinst\resource.h ===
#define IDS_APP_TITLE                       500
#define IDS_APP_ERROR_TITLE                 501


#define IDS_HELP_TEXT                       1000
#define IDS_UNABLE_TO_GET_FILE              1001
#define IDS_UNABLE_TO_OPEN_FILE             1002
#define IDS_NO_DB_TAG                       1003
#define IDS_NO_DB_ID                        1004
#define IDS_CANT_INSTALL_SYS                1005
#define IDS_ALREADY_INSTALLED               1006
#define IDS_NOT_INSTALLED                   1007
#define IDS_NEED_INSTALL_PERMISSION         1008
#define IDS_CANT_CREATE_REG_KEY             1009
#define IDS_NO_EXE_NAME                     1010
#define IDS_NO_EXE_NAME_PTR                 1011
#define IDS_CANT_CREATE_VALUE               1012
#define IDS_NEED_UNINSTALL_PERMISSION       1013
#define IDS_CANT_OPEN_REG_KEY               1014
#define IDS_CANT_DELETE_REG_KEY             1015
#define IDS_CANT_DELETE_REG_VALUE           1016
#define IDS_CANT_COPY_FILE                  1017
#define IDS_CANT_DELETE_FILE                1018
#define IDS_INSTALL_COMPLETE                1019
#define IDS_UNINSTALL_COMPLETE              1020
#define IDS_CANT_GET_ARGS                   1021
#define IDS_INVALID_SWITCH                  1022
#define IDS_TOO_MANY_ARGS                   1023
#define IDS_MUST_SPECIFY_SDB                1024
#define IDS_CANT_GET_FULL_PATH              1025
#define IDS_FOUND_SAME_ID                   1026
#define IDS_FAILED_UNINSTALL                1027
#define IDS_NEED_ARG                        1028
#define IDS_NO_FRIENDLY_NAME                1029
#define IDS_GUID_BAD_FORMAT                 1030
#define IDS_MISSING_PACKAGE_ID              1031
#define IDS_BUFFER_TOO_SMALL                1032
#define IDS_CANT_REGISTER_DB                1033
#define IDS_CANT_UNREGISTER_DB              1034
#define IDS_CANT_ALLOC_ALLUSERDIR           1035
#define IDS_CANT_GET_SIZEOF_ALLUSERDIR      1036
#define IDS_CANT_GET_ALLUSERDIR             1037
#define IDS_OBJECT_ALREADY_EXISTS           1038
#define IDS_CANT_CREATE_DIRECTORY           1039
#define IDS_CANT_SET_ACLS                   1040
#define IDS_CANT_EXPAND_DIR                 1041
#define IDS_CANT_SET_REG_VALUE              1042
#define IDS_NO_PATCHES_ALLOWED              1043
#define IDS_ARG_TOO_LONG                    1044
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\qfixapp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by QFixApp.rc
//
#define IDS_MATCH_PATH_NOT_RELATIVE     1
#define IDS_BUFFER_ALLOC_FAIL           2
#define IDS_FILE_CREATE_FAIL            3
#define IDC_ADD                         3
#define IDS_SDB_READ_FAIL               4
#define IDC_REMOVE                      4
#define IDS_FIX_CREATE_FAIL             5
#define IDS_TOO_MANY_FILES              6
#define IDS_ADD_SUPPORT_FAIL            7
#define IDS_LAYER_SELECT                9
#define IDS_NO_LOGFILE                  10
#define IDS_NO_SELECTION                12
#define IDS_NO_MOD                      13
#define IDS_NO_INCEXC                   14
#define IDS_W2K_NO_SDB                  15
#define IDS_SP2_SDB                     16
#define IDS_CREATE_FIX                  17
#define IDS_INSTALL_FIX_FAIL            18
#define IDS_INSTALL_FIX_OK              19
#define IDS_W2K_LINK                    21
#define IDS_XP_LINK                     22
#define IDS_NO_16BIT                    23
#define IDS_NOT_ADMIN                   24
#define IDS_MSG_LINK                    25
#define IDS_INVALID_CMD_LINE            26
#define IDS_TAB_FIRST_TEXT              27
#define IDS_TAB_SECOND_TEXT             28
#define IDS_INCLUDE_HDR                 29
#define IDS_EXCLUDE_HDR                 30
#define IDS_SEL_CAPTION                 31
#define IDS_FIXNAME_COLUMN              32
#define IDS_CMDLINE_COLUMN              33
#define IDS_MODULE_COLUMN               34
#define IDS_XP_NO_SDB                   35
#define IDS_SAVE_FILTER                 36
#define IDS_APP_TITLE                   37
#define IDS_BROWSE_FILTER               38
#define IDS_BROWSE_TITLE                39
#define IDS_MATCH_FILTER                40
#define IDS_MATCH_TITLE                 41
#define IDS_PARENT_TITLE                42
#define IDS_SIMPLE_TEXT                 43
#define IDS_ADVANCED_TEXT               44
#define IDS_MOD_TYPE                    45
#define IDS_MOD_NAME                    46
#define IDS_OPTIONS_TITLE               47
#define IDS_TAB_SETUP_FAIL              48
#define IDS_REPLACE_FILE                49
#define IDS_NO_DESCR_AVAIL              50
#define IDS_RUNAPP_FAILED               51
#define IDS_INIT_FAILED                 52
#define IDD_DIALOG                      101
#define IDI_ICON                        102
#define IDD_XML                         103
#define IDB_BMP_CHECK                   104
#define IDM_ATTR_POPUP                  106
#define IDD_OPTIONS                     109
#define IDD_MSGBOX_SDB                  111
#define IDI_EXCLAIM                     112
#define IDD_MSGBOX_SP2                  113
#define IDD_LAYERS_TAB                  114
#define IDD_FIXES_TAB                   115
#define IDC_BINARY                      1000
#define IDC_XML                         1000
#define IDC_BROWSE                      1001
#define IDC_MOD_LIST                    1001
#define IDC_SHIMS                       1002
#define IDC_SHIM_DESCRIPTION            1003
#define IDC_RUN                         1004
#define IDC_DETAILS                     1005
#define IDC_ATTRIBUTES                  1007
#define IDC_REMOVE_MATCHING             1008
#define IDC_FILE_ATTRIBUTES_STATIC      1009
#define IDC_CREATEFILE                  1010
#define IDC_SHOWXML                     1011
#define IDC_SELECTED_SHIMS              1012
#define IDC_TAB_FIXES                   1014
#define IDC_CMD_LINE                    1015
#define IDC_VIEW_LOG                    1016
#define IDC_LAYERS                      1018
#define IDC_CLEAR_SHIMS                 1022
#define IDC_SHIM_CMD_LINE               1023
#define IDC_ADD_MATCHING                1024
#define IDC_SAVE_XML                    1026
#define IDC_MOD_NAME                    1032
#define IDC_DOWNLOAD_WU                 1033
#define IDC_INCLUDE                     1038
#define IDC_EXCLUDE                     1039
#define IDC_MESSAGE                     1043
#define IDC_MSG_LINK                    1044
#define IDC_SDB_XML                     1050
#define IDC_DISPLAY_XML                 1051
#define IDM_SELECT_ALL                  40003
#define IDM_CLEAR_ALL                   40004

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1052
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\sdbinst\sdbinst.cpp ===
/*--

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sdbinst.cpp

Abstract:

    installs custom SDB files into AppPatch\Custom, and adds registry entries to point
    to them

Author:

    dmunsil 12/29/2000

Revision History:

    Many people contributed over time.
    (in alphabetical order: clupu, dmunsil, rparsons, vadimb)
    
Notes:



--*/

#define _UNICODE

#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _WINDOWS
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <aclapi.h>

#include "resource.h"

extern "C" {
#include "shimdb.h"
}

//
// DJM - turning off strsafe deprecation for now, but all of these deprecated functions
// should be replaced.
//
#include <strsafe.h>


BOOL    g_bQuiet;
BOOL    g_bWin2K;
WCHAR   g_wszCustom[MAX_PATH];

BOOL    g_bAllowPatches = FALSE;

HINSTANCE g_hInst;

HANDLE  g_hLogFile = INVALID_HANDLE_VALUE;

typedef enum _INSTALL_MODE {
    MODE_INSTALL,
    MODE_UNINSTALL,
    MODE_CLEANUP,
    MODE_CONVERT_FORMAT_NEW,
    MODE_CONVERT_FORMAT_OLD
} INSTALL_MODE;

#define UNINSTALL_KEY_PATH  L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\"
#define APPCOMPAT_KEY       L"System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

DWORD g_dwWow64Key = (DWORD)-1;

UINT
SdbGetWindowsDirectory(
    LPWSTR pwszBuffer,
    DWORD  dwSize
    )
{
    pwszBuffer[0] = 0;

    UINT unRet = GetSystemWindowsDirectoryW(pwszBuffer, dwSize);

    if (!unRet) {
        goto out;
    }

    if (unRet >= dwSize) {
        unRet++;
        goto out;
    }

    //
    // throw a backslash on there if it's not already there
    //
    if (pwszBuffer[unRet - 1] != L'\\') {
        pwszBuffer[unRet] = L'\\';
        unRet++;
        pwszBuffer[unRet] = 0;
    }

out:
    return unRet;
}

void
__cdecl
vPrintError(
    UINT unRes,
    ...
    )
{
    WCHAR   szT[1024];
    WCHAR   wszFormat[1024];
    WCHAR   wszCaption[1024];
    va_list arglist;

    if (!g_bQuiet) {
        if (!LoadStringW(g_hInst, IDS_APP_ERROR_TITLE, wszCaption, ARRAYSIZE(wszCaption))) {
            return;
        }
        
        if (LoadStringW(g_hInst, unRes, wszFormat, ARRAYSIZE(wszFormat))) {
            va_start(arglist, unRes);
            StringCchVPrintfW(szT, ARRAYSIZE(szT), wszFormat, arglist);
            va_end(arglist);

            MessageBoxW(NULL, szT, wszCaption, MB_OK | MB_ICONWARNING);
        }
    }
}

void
__cdecl
vPrintMessage(
    UINT unRes,
    ...
    )
{
    WCHAR   szT[1024];
    WCHAR   wszFormat[1024];
    WCHAR   wszCaption[1024];
    va_list arglist;

    if (!g_bQuiet) {
        if (!LoadStringW(g_hInst, IDS_APP_TITLE, wszCaption, ARRAYSIZE(wszCaption))) {
            return;
        }
        
        if (LoadStringW(g_hInst, unRes, wszFormat, ARRAYSIZE(wszFormat))) {
            va_start(arglist, unRes);
            StringCchVPrintfW(szT, ARRAYSIZE(szT), wszFormat, arglist);
            va_end(arglist);

            MessageBoxW(NULL, szT, wszCaption, MB_OK | MB_ICONINFORMATION);
        }
    }
}

void
__cdecl
vLogMessage(
    LPCSTR pwszFormat,
    ...
    )
{
    CHAR    szT[1024];
    va_list arglist;
    int     nLength;

    va_start(arglist, pwszFormat);
    StringCchVPrintfA(szT, CHARCOUNT(szT), pwszFormat, arglist);
    nLength = strlen(szT);
    
    va_end(arglist);

    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        DWORD dwWritten;
        WriteFile(g_hLogFile, (LPVOID)szT, (DWORD)nLength, &dwWritten, NULL);
    }

    OutputDebugStringA(szT);
}

DWORD
GetWow64Flag(
    void
    )
{
    if (g_dwWow64Key == (DWORD)-1) {
        if (g_bWin2K) {
            g_dwWow64Key = 0; // no flag since there is no wow64 on win2k
        } else {
            g_dwWow64Key = KEY_WOW64_64KEY;
        }
    }

    return g_dwWow64Key;
}

VOID
OpenLogFile(
    VOID
    )
{
    WCHAR wszLogFile[MAX_PATH];

    SdbGetWindowsDirectory(wszLogFile, ARRAYSIZE(wszLogFile));
    StringCchCatW(wszLogFile, ARRAYSIZE(wszLogFile), L"AppPatch\\SdbInst.Log");

    g_hLogFile = CreateFileW(wszLogFile,
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
}

VOID
CloseLogFile(
    VOID
    )
{
    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hLogFile);
    }
    g_hLogFile = INVALID_HANDLE_VALUE;
}

void
vPrintHelp(
    WCHAR* szAppName
    )
{
    vPrintMessage(IDS_HELP_TEXT, szAppName);
}

typedef void (CALLBACK *pfn_ShimFlushCache)(HWND, HINSTANCE, LPSTR, int);

void
vFlushCache(
    void
    )
{
    HMODULE hAppHelp;
    pfn_ShimFlushCache pShimFlushCache;


    hAppHelp = LoadLibraryW(L"apphelp.dll");
    if (hAppHelp) {
        pShimFlushCache = (pfn_ShimFlushCache)GetProcAddress(hAppHelp, "ShimFlushCache");
        if (pShimFlushCache) {
            pShimFlushCache(NULL, NULL, NULL, 0);
        }
    }
}

BOOL
bSearchGroupForSID(
    DWORD dwGroup,
    BOOL* pfIsMember
    )
{
    PSID                     pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {
        return FALSE;
    }

    if (!pSID) {
        return FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

BOOL
bCanRun(
    void
    )
{
    BOOL fIsAdmin;

    if (!bSearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin))
    {
        return FALSE;
    }

    return fIsAdmin;
}

WCHAR*
wszGetFileFromPath(
    WCHAR* wszPath
    )
{
    WCHAR* szTemp = wcsrchr(wszPath, L'\\');
    
    if (szTemp) {
        return szTemp + 1;
    }

    return NULL;
}

BOOL
bIsAlreadyInstalled(
    WCHAR* wszPath
    )
{
    DWORD dwCustomLen;
    DWORD dwInputLen;
    DWORD dwPos;

    dwCustomLen = wcslen(g_wszCustom);
    dwInputLen = wcslen(wszPath);

    if (_wcsnicmp(wszPath, g_wszCustom, dwCustomLen) != 0) {
        //
        // it's not in the custom directory
        //
        return FALSE;
    }

    for (dwPos = dwCustomLen; dwPos < dwInputLen; ++dwPos) {
        if (wszPath[dwPos] == L'\\') {
            //
            // it's in a subdirectory of Custom,
            //
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
bGuidToPath(
    GUID*   pGuid,
    WCHAR*  wszPath,
    DWORD   dwPathSize
    )
{
    UNICODE_STRING ustrGuid;
    HRESULT hr1, hr2, hr3;

    if (!NT_SUCCESS(RtlStringFromGUID(*pGuid, &ustrGuid))) {
        return FALSE;
    }
    
    hr1 = StringCchCopyW(wszPath, dwPathSize, g_wszCustom);
    hr2 = StringCchCatW(wszPath, dwPathSize, ustrGuid.Buffer);
    hr3 = StringCchCatW(wszPath, dwPathSize, L".sdb");

    RtlFreeUnicodeString(&ustrGuid);

    if (FAILED(hr1) || FAILED(hr2) || FAILED(hr3)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
bGetGuid(
    WCHAR* wszSDB,
    GUID*  pGuid
    )
{
    PDB     pdb = NULL;
    TAGID   tiDatabase;
    TAGID   tiID;
    BOOL    bRet = FALSE;

    pdb = SdbOpenDatabase(wszSDB, DOS_PATH);
    
    if (!pdb) {
        vPrintError(IDS_UNABLE_TO_OPEN_FILE, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    
    if (!tiDatabase) {
        vPrintError(IDS_NO_DB_TAG, wszSDB);
        bRet = FALSE;
        goto out;
    }

    ZeroMemory(pGuid, sizeof(GUID));
    tiID = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);
    
    if (tiID) {
        if (SdbReadBinaryTag(pdb, tiID, (PBYTE)pGuid, sizeof(GUID))) {
            bRet = TRUE;
        }
    }

    if (!bRet) {
        vPrintError(IDS_NO_DB_ID, wszSDB);
    }

out:
    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    return bRet;
}

typedef enum _TIME_COMPARE {
    FILE_NEWER,
    FILE_SAME,
    FILE_OLDER
} TIME_COMPARE;

BOOL
bOldSdbInstalled(
    WCHAR* wszPath,
    WCHAR* wszOldPath,
    DWORD  dwOldPathSize
    )
{
    WIN32_FIND_DATAW FindData;
    GUID    guidMain;
    BOOL    bRet = FALSE;
    HANDLE  hFind;

    //
    // get the guid from the DB we're installing
    //
    if (!bGetGuid(wszPath, &guidMain)) {
        //
        // there's no info in this DB, so no way to tell.
        //
        return FALSE;
    }

    //
    // get the path to the current file
    //
    if (!bGuidToPath(&guidMain, wszOldPath, dwOldPathSize)) {
        //
        // couldn't convert to path
        //
        return FALSE;
    }

    //
    // check to see if the file exists
    //
    hFind = FindFirstFileW(wszOldPath, &FindData);
    
    if (hFind != INVALID_HANDLE_VALUE) {
        //
        // yup
        //
        bRet = TRUE;
        FindClose(hFind);
    }

    return bRet;
}

BOOL 
IsKnownDatabaseGUID(
    GUID* pGuid
    )
{
    const GUID* rgpGUID[] = {
        &GUID_SYSMAIN_SDB,
        &GUID_APPHELP_SDB,
        &GUID_SYSTEST_SDB,
        &GUID_DRVMAIN_SDB,
        &GUID_MSIMAIN_SDB
    };

    int i;
    
    for (i = 0; i < ARRAYSIZE(rgpGUID); ++i) {
        if (*rgpGUID[i] == *pGuid) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
DatabaseContainsPatch(
    WCHAR* wszSDB
    )
{
    PDB     pdb = NULL;
    TAGID   tiDatabase = TAGID_NULL;
    TAGID   tiLibrary = TAGID_NULL;
    TAGID   tiPatch = TAGID_NULL;
    BOOL    bRet = FALSE;

    pdb = SdbOpenDatabase(wszSDB, DOS_PATH);
    
    if (!pdb) {
        vPrintError(IDS_UNABLE_TO_OPEN_FILE, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    
    if (!tiDatabase) {
        vPrintError(IDS_NO_DB_TAG, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);
    if (!tiLibrary) {
        //
        // this isn't an error -- no library just means no patches
        //
        bRet = FALSE;
        goto out;
    }

    tiPatch = SdbFindFirstTag(pdb, tiLibrary, TAG_PATCH);
    if (tiPatch) {
        bRet = TRUE;
    } else {
        bRet = FALSE;
    }

out:
    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    return bRet;
}

BOOL
bGetInternalNameAndID(
    WCHAR*  wszSDB,
    WCHAR*  wszInternalName,
    DWORD   dwInternalNameSize,
    GUID*   pGuid
    )
{
    PDB     pdb = NULL;
    TAGID   tiDatabase;
    TAGID   tiName;
    TAGID   tiID;
    BOOL    bRet = FALSE;
    WCHAR*  wszTemp;

    pdb = SdbOpenDatabase(wszSDB, DOS_PATH);
    
    if (!pdb) {
        vPrintError(IDS_UNABLE_TO_OPEN_FILE, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    
    if (!tiDatabase) {
        vPrintError(IDS_NO_DB_TAG, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiName = SdbFindFirstTag(pdb, tiDatabase, TAG_NAME);
    
    if (tiName) {
        wszTemp = SdbGetStringTagPtr(pdb, tiName);
    }

    if (wszTemp) {
        StringCchCopyW(wszInternalName, dwInternalNameSize, wszTemp);
    } else {
        wszInternalName[0] = 0;
    }

    ZeroMemory(pGuid, sizeof(GUID));
    tiID = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);
    
    if (!tiID) {
        bRet = FALSE;
        goto out;
    }

    if (!SdbReadBinaryTag(pdb, tiID, (PBYTE)pGuid, sizeof(GUID))) {
        bRet = FALSE;
        goto out;
    }

    bRet = TRUE;

out:
    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    return bRet;
}


BOOL
bFriendlyNameToFile(
    WCHAR*  wszFriendlyName,
    WCHAR*  wszFile,
    DWORD   dwFileSize,
    WCHAR*  wszPath,
    DWORD   dwPathSize
    )
{
    WCHAR            wszSearchPath[MAX_PATH];
    WIN32_FIND_DATAW FindData;
    BOOL             bRet = FALSE;
    WCHAR            wszInternalTemp[256];
    WCHAR            wszFileTemp[MAX_PATH];
    GUID             guidTemp;
    HANDLE           hFind;

    StringCchCopyW(wszSearchPath, ARRAYSIZE(wszSearchPath), g_wszCustom);
    StringCchCatW(wszSearchPath, ARRAYSIZE(wszSearchPath), L"*.sdb");

    hFind = FindFirstFileW(wszSearchPath, &FindData);
    
    if (hFind == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    while (hFind != INVALID_HANDLE_VALUE) {

        StringCchCopyW(wszFileTemp, ARRAYSIZE(wszFileTemp), g_wszCustom);
        StringCchCatW(wszFileTemp, ARRAYSIZE(wszFileTemp), FindData.cFileName);

        if (!bGetInternalNameAndID(wszFileTemp, wszInternalTemp, ARRAYSIZE(wszInternalTemp), &guidTemp)) {
            goto nextFile;
        }
        
        if (_wcsicmp(wszInternalTemp, wszFriendlyName) == 0) {
            bRet = TRUE;
            StringCchCopyW(wszFile, dwFileSize, FindData.cFileName);
            StringCchCopyW(wszPath, dwPathSize, wszFileTemp);
            FindClose(hFind);
            break;
        }

nextFile:
        if (!FindNextFileW(hFind, &FindData)) {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    return bRet;

}

BOOL
bFindInstallName(
    WCHAR* wszPath,
    WCHAR* wszInstallPath,
    DWORD  dwInstallPathSize
    )
{
    GUID guidMain;

    //
    // get the guid from the DB we're installing
    //
    if (!bGetGuid(wszPath, &guidMain)) {
        //
        // there's no info in this DB, so no way to tell.
        //
        return FALSE;
    }

    //
    // get the path to the current file
    //
    if (!bGuidToPath(&guidMain, wszInstallPath, dwInstallPathSize)) {
        //
        // couldn't convert to path
        //
        return FALSE;
    }

    return TRUE;
}

//
// this function is necessary because RegDeleteKey doesn't work right with
// a 32-bit app deleting 64-bit reg keys
//
LONG
LocalRegDeleteKeyW (
    IN HKEY    hKey,
    IN LPCWSTR lpSubKey
    )
{
    LONG  lRes;
    HKEY  hSubKey    = NULL;

    lRes = RegOpenKeyExW(hKey,
                         lpSubKey,
                         0,
                         KEY_ALL_ACCESS|GetWow64Flag(),
                         &hSubKey);
    if (lRes != ERROR_SUCCESS) {
        return lRes;
    }

    lRes = NtDeleteKey(hSubKey);

    RegCloseKey(hSubKey);

    return lRes;
}

VOID
InstallW2KData(
    WCHAR*  pszEntryName,
    LPCWSTR pszGuidDB
    )
{
    HKEY  hKey;
    WCHAR wszRegPath[MAX_PATH * 2];
    DWORD dwDisposition, cbData;
    LONG  lResult = 0;
    BYTE  data[16] = {0x0c, 0, 0, 0, 0, 0, 0, 0,
                      0x06, 0, 0, 0, 0, 0, 0, 0};
    HRESULT hr;

    //
    // This is Windows 2000 - attempt to add custom SDB specific data.
    //
    hr = StringCchPrintfW(wszRegPath, ARRAYSIZE(wszRegPath), L"%s\\%s", APPCOMPAT_KEY, pszEntryName);
    if (FAILED(hr)) {
        vPrintError(IDS_BUFFER_TOO_SMALL);
        return;
    }

    lResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                              wszRegPath,
                              0,
                              NULL,
                              0,
                              KEY_SET_VALUE,
                              NULL,
                              &hKey,
                              &dwDisposition);

    if (ERROR_SUCCESS != lResult) {
        if (ERROR_ACCESS_DENIED == lResult) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
            return;
        } else {
            vPrintError(IDS_CANT_CREATE_REG_KEY, pszEntryName);
            return;
        }
    }

    //
    // Set the registry values.
    //
    lResult = RegSetValueExW(hKey,
                             pszGuidDB,
                             0,
                             REG_BINARY,
                             data,
                             sizeof(data));

    if (ERROR_SUCCESS != lResult) {
        
        RegCloseKey(hKey);
        
        if (ERROR_ACCESS_DENIED == lResult) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
        } else {
            vPrintError(IDS_CANT_SET_REG_VALUE, pszEntryName);
        }
        return;
    }

    data[0] = 0;

    hr = StringCchPrintfW(wszRegPath, ARRAYSIZE(wszRegPath), L"DllPatch-%s", pszGuidDB);
    if (FAILED(hr)) {
        vPrintError(IDS_BUFFER_TOO_SMALL);
        return;
    }

    lResult = RegSetValueExW(hKey,
                             wszRegPath,
                             0,
                             REG_SZ,
                             data,
                             2 * sizeof(WCHAR));

    if (ERROR_SUCCESS != lResult) {
        
        RegCloseKey(hKey);
        
        if (ERROR_ACCESS_DENIED == lResult) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
        } else {
            vPrintError(IDS_CANT_SET_REG_VALUE, pszEntryName);
        }
        return;
    }

    RegCloseKey(hKey);
}

VOID
RemoveW2KData(
    WCHAR*  pszEntryName,
    LPCWSTR pszGuidDB
    )
{
    HKEY  hKey;
    WCHAR wszRegPath[MAX_PATH];
    LONG  lResult = 0;
    DWORD dwValues;
    HRESULT hr;

    //
    // This is Windows 2000 - attempt to remove custom SDB specific data.
    //
    hr = StringCchPrintfW(wszRegPath, ARRAYSIZE(wszRegPath), L"%s\\%s", APPCOMPAT_KEY, pszEntryName);
    if (FAILED(hr)) {
        vPrintError(IDS_BUFFER_TOO_SMALL);
        return;
    }

    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            wszRegPath,
                            0,
                            KEY_ALL_ACCESS|GetWow64Flag(),
                            &hKey);

    if (ERROR_SUCCESS != lResult) {
        if (ERROR_ACCESS_DENIED == lResult) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
            return;
        } else {
            vPrintError(IDS_CANT_OPEN_REG_KEY, wszRegPath);
            return;
        }
    }

    RegDeleteValueW(hKey, pszGuidDB);
    
    hr = StringCchPrintfW(wszRegPath, ARRAYSIZE(wszRegPath), L"DllPatch-%s", pszGuidDB);
    if (FAILED(hr)) {
        vPrintError(IDS_BUFFER_TOO_SMALL);
        return;
    }

    RegDeleteValueW(hKey, wszRegPath);

    //
    // Figure out if we should delete the key, if there aren't any more values left
    //
    lResult = RegQueryInfoKey(hKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &dwValues,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    RegCloseKey(hKey);
    hKey = NULL;
    
    if (dwValues != 0) {
        return;
    }
    
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            APPCOMPAT_KEY,
                            0,
                            KEY_ALL_ACCESS|GetWow64Flag(),
                            &hKey);
    
    if (ERROR_SUCCESS == lResult) {
        lResult = LocalRegDeleteKeyW(hKey, pszEntryName);
    }
    
    if (lResult != ERROR_SUCCESS) {
        vPrintError(IDS_CANT_DELETE_REG_KEY, pszEntryName, APPCOMPAT_KEY);
    }

    RegCloseKey(hKey);
}

// Caller is responsible for freeing the memory using delete [].
LPWSTR 
ExpandItem(
    LPCWSTR pwszItem
    )
{
    LPWSTR pwszItemExpand = NULL;

    // Get the required length.
    DWORD dwLenExpand = ExpandEnvironmentStringsW(pwszItem, NULL, 0);

    if (!dwLenExpand)
    {
        goto err;
    }

    //
    // Make room for "\\?\"
    //
    dwLenExpand += 4;

    pwszItemExpand = new WCHAR [dwLenExpand];
    if (!pwszItemExpand)
    {
        goto err;
    }

    LPWSTR pwszTemp = pwszItemExpand;
    DWORD dwTemp = dwLenExpand;

    StringCchCopyW(pwszItemExpand, dwLenExpand, L"\\\\?\\");
    pwszTemp += 4;
    dwTemp -= 4;

    if (!ExpandEnvironmentStringsW(pwszItem, pwszTemp, dwTemp))
    {
        goto err;
    }
    
    return pwszItemExpand;

err:
    if (pwszItemExpand) {
        delete [] pwszItemExpand;
    }

    return NULL;

}

DWORD
GiveUsersWriteAccess(
    LPWSTR pwszDir
    )
{
    DWORD                    dwRes;
    EXPLICIT_ACCESS          ea;
    PACL                     pOldDACL;
    PACL                     pNewDACL = NULL;
    PSECURITY_DESCRIPTOR     pSD = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    PSID                     pUsersSID = NULL;

    dwRes = GetNamedSecurityInfoW(pwszDir,
                                  SE_FILE_OBJECT,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  NULL,
                                  &pOldDACL,
                                  NULL,
                                  &pSD);
    
    if (ERROR_SUCCESS != dwRes) {
        goto Cleanup; 
    }  

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pUsersSID) ) {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize an EXPLICIT_ACCESS structure for the new ACE. 
    //
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    
    ea.grfAccessPermissions = FILE_GENERIC_WRITE | FILE_GENERIC_READ | DELETE;
    ea.grfAccessMode        = GRANT_ACCESS;
    ea.grfInheritance       = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType  = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName    = (LPTSTR)pUsersSID;

    //
    // Create a new ACL that merges the new ACE
    // into the existing DACL.
    //
    dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
    
    if (ERROR_SUCCESS != dwRes)  {
        goto Cleanup; 
    }

    dwRes = SetNamedSecurityInfoW(pwszDir,
                                  SE_FILE_OBJECT,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  NULL,
                                  pNewDACL,
                                  NULL);
    
    if (ERROR_SUCCESS != dwRes)  {
        goto Cleanup; 
    }

Cleanup:

    if (pSD) {
        LocalFree(pSD);
    }

    if (pUsersSID) {
        FreeSid(pUsersSID);
    }
    
    if (pNewDACL) {
        LocalFree(pNewDACL);
    }

    return dwRes;
}

BOOL
SetupLUAAllUserDir(
    LPCWSTR pwszAllUserDir
    )
{
    BOOL bRes = FALSE;

    LPWSTR pwszExpandedDir = ExpandItem(pwszAllUserDir);

    if (!pwszExpandedDir) {
        vPrintError(IDS_CANT_EXPAND_DIR, pwszAllUserDir);
        return FALSE;
    }

    //
    // Create the directory if it doesn't already exist.
    //
    DWORD dwAttributes = GetFileAttributesW(pwszExpandedDir);

    if (dwAttributes != -1) {
        if (!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            vPrintError(IDS_OBJECT_ALREADY_EXISTS, pwszExpandedDir);
            goto Cleanup;
        }
    } else {
        if (!CreateDirectoryW(pwszExpandedDir, NULL)) {
            vPrintError(IDS_CANT_CREATE_DIRECTORY, pwszExpandedDir, GetLastError());
            goto Cleanup;
        }
    }

    //
    // Give the Users group full control access (power users can already modify
    // files in this directory).
    //
    if (GiveUsersWriteAccess((LPWSTR)pwszExpandedDir) != ERROR_SUCCESS) {
        vPrintError(IDS_CANT_SET_ACLS, pwszExpandedDir);
        goto Cleanup;
    }

    bRes = TRUE;

Cleanup:

    delete [] pwszExpandedDir;

    return bRes;
}

BOOL
ProcessLUAAction(
    PDB     pdb,
    TAGID   tiExe
    )
{
    LPWSTR szAllUserDir = NULL;

    //
    // See if this EXE has an ACTION node. Currently only EXEs shimmed with the LUA
    // shims have ACTION nodes.
    //
    TAGID tiAction = SdbFindFirstTag(pdb, tiExe, TAG_ACTION);

    if (tiAction) {

        //
        // the ACTION node in the EXE shimmed with LUA looks like this:
        //
        //  <ACTION NAME="REDIRECT" TYPE="ChangeACLs">
        //      <DATA NAME="AllUserDir" VALUETYPE="STRING" 
        //            VALUE="%ALLUSERSPROFILE%\Application Data\Fireworks 3"/>
        //  </ACTION>
        //
        TAGID tiName, tiType, tiData, tiValue;
        LPWSTR szName, szType, szData;

        if ((tiName = SdbFindFirstTag(pdb, tiAction, TAG_NAME)) &&
            (szName = SdbGetStringTagPtr(pdb, tiName))) {

            if (!wcscmp(szName, L"REDIRECT")) {
                
                if ((tiType = SdbFindFirstTag(pdb, tiAction, TAG_ACTION_TYPE)) &&
                    (szType = SdbGetStringTagPtr(pdb, tiType))) {

                    if (!wcscmp(szType, L"ChangeACLs")) {

                        if ((tiData = SdbFindFirstTag(pdb, tiAction, TAG_DATA)) &&
                            (tiValue = SdbFindFirstTag(pdb, tiData, TAG_DATA_STRING)) &&
                            (szAllUserDir = SdbGetStringTagPtr(pdb, tiValue))) {
                            
                            if (!SetupLUAAllUserDir(szAllUserDir)) {
                                
                                return FALSE;
                            }
                        }
                    }
                }
            }
        }
    }

    return TRUE;
}

// buffer size is in characters (unicode)
BOOL 
InstallSdbEntry(
    WCHAR*    szEntryName,     // entry name (foo.exe or layer name)
    LPCWSTR   pszGuidDB,       // guid database id in string format
    ULONGLONG ullSdbTimeStamp, // representation of a timestamp
    BOOL      bLayer           // true if layer name
    )
{
    LONG    lRes;
    WCHAR   szRegPath[MAX_PATH * 2]; // MAX_PATH for the reg path, and MAX_PATH for the exe name
    WCHAR   szDBName[MAX_PATH];  // this is used in older (win2k) versions
    HRESULT hr;
    BOOL    bReturn = FALSE;
    HKEY    hKey    = NULL;

    StringCchCopyW(szDBName, ARRAYSIZE(szDBName), pszGuidDB);

    StringCchCatW(szDBName, ARRAYSIZE(szDBName), L".sdb");

    pszGuidDB = szDBName;
    
    //
    // If this is Win2K, add data to the AppCompatibility key.
    //
    if (g_bWin2K) {
        InstallW2KData(szEntryName, pszGuidDB);
    }

    // else we have a string
    hr = StringCchPrintfW(szRegPath, 
                     ARRAYSIZE(szRegPath),
                     (bLayer ? L"%s\\Layers\\%s": L"%s\\%s"),
                     APPCOMPAT_KEY_PATH_CUSTOM_W,
                     szEntryName);



    if (FAILED(hr)) {
        // error
        vPrintError(IDS_BUFFER_TOO_SMALL);
        goto HandleError;
    }


    lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                           szRegPath,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS|GetWow64Flag(),
                           NULL,
                           &hKey,
                           NULL);

    //
    // on install, we want to quit if we hit an error.
    // BUGBUG - should we undo whatever we've already completed?
    //
    if (lRes != ERROR_SUCCESS) {
        vPrintError(IDS_CANT_CREATE_REG_KEY, szRegPath);
        goto HandleError;
    }

    lRes = RegSetValueExW(hKey,
                          pszGuidDB,
                          0,
                          REG_QWORD,
                          (PBYTE)&ullSdbTimeStamp,
                          sizeof(ullSdbTimeStamp));

    if (lRes != ERROR_SUCCESS) {
        vPrintError(IDS_CANT_CREATE_VALUE, szRegPath);
        goto HandleError;
    }

    bReturn = TRUE;

HandleError:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return bReturn;
}


BOOL
UninstallSdbEntry(
    WCHAR*    szEntryName,      // foo.exe or layer name
    LPCWSTR   pszGuidDB,        // guid (database id) in string format
    BOOL      bLayer            // true is layer
    )
{
    LONG  lRes;
    WCHAR szRegPath[MAX_PATH * 2]; // MAX_PATH for the reg path, and MAX_PATH for the exe name
    WCHAR szDBName[MAX_PATH];
    HRESULT hr;
    BOOL  bReturn = FALSE;
    HKEY  hKey    = NULL;
    DWORD dwValues;
    WCHAR szOldInstallName[MAX_PATH];

    StringCchCopyW(szDBName, ARRAYSIZE(szDBName), pszGuidDB);

    StringCchCatW(szDBName, ARRAYSIZE(szDBName), L".sdb");

    pszGuidDB = szDBName;
    
    if (g_bWin2K) {
        RemoveW2KData(szEntryName, pszGuidDB);
    }

    hr = StringCchPrintfW(szRegPath, 
                     ARRAYSIZE(szRegPath),
                     (bLayer ? L"%s\\Layers\\%s": L"%s\\%s"),
                     APPCOMPAT_KEY_PATH_CUSTOM_W,
                     szEntryName);

    if (FAILED(hr)) {
        // error
        vPrintError(IDS_BUFFER_TOO_SMALL);
        goto Out;
    }

    lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                         szRegPath,
                         0,
                         KEY_ALL_ACCESS|GetWow64Flag(),
                         &hKey);

    //
    // if we fail to open a key on uninstall, keep going, so
    // hopefully we can get as much uninstalled as possible.
    //
    if (lRes != ERROR_SUCCESS) {
        if (lRes == ERROR_ACCESS_DENIED) {
            vPrintError(IDS_NEED_UNINSTALL_PERMISSION);
            goto HandleError;
        } else {
            //
            // DO NOT report an error - this key might have been cleaned up during the
            // previous path, such as when identical exe names appear in the same db
            // for instance, two setup.exe's -- the first pass will clean up the key,
            // second path will fail to open them right here
            //
            // vPrintError(IDS_CANT_OPEN_REG_KEY, szRegPath);
            goto Out;
        }
    }

    lRes = RegDeleteValueW(hKey, pszGuidDB);
    if (lRes != ERROR_SUCCESS) {
        if (lRes == ERROR_ACCESS_DENIED) {
            vPrintError(IDS_NEED_UNINSTALL_PERMISSION);
            goto HandleError; // fatal error
        } else {
            //
            // bugbug - pszSdbInstallName
            //
            if (lRes == ERROR_FILE_NOT_FOUND) {
                WCHAR wszOldFormat[MAX_PATH];
                
                //
                // aha, value's not there, try old format
                //
                StringCchCopyW(wszOldFormat, ARRAYSIZE(wszOldFormat), pszGuidDB);
                StringCchCatW(wszOldFormat, ARRAYSIZE(wszOldFormat), L".sdb");
                lRes = RegDeleteValueW(hKey, wszOldFormat);
            }

            if (lRes != ERROR_SUCCESS) {
                vPrintError(IDS_CANT_DELETE_REG_VALUE, pszGuidDB, szRegPath);
            }
        }
    }

    //
    // figure out if we should delete the key, if there aren't any more values left
    //
    lRes = RegQueryInfoKey(hKey,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           &dwValues,
                           NULL,
                           NULL,
                           NULL,
                           NULL);
    if (dwValues == 0) {
        RegCloseKey(hKey);
        hKey = NULL;

        hr = StringCchPrintfW(szRegPath, 
                         sizeof(szRegPath)/sizeof(szRegPath[0]),
                         (bLayer ? L"%s\\Layers": L"%s"),
                         APPCOMPAT_KEY_PATH_CUSTOM_W);

        if (FAILED(hr)) {
            // error
            vPrintError(IDS_BUFFER_TOO_SMALL);
            goto Out;
        }

        lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_WRITE|GetWow64Flag(), &hKey);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_OPEN_REG_KEY, szRegPath);
            goto Out;
        }


        lRes = LocalRegDeleteKeyW(hKey, szEntryName);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_DELETE_REG_KEY, szEntryName, szRegPath);
        }
    }

Out:
    bReturn = TRUE;

HandleError:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return bReturn;
}

NTSTATUS
SDBAPI
FindCharInUnicodeString(
    ULONG            Flags,
    PCUNICODE_STRING StringToSearch,
    PCUNICODE_STRING CharSet,
    USHORT*          NonInclusivePrefixLength
    )
{
    LPCWSTR pch;

    //
    // implement only the case when we move backward
    //
    if (Flags != RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END) {
        return STATUS_NOT_IMPLEMENTED;
    }

    pch = StringToSearch->Buffer + StringToSearch->Length / sizeof(WCHAR);
    
    while (pch >= StringToSearch->Buffer) {

        if (_tcschr(CharSet->Buffer, *pch)) {
            //
            // got the char
            //
            if (NonInclusivePrefixLength) {
                *NonInclusivePrefixLength = (USHORT)(pch - StringToSearch->Buffer) * sizeof(WCHAR);
            }
            
            return STATUS_SUCCESS;
        }

        pch--;
    }

    //
    // We haven't found it. Return failure.
    //
    return STATUS_NOT_FOUND;
}

//
// Database list entry
// Used to represent a particular installed database
//

typedef struct tagSDBLISTENTRY {
    LIST_ENTRY ListEntry;         // link list stuff
    
    ULONGLONG  ullTimeStamp;      // database install timestamp
    GUID       guidDB;            // database guid
    WCHAR      szTimeStamp[32];   // time stamp in string form
    WCHAR      szGuidDB[64];      // guid in string form
    WCHAR      szDatabasePath[1]; // database path - we store only the name
} SDBLISTENTRY, *PSDBLISTENTRY;

/*++
    AddSdbListEntry
    
    Adds a particular database to the list of installed sdbs (maintained internally)
    parses database path to retrieve database name
        
    [in out] pHeadList       - pointer to the associated list head for the installed sdbs
    [in]     guidDB          - database guid
    [in]     TimeStamp       - database time stamp
    [in]     pszDatabasePath - final database path

    returns true if success
--*/

BOOL
AddSdbListEntry(
    PLIST_ENTRY pHeadList,
    GUID&       guidDB,
    ULONGLONG&  TimeStamp,
    LPCWSTR     pszDatabasePath
    )
{
    //
    // out of database path, recover the database name
    //
    UNICODE_STRING  ustrPath = { 0 };
    USHORT          uPrefix;
    UNICODE_STRING  ustrPathSep = RTL_CONSTANT_STRING(L"\\/");
    NTSTATUS        Status;
    UNICODE_STRING  ustrGUID = { 0 };

    if (pszDatabasePath != NULL) {
        RtlInitUnicodeString(&ustrPath, pszDatabasePath);

        Status = FindCharInUnicodeString(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                         &ustrPath,
                                         &ustrPathSep,
                                         &uPrefix);
        
        if (NT_SUCCESS(Status) && (uPrefix + sizeof(WCHAR)) < ustrPath.Length) {

            //
            // uPrefix is number of character preceding the one we found not including it
            //
            ustrPath.Buffer        += uPrefix / sizeof(WCHAR) + 1;
            ustrPath.Length        -= (uPrefix + sizeof(WCHAR));
            ustrPath.MaximumLength -= (uPrefix + sizeof(WCHAR));
        }

        //
        // at this point ustrPath has just the filename -- this is what we shall use
        //
    }

    PBYTE Buffer = new BYTE[sizeof(SDBLISTENTRY) + ustrPath.Length];

    if (Buffer == NULL) {
        vLogMessage("[AddSdbListEntry] Failed to allocate 0x%lx bytes\n",
                    sizeof(SDBLISTENTRY) + ustrPath.Length);
        return FALSE;
    }

    PSDBLISTENTRY pSdbEntry = (PSDBLISTENTRY)Buffer;

    pSdbEntry->guidDB = guidDB;
    pSdbEntry->ullTimeStamp = TimeStamp;

    Status = RtlStringFromGUID(guidDB, &ustrGUID);
    
    if (!NT_SUCCESS(Status)) {
        //
        // we can't convert guid to string? memory allocation failure
        //
        vLogMessage("[AddSdbListEntry] Failed to convert guid to string Status 0x%lx\n",
                    Status);
        delete[] Buffer;
        return FALSE;
    }
    
    RtlCopyMemory(&pSdbEntry->szGuidDB[0], &ustrGUID.Buffer[0], ustrGUID.Length);
    pSdbEntry->szGuidDB[ustrGUID.Length/sizeof(WCHAR)] = L'\0';
    RtlFreeUnicodeString(&ustrGUID);

    StringCchPrintfW(pSdbEntry->szTimeStamp, ARRAYSIZE(pSdbEntry->szTimeStamp), L"%.16I64X", TimeStamp);

    RtlCopyMemory(&pSdbEntry->szDatabasePath[0], &ustrPath.Buffer[0], ustrPath.Length);
    pSdbEntry->szDatabasePath[ustrPath.Length / sizeof(WCHAR)] = L'\0';

    InsertHeadList(pHeadList, &pSdbEntry->ListEntry);

    return TRUE;
}

//
// only pGuidDB OR pwszGuid is allowed
//

/*++
    FindSdbListEntry

    Finds and returns an sdb list entry given a guid (in string or binary form)
    Whenever possible pwszGuid is used (if it's supplied). If pwszGuid happens to be 
    an arbitrary filename -- it is assumed that it's the name of an installed sdb file
    as registered. 
    
    [in]  pHeadList      - list of the installed sdbs
    [in]  pwszGuid       - guid or guid.sdb 
    [out] ppSdbListEntry - if found, this receives a pointer to sdb list entry
    [in]  pGuidDB        - guid in binary form

    returns true if matching database has been located in the list    
--*/

BOOL
FindSdbListEntry(
    PLIST_ENTRY    pHeadList,
    LPCWSTR        pwszGuid, // guid, possibly with trailing '.sdb'
    PSDBLISTENTRY* ppSdbListEntry,
    GUID*          pGuidDB   // guid
    )
{
    UNICODE_STRING  ustrDot = RTL_CONSTANT_STRING(L".");
    UNICODE_STRING  ustrPath;
    USHORT          uPrefix;
    NTSTATUS        Status;
    PLIST_ENTRY     pEntry;
    PSDBLISTENTRY   pSdbEntry;
    GUID            guidDB;
    BOOL            bGuidSearch = TRUE;
    BOOL            bFound = FALSE;
    LPCWSTR         pch;

    if (pGuidDB == NULL) {

        RtlInitUnicodeString(&ustrPath, pwszGuid);

        Status = FindCharInUnicodeString(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                         &ustrPath,
                                         &ustrDot,
                                         &uPrefix);
        if (NT_SUCCESS(Status)) {

            //
            // uPrefix is number of character preceding the one we found not including it
            //
            ustrPath.Length = uPrefix;
        }

        //
        // convert to guid, but check first
        //
        pch = pwszGuid + wcsspn(pwszGuid, L" \t");
        if (*pch != L'{') { // not a guid, why convert ?
            bGuidSearch = FALSE;
        } else {

            Status = RtlGUIDFromString(&ustrPath, &guidDB);
            if (!NT_SUCCESS(Status)) {
                //
                // failed, so use database path instead
                //
                bGuidSearch = FALSE;
            }
        }
    } else {
        guidDB = *pGuidDB;  // guid search only
    }


    pEntry = pHeadList->Flink;
    
    while (pEntry != pHeadList && !bFound) {

        //
        // convert entry by subtracting the offset of the list entry
        //
        pSdbEntry = (PSDBLISTENTRY)((PBYTE)pEntry - OFFSETOF(SDBLISTENTRY, ListEntry));

        //
        // compare db guids or paths
        //
        if (bGuidSearch) {
            bFound = RtlEqualMemory(&pSdbEntry->guidDB, &guidDB, sizeof(GUID));
        } else {
            bFound = !_wcsicmp(pSdbEntry->szDatabasePath, pwszGuid);
        }

        pEntry = pEntry->Flink;
    }

    //
    // we have found an entry ? return it -- note that pEntry would have advanced while pSdbEntry
    // still points to the entry we have found
    //
    if (bFound) {
        *ppSdbListEntry = pSdbEntry;
    }

    return bFound;
}

/*++
    CleanupSdbList

    Performs cleanup for the installed sdb list
    
    returns nothing
--*/

VOID
CleanupSdbList(
    PLIST_ENTRY pSdbListHead
    )
{
    PLIST_ENTRY   pEntry;
    PSDBLISTENTRY pSdbEntry;
    PBYTE         Buffer;

    pEntry = pSdbListHead->Flink;
    if (pEntry == NULL) {
        return;
    }

    while (pEntry != pSdbListHead) {
        pSdbEntry = (PSDBLISTENTRY)((PBYTE)pEntry - OFFSETOF(SDBLISTENTRY, ListEntry));
        pEntry = pEntry->Flink;

        Buffer = (PBYTE)pSdbEntry;
        delete[] Buffer;
    }

}

/*++
    ConvertInstalledSdbsToNewFormat

    Converts installed sdbs to new format, which involves storing (or verifying) the
    timestamp for each installed sdb file. This function also builds a list of sdbs
    used elsewhere

    [in]     hKey         - a key handle for hklm/..../InstalledSdb
    [in out] pSdbListHead - list head for the installed sdbs

    returns true if successful

--*/

BOOL
ConvertInstalledSdbsToNewFormat(
    HKEY        hKey,           // hklm/.../InstalledSdb
    PLIST_ENTRY pSdbListHead    // we fill this list with our sdbs for later
    )
{
    DWORD           dwIndex = 0;
    WCHAR           szSubKeyName[MAX_PATH];
    PWCHAR          pwszKeyName;
    DWORD           dwBufferSize;
    FILETIME        ftLastWriteTime;
    HKEY            hKeyEntry = NULL;
    LONG            lResult;
    ULARGE_INTEGER  liTimeStamp;
    UNICODE_STRING  ustrGuid;
    GUID            guidDB;
    NTSTATUS        Status;
    WCHAR           szDatabasePath[MAX_PATH];
    PWCHAR          pszDatabasePath;
    DWORD           dwType;
    BOOL            bSuccess = TRUE;

    while (TRUE) {

        dwBufferSize = sizeof(szSubKeyName)/sizeof(szSubKeyName[0]);
        
        lResult = RegEnumKeyExW(hKey,
                                dwIndex,
                                szSubKeyName,
                                &dwBufferSize,
                                NULL, NULL, NULL,
                                &ftLastWriteTime);
        ++dwIndex;

        if (lResult != ERROR_SUCCESS) {
            //
            // done if no more keys, else some sort of error
            // bugbug
            //
            if (lResult == ERROR_NO_MORE_ITEMS) {
                //
                // we are done, clean
                //
                break;
            }

            //
            // this is unexpected
            //
            vLogMessage("[ConvertInstalledSdbsToNewFormat] RegEnumKeyExW for index 0x%lx returned unexpected error 0x%lx\n",
                        dwIndex, lResult);

            break;
        }

        RtlInitUnicodeString(&ustrGuid, szSubKeyName);
        Status = RtlGUIDFromString(&ustrGuid, &guidDB);
        
        if (!NT_SUCCESS(Status)) {
            //
            // BUGBUG - failed to convert the guid (subkey name!)
            // extraneous entry, log warning
            //
            vLogMessage("[ConvertInstalledSdbsToNewFormat] Failed to convert string to guid for \"%ls\" status 0x%lx\n",
                        szSubKeyName, Status);
            continue;
        }

        //
        // for this db entry we have to set the timestamp
        //
        lResult = RegOpenKeyExW(hKey,
                                szSubKeyName,
                                0,
                                KEY_READ|KEY_WRITE|GetWow64Flag(),
                                &hKeyEntry);
        
        if (lResult != ERROR_SUCCESS) {
            //
            // bad error ?
            // BUGBUG
            vLogMessage("[ConvertInstalledSdbsToNewFormat] Failed to open subkey \"%ls\" error 0x%lx\n",
                        szSubKeyName, lResult);
            continue;
        }

        //
        // now check the value
        //

        dwBufferSize = sizeof(liTimeStamp.QuadPart);
        lResult = RegQueryValueExW(hKeyEntry,
                                   L"DatabaseInstallTimeStamp",
                                   NULL,
                                   &dwType,
                                   (PBYTE)&liTimeStamp.QuadPart,
                                   &dwBufferSize);

        if (lResult != ERROR_SUCCESS || dwType != REG_BINARY) {

            //
            // we may either have this value already -- if not, set it up now
            //
            liTimeStamp.LowPart  = ftLastWriteTime.dwLowDateTime;
            liTimeStamp.HighPart = ftLastWriteTime.dwHighDateTime;

            vLogMessage("[Info] Database \"%ls\" receives timestamp \"%.16I64X\"\n",
                        szSubKeyName, liTimeStamp.QuadPart);

            lResult = RegSetValueExW(hKeyEntry,
                                     L"DatabaseInstallTimeStamp",
                                     0,
                                     REG_BINARY,
                                     (PBYTE)&liTimeStamp.QuadPart,
                                     sizeof(liTimeStamp.QuadPart));
            if (lResult != ERROR_SUCCESS) {
                //
                // error, ignore for now
                //
                vLogMessage("[ConvertInstalledSdbsToNewFormat] Failed to set timestamp value for database \"%ls\" value \"%.16I64X\" error 0x%lx\n",
                            szSubKeyName, liTimeStamp.QuadPart, lResult);
            }
        }

        //
        // at this point we have :
        // sdb guid (in szSubKeyName)
        // time stamp in liTimeStamp
        //

        //
        // query also database path
        //
        pszDatabasePath = &szDatabasePath[0];
        dwBufferSize = sizeof(szDatabasePath);
        
        lResult = RegQueryValueExW(hKeyEntry,
                                   L"DatabasePath",
                                   NULL,
                                   &dwType,
                                   (PBYTE)pszDatabasePath,
                                   &dwBufferSize);
        
        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {
            //
            // no database path
            // warn basically corrupt database path
            //
            vLogMessage("[ConvertInstalledSdbsToNewFormat] Failed to query database path for \"%s\" error 0x%lx\n", szSubKeyName, lResult);
            pszDatabasePath = NULL;
        }

        //
        // optional check: we can check here whether the sdb file does exist
        //

        //
        // add this sdb to our cache
        //

        if (!AddSdbListEntry(pSdbListHead, guidDB, liTimeStamp.QuadPart, pszDatabasePath)) {

            //
            // failed to add list entry - we cannot continue
            //
            bSuccess = FALSE;
            break;
        }


        RegCloseKey(hKeyEntry);
        hKeyEntry = NULL;

    }


    if (hKeyEntry != NULL) {
        RegCloseKey(hKeyEntry);
    }

    //
    // we are done converting entries -- and we have also collected cache of sdb info
    //

    return bSuccess;

}

//
// this stucture is used to cache values associated with any particular entry (exe)
//

typedef struct tagSDBVALUEENTRY {
    LIST_ENTRY ListEntry;    // link
    PSDBLISTENTRY pSdbEntry; // this entry belongs to this database 
    WCHAR szValueName[1];    // value name as we got it from registry
} SDBVALUEENTRY, *PSDBVALUEENTRY;


/*++

    AddValueEntry

    Adds an new link list element to the list of values 

    [in out] pValueListHead - link list of values
    [in]     pSdbEntry      - pointer to a cached entry from sdb list 
    [in]     pwszValueName  - value name as we got it from the db (something like {guid} or {guid}.sdb)

    returns true if successful
    
--*/

BOOL
AddValueEntry(
    PLIST_ENTRY   pValueListHead,
    PSDBLISTENTRY pSdbEntry,
    LPCWSTR       pwszValueName
    )
{
    PSDBVALUEENTRY pValueEntry;
    PBYTE          Buffer;
    DWORD          dwSize;

    dwSize = sizeof(SDBVALUEENTRY) + wcslen(pwszValueName) * sizeof(WCHAR);
    
    Buffer = new BYTE[dwSize];

    if (Buffer == NULL) {
        //
        // out of memory
        //
        vLogMessage("[AddValueEntry] Failed to allocate buffer for %ls 0x%lx bytes\n",
                    pwszValueName, dwSize);

        return FALSE;
    }

    pValueEntry = (PSDBVALUEENTRY)Buffer;

    pValueEntry->pSdbEntry = pSdbEntry;
    StringCchCopyW(pValueEntry->szValueName, (dwSize - sizeof(SDBVALUEENTRY) + sizeof(WCHAR)), pwszValueName);

    InsertHeadList(pValueListHead, &pValueEntry->ListEntry);

    return TRUE;
}

/*++
    WriteEntryValue

    Writes value for a particular entry (exe or layer name), deletes old value associated with 
    this particular database for this exe (or layer)

    [in] hKey            - handle for an entry (for instance 
                           hklm/Software/Microsoft/Windows NT/CurrentVersion/AppcompatFlags/Custom/Notepad.exe)
    [in] pValueEntry     - pointer to a value entry element from the value list
    [in] bWriteNewFormat - whether we are asked to write new or old format

    returns true if successful

--*/


BOOL
WriteEntryValue(
    HKEY           hKey,
    PSDBVALUEENTRY pValueEntry,
    BOOL           bWriteNewFormat  // if true -- write new format else old format
    )
{
    LONG    lResult;
    BOOL    bSuccess = FALSE;
    LPCWSTR pValueName;

    if (bWriteNewFormat) {
        
        pValueName = pValueEntry->pSdbEntry->szGuidDB;
        
        lResult = RegSetValueExW(hKey,
                                 pValueName,
                                 0,
                                 REG_QWORD,
                                 (PBYTE)&pValueEntry->pSdbEntry->ullTimeStamp,
                                 sizeof(pValueEntry->pSdbEntry->ullTimeStamp));
        if (lResult != ERROR_SUCCESS) {

            //
            // we can't do this entry ?
            //
            vLogMessage("[WriteEntryValue] Failed to write qword value \"%ls\"=\"%.16I64X\" error 0x%lx\n",
                        pValueEntry->pSdbEntry->szGuidDB, pValueEntry->pSdbEntry->ullTimeStamp, lResult);

            goto cleanup;
        }

        //
        // nuke old entry
        //
    } else {
        //
        // old style format please
        //
        pValueName = pValueEntry->pSdbEntry->szDatabasePath;
        
        lResult = RegSetValueExW(hKey,
                                 pValueName,
                                 0,
                                 REG_SZ,
                                 (PBYTE)L"",
                                 sizeof(WCHAR));
        
        if (lResult != ERROR_SUCCESS) {

            //
            // trouble -- error
            //
            vLogMessage("[WriteEntryValue] Failed to write string value \"%ls\" error 0x%lx\n",
                        pValueEntry->pSdbEntry->szDatabasePath, lResult);
            goto cleanup;
        }
    }

    //
    // if we are here -- success, check to see if we can delete the old value
    // 

    if (_wcsicmp(pValueEntry->szValueName, pValueName) != 0) {
        lResult = RegDeleteValueW(hKey, pValueEntry->szValueName);
        if (lResult != ERROR_SUCCESS) {
            vLogMessage("[WriteEntryValue] Failed to delete value \"%ls\" error 0x%lx\n",
                        pValueEntry->szValueName, lResult);
        }
    }

    bSuccess = TRUE;

cleanup:

    return bSuccess;
}

/*++

    ConvertEntryToNewFormat    

    Converts a particular entry (layer or exe)

    [in] hKeyParent    - key handle for a parent key (for instance 
                         hklm/Software/Microsoft/Windows NT/CurrentVersion/AppcompatFlags/Custom when 
                         pwszEntryName == "Notepad.exe" or 
                         hklm/Software/Microsoft/Windows NT/CurrentVersion/AppcompatFlags/Custom/Layers when
                         pwszEntryName == "RunLayer"
    [in] pwszEntryName - Either exe name or layer name
    [in] pSdbListHead  - cached list of installed databases
    [in] bNewFormat    - whether to use new or old format

    returns true if successful

--*/

BOOL
ConvertEntryToNewFormat(
    HKEY        hKeyParent,
    LPCWSTR     pwszEntryName,
    PLIST_ENTRY pSdbListHead,
    BOOL        bConvertToNewFormat // true if converting to new format, false if reverting
    )
{
    LONG            lResult;
    DWORD           dwValues;
    DWORD           dwMaxValueNameLen;
    DWORD           dwMaxValueLen;
    DWORD           dwType;
    DWORD           dwValueNameSize;
    DWORD           dwValueSize;
    LPWSTR          pwszValueName = NULL;
    LPBYTE          pValue = NULL;
    PSDBLISTENTRY   pSdbEntry;
    DWORD           dwIndex;
    LIST_ENTRY      ValueList = { 0 };
    PSDBVALUEENTRY  pValueEntry;
    PLIST_ENTRY     pValueList;
    PBYTE           Buffer;
    BOOL            bSuccess = FALSE;
    HKEY            hKey = NULL;
    
    //
    // loop through values, for each value - find sdb and write out new entry
    // then delete old entry
    //
    lResult = RegOpenKeyExW(hKeyParent,
                            pwszEntryName,
                            0,
                            KEY_READ|KEY_WRITE|GetWow64Flag(),
                            &hKey);
    
    if (lResult != ERROR_SUCCESS) {
        vLogMessage("[ConvertEntryToNewFormat] Failed to open key \"%ls\" error 0x%lx\n",
                    pwszEntryName, lResult);
        goto cleanup;
    }

    lResult = RegQueryInfoKeyW(hKey,
                               NULL, NULL, // class/class buffer
                               NULL,       // reserved
                               NULL, NULL, // subkeys/max subkey length
                               NULL,       // max class len
                               &dwValues,  // value count
                               &dwMaxValueNameLen,
                               &dwMaxValueLen,
                               NULL, NULL);

    if (lResult != ERROR_SUCCESS) {
        //
        // failed to query the key, very bad
        // bugbug
        vLogMessage("[ConvertEntryToNewFormat] Failed to query key information \"%ls\" error 0x%lx\n",
                    pwszEntryName, lResult);
        goto cleanup;
    }

    //
    // allocate buffers
    //
    pwszValueName = new WCHAR[dwMaxValueNameLen + 1];
    pValue = new BYTE[dwMaxValueLen];
    
    if (pValue == NULL || pwszValueName == NULL) {
        //
        // bugbug
        //
        vLogMessage("[ConvertEntryToNewFormat] Failed to allocate memory buffer entry \"%ls\" (0x%lx, 0x%lx)\n",
                    pwszEntryName, dwMaxValueNameLen, dwMaxValueLen);
        goto cleanup;
    }

    InitializeListHead(&ValueList);

    //
    // we have dwValues -- the count of values
    //
    for (dwIndex = 0; dwIndex < dwValues; ++dwIndex) {

        dwValueNameSize = dwMaxValueNameLen + 1;
        dwValueSize = dwMaxValueLen;

        lResult = RegEnumValueW(hKey,
                                dwIndex,
                                pwszValueName,
                                &dwValueNameSize,
                                NULL,
                                &dwType,
                                (PBYTE)pValue,
                                &dwValueSize);
        //
        // check if we are successful
        //
        if (lResult != ERROR_SUCCESS) {

            if (lResult == ERROR_NO_MORE_ITEMS) {
                //
                // oops -- we ran out of values!!! Unexpected, but ok
                //
                vLogMessage("[ConvertEntryToNewFormat] RegEnumValue unexpectedly reports no more items for \"%ls\" index 0x%lx\n",
                            pwszEntryName, dwIndex);
                break;
            }

            //
            // log error and continue
            //
            vLogMessage("[ConvertEntryToNewFormat] RegEnumValue failed for \"%ls\" index 0x%lx error 0x%lx\n",
                        pwszEntryName, dwIndex, lResult);
            continue;

        }

        if (bConvertToNewFormat) {

            if (dwType != REG_SZ) {
                //
                // bad entry for sure -- this could be a new entry
                // log warning
                //
                if (dwType == REG_QWORD || (dwType == REG_BINARY && dwValueSize == sizeof(ULONGLONG))) {
                    //
                    // new style entry ? 
                    //
                    if (wcsrchr(pwszValueName, L'.') == NULL && 
                        *pwszValueName == L'{' && 
                        *(pwszValueName + wcslen(pwszValueName) - 1) == L'}') {
                        
                        vLogMessage("[Info] Entry \"%ls\" value \"%ls\" already in new format.\n",
                                    pwszEntryName, pwszValueName);
                        continue;
                    } 
                }
                
                // 
                // very likely - some entry we do not understand
                //
            
                vLogMessage("[ConvertEntryToNewFormat] Bad value type (0x%lx) for entry \"%ls\" value \"%ls\" index 0x%lx\n",
                            dwType, pwszEntryName, pwszValueName, dwIndex);
                                            
                continue;
            }

            //
            // search by pwszValueName (which happens to be the GUID.sdb)
            // this may be any kind of a string -- not nec. guid
            //
            if (!FindSdbListEntry(pSdbListHead, pwszValueName, &pSdbEntry, NULL)) {
                //
                // error - sdb not found!
                //
                vLogMessage("[ConvertEntryToNewFormat] Failed to find database \"%ls\" for entry \"%ls\" index 0x%lx\n",
                            pwszValueName, pwszEntryName, dwIndex);
                continue;
            }

        } else {

            //
            // check the type first, if this is a new style entry - this will be bin
            //

            if (dwType == REG_SZ &&
                wcsrchr(pwszValueName, L'.') != NULL && 
                *(LPCWSTR)pValue == L'\0') {
                
                vLogMessage("[Info] Entry \"%ls\" value \"%ls\" is already in required (old) format.\n",
                            pwszEntryName, pwszValueName);
                continue;
            }
            
            if (dwType != REG_QWORD &&
                (dwType != REG_BINARY || dwValueSize < sizeof(ULONGLONG))) {
                //
                // error -- we don't know what this entry is, go to the next one
                // print warning actually
                //
                vLogMessage("[ConvertEntryToNewFormat] Bad value type (0x%lx) or size (0x%lx) for entry \"%ls\" value \"%ls\" index 0x%lx\n",
                            dwType, dwValueSize, pwszEntryName, pwszValueName, dwIndex);
                continue;
            }

            if (!FindSdbListEntry(pSdbListHead, pwszValueName, &pSdbEntry, NULL)) {

                //
                // we're in trouble -- an entry has no registered database
                //
                vLogMessage("[ConvertEntryToNewFormat] Failed to find database for value \"%ls\" for entry \"%ls\" index 0x%lx\n",
                            pwszValueName, pwszEntryName, dwIndex);
                continue;
            }
        }

        //
        // we have found entry and we're ready to write it out, queue it up
        //
        if (!AddValueEntry(&ValueList, pSdbEntry, pwszValueName)) {

            //
            // bugbug can't add value entry
            //
            vLogMessage("[ConvertEntryToNewFormat] Failed to add value \"%ls\" for entry \"%ls\" index 0x%lx\n",
                        pwszValueName, pwszEntryName, dwIndex);
            goto cleanup;
        }
    }

    //
    // we have gone through all the values, write loop
    //
    bSuccess = TRUE;

    pValueList = ValueList.Flink;
    
    while (pValueList != &ValueList) {

        pValueEntry = (PSDBVALUEENTRY)((PBYTE)pValueList - OFFSETOF(SDBVALUEENTRY, ListEntry));

        //
        // we can point to the next entry now
        //

        if (!WriteEntryValue(hKey, pValueEntry, bConvertToNewFormat)) {

            //
            // error, can't convert entry
            // continue though so that we cleanout the list
            vLogMessage("[ConvertEntryToNewFormat] Failed to write value for entry \"%ls\"\n",
                        pwszEntryName);
        }

        pValueList = pValueList->Flink;
    }

cleanup:

    if (ValueList.Flink) {
        pValueList = ValueList.Flink;
        while (pValueList != &ValueList) {
            Buffer = (PBYTE)pValueList - OFFSETOF(SDBVALUEENTRY, ListEntry);
            pValueList = pValueList->Flink;

            delete[] Buffer;
        }
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pwszValueName != NULL) {
        delete[] pwszValueName;
    }

    if (pValue != NULL) {
        delete[] pValue;
    }

    return bSuccess;

}


/*++
    ConvertFormat

    This function handles format conversions

    [in] bConvertToNewFormat - true if conversion old->new, false otherwise

    returns true if success
    
--*/


BOOL
ConvertFormat(
    BOOL bConvertToNewFormat
    )
{
    LIST_ENTRY  SdbList = { 0 }; // installed sdbs cache
    HKEY        hKey;
    LONG        lResult;
    DWORD       dwIndex;
    WCHAR       szSubKeyName[MAX_PATH];
    DWORD       dwBufferSize;
    WCHAR       szKeyPath[MAX_PATH];
    BOOL        bSuccess = FALSE;

    //
    // first convert installed sdbs
    // open installed sdb key
    //
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            APPCOMPAT_KEY_PATH_INSTALLEDSDB_W, // path to InstalledSDB
                            0,
                            KEY_READ|KEY_WRITE|GetWow64Flag(),
                            &hKey);
    
    if (lResult != ERROR_SUCCESS) {

        //
        // perhaps no dbs are installed ?
        //
        if (lResult == ERROR_FILE_NOT_FOUND) {
            //
            // no installed sdbs -- no problem
            //
            vLogMessage("[ConvertFormat] No Installed sdbs found\n");
            return TRUE;
        }

        //
        // some sort of error has occured
        //
        vLogMessage("[ConvertFormat] Failed to open key \"%ls\" Error 0x%lx\n",
                    APPCOMPAT_KEY_PATH_INSTALLEDSDB_W, lResult);
        return FALSE;
    }

    //
    // note that ConvertInstalledSdbsToNewFormat works properly for both install and uninstall cases
    //
    InitializeListHead(&SdbList);
    
    if (!ConvertInstalledSdbsToNewFormat(hKey, &SdbList)) {
        goto cleanup;
    }

    // done with Installed sdbs
    RegCloseKey(hKey);
    hKey = NULL;

    //
    // next up is entry conversion -- first enum exes, then layers
    //
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            APPCOMPAT_KEY_PATH_CUSTOM_W,
                            0,
                            KEY_READ|KEY_WRITE|GetWow64Flag(),
                            &hKey);
    
    if (lResult != ERROR_SUCCESS) {
        //
        // what is this?
        //
        if (lResult == ERROR_FILE_NOT_FOUND && !IsListEmpty(&SdbList)) {
            vLogMessage("[ConvertFormat] Failed to open \"%ls\" - check consistency\n",
                        APPCOMPAT_KEY_PATH_CUSTOM_W);
        } else {
            vLogMessage("[ConvertFormat] Failed to open \"%ls\" error 0x%lx\n",
                        APPCOMPAT_KEY_PATH_CUSTOM_W, lResult);
        }

        goto cleanup;
    }

    dwIndex = 0;
    
    while (TRUE) {

        dwBufferSize = sizeof(szSubKeyName)/sizeof(szSubKeyName[0]);

        lResult = RegEnumKeyExW(hKey,
                                dwIndex,
                                szSubKeyName,
                                &dwBufferSize,
                                NULL, NULL, NULL,
                                NULL);
        ++dwIndex;

        if (lResult != ERROR_SUCCESS) {

            if (lResult == ERROR_NO_MORE_ITEMS) {
                break;
            }

            //
            // some sort of error, log and continue
            //
            vLogMessage("[ConvertFormat] RegEnumKey (entries) returned error for index 0x%lx error 0x%lx\n",
                        dwIndex, lResult);
            break;
        }

        //
        // skip layers for now
        //
        if (!_wcsicmp(szSubKeyName, L"Layers")) {
            continue;
        }

        // for each of these -- call fixup function

        if (!ConvertEntryToNewFormat(hKey, szSubKeyName, &SdbList, bConvertToNewFormat)) {
            vLogMessage("[ConvertFormat] Failed to convert entry \"%ls\"\n", szSubKeyName);
        }
    }

    RegCloseKey(hKey);
    hKey = NULL;

    //
    // next up - layers
    //
    StringCchCopyW(szKeyPath, ARRAYSIZE(szKeyPath), APPCOMPAT_KEY_PATH_CUSTOM_W);
    StringCchCatW(szKeyPath, ARRAYSIZE(szKeyPath), L"\\Layers");

    //
    // open and enum layers
    //
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            szKeyPath,
                            0,
                            KEY_READ|KEY_WRITE|GetWow64Flag(),
                            &hKey);
    
    if (lResult != ERROR_SUCCESS) {
        // maybe dead ?
        if (lResult == ERROR_FILE_NOT_FOUND) {
            //
            // it's ok, maybe we have none of those ?
            //
            vLogMessage("[ConvertFormat] No layers found\n");
            goto ConvertComplete;
        }

        vLogMessage("[ConvertFormat] Failed to open \"%ls\" error 0x%lx\n", szKeyPath, lResult);
        goto cleanup;
    }

    dwIndex = 0;
    
    while (TRUE) {

        dwBufferSize = sizeof(szSubKeyName)/sizeof(szSubKeyName[0]);

        lResult = RegEnumKeyExW(hKey,
                                dwIndex,
                                szSubKeyName,
                                &dwBufferSize,
                                NULL, NULL, NULL,
                                NULL);
        ++dwIndex;

        if (lResult != ERROR_SUCCESS) {

            // check if this was the last entry
            if (lResult == ERROR_NO_MORE_ITEMS) {
                // clean break
                break;
            }

            // some sort of error, log and continue
            vLogMessage("[ConvertFormat] RegEnumKey (layers) returned error for index 0x%lx error 0x%lx\n",
                        dwIndex, lResult);
            break;
        }

        // for each of these -- call fixup function

        if (!ConvertEntryToNewFormat(hKey, szSubKeyName, &SdbList, bConvertToNewFormat)) {
            vLogMessage("[ConvertFormat] Failed to convert entry \"%ls\"\n", szSubKeyName);
        }
    }

    RegCloseKey(hKey);
    hKey = NULL;

ConvertComplete:

    bSuccess = TRUE;

cleanup:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    //
    // free SdbList
    //
    CleanupSdbList(&SdbList);

    return bSuccess;
}

BOOL
ProcessMSIPackages(
    PDB          pdb,
    TAGID        tiDatabase,
    LPCWSTR      pszGuidDB,
    ULONGLONG    ullSdbTimeStamp,
    INSTALL_MODE eMode)
{
    TAGID tiMsiPackage;
    TAGID tiMsiPackageID;
    GUID* pGuidID;
    GUID  GuidID;
    WCHAR szRegPath[MAX_PATH];
    BOOL  bReturn = TRUE;
    WCHAR wszGuid[64];
    
    UNICODE_STRING ustrGuid = { 0 };

    tiMsiPackage = SdbFindFirstTag(pdb, tiDatabase, TAG_MSI_PACKAGE);
    
    while (tiMsiPackage && bReturn) {
        //
        // we have a package, extract/find TAG_MSI_PACKAGE_ID
        //
        tiMsiPackageID = SdbFindFirstTag(pdb, tiMsiPackage, TAG_MSI_PACKAGE_ID);
        if (!tiMsiPackageID) {
            if (eMode == MODE_CLEANUP || eMode == MODE_UNINSTALL) {
                goto NextPackage;
            } else {
                vPrintError(IDS_MISSING_PACKAGE_ID);
                bReturn = FALSE;
                break;
            }
        }

        pGuidID = (GUID*)SdbGetBinaryTagData(pdb, tiMsiPackageID);
        if (pGuidID == NULL) {
            if (eMode == MODE_CLEANUP || eMode == MODE_UNINSTALL) {
                goto NextPackage;
            } else {
                vPrintError(IDS_MISSING_PACKAGE_ID);
                bReturn = FALSE;
                break;
            }
        }

        RtlCopyMemory(&GuidID, pGuidID, sizeof(GUID));

        if (!NT_SUCCESS(RtlStringFromGUID(GuidID, &ustrGuid))) {
            vPrintError(IDS_GUID_BAD_FORMAT);
            bReturn = FALSE;
            break;
        }

        RtlCopyMemory(wszGuid, ustrGuid.Buffer, ustrGuid.Length);
        wszGuid[ustrGuid.Length / sizeof(WCHAR)] = TEXT('\0');

        if (eMode == MODE_INSTALL) {
            bReturn = InstallSdbEntry(wszGuid, pszGuidDB, ullSdbTimeStamp, FALSE);
        } else {
            bReturn = UninstallSdbEntry(wszGuid, pszGuidDB, FALSE);
        }

        RtlFreeUnicodeString(&ustrGuid);

NextPackage:

        tiMsiPackage = SdbFindNextTag(pdb, tiDatabase, tiMsiPackage);
    }

    return bReturn;
}


#define MAX_FRIENDLY_NAME_LEN 256

BOOL
bHandleInstall(
    WCHAR*          wszSdbPath,
    INSTALL_MODE    eMode,
    WCHAR*          wszSdbInstallPath,
    DWORD           dwSdbInstallPathSize
    )
{
    PDB      pdb = NULL;
    int      i;
    WCHAR    wszSdbName[MAX_PATH];
    WCHAR    wszSdbInstallName[MAX_PATH];
    HKEY     hKey = NULL;
    LONG     lRes;
    TAGID    tiDatabase, tiExe, tiLayer;
    TAGID    tiDBName = TAGID_NULL;
    WCHAR*   pszDBName = NULL;
    WCHAR    wszFriendlyName[MAX_FRIENDLY_NAME_LEN];
    WCHAR*   wszTemp;
    GUID     guidDB;
    NTSTATUS Status;
    FILETIME SystemTime;
    BOOL     bRet = TRUE;
    
    UNICODE_STRING ustrGUID;
    ULARGE_INTEGER TimeStamp = { 0 };

    //
    // determine the timestamp (for the install case)
    //
    if (eMode == MODE_INSTALL) {
        GetSystemTimeAsFileTime(&SystemTime);
        TimeStamp.LowPart  = SystemTime.dwLowDateTime;
        TimeStamp.HighPart = SystemTime.dwHighDateTime;
    }

    assert(wszSdbPath && wszSdbInstallPath);
    if (!wszSdbPath || !wszSdbInstallPath) {
        bRet = FALSE;
        goto quickOut;
    }

    ZeroMemory(wszFriendlyName, sizeof(wszFriendlyName));

    //
    // get the full path from the file name
    //
    wszTemp = wszGetFileFromPath(wszSdbPath);
    
    if (!wszTemp) {
        vPrintMessage(IDS_UNABLE_TO_GET_FILE);
        bRet = FALSE;
        goto quickOut;
    }
    
    StringCchCopyW(wszSdbName, ARRAYSIZE(wszSdbName), wszTemp);

    if (wcscmp(wszSdbName, L"sysmain.sdb") == 0) {
        vPrintError(IDS_CANT_INSTALL_SYS);
        bRet = FALSE;
        goto quickOut;
    }

    if (GetFileAttributesW(wszSdbPath) != -1 && bIsAlreadyInstalled(wszSdbPath)) {
        if (eMode == MODE_INSTALL) {
            //
            // they asked us to install, it's installed, so we're done
            //
            vPrintMessage(IDS_ALREADY_INSTALLED, wszSdbPath);
            goto quickOut;
        }
    } else {
        if (eMode == MODE_UNINSTALL) {
            //
            // they asked us to uninstall, it's not installed, so we're done
            //
            vPrintMessage(IDS_NOT_INSTALLED, wszSdbPath);
            goto quickOut;
        }
    }

    if (eMode == MODE_INSTALL) {
        //
        // find out what file name we're going to use for installing
        //
        if (!bFindInstallName(wszSdbPath, wszSdbInstallPath, dwSdbInstallPathSize)) {
            bRet = FALSE;
            goto quickOut;
        }

    } else if (eMode == MODE_CLEANUP) {
        //
        // we're cleaning up a bad install, so we need to get the install name from the
        // install path
        //
        wszTemp = wszGetFileFromPath(wszSdbInstallPath);
        if (!wszTemp) {
            vPrintMessage(IDS_UNABLE_TO_GET_FILE);
            bRet = FALSE;
            goto quickOut;
        }

    } else {
        //
        // we're uninstalling, so the install name is the given name
        // and the install path is the given path
        //
        StringCchCopyW(wszSdbInstallPath, dwSdbInstallPathSize, wszSdbPath);
    }

    //
    // try to get the guid for later
    //
    if (!bGetGuid(wszSdbPath, &guidDB)) {
        bRet = FALSE;
        goto out;
    }

    //
    // check whether the guid is coopted from one of the known databases
    //
    if (IsKnownDatabaseGUID(&guidDB)) {
        vPrintError(IDS_CANT_INSTALL_SYS);
        bRet = FALSE;
        goto quickOut;
    }        


    //
    // in all cases, install name is the db GUID
    //
    Status = RtlStringFromGUID(guidDB, &ustrGUID);
    if (!NT_SUCCESS(Status)) {
        bRet = FALSE;
        goto out;
    }
    RtlCopyMemory(wszSdbInstallName, ustrGUID.Buffer, ustrGUID.Length);
    wszSdbInstallName[ustrGUID.Length/sizeof(WCHAR)] = L'\0';
    RtlFreeUnicodeString(&ustrGUID);

    //
    // if we're installing, make sure the root tags are in place
    //
    if (eMode == MODE_INSTALL) {
        lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                               APPCOMPAT_KEY_PATH_W,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS|GetWow64Flag(),
                               NULL,
                               &hKey,
                               NULL);

        if (lRes != ERROR_SUCCESS) {
            if (lRes == ERROR_ACCESS_DENIED) {
                vPrintError(IDS_NEED_INSTALL_PERMISSION);
            } else {
                vPrintError(IDS_CANT_CREATE_REG_KEY, APPCOMPAT_KEY_PATH_W);
            }
            bRet = FALSE;
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                               APPCOMPAT_KEY_PATH_CUSTOM_W,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS|GetWow64Flag(),
                               NULL,
                               &hKey,
                               NULL);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_CREATE_REG_KEY, APPCOMPAT_KEY_PATH_CUSTOM_W);
            bRet = FALSE;
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    // Open the DB.
    pdb = SdbOpenDatabase(wszSdbPath, DOS_PATH);

    if (pdb == NULL) {
        vPrintError(IDS_UNABLE_TO_OPEN_FILE, wszSdbPath);
        bRet = FALSE;
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    if (!tiDatabase) {
        vPrintError(IDS_NO_DB_TAG, wszSdbPath);
        bRet = FALSE;
        goto out;
    }

    //
    // get the friendly name of the database
    //
    tiDBName = SdbFindFirstTag(pdb, tiDatabase, TAG_NAME);
    if (tiDBName) {
        pszDBName = SdbGetStringTagPtr(pdb, tiDBName);
    }

    //
    // if we don't find a friendly name, use the SDB file name
    //
    if (pszDBName) {
        StringCchCopyW(wszFriendlyName, ARRAYSIZE(wszFriendlyName), pszDBName);
    } else {
        StringCchCopyW(wszFriendlyName, ARRAYSIZE(wszFriendlyName), wszSdbName);
    }

    tiExe = SdbFindFirstTag(pdb, tiDatabase, TAG_EXE);
    while (tiExe) {
        WCHAR szRegPath[MAX_PATH];
        TAGID tiName;
        WCHAR *szName;
        TAGID tiTemp;

        tiName = SdbFindFirstTag(pdb, tiExe, TAG_NAME);
        if (!tiName) {
            bRet = FALSE;
            if (eMode == MODE_CLEANUP || eMode == MODE_UNINSTALL) {
                goto nextExe;
            } else {
                vPrintError(IDS_NO_EXE_NAME);
                goto quickOut;
            }
        }
        szName = SdbGetStringTagPtr(pdb, tiName);
        if (!szName) {
            bRet = FALSE;
            if (eMode == MODE_CLEANUP || eMode == MODE_UNINSTALL) {
                goto nextExe;
            } else {
                vPrintError(IDS_NO_EXE_NAME_PTR);
                goto quickOut;
            }
        }
        
        if (eMode == MODE_INSTALL) {

            if (!InstallSdbEntry(szName, wszSdbInstallName, TimeStamp.QuadPart, FALSE) ||
                !ProcessLUAAction(pdb, tiExe)) {

                bRet = FALSE;
                goto out;
            }

        } else {

            if (!UninstallSdbEntry(szName, wszSdbInstallName, FALSE)) {
                goto quickOut;
            }
        }

nextExe:

        tiTemp = tiExe;
        tiExe = SdbFindNextTag(pdb, tiDatabase, tiExe);

        //
        // fallback to ensure we don't get caught in a loop because of a quirk in
        // sdbapi and a corrupt database. If we get handed back the same TAGID as before,
        // get out.
        //
        if (tiExe == tiTemp) {
            break;
        }
    }

    //
    // Loop through the published layers
    //
    tiLayer = SdbFindFirstTag(pdb, tiDatabase, TAG_LAYER);
    
    while (tiLayer) {
        WCHAR  szRegPath[MAX_PATH];
        TAGID  tiName;
        WCHAR* szName;
        TAGID  tiTemp;

        tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);
        if (!tiName) {
            bRet = FALSE;
            if (eMode == MODE_CLEANUP || eMode == MODE_UNINSTALL) {
                goto nextLayer;
            } else {
                vPrintError(IDS_NO_EXE_NAME);
                goto quickOut;
            }
        }
        szName = SdbGetStringTagPtr(pdb, tiName);
        if (!szName) {
            bRet = FALSE;
            if (eMode == MODE_CLEANUP || eMode == MODE_UNINSTALL) {
                goto nextLayer;
            } else {
                vPrintError(IDS_NO_EXE_NAME_PTR);
                goto quickOut;
            }
        }

        if (eMode == MODE_INSTALL) {

            if (!InstallSdbEntry(szName, wszSdbInstallName, TimeStamp.QuadPart, TRUE)) {
                bRet = FALSE;
                goto out;
            }

        } else {

            if (!UninstallSdbEntry(szName, wszSdbInstallName, TRUE)) {
                goto quickOut;
            }
        }

nextLayer:

        tiTemp = tiLayer;
        tiLayer = SdbFindNextTag(pdb, tiDatabase, tiLayer);
        
        //
        // fallback to ensure we don't get caught in a loop because of a quirk in
        // sdbapi and a corrupt database. If we get handed back the same TAGID as before,
        // get out.
        //
        if (tiLayer == tiTemp) {
            break;
        }
    }

    if (!ProcessMSIPackages(pdb, tiDatabase, wszSdbInstallName, TimeStamp.QuadPart, eMode)) {
        bRet = FALSE;
        goto quickOut;
    }

    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    //
    // now that we've handled the registry keys, copy the file
    //
    if (eMode == MODE_INSTALL) {
        //
        // ensure the directory exists
        //
        CreateDirectoryW(g_wszCustom, NULL);
        if (!CopyFileW(wszSdbPath, wszSdbInstallPath, TRUE)) {
            vPrintError(IDS_CANT_COPY_FILE, wszSdbInstallPath);
            bRet = FALSE;
            goto out;
        }
    } else {
        //
        // ensure that we don't fail because of read-only files
        //
        SetFileAttributesW(wszSdbInstallPath, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFileW(wszSdbInstallPath)) {
            vPrintError(IDS_CANT_DELETE_FILE, wszSdbInstallPath);
            bRet = FALSE;
        }
    }


    //
    // set up or delete the uninstall registry keys
    //
    if (eMode == MODE_INSTALL) {
        WCHAR wszSDBInstPath[MAX_PATH];
        WCHAR wszUninstallPath[MAX_PATH];
        WCHAR wszUninstallString[MAX_PATH * 2 + 10];
        HRESULT hr;

        //
        // goofball hack required because of crazy redirection strategy on IA64
        //
        wszSDBInstPath[0] = 0;
        SdbGetWindowsDirectory(wszSDBInstPath, ARRAYSIZE(wszSDBInstPath));

#if defined(_WIN64)    
        StringCchCatW(wszSDBInstPath, ARRAYSIZE(wszSDBInstPath), L"System32\\sdbinst.exe");
#else
        StringCchCatW(wszSDBInstPath, ARRAYSIZE(wszSDBInstPath), L"SysWow64\\sdbinst.exe");
#endif
        
        if (GetFileAttributesW(wszSDBInstPath) == -1) {
            //
            // there's no SysWow64 directory, so we'll just use system32
            //

            wszSDBInstPath[0] = 0;
            SdbGetWindowsDirectory(wszSDBInstPath, ARRAYSIZE(wszSDBInstPath));
            StringCchCatW(wszSDBInstPath, ARRAYSIZE(wszSDBInstPath), L"system32\\sdbinst.exe");
        }

        StringCchCopyW(wszUninstallPath, ARRAYSIZE(wszUninstallPath), UNINSTALL_KEY_PATH);
        StringCchCatW(wszUninstallPath, ARRAYSIZE(wszUninstallPath), wszSdbInstallName);
        StringCchCatW(wszUninstallPath, ARRAYSIZE(wszUninstallPath), L".sdb");

        lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                               wszUninstallPath,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS|GetWow64Flag(),
                               NULL,
                               &hKey,
                               NULL);
        
        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_CREATE_REG_KEY, wszUninstallPath);
            bRet = FALSE;
            goto out;
        }

        lRes = RegSetValueExW(hKey,
                              L"DisplayName",
                              0,
                              REG_SZ,
                              (PBYTE)wszFriendlyName,
                              (wcslen(wszFriendlyName) + 1) * sizeof(WCHAR));

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_CREATE_VALUE, wszUninstallPath);
            bRet = FALSE;
            goto out;
        }

        hr = StringCchPrintfW(wszUninstallString, ARRAYSIZE(wszUninstallString), L"%s -u \"%s\"", wszSDBInstPath, wszSdbInstallPath);
        if (FAILED(hr)) {
            vPrintError(IDS_CANT_CREATE_VALUE, wszUninstallPath);
            bRet = FALSE;
            goto out;
        }

        lRes = RegSetValueExW(hKey, L"UninstallString", 0, REG_SZ,
                              (PBYTE)wszUninstallString, (wcslen(wszUninstallString) + 1) * sizeof(WCHAR));

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_CREATE_VALUE, wszUninstallPath);
            bRet = FALSE;
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    } else {

        WCHAR wszUninstallPath[MAX_PATH];

        lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, UNINSTALL_KEY_PATH, 0, KEY_ALL_ACCESS|GetWow64Flag(), &hKey);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_OPEN_REG_KEY, UNINSTALL_KEY_PATH);
            bRet = FALSE;
            goto out;
        }

        //
        // create sdb path name
        //
        StringCchCopyW(wszUninstallPath, ARRAYSIZE(wszUninstallPath), wszSdbInstallName);
        StringCchCatW(wszUninstallPath, ARRAYSIZE(wszUninstallPath), L".sdb");

        lRes = LocalRegDeleteKeyW(hKey, wszUninstallPath);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_DELETE_REG_KEY, wszSdbInstallName, UNINSTALL_KEY_PATH);
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    //
    // register or unregister the DB
    //
    if (eMode == MODE_INSTALL) {
        if (!SdbRegisterDatabaseEx(wszSdbInstallPath, SDB_DATABASE_SHIM, &TimeStamp.QuadPart)) {
            vPrintError(IDS_CANT_REGISTER_DB, wszFriendlyName);
            bRet = FALSE;
            goto out;
        }
    } else {
        if (!SdbUnregisterDatabase(&guidDB)) {
            vPrintError(IDS_CANT_UNREGISTER_DB, wszFriendlyName);
        }
    }

    if (eMode == MODE_INSTALL) {
        vPrintMessage(IDS_INSTALL_COMPLETE, wszFriendlyName);
    } else {
        vPrintMessage(IDS_UNINSTALL_COMPLETE, wszFriendlyName);
    }

out:

    //
    // always silently delete the file on uninstall, whether we failed to remove the
    // registry entries or not.
    //
    if (eMode != MODE_INSTALL) {
        //
        // need to make sure the pdb is closed before deleting it.
        //
        if (pdb) {
            SdbCloseDatabase(pdb);
            pdb = NULL;
        }
        //
        // ensure that we don't fail because of read-only files
        //
        SetFileAttributesW(wszSdbInstallPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFileW(wszSdbInstallPath);
    }

quickOut:

    //
    // these cleanup steps are not strictly necessary, as they'll be cleaned up
    // on exit anyway. But what the heck.
    //
    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }
    if (hKey) {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    return bRet;
}


extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR    lpCmdLine,
    int       nCmdShow
    )
{
    int             i;
    int             nReturn = 0;
    WCHAR           wszSdbName[MAX_PATH];
    WCHAR           wszSdbPath[MAX_PATH];
    WCHAR           wszSdbInstallPath[MAX_PATH];
    WCHAR           wszOldSdbPath[MAX_PATH];
    TAGID           tiDBName = TAGID_NULL;
    WCHAR*          pszDBName = NULL;
    WCHAR           wszFriendlyName[256];
    WCHAR           wszGuid[100];
    
    OSVERSIONINFO   osvi;

    LPWSTR          szCommandLine;
    LPWSTR*         argv;
    int             argc;
    INSTALL_MODE    eMode;
    HRESULT         hr;
    DWORD           dwLen;

    g_hInst = hInstance;

    //
    // check to make sure the user is an administrator
    //
    if (!bCanRun()) {
        vPrintError(IDS_NEED_INSTALL_PERMISSION);
        return 1;
    }

    //
    // init custom directory
    //
    g_wszCustom[0] = 0;
    SdbGetWindowsDirectory(g_wszCustom, ARRAYSIZE(g_wszCustom));
    StringCchCatW(g_wszCustom, ARRAYSIZE(g_wszCustom), L"AppPatch\\Custom\\");
    
    CreateDirectoryW(g_wszCustom, NULL);

#if defined(_WIN64)    
    StringCchCatW(g_wszCustom, ARRAYSIZE(g_wszCustom), L"IA64\\");
    CreateDirectoryW(g_wszCustom, NULL);
#endif // _WIN64

    RtlZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {
        g_bWin2K = TRUE;
    }

    //
    // Note that this memory isn't freed because it will automatically
    // be freed on exit anyway, and there are a lot of exit cases from this application
    //
    szCommandLine = GetCommandLineW();
    argv = CommandLineToArgvW(szCommandLine, &argc);

    if (!argv) {
        vPrintError(IDS_CANT_GET_ARGS);
        return 1;
    }

    if (argc < 2) {
        vPrintHelp(argv[0]);
        return 0;
    }

    g_bQuiet = FALSE;
    eMode = MODE_INSTALL;
    wszSdbName[0] = 0;
    wszGuid[0] = 0;
    wszFriendlyName[0] = 0;

    for (i = 1; i < argc; ++i) {
        if (argv[i][0] == L'-' || argv[i][0] == L'/') {
            switch (tolower(argv[i][1])) {
            
            case L'?':
                vPrintHelp(argv[0]);
                return 0;
                break;

            case L'c':
                //
                // convert entries to new format
                //
                eMode = MODE_CONVERT_FORMAT_NEW;
                break;

            case L'g':
                i++;
                if (i >= argc) {
                    vPrintError(IDS_NEED_ARG, argv[i-1]);
                    vPrintHelp(argv[0]);
                    return 1;
                }
                eMode = MODE_UNINSTALL;
                hr = StringCchCopyW(wszGuid, ARRAYSIZE(wszGuid), argv[i]);
                if (FAILED(hr)) {
                    vPrintError(IDS_ARG_TOO_LONG);
                    vPrintHelp(argv[0]);
                    return 1;
                }
                break;

            case L'n':
                i++;
                if (i >= argc) {
                    vPrintError(IDS_NEED_ARG, argv[i-1]);
                    vPrintHelp(argv[0]);
                    return 1;
                }
                eMode = MODE_UNINSTALL;
                hr = StringCchCopyW(wszFriendlyName, ARRAYSIZE(wszFriendlyName), argv[i]);
                if (FAILED(hr)) {
                    vPrintError(IDS_ARG_TOO_LONG);
                    vPrintHelp(argv[0]);
                    return 1;
                }
                break;

            case L'p':
                g_bAllowPatches = TRUE;
                break;

            case L'r':
                //
                // revert to old format
                //
                eMode = MODE_CONVERT_FORMAT_OLD;
                break;

            case L'q':
                g_bQuiet = TRUE;
                break;

            case L'u':
                eMode = MODE_UNINSTALL;
                break;

            default:
                vPrintError(IDS_INVALID_SWITCH, argv[i]);
                vPrintHelp(argv[0]);
                return 1;
            }
        } else {
            if (wszSdbName[0]) {
                vPrintError(IDS_TOO_MANY_ARGS);
                vPrintHelp(argv[0]);
                return 1;
            }
            hr = StringCchCopyW(wszSdbName, ARRAYSIZE(wszSdbName), argv[i]);
            if (FAILED(hr)) {
                vPrintError(IDS_ARG_TOO_LONG);
                vPrintHelp(argv[0]);
                return 1;
            }
        }
    }

    //
    // check if we are running in a special 'setup' mode (converting or reverting the entries)
    //
    if (eMode == MODE_CONVERT_FORMAT_NEW || eMode == MODE_CONVERT_FORMAT_OLD) {
        OpenLogFile();
        if (!ConvertFormat(eMode == MODE_CONVERT_FORMAT_NEW)) {
            nReturn = 1;
        }
        CloseLogFile();
        return nReturn;
    }

    if (eMode == MODE_INSTALL && !wszSdbName[0]) {
        vPrintError(IDS_MUST_SPECIFY_SDB);
        vPrintHelp(argv[0]);
        return 1;
    }
    if (eMode == MODE_UNINSTALL && !wszSdbName[0] && !wszGuid[0] && !wszFriendlyName[0]) {
        vPrintError(IDS_MUST_SPECIFY_SDB);
        vPrintHelp(argv[0]);
        return 1;
    }

    if (wszSdbName[0]) {
        if (wszSdbName[1] == L':' || wszSdbName[1] == L'\\') {
            //
            // this is a full path name, so just copy it
            //
            hr = StringCchCopyW(wszSdbPath, ARRAYSIZE(wszSdbPath), wszSdbName);
            if (FAILED(hr)) {
                vPrintError(IDS_ARG_TOO_LONG);
                vPrintHelp(argv[0]);
                return 1;
            }
        } else {
            DWORD dwRet;

            //
            // this is a relative path name, so get the full one
            //
            if (!_wfullpath(wszSdbPath, wszSdbName, ARRAYSIZE(wszSdbPath))) {
                vPrintError(IDS_CANT_GET_FULL_PATH);
                return 1;
            }
        }
    }

    //
    // First, get the real file name from other params, if necessary
    //
    if (eMode == MODE_UNINSTALL) {
        if (wszGuid[0]) {
            DWORD dwLen = wcslen(wszGuid);

            if (dwLen != 38 || wszGuid[0] != L'{' || wszGuid[dwLen - 1] != L'}' ||
                wszGuid[9] != L'-' || wszGuid[14] != L'-' || wszGuid[19] != L'-' ||
                wszGuid[24] != L'-') {
                vPrintError(IDS_GUID_BAD_FORMAT);
                return 1;
            }
            StringCchCopyW(wszSdbName, ARRAYSIZE(wszSdbName), wszGuid);
            StringCchCatW(wszSdbName, ARRAYSIZE(wszSdbName), L".sdb");

            StringCchCopyW(wszSdbPath, ARRAYSIZE(wszSdbPath), g_wszCustom);
            StringCchCatW(wszSdbPath, ARRAYSIZE(wszSdbPath), wszSdbName);
        } else if (wszFriendlyName[0]) {
            if (!bFriendlyNameToFile(wszFriendlyName, wszSdbName, ARRAYSIZE(wszSdbName), wszSdbPath, ARRAYSIZE(wszSdbPath))) {
                vPrintError(IDS_NO_FRIENDLY_NAME, wszFriendlyName);
                return 1;
            }
        } else {
            if (!bIsAlreadyInstalled(wszSdbPath)) {
                WCHAR wszSdbPathTemp[MAX_PATH];

                //
                // they're not giving us an installed file, so get the GUID and convert to a file
                //
                if (!bFindInstallName(wszSdbPath, wszSdbPathTemp, ARRAYSIZE(wszSdbPathTemp))) {
                    return 1;
                }
                StringCchCopyW(wszSdbName, ARRAYSIZE(wszSdbName), wszSdbPathTemp); // name and path are the same
                StringCchCopyW(wszSdbPath, ARRAYSIZE(wszSdbPath), wszSdbPathTemp);
            }
        }
    }

    if (eMode == MODE_INSTALL &&
        GetFileAttributesW(wszSdbPath) != -1 &&
        bIsAlreadyInstalled(wszSdbPath)) {
        
        //
        // they asked us to install, it's installed, so we're done
        //
        vPrintMessage(IDS_ALREADY_INSTALLED, wszSdbPath);
        goto quickOut;
    }

    if (eMode == MODE_UNINSTALL && GetFileAttributesW(wszSdbPath) == -1) {
        //
        // they asked us to uninstall, it's not installed, so we're done
        //
        vPrintMessage(IDS_NOT_INSTALLED, wszSdbName);
        goto quickOut;
    }

    if (eMode == MODE_INSTALL && DatabaseContainsPatch(wszSdbPath) && !g_bAllowPatches) {

        //
        // we can't install because the SDB contains a patch and the user hasn't authorized it.
        //
        vPrintMessage(IDS_NO_PATCHES_ALLOWED);
        goto quickOut;
    }

    if (eMode == MODE_INSTALL && bOldSdbInstalled(wszSdbPath, wszOldSdbPath, ARRAYSIZE(wszOldSdbPath))) {
        //
        // we should ask if we're going to uninstall the old one,
        // unless we're in quiet mode.
        //
        int nRet;
        WCHAR wszCaption[1024];
        WCHAR wszText[1024];

        if (g_bQuiet) {
            nRet = IDYES;
        } else {
            if (!LoadStringW(g_hInst, IDS_APP_TITLE, wszCaption, ARRAYSIZE(wszCaption))) {
                return 1;
            }
            if (!LoadStringW(g_hInst, IDS_FOUND_SAME_ID, wszText, ARRAYSIZE(wszText))) {
                return 1;
            }

            nRet = MessageBoxW(NULL,
                               wszText,
                               wszCaption,
                               MB_YESNO | MB_ICONQUESTION);
        }
        
        if (nRet == IDNO) {
            return 0;
        } else if (nRet == IDYES) {
            if (!bHandleInstall(wszOldSdbPath, MODE_UNINSTALL, wszSdbInstallPath, ARRAYSIZE(wszSdbInstallPath))) {
                vPrintError(IDS_FAILED_UNINSTALL);
                return 1;
            }
        }
    }

    wszSdbInstallPath[0] = 0;

    if (!bHandleInstall(wszSdbPath, eMode, wszSdbInstallPath, ARRAYSIZE(wszSdbInstallPath))) {
        if (eMode == MODE_INSTALL) {
            //
            // we need to clean up; the install failed.
            //
            g_bQuiet = TRUE;
            bHandleInstall(wszSdbPath, MODE_CLEANUP, wszSdbInstallPath, ARRAYSIZE(wszSdbInstallPath));
        }
        nReturn = 1;
    }

    //
    // no matter what happens, flush the cache
    //
    vFlushCache();

quickOut:

    return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\shimviewer\listview.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Listview.cpp

  Abstract:

    Manages the list view.

  Notes:

    Unicode only.

  History:

    05/04/2001  rparsons    Created
    01/11/2002  rparsons    Cleaned up

--*/
#include "precomp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Initializes the list view column.

  Arguments:

    None.

  Return Value:

    -1 on failure.

--*/
int
InitListViewColumn(
    void
    )
{
    LVCOLUMN    lvc;

    lvc.mask        =   LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.iSubItem    =   0;
    lvc.pszText     =   (LPWSTR)L"Messages";
    lvc.cx          =   555;

    return (ListView_InsertColumn(g_ai.hWndList, 1, &lvc));
}

/*++

  Routine Description:

    Adds an item to the list view.

  Arguments:

    pwszItemText    -   Text that belongs to the item.

  Return Value:

    -1 on failure.

--*/
int
AddListViewItem(
    IN LPWSTR pwszItemText
    )
{
    LVITEM  lvi;
    int     nReturn = 0;


    lvi.iItem       =   ListView_GetItemCount(g_ai.hWndList);
    lvi.mask        =   LVIF_TEXT;
    lvi.iSubItem    =   0;
    lvi.pszText     =   pwszItemText;

    nReturn = ListView_InsertItem(g_ai.hWndList, &lvi);

    if (-1 != nReturn) {
        ListView_EnsureVisible(g_ai.hWndList, lvi.iItem, FALSE);
    }

    return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\shimviewer\main.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Main.cpp

  Abstract:

    Implements the entry point and message
    pump for the application.

  Notes:

    Unicode only.

  History:

    05/04/2001  rparsons    Created
    01/11/2002  rparsons    Cleaned up

--*/
#include "precomp.h"

APPINFO g_ai;

/*++

  Routine Description:

    Application entry point.

  Arguments:

    hInstance        -    App instance handle.
    hPrevInstance    -    Always NULL.
    lpCmdLine        -    Pointer to the command line.
    nCmdShow         -    Window show flag.

  Return Value:

    The wParam of the message or 0 on failure.

--*/
int
APIENTRY
WinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPSTR     lpCmdLine,
    IN int       nCmdShow
    )
{
    MSG                     msg;
    WNDCLASS                wndclass;
    WCHAR                   wszError[MAX_PATH];
    RECT                    rcDialog;
    RECT                    rcDesktopWorkArea;
    INITCOMMONCONTROLSEX    icex;
    POINT                   pt;
    HANDLE                  hMutex;
    int                     nWidth = 0, nHeight = 0;
    int                     nTaskbarHeight = 0;
    OSVERSIONINFOEX         osvi = {0};

    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(hPrevInstance);

    g_ai.hInstance = hInstance;

    //
    // Make sure we're the only instance running.
    //
    hMutex = CreateMutex(NULL, FALSE, L"ShimViewer");

    if (ERROR_ALREADY_EXISTS == GetLastError()) {
        return 0;
    }

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!GetVersionEx((OSVERSIONINFO*)&osvi)) {
        MessageBox(
            NULL, 
            L"Failed to get the OS version info", 
            L"Error",
            MB_ICONERROR);

        return -1;
    }

    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        osvi.dwMajorVersion == 5 && 
        osvi.dwMinorVersion >= 2) {

        g_ai.bUsingNewShimEng = TRUE;

        //
        // If we are using shimeng from NT 5.2 or newer we need
        // to create the debug objects to get debug spew from
        // OutputDebugString.
        //
        if (!CreateDebugObjects()) {
            MessageBox(
                NULL, 
                L"Failed to create the necessary objects to get debug spew "
                L"from OutputDebugString",
                L"Error",
                MB_ICONERROR);
            return 0;
        }

    } else {

        g_ai.bUsingNewShimEng = FALSE;
    }    

    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC)MainWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = APP_CLASS;

    if (!RegisterClass(&wndclass)) {
        LoadString(hInstance, IDS_NO_CLASS, wszError, ARRAYSIZE(wszError));
        MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
        return 0;
    }

    //
    // Set up the common controls.
    //
    icex.dwSize     =   sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC      =   ICC_LISTVIEW_CLASSES;

    if (!InitCommonControlsEx(&icex)) {
        InitCommonControls();
    }

    //
    // Get application settings from the registry, if there are any.
    //
    GetSaveSettings(FALSE);

    g_ai.hMainDlg = CreateDialog(hInstance,
                                 (LPCWSTR)IDD_MAIN,
                                 NULL,
                                 MainWndProc);

    if (!g_ai.hMainDlg) {
        LoadString(hInstance, IDS_NO_MAIN_DLG, wszError, ARRAYSIZE(wszError));
        MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
        return 0;
    }

    //
    // Get the window position info from the registry, if it's there.
    //
    GetSavePositionInfo(FALSE, &pt);

    //
    // If previous settings were retrieved from the registry, use them.
    //
    if (pt.x != 0) {
        SetWindowPos(g_ai.hMainDlg,
                     g_ai.fOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
                     pt.x,
                     pt.y,
                     0,
                     0,
                     SWP_NOSIZE | SWP_SHOWWINDOW);

    } else {
        //
        // Get the coords of the desktop window and place the dialog.
        // We put it in the bottom-right corner of the desktop above
        // the taskbar.
        //
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcDesktopWorkArea, 0);

        GetWindowRect(g_ai.hMainDlg, &rcDialog);

        nWidth  = rcDialog.right - rcDialog.left;
        nHeight = rcDialog.bottom - rcDialog.top;

        SetWindowPos(g_ai.hMainDlg,
                     g_ai.fOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
                     rcDesktopWorkArea.right - nWidth,
                     rcDesktopWorkArea.bottom - nHeight,
                     0,
                     0,
                     SWP_NOSIZE | SWP_SHOWWINDOW);
    }

    ShowWindow(g_ai.hMainDlg, g_ai.fMinimize ? SW_MINIMIZE : SW_SHOWNORMAL);

    while (GetMessage(&msg, (HWND)NULL, 0, 0)) {
        if (!IsDialogMessage(g_ai.hMainDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return (int)msg.wParam;
}

/*++

  Routine Description:

    Runs the message loop for the app.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK
MainWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) {
    case WM_INITDIALOG:
    {
        WCHAR   wszError[MAX_PATH];
        HICON   hIcon;

        //
        // Initialize the list view, menu items, and then create our thread.
        //
        g_ai.hWndList = GetDlgItem(hWnd, IDC_LIST);
        InitListViewColumn();

        hIcon = LoadIcon(g_ai.hInstance, MAKEINTRESOURCE(IDI_APPICON));

        SetClassLongPtr(hWnd, GCLP_HICON, (LONG_PTR)hIcon);

        CheckMenuItem(GetMenu(hWnd),
                      IDM_ON_TOP,
                      g_ai.fOnTop ? MF_CHECKED : MF_UNCHECKED);

        CheckMenuItem(GetMenu(hWnd),
                      IDM_START_SMALL,
                      g_ai.fMinimize ? MF_CHECKED : MF_UNCHECKED);

        CheckMenuItem(GetMenu(hWnd),
                      IDM_MONITOR,
                      g_ai.fMonitor ? MF_CHECKED : MF_UNCHECKED);

        if (g_ai.fMonitor) {
            if (!CreateReceiveThread()) {
                LoadString(g_ai.hInstance,
                           IDS_CREATE_FAILED,
                           wszError,
                           ARRAYSIZE(wszError));
                MessageBox(hWnd, wszError, APP_NAME, MB_ICONERROR);

                g_ai.fMonitor = FALSE;
            } else {
                SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS);
            }
        }

        break;

    }

    case WM_CLOSE:
    {
        RECT    rc;

        GetWindowRect(hWnd, &rc);
        GetSavePositionInfo(TRUE, (LPPOINT)&rc);
        GetSaveSettings(TRUE);
        RemoveFromTray(hWnd);
        EndDialog(hWnd, 0);
        PostQuitMessage(0);
        break;
    }

    case WM_SIZE:
    {
        HICON hIcon;

        if (SIZE_MINIMIZED == wParam) {
            ShowWindow(hWnd, SW_HIDE);

            hIcon = (HICON)LoadImage(g_ai.hInstance,
                                     MAKEINTRESOURCE(IDI_APPICON),
                                     IMAGE_ICON,
                                     16,
                                     16,
                                     0);

            AddIconToTray(hWnd, hIcon, APP_NAME);

            return TRUE;
        }

        MoveWindow(g_ai.hWndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);

        break;
    }

    case WM_NOTIFYICON:
        switch (lParam) {
        case WM_RBUTTONUP:

            DisplayMenu(hWnd);
            break;

        case WM_LBUTTONDBLCLK:

            RemoveFromTray(hWnd);
            ShowWindow(hWnd, SW_SHOWNORMAL);
            break;

        default:
            break;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDM_EXIT:

            PostMessage(hWnd, WM_CLOSE, 0, 0);
            break;

        case IDM_RESTORE:

            ShowWindow(hWnd, SW_SHOWNORMAL);
            SetWindowPos(hWnd,
                         g_ai.fOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
                         0,
                         0,
                         0,
                         0,
                         SWP_NOSIZE | SWP_NOMOVE);
            RemoveFromTray(hWnd);
            break;

        case IDM_ABOUT:

            ShellAbout(hWnd,
                       APP_NAME,
                       WRITTEN_BY,
                       LoadIcon(g_ai.hInstance, MAKEINTRESOURCE(IDI_APPICON)));
            break;

        case IDM_MONITOR:

            CheckMenuItem(GetMenu(hWnd),
                          IDM_MONITOR,
                          g_ai.fMonitor ? MF_UNCHECKED : MF_CHECKED);

            g_ai.fMonitor = g_ai.fMonitor ? FALSE : TRUE;

            if (g_ai.fMonitor) {
                CreateReceiveThread();
            }

            break;

        case IDM_ON_TOP:

            CheckMenuItem(GetMenu(hWnd),
                          IDM_ON_TOP,
                          g_ai.fOnTop ? MF_UNCHECKED : MF_CHECKED);

            SetWindowPos(hWnd,
                         g_ai.fOnTop ? HWND_NOTOPMOST : HWND_TOPMOST,
                         0,
                         0,
                         0,
                         0,
                         SWP_NOSIZE | SWP_NOMOVE);

            g_ai.fOnTop = g_ai.fOnTop ? FALSE : TRUE;
            break;

        case IDM_START_SMALL:

            CheckMenuItem(GetMenu(hWnd),
                          IDM_START_SMALL,
                          g_ai.fMinimize ? MF_UNCHECKED : MF_CHECKED);

            g_ai.fMinimize = g_ai.fMinimize ? FALSE : TRUE;
            break;

        case IDM_CLEAR:

            ListView_DeleteAllItems(g_ai.hWndList);
            break;

        default:
            break;

        }

    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\shimviewer\misc.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Misc.cpp

  Abstract:

    Implements misc. functionality

  Notes:

    Unicode only.

  History:

    05/04/2001  rparsons    Created
    01/11/2002  rparsons    Cleaned up

--*/
#include "precomp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Retrieves or sets position info in the registry.

  Arguments:

    fSave   -   If true, indicates we're saving data.
    *lppt   -   A POINT structure that contains/receives our data.

  Return Value:

    None.

--*/
void
GetSavePositionInfo(
    IN     BOOL   fSave,
    IN OUT POINT* lppt
    )
{
    HKEY        hKey;
    DWORD       cbSize = 0, dwDisposition = 0;
    LONG        lRetVal = 0;

    //
    // Initialize our coordinates in case there's no data there.
    //
    if (!fSave) {
        lppt->x = lppt->y = 0;
    }

    //
    // Open the registry key (or create it if the first time being used).
    //
    lRetVal = RegCreateKeyEx(HKEY_CURRENT_USER,
                             L"Software\\Microsoft\\ShimViewer",
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_QUERY_VALUE | KEY_SET_VALUE,
                             0,
                             &hKey,
                             &dwDisposition);

    if (ERROR_SUCCESS != lRetVal) {
        return;
    }

    //
    // Save or retrieve our coordinates.
    //
    if (fSave) {
        RegSetValueEx(hKey,
                      L"DlgCoordinates",
                      0,
                      REG_BINARY,
                      (const BYTE*)lppt,
                      sizeof(*lppt));

    } else {
        cbSize = sizeof(*lppt);
        RegQueryValueEx(hKey,
                        L"DlgCoordinates",
                        0,
                        0,
                        (LPBYTE)lppt,
                        &cbSize);
    }

    RegCloseKey(hKey);
}

/*++

  Routine Description:

    Retrieves or sets setting info in the registry.

  Arguments:

    fSave   -   If true, indicates we're saving data.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
void
GetSaveSettings(
    IN BOOL fSave
    )
{
    HKEY    hKey;
    LONG    lRetVal = 0;
    DWORD   dwOnTop = 0, dwMinimize = 0, dwMonitor = 0;
    DWORD   dwDisposition = 0, cbSize = 0;

    //
    // Open the registry key (or create it if the first time being used).
    //
    lRetVal = RegCreateKeyEx(HKEY_CURRENT_USER,
                             L"Software\\Microsoft\\ShimViewer",
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             0,
                             &hKey,
                             &dwDisposition);

    if (ERROR_SUCCESS != lRetVal) {
        return;
    }

    if (fSave) {
        if (g_ai.fOnTop) {
            dwOnTop = 1;
        }

        if (g_ai.fMinimize) {
            dwMinimize = 1;
        }

        if (g_ai.fMonitor) {
            dwMonitor = 1;
        }

        lRetVal = RegSetValueEx(hKey,
                      L"AlwaysOnTop",
                      0,
                      REG_DWORD,
                      (const BYTE*)&dwOnTop,
                      sizeof(DWORD));

        RegSetValueEx(hKey,
                      L"StartMinimize",
                      0,
                      REG_DWORD,
                      (const BYTE*)&dwMinimize,
                      sizeof(DWORD));

        RegSetValueEx(hKey,
                      L"MonitorMessages",
                      0,
                      REG_DWORD,
                      (const BYTE*)&dwMonitor,
                      sizeof(DWORD));


    } else {
        cbSize = sizeof(DWORD);
        RegQueryValueEx(hKey,
                        L"AlwaysOnTop",
                        0,
                        0,
                        (LPBYTE)&dwOnTop,
                        &cbSize);

        cbSize = sizeof(DWORD);
        RegQueryValueEx(hKey,
                        L"StartMinimize",
                        0,
                        0,
                        (LPBYTE)&dwMinimize,
                        &cbSize);

        cbSize = sizeof(DWORD);
        lRetVal = RegQueryValueEx(hKey,
                                  L"MonitorMessages",
                                  0,
                                  0,
                                  (LPBYTE)&dwMonitor,
                                  &cbSize);

        if (dwOnTop) {
            g_ai.fOnTop = TRUE;
        }

        if (dwMinimize) {
            g_ai.fMinimize = TRUE;
        }

        if (dwMonitor || ERROR_SUCCESS != lRetVal) {
            g_ai.fMonitor = TRUE;
        }

    }

    RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\shimviewer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shimview.rc
//
#define IDS_NO_CLASS                    1
#define IDS_NO_MAIN_DLG                 2
#define IDS_CREATE_FAILED               3
#define IDD_MAIN                        101
#define IDR_MENU                        102
#define IDI_APPICON                     102
#define IDM_MENU                        102
#define IDM_POPUP                       104
#define IDC_LIST                        1000
#define IDM_MONITOR                     40001
#define IDM_EXIT                        40002
#define IDM_ABOUT                       40003
#define IDM_ON_TOP                      40004
#define IDM_RESTORE                     40005
#define IDM_START_SMALL                 40006
#define IDM_CLEAR                       40007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40008
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\shimviewer\precomp.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Precomp.h

  Abstract:

    Contains constants, function prototypes, structures, etc.
    used throughout the application.

  Notes:

    Unicode only.

  History:

    05/04/2001  rparsons    Created
    01/11/2002  rparsons    Cleaned up
    02/20/2002  rparsons    Implemented strsafe

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <process.h>
#include <string.h>
#include <commctrl.h>
#include <shellapi.h>
#include <strsafe.h>
#include "resource.h"

//
// Constants used throughout the application.
//
#define APP_NAME        L"ShimViewer"
#define APP_CLASS       L"SHIMVIEW"
#define WRITTEN_BY      L"Written by rparsons"
#define PIPE_NAME       L"\\\\.\\pipe\\ShimViewer" 

//
// For our tray icon.
//
#define ICON_NOTIFY     10101
#define WM_NOTIFYICON   (WM_APP + 100)

#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))

//
// Contains all the information we'll need throughout the application.
//
typedef struct _APPINFO {
    HWND        hMainDlg;           // main dialog handle
    HWND        hWndList;           // list view handle
    HINSTANCE   hInstance;          // main instance handle
    BOOL        fOnTop;             // flag for window position
    BOOL        fMinimize;          // flag for window placement
    BOOL        fMonitor;           // flag for monitoring messages
    UINT        uThreadId;          // receive thread identifier
    UINT        uInstThreadId;      // instance thread identifier
    BOOL        bUsingNewShimEng;   // are we using the shimeng from NT 5.2+?
} APPINFO, *LPAPPINFO;

INT_PTR
CALLBACK
MainWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL 
AddIconToTray(
    IN HWND    hWnd,
    IN HICON   hIcon,
    IN LPCWSTR pwszTip
    );

BOOL
RemoveFromTray(
    IN HWND hWnd
    );

BOOL 
DisplayMenu(
    IN HWND hWnd
    );

BOOL
CreateReceiveThread(
    void
    );

BOOL
CreateDebugObjects(
   void
   );

void
GetSavePositionInfo(
    IN     BOOL   fSave,
    IN OUT POINT* lppt
    );

void
GetSaveSettings(
    IN BOOL fSave
    );

int
InitListViewColumn(
    void
    );

int
AddListViewItem(
    IN LPWSTR pwszItemText
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\shimviewer\ipc.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    ipc.cpp

  Abstract:

    Implements code that communicates with shimeng to get the debug spew.
    On xpsp1 and beyong we get the debug info spewed by OutputDebugString. 
    On the older platforms we use named pipes to communicate with shimeng.

  Notes:

    Unicode only.

  History:

    04/22/2002 maonis   Created 

--*/
#include "precomp.h"

extern APPINFO g_ai;

// These are the only types of objects we created.
typedef enum _SHIMVIEW_OBJECT_TYPE
{
    SHIMVIEW_EVENT = 0,
    SHIMVIEW_FILE_MAPPING,
    SHIMVIEW_NAMED_PIPE
} SHIMVIEW_OBJECT_TYPE;

//
// Stuff we need for the new version.
//
#define SHIMVIEW_SPEW_LEN 2048
#define DEBUG_SPEW_DATA_PREFIX     "SHIMVIEW:"
#define DEBUG_SPEW_DATA_PREFIX_LEN (sizeof(DEBUG_SPEW_DATA_PREFIX)/sizeof(CHAR) - 1)

LPSTR  g_pDebugSpew;
HANDLE g_hReadyEvent;
HANDLE g_hAckEvent;

/*++

  Routine Description:

    Creates a security descriptor that gives Everyone read and write access
    to the object itself, ie, we don't include permissions like WRITE_OWNER
    or WRITE_DAC.

    The resulting security descriptor should be freed by the caller using 
    free.

  Arguments:

    eObjectType      -   the object type.

  Return Value:

    NULL on failure, a valid security descriptor on success.

--*/
PSECURITY_DESCRIPTOR
CreateShimViewSd(
    SHIMVIEW_OBJECT_TYPE eObjectType
    )
{
    BOOL                    bIsSuccess = FALSE;
    PSID                    pWorldSid = NULL;
    PSECURITY_DESCRIPTOR    pWorldSd = NULL;
    DWORD                   dwAclSize = 0;
    PACL                    pAcl = NULL;
    DWORD                   dwAccessMask = 0;

    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    if (!AllocateAndInitializeSid(&WorldSidAuthority,
                                 1,
                                 SECURITY_WORLD_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pWorldSid)) {
        MessageBox(NULL, L"Failed to allocate a SID", L"Error!", MB_ICONERROR);
        goto cleanup;
    } 

    dwAclSize = 
        sizeof (ACL) + 
        sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD) + 
        GetLengthSid(pWorldSid);
    
    pWorldSd = (PSECURITY_DESCRIPTOR)malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + dwAclSize);

    if (pWorldSd == NULL) {
        MessageBox(
            NULL, 
            L"Failed to allocate memory for the security descriptor", 
            L"Error",
            MB_ICONERROR);

        goto cleanup;
    }

    pAcl = (PACL)((BYTE *)pWorldSd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeAcl(pAcl,
                       dwAclSize,
                       ACL_REVISION)) {
        MessageBox(
            NULL, 
            L"Failed to allocate memory for the security descriptor", 
            L"Error",
            MB_ICONERROR);

        goto cleanup;
    }

    switch (eObjectType) {
        case SHIMVIEW_EVENT:
            dwAccessMask = READ_CONTROL | SYNCHRONIZE | EVENT_MODIFY_STATE;
            break;

        case SHIMVIEW_FILE_MAPPING:
            dwAccessMask = FILE_MAP_READ | FILE_MAP_WRITE;
            break;

        case SHIMVIEW_NAMED_PIPE:
            dwAccessMask = GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE;
            break;

        default:
            MessageBox(
                NULL, 
                L"You specified an unknown object type to create the security descriptor", 
                L"Error",
                MB_ICONERROR);

            goto cleanup;
    }

    if (!AddAccessAllowedAce(pAcl,
                             ACL_REVISION,
                             dwAccessMask,
                             pWorldSid)) {
        MessageBox(
            NULL, 
            L"Failed to add the ACE to the security descriptor", 
            L"Error",
            MB_ICONERROR);

        goto cleanup;
    }

    if (!InitializeSecurityDescriptor(pWorldSd, SECURITY_DESCRIPTOR_REVISION) ||
        !SetSecurityDescriptorDacl(pWorldSd, TRUE, pAcl, FALSE)) {

        MessageBox(
            NULL, 
            L"Failed to set the DACL for the security descriptor", 
            L"Error",
            MB_ICONERROR);

        goto cleanup;
    }

    bIsSuccess = TRUE;

cleanup:

    if (pWorldSid) {
        FreeSid(pWorldSid);
    }

    if (!bIsSuccess) {

        if (pWorldSd) {
            free(pWorldSd);
            pWorldSd = NULL;
        }
    }
    
    return pWorldSd;
}

void
AddSpewW(
    LPCWSTR pwszBuffer
    )
{
    WCHAR*  pTemp = NULL;

    //
    // See if this is a new process notification.
    //
    pTemp = wcsstr(pwszBuffer, L"process");

    if (pTemp) {
        //
        // We got a new process notification.
        // See if any items are already in the list
        //
        if (ListView_GetItemCount(g_ai.hWndList)) {
            AddListViewItem(L"");
        }
    }

    AddListViewItem((LPWSTR)pwszBuffer);
}

void
AddSpewA(
    LPCSTR pszBuffer
    )
{
    int iChars = 0;
    LPWSTR pwszBuffer = NULL;
    
    iChars = MultiByteToWideChar(CP_ACP, 0, pszBuffer, -1, NULL, 0);

    if (iChars) {

        pwszBuffer = (LPWSTR)malloc(iChars * sizeof(WCHAR));

        if (pwszBuffer) {

            if (MultiByteToWideChar(CP_ACP, 0, pszBuffer, -1, pwszBuffer, iChars)) {

                pwszBuffer[iChars - 1] = 0;
                AddSpewW(pwszBuffer);
            }

            free(pwszBuffer);
        }
    }
}

/*++

  Routine Description:

    Thread callback responsible for receiving data from the client.

  Arguments:

    *pVoid      -   A handle to the pipe.

  Return Value:

    -1 on failure, 1 on success.

--*/
UINT
InstanceThread(
    IN void* pVoid
    )
{
    HANDLE  hPipe;
    BOOL    fSuccess = TRUE;
    DWORD   cbBytesRead = 0;
    WCHAR   wszBuffer[SHIMVIEW_SPEW_LEN];

    //
    // The pipe handle was passed as an argument.
    //
    hPipe = (HANDLE)pVoid;

    while (TRUE) {
        fSuccess = ReadFile(hPipe,
                            wszBuffer,
                            SHIMVIEW_SPEW_LEN * sizeof(WCHAR),
                            &cbBytesRead,
                            NULL);

        if (!fSuccess || cbBytesRead == 0) {
            break;
        }

        wszBuffer[cbBytesRead / sizeof(WCHAR)] = 0;

        AddSpewW(wszBuffer);
    }

    //
    // Flush the pipe to allow the client to read the pipe's contents
    // before disconnecting. Then disconnect the pipe, and close the
    // handle to this pipe instance.
    //
    FlushFileBuffers(hPipe);
    DisconnectNamedPipe(hPipe);
    CloseHandle(hPipe);

    return 1;
}

/*++

  Routine Description:

    Creates a pipe and listens for messages from the client.
    This code is modified from the pipe.cpp that was sd deleted.

  Arguments:

    None.

  Return Value:

    -1 on failure, 0 on success.

--*/
UINT
CreatePipeAndWait()
{
    HANDLE hPipe, hThread;
    BOOL   fConnected = FALSE;

    while (g_ai.fMonitor) {
        //
        // Create the named pipe.
        //
        SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, FALSE};
        PSECURITY_DESCRIPTOR pSd = CreateShimViewSd(SHIMVIEW_NAMED_PIPE);

        if (pSd == NULL) {
            return -1;
        }

        sa.lpSecurityDescriptor = pSd;

        hPipe = CreateNamedPipe(PIPE_NAME,                  // pipe name
                                PIPE_ACCESS_INBOUND,        // read access
                                PIPE_TYPE_MESSAGE |         // message type pipe
                                PIPE_READMODE_MESSAGE |     // message-read mode
                                PIPE_WAIT,                  // blocking mode
                                PIPE_UNLIMITED_INSTANCES,   // max. instances
                                0,                          // output buffer size
                                SHIMVIEW_SPEW_LEN,          // input buffer size
                                0,                          // client time-out
                                &sa);                       // no security attribute

        free(pSd);

        if (INVALID_HANDLE_VALUE == hPipe) {
            return -1;
        }

        //
        // Wait for clients to connect.
        //
        fConnected = ConnectNamedPipe(hPipe, NULL) ?
            TRUE :
            (GetLastError() == ERROR_PIPE_CONNECTED);

        if (fConnected && g_ai.fMonitor) {
            hThread = (HANDLE)_beginthreadex(NULL,
                                             0,
                                             &InstanceThread,
                                             (LPVOID)hPipe,
                                             0,
                                             &g_ai.uInstThreadId);

            if (INVALID_HANDLE_VALUE == hThread) {
                return -1;
            } else {
                CloseHandle(hThread);
            }

        } else {
            CloseHandle(hPipe);
        }
    }

    return 0;
}

/*++

  Routine Description:

    Waits for the spew from OutputDebugString and add it to the listview.

    Code is modified from the dbmon source.

  Arguments:

    None.

  Return Value:

    -1 on failure, 0 on success.

--*/
UINT
GetOutputDebugStringSpew()
{
    DWORD dwRet;

    while (TRUE) {

        dwRet = WaitForSingleObject(g_hReadyEvent, INFINITE);

        if (dwRet != WAIT_OBJECT_0) {

            return -1;

        } else {
            if (g_ai.fMonitor && 
                !strncmp(g_pDebugSpew, 
                         DEBUG_SPEW_DATA_PREFIX, 
                         DEBUG_SPEW_DATA_PREFIX_LEN)) {

                //
                // Only add when it came from shimeng.
                //
                AddSpewA(g_pDebugSpew + DEBUG_SPEW_DATA_PREFIX_LEN);
            }

            SetEvent(g_hAckEvent);
        }
    }

    return 0;
}

/*++

  Routine Description:

    Creates the necessary objects to get the spew from OutputDebugString.

    Code is modified from the dbmon source.

  Arguments:

    None.

  Return Value:

    FALSE on failure, TRUE on success.

--*/
BOOL
CreateDebugObjects(
    void
    )
{
    SECURITY_ATTRIBUTES     saEvent = {sizeof(SECURITY_ATTRIBUTES), NULL, FALSE};
    SECURITY_ATTRIBUTES     saFileMapping = {sizeof(SECURITY_ATTRIBUTES), NULL, FALSE};
    PSECURITY_DESCRIPTOR    pSdEvent = NULL;
    PSECURITY_DESCRIPTOR    pSdFileMapping = NULL;
    HANDLE                  hSharedFile;
    LPVOID                  pSharedMem;
    BOOL                    bReturn = FALSE;

    pSdEvent = CreateShimViewSd(SHIMVIEW_EVENT);
    if (pSdEvent == NULL) {
        goto cleanup;
    }

    pSdFileMapping = CreateShimViewSd(SHIMVIEW_FILE_MAPPING);

    if (pSdFileMapping == NULL) {
        goto cleanup;
    }

    saEvent.lpSecurityDescriptor = pSdEvent;
    saFileMapping.lpSecurityDescriptor = pSdFileMapping;

    g_hAckEvent = CreateEvent(&saEvent, FALSE, FALSE, L"DBWIN_BUFFER_READY");

    if (g_hAckEvent == NULL) {
        goto cleanup;
    }

    g_hReadyEvent = CreateEvent(&saEvent, FALSE, FALSE, L"DBWIN_DATA_READY");

    if (g_hReadyEvent == NULL) {
        goto cleanup;
    }

    hSharedFile = CreateFileMapping((HANDLE)-1,
                                    &saFileMapping,
                                    PAGE_READWRITE,
                                    0,
                                    4096,
                                    L"DBWIN_BUFFER");

    if (hSharedFile == NULL) {
        goto cleanup;
    }

    pSharedMem = MapViewOfFile(hSharedFile,
                               FILE_MAP_READ,
                               0,
                               0,
                               512);

    if (pSharedMem == NULL) {
        goto cleanup;
    }

    g_pDebugSpew = (LPSTR)pSharedMem + sizeof(DWORD);

    SetEvent(g_hAckEvent);

    bReturn = TRUE;

cleanup:

    if (pSdEvent) {
        free(pSdEvent);
    }

    if (pSdFileMapping) {
        free(pSdFileMapping);
    }

    return bReturn;
}

UINT
GetSpewProc(
    IN void* pVoid
    )
{
    if (g_ai.bUsingNewShimEng) {

        return GetOutputDebugStringSpew();

    } else {

        return CreatePipeAndWait();
    }    
}

/*++

  Routine Description:

    Check the version of the OS - for 5.2 and beyong shimeng outputs debug spew via
    OutputDebugString. For OS version < 5.2 it writes to the named pipe.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CreateReceiveThread(
    void
    )
{
    HANDLE  hThread;        

    hThread = (HANDLE)_beginthreadex(NULL,
                                     0,
                                     &GetSpewProc,
                                     NULL,
                                     0,
                                     &g_ai.uThreadId);
    CloseHandle(hThread);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\shimviewer\tray.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Tray.cpp

  Abstract:

    Implements systray functionality.

  Notes:

    Unicode only.

  History:

    05/04/2001  rparsons    Created
    01/11/2002  rparsons    Cleaned up

--*/
#include "precomp.h"

/*++

  Routine Description:

    Adds the specified icon to the system tray.

  Arguments:

    hWnd        -   Parent window handle.
    hIcon       -   Icon handle to add to the tray.
    pwszTip     -   Tooltip to associate with the icon.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
AddIconToTray(
    IN HWND    hWnd,
    IN HICON   hIcon,
    IN LPCWSTR pwszTip
    )
{
    NOTIFYICONDATA  pnid;
    
    pnid.cbSize             =   sizeof(NOTIFYICONDATA); 
    pnid.hWnd               =   hWnd; 
    pnid.uID                =   ICON_NOTIFY; 
    pnid.uFlags             =   NIF_ICON | NIF_MESSAGE | NIF_TIP; 
    pnid.uCallbackMessage   =   WM_NOTIFYICON; 
    pnid.hIcon              =   hIcon;
    
    if (pwszTip) {
        StringCchCopy(pnid.szTip, ARRAYSIZE(pnid.szTip), pwszTip);
    } else {
        *pnid.szTip = 0;
    }
    
    return Shell_NotifyIcon(NIM_ADD, &pnid);
}

/*++

  Routine Description:

    Removes the specified icon from the system tray.

  Arguments:

    hWnd    -   Parent window handle.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
RemoveFromTray(
    IN HWND hWnd
    )
{
    NOTIFYICONDATA  pnid;
    
    pnid.cbSize     =    sizeof(NOTIFYICONDATA); 
    pnid.hWnd       =    hWnd; 
    pnid.uID        =    ICON_NOTIFY; 
    
    return Shell_NotifyIcon(NIM_DELETE, &pnid);
}

/*++

  Routine Description:

    Displays a popup menu for the tray icon.

  Arguments:

    hWnd    -   Main window handle.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
DisplayMenu(
    IN HWND hWnd
    )
{
    MENUITEMINFO    mii;
    HMENU           hMenu;
    POINT           pt;
    BOOL            bReturn = FALSE;

    const WCHAR     wszItemOne[] = L"&Restore";
    const WCHAR     wszItemTwo[] = L"E&xit";
    
    hMenu = CreatePopupMenu();

    if (hMenu) {
        mii.cbSize          =   sizeof(MENUITEMINFO);
        mii.fMask           =   MIIM_DATA | MIIM_ID | MIIM_TYPE | MIIM_STATE;
        mii.fType           =   MFT_STRING;                            
        mii.wID             =   IDM_RESTORE;
        mii.hSubMenu        =   NULL;                                
        mii.hbmpChecked     =   NULL;                                
        mii.hbmpUnchecked   =   NULL;                                
        mii.dwItemData      =   0;
        mii.dwTypeData      =   (LPWSTR)wszItemOne;
        mii.cch             =   ARRAYSIZE(wszItemOne);
        mii.fState          =   MFS_ENABLED;

        InsertMenuItem(hMenu, 0, TRUE, &mii);

        mii.cbSize          =   sizeof(MENUITEMINFO);  
        mii.fMask           =   MIIM_TYPE; 
        mii.fType           =   MFT_SEPARATOR; 
        mii.hSubMenu        =   NULL; 
        mii.hbmpChecked     =   NULL; 
        mii.hbmpUnchecked   =   NULL; 
        mii.dwItemData      =   0;
        
        InsertMenuItem(hMenu, 1, TRUE, &mii);

        mii.cbSize           =  sizeof(MENUITEMINFO);
        mii.fMask            =  MIIM_DATA | MIIM_ID | MIIM_TYPE | MIIM_STATE;
        mii.fType            =  MFT_STRING;                            
        mii.wID              =  IDM_EXIT;
        mii.hSubMenu         =  NULL;                                
        mii.hbmpChecked      =  NULL;                                
        mii.hbmpUnchecked    =  NULL;                                
        mii.dwItemData       =  0;
        mii.dwTypeData       =  (LPWSTR)wszItemTwo;
        mii.cch              =  ARRAYSIZE(wszItemTwo);
        mii.fState           =  MFS_ENABLED;

        InsertMenuItem(hMenu, 2, TRUE, &mii);

        GetCursorPos(&pt);        

        bReturn = TrackPopupMenuEx(hMenu,
                                   TPM_CENTERALIGN | TPM_RIGHTBUTTON,
                                   pt.x,
                                   pt.y,
                                   hWnd,
                                   NULL);
        
        DestroyMenu(hMenu);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\core.inc ===
C_DEFINES=$(C_DEFINES)           \
          -DGENERIC_INPUT        \
          -DSUBPIXEL_MOUSE       \
          -DHUNGAPP_GHOSTING     \
          -DIMM_PER_LOGON        \
          -DLAZY_CLASS_INIT      \
          -DAUTORUN_CURSOR       \
          -DMOUSE_IP             \
          -DGI_SINK              \
          -DMESSAGE_PUMP_HOOK    \
          -DCUAS_ENABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_glob.c ===
/////   LPK_GLOB - LPK Global variable structure
//
//      The following data is global to each process.
//
//      This structure is instantiated with the name G by GAD.C. hence
//      any code can refer to these variables as G.xxx.
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//




#define LPKGLOBALHERE


#include "lpk_glob.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_gdi.cxx ===
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Module Name : LPK_GDI.c                                                 //
//                                                                          //
//  Entry points (formal interfaces) for GDI32 to call                      //
//  and route their APIs, so that we can implement our language-specific    //
//  features.                                                               //
//                                                                          //
//  Created : Oct 24, 1996                                                  //
//  Author  : Mohamed AbdEl Hamid  [mhamid]                                 //
//                                                                          //
//  Copyright (c) 1996, Microsoft Corporation. All rights reserved.         //
//////////////////////////////////////////////////////////////////////////////

#include "precomp.hxx"


////    FontHasWesternScript
//
//      Detect if the current selected font in the hdc has Western script or not by using
//      the cached data g_FontIDCache. and also add the selected font to the cache it it is
//      not cached before.
//      All calles used inside this function is Client-mode calls except if the font will be
//      cached then calling GetGlyphIndices (Kernel-mode call) will take place.
//      This function used in the optimization checking for ExtTextOut and GetTextExtent.
//
//      entry   hdc      - Device context
//
//      return value:    TRUE if font has western script. FALSE otherwise.
//

BOOL FontHasWesternScript(HDC hdc)
{
   REALIZATION_INFO ri;
   int              i;
   WORD             Glyphs[4];
   BOOL             fRet;

   if (!GdiRealizationInfo(hdc, &ri)) {
      return FALSE;
   }

   EnterCriticalSection(&csFontIdCache);

   if (g_cCachedFontsID > 0) {
      for (i=0 ; i<g_cCachedFontsID ; i++) {
         if (ri.uFontFileID == g_FontIDCache[i].uFontFileID) {
            fRet = g_FontIDCache[i].bHasWestern;
            LeaveCriticalSection(&csFontIdCache);
            return (fRet);
         }
      }
   }

   if ((GetGlyphIndicesW(hdc , L"dMr\"" , 4 , Glyphs , GGI_MARK_NONEXISTING_GLYPHS) == 4) &&
       (Glyphs[0] != 0xFFFF && Glyphs[1] != 0xFFFF && Glyphs[2] != 0xFFFF && Glyphs[3] != 0xFFFF)) {

      g_FontIDCache[g_pCurrentAvailablePos].bHasWestern     = fRet = TRUE;
   } else {
      g_FontIDCache[g_pCurrentAvailablePos].bHasWestern     = fRet = FALSE;
   }
   g_FontIDCache[g_pCurrentAvailablePos].uFontFileID  = ri.uFontFileID        ;

   g_pCurrentAvailablePos++;
   if (g_pCurrentAvailablePos >= MAX_FONT_ID_CACHE) {
       g_pCurrentAvailablePos = 0;
   }
   if (g_cCachedFontsID < MAX_FONT_ID_CACHE) {
      g_cCachedFontsID++;
   }
   LeaveCriticalSection(&csFontIdCache);
   return (fRet);
}



////    InternalTextOut
//
//      Display text with possible font association
//
//      entry   hdc      - Device context
//              x,y      - Starting coords (Unless TA_UPDATECP)
//              uOptions - Flags (see below)
//              prc      - Pointer to clipping rectangle
//              pString  - Unicode string
//              cbCount  - String length in unicode characters
//              pdx      - Overriding logical dx array
//              iCharset  - Original ANSI iCharset, or -1 if unicode
//
//      exit    TRUE if string drawn OK
//
//      options ETO_CLIPPED    - Clip to clipping rectangle
//              ETO_OPAQUE     - Extend background colour to bounds of clipping rectangle
//              ETO_RTLREADING - Render text with right to left reading order
//              ETO_NUMERICSLOCAL
//              ETO_NUMERICSLATIN
//              ETO_PDY        - lpdx array contains DX,DY pairs - causes LPK to be bypassed
//
//      note    LpkExtTextOut also obeys options set by SetTextAlign:
//              TA_LEFT       - x,y is position of left edge of displayed glyphs
//              TA_CENTRE     - x,y is position at centre of diplayed glyphs
//              TA_RIGHT      - x,y is position at right edge of displayed glyphs
//              TA_RTLREADING - Render text with right to left reading order
//              TA_UPDATECP   - Get x,y from current position, ignoring x,y parameters,
//                              update current position following textout.
//
//      history Oct 22, 1996 -by- Samer Arafeh [samera]
//              Oct 24, 1996 -by- Mohamed AbdEl Hamid [mhamid]
//              Feb 18, 1887 dbrown - Support font association






/////   InternalTextOut
//
//

BOOL InternalTextOut(
    HDC           hdc,
    int           x,
    int           y,
    UINT          uOptions,
    const RECT   *prc,
    const WCHAR  *pStr,
    UINT          cbCount,
    const int    *piDX,
    int           iCharset,
    int          *piWidth,
    int           iRequiredWidth) {

    BOOL          fRTLreading;
    int           iDigitSubstitute;
    int           iTextAlign;
    HRESULT       hr;
    DWORD         dwObjType;
    DWORD         dwSicFlags;   // Flags for ScriptIsComplex
    int           iCurrentCharSet;
    STRING_ANALYSIS *psa;

    UNREFERENCED_PARAMETER(iRequiredWidth) ;


    if (!cbCount || !pStr) {

        // Empty string - no glyph processing required. Optimise ...

        return ExtTextOutW(hdc, x, y, uOptions|ETO_GLYPH_INDEX, prc,
                           pStr, cbCount, piDX);
    }


    // ETO_PDY is not relevant for complex script strings. Let GDI
    // handle it. (APps wanting to adjust the y coordinate of glyphs in
    // complex script strings should use Uniscribe and manipulate the
    // pGoffset parameter to ScriptTextOut.

    if (uOptions & ETO_PDY) {
        return ExtTextOutW(hdc, x, y, uOptions | ETO_IGNORELANGUAGE, prc,
                       pStr, cbCount, piDX);
    }

    // Establish Bidi reading order.
    //
    // Note, it is possible for us to be passed an hdc that does not
    // support GetTextAlign, in which case GetTextAlign will return -1.
    // Treat this as left to right reading order.

    fRTLreading =     ((uOptions & ETO_RTLREADING)
                  ||  (((iTextAlign = GetTextAlign(hdc)) & TA_RTLREADING) && (iTextAlign != -1)))
                  ?   TRUE : FALSE;


    //  Interpret ETO_NUMERICS* flags:
    //  If both bits are set, the digit substitute = context. This is a win95
    //  compatability issue and is used mainly by Access.

    if ((uOptions&(ETO_NUMERICSLOCAL|ETO_NUMERICSLATIN)) == (ETO_NUMERICSLOCAL|ETO_NUMERICSLATIN)) {
        iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_CONTEXT;
    } else if (uOptions & ETO_NUMERICSLOCAL) {
        iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_TRADITIONAL;
    } else if (uOptions & ETO_NUMERICSLATIN) {
        iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_NONE;
    } else {
        iDigitSubstitute = -1;
    }

    uOptions = uOptions & ~(ETO_NUMERICSLOCAL | ETO_NUMERICSLATIN);


    // Check for plain text that can bypass the LPK entirely

    dwSicFlags = SIC_COMPLEX;

    if (    iDigitSubstitute == SCRIPT_DIGITSUBSTITUTE_CONTEXT
        ||  iDigitSubstitute == SCRIPT_DIGITSUBSTITUTE_TRADITIONAL
        ||  g_DigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE) {
        dwSicFlags |= SIC_ASCIIDIGIT;
    }

    if (fRTLreading != !!(GetLayout(hdc) & LAYOUT_RTL)) {
        dwSicFlags |= SIC_NEUTRAL;
    }

    if ((   ScriptIsComplex(pStr,cbCount,dwSicFlags) == S_FALSE
        && FontHasWesternScript(hdc)) 
        || GetTextCharacterExtra(hdc) != 0)
    {
        // No complex script processing required

        return ExtTextOutW(hdc, x, y, uOptions | ETO_IGNORELANGUAGE, prc,
                       pStr, cbCount, piDX);
    }


    dwObjType = GetObjectType(hdc);

    // Analyse the string

    hr = LpkStringAnalyse(
            hdc, pStr, cbCount, 0, -1,
              SSA_GLYPHS
            | (dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_DONTGLYPH : 0)
            | (iCharset==-1 || GdiIsPlayMetafileDC(hdc) ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
            | (fRTLreading  ? SSA_RTL : 0),
            iDigitSubstitute, iRequiredWidth,
            NULL, NULL,
            piDX,
            NULL, NULL,
            &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("InternalTextOut - LpkStringAnalyse"));
        return FALSE;
    }


    // Return string width if required (for DrawText)

    if (piWidth) {
        *piWidth = psa->size.cx;
    }


    hr = ScriptStringOut(psa, x, y, uOptions, prc, 0, 0, FALSE);

    ScriptStringFree((void**)&psa);

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        ASSERTHR(hr, ("InternalTextOut - ScriptStringOut"));
        return FALSE;
    }
}






BOOL LpkExtTextOut(
    HDC         hdc,
    int         x,
    int         y,
    UINT        uOptions,
    CONST RECT *prc,
    PCWSTR      pStr,
    UINT        cbCount,
    CONST INT  *pDx,
    int         iCharset) {

    return InternalTextOut(hdc, x, y, uOptions, prc, pStr, cbCount, pDx, iCharset, NULL, -1);
}


//////////////////////////////////////////////////////////////////////////////
// GDI32 GetTextExtentExPoint will call this function for supporting        //
// Multilingual Text handling.                                              //
//                                                                          //
// LpkGetTextExtentExPoint( HDC hdc, PWSTR pStr, int cchString,             //
//     int nMaxExtent, PINT pnFit, PINT pDx, PSIZE pSize, int iCharset)     //
//                                                                          //
// hDC          Identifies the device context                               //
// pStr         Points to string for which extents are to be retrieved.     //
// cchString    Count of characters in input string                         //
// nMaxExtent   Specifies the maximum allowable width, in logical units,    //
//              of the formatted string.                                    //
// pnFit        Maximum characters that fit in the formatted string         //
//              When the pnFit parameter is NULL, the nMaxExtent parameter  //
//              is ignored.                                                 //
//                                                                          //
// pDx          address of array for partial string widths                  //
// pSize        Address for string dimension                                //
// fl           ????                                                        //
// iCharset      Indicates character set of codes. to optimizing the work. ??//
//                                                                          //
// Return                                                                   //
//      If the function succeeds, the return value is TRUE.                 //
//      If the function fails, the return value is FALSE.                   //
//      And we seted the error by call SetLastError.                        //
//      To get extended error information, call GetLastError.               //
//                                                                          //
// History                                                                  //
//   Oct 22, 1996 -by- Samer Arafeh [samera]                                //
//   Oct 25, 1996 -by- MOhammed Abdul Hammed [mhamid]                       //
//////////////////////////////////////////////////////////////////////////////

BOOL LpkGetTextExtentExPoint(
    HDC    hdc,
    PCWSTR pStr,
    int    cchString,
    int    nMaxExtent,
    PINT   pnFit,
    PINT   pDx,
    PSIZE  pSize,
    FLONG  fl,
    int    iCharset)
{
    int         iTextAlign;
    BOOL        fRTLreading;
    int         i;
    HRESULT     hr;
    DWORD       dwObjType;
    DWORD       dwSicFlags;   // Flags for ScriptIsComplex
    int         iCurrentCharSet;
    STRING_ANALYSIS  *psa;
    STRING_ANALYSIS  *psaFit;
    UNREFERENCED_PARAMETER(fl) ;


    // Check required parameters

    if (!hdc  ||  !pSize) {

        ASSERTS(hdc,   ("LpkGetTextExtentPoint - required parameter hdc is NULL"));
        ASSERTS(pSize, ("LpkGetTextExtentPoint - required parameter pSize is NULL"));
        return FALSE;
    }


    //Do we have a string
    if (!cchString || !pStr) {
        //no then go away
        pSize->cx = 0;
        pSize->cy = 0;
        if (pnFit) {
            *pnFit = 0;
        }
        return TRUE;
    }


    iTextAlign = GetTextAlign(hdc);
    fRTLreading = (iTextAlign & TA_RTLREADING) && (iTextAlign != -1);


    // Check for plain text that can bypass the LPK entirely

    dwSicFlags = SIC_COMPLEX;

    if (g_DigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE) {
        dwSicFlags |= SIC_ASCIIDIGIT;
    }

    if (fRTLreading != !!(GetLayout(hdc) & LAYOUT_RTL)) {
        dwSicFlags |= SIC_NEUTRAL;
    }

    if ((   ScriptIsComplex(pStr, cchString, dwSicFlags) == S_FALSE
        && FontHasWesternScript(hdc))
        || GetTextCharacterExtra(hdc) != 0)
    {
        // No complex script processing required

        return GetTextExtentExPointWPri(hdc, pStr, cchString, nMaxExtent, pnFit, pDx, pSize);
    }


    dwObjType = GetObjectType(hdc);

    // Analyse the string

    hr = LpkStringAnalyse(
            hdc, pStr, cchString, 0, -1,
              SSA_GLYPHS
            // if the DC is Meta-File DC, we should enable the FallBack because it is enabled for ETOA while playing any Meta-File.
            | (iCharset==-1 || dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
            | (fRTLreading  ? SSA_RTL  : 0)
            | (pnFit        ? SSA_FULLMEASURE : 0),
            -1, nMaxExtent,
            NULL, NULL, NULL, NULL, NULL,
            &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("LpkGetTextExtentExPoint - LpkStringAnalyse"));
        return FALSE;
    }


    if (pDx) {

        // if we have pnFit and psa->cOutChars>=cchString so we should fill lpDx.
        if (!pnFit || psa->cOutChars>=cchString) {
            ScriptStringGetLogicalWidths(psa, pDx);
        }

        // we need to update the width of last fit glyph.
        if (pnFit && psa->cOutChars<cchString && psa->cOutChars>0) {
            hr = LpkStringAnalyse(
                    hdc, pStr, psa->cOutChars, 0, -1,
                      SSA_GLYPHS
                    // if the DC is Meta-File DC, we should enable the FallBack because it is enabled for ETOA while playing any Meta-File.
                    | (iCharset==-1 || dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
                    | (fRTLreading  ? SSA_RTL  : 0),
                    -1, 0,
                    NULL, NULL, NULL, NULL, NULL,
                    &psaFit);

            if (FAILED(hr)) {
                ScriptStringFree((void**)&psa);
                ASSERTHR(hr, ("LpkGetTextExtentExPoint - LpkStringAnalyse"));
                return FALSE;
            }
            ScriptStringGetLogicalWidths(psaFit, pDx);
            ScriptStringFree((void**)&psaFit);
        }

        // Accumulate extents
        for (i=1; i<(pnFit==NULL?cchString:psa->cOutChars); i++) {
            pDx[i] += pDx[i-1];
        }
    }

    if (pnFit) {
        *pnFit = psa->cOutChars;
    }

    *pSize = psa->size;

    ScriptStringFree((void**)&psa);

    return TRUE;
}







////    GetCharacterPlacement support
//
//




////    GCPgenerateOutString
//
//      Creates a reordered copy of the input string


void GCPgenerateOutString(
    STRING_ANALYSIS  *psa,
    WCHAR            *pwOutString) {

    int     i,j;
    int     iItem;
    int     iStart;
    int     iLen;
    WCHAR  *pwch;


    // Copy items one by one in visual order

    for (i=0; i<psa->cItems; i++) {

        iItem  = psa->piVisToLog[i];
        iStart = psa->pItems[iItem].iCharPos;
        iLen   = psa->pItems[iItem+1].iCharPos - iStart;

        if (psa->pItems[iItem].a.fRTL) {

            // Right to left item

            pwch = psa->pwInChars + iStart + iLen - 1;
            for (j=0; j<iLen; j++) {
                *pwOutString++ = *pwch--;
            }

        } else {

            // Left to right item

            memcpy(pwOutString, psa->pwInChars+iStart, sizeof(WCHAR) * iLen);
            pwOutString += iLen;
        }
    }
}







////    GCPgenerateClass
//
//      Creates an array of character classifications using
//      GetCharacterPlacement legacy definitons


void GCPgenerateClass(
    STRING_ANALYSIS  *psa,
    BYTE             *pbClass) {

    int  iItem;
    int  iStart;
    int  iLen;
    int  iClass;
    int  iChar;


    // Map LogClust entries item by item in logical order

    for (iItem=0; iItem<psa->cItems; iItem++) {

        iStart     = psa->pItems[iItem].iCharPos;
        iLen       = psa->pItems[iItem+1].iCharPos - iStart;

        if (g_ppScriptProperties[psa->pItems[iItem].a.eScript]->fNumeric) {

            if (psa->pItems[iItem].a.fLayoutRTL) {
                iClass = GCPCLASS_LOCALNUMBER;
            } else {
                iClass = GCPCLASS_LATINNUMBER;
            }

        } else {

            if (psa->pItems[iItem].a.fLayoutRTL) {
                iClass = GCPCLASS_ARABIC;  // (Same constant as GCPCLASS_HEBREW)
            } else {
                iClass = GCPCLASS_LATIN;
            }
        }

        memset(pbClass, iClass, iLen);
        pbClass += iLen;
    }
}


/******************************Public*Routine******************************\
* GCPJustification
*
* Justifies text according to piJustify and returns proper pwgi and piDx
* arrays.
*
* IMPORTANT : Caller should free (USPFREE(*ppwgi)) allocated buffer if
* the fn succeeds (SUCCEEDED(hr)) and return code isn't S_FALSE.
* S_FALSE means no justification is to be applied here since the piJustify and
* piDx are either identical or the total width to justify for is less than the
* min kashida width.
*
* All param are DWORD aligned.
*
* History :
*
*   Mar 23, 1998 -by-      Samer Arafeh [samera]
* wrote it
\**************************************************************************/
#define BlankPriority   10
HRESULT GCPJustification( WORD **ppwgi,                   // Out Output buffer width justified glyphs
                        int **ppiJustifyDx,               // Out Newly generated piDx buffer
                        WORD *pwgi,                       // In  Incoming GIs
                        const int *piAdvWidth,            // In  Advance wdiths
                        const SCRIPT_VISATTR *pVisAttr,   // In  Visual attributes
                        int *piJustify,                   // In  Justification advanced widths
                        int cGlyphs,                      // In  number of glyphs
                        int iKashidaWidth,                // In  Minimum width of kashida
                        int *pcJustifiedGlyphs,           // Out Receives the total # of glyphs in output buf
                        DWORD dwgKashida,                 // In Kashida GI
                        DWORD dwgSpace)                   // In Space GI
{
  DWORD dwSize;
  int iInsert=0L, iGlyph, iAmount, iJustDx;
  int cNewGlyphs = cGlyphs;
  WORD *pwNewGlyph;
  int *piNewAdvWidth;
  int   cMaxGlyphs = *pcJustifiedGlyphs;
  int cNonArabicGlyph;
  int cNonBlank;
  int iDelta;
  HRESULT hr;
  INT iPartialKashida;

  //
  // Point to caller's data initially
  //
  *ppwgi = pwgi;
  *ppiJustifyDx = (INT *)piJustify;
  *pcJustifiedGlyphs = cGlyphs;

  //
  // If Kashida width is less than or equal 0, then justify with spaces only.
  //
  if(iKashidaWidth <= 0L) {
    iKashidaWidth = -1;
  }

  //
  // 1- Analyze input buffer to see how many kashida to insert, If Kashida is used.
  //
  if (iKashidaWidth != -1 ) {
     cNonArabicGlyph = 0;
     cNonBlank       = 0;
     iDelta = 0;

     for( iGlyph=cGlyphs-1 ; iGlyph >= 0L ; iGlyph-- )
     {
        if( (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_NONE) ||
            (pVisAttr[iGlyph].uJustification >= SCRIPT_JUSTIFY_ARABIC_NORMAL)) {

            iAmount = piJustify[iGlyph]-piAdvWidth[iGlyph];
            if (iAmount > 0 && cNewGlyphs < cMaxGlyphs){
               iPartialKashida = iAmount % iKashidaWidth;
               iAmount /= iKashidaWidth;
               if (iPartialKashida > 0 && iAmount>0)
               {
                iAmount++;
               }
               if (cNewGlyphs + iAmount > cMaxGlyphs) {
                  iAmount = (cMaxGlyphs - cNewGlyphs) * iKashidaWidth;
                  cNewGlyphs = cMaxGlyphs;
                  iDelta += piJustify[iGlyph] - piAdvWidth[iGlyph] - iAmount;
                  piJustify[iGlyph] = piAdvWidth[iGlyph] + iAmount;
               } else {
                  cNewGlyphs += iAmount;
               }
            } else {
               iDelta += iAmount;
               piJustify[iGlyph] = piAdvWidth[iGlyph];
            }
        } else {

            if( (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_ARABIC_BLANK) ||
                (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_BLANK)) {
                cNonBlank++;
            } else {
                cNonArabicGlyph++;
            }
        }
     }

     if (iDelta > 0 && cNonArabicGlyph+cNonBlank>0) {
        // The Space has 10-times higher priority than Latin characters.
        iAmount = iDelta / (cNonArabicGlyph + (cNonBlank * BlankPriority));

        for( iGlyph=0  ; iGlyph < cGlyphs ; iGlyph++ )
        {
           if( (pVisAttr[iGlyph].uJustification != SCRIPT_JUSTIFY_NONE) &&
               (pVisAttr[iGlyph].uJustification < SCRIPT_JUSTIFY_ARABIC_NORMAL)) {


               if( (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_ARABIC_BLANK) ||
                   (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_BLANK)) {

                   piJustify[iGlyph] += BlankPriority * iAmount;
                   iDelta -= BlankPriority * iAmount;
               } else {
                   piJustify[iGlyph] += iAmount;
                   iDelta -= iAmount;
               }
               cNonArabicGlyph = iGlyph;
           }

        }
        if (iDelta > 0) {
          piJustify[cNonArabicGlyph] += iDelta;
        }
     }
  }

  //
  // 2- Allocate for new glyphs and piDx
  //

  dwSize = (cNewGlyphs * (sizeof(INT)+sizeof(WORD)));
  hr = USPALLOCTEMP( dwSize , (void **)&pwNewGlyph );
  if(FAILED(hr))
  {
    ASSERTHR(hr, ("Not ennough memory for JustifiyArabicStringWithKashida()"));
    return hr;
  }
  piNewAdvWidth = (INT *)(pwNewGlyph+cNewGlyphs);


  //
  // 3- Begin inserting and formulating the justified buffer
  //
  int iJustReminder = 0;

  for( iGlyph=cGlyphs-1, iInsert=cNewGlyphs-1; iGlyph >= 0L && iInsert>=0; iGlyph-- )
  {
    iJustDx = (piJustify[iGlyph] - piAdvWidth[iGlyph]) + iJustReminder;

    iJustReminder = 0;

    if( iJustDx > 0)
    {
      if( (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_NONE) ||
          (pVisAttr[iGlyph].uJustification >= SCRIPT_JUSTIFY_ARABIC_NORMAL))
      {
        //Arabic glyph then justify with kashida
        if(( iJustDx >= iKashidaWidth ) && (iKashidaWidth != -1))
        {

          pwNewGlyph[iInsert] = pwgi[iGlyph];
          piNewAdvWidth[iInsert] = piAdvWidth[iGlyph];
          iInsert--;

          while( (iJustDx >= iKashidaWidth) && (iInsert >= 0L) )
          {
            pwNewGlyph[iInsert] = (WORD)dwgKashida;
            piNewAdvWidth[iInsert] = iKashidaWidth;
            iInsert--;

            iJustDx -= iKashidaWidth;
          }

          if(( iJustDx > 0L ) && (iInsert >= 0L))
          {
            pwNewGlyph[iInsert] = (WORD)dwgKashida;
            piNewAdvWidth[iInsert] = iJustDx;
            iInsert--;
            iJustDx = 0L;
          }
        }
        else
        {
          pwNewGlyph[iInsert] = pwgi[iGlyph];
          piNewAdvWidth[iInsert] = piAdvWidth[iGlyph];
          iJustReminder = iJustDx;
          iInsert--;
        }
      }
      else
      {
        pwNewGlyph[iInsert] = pwgi[iGlyph];
        piNewAdvWidth[iInsert] = piAdvWidth[iGlyph] + iJustDx;
        iInsert--;
      }
    }
    else
    {
      pwNewGlyph[iInsert] = pwgi[iGlyph];
      piNewAdvWidth[iInsert] = piJustify[iGlyph];
      iInsert--;
    }
  }

  //
  // In case there is a space glyph, it will be expanded in locatio rather
  // than inserting kashida GIs
  //
  while( iInsert >= 0L )
  {
    piNewAdvWidth[iInsert] = 0L;
    pwNewGlyph[iInsert] = (WORD)dwgSpace;
    iInsert--;
  }

  //
  // 4- Update results
  //
  *ppwgi = pwNewGlyph;
  *ppiJustifyDx = piNewAdvWidth;
  *pcJustifiedGlyphs = cNewGlyphs;

  return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// GDI32 GetCharacterPlacement will call this function for                  //
// supporting Multilingual Text handling.                                   //
//                                                                          //
// LpkGetCharacterPlacement( HDC hdc, PWSTR pStr, int nCount,               //
//        int nMaxExtent, LPGCP_RESULTSW pResults, DWORD dwFlags,           //
//                                                  int iCharset)           //
//                                                                          //
// hDC        : Handle to device context                                    //
// pStr       : Input string                                                //
// nCount     : Count of characters in input string                         //
// nMaxExtent : Maximum width for formatting string                         //
// pResults   : Pointer to GCP_RESULTS strucutre for output                 //
// dwFlags    : GCP Processing Flags                                        //
// iCharset   : Origianl character set of pStr                              //
//                                                                          //
// Return                                                                   //
//  If the function succeeds, the return value is Width an the Height       //
//      of the string                                                       //
//  If the function fails, the return value is 0.                           //
//      And we seted the error by call SetLastError.                        //
//      To get extended error information, call GetLastError.               //
//                                                                          //
// History :                                                                //
//   Oct 22, 1996 -by- Samer Arafeh [samera]                                //
//   Oct 29, 1996 -by- MOhammed Abdul Hammed [mhamid]                       //
//   Jan 13, 1997 -by- David C Brown (dbrown)                               //
//                        New justification widths buffer                   //
//                        ANALYSE field name changes                        //
//////////////////////////////////////////////////////////////////////////////

DWORD LpkGetCharacterPlacement(
    HDC              hdc,
    const WCHAR     *pwcInChars,
    int              cInChars,
    int              nMaxExtent,
    GCP_RESULTSW    *pResults,
    DWORD            dwFlags,
    int              iCharset) {

    UINT                   uBufferOptions;
    int                    iDigitSubstitute, i, cMaxGlyphs;
    int                    *pLocalDX;
    DWORD                  dwRet = 0;
    HRESULT                hr;
    DWORD                  dwSSAflags;
    SCRIPT_CONTROL         scriptControl = {0}; // Analysis control
    SCRIPT_STATE           scriptState   = {0}; // Initial state
    STRING_ANALYSIS        *psa;
    SCRIPT_FONTPROPERTIES  sfp;
    WORD                   *pwLocalGlyphs;



    TRACE(GDI, ("LpkGetCharacterPlacement begins"));


    //////////////////////////////////////////////////////////////////////////
    //                          1-Check parameters                          //
    //////////////////////////////////////////////////////////////////////////

    // Check required parameters
    ASSERTS(hdc,   ("LpkGetCharacterPlacement - required parameter hdc is NULL"));

    //GCP_MAXEXTENT and no nMaxExtent
    if ((dwFlags & GCP_MAXEXTENT) && (nMaxExtent < 0)) {
        TRACEMSG(("LpkGetCharacterPlacement: Invalid parameter - GCP_MAXEXTENT and no nMaxExtent"));
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    //GCP_CLASSIN set and no pClass
    if ((dwFlags & GCP_CLASSIN) && !(pResults->lpClass)) {
        TRACEMSG(("LpkGetCharacterPlacement: Invalid parameter - GCP_CLASSIN set and no pClass"));
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }


    //////////////////////////////////////////////////////////////////////////
    //                    2 - Interpret control flags                       //
    //////////////////////////////////////////////////////////////////////////


    switch (dwFlags & (GCP_NUMERICSLOCAL|GCP_NUMERICSLATIN)) {

        case GCP_NUMERICSLOCAL:
            iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_TRADITIONAL;
            break;

        case GCP_NUMERICSLOCAL|GCP_NUMERICSLATIN:
            iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_CONTEXT;
            break;

        case GCP_NUMERICSLATIN:
            iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_NONE;
            break;

        default:
            iDigitSubstitute = -1;
    }


    dwSSAflags = 0;

    if (dwFlags & GCP_REORDER) {
        if (GetTextAlign(hdc) & TA_RTLREADING ? 1 : 0) {
            dwSSAflags |= SSA_RTL;
        }
    } else {
        scriptState.fOverrideDirection = TRUE;
    }

    if (dwFlags & GCP_DISPLAYZWG)       scriptState.fDisplayZWG        = TRUE;
    if (!(dwFlags & GCP_LIGATE))        scriptState.fInhibitLigate     = TRUE;
    if (dwFlags & GCP_SYMSWAPOFF)       scriptState.fInhibitSymSwap    = TRUE;
    if (dwFlags & GCP_NEUTRALOVERRIDE)  scriptControl.fNeutralOverride = TRUE;
    if (dwFlags & GCP_NUMERICOVERRIDE)  scriptControl.fNumericOverride = TRUE;

    if (pResults->lpGlyphs) {
        scriptControl.fLinkStringBefore = pResults->lpGlyphs[0] & GCPGLYPH_LINKBEFORE  ? TRUE : FALSE;
        scriptControl.fLinkStringAfter  = pResults->lpGlyphs[0] & GCPGLYPH_LINKAFTER   ? TRUE : FALSE;
    }

    if (dwFlags & GCP_MAXEXTENT) {
        dwSSAflags |= SSA_CLIP;
        if (dwFlags & GCP_JUSTIFY) {
            dwSSAflags |= SSA_FIT;
            if (!(dwFlags & GCP_KASHIDA) || !(dwFlags & (GCP_GLYPHSHAPE | GCP_LIGATE))) {
                dwSSAflags |= SSA_NOKASHIDA;
            }
        }
    }

    if (dwFlags & GCP_CLASSIN) {
        if (((const BYTE *)pResults->lpClass)[0] & (GCPCLASS_PREBOUNDLTR | GCPCLASS_PREBOUNDRTL)) {
            scriptControl.fInvertPreBoundDir =    (((const BYTE *)pResults->lpClass)[0] & GCPCLASS_PREBOUNDRTL ? 1 : 0)
                                               ^  (dwSSAflags & SSA_RTL ? 1 : 0);
        }

        if (((const BYTE *)pResults->lpClass)[0] & (GCPCLASS_POSTBOUNDLTR | GCPCLASS_POSTBOUNDRTL)) {
            scriptControl.fInvertPostBoundDir =    (((const BYTE *)pResults->lpClass)[0] & GCPCLASS_POSTBOUNDRTL ? 1 : 0)
                                                ^  (dwSSAflags & SSA_RTL ? 1 : 0);
        }
    }


    //////////////////////////////////////////////////////////////////////////
    //               3-Call LPK_ANA to do Layout and Shaping                //
    //////////////////////////////////////////////////////////////////////////

    if (dwFlags & GCP_CLASSIN) {
        hr = LpkStringAnalyse(
                hdc, pwcInChars, cInChars, pResults->nGlyphs, -1,
                dwSSAflags | SSA_GLYPHS | SSA_GCP,
                iDigitSubstitute, nMaxExtent,
                &scriptControl, &scriptState,
                NULL,
                NULL,
                (BYTE*)pResults->lpClass,
                &psa);
    } else {
        hr = LpkStringAnalyse(
                hdc, pwcInChars, cInChars, pResults->nGlyphs, -1,
                dwSSAflags | SSA_GLYPHS | SSA_GCP,
                iDigitSubstitute, nMaxExtent,
                &scriptControl, &scriptState,
                NULL,
                NULL,
                NULL,
                &psa);
    }
    if (FAILED(hr)) {
        ASSERTHR(hr, ("LpkGetTextExtentExPoint - LpkStringAnalyse"));
        return FALSE;
    }

    //
    // If the user's suppled buffer isn't sufficient to hold the
    // output, then let's truncate it.
    //
    if (pResults->nGlyphs < (UINT) psa->cOutGlyphs) {
        psa->cOutGlyphs = (UINT) pResults->nGlyphs;
    }

    if (pResults->lpOutString) {
        GCPgenerateOutString(psa, pResults->lpOutString);
    }


    if (pResults->lpOrder) {
        ScriptStringGetOrder(psa, pResults->lpOrder);
    }


    if (pResults->lpClass) {
        GCPgenerateClass(psa, (PBYTE) pResults->lpClass);
    }

    BOOL bGlyphsCopied = FALSE;

    if (pResults->lpDx) {
        if (psa->piJustify  && (dwFlags & GCP_JUSTIFY)) {
            sfp.cBytes = sizeof(SCRIPT_FONTPROPERTIES);
            hr = ScriptGetFontProperties(hdc,
                                         &psa->sc[0],
                                         &sfp);
            if(SUCCEEDED(hr)) {
                if (!(dwFlags & GCP_KASHIDA) || !(dwFlags & (GCP_GLYPHSHAPE | GCP_LIGATE)))
                    sfp.iKashidaWidth = -1;
                else {
                    ASSERTS(sfp.wgKashida,   ("LpkGetCharacterPlacement - ther is no Kashida glyph"));
                }

                cMaxGlyphs = pResults->nGlyphs;

                hr = GCPJustification( (WORD **)&pwLocalGlyphs,
                                       (int **)&pLocalDX,
                                       (WORD *)psa->pwGlyphs,
                                       (int *)psa->piAdvance,
                                       psa->pVisAttr,
                                       psa->piJustify,
                                       psa->cOutGlyphs,
                                       sfp.iKashidaWidth,
                                       &cMaxGlyphs,
                                       sfp.wgKashida,
                                       sfp.wgBlank);
                if(SUCCEEDED(hr)) {
                    int iOffset = 0;
                    if (cMaxGlyphs > (int)pResults->nGlyphs) {
                        iOffset = cMaxGlyphs - pResults->nGlyphs;
                        cMaxGlyphs = pResults->nGlyphs;
                    }

                    psa->cOutGlyphs = cMaxGlyphs;

                    if (pResults->lpGlyphs) {
                        memcpy (pResults->lpGlyphs, (LPVOID)(pwLocalGlyphs+iOffset), sizeof(WORD) * cMaxGlyphs);
                        bGlyphsCopied = TRUE;
                    }

                    psa->size.cx = 0;
                    for (i=0; i<cMaxGlyphs; i++) {
                        pResults->lpDx[i] = pLocalDX[i+iOffset];
                        psa->size.cx += pLocalDX[i+iOffset];
                    }
                    USPFREE((LPVOID)pwLocalGlyphs);
                }
            }

        } else {
            memcpy(pResults->lpDx,  psa->piAdvance,  sizeof(int) * psa->cOutGlyphs);
        }
    }

    if (!bGlyphsCopied && pResults->lpGlyphs) {
        memcpy(pResults->lpGlyphs,  psa->pwGlyphs,  sizeof(WORD) * psa->cOutGlyphs);
    }


    if (dwFlags & (GCP_GLYPHSHAPE | GCP_LIGATE))
        pResults->nGlyphs = psa->cOutGlyphs;
    else
        pResults->nGlyphs = cInChars;

    pResults->nMaxFit = psa->cOutChars;


    // If there was justification we may have zero glyphs

    if (!psa->cOutGlyphs) {

        pResults->nGlyphs = 0;

        ScriptStringFree((void**)&psa);


        // Weird Middle East Win95 compatability rules

        if (    (dwFlags & GCP_MAXEXTENT)
            || !(dwFlags & GCP_GLYPHSHAPE)
            || !pResults->lpGlyphs) {

            return 1;

        } else {

            return 0;
        }
    }


    //////////////////////////////////////////////////////////////////////////
    //                      4-Generate lpCaretPos                           //
    //////////////////////////////////////////////////////////////////////////

    if (pResults->lpCaretPos) {
        char   *pbClass   = NULL;
        INT    *piAdvance = pResults->lpDx  ? pResults->lpDx : psa->piAdvance;
        UINT   *puiOrder  = NULL;
        INT    *pCaretCalc;
        INT     iWidth    = 0;
        UINT    j, uOrder;

        hr = USPALLOC(sizeof(INT)*pResults->nGlyphs, (void **)&pCaretCalc);

        if(FAILED(hr)) {
            ScriptStringFree((void**)&psa);
            return 0;
        }

        // Allocate for pbClass if pResults->lpClass is NULL otherwise us it.
        if (pResults->lpClass == NULL) {
            hr = USPALLOC(sizeof(char)*cInChars, (void **)&pbClass);
            if(FAILED(hr)) {
                USPFREE(pCaretCalc);
                ScriptStringFree((void**)&psa);
                return 0;
            }
            GCPgenerateClass(psa, (PBYTE) pbClass);
        } else {
            pbClass = pResults->lpClass;
        }

        // Allocate for puiOrder if pResults->lpOrder is NULL otherwise us it.
        if (pResults->lpOrder == NULL) {
            hr = USPALLOC(sizeof(UINT)*cInChars, (void **)&puiOrder);
            if(FAILED(hr)) {
                if (pResults->lpClass == NULL) {
                    USPFREE(pbClass);
                }
                USPFREE(pCaretCalc);
                ScriptStringFree((void**)&psa);
                return 0;
            }
            ScriptStringGetOrder(psa, puiOrder);
        } else {
            puiOrder = pResults->lpOrder;
        }

        // simple-minded loop used to generate glyph-offsets
        // as the same code used in NT4/MET.

        UINT caretPosCount = min(pResults->nGlyphs, (UINT)cInChars);

        for( j=0 ; j<caretPosCount ; j++ ) {
            if (pbClass[j] == GCPCLASS_ARABIC) {
                iWidth += piAdvance[j];
                pCaretCalc[j] = iWidth - 1;
                if (iWidth == 0) {
                    pCaretCalc[j] = 0;
                }
            } else {
                pCaretCalc[j] = iWidth;
                iWidth += piAdvance[j];
            }
        }

        if (pResults->nGlyphs > (UINT)cInChars)
        {
            for( j=cInChars ; j<pResults->nGlyphs ; j++) 
            {
                pCaretCalc[j] = iWidth;
                iWidth += piAdvance[j];
            }
        }

        // Convert to char-indexing. We need to take care if the
        // user supplied in sufficient visual buffers
        for( j=0 ; j<(UINT)cInChars ; j++ ) {
            uOrder = puiOrder[j];
            if ((uOrder+1) > (UINT)psa->cOutGlyphs) {
                uOrder = 0;
            }
            pResults->lpCaretPos[j] = pCaretCalc[uOrder];
        }

        if (pResults->lpOrder == NULL) {
            USPFREE(puiOrder);
        }
        if (pResults->lpClass == NULL) {
            USPFREE(pbClass);
        }
        USPFREE(pCaretCalc);
    }


    //////////////////////////////////////////////////////////////////////////
    //                      5 - Return width and height                     //
    //////////////////////////////////////////////////////////////////////////


    dwRet = (psa->size.cx & 0xffff) + (psa->size.cy << 16);


    //////////////////////////////////////////////////////////////////////////
    //                      6 - Free allocated memory and exit              //
    //////////////////////////////////////////////////////////////////////////


    ScriptStringFree((void**)&psa);

    return dwRet;
}


/******************************Public*Routine******************************\
*
* BOOL LpkUseGDIWidthCache( HDC hDC , LPCSTR psz , int count ,
*                           LONG fl , BOOL fUnicode)
*
* Checks whether the LPK can use GDI cached widths for the ASCII (0<=x<=127)
* by inspecting the following variables :
* - System numeric shape setting
* - DC Align state
* - The selected font has Western script
* - The string code points in range 0<=x<=127 with Ansi calls
*
* Returns TRUE if it is OK to use GDI width cache, otherwise FALSE
*
* History:
*  28-Aug-1997 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/
BOOL LpkUseGDIWidthCache( HDC hDC , LPCSTR psz , int count , LONG fl , BOOL fUnicode)
{
    BOOL bRet;
    int   i;
    BYTE  cTest;
    LPSTR pstr;

    //
    // Let's make sure that :
    // 1- Text is LTR Reading
    // 2- Digits shape setting is Arabic
    // 3- if Unicode call, make sure the font has Western script
    //    if Ansi call check if all code points less than 0x80 and font has Wetern script.

    bRet =      (!!(fl & TA_RTLREADING) == !!(GetLayout(hDC) & LAYOUT_RTL))
            &&  g_DigitSubstitute.DigitSubstitute == SCRIPT_DIGITSUBSTITUTE_NONE;

    TRACE( GDI, ("LpkUseGDIWidthCache: g_DigitSubstitute.DigitSubstitute=%x, bRet=%x",
                 g_DigitSubstitute.DigitSubstitute, bRet));


    if (bRet) {

       // We don't need this check for Unicdoe calls because it is done in GDI.
       if (!fUnicode) {
          cTest = 0;
          i = count;
          pstr = (LPSTR) psz;

          unroll_here:
          switch(i)
          {
              default:
                  cTest |= pstr[9];
              case 9:
                  cTest |= pstr[8];
              case 8:
                  cTest |= pstr[7];
              case 7:
                  cTest |= pstr[6];
              case 6:
                  cTest |= pstr[5];
              case 5:
                  cTest |= pstr[4];
              case 4:
                  cTest |= pstr[3];
              case 3:
                  cTest |= pstr[2];
              case 2:
                  cTest |= pstr[1];
              case 1:
                  cTest |= pstr[0];
          }

          if ((i > 10) && !(cTest & 0x80))
          {
              i -= 10;
              pstr += 10;
              goto unroll_here;
          }

          bRet = !(cTest & 0x80);
       }

       return (bRet && FontHasWesternScript(hDC));
    }

    return bRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_edit.c ===
////    LPK_EDIT - Edit control support - C interface
//
//      Handles all callouts from the standard US edit control.
//
//      David C Brown (dbrown) 17th Nov 1996.
//
//      Copyright (c) 1996-1997 Microsoft Corporation. All right reserved.




/*
 * Core NT headers
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#define NONTOSPINTERLOCK
#include <ntosp.h>

/*
 * Standard C runtime headers
 */
#include <limits.h>
#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

/*
 * NtUser Client specific headers
 */
#include "usercli.h"
#include <winnlsp.h>
#include <ntsdexts.h>
#include <windowsx.h>
#include <newres.h>
#include <asdf.h>

/*
 * Complex script language pack
 */
#include "lpk.h"
#include "lpk_glob.h"


// Don't link directly to NtUserCreateCaret
#undef CreateCaret

///     Unicode control characters
//

#define U_TAB   0x0009
#define U_FS    0x001C
#define U_GS    0x001D
#define U_RS    0x001E
#define U_US    0x001F
#define U_ZWNJ  0x200C
#define U_ZWJ   0x200D
#define U_LRM   0x200E
#define U_RLM   0x200F
#define U_LRE   0x202A
#define U_RLE   0x202B
#define U_PDF   0x202C
#define U_LRO   0x202D
#define U_RLO   0x202E
#define U_ISS   0x206A
#define U_ASS   0x206B
#define U_IAFS  0x206C
#define U_AAFS  0x206D
#define U_NADS  0x206E
#define U_NODS  0x206F


#define TRACE(a,b)
#define ASSERTS(a,b)
#define ASSERTHR(a,b)






/***************************************************************************\
* BOOL ECIsDBCSLeadByte( PED ped, BYTE cch )
*
*   IsDBCSLeadByte for Edit Control use only.
*
* History: 18-Jun-1996 Hideyuki Nagase
\***************************************************************************/

BOOL ECIsDBCSLeadByte(PED ped, BYTE cch)
{
    int i;

    if (!ped->fDBCS || !ped->fAnsi)
        return (FALSE);

    for (i = 0; ped->DBCSVector[i]; i += 2) {
        if ((ped->DBCSVector[i] <= cch) && (ped->DBCSVector[i+1] >= cch))
            return (TRUE);
    }

    return (FALSE);
}


////    GetEditAnsiConversionCharset - Figure a proper charset to MBTWC ANSI edit control's data
//
//      In some Far East settings, they associate the symbol font to their ANSI codepage for
//      backward compatibility (this is not the case for Japanese though), otherwise we convert
//      using page 0. Currently Uniscribe glyph table maps SYMBOLIC_FONT to 3 pages - U+00xx,
//      U+F0xx and the system's ACP page.
//
//      For Unicode control returns -1


int GetEditAnsiConversionCharset(PED ped)
{
    int iCharset = ped->fAnsi ? ped->charSet : -1;

    if (iCharset == SYMBOL_CHARSET || iCharset == OEM_CHARSET)
    {
        iCharset = ANSI_CHARSET;    // assume page U+00xx

    }

    if (iCharset == ANSI_CHARSET && ped->fDBCS)
    {
        // In Chinese system, there is font association to map symbol to ACP
        // (QueryFontAssocStatus returns non-null). More detail please refer
        // to USER's ECGetDBCSVector(...)

        CHARSETINFO csi;

        if (TranslateCharsetInfo((DWORD*)UIntToPtr(g_ACP), &csi, TCI_SRCCODEPAGE))
            iCharset = csi.ciCharset;
    }

    return iCharset;
}




////    MBCPtoWCCP - Translate multi-byte caret position to wide char caret position
//
//      Translates from a multibyte caret position specified as a byte offset
//      into an 8 bit string, to a widechar caret position, returned as a
//      word offset into a 16 bit character string.
//
//      If the codepage isn't a DBCS, the imput offset is returned unchanged.
//
//      Returns E_FAIL if icpMbStr addresses the second byte of a double byte character


HRESULT MBCPtoWCCP(
    PED     ped,            // In  - Edit control structure
    BYTE   *pbMbStr,        // In  - Multi byte string
    int     icpMbStr,       // In  - Byte offset of caret in multibyte string
    int    *picpWcStr) {    // Out - Wide char caret position


    if (!ped->fDBCS  || !ped->fAnsi) {

        *picpWcStr = icpMbStr;
        return S_OK;
    }


    // Scan through DBCS string counting characters

    *picpWcStr = 0;
    while (icpMbStr > 0) {

        if (ECIsDBCSLeadByte(ped, *pbMbStr)) {

            // Character takes two bytes

            icpMbStr -= 2;
            pbMbStr  += 2;

        } else {

            // Character takes one byte

            icpMbStr--;
            pbMbStr++;
        }

        (*picpWcStr)++;
    }

    return icpMbStr == 0 ? S_OK : E_FAIL;
}





////    WCCPtoMBCP - Translate wide char caret position to multi-byte caret position
//
//      Translates from a widechar caret position specified as a word offset
//      into a 16 bit string, to a multibyte caret position, returned as a
//      byte offset into an 8 bit character string.


HRESULT WCCPtoMBCP(
    PED     ped,            // In  - Edit control structure
    BYTE   *pbMbStr,        // In  - Multi byte string
    int     icpWcStr,       // In  - Wide char caret position
    int    *picpMbStr) {    // Out - Byte offset of caret in multibyte string


    if (!ped->fDBCS  || !ped->fAnsi) {

        *picpMbStr = icpWcStr;
        return S_OK;
    }


    // Scan through DBCS string counting characters

    *picpMbStr = 0;
    while (icpWcStr > 0) {

        if (ECIsDBCSLeadByte(ped, *pbMbStr)) {

            // Character takes two bytes

            (*picpMbStr) += 2;
            pbMbStr      += 2;

        } else {

            // Character takes one byte

            (*picpMbStr)++;
            pbMbStr++;
        }

        icpWcStr--;
    }

    return S_OK;
}






////    LeftEdgeX
//
//      Returns the visual x offset (i.e. from the left edge of the window)
//      to the left edge of a line of width iWidth given the current
//      formatting state of the edit control, .format and .xOffset.



int LeftEdgeX(PED ped, INT iWidth) {

    INT iX;


    // First generate logical iX - offset forward from leading margin.

    iX = 0;

    switch (ped->format) {

        case ES_LEFT:           // leading margin alignment
            if (ped->fWrap) {
                iX = 0;
            } else {
                iX = -(INT)ped->xOffset;
            }
            break;

        case ES_CENTER:
            iX = (ped->rcFmt.right - ped->rcFmt.left - iWidth) / 2;
            break;

        case ES_RIGHT:          // far margin alignment
            iX = ped->rcFmt.right - ped->rcFmt.left - iWidth;
            break;
    }


    // iX is logical offset from leading margin to leading edge of string
    if (ped->format != ES_LEFT && iX < 0) {
        iX = !ped->fWrap ? -(INT)ped->xOffset : 0;
    }

    // Now adjust for right to left origin and incorporate left margin

    if (ped->fRtoLReading) {
        iX = ped->rcFmt.right - (iX+iWidth);
    } else {
        iX += ped->rcFmt.left;
    }

    TRACE(EDIT, ("LeftEdgeX iWidth=%d, format=%d, xOffset=%d, fWrap=%d, fRtoLReading=%d, right-left=%d, returning %d",
                 iWidth, ped->format, ped->xOffset, ped->fWrap, ped->fRtoLReading, ped->rcFmt.right - ped->rcFmt.left, iX));

    return iX;
}




/////   Shaping engins IDs.

#define BIDI_SHAPING_ENGINE_DLL     1<<0
#define THAI_SHAPING_ENGINE_DLL     1<<1
#define INDIAN_SHAPING_ENGINE_DLL   1<<4


///


////    EditCreate
//
//      Called from edecrare.c ECCreate.
//
//      Return TRUE if create succeeded


BOOL EditCreate(PED ped, HWND hWnd) {

    LONG_PTR dwExStyle, dwStyle;

    TRACE(EDIT, ("EditCreate called."));


    // Check if BIDI shaping engine is loaded then
    // allow the edit control to switch its direction.

    if (g_dwLoadedShapingDLLs & BIDI_SHAPING_ENGINE_DLL) {
        ped->fAllowRTL = TRUE;
    } else {
        ped->fAllowRTL = FALSE;
    }


    // Process WS_EX flags

    dwExStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE);

    if (dwExStyle & WS_EX_LAYOUTRTL) {
        dwExStyle = dwExStyle & ~WS_EX_LAYOUTRTL;
        dwExStyle = dwExStyle ^ (WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);
        SetWindowLongPtr(hWnd, GWL_EXSTYLE, dwExStyle);

        dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
        if (!(dwStyle & ES_CENTER)) {
            dwStyle = dwStyle ^ ES_RIGHT;
            SetWindowLongPtr(hWnd, GWL_STYLE, dwStyle);
        }
    }


    if (dwExStyle & WS_EX_RIGHT && ped->format == ES_LEFT) {
        ped->format = ES_RIGHT;
    }

    if (dwExStyle & WS_EX_RTLREADING) {
        ped->fRtoLReading = TRUE;
        switch (ped->format) {
            case ES_LEFT:   ped->format = ES_RIGHT;  break;
            case ES_RIGHT:  ped->format = ES_LEFT;   break;
        }
    }

    return TRUE;
}






////    EditStringAnalyse
//
//      Creates standard analysis parameters from the PED

HRESULT EditStringAnalyse(
    HDC             hdc,
    PED             ped,
    PSTR            pText,
    int             cch,
    DWORD           dwFlags,
    int             iMaxExtent,
    STRING_ANALYSIS **ppsa){


    HRESULT         hr;
    SCRIPT_TABDEF   std;
    int             iTabExtent;

    if (!ped->pTabStops)
    {
        std.cTabStops  = 1;
        std.iScale     = 4;
        std.pTabStops  = &iTabExtent;
        std.iTabOrigin = 0;
        iTabExtent     = ped->aveCharWidth * 8;
    }
    else
    {
        std.cTabStops  = *ped->pTabStops;
        std.iScale     = 4;                 // Tabstops are already in device units
        std.pTabStops  = ped->pTabStops + 1;
        std.iTabOrigin = 0;
    }


    hr = LpkStringAnalyse(
         hdc,
         ped->charPasswordChar ? (char*)&ped->charPasswordChar : pText,
         cch, 0,
         GetEditAnsiConversionCharset(ped),
         dwFlags | SSA_FALLBACK | SSA_TAB
         | (ped->fRtoLReading     ? SSA_RTL      : 0)
         | (ped->fDisplayCtrl     ? SSA_DZWG     : 0)
         | (ped->charPasswordChar ? SSA_PASSWORD : 0),
         -1, iMaxExtent,
         NULL, NULL,    // Control, State
         NULL,          // Overriding Dx array
         &std,          // Tab definition
         NULL,          // Input class overrides
         ppsa);

    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditStringAnalyse - LpkStringAnalyse"));
    }

    return hr;
}


////    HScroll
//
//      Checks wether the cursor is visible withing the rcFormat
//      area, and if not, updates xOffset so that it's 1/4 of the
//      way from the edge it was closest to.
//
//      However, it never leaves whitespace between the leading margin
//      and the leading edge of the string, nor will it leave whitespace
//      between the trailing edge and the trailing margin when there's
//      enough text in the string to fill the whole window.
//
//      Implemented for the single line edit control.


BOOL EditHScroll(PED ped, HDC hdc, PSTR pText) {

    int       ichCaret;
    int       dx;       // Distance to move RIGHTWARDS (i.e. visually)
    int       cx;       // Original visual cursor position
    int       tw;       // Text width
    int       rw;       // Rectangle width
    int       ix;       // ScriptCPtoX result
    UINT      uOldXOffset;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (!ped->cch || ped->ichCaret > ped->cch) {
        ped->xOffset = 0;
        return FALSE;
    }


    hr = EditStringAnalyse(hdc, ped, pText, ped->cch, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditHScroll - EditStringAnalyse"));
        return FALSE;
    }

    MBCPtoWCCP(ped, pText, ped->ichCaret, &ichCaret);


    uOldXOffset = ped->xOffset;
    tw = psa->size.cx;                              // Text width
    rw = ped->rcFmt.right-ped->rcFmt.left;          // Window rectangle width
    #ifdef CURSOR_ABSOLUTE_HOME_AND_END
        if (ichCaret <= 0) {
            cx = ped->fRtoLReading ? psa->size.cx : 0;
        } else if (ichCaret >= psa->cInChars) {
            cx = ped->fRtoLReading ? 0: psa->size.cx;
        } else {
            cx = ScriptCursorX(psa, ichCaret-1);
        }
        cx += LeftEdgeX(ped, tw);
    #else
        if (ichCaret <= 0) {
            hr = ScriptStringCPtoX(psa, ichCaret, FALSE, &ix);
        } else {
            hr = ScriptStringCPtoX(psa, ichCaret-1, TRUE, &ix);
        }

        if (FAILED(hr)) {
            ASSERTHR(hr, ("EditHScroll - ScriptStringCPtoX"));
            ScriptStringFree(&psa);
            return FALSE;
        }

        cx = LeftEdgeX(ped, tw) + ix;
    #endif

    if (cx < ped->rcFmt.left) {

        // Bring cursor position to left quartile
        dx = rw/4 - cx;

    } else if (cx > ped->rcFmt.right) {

        // Bring cursor position to right quartile
        dx = (3*rw)/4 - cx;

    } else
        dx = 0;


    // Adjust visual position change to logical - relative to reading order

    if (ped->fRtoLReading) {
        dx = - dx;
    }


    // Avoid unnecessary leading or trailing whitespace

    if (tw - ((INT)ped->xOffset - dx) < rw && tw > rw ) {

        // No need to have white space at the end if there's enough text
        ped->xOffset = (UINT)(tw-rw);

    } else if ((INT)ped->xOffset < dx) {

        // No need to have white space at beginning of line
        ped->xOffset = 0;

    } else {

        // Move cursor directly to chosen quartile
        ped->xOffset -= (UINT) dx;
    }


    TRACE(EDIT, ("HScroll format=%d, fWrap=%d, fRtoLReading=%d, right-left=%d, new xOffset %d",
                 ped->format, ped->fWrap, ped->fRtoLReading, ped->rcFmt.right - ped->rcFmt.left, ped->xOffset));

    ScriptStringFree(&psa);

    return ped->xOffset != uOldXOffset ? TRUE : FALSE;
}







////    IchToXY
//
//      Converts a character position to the corresponding x coordinate
//      offset from the left end of the text of the line.


int EditIchToXY(PED ped, HDC hdc, PSTR pText, ICH ichLength, ICH ichPos) {

    INT       iResult;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (ichLength == 0) {
        return LeftEdgeX(ped, 0);
    }


    hr = EditStringAnalyse(hdc, ped, pText, ichLength, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditIchToXY - EditStringAnalyse"));
        return LeftEdgeX(ped, 0);
    }

    MBCPtoWCCP(ped, pText, ichPos, &ichPos);

    #ifdef CURSOR_ABSOLUTE_HOME_AND_END
        if (ichPos <= 0) {
            iResult = ped->fRtoLReading ? psa->size.cx : 0;
        } else if (ichPos >= psa->cInChars) {
            iResult = ped->fRtoLReading ? 0 : psa->size.cx;
        } else {
            iResult = ScriptStringCPtoX(psa, ichPos-1);
        }
    #else
        if (ichPos <= 0) {
            hr = ScriptStringCPtoX(psa, ichPos, FALSE, &iResult);
        } else {
            hr = ScriptStringCPtoX(psa, ichPos-1, TRUE, &iResult);
        }
        if (FAILED(hr)) {
            ASSERTHR(hr, ("EditIchToXY - ScriptStringCPtoX"));
            iResult = 0;
        }
    #endif

    iResult += LeftEdgeX(ped, psa->size.cx);

    ScriptStringFree(&psa);

    return (int) iResult;
}







////    EditDrawText - draw one line for MLDrawText
//
//      Draws the text at offset ichStart from pText length ichLength.
//
//      entry   pwText    - points to beginning of line to display
//              iMinSel,  - range of characters to be highlighted. May
//              iMaxSel     be -ve or > cch.
//
//      Uses ED structure fields as follows:
//
//      rcFmt       - drawing area
//      xOffset     - distance from leading margin to leading edge of text.
//                    (May be negative if the text is horizontally scrolled).
//      RtoLReading - determines leading margin/edge.
//      format      - ES_LEFT   - leading edge aligned (may be scrolled horizontally)
//                  - ES_CENTRE - centred between margins. (can't be scrolled horizontally)
//                  - ES_RIGHT  - trailing margin aligned (can't be scrolled horizontally)


void EditDrawText(PED ped, HDC hdc, PSTR pText, INT iLength, INT iMinSel, INT iMaxSel, INT iY) {

    INT       iX;               // x position to start display at
    INT       iWidth;           // Width of line
    RECT      rc;               // Locally updated copy of rectangle
    int       xFarOffset;
    HRESULT   hr;
    STRING_ANALYSIS *psa;


    // Establish where to display the line

    rc         = ped->rcFmt;
    rc.top     = iY;
    rc.bottom  = iY + ped->lineHeight;
    xFarOffset = ped->xOffset + rc.right - rc.left;

    // Include left or right margins in display unless clipped
    // by horizontal scrolling.
    if (ped->wLeftMargin) {
        if (!(   ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
              && (   (!ped->fRtoLReading && ped->xOffset > 0)  // LTR and first char not fully in view
                  || ( ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) { //RTL and last char not fully in view
            rc.left  -= ped->wLeftMargin;
        }
    }
    if (ped->wRightMargin) {
        if (!(   ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
              && (   ( ped->fRtoLReading && ped->xOffset > 0)  // RTL and first char not fully in view
                  || (!ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) { // LTR and last char not fully in view
            rc.right += ped->wRightMargin;
        }
    }



    if (iMinSel < 0)       iMinSel = 0;
    if (iMaxSel > iLength) iMaxSel = iLength;


    if (ped->fSingle) {
        // The single line edit control always applies the background color
        SetBkMode(hdc, OPAQUE);
    }

    if (iLength <= 0) {
        if ((iMinSel < iMaxSel) || (GetBkMode(hdc) == OPAQUE)) {
            // Empty line, just clear it on screen
            ExtTextOutW(hdc, 0,iY, ETO_OPAQUE, &rc, NULL, 0, NULL);
        }
        return;
    }


    hr = EditStringAnalyse(hdc, ped, pText, iLength, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditDrawText - EditStringAnalyse"));
        return;
    }

    MBCPtoWCCP(ped, pText, iMinSel, &iMinSel);
    MBCPtoWCCP(ped, pText, iMaxSel, &iMaxSel);

    iWidth = psa->size.cx;
    iX = LeftEdgeX(ped, iWidth);    // Visual x where left edge of string should be.


    ScriptStringOut(
        psa,
        iX,
        iY,
        ETO_CLIPPED
        | (GetBkMode(hdc) == OPAQUE    ? ETO_OPAQUE     : 0),
        &rc,
        iMinSel,
        ped->fNoHideSel || ped->fFocus ? iMaxSel : iMinSel,
        ped->fDisabled);


    ScriptStringFree(&psa);
}







////    EditMouseToIch
//
//      Returns the logical character offset corresponding to
//      a specified x offset.
//
//      entry   iX - Window (visual) x position



ICH EditMouseToIch(PED ped, HDC hdc, PSTR pText, ICH ichCount, INT iX) {

    ICH       iCh;
    BOOL      fTrailing;
    int       iWidth;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (ichCount == 0) {
        return 0;
    }


    hr = EditStringAnalyse(hdc, ped, pText, ichCount, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditMouseToIch - EditStringAnalyse"));
        return 0;
    }


    iWidth = psa->size.cx;

    // Take horizontal scroll position into consideration.

    iX -= LeftEdgeX(ped, iWidth);

    // If the user clicked beyond the edge of the string, treat it as a logical
    // start or end of string request.

    if (iX < 0) {

        iCh = ped->fRtoLReading ? ichCount : 0;

    } else if (iX > iWidth) {

        TRACE(POSN, ("LpkEditMouseToIch iX beyond right edge: iX %d, psa->piOutVW %x, psa->nOutGlyphs %d, psa->piDx[psa->nOutGlyphs-1] %d",
                iX, psa->piOutVW, psa->nOutGlyphs, iWidth));

        iCh = ped->fRtoLReading ? 0 : ichCount;

    } else {

        // Otherwise it's in the string. Find the logical character whose centre is nearest.

        ScriptStringXtoCP(psa, iX, &iCh, &fTrailing);
        iCh += fTrailing;   // Snap to nearest character edge

        WCCPtoMBCP(ped, pText, iCh, &iCh);
    }

    ScriptStringFree(&psa);

    TRACE(POSN, ("EditMouseToIch iX %d returns ch %d", iX, iCh));

    return iCh;
}







////    EditGetLineWidth
//
//      Returns width of line in pixels


INT EditGetLineWidth(PED ped, HDC hdc, PSTR pText, ICH cch) {

    INT       iResult;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (cch == 0) {
        return 0;
    }

    if (cch > MAXLINELENGTH) {
        cch = MAXLINELENGTH;
    }


    hr = EditStringAnalyse(hdc, ped, pText, cch, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditGetLineWidth - EditStringAnalyse"));
        return 0;
    }

    iResult = psa->size.cx;

    ScriptStringFree(&psa);

    TRACE(EDIT, ("EditGetLineWidth width %d returns %d", cch, iResult))

    return iResult;
}







////    EditCchInWidth
//
//      Returns number of characters that will fit in width pixels.


ICH  EditCchInWidth(PED ped, HDC hdc, PSTR pText, ICH cch, int width) {

    ICH       ichResult;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (cch > MAXLINELENGTH) {
        cch = MAXLINELENGTH;
    } else if (cch == 0) {
        return 0;
    }


    hr = EditStringAnalyse(hdc, ped, pText, cch, SSA_GLYPHS | SSA_CLIP, width, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditCchInWidth - EditStringAnalyse"));
        return 0;
    }

    ichResult = psa->cOutChars;

    WCCPtoMBCP(ped, pText, ichResult, &ichResult);

    ScriptStringFree(&psa);


    TRACE(EDIT, ("EditCchInWidth width %d returns %d", width, ichResult))

    return ichResult;
}







////    EditMoveSelection
//
//      Returns nearest character position backward or forward from current position.
//
//      Position is restricted according to language rules. For example, in Thai it is
//      not possible to position the cursor between a base consonant and it's
//      associated vowel or tone mark.


ICH EditMoveSelection(PED ped, HDC hdc, PSTR pText, ICH ich, BOOL fBackward) {


    #define SP  0x20
    #define TAB 0x09
    #define CR  0x0D
    #define LF  0x0A
    #define EDWCH(ich)     (ped->fAnsi ? (WCHAR)pText[ich] : ((PWSTR)pText)[ich])
    #define EDWCBLANK(ich) ((BOOL) (EDWCH(ich) == SP || EDWCH(ich) == TAB))
    #define EDWCCR(ich)    ((BOOL) (EDWCH(ich) == CR))
    #define EDWCLF(ich)    ((BOOL) (EDWCH(ich) == LF))
    #define EDSTARTWORD(ich) (   (ich == 0)                   \
                              || (    (    EDWCBLANK(ich-1)   \
                                       ||  EDWCLF(ich-1))     \
                                  &&      !EDWCBLANK(ich))    \
                              || (    !EDWCCR(ich-1)          \
                                  &&  EDWCCR(ich)))


    ICH  ichNonblankStart;  // Leading character of nonblank run containing potential caret position
    ICH  ichNonblankLimit;  // First character beyond nonblank run containing potential caret position
    int  iOffset;           // Offset into nonblank run of ich measued in logical characters

    STRING_ANALYSIS  *psa;
    HRESULT           hr;


    // Handle simple special cases:
    // o  At very beginning or end of buffer
    // o  When target position is blank or start or end of line


    if (fBackward) {

        if (ich <= 1) {
            return 0;
        }

        ich--;

        if (EDWCBLANK(ich)) {
            return ich;
        }

        if (EDWCLF(ich)) {
            while (    ich > 0
                   &&  EDWCCR(ich-1)) {
                ich--;
            }
            return ich;
        }

    } else {

        if (ich >= ped->cch-1) {
            return ped->cch;
        }

        ich++;

        if (EDWCBLANK(ich)) {
            return ich;
        }

        if (EDWCCR(ich-1)) {

            // Moving forward from a CR.

            if (    ich < ped->cch
                &&  EDWCCR(ich)) {
                ich++;
            }
            if (    ich < ped->cch
                &&  EDWCLF(ich)) {
                ich++;
            }

            return ich;
        }
    }


    // Identify nonblank run containing target position

    ichNonblankStart = ich;
    ichNonblankLimit = ich+1;


    // Move ichNonblankStart back to real start of blank delimited run

    while (    ichNonblankStart > 0
           &&  !(EDSTARTWORD(ichNonblankStart))) {
        ichNonblankStart--;
    }

    // Include one leading space if any

    if (    ichNonblankStart > 0
        &&  EDWCBLANK(ichNonblankStart - 1)) {

        ichNonblankStart--;
    }


    // Move ichNonblankLimit on to real end of blank delimited run

    while (    ichNonblankLimit < ped->cch
           &&  !EDWCBLANK(ichNonblankLimit)
           &&  !EDWCCR(ichNonblankLimit)) {

        ichNonblankLimit++;
    }


    // Obtain a break analysis of the identified nonblank run

     hr = LpkStringAnalyse(
          hdc,
          pText + ichNonblankStart * ped->cbChar,
          ichNonblankLimit - ichNonblankStart,
          0,
          GetEditAnsiConversionCharset(ped),
          SSA_BREAK,
          -1, 0,
          NULL, NULL, NULL, NULL, NULL,
          &psa);


     if (SUCCEEDED(hr)) {

        // Use the charstop flags in the logical attributes to correct ich

        if (ich <= ichNonblankStart) {
            iOffset = 0;
        } else {
            hr = MBCPtoWCCP(ped, pText+ichNonblankStart*ped->cbChar, ich-ichNonblankStart, &iOffset);
            if (hr == E_FAIL) {
                // ich was the second byte of a double byte character.
                // In this case MBCPtoWCCP has returned the subsequent character
                if (fBackward) {
                    iOffset--;
                }
            }
        }


        if (fBackward) {

            while (    iOffset > 0
                   &&  !psa->pLogAttr[iOffset].fCharStop) {
                iOffset--;
            }

        } else {

            while (    iOffset < psa->cInChars
                   &&  !psa->pLogAttr[iOffset].fCharStop) {
                iOffset++;
            }
        }

        ScriptStringFree(&psa);

        WCCPtoMBCP(ped, pText+ichNonblankStart*ped->cbChar, iOffset, &ich);

        return ichNonblankStart + ich;

    } else {

        ASSERTHR(hr, ("EditMoveSelection - LpkStringAnalyse"));

        // Analysis not possible - ignore content of complex scripts.

        return ich;
    }
}





void EditGetNextBoundaries(
    PED       ped,
    HDC       hdc,
    PSTR      pText,
    ICH       ichStart,
    BOOL      fLeft,
    ICH      *pichMin,
    ICH      *pichMax,
    BOOL      fWordStop)
{


    ICH       sd,ed;     // Start and end of blank delimited run
    ICH       sc,ec;     // Star and end of complex script word within sd,se
    HRESULT   hr;
    STRING_ANALYSIS *psa;


    // Identify left end of nearest delimited word (see diagram above)

    sd = ichStart;

    if (fLeft) {

        // Going left

        if (sd) {
            sd--;

            while (!(EDSTARTWORD(sd))) {
                sd--;
            }
        }

    } else {

        // Going right

        if (EDWCBLANK(sd)) {

            // Move right to first character of word

            if (sd < ped->cch) {
                sd++;
                while (sd < ped->cch && !EDSTARTWORD(sd)) {
                    sd++;
                }
            }

        } else {

            // Move left to first character of this word

            while (!EDSTARTWORD(sd)) {
                sd--;
            }
        }
    }



    // Position 'e' on first character of next word

    ed = sd;
    if (ed < ped->cch) {
        ed++;
        while (ed<ped->cch && !EDSTARTWORD(ed)) {
            ed++;
        }
    }


    // Obtain an analysis of the identified word

     hr = LpkStringAnalyse(
          hdc, pText  + sd * ped->cbChar, ed - sd, 0,
          GetEditAnsiConversionCharset(ped),
          SSA_BREAK,
          -1, 0,
          NULL, NULL, NULL, NULL, NULL,
          &psa);

     if (SUCCEEDED(hr)) {

        // Use the start of word (linebreak) flags in the logical attribute
        // to narrow the word where appropriate to complex script handling

        if (ichStart > sd) {
            MBCPtoWCCP(ped, pText+sd*ped->cbChar, ichStart-sd, &sc);
        } else {
            sc = 0;
        }

        // Change ed from byte offset to codepoint index relative to sd

        MBCPtoWCCP(ped, pText+sd*ped->cbChar, ed-sd, &ed);


        if (fLeft && sc) // Going left
            sc--;

        if (fWordStop) {
            while (sc && !psa->pLogAttr[sc].fSoftBreak)
                sc--;
        }
        else {
            while (sc && !psa->pLogAttr[sc].fCharStop)
                sc--;
        }

        // Set ichMax to next stop

        ec = sc;

        if (ec < ed) {
            ec++;
            if (fWordStop) {
                while (ec < ed && !psa->pLogAttr[ec].fSoftBreak)
                    ec++;
            }
            else {
                while (ec < ed && !psa->pLogAttr[ec].fCharStop)
                    ec++;
            }
        }

        WCCPtoMBCP(ped, pText+sd*ped->cbChar, sc, &sc);
        WCCPtoMBCP(ped, pText+sd*ped->cbChar, ec, &ec);

        if (pichMin) *pichMin = sd + sc;
        if (pichMax) *pichMax = sd + ec;

        ScriptStringFree(&psa);

    } else {

        ASSERTHR(hr, ("EditGetNextBoundaries - LpkStringAnalyse"));

        // Analysis not possible - ignore content of complex scripts.

        if (pichMin) *pichMin = sd;
        if (pichMax) *pichMax = ed;
    }
}


////    EditNextWord - find adjacent word start and end points
//
//      Duplicates the behaviour of US notepad.
//
//      First stage identify word range using standard
//      blank/tab as delimiter.
//
//      Second stage - analyse this run and use the logical
//      attributes to narrow down on words identified by
//      contextual processing in the complex script shaping
//      engines.
//
//
//      The following diagram describes the identification
//      of the initial character of the nearest word:
//
//      GOING LEFT:
//
//      Words        WWWW    WWWW    WWWW
//      from any of           xxxxxxxx
//      to                   x
//
//      (Notice that the result is always to the left of the initial
//      position).
//
//
//      GOING RIGHT:
//
//      Words        WWWW    WWWW    WWWW
//      from any of      xxxxxxxx
//      to                   x
//
//
//      Note that CRLF and CRCRLF are treated as words even if not
//      delimited by blanks.


void EditNextWord(
    PED       ped,
    HDC       hdc,
    PSTR      pText,
    ICH       ichStart,
    BOOL      fLeft,
    ICH      *pichMin,
    ICH      *pichMax)
{
    EditGetNextBoundaries(ped, hdc, pText, ichStart, fLeft, pichMin, pichMax, TRUE);
}





////    IsVietnameseSequenceValid
//
//      Borrow this code from richedit. The logic was provided by Chau Vu.
//
//      April 26, 1999  [wchao]

BOOL IsVietnameseSequenceValid (WCHAR ch1, WCHAR ch2)
{

    #define IN_RANGE(n1, b, n2)     ((unsigned)((b) - (n1)) <= (unsigned)((n2) - (n1)))

    int i;
    static const BYTE vowels[] = {0xF4, 0xEA, 0xE2, 'y', 'u', 'o', 'i', 'e', 'a'};


    if (!IN_RANGE(0x300, ch2, 0x323) ||     // Fast out
        !IN_RANGE(0x300, ch2, 0x301) && ch2 != 0x303 && ch2 != 0x309 && ch2 != 0x323)
    {
        return TRUE;                        // Not Vietnamese tone mark
    }

    for(i = sizeof(vowels) / sizeof(vowels[0]); i--;)
        if((ch1 | 0x20) == vowels[i])       // Vietnamese tone mark follows
            return TRUE;                    // vowel

    return IN_RANGE(0x102, ch1, 0x103) ||   // A-breve, a-breve
           IN_RANGE(0x1A0, ch1, 0x1A1) ||   // O-horn,  o-horn
           IN_RANGE(0x1AF, ch1, 0x1B0);     // U-horn,  u-horn
}





////    EditStringValidate
//
//      Validate the string sequence from the insertion point onward.
//      Return S_FALSE if any character beyond the insertion point produces fInvalid.
//
//      April 5,1999     [wchao]

HRESULT EditStringValidate (STRING_ANALYSIS* psa, int ichInsert)
{
    BOOL    fVietnameseCheck = PRIMARYLANGID(THREAD_HKL()) == LANG_VIETNAMESE;
    int     iItem;
    int     i;
    int     l;


    if (!psa->pLogAttr)
        return E_INVALIDARG;


    for (iItem = 0; iItem < psa->cItems; iItem++)
    {
        if (g_ppScriptProperties[psa->pItems[iItem].a.eScript]->fRejectInvalid)
        {
            i = psa->pItems[iItem].iCharPos;
            l = psa->pItems[iItem + 1].iCharPos - i;

            while (l)
            {
                if (i >= ichInsert && psa->pLogAttr[i].fInvalid)
                    return S_FALSE;
                i++;
                l--;
            }
        }
        else if (fVietnameseCheck && g_ppScriptProperties[psa->pItems[iItem].a.eScript]->fCDM)
        {
            // Vietnamese specific sequence check

            i = psa->pItems[iItem].iCharPos;
            l = psa->pItems[iItem + 1].iCharPos - i;

            while (l)
            {
                if (i > 0 && i >= ichInsert && !IsVietnameseSequenceValid(psa->pwInChars[i-1], psa->pwInChars[i]))
                    return S_FALSE;
                i++;
                l--;
            }
        }
    }

    return S_OK;
}






////    EditVerifyText
//
//      Verify the sequence of input text at the insertion point by calling
//      shaping engine that will return output flag pLogAttr->fInvalid in
//      the invalid position of text. Return 0 if the insert text has invalid
//      combination.
//
//      Mar 31,1997     [wchao]

INT EditVerifyText (PED ped, HDC hdc, PSTR pText, ICH ichInsert, PSTR pInsertText, ICH cchInsert) {

    ICH      ichRunStart;
    ICH      ichRunEnd;
    ICH      ichLineStart;
    ICH      ichLineEnd;
    ICH      cchVerify;
    PSTR     pVerify;
    INT      iResult;
    UINT     cbChar;
    BOOL     fLocateChar;
    HRESULT  hr;
    STRING_ANALYSIS *psa;

    ASSERTS(cchInsert > 0  &&  pInsertText != NULL  &&  pText != NULL,  ("Invalid parameters!"));

    if (cchInsert > 1)
        // What we concern here is about how should we handle a series of characters
        // forming invalid combination(s) that gets updated to the backing store as one
        // operation (e.g. pasting). We chose to not handle it and the logic is that to
        // -only- validate a given input char against the current state of the backing store.
        //
        // Notice that i use the value 1 so we're safe if inserted text is a DBCS character.
        //
        // [Dec 10, 98, wchao]
        return TRUE;

    if (ped->fSingle) {
        ichLineStart = 0;
          ichLineEnd = ped->cch;
    } else {
        ichLineStart = ped->chLines[ped->iCaretLine];
        ichLineEnd = ped->iCaretLine == ped->cLines-1 ? ped->cch : ped->chLines[ped->iCaretLine+1];
    }

    ichRunEnd = ichRunStart = ichInsert;    // insertion point

    // Are we at the space?
    fLocateChar = EDWCH(ichInsert) == SP ? TRUE : FALSE;

    // Locate a valid char
    while ( ichRunStart > ichLineStart && fLocateChar && EDWCH(ichRunStart) == SP ) {
        ichRunStart--;
    }

    // Locate run starting point

    // Find space
    while (ichRunStart > ichLineStart && EDWCH(ichRunStart - 1) != SP) {
        ichRunStart--;
    }

    // Cover leading spaces
    while (ichRunStart > ichLineStart && EDWCH(ichRunStart - 1) == SP) {
        ichRunStart--;
    }

    // Locate a valid char
    while ( ichRunEnd < ichLineEnd && fLocateChar && EDWCH(ichRunEnd) == SP ) {
        ichRunEnd++;
    }

    // Locate run ending point
    while (ichRunEnd < ichLineEnd && EDWCH(ichRunEnd) != SP) {
        ichRunEnd++;
    }

    ASSERTS(ichRunStart <= ichRunEnd, "Invalid run length!");

    // Merge insert text with insertion point run.

    cchVerify = ichRunEnd - ichRunStart + cchInsert;
    cbChar    = ped->cbChar;
    pVerify   = (PSTR) GlobalAlloc(GMEM_FIXED, cchVerify * cbChar);

    if (pVerify) {

        PSTR    pv;
        UINT    cbCopy;

        pv = pVerify;

        cbCopy = (ichInsert - ichRunStart) * cbChar;
        memcpy (pv, pText + ichRunStart * cbChar, cbCopy);
        pv += cbCopy;

        cbCopy = cchInsert * cbChar;
        memcpy (pv, pInsertText, cbCopy);
        pv += cbCopy;

        cbCopy = (ichRunEnd - ichInsert) * cbChar;
        memcpy (pv, pText + ichInsert * cbChar, cbCopy);

    } else {

        ASSERTS(pVerify, "EditVerifyText: Assertion failure: Could not allocate merge text buffer");
        return 1;   // can do nothing now just simply accept it.
    }

    psa      = NULL;
    iResult  = TRUE;    // assume verification pass.

    // Do the real work.
    // This will call to shaping engine and proceed item by item.
    //

    hr = LpkStringAnalyse(
         hdc, pVerify, cchVerify, 0,
         GetEditAnsiConversionCharset(ped),
         SSA_BREAK
         | (ped->charPasswordChar ? SSA_PASSWORD : 0)
         | (ped->fRtoLReading     ? SSA_RTL      : 0),
         -1, 0,
         NULL, NULL, NULL, NULL, NULL,
         &psa);

    if (SUCCEEDED(hr)) {

        MBCPtoWCCP(ped, pVerify, ichInsert - ichRunStart, &ichInsert);

        hr = EditStringValidate(psa, ichInsert);

        if (hr == S_FALSE) {

            MessageBeep((UINT)-1);
            iResult = FALSE;

        } else if (FAILED(hr)) {

            ASSERTHR(hr, ("EditVerifyText - EditStringValidate"));
        }

        ScriptStringFree(&psa);

    } else {
        ASSERTHR(hr, ("EditVerifyText - LpkStringAnalyse"));
    }

    GlobalFree((HGLOBAL) pVerify);
    return iResult;
}







////    EditProcessMenu
//
//      Process LPK context menu commands.
//
//      April 18, 1997     [wchao]
//


INT EditProcessMenu (PED ped, UINT idMenuItem)
{
    HWND    hwnd;
    INT     iResult;

    iResult = TRUE;

    switch (idMenuItem) {

        case ID_CNTX_RTL:
            hwnd = ped->hwnd;
            SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) & ~ES_FMTMASK);
            if (!ped->fRtoLReading) {
                SetWindowLongPtr(hwnd, GWL_EXSTYLE, GetWindowLongPtr(hwnd, GWL_EXSTYLE)
                              | (WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR));
            }
            else {
                SetWindowLongPtr(hwnd, GWL_EXSTYLE, GetWindowLongPtr(hwnd, GWL_EXSTYLE)
                              & ~(WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR));
            }
            break;


        case ID_CNTX_DISPLAYCTRL:
            hwnd = ped->hwnd;
            ped->fDisplayCtrl = !ped->fDisplayCtrl;

            if (ped->fFlatBorder) {

                RECT    rcT;
                int     cxBorder, cyBorder;

                GetClientRect(hwnd, &rcT);
                cxBorder = GetSystemMetrics (SM_CXBORDER);
                cyBorder = GetSystemMetrics (SM_CYBORDER);
                InflateRect(&rcT, -cxBorder, -cyBorder);
                InvalidateRect(hwnd, &rcT, TRUE);
            }
            else {
                InvalidateRect(hwnd, NULL, TRUE);
            }
            break;

        case ID_CNTX_ZWNJ:
            if (ped->fAnsi) {
                SendMessageA(ped->hwnd, WM_CHAR, 0x9D, 0);
            } else {
                SendMessageW(ped->hwnd, WM_CHAR, U_ZWNJ, 0);
            }
            break;

        case ID_CNTX_ZWJ:
            if (ped->fAnsi) {
                SendMessageA(ped->hwnd, WM_CHAR, 0x9E, 0);
            } else {
                SendMessageW(ped->hwnd, WM_CHAR, U_ZWJ, 0);
            }
            break;

        case ID_CNTX_LRM:
            if (ped->fAnsi) {
                SendMessageA(ped->hwnd, WM_CHAR, 0xFD, 0);
            } else {
                SendMessageW(ped->hwnd, WM_CHAR, U_LRM, 0);
            }
            break;

        case ID_CNTX_RLM:
            if (ped->fAnsi) {
                SendMessageA(ped->hwnd, WM_CHAR, 0xFE, 0);
            } else {
                SendMessageW(ped->hwnd, WM_CHAR, U_RLM, 0);
            }
            break;

        case ID_CNTX_LRE:  SendMessageW(ped->hwnd, WM_CHAR, U_LRE,  0); break;
        case ID_CNTX_RLE:  SendMessageW(ped->hwnd, WM_CHAR, U_RLE,  0); break;
        case ID_CNTX_LRO:  SendMessageW(ped->hwnd, WM_CHAR, U_LRO,  0); break;
        case ID_CNTX_RLO:  SendMessageW(ped->hwnd, WM_CHAR, U_RLO,  0); break;
        case ID_CNTX_PDF:  SendMessageW(ped->hwnd, WM_CHAR, U_PDF,  0); break;
        case ID_CNTX_NADS: SendMessageW(ped->hwnd, WM_CHAR, U_NADS, 0); break;
        case ID_CNTX_NODS: SendMessageW(ped->hwnd, WM_CHAR, U_NODS, 0); break;
        case ID_CNTX_ASS:  SendMessageW(ped->hwnd, WM_CHAR, U_ASS,  0); break;
        case ID_CNTX_ISS:  SendMessageW(ped->hwnd, WM_CHAR, U_ISS,  0); break;
        case ID_CNTX_AAFS: SendMessageW(ped->hwnd, WM_CHAR, U_AAFS, 0); break;
        case ID_CNTX_IAFS: SendMessageW(ped->hwnd, WM_CHAR, U_IAFS, 0); break;
        case ID_CNTX_RS:   SendMessageW(ped->hwnd, WM_CHAR, U_RS,   0); break;
        case ID_CNTX_US:   SendMessageW(ped->hwnd, WM_CHAR, U_US,   0); break;
    }

    return iResult;
}






////    EditSetMenu - Set menu state
//
//


void EditSetMenu(PED ped, HMENU hMenu) {


    EnableMenuItem(hMenu, ID_CNTX_RTL, MF_BYCOMMAND | MF_ENABLED);
    CheckMenuItem (hMenu, ID_CNTX_RTL, MF_BYCOMMAND | (ped->fRtoLReading ? MF_CHECKED : MF_UNCHECKED));


    if (!ped->fAnsi || ped->charSet == ARABIC_CHARSET || ped->charSet == HEBREW_CHARSET) {

        // It's unicode, Arabic or Hebrew - we can display and enter at least some control characters

        EnableMenuItem(hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND | MF_ENABLED);
        CheckMenuItem (hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND | (ped->fDisplayCtrl ? MF_CHECKED : MF_UNCHECKED));
        EnableMenuItem(hMenu, ID_CNTX_INSERTCTRL, MF_BYCOMMAND | MF_ENABLED);

        EnableMenuItem(hMenu, ID_CNTX_LRM,  MF_BYCOMMAND  | MF_ENABLED);
        EnableMenuItem(hMenu, ID_CNTX_RLM,  MF_BYCOMMAND  | MF_ENABLED);


        if (!ped->fAnsi || ped->charSet == ARABIC_CHARSET) {

            // Controls characters in Unicode and ANSI Arabic only

            EnableMenuItem(hMenu, ID_CNTX_ZWJ,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_ZWNJ, MF_BYCOMMAND | MF_ENABLED);
        }

        if (!ped->fAnsi) {

            // These control characters are specific to the Unicode bidi algorithm

            EnableMenuItem(hMenu, ID_CNTX_LRE,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_RLE,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_LRO,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_RLO,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_PDF,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_NADS, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_NODS, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_ASS,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_ISS,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_AAFS, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_IAFS, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_RS,   MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_US,   MF_BYCOMMAND | MF_ENABLED);
        }
    } else {

        // No opportunity to enter control characters

        EnableMenuItem(hMenu, ID_CNTX_INSERTCTRL,  MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND | MF_GRAYED);
    }
}





////    EditCreateCaretFromFont
//
//      Create one of the special caret shapes for complex script languages.
//
//      returns FALSE if it couldn't create the caret for example in low
//      memory situations.


#define CURSOR_USA   0xffff
#define CURSOR_LTR   0xf00c
#define CURSOR_RTL   0xf00d
#define CURSOR_THAI  0xf00e


BOOL EditCreateCaretFromFont(
    PED    ped,
    HDC    hdc,
    INT    nWidth,
    INT    nHeight,
    WCHAR  wcCursorCode
)
{
    BOOL      fResult = FALSE;  // Assume the worst
    HBITMAP   hbmBits;
    HDC       hcdcBits;
    HFONT     hArrowFont;
    ABC       abcWidth;
    COLORREF  clrBk;
    WORD      gidArrow;
    UINT      uiWidthBits;
    HBITMAP   hOldBitmap;



    // Create caret from the Arial font

    hcdcBits = CreateCompatibleDC (hdc);
    if (!hcdcBits)
    {
        return FALSE;
    }


    // create Arrow font then select into compatible DC

    // Bitmap will be XORed with the background color before caret starts blinking.
    // Therefore, we need to set our bitmap background to be opposite with the DC
    // actual background in order to generate caret properly.

    clrBk = GetBkColor(hdc);
    SetBkColor (hcdcBits, ~clrBk);

    // Creating the caret with white pattern to be consistant with User-edit field.

    clrBk = RGB(255, 255 , 255); // White
    SetTextColor (hcdcBits, clrBk);

    hArrowFont = CreateFontW ( nHeight, 0, 0, 0, nWidth > 1 ? 700 : 400, 0L, 0L, 0L, 1L,
                     0L, 0L, 0L, 0L, L"Microsoft Sans Serif" );

    if (!hArrowFont)
    {
        goto error;
    }


    SelectObject (hcdcBits, hArrowFont);


    // textout the Arrow char to get its bitmap

    if (!GetCharABCWidthsW (hcdcBits, wcCursorCode, wcCursorCode, &abcWidth))
    {
        goto error;
    }

    if (!GetGlyphIndicesW (hcdcBits, &wcCursorCode, 1, &gidArrow, 0))
    {
        goto error;
    }

    uiWidthBits = (((abcWidth.abcB)+15)/16)*16; // bitmap width must be WORD-aligned

    hbmBits = CreateCompatibleBitmap (hdc, uiWidthBits, nHeight);
    if (!hbmBits)
    {
        goto error;
    }

    hOldBitmap = SelectObject(hcdcBits, hbmBits);

    if (!ExtTextOutW (hcdcBits, -abcWidth.abcA, 0, ETO_OPAQUE | ETO_GLYPH_INDEX, NULL, &gidArrow, 1, NULL))
    {
        DeleteObject(SelectObject(hcdcBits, hOldBitmap));
        goto error;
    }


    // free current caret bitmap handle if we have one

    if (ped->hCaretBitmap) {
        DeleteObject (ped->hCaretBitmap);
    }

    ped->hCaretBitmap = hbmBits;

    if (wcCursorCode == CURSOR_RTL) {
        // RTL cursor has vertical stroke on right hand side. Overlap LTR and RTL
        // positions by one pixel so cursor doesn't go outside the edit control
        // at small sizes.
        ped->iCaretOffset  = 1 - (int) abcWidth.abcB;  // (Allow one pixel overlap between ltr & rtl)

    } else {

        ped->iCaretOffset = 0;
    }

    fResult = CreateCaret (ped->hwnd, hbmBits, 0, 0);


error:
    // release allocated objects

    if (hArrowFont)
    {
        DeleteObject(hArrowFont);
    }

    if (hcdcBits)
    {
        DeleteDC(hcdcBits);
    }

    return fResult;
}







////    EditCreateCaret
//
//      Create locale specific caret shape
//
//      April 25, 1997  [wchao]
//      May 1st,  1997  [samera] Added traditional BiDi cursor under #ifdef
//      Aug 15th, 2000  [dbrown] Fix prefix bug 43057 - no handling for low memory
//
//      Note
//      Complex script carets are mapped in the private area of Unicode in the font.
//      LTR cursor          0xf00c
//      RTL cursor          0xf00d
//      Thai cursor         0xf00e
//


#define LANG_ID(x)      ((DWORD)(DWORD_PTR)x & 0x000003ff);


INT EditCreateCaret(
    PED       ped,
    HDC       hdc,
    INT       nWidth,
    INT       nHeight,
    UINT      hklCurrent) {

    UINT      uikl;
    ULONG     ulCsrCacheCount;
    WCHAR     wcCursorCode;


    ped->iCaretOffset = 0;

    if (!hklCurrent) {
        uikl = LANG_ID(GetKeyboardLayout(0L));
    } else {
        uikl = LANG_ID(hklCurrent);
    }


    // Choose caret shape - use either the standard US caret, or a
    // special shape from the Arial font.

    wcCursorCode = CURSOR_USA;

    switch (uikl) {

        case LANG_THAI:    wcCursorCode = CURSOR_THAI;  break;

        //
        // we may need to call GetLocaleInfo( FONT_SIGNATURE ...) to
        // properly detect RTL languages.
        //

        case LANG_ARABIC:
        case LANG_FARSI:
        case LANG_URDU:
        case LANG_HEBREW:  wcCursorCode = CURSOR_RTL;   break;

        default:

            // Make sure the NLS settings are cached before checking on g_UserBidiLocale. it happens!

            if (    g_ulNlsUpdateCacheCount==-1
                &&  (ulCsrCacheCount = NlsGetCacheUpdateCount()) != g_ulNlsUpdateCacheCount) {

                 TRACE(NLS, ("LPK : Updating NLS cache from EditCreateCaret, lpkNlsCacheCount=%ld, CsrssCacheCount=%ld",
                            g_ulNlsUpdateCacheCount ,ulCsrCacheCount));

                 g_ulNlsUpdateCacheCount = ulCsrCacheCount;

                 // Update the cache now
                 ReadNLSScriptSettings();
            }

            if (g_UserBidiLocale) {
                // Other keyboards have a left-to-right pointing caret
                // in Bidi locales.
                wcCursorCode = CURSOR_LTR;
            }
    }


    if (wcCursorCode != CURSOR_USA)
    {
        // Try to create a caret from the Arial font

        if (!EditCreateCaretFromFont(ped, hdc, nWidth, nHeight, wcCursorCode))
        {
            // Caret from font failed - low memory perhaps
            wcCursorCode = CURSOR_USA;  // Fall back to USA cursor
        }
    }


    if (wcCursorCode == CURSOR_USA) {

        // Use Windows default caret

        return CreateCaret (ped->hwnd, NULL, nWidth, nHeight);

    } else {

        return TRUE;

    }
}






////    EditAdjustCaret
//
//      Adjust caret after insertion/deletion to avoid the caret in between a cluster,
//      very common in Indic e.g.
//
//          1. Deleting the space "X| Y" and it becomes "X|y".
//          2. Inserting 'X' at "|Y" and it becomes "X|y".
//
//      May 3,1999        [wchao]
//

INT EditAdjustCaret (
    PED     ped,
    HDC     hdc,
    PSTR    pText,
    ICH     ich)
{
#if 0
    //
    // Indiannt unanimously request this feature to be removed for final product.
    // (wchao - 7/12/99)
    //
    ICH     ichMin;
    ICH     ichMax;

    if (ich < ped->cch)
    {
        EditGetNextBoundaries(ped, hdc, pText, ich, FALSE, &ichMin, &ichMax, FALSE);

        if (ich > ichMin)
            ich = ichMax;
    }
#endif
    UNREFERENCED_PARAMETER(ped);
    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(pText);

    return ich;
}






////    Edit callout
//
//      The LPK edit support functions are acessed by the edit
//      control code through a struct defined in user.h.
//
//      Here we initialise that struct with the addresses
//      of the callout functions.


LPKEDITCALLOUT LpkEditControl = {
    EditCreate,
    EditIchToXY,
    EditMouseToIch,
    EditCchInWidth,
    EditGetLineWidth,
    EditDrawText,
    EditHScroll,
    EditMoveSelection,
    EditVerifyText,
    EditNextWord,
    EditSetMenu,
    EditProcessMenu,
    EditCreateCaret,
    EditAdjustCaret
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk.h ===
/*++

   Copyright (c) 1998-1999 Microsoft Corporation.

*/

#ifndef __lpk__
#define __lpk__
#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#ifdef __cplusplus
extern "C" {
#endif


/////   LPK.H - Internal header
//
//
#include "usp10.h"
#include "usp10p.h"
#include "lpk_glob.h"


/////   LpkStringAnalyse
//
//      Build Uniscribe input flag structures


HRESULT LpkStringAnalyse(
    HDC               hdc,       //In  Device context (required)
    const void       *pString,   //In  String in 8 or 16 bit characters
    int               cString,   //In  Length in characters
    int               cGlyphs,   //In  Required glyph buffer size (default cString*3/2 + 1)
    int               iCharset,  //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD             dwFlags,   //In  Analysis required
    int               iDigitSubstitute,
    int               iReqWidth, //In  Required width for fit and/or clip
    SCRIPT_CONTROL   *psControl, //In  Analysis control (optional)
    SCRIPT_STATE     *psState,   //In  Analysis initial state (optional)
    const int        *piDx,      //In  Requested logical dx array
    SCRIPT_TABDEF    *pTabdef,   //In  Tab positions (optional)
    BYTE             *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)

    STRING_ANALYSIS **ppsa);     //Out Analysis of string






/////   ftsWordBreak - Support full text search wordbreaker
//
//
//      Mar 9,1997 - [wchao]
//


BOOL WINAPI ftsWordBreak (
    PWSTR  pInStr,
    INT    cchInStr,
    PBYTE  pResult,
    INT    cchRes,
    INT    charset);






/////   Shared definitions for USER code

#define IS_ALTDC_TYPE(h)    (LO_TYPE(h) != LO_DC_TYPE)



/////   LpkInternalPSMtextOut
//
//      Called from LPK_USRC.C

int LpkInternalPSMTextOut(
    HDC           hdc,
    int           xLeft,
    int           yTop,
    const WCHAR  *pwcInChars,
    int           nCount,
    DWORD         dwFlags);






/////   LpkBreakAWord
//
//      Called from LPK_USRC.C

int LpkBreakAWord(
    HDC     hdc,
    LPCWSTR lpchStr,
    int     cchStr,
    int     iMaxWidth);






/////   LpkgetNextWord
//
//      Called from LPK_USRC.C

int LpkGetNextWord(
    HDC      hdc,
    LPCWSTR  lpchStr,
    int      cchCount,
    int      iCharset);






/////   LpkCharsetDraw
//
//      Called from LPK_USRC.C
//
//      Note: Doesn't implement user defined tabstops

int LpkCharsetDraw(
    HDC             hdc,
    int             xLeft,
    int             cxOverhang,
    int             iTabOrigin,
    int             iTabLength,
    int             yTop,
    PCWSTR          pcwString,
    int             cchCount,
    BOOL            fDraw,
    DWORD           dwFormat,
    int             iCharset);






/////   InternalTextOut
//
//

BOOL InternalTextOut(
    HDC           hdc,
    int           x,
    int           y,
    UINT          uOptions,
    const RECT   *prc,
    const WCHAR  *pStr,
    UINT          cbCount,
    const int    *piDX,
    int           iCharset,
    int          *piWidth,
    int           iRequiredWidth);






///// ReadNLSScriptSettings

BOOL ReadNLSScriptSettings(
    void);






/////   InitNLS

BOOL InitNLS();






/////   NLSCleanup

BOOL NLSCleanup(
    void);






/////   Shaping engins IDs.

#define BIDI_SHAPING_ENGINE_DLL     1<<0
#define THAI_SHAPING_ENGINE_DLL     1<<1
#define INDIAN_SHAPING_ENGINE_DLL   1<<4


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_nls.cxx ===
/*++

  Copyright (c) 1997-1999,  Microsoft Corporation  All rights reserved.

  Module Name  :

    lpk_nls.c

  Abstract:

    This module picks up any changes to the NLS data which happen to the
    registry. A thread is dispatched from the LPK and waits for an event
    of a registry-change notification. This is a HELL-OF overhead, since it
    envolves a thread overhead/process as long as the LPK is attached
    to each process.

    Current NLS information being set :
      - Numeric Style (Native + Substitution). Currently for Beta-1 timeframe,
        we'll just set the registry entry at setup time, and if user wants to change it,
        he should go CURRENT_USER\Control Panel\International and change the value of
        sNativeDigits and iDigitSubstitution.

  Author:

    Samer Arafeh (SamerA) 27-Feb-1997    @ 5:04 pm

  Revision History:
    [samera] Apr 3rd, 1997, Dispatch NLS thread to wait on Control Panel\Internationl Reg Notification Change
    [DBrown] Dec 4th, 1997, Update for NT5 LPK and Uniscribe

--*/






#include "precomp.hxx"






/************************************************************
 BOOL ReadNLSScriptSettings


 Reads script related registry settings from
      HKEY_CURRENT_USER\Control Panel\International

 History :
   Samera    Created   Feb 18, 1997
 ************************************************************/

///// ReadNLSScriptSettings

BOOL ReadNLSScriptSettings(
    void) {

    #define       MAXWCBUF  80

    WCHAR         wcBuf[MAXWCBUF];   // Registry read buffer
    int           cBuf;
    SCRIPT_ITEM   item[2];
    int           cItems;
    HRESULT       hr;


    // User locale information

    g_UserLocale          = GetUserDefaultLCID();
    g_UserPrimaryLanguage = PRIMARYLANGID(LANGIDFROMLCID(g_UserLocale));

    cBuf = GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_FONTSIGNATURE, wcBuf, MAXWCBUF);
    g_UserBidiLocale      = (cBuf  &&  wcBuf[7] & 0x0800) ? TRUE : FALSE;


    // Establish users digit substitution settings

    hr = ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &g_DigitSubstitute);
    if (FAILED(hr)) {
        return FALSE;
    }


    return TRUE ;
}






/************************************************************
 BOOL InitNLS()

 Initializes all NLS related info in LPK Globals and fetches
 out the registry Control Panel\International for Numeric settings.

 History :
   Dbrown    Created
   Samera    Feb 18, 1997 Read NLS at init
 ************************************************************/

/////   InitNLS

BOOL InitNLS() {


    // Initialize Thread-NLS-Pickup

    g_hCPIntlInfoRegKey = NULL;
    g_hNLSWaitThread    = NULL;


    // Always update our NLS cache at initialization.
    g_ulNlsUpdateCacheCount = -1;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_init.cxx ===
/********************************************************************
 *
 *  Module Name : lpk_init.cxx
 *
 *  The module handles the Dll entry point and intialization routines.
 *
 *  Created : Oct 21, 1996
 *  Author  : Samer Arafeh  [samera]
 *
 *  Copyright (c) 1996, Microsoft Corporation. All rights reserved.
 *
 **********************************************************************/


#include "precomp.hxx"






/***************************************************************************\
* FindStartOfString
*
* Searches the unicode res string for the specified pattern.
*
* History:
* 2-Jan-1998 SamerA    Created.
\***************************************************************************/


PWSTR FindStartOfString(
    PWSTR pwszToFind,
    ULONG uLenToFind,
    PWSTR pResourceData,
    ULONG uSearchLen)
{
    ULONG i=0,j=0;
    PWSTR pwszMatch=pResourceData ;

  
    if ( uLenToFind > uSearchLen ) {
        return NULL;
    }

    while ( i<uSearchLen ) {

        if ( (pwszToFind[j] == pwszMatch[i]) &&
            ((uSearchLen-i+1) >= uLenToFind ) ) {
            while ( j<uLenToFind ) {
                if ( pwszToFind[j] != pwszMatch[i] ) {
                    j=0;
                    break;
                }
                ++j;
                ++i;
            }

            if (j == uLenToFind) {
                //
                // Clear NULLs
                //
                while ( pwszMatch[i] == L'\0' )
                    ++i;
                return &pwszMatch[i];
            }

            continue;
        }
        ++i;
    }

    return NULL;
}

/***************************************************************************\
* LpkCheckForMirrorSignature
*
* Reetreives a pointer to the version resource section of the
* current executable. It checks if the 'FileDescription' field
* contains double LRM at the beginning to indicate a localized Mirrored
* App that requires mirroring. If signature is found, then
* SetProcessDefaultLayout is automatically called to apply mirroring for
* the current process.
*
* History:
* 2-Jan-1998 SamerA    Created.
\***************************************************************************/
BOOL LpkCheckForMirrorSignature( void )
{

    NTSTATUS                   status = STATUS_UNSUCCESSFUL;
    PVOID                      pImageBase,pResourceData;
    PIMAGE_RESOURCE_DATA_ENTRY pImageResource;
    ULONG                      uResourceSize;
    ULONG_PTR                   resIdPath[ 3 ];
    WCHAR                     *pwchDescritpion;
    WCHAR                      wchVersionVar[] = L"FileDescription";


    //
    // Get the current executable handle
    //
    pImageBase = NtCurrentPeb()->ImageBaseAddress;
    if ( NULL == pImageBase ) {
        return NT_SUCCESS(status);
    }

    //
    // Find the version resource. Search for neutral resource, this way
    // the MUI resource redirection code is activated, and the MUI
    // resource will be selected, if available.
    //
    resIdPath[0] = (ULONG_PTR) RT_VERSION ;
    resIdPath[1] = (ULONG_PTR) 1;
    resIdPath[2] = (ULONG_PTR) MAKELANGID( LANG_NEUTRAL , SUBLANG_NEUTRAL );
//    try {
    //
    // Bug #246044 WeiWu 12/07/00
    // Due to #173609 bug fix, resource loader no longer by default redirects 
    // version resource searching to MUI alternative modules
    // So, we have to use LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION to force version redirection
    //
    status = LdrFindResourceEx_U( 
                LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION,
                pImageBase,
                resIdPath,
                3,
                &pImageResource
                );
//    }
//    except( EXCEPTION_EXECUTE_HANDLER )
//    {
//        status = GetExceptionCode();
//    }

    if ( NT_SUCCESS(status) ) {
        //
        // Load the resource into memory
        //
//        try {
            status = LdrAccessResource( pImageBase ,
                         pImageResource,
                         &pResourceData,
                         &uResourceSize
                         );
//        }
//        except( EXCEPTION_EXECUTE_HANDLER )
//        {
//            status = GetExceptionCode();
//        }

        if ( NT_SUCCESS(status) ) {

            //
            // Now we have the Version Info of the current
            // executable.
            //
            // Let's  read the FileDescription and check
            // if this image needs to be mirrored by
            // calling NtUserSetProcessDefaultLayout()
            //

            pwchDescritpion = FindStartOfString( wchVersionVar ,
                                  (sizeof(wchVersionVar)/sizeof(WCHAR)) ,
                                  (WCHAR*)pResourceData ,
                                  uResourceSize/sizeof(WCHAR));

            if ( pwchDescritpion &&
                (0x200e == pwchDescritpion[0]) &&
                (0x200e == pwchDescritpion[1]) ) {
                SetProcessDefaultLayout( LAYOUT_RTL );
            }

        }
    }


    //
    // return status of operation
    //

    return NT_SUCCESS(status);
}


/*************************************************************
 *
 *   LPK Dll Initialization Routines
 *
 **************************************************************/

/**********************************************************************
 LpkDllInitialize( HANDLE hDll , DWORD dwReason , PVOID pvSituation )

 hDll         : Handle to Dll
 dwReason     : Process attach, thread attach, ...etc
 pvSituation  : Load-time or Run-time Dynalink

 This is the initialization procedure called when LPK.DLL gets loaded
 into a process address space

 History :
   Oct 21, 1996 -by- Samer Arafeh [samera]
 ***********************************************************************/
extern "C" BOOL LpkDllInitialize(HINSTANCE hDll, DWORD dwReason, PVOID pvSituation)
{
  BOOL bRet = TRUE ;
  UNREFERENCED_PARAMETER(pvSituation) ;
  switch( dwReason )
  {
    /* Process Attachment : when a process first maps the LPK.DLL to its address space,
       do the one time initialization. */
    case DLL_PROCESS_ATTACH:
      {
        // Disable calling our DLL when new threads are created within the process
        // context that we are mapped in. This is a useful optimization since
        // we are not handlling DLL_THREAD_ATTACH
        DisableThreadLibraryCalls( hDll ) ;
        LpkPresent();   // Tell Uniscribe that the LPK is present.
      }
    break ;

    case DLL_THREAD_ATTACH:
    break ;

    case DLL_THREAD_DETACH:
    break ;

    case DLL_PROCESS_DETACH:
    break ;
  }

  return bRet ;
}



//////////////////////////////////////////////////////////////////////////////
//   GDI32 will call this function at loading time and should return TRUE   //
//////////////////////////////////////////////////////////////////////////////





BOOL LpkInitialize (DWORD dwLPKShapingDLLs) {

    HRESULT hr;

    hr = ScriptGetProperties(&g_ppScriptProperties, &g_iMaxScript);
    if (FAILED(hr)) {
        return FALSE;
    }

    // InitNLS is returning true any way, but I prefered to stay checking it just in case 
    // somebody changed the code indise it.
    
    if (!InitNLS()) {
        return FALSE;
    }

    // in case of low memory InitializeCriticalSectionAndSpinCount return FALSE.
    // we didn't use InitializeCriticalSection because it may throw exception in the low memory
    // condition and should be catched be try-except block. 
    if (!InitializeCriticalSectionAndSpinCount(&csFontIdCache, 0))
    {
        return FALSE;
    }

    LpkCheckForMirrorSignature();

    g_dwLoadedShapingDLLs = dwLPKShapingDLLs;
    // We don't call the GDI intialization for the font linking here because in the CSRSS
    // process the LPK intailization will be done before the Gre GDI intailization.
    g_iUseFontLinking = -1; 

    g_ACP = GetACP();

    // Prepare the FontID cache.
    g_cCachedFontsID       = 0;             // # of cahced font ID.
    g_pCurrentAvailablePos = 0;             // where can we cache next font ID.

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_glob.h ===
#ifndef __LPKGLOBAL__
#define __LPKGLOBAL__

/////   LPK_GLOB - LPK Global variable structure
//
//      The following data is global to each process.
//
//      This structure is instantiated with the name G by GAD.C. hence
//      any code can refer to these variables as G.xxx.
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//




#include <windows.h>
#include <usp10.h>
#include <wingdip.h>




#ifdef __cplusplus
extern "C" {
#endif




#ifdef LPKGLOBALHERE
#define LPKGLOBAL
#else
#define LPKGLOBAL extern
#endif

LPKGLOBAL  UINT                     g_ACP;                   // System default codepage

LPKGLOBAL  LCID                     g_UserLocale;            // User default locale
LPKGLOBAL  LANGID                   g_UserPrimaryLanguage;   // Primary language for user default locale
LPKGLOBAL  BOOL                     g_UserBidiLocale;        // Whether User default locale is Bidi

LPKGLOBAL  SCRIPT_DIGITSUBSTITUTE   g_DigitSubstitute;       // Users choice of digit substitution

LPKGLOBAL  HKEY                     g_hCPIntlInfoRegKey;     // Handle to Control Panel\International Registry Key
LPKGLOBAL  HANDLE                   g_hNLSWaitThread;        // Thread Handle
LPKGLOBAL  int                      g_iUseFontLinking;       // Set when GDI supports font linking


LPKGLOBAL  const SCRIPT_PROPERTIES **g_ppScriptProperties;   // Array of pointers to properties
LPKGLOBAL  int                      g_iMaxScript;
LPKGLOBAL  ULONG                    g_ulNlsUpdateCacheCount; // NLS Update Cache Count

LPKGLOBAL  DWORD                    g_dwLoadedShapingDLLs;   // Each shapping engin has a bit in this dwword.


/////   FontIDCache
//
//      Used to cache the font ID with flag tells if the font has Western Script.
//      This cache will be used in the optimization for ETO and GTE.
#define   MAX_FONT_ID_CACHE         30
LPKGLOBAL  CRITICAL_SECTION csFontIdCache;


typedef struct _tagFontIDCache
{
    UINT   uFontFileID;              // Unique ID number
    BOOL   bHasWestern;              // Falgs for the specified font.
} FONTIDCACHE;

LPKGLOBAL  FONTIDCACHE g_FontIDCache[MAX_FONT_ID_CACHE];
LPKGLOBAL  LONG        g_cCachedFontsID;       // # of cahced font ID.
LPKGLOBAL  LONG        g_pCurrentAvailablePos; // where can we cache next font ID.


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_usrc.c ===
///     lpk_usrc.c - 'c' language interface to USER
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//
//


/*
 * Core NT headers
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#define NONTOSPINTERLOCK
#include <ntosp.h>
/*
 * Standard C runtime headers
 */
#include <limits.h>
#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

/*
 * NtUser Client specific headers
 */
#include "usercli.h"

#include <ntsdexts.h>
#include <windowsx.h>
#include <newres.h>
#include <asdf.h>

/*
 * Complex script language pack
 */
#include "lpk.h"



#ifdef LPKBREAKAWORD
// Remove this after checking in the change in user.h (wchao :- 5-27-99)
#ifndef DT_BREAKAWORD
#define DT_BREAKAWORD   5
#endif
#endif



int WINAPI LpkDrawTextEx(
    HDC             hdc,
    int             xLeft,
    int             yTop,
    PCWSTR          pcwString,
    int             cchCount,
    BOOL            fDraw,
    DWORD           dwFormat,
    LPDRAWTEXTDATA  pDrawInfo,
    UINT            uAction,
    int             iCharSet) {

    switch (uAction) {

        case DT_GETNEXTWORD:
            return LpkGetNextWord(hdc, pcwString, cchCount, iCharSet);

#ifdef LPKBREAKAWORD
        case DT_BREAKAWORD:
            return LpkBreakAWord(hdc, pcwString, cchCount, pDrawInfo->cxMaxWidth);
#endif

        case DT_CHARSETDRAW:
        default: // Default equivalent to DT_CHARSETDRAW to duplicate NT4 behaviour
            return LpkCharsetDraw(
                hdc,
                xLeft,
                pDrawInfo->cxOverhang,
                pDrawInfo->rcFormat.left,   // Tab origin
                pDrawInfo->cxTabLength,
                yTop,
                pcwString,
                cchCount,
                fDraw,
                dwFormat,
                iCharSet);
    }
}






void LpkPSMTextOut(
    HDC           hdc,
    int           xLeft,
    int           yTop,
    const WCHAR  *pwcInChars,
    int           nCount,
    DWORD         dwFlags)
{
    LpkInternalPSMTextOut(hdc, xLeft, yTop, pwcInChars, nCount, dwFlags);

    UNREFERENCED_PARAMETER(dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_usp.cxx ===
////    LPK_USP - Interface to Uniscribe String APIs
//
//      Dave C Brown (dbrown) 13th December 1997.
//
//      Copyright (c) 1996-7, Microsoft Corporation. All rights reserved.






////    LPK_ANA provides the main analysis entrypoint for the script engine
//
//      ScriptStringAnalyse creates and returns a structure containing a
//      variety of information about the string, optionally including:
//
//          Glyphs and glyph attributes
//          Glyph positions
//          Cursor and word positions


#include "precomp.hxx"

#include "winnlsp.h"    // import NlsGetCacheUpdateCount()

extern "C" WINGDIAPI BOOL WINAPI AnyLinkedFonts();  // GDI exports this but doesn't provide a header



/////   LPK.H - Internal header
//
//
//. #include "usp10.h"
//. #include "usp10p.h"
//. #include "lpk_glob.h"


/////   LpkStringAnalyse
//
//      Build Uniscribe input flag structures


HRESULT LpkStringAnalyse(
    HDC               hdc,       //In  Device context (required)
    const void       *pString,   //In  String in 8 or 16 bit characters
    int               cString,   //In  Length in characters
    int               cGlyphs,   //In  Required glyph buffer size (default cString*3/2 + 1)
    int               iCharset,  //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD             dwFlags,   //In  Analysis required
    int               iDigitSubstitute,
    int               iReqWidth, //In  Required width for fit and/or clip
    SCRIPT_CONTROL   *psControl, //In  Analysis control (optional)
    SCRIPT_STATE     *psState,   //In  Analysis initial state (optional)
    const int        *piDx,      //In  Requested logical dx array
    SCRIPT_TABDEF    *pTabdef,   //In  Tab positions (optional)
    BYTE             *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)

    STRING_ANALYSIS **ppsa) {    //Out Analysis of string


    const SCRIPT_CONTROL emptySc = {0};
    const SCRIPT_STATE   emptySs = {0};

    HRESULT                 hr;
    SCRIPT_CONTROL          sc;
    SCRIPT_STATE            ss;
    ULONG                   ulCsrCacheCount;
    SCRIPT_DIGITSUBSTITUTE  sds;


    ASSERTS(cString!=0, "LpkStringAnalyse: input string must contain at least one character");

    TIMEENTRY(LSA, cString);

    if (psControl) {
        sc = *psControl;
    } else {
        sc = emptySc;
    }

    if (psState) {
        ss = *psState;
    } else {
        ss = emptySs;
    }


    // Check to see if we need to update our NLS cached data

    if ((ulCsrCacheCount=NlsGetCacheUpdateCount()) != g_ulNlsUpdateCacheCount) {

        TRACE(NLS, ("LPK : Updating NLS cache, lpkNlsCacheCount=%ld, CsrssCacheCount=%ld",
                     g_ulNlsUpdateCacheCount ,ulCsrCacheCount));

        g_ulNlsUpdateCacheCount = ulCsrCacheCount;

        // Update the cache now
        ReadNLSScriptSettings();
    }


    // Select required digit substitution

    if (iDigitSubstitute < 0) {

        // Use NLS digit subtitution as selected by user through control panel

        ScriptApplyDigitSubstitution(&g_DigitSubstitute, &sc, &ss);

    } else {

        // Override digit subtitution

        sds = g_DigitSubstitute;
        sds.DigitSubstitute = iDigitSubstitute;
        ScriptApplyDigitSubstitution(&sds, &sc, &ss);
    }


    // On Arabic systems, RTL fields start with the ENtoAN rule active.

    if (   (dwFlags & SSA_RTL)
        && (   g_ACP == 1256
            || g_UserPrimaryLanguage == LANG_ARABIC))
    {
        ss.fArabicNumContext = TRUE;
    }


    // When font linking is activated, it takes precedence over font fallback
    // for non-complex scripts.

    if (g_iUseFontLinking == -1) {
      g_iUseFontLinking = (int) AnyLinkedFonts();
    }

    if (g_iUseFontLinking) {
        dwFlags |= SSA_LINK;

    }


    sc.fLegacyBidiClass = TRUE;     // All legacy APIs use legacy plus, minus, solidus classifications


    //TRACEMSG(("LpkStringAnalyse: g_uLocaleLanguage %d, LANG_ARABIC %d, dwFlags & SSA_RTL %x, ss.fArabicNumContext %x",
    //          g_uLocaleLanguage, LANG_ARABIC, dwFlags & SSA_RTL, ss.fArabicNumContext));


    hr = ScriptStringAnalyse(
        hdc,
        pString,
        cString,
        cGlyphs,
        iCharset,
        dwFlags,
        iReqWidth,
        &sc,
        &ss,
        piDx,
        pTabdef,
        pbInClass,
        (SCRIPT_STRING_ANALYSIS*)ppsa);


    TIMEEXIT(LSA);
    return hr;
}







/////   ftsWordBreak - Support full text search wordbreaker
//
//
//      Mar 9,1997 - [wchao]
//


extern "C" BOOL WINAPI ftsWordBreak (
    PWSTR  pInStr,
    INT    cchInStr,
    PBYTE  pResult,
    INT    cchRes,
    INT    charset) {

    int      ich;
    int      ichRes;
    int      ichPrev;
    HRESULT  hr;
    STRING_ANALYSIS *psa;

    UNREFERENCED_PARAMETER(cchRes) ;

    // set up ED structure to prefer BasicAnalysis
    //

    hr = LpkStringAnalyse(
         NULL, pInStr, cchInStr, 0,
         charset,
         SSA_BREAK,
         -1, 0,
         NULL, NULL, NULL, NULL, NULL,
         &psa);

    if (SUCCEEDED(hr)) {

        for (ich=1, ichRes=0, ichPrev=0; ich < cchInStr; ich++) {
            if (psa->pLogAttr[ich].fSoftBreak) {
                pResult[ichRes] = ich - ichPrev;
                ichPrev = ich;
                ichRes++;
            }
        }
        pResult[ichRes] = 0;
        ScriptStringFree((void**)&psa);

    } else {

        ASSERTHR(hr, ("ftsWordBreak - LpkStringAnalyse"));

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\lpk_user.cxx ===
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Module Name : LPK_USER.c                                                //
//                                                                          //
//  Entry points (formal interfaces) for GDI32 to call                      //
//  and route their APIs, so that we can implement our language-specific    //
//  features.                                                               //
//                                                                          //
//  Created : Nov 6, 1996                                                   //
//  Author  : Mohamed AbdEl Hamid  [mhamid]                                 //
//                                                                          //
//  Copyright (c) 1996, Microsoft Corporation. All rights reserved.         //
//////////////////////////////////////////////////////////////////////////////

#include "precomp.hxx"




/////   Shared definitions for USER code

#define IS_ALTDC_TYPE(h)    (LO_TYPE(h) != LO_DC_TYPE)



///

#undef TRACE
#define TRACE(a,b)



//////////////////////////////////////////////////////////////////////////////
// USER32 TabbedTextOut will call this function for supporting Multilingual //
//          Tabbed Text handling.                                           //
// LpkTabbedTextOut( HDC hdc , int x, int y, LPCWSTR lpstring, UINT nCount, //
//                  int nTabPositions, LPINT lpTabPositions, int iTabOrigin,//
//                  BOOL fDrawTheText, int cxCharWidth, int cyCharHeight,   //
//                  int charSet)                                            //
// hDC              :   Handle of device context                            //
// x                :   x-coordinate of text to render                      //
// y                :   y-coordinate of text to render                      //
// lpstring         :   Input string                                        //
// nCount           :   Count of characters in input string                 //
// nTabPositions    :   Specifies the number of values in the array of      //
//                      tab-stop positions.                                 //
// lpTabPositions   :   The tab-stop positions array (increasing order)(+/-)//
// iTabOrigin       :   The X-coordinate position to start expand tabs      //
// fDrawTheText     :   Draw the Text or expand tha tabs only               //
// cxCharWidth      :   Character width to be use to expand the tabs        //
// cxCharHeight     :   Character Height to be use to expand the tabs       //
// charSet   :  Indicates character set of codes. to optimizing the work. ??//
//                                                                          //
// Return       :                                                           //
//      If the function succeeds, return the string dimensions              //
//      Else, the return value is 0.                                        //
//          And we seted the error by call SetLastError.                    //
//                                                                          //
// History :                                                                //
//   Nov 6, 1996 -by- Mohamed AbdEl Hamid [mhamid]                          //
//////////////////////////////////////////////////////////////////////////////
LONG LpkTabbedTextOut(
    HDC         hdc,
    int         x,
    int         y,
    WCHAR      *pwcInChars,
    int         nCount,
    int         nTabPositions,
    int        *pTabPositions,
    int         iTabOrigin,
    BOOL        fDrawTheText,
    int         cxCharWidth,
    int         cyCharHeight,
    int         iCharset) {


    SIZE        textextent;
    SIZE        viewextent;
    SIZE        windowextent;
    int         initialx = x;
    int         cch;
    WCHAR      *pwc;
    int         iOneTab = 0;
    RECT        rc;
    UINT        uOpaque;
    BOOL        fStrStart = TRUE;
    BOOL        fRTLreading;
    int         ySign = 1;     //Assume y increases in down direction.
    UINT        OldTextAlign;
    HRESULT     hr;
    DWORD       dwObjType;
    RECT        rcRTL;

    STRING_ANALYSIS *psa;


    uOpaque = (GetBkMode(hdc) == OPAQUE) ? ETO_OPAQUE : 0;


    /*
    * If no tabstop positions are specified, then use a default of 8 system
    * font ave char widths or use the single fixed tab stop.
    */
    if (!pTabPositions) {
        // no tab stops specified -- default to a tab stop every 8 characters
        iOneTab = 8 * cxCharWidth;
    } else if (nTabPositions == 1) {
        // one tab stop specified -- treat value as the tab increment, one
        // tab stop every increment
        iOneTab = pTabPositions[0];

        if (!iOneTab) {
            iOneTab = 1;
        }
    }


    // Calculate if the y increases or decreases in the down direction using
    // the ViewPortExtent and WindowExtents.
    // If this call fails, hdc must be invalid

    if (!GetViewportExtEx(hdc, &viewextent)) {
        TRACEMSG(("LpkTabbedTextOut: GetViewportExtEx failed"));
        return 0;
    }

    GetWindowExtEx(hdc, &windowextent);
    if ((viewextent.cy ^ windowextent.cy) & 0x80000000) {
        ySign = -1;
    }

    OldTextAlign = GetTextAlign(hdc);
    fRTLreading  = OldTextAlign & TA_RTLREADING;

    SetTextAlign(hdc, (OldTextAlign & ~(TA_CENTER|TA_RIGHT)) | TA_LEFT);

    rc.left = initialx;
    rc.right= initialx;

    rc.top = y;

    if (OldTextAlign & TA_BOTTOM) {
        rc.bottom = rc.top;
    } else {
        rc.bottom = rc.top + (ySign * cyCharHeight);
    }

    while (TRUE) {

        // count the number of characters until the next tab character
        // this set of characters (substring) will be the working set for
        // each iteration of this loop

        for (cch = nCount, pwc = pwcInChars; cch && (*pwc != TEXT('\t')); pwc++, cch--) {
        }

        // Compute the number of characters to be drawn with textout.
        cch = nCount - cch;

        // Compute the number of characters remaining.
        nCount -= cch;       // + 1;

        // get height and width of substring
        if (cch == 0) {

            textextent.cx = 0;
            textextent.cy = cyCharHeight;
            psa = NULL;

        } else {

            dwObjType = GetObjectType(hdc);
            hr = LpkStringAnalyse(
                    hdc, pwcInChars, cch, 0, -1,
                      SSA_GLYPHS
                    | (dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_METAFILE : 0)
                    | (iCharset==-1 || GdiIsPlayMetafileDC(hdc) ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
                    | (fRTLreading  ? SSA_RTL : 0),
                    -1, 0,
                    NULL, NULL, NULL, NULL, NULL,
                    &psa);
            if (FAILED(hr)) {
                ASSERTHR(hr, ("LpkTabbedTextOut - LpkStringAnalyse"));
                return FALSE;
            }

            textextent = psa->size;
        }

        if (fStrStart) {
            // first iteration should just spit out the first substring
            // no tabbing occurs until the first tab character is encountered
            fStrStart = FALSE;
        } else {
            // not the first iteration -- tab accordingly

            int xTab;
            int i;

            if (!iOneTab) {
                // look thru tab stop array for next tab stop after existing
                // text to put this substring
                for (i = 0; i != nTabPositions; i++) {
                    xTab = pTabPositions[i];

                    if (xTab < 0) {
                        // calc length needed to use this right justified tab
                        xTab = iTabOrigin - xTab - textextent.cx;
                    } else {
                        // calc length needed to use this left  justified tab
                        xTab = iTabOrigin + xTab;
                    }
                    if ((xTab - x) > 0) {
                        // we found a tab with enough room -- let's use it
                        x = xTab;
                        break;
                    }
                }
                if (i == nTabPositions) {
                    // we've exhausted all of the given tab positions
                    // go back to default of a tab stop every 8 characters
                    iOneTab = 8 * cxCharWidth;
                }
            }

            // we have to recheck iOneTab here (instead of just saying "else")
            // because iOneTab will be set if we've run out of tab stops
            if (iOneTab) {
                if (iOneTab < 0) {
                    // calc next available right justified tab stop
                    xTab = x + textextent.cx - iTabOrigin;
                    xTab = ((xTab / iOneTab) * iOneTab) - iOneTab - textextent.cx + iTabOrigin;
                } else {
                    // calc next available left justified tab stop
                    xTab = x - iTabOrigin;
                    xTab = ((xTab / iOneTab) * iOneTab) + iOneTab + iTabOrigin;
                }
                x = xTab;
            }
        }

        if (fDrawTheText && (cch!=0)) {
            /*
            * Output all text up to the tab (or end of string) and get its
            * extent.
            */
            rc.right = x + textextent.cx;

            // All the calculations are made as if it is LTR and we flip the coordinates
            // if we have RTL.
            if (fRTLreading) {
                rcRTL = rc;
                rcRTL.left = (2 * initialx) - rc.right;
                rcRTL.right= rcRTL.left + (rc.right - rc.left) ;
                ScriptStringOut(psa, rcRTL.left , y, uOpaque, &rcRTL, 0, 0, FALSE);
            } else {

                ScriptStringOut(psa, x, y, uOpaque, &rc, 0, 0, FALSE);
            }
            rc.left = rc.right;
        }

        if (cch) {
            ScriptStringFree((void**)&psa);
        }

        // Skip over the tab and the characters we just drew.
        x = x + textextent.cx;

        // Skip over the characters we just drew.
        pwcInChars += cch;

        // See if we have more to draw OR see if this string ends in
        // a tab character that needs to be drawn.
        if ((nCount > 0) && (*pwcInChars == TEXT('\t'))) {
            pwcInChars++;  // Skip over the tab
            nCount--;
            continue;
        } else {
            break;        // Break from the loop.
        }
    }

    // if we have at the end of the text some Tabs then wen need to drae the background
    // for it.
    if (fDrawTheText && x>rc.right && uOpaque)
    {
        rc.right = x;

        if (fRTLreading) {
            rcRTL = rc;
            rcRTL.left = (2 * initialx) - rc.right;
            rcRTL.right= rcRTL.left + (rc.right - rc.left) ;
            ExtTextOutW(hdc, rcRTL.left, y, uOpaque|ETO_IGNORELANGUAGE, &rcRTL, L"", 0, NULL);
        } else {
            ExtTextOutW(hdc, rc.left, y, uOpaque|ETO_IGNORELANGUAGE, &rc, L"", 0, NULL);
        }
    }

    SetTextAlign(hdc, OldTextAlign);

    return MAKELONG((x - initialx), (short)textextent.cy);
}







//////////////////////////////////////////////////////////////////////////////
// USER32 PSMTextOut will call this function for supporting Multilingual    //
//          Menu handling.                                                  //
// LpkPSMTextOut( HDC hdc, int xLeft, int yTop, LPCWSTR  lpString,          //
//                  int  nCount)                                            //
// hDC              :   Handle of device context                            //
// xLeft            :   x-coordinate of text to render                      //
// yTop             :   y-coordinate of text to render                      //
// lpString         :   Input string                                        //
// nCount           :   Count of characters in input string                 //
//                                                                          //
// Return           :   Nothing                                             //
//                                                                          //
// History :                                                                //
//   Nov 6, 1996 -by- Mohamed AbdEl Hamid [mhamid]                          //
//////////////////////////////////////////////////////////////////////////////


/////   LpkInternalPSMtextOut
//
//      Called from LPK_USRC.C

int LpkInternalPSMTextOut(
    HDC           hdc,
    int           xLeft,
    int           yTop,
    const WCHAR  *pwcInChars,
    int           nCount,
    DWORD         dwFlags) {


    HRESULT       hr;
    int           iTextAlign;
    STRING_ANALYSIS  *psa;
    int           iWidth;
    DWORD         dwObjType;


    if (!nCount || !pwcInChars) {

        // No action required

        TRACE(GDI, ("LpkPSMTextOut: No string: nCount %d, pwcInChars %x",
                     nCount, pwcInChars));
        return 0;   // That was easy!
    }


    dwObjType = GetObjectType(hdc);


    hr = LpkStringAnalyse(
        hdc, pwcInChars, nCount, 0, -1,
          SSA_GLYPHS
        |    (dwFlags & DT_NOPREFIX ? 0
           : (dwFlags & DT_HIDEPREFIX ? SSA_HIDEHOTKEY
           : (dwFlags & DT_PREFIXONLY ? SSA_HOTKEYONLY : SSA_HOTKEY)))
        | (dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_METAFILE : 0)
        | SSA_FALLBACK
        | ((((iTextAlign = GetTextAlign(hdc)) & TA_RTLREADING) && (iTextAlign != -1)) ? SSA_RTL : 0),
        -1, 0,
        NULL, NULL, NULL, NULL, NULL,
        &psa);

    if (SUCCEEDED(hr)) {

        iWidth = psa->size.cx;
        ScriptStringOut(psa, xLeft, yTop, 0, NULL, 0, 0, FALSE);
        ScriptStringFree((void**)&psa);

    } else {

        iWidth = 0;
        ASSERTHR(hr, ("LpkInternalPSMTextOut - LpkStringAnalyse"));
        psa = NULL;

    }

    return iWidth;
}





#ifdef LPKBREAKAWORD

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// LpkBreakAWord : DrawText calls this routine when the length of a word    //
//                 is longer than the line width.                           //
//                                                                          //
// return - character position to break a non-breakable word                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


/////   LpkBreakAWord
//
//      Called from LPK_USRC.C

int LpkBreakAWord(
    HDC     hdc,
    LPCWSTR lpchStr,
    int     cchStr,
    int     iMaxWidth) {

    if (!lpchStr || cchStr <= 0 || iMaxWidth <= 0)
        return 0;


    STRING_ANALYSIS*    psa;
    int                 cOutChars;
    HRESULT             hr;


    hr = LpkStringAnalyse(
         hdc, lpchStr, cchStr, 0, -1,
         SSA_GLYPHS | SSA_CLIP,
         -1, iMaxWidth,
         NULL, NULL, NULL, NULL, NULL,
         &psa);

    if (FAILED(hr)) {
        ASSERTHR(hr, ("LpkBreakAWord - qLpkStringAnalyse"));
        return 0;
    }

    cOutChars = psa->cOutChars;

    ScriptStringFree((void**)&psa);

    return max(0, cOutChars);
}

#endif





//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// LpkGetNextWord                                                           //
// return - offset to the next word                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
#define CR  0x000D
#define LF  0x000A


/////   LpkgetNextWord
//
//      Called from LPK_USRC.C

int LpkGetNextWord(
    HDC      hdc,
    LPCWSTR  lpchStr,
    int      cchCount,
    int      iCharset) {

    WCHAR   *pRun;
    WCHAR   *pRunEnd;
    int      cchRun;
    int      i=0;
    WCHAR    wchRun;
    HRESULT  hr;
    STRING_ANALYSIS *psa;


    // instantly advance 1 if current char located at whitespaces.

    if (*lpchStr == '\t' || *lpchStr == ' ') {
        return 1;
    }


    // try to find the shortest text run that are going to be analysed

    cchRun = 0;
    pRun = (PWSTR)lpchStr;
    pRunEnd = (PWSTR)(lpchStr + cchCount);
    while (pRun < pRunEnd) {
        wchRun = *pRun;
        if (wchRun == CR || wchRun == LF ||
            wchRun == '\t' || wchRun == ' ') {
            break;
        }
        pRun++;
        cchRun++;
    }

    if (cchRun == 0) {
        return 0;
    }

    hr = LpkStringAnalyse(
         hdc, lpchStr, cchRun, 0, -1,
         SSA_BREAK,
         -1, 0,
         NULL, NULL, NULL, NULL, NULL,
         &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("LpkGetNextWord - qLpkStringAnalyse"));
        return 0;
    }

    // We only return next wordbreak if the first item is a breakable one.
    if (g_ppScriptProperties[psa->pItems->a.eScript]->fComplex) {
        for (i=1; i < cchRun; i++) {
            if (psa->pLogAttr[i].fSoftBreak )
                break;
        }
    }

    ScriptStringFree((void**)&psa);

    return i;
}

//////////////////////////////////////////////////////////////////////////////
// USER32 DrawTextEx will call this function for supporting Multilingual    //
//          DrawTextEx handling.                                            //
// LpkDrawTextEx(HDC hdc, int xLeft, int yTop,LPCWSTR pwcInChars, int cchCount//
//                  , BOOL fDraw, WORD wFormat, LPDRAWTEXTDATA lpDrawInfo,  //
//                  UNIT bAction)                                           //
// hDC              :   Handle of device context                            //
// xLeft            :   x-coordinate of text to render                      //
// yTop             :   y-coordinate of text to render                      //
// lpchStr          :   Input string                                        //
// cchCount         :   Count of characters in input string                 //
// fDraw            :   Draw the Text or expand tha tabs only               //
// wFormat          :   Same as dwDTFormat options for DrawTextEx           //
// lpDrawInfo       :   Internal Structure                                  //
// bAction          :   DT_CHARSETDRAW OR DT_GETNEXTWORD                    //
//                                                                          //
// Return       : Nothing                                                   //
//                                                                          //
// History :                                                                //
//   Nov 15, 1996 -by- Mohamed AbdEl Hamid [mhamid]                         //
//   Mar 26, 1997 Adding DT_GETNEXTWORD  -[wchao]                           //
//////////////////////////////////////////////////////////////////////////////


/////   LpkCharsetDraw
//
//      Called from LPK_USRC.C
//
//      Note: Doesn't implement user defined tabstops

int LpkCharsetDraw(
    HDC             hdc,
    int             xLeft,
    int             cxOverhang,
    int             iTabOrigin,
    int             iTabLength,
    int             yTop,
    PCWSTR          pcwString,
    int             cchCount,
    BOOL            fDraw,
    DWORD           dwFormat,
    int             iCharset) {


    HRESULT           hr;
    int               iTextAlign;
    int               iWidth;
    STRING_ANALYSIS  *psa;
    SCRIPT_TABDEF     std;
    DWORD             dwObjType;


    if (cchCount <= 0) {
        return 0;   // That was easy!
    }


    if (dwFormat & DT_EXPANDTABS) {

        std.cTabStops  = 1;
        std.pTabStops  = &iTabLength;
        std.iTabOrigin = 0;
        std.iScale     = 4;        // Tab stops in pixels (avg ch width already applied in USER)
    }

    dwObjType = GetObjectType(hdc);


    hr = LpkStringAnalyse(
        hdc, pcwString, cchCount, 0, -1,
          SSA_GLYPHS
        |    (dwFormat & DT_NOPREFIX ? 0
           : (dwFormat & DT_HIDEPREFIX ? SSA_HIDEHOTKEY
           : (dwFormat & DT_PREFIXONLY ? SSA_HOTKEYONLY : SSA_HOTKEY)))
        | (dwFormat & DT_EXPANDTABS                               ? SSA_TAB      : 0)
        | (dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_METAFILE : 0)
        | (iCharset==-1 || GdiIsPlayMetafileDC(hdc) ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
        | (    dwFormat & DT_RTLREADING
           ||  (((iTextAlign = GetTextAlign(hdc)) & TA_RTLREADING) && (iTextAlign != -1))
           ?   SSA_RTL : 0),
        -1, 0,
        NULL, NULL, NULL,
        dwFormat & DT_EXPANDTABS ? &std : NULL,
        NULL,
        &psa);

    if (SUCCEEDED(hr)) {

        iWidth = psa->size.cx;

        if (fDraw && (!(dwFormat & DT_CALCRECT))) {
            ScriptStringOut(psa, xLeft, yTop, 0, NULL, 0, 0, FALSE);
        }

        ScriptStringFree((void**)&psa);

    } else {

        iWidth = 0;
        ASSERTHR(hr, ("LpkCharsetDraw - LpkStringAnalyse"));
        psa = NULL;
    }

    return iWidth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\makefile.inc ===
###     Include developer makefile
#
#       The following file causes a perl script to build lpk.h
#       on developer machines enlisted in the Uniscribe SLM
#       tree (\\letterbox\slm) only. On the NT SLM tree, lpk.h
#       is always checked in and makefile.dev is a dummy.


!include makefile.dev
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\cslpk\lpk\sources.inc ===
MAJORCOMP=windows
MINORCOMP=LPK

TARGETNAME=lpk
TARGETTYPE=DYNLINK

!include sources.dev

DLLENTRY=LpkDllInitialize

TARGETPATH=$(_OBJ_DIR)
TARGETPATHLIB=$(_OBJ_DIR)


TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(WINDOWS_LIB_PATH)\gdi32p.lib   \
           $(WINDOWS_LIB_PATH)\user32p.lib  \
           $(SDK_LIB_PATH)\kernl32p.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\ntdll.lib    \
           $(SDK_LIB_PATH)\usp10.lib    \
           $(WINDOWS_LIB_PATH)\usp10p.lib


!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

#####
##    LPK-Profiling thru ICAP.DLL
!ifdef PROFILE_CSLPK
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\icap.lib
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Gh
!endif

!if ! $(FREEBUILD)
# Disable optimizations to help debugging, but do generate intrinsic functions
MSC_OPTIMIZATION = /Od /Oi
!  endif


INCLUDES=..;                                        \
         ..\..\inc;                                 \
         $(NTUSER_PATH)\client;                     \
         $(NTUSER_PATH)\inc;                        \
         $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);    \
         $(WINCORE_PATH)\w32inc;                    \
         $(WINCORE_PATH)\w32inc\$(O);               \
         $(BASE_INC_PATH);                          \
         $(NTGDI_PATH)\inc;                         \
         $(WINDOWS_INC_PATH);


USE_NTDLL=1
NT_UP=0

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -DUNICODE -DUSE_MIRRORING -DLANGPACK

DLLDEF=..\lpk.def

SOURCES= ..\lpk.rc           \
         ..\lpk_usrc.c       \
         ..\lpk_edit.c       \
         ..\lpk_glob.c       \
         ..\lpk_init.cxx     \
         ..\lpk_gdi.cxx      \
         ..\lpk_user.cxx     \
         ..\lpk_nls.cxx      \
         ..\lpk_usp.cxx      \


LINKER_FLAGS = $(LINKER_FLAGS) -mapinfo:exports -verbose:lib
NTDBGFILES=1
USE_MAPSYM=1

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\d3d.cxx ===
/******************************Module*Header*******************************\
* Module Name: d3d.cxx
*
* Contains all of GDI's private Direct3D APIs.
*
* Created: 04-Jun-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Minimum size of DrawPrimitive buffer associated with a context.
#define MIN_PRIM_BUFFER_SIZE (1 << 14)
// Maximum
#define MAX_PRIM_BUFFER_SIZE (1 << 20)
// Default
#define DEF_PRIM_BUFFER_SIZE (1 << 16)

// Alignment requirement for the DrawPrim buffer.  Must be a power of two.
#define DP_BUFFER_ALIGN 32

// Maximum number of vertices considered legal.
#define MAX_VERTEX_COUNT 0x10000

// Maximum number of indices considered legal.
#define MAX_INDEX_COUNT 0x80000

// Maximum number of clear rectangles considered legal.
#define MAX_CLEAR_RECTS 0x1000

// Maximum number of state changes per RenderState call
#define MAX_STATE_CHANGE (D3DRENDERSTATE_STIPPLEPATTERN31+1)

#ifdef D3D_ENTRIES
#define D3D_ENTRY(s) WARNING(s)
#else
#define D3D_ENTRY(s)
#endif

// Simple structure for managing DD surfaces
struct D3D_SURFACE
{
    HANDLE            h;
    BOOL              bOptional;
    EDD_SURFACE*      peSurf;
    PDD_SURFACE_LOCAL pLcl;
};

#define INIT_D3DSURFACE(SurfaceArray, Count) \
    for (int i = 0 ; i < (Count) ; i++) { \
        (SurfaceArray)[i].peSurf = NULL; \
    }

#define CLEANUP_D3DSURFACE(SurfaceArray, Count) \
    for (int i = 0 ; i < (Count) ; i++) { \
        if ((SurfaceArray)[i].peSurf) { \
            DEC_EXCLUSIVE_REF_CNT((SurfaceArray)[i].peSurf); \
        } \
    }

// Convenience macro for parameter validation.  ProbeForWrite does
// all the checks that ProbeForRead does in addition to write testing
// so it serves as a read/write check.
// Assumes DWORD alignment.

#define CAPTURE_RW_STRUCT(ptr, type) \
    (ProbeForWrite(ptr, sizeof(type), sizeof(DWORD)), *(ptr))
#define CAPTURE_RD_STRUCT(ptr, type) \
    (ProbeForRead(ptr, sizeof(type), sizeof(DWORD)), *(ptr))

/******************************Public*Routine******************************\
*
* D3dLockSurfaces
*
* Walks the array of surfaces, locking any with non-zero handles
*
* 1. This routine must be called with the HmgrSemaphore acquired.
* 2. INIT_D3DSURFACE must be called for pSurf parameter.
*
* History:
*  Fri Jun 14 14:26:06 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL D3dLockSurfaces(int n, D3D_SURFACE *pSurf)
{
    while (n-- > 0)
    {
        if (pSurf->h != NULL)
        {
            pSurf->peSurf = (EDD_SURFACE *)DdHmgLock((HDD_OBJ)pSurf->h, DD_SURFACE_TYPE, TRUE);

            if (pSurf->peSurf == NULL)
            {
                WARNING("D3dLockSurfaces unable to lock buffer");
                return FALSE;
            }
            if (pSurf->peSurf->bLost)
            {   
                WARNING("D3dLockSurfaces unable to lock buffer Surface is Lost");
                return FALSE;
            }

            pSurf->pLcl = pSurf->peSurf;
        }
        else if (!pSurf->bOptional)
        {
            WARNING("D3dLockSurfaces: NULL for mandatory surface");
            return FALSE;
        }
        else
        {
            pSurf->pLcl = NULL;
        }

        pSurf++;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* D3dSetup
*
* Prepares the system for a call to a D3D driver
*
* History:
*  Tue Jun 04 17:09:23 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL D3dSetup(EDD_DIRECTDRAW_GLOBAL* peDdGlobal,
              KFLOATING_SAVE* pfsState)
{
    ASSERTGDI(peDdGlobal != NULL,
              "D3dSetup on NULL global\n");

    if (!NT_SUCCESS(KeSaveFloatingPointState(pfsState)))
    {
        WARNING("D3dSetup: Unable to save FP state\n");
        return FALSE;
    }

    DxEngLockHdev(peDdGlobal->hdev);

    return TRUE;
}

/******************************Public*Routine******************************\
*
* D3dCleanup
*
* Cleans up after a D3D driver calls
*
* History:
*  Tue Jun 04 17:10:21 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void D3dCleanup(EDD_DIRECTDRAW_GLOBAL* peDdGlobal,
                KFLOATING_SAVE* pfsState)
{
    DxEngUnlockHdev(peDdGlobal->hdev);
    KeRestoreFloatingPointState(pfsState);
}

/******************************Public*Routine******************************\
*
* D3dLockContext
*
* Prepares the system for a call to a D3D driver with a driver context
*
* This routine must be called with the HmgrSemaphore acquired
*
* History:
*  Tue Jun 04 17:09:23 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

D3DNTHAL_CONTEXT *D3dLockContext(KFLOATING_SAVE *pfsState,
                                  ULONG_PTR *pdwhContext)
{
    D3DNTHAL_CONTEXT *pdhctx;

    pdhctx = (D3DNTHAL_CONTEXT *)DdHmgLock((HDD_OBJ)*pdwhContext, D3D_HANDLE_TYPE, TRUE);

    // release handle manager lock.

    DdHmgReleaseHmgrSemaphore();

    if (pdhctx == NULL)
    {
        WARNING("D3dLockContext unable to lock context");
        return NULL;
    }

    // Before we access inside D3DCONTEXT.peDdGlobal, hold shared devlock,
    // since peDdGlobal can be changed during video mode change.

    DxEngLockShareSem();

    if (pdhctx->dwType != DNHO_CONTEXT)
    {
        WARNING("D3dLockContext: Valid handle not a context");
        goto Error_LockContext;
    }

    if (pdhctx->peDdGlobal == NULL)
    {
        WARNING("D3dLockContext: Call on disabled object");
        goto Error_LockContext;
    }
    
    ASSERTGDI(pdhctx->peDdGlobal->Miscellaneous2CallBacks.CreateSurfaceEx,
              "D3dLockContext: No CreateSurfaceEx callback");

    if (D3dSetup(pdhctx->peDdGlobal, pfsState))
    {
        *pdwhContext = pdhctx->dwDriver;
        // keep holding share lock, will be released at D3dUnlockContext. 
        return pdhctx;
    }

Error_LockContext:

    DEC_EXCLUSIVE_REF_CNT(pdhctx);
    DxEngUnlockShareSem();
    return NULL;
}

/******************************Public*Routine******************************\
*
* D3dUnlockContext
*
* Cleans up after a D3D driver calls with D3D context
*
* History:
*  Tue Apr 10 16:15:00 2001 -by-    Hideyuki Nagase [hideyukn]
*   Created
*
\**************************************************************************/

VOID D3dUnlockContext(D3DNTHAL_CONTEXT *pdhctx, KFLOATING_SAVE *pfsState)
{
    //
    // Release devlock, and restore floating point state.
    //
    D3dCleanup(pdhctx->peDdGlobal, pfsState);

    //
    // Release share devlock.
    //
    DxEngUnlockShareSem();

    //
    // Unlock context
    //
    DEC_EXCLUSIVE_REF_CNT(pdhctx);
}

/******************************Public*Routine******************************\
*
* D3dDeleteHandle
*
* Cleans up D3D driver context wrapper objects
*
* History:
*  Tue Jun 11 17:42:25 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD D3dDeleteHandle(HANDLE hD3dHandle, ULONG_PTR dwContext,
                      BOOL *pbRemoved, HRESULT *phr)
{
    D3DNTHAL_OBJECT  *pdhobj;
    D3DNTHAL_CONTEXT *pdhctx;
    D3DNTHAL_CONTEXTDESTROYDATA dcdd;
    D3DNTHAL_TEXTUREDESTROYDATA dtdd;
    KFLOATING_SAVE fsState;
    DWORD dwRet = DDHAL_DRIVER_HANDLED;

    // Lock handle first.

    pdhobj = (D3DNTHAL_OBJECT *) DdHmgLock((HDD_OBJ)hD3dHandle, D3D_HANDLE_TYPE, FALSE);

    if (pdhobj == NULL)
    {
        if (pbRemoved != NULL)
        {
            *pbRemoved = FALSE;
        }

        *phr = DDERR_INVALIDOBJECT;
        return (dwRet);
    }

    // Before we access inside D3DCONTEXT.peDdGlobal, hold shared devlock,
    // since peDdGlobal can be changed during video mode change.

    DxEngLockShareSem();

    // Sundowndx: Needs to pass in cjBuffer as SIZE_T inorder to compiler in 64bit

    SIZE_T cjBuffer = 0;

    if (!D3dSetup(pdhobj->peDdGlobal, &fsState))
    {
        DxEngUnlockShareSem();
        DEC_EXCLUSIVE_REF_CNT(pdhobj);
        *phr = DDERR_OUTOFMEMORY;
        return (dwRet);
    }

    switch(pdhobj->dwType)
    {
    case DNHO_CONTEXT:

        // Clean up DrawPrimitive buffer.

        pdhctx = (D3DNTHAL_CONTEXT *)pdhobj;
        MmUnsecureVirtualMemory(pdhctx->hBufSecure);
        ZwFreeVirtualMemory(NtCurrentProcess(), &pdhctx->pvBufferAlloc,
                            &cjBuffer, MEM_RELEASE);

        // Sundowndx: need to look at the d3d structure, truncate it for now

        pdhctx->cjBuffer = (ULONG)cjBuffer;

        // Call driver.

        dcdd.dwhContext = pdhobj->dwDriver;
        dwRet = pdhobj->peDdGlobal->D3dCallBacks.ContextDestroy(&dcdd);
        *phr = dcdd.ddrval;
        break;

    case DNHO_TEXTURE:

        dtdd.dwhContext = dwContext;
        dtdd.dwHandle = pdhobj->dwDriver;
        dwRet = pdhobj->peDdGlobal->D3dCallBacks.TextureDestroy(&dtdd);
        *phr = dtdd.ddrval;
        break;
    }

    // Now Remove handle from handle manager.

    PVOID pv = DdHmgRemoveObject((HDD_OBJ)hD3dHandle, 1, 0, TRUE, D3D_HANDLE_TYPE);

    // This shouldn't fail, because above DdHmgLock is succeeded.

    ASSERTGDI(pv,"DdHmgRemoveObject failed D3dDeleteHandle");

    // Release devlock and restore floating point state.

    D3dCleanup(pdhobj->peDdGlobal, &fsState);

    // Release share lock

    DxEngUnlockShareSem();

    // If this is last reference to DdGlobal (= GDI's PDEV), this
    // will release it, so we can't call it while devlock is hold (which
    // means between D3dSetup ~ D3dCleanup).

    vDdDecrementReferenceCount(pdhobj->peDdGlobal);

    // Delete the object.

    DdFreeObject(pdhobj, D3D_HANDLE_TYPE);

    if (pbRemoved != NULL)
    {
        *pbRemoved = TRUE;
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* D3D_SIMPLE_COPY_WITH_CONTEXT
*
* Macro which creates a thunk function for D3D entry points which
* have only simple copy arguments in, a context to dereference and
* only a simple copy out.
*
* D3D_SIMPLE_DECL can be defined to add declarations.
* By default it's empty.
* D3D_SIMPLE_SETUP can be defined to add more setup code.
* By default it's empty.
* D3D_SIMPLE_WRITEBACK can be defined to add more writeback code.
* By default it's empty.
* D3D_SIMPLE_CALLBACKS is defined to the callbacks structure to look in.
* By default it's D3dCallBacks.
*
* History:
*  Fri Jun 14 14:12:54 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define D3D_SIMPLE_DECL
#define D3D_SIMPLE_SETUP
#define D3D_SIMPLE_WRITEBACK
#define D3D_SIMPLE_CALLBACKS D3dCallBacks

#define D3D_SIMPLE_COPY_WITH_CONTEXT(Name, Type)                           \
DWORD APIENTRY                                                             \
DxD3d##Name(LPD3DNTHAL_##Type##DATA pdata)                                 \
{                                                                          \
    D3DNTHAL_##Type##DATA data;                                            \
    KFLOATING_SAVE fsState;                                                \
    DWORD dwRet;                                                           \
    D3DNTHAL_CONTEXT* pdhctx;                                              \
    D3D_SIMPLE_DECL                                                        \
                                                                           \
    D3D_ENTRY("DxD3d" #Name);                                              \
                                                                           \
    dwRet = DDHAL_DRIVER_NOTHANDLED;                                       \
                                                                           \
    __try                                                                  \
    {                                                                      \
        data = CAPTURE_RW_STRUCT(pdata, D3DNTHAL_##Type##DATA);            \
    }                                                                      \
    __except(EXCEPTION_EXECUTE_HANDLER)                                    \
    {                                                                      \
        WARNING("DxD3d" #Name " unable to access argument");               \
        return dwRet;                                                      \
    }                                                                      \
                                                                           \
    DdHmgAcquireHmgrSemaphore(); /* will be released inside D3dLockContext */ \
                                                                           \
    pdhctx = D3dLockContext(&fsState, &data.dwhContext);                   \
    if (pdhctx == NULL)                                                    \
    {                                                                      \
        return dwRet;                                                      \
    }                                                                      \
                                                                           \
    D3D_SIMPLE_SETUP                                                       \
                                                                           \
    if (pdhctx->peDdGlobal->bSuspended)                                    \
    {                                                                      \
        data.ddrval = DDERR_SURFACELOST;                                   \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        if (pdhctx->peDdGlobal->D3D_SIMPLE_CALLBACKS.##Name)               \
        {                                                                  \
            dwRet = pdhctx->peDdGlobal->D3D_SIMPLE_CALLBACKS.##Name(&data);\
        }                                                                  \
        else                                                               \
        {                                                                  \
            WARNING("DxD3d" #Name " call not present!");                   \
        }                                                                  \
    }                                                                      \
                                                                           \
    D3dUnlockContext(pdhctx, &fsState);                                    \
                                                                           \
    __try                                                                  \
    {                                                                      \
        pdata->ddrval = data.ddrval;                                       \
        D3D_SIMPLE_WRITEBACK                                               \
    }                                                                      \
    __except(EXCEPTION_EXECUTE_HANDLER)                                    \
    {                                                                      \
        WARNING("DxD3d" #Name " unable to write back arguments");          \
    }                                                                      \
                                                                           \
    return dwRet;                                                          \
}

/******************************Public*Routine******************************\
*
* D3D_DELETE_HANDLE
*
* Macro for routines which destroy a handle-managed object.
*
* History:
*  Wed Oct 23 19:32:11 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define D3D_DELETE_HANDLE(Name, Type, Field)                               \
DWORD APIENTRY                                                             \
DxD3d##Name##Destroy(LPD3DNTHAL_##Type##DESTROYDATA pdata)                 \
{                                                                          \
    DWORD dwRet;                                                           \
    HANDLE hD3dHandle;                                                     \
    HRESULT hr;                                                            \
                                                                           \
    D3D_ENTRY("DxD3d" #Name "Destroy");                                    \
                                                                           \
    __try                                                                  \
    {                                                                      \
        ProbeForWrite(pdata, sizeof(D3DNTHAL_##Type##DESTROYDATA),         \
                      sizeof(DWORD));                                      \
        hD3dHandle = (HANDLE)pdata->Field;                                 \
    }                                                                      \
    __except(EXCEPTION_EXECUTE_HANDLER)                                    \
    {                                                                      \
        WARNING("DxD3d" #Name "Destroy unable to access argument");        \
        return DDHAL_DRIVER_NOTHANDLED;                                    \
    }                                                                      \
                                                                           \
    dwRet = D3dDeleteHandle(hD3dHandle, 0, (BOOL *)NULL, &hr);             \
                                                                           \
    __try                                                                  \
    {                                                                      \
        pdata->ddrval = hr;                                                \
    }                                                                      \
    __except(EXCEPTION_EXECUTE_HANDLER)                                    \
    {                                                                      \
        WARNING("DxD3d" #Name "Destroy unable to write back arguments");   \
    }                                                                      \
                                                                           \
    return dwRet;                                                          \
}

/******************************Public*Routine******************************\
*
* DxD3dContextCreate
*
* History:
*  Tue Jun 04 13:05:18 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY
DxD3dContextCreate(HANDLE hDirectDrawLocal,
                      HANDLE hSurfColor,
                      HANDLE hSurfZ,
                      D3DNTHAL_CONTEXTCREATEI *pdcci)
{
    LPD3DNTHAL_CONTEXTCREATEDATA pdccd;
    D3DNTHAL_CONTEXTCREATEDATA dccd;
    KFLOATING_SAVE fsState;
    DWORD dwRet;
    HANDLE hCleanup = 0;
    EDD_DIRECTDRAW_LOCAL* peDdLocal;
    EDD_LOCK_DIRECTDRAW eLockDd;
    EDD_DIRECTDRAW_GLOBAL* peDdGlobal;
    D3D_SURFACE dsurf[2];
    NTSTATUS nts;
    SIZE_T cjBuffer;

    D3DNTHAL_CONTEXT* pdhctx = NULL;
    PVOID pvBuffer = NULL;
    PVOID pvBufRet = NULL;
    HANDLE hBufSecure = NULL;
    ULONG_PTR Interface;

    D3D_ENTRY("DxD3dContextCreate");

    ASSERTGDI(FIELD_OFFSET(D3DNTHAL_CONTEXTCREATEI, pvBuffer) ==
              sizeof(D3DNTHAL_CONTEXTCREATEDATA),
              "D3DNTHAL_CONTEXTCREATEI out of sync\n");
    pdccd = (LPD3DNTHAL_CONTEXTCREATEDATA)pdcci;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    __try
    {
        ProbeForWrite(pdcci, sizeof(D3DNTHAL_CONTEXTCREATEI), sizeof(DWORD));
        dccd.dwPID = pdccd->dwPID;
        dccd.dwhContext = pdccd->dwhContext;
        dccd.ddrval = pdccd->ddrval;
        cjBuffer = pdcci->cjBuffer;
        Interface = pdccd->dwhContext;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dContextCreate unable to access argument");
        return dwRet;
    }

    if (cjBuffer == 0)
    {
        cjBuffer = DEF_PRIM_BUFFER_SIZE;
    }
    else if (cjBuffer < MIN_PRIM_BUFFER_SIZE ||
             cjBuffer > MAX_PRIM_BUFFER_SIZE)
    {
        WARNING("DxD3dContextCreate: illegal prim buffer size");
        return dwRet;
    }

    peDdLocal = eLockDd.peLock(hDirectDrawLocal);

    if (peDdLocal == NULL)
    {
        WARNING("DxD3dContextCreate unable to lock hDdLocal");
        return dwRet;
    }

    peDdGlobal = peDdLocal->peDirectDrawGlobal;

    INIT_D3DSURFACE(dsurf, 2);

    dsurf[0].h = hSurfColor;
    dsurf[0].bOptional = FALSE;
    dsurf[1].h = hSurfZ;
    dsurf[1].bOptional = TRUE;

    DdHmgAcquireHmgrSemaphore();

    if (!D3dLockSurfaces(2, dsurf))
    {
        DdHmgReleaseHmgrSemaphore();
        goto Exit_CreateContext;
    }

    DdHmgReleaseHmgrSemaphore();

    pdhctx = (D3DNTHAL_CONTEXT *)DdHmgAlloc(sizeof(D3DNTHAL_CONTEXT),
                                          D3D_HANDLE_TYPE, HMGR_ALLOC_LOCK);
    if (pdhctx == NULL)
    {
        WARNING("DxD3dContextCreate unable to alloc handle");
        goto Exit_CreateContext;
    }

    hCleanup = pdhctx->hHmgr;

    // Allocate and lock DrawPrimitive buffer space.  We want the
    // buffer to be aligned on a large boundary so we alter the
    // pointer to return to be aligned.  Note that we do not overallocate
    // since we don't want the extra alignment space to push the allocation
    // into another page.  We're returning a size anyway so we can
    // get away with this transparently.

    nts = ZwAllocateVirtualMemory(NtCurrentProcess(), &pvBuffer,
                                  0, &cjBuffer, MEM_COMMIT | MEM_RESERVE,
                                  PAGE_READWRITE);

    if (!NT_SUCCESS(nts))
    {
        goto Exit_CreateContext;
    }

    hBufSecure = MmSecureVirtualMemory(pvBuffer, cjBuffer, PAGE_READWRITE);

    if (hBufSecure == NULL)
    {
        goto Exit_CreateContext;
    }

    if (!D3dSetup(peDdGlobal, &fsState))
    {
        goto Exit_CreateContext;
    }

    // CreateSurfaceEx callback must exist for DX7 or greater drivers

    if (!peDdGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
    {
        D3dCleanup(peDdGlobal, &fsState);
        goto Exit_CreateContext;
    }

    dccd.lpDDLcl = peDdLocal;
    dccd.lpDDS = dsurf[0].pLcl;
    dccd.lpDDSZ = dsurf[1].pLcl;

    if (peDdGlobal->D3dCallBacks.ContextCreate)
    {
        dwRet = peDdGlobal->D3dCallBacks.ContextCreate(&dccd);
    }
    else
    {
        WARNING("DxD3dContextCreate: ContextCreate callback not found");
    }
    
    if (dwRet == DDHAL_DRIVER_HANDLED &&
        dccd.ddrval == DD_OK)
    {
        // Create a wrapper for the handle and stash the DD global in it
        pdhctx->dwType = DNHO_CONTEXT;
        pdhctx->dwDriver = dccd.dwhContext;
        pdhctx->peDdGlobal = peDdGlobal;
        pdhctx->peDdLocal  = peDdLocal;
        pdhctx->hSurfColor = hSurfColor;
        pdhctx->hSurfZ = hSurfZ;
        pdhctx->hBufSecure = hBufSecure;

        // Save the real pointer for freeing and return an aligned pointer
        // rather than the raw pointer.
        pdhctx->pvBufferAlloc = pvBuffer;
        pvBufRet = (PVOID)(((ULONG_PTR)pvBuffer+DP_BUFFER_ALIGN-1) &
                           ~(DP_BUFFER_ALIGN-1));
        pdhctx->pvBufferAligned = pvBufRet;
        pdhctx->cjBuffer = (ULONG)cjBuffer;
        // Subtract off any space used for alignment.
        cjBuffer -= (DWORD)((ULONG_PTR)pvBufRet-(ULONG_PTR)pvBuffer);

        // Save interface number
        pdhctx->Interface = Interface;

        // Null these values to deactivate cleanup code.
        hBufSecure = NULL;
        pvBuffer = NULL;
        hCleanup = NULL;

        dccd.dwhContext = (ULONG_PTR)pdhctx->hHmgr;

        /* Add reference to DirectDraw driver instance so that it won't
           go away during dynamic mode changes, until the object is
           deleted. */
        vDdIncrementReferenceCount(pdhctx->peDdGlobal);
    }

    // We're done with pdhctx so unlock it
    DEC_EXCLUSIVE_REF_CNT(pdhctx);

    D3dCleanup(peDdGlobal, &fsState);

    __try
    {
        pdccd->dwhContext = dccd.dwhContext;
        pdccd->ddrval = dccd.ddrval;
        pdcci->pvBuffer = pvBufRet;
        pdcci->cjBuffer = (ULONG)cjBuffer;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dContextCreate unable to write back arguments");
        /* This is an unlikely thing to occur so we don't bother cleaning
           up the handle here.  It will be cleaned up by the process
           termination handle cleanup. */
        dwRet = DDHAL_DRIVER_NOTHANDLED;
    }

Exit_CreateContext:

    CLEANUP_D3DSURFACE(dsurf, 2);

    if (hBufSecure != NULL)
    {
        MmUnsecureVirtualMemory(hBufSecure);
    }

    if (pvBuffer != NULL)
    {
        // cjBuffer has to be zero to free memory.
        cjBuffer = 0;
        ZwFreeVirtualMemory(NtCurrentProcess(), &pvBuffer, &cjBuffer,
                            MEM_RELEASE);
    }

    if (hCleanup != NULL)
    {
        DdHmgFree((HDD_OBJ)hCleanup);
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* DxD3dContextDestroy
*
* History:
*  Tue Jun 04 13:08:43 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

D3D_DELETE_HANDLE(Context, CONTEXT, dwhContext)

/******************************Public*Routine******************************\
*
* DxD3dContextDestroyAll
*
* History:
*  Tue Jun 04 13:09:04 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY
DxD3dContextDestroyAll(LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad)
{
    DWORD dwRet;

    D3D_ENTRY("DxD3dContextDestroyAll");

    __try
    {
        ProbeForWrite(pdcdad, sizeof(D3DNTHAL_CONTEXTDESTROYALLDATA),
              sizeof(DWORD));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dContextDestroyAll unable to access argument");
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // Having the context wrappers be handle-based should
    // provide automatic process cleanup of driver contexts
    // If this function does need to be passed to the driver then
    // some way to get the proper DD global will need to be found
    // I don't think it's necessary, though

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    __try
    {
        pdcdad->ddrval = DDERR_GENERIC;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dContextDestroyAll unable to write back arguments");
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* DxD3dDrawPrimitives2
*
* History:
*  Fri Jun 14 11:56:53 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY
DxD3dDrawPrimitives2(HANDLE hCmdBuf, HANDLE hVBuf,
                        LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
                        FLATPTR* pfpVidMemCmd,
                        DWORD* pdwSizeCmd,
                        FLATPTR* pfpVidMemVtx,
                        DWORD* pdwSizeVtx)
{
    D3DNTHAL_DRAWPRIMITIVES2DATA ded;
    KFLOATING_SAVE fsState;
    DWORD dwRet;
    D3D_SURFACE dsurf[4];

    HANDLE            hSecure = NULL;
    D3DNTHAL_CONTEXT* pdhctx = NULL;

    D3D_ENTRY("DxD3dDrawPrimitives2");

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    __try
    {
        //
        // ProbeForRead and ProbeForWrite are fairly expensive.  Moved the write probe
        // to the bottom but we could also do a ProbeForWriteStructure here if the
        // error checking needs to be the exact same semantics.
        //
        ded = ProbeAndReadStructure(pded, D3DNTHAL_DRAWPRIMITIVES2DATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dDrawPrimitives2 unable to access argument");
        return dwRet;
    }

    // Initialize surface array.

    INIT_D3DSURFACE(dsurf, 4);

    DWORD Length = ded.dwVertexLength*ded.dwVertexSize;

    // Validate and secure user-mode memory if it is a user
    // allocated buffer instead of a ddraw surface

    if (ded.dwFlags & D3DNTHALDP2_USERMEMVERTICES)
    {
        // !!Assert here that hVBuf is NULL
        ASSERTGDI(hVBuf == NULL,
                  "User allocated memory, hVBuf should be NULL\n");

        if ((Length > 0) && (ded.lpVertices != NULL))
        {
            LPVOID Address = (LPVOID) ((LPBYTE)ded.lpVertices +
                                          ded.dwVertexOffset);

            // Secure user-mode data.

            __try
            {
                ProbeForRead(Address, Length, sizeof(BYTE));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("DxD3dDrawPrimives2 fail to secure the vertex buffer");
                goto Exit_DP2;
            }

            hSecure = MmSecureVirtualMemory(Address, Length, PAGE_READONLY);
            if (hSecure == NULL)
            {
                goto Exit_DP2;
            }

            dsurf[0].h = hCmdBuf;
            dsurf[0].bOptional = FALSE;

            DdHmgAcquireHmgrSemaphore(); // will be released at D3dLockContext();

            if (!D3dLockSurfaces(1, dsurf))
            {
                DdHmgReleaseHmgrSemaphore();
                goto Exit_DP2;
            }

            ded.lpDDCommands = dsurf[0].pLcl;
        }
        else
        {
            goto Exit_DP2;
        }
    }
    else
    {
        dsurf[0].h = hCmdBuf;
        dsurf[0].bOptional = FALSE;
        dsurf[1].h = hVBuf;
        dsurf[1].bOptional = FALSE;

        DdHmgAcquireHmgrSemaphore(); // will be released at D3dLockContext();

        if (!D3dLockSurfaces(2, dsurf))
        {
            DdHmgReleaseHmgrSemaphore();
            goto Exit_DP2;
        }

        ded.lpDDCommands = dsurf[0].pLcl;
        ded.lpDDVertex = dsurf[1].pLcl;

        // Make sure given buffer size is smaller than the actual surface size.

        if (dsurf[1].peSurf && ded.dwVertexSize)
        {
            DWORD dwSurfaceSize = dsurf[1].peSurf->lPitch;

            if (Length > dwSurfaceSize)
            {
                WARNING("DxD3dDrawPrimitive2 d3d.dwVertexLength is bigger than surface, trim it!!");

                ded.dwVertexLength = dwSurfaceSize / ded.dwVertexSize;
            }
        }
    }

    pdhctx = D3dLockContext(&fsState, &ded.dwhContext);
    if (pdhctx == NULL)
    {
        goto Exit_DP2;
    }

    // Validate that the lpdwRStates pointer is the same as the one allocated
    // by the kernel during context create. The D3d runtime uses this pointer
    // to receive state information from the driver.

    if (ded.lpdwRStates != pdhctx->pvBufferAligned)
    {
        goto Exit_DP2;
    }

    if ((pdhctx->peDdGlobal->bSuspended) ||
        ((pdhctx->peDdLocal->cSurface != pdhctx->peDdLocal->cActiveSurface) &&
        // We wish we could do this for all interfaces, but due to legacy app compat reasons, we can't.
        // We have noticed that apps such as Dungeon Keeper II and Final Fantasy lose surfaces and
        // never bother to restore them.
         pdhctx->Interface >= 4))
    {
#if DBG
        if (pdhctx->peDdGlobal->bSuspended)
        {
            // WARNING("D3dDrawPrimitives2" Caller uses disabled device");
        }
        else if ((pdhctx->peDdLocal->cSurface != pdhctx->peDdLocal->cActiveSurface)) 
        {
            WARNING("D3dDrawPrimitives2: Cannot call driver when lost surfaces exist in the context");
        }
#endif
        dwRet = DDHAL_DRIVER_HANDLED;
        ded.ddrval = DDERR_SURFACELOST;
    }
    else
    {
        if (pdhctx->peDdGlobal->D3dCallBacks3.DrawPrimitives2)
        {
            dwRet = pdhctx->peDdGlobal->D3dCallBacks3.DrawPrimitives2(&ded);
        }
        else
        {
            WARNING("DxD3dDrawPrimitives2: DrawPrimitives2 callback absent!");
        }
    }

    __try
    {
        if ((dwRet == DDHAL_DRIVER_HANDLED) && (ded.ddrval == DD_OK))
        {
            if (ded.dwFlags & D3DNTHALDP2_SWAPCOMMANDBUFFER)
            {
                ProbeAndWriteStructure( pfpVidMemCmd, ded.lpDDCommands->lpGbl->fpVidMem, FLATPTR); 
                ProbeAndWriteStructure( pdwSizeCmd, ded.lpDDCommands->lpGbl->dwLinearSize, DWORD);  
            }
            if ((ded.dwFlags & D3DNTHALDP2_SWAPVERTEXBUFFER) && 
                !(ded.dwFlags & D3DNTHALDP2_USERMEMVERTICES))
            {
                ProbeAndWriteStructure( pfpVidMemVtx, ded.lpDDVertex->lpGbl->fpVidMem, FLATPTR); 
                ProbeAndWriteStructure( pdwSizeVtx, ded.lpDDVertex->lpGbl->dwLinearSize, DWORD);  
            }
        }

        ProbeAndWriteUlong(&pded->dwErrorOffset, ded.dwErrorOffset);

        //
        // Should be cleaned up as HRESULT might not allways be a ULONG
        //
        ProbeAndWriteLong(&pded->ddrval, ded.ddrval);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dDrawPrimitives2 unable to write back arguments");
        dwRet = DDHAL_DRIVER_NOTHANDLED;
    }

Exit_DP2:

    if (pdhctx)
    {
        D3dUnlockContext(pdhctx, &fsState);
    }

    CLEANUP_D3DSURFACE(dsurf, 4);

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* DxD3dValidateTextureStageState
*
\**************************************************************************/

#undef  D3D_SIMPLE_WRITEBACK
#define D3D_SIMPLE_WRITEBACK pdata->dwNumPasses = data.dwNumPasses;
#undef  D3D_SIMPLE_CALLBACKS
#define D3D_SIMPLE_CALLBACKS D3dCallBacks3
D3D_SIMPLE_COPY_WITH_CONTEXT(ValidateTextureStageState, VALIDATETEXTURESTAGESTATE)
#undef  D3D_SIMPLE_WRITEBACK
#define D3D_SIMPLE_WRITEBACK
#undef  D3D_SIMPLE_CALLBACKS
#define D3D_SIMPLE_CALLBACKS D3dCallBacks

/******************************Public*Routine******************************\
*
* D3DParseUnknownCommand
*
\**************************************************************************/

HRESULT CALLBACK D3DParseUnknownCommand (LPVOID lpvCommands,
                              LPVOID *lplpvReturnedCommand)
{
    LPD3DINSTRUCTION lpInstr = (LPD3DINSTRUCTION) lpvCommands;
    LPD3DPROCESSVERTICES data;
    int i;

    // Initialize the return address to the command's address
    *lplpvReturnedCommand = lpvCommands;

    switch (lpInstr->bOpcode)
    {
    case D3DOP_SPAN:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof (D3DINSTRUCTION) +
                                          lpInstr->wCount *
                                          lpInstr->bSize);                   
        return DD_OK;
    case D3DNTDP2OP_VIEWPORTINFO:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof(D3DINSTRUCTION) +
                                          lpInstr->wCount *
                                          sizeof(D3DNTHAL_DP2VIEWPORTINFO));
        return DD_OK;
    case D3DNTDP2OP_WINFO:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof(D3DINSTRUCTION) +
                                          lpInstr->wCount *
                                          sizeof(D3DNTHAL_DP2WINFO));
        return DD_OK;
    case D3DOP_PROCESSVERTICES:
    case D3DOP_MATRIXLOAD:
    case D3DOP_MATRIXMULTIPLY:
    case D3DOP_STATETRANSFORM:
    case D3DOP_STATELIGHT:
    case D3DOP_TEXTURELOAD:
    case D3DOP_BRANCHFORWARD:
    case D3DOP_SETSTATUS:
    case D3DOP_EXIT:
        return D3DNTERR_COMMAND_UNPARSED;
    default:
        return DDERR_GENERIC;
    }
}

/******************************Public*Routine******************************\
*
* DxDdGetDriverState
*
\**************************************************************************/

DWORD APIENTRY
DxDdGetDriverState(PDD_GETDRIVERSTATEDATA pdata)
{
    DD_GETDRIVERSTATEDATA data;
    KFLOATING_SAVE fsState;
    DWORD dwRet;
    D3DNTHAL_CONTEXT* pdhctx;
    HANDLE hSecure;

    D3D_ENTRY("DxDdGetDriverState");

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    __try
    {
        data = CAPTURE_RW_STRUCT(pdata, DD_GETDRIVERSTATEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxDdGetDriverState unable to access argument");
        return dwRet;
    }

    if (data.lpdwStates == NULL)
    {
        WARNING("DxDdGetDriverState passed null lpdwStates");
        return dwRet;
    }

    // Secure the usermode memory passed down to collect state data
    hSecure = MmSecureVirtualMemory((LPVOID)data.lpdwStates, data.dwLength, 
                                    PAGE_READONLY);
    if (hSecure == 0)
    {
        return dwRet;
    }
    
    DdHmgAcquireHmgrSemaphore(); // will be released inside D3dLockContext()

    pdhctx = D3dLockContext(&fsState, &data.dwhContext);
    if (pdhctx == NULL)
    {
        goto Exit_GDS;
    }

    // No additional validation is needed
    // Assuming that GetDriverState exists in all DX7+ drivers

    ASSERTGDI(pdhctx->peDdGlobal->Miscellaneous2CallBacks.GetDriverState != NULL,
              "DxDdGetDriverState is not present. It is not an optional callback\n");

    if (pdhctx->peDdGlobal->bSuspended)
    {
        data.ddRVal = DDERR_GENERIC;
    }
    else
    {
        if (pdhctx->peDdGlobal->Miscellaneous2CallBacks.GetDriverState)
        {
            dwRet = pdhctx->peDdGlobal->Miscellaneous2CallBacks.GetDriverState(&data);
        }
        else
        {
            WARNING("DxD3dDrawPrimitives2: GetDriverState callback absent!");
        }
    }
    
    D3dUnlockContext(pdhctx, &fsState);

    __try
    {
        pdata->ddRVal = data.ddRVal;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxDdGetDriverState unable to write back arguments");
    }

Exit_GDS:

    MmUnsecureVirtualMemory(hSecure);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddagp.cxx ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "precomp.hxx"

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

#define PAGE_COUNT(Bytes) (((Bytes) + (PAGE_SIZE - 1)) / PAGE_SIZE)
#define PAGE_ROUND(Bytes) (((Bytes) + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1))

//
// AGP memory policy parameters.
//

// Maximum amount of AGP memory to use.  Currently 32MB.
// Recomputed when the DirectDraw interface is created.
DWORD dwAGPPolicyMaxBytes = 32 * 1024 * 1024;

// Amount of memory to commit when a commit is needed.
// Reset when the DirectDraw interface is created.
DWORD dwAGPPolicyCommitDelta = DEFAULT_AGP_COMMIT_DELTA;


DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  PVOID *ppvReservation )
{
    DWORD dwNumPages;
    
    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != pfpLinStart );
    DDASSERT( NULL                 != pliDevStart );
    DDASSERT( NULL                 != ppvReservation );

    /*
     * The first thing to do is make sure our AGP policy is respected.
     * The easy way to do that is to limit how much we reserve...
     */
    dwSize = min(dwSize, dwAGPPolicyMaxBytes);

    /*
     * DDraw will attempt to reserve space for the heap, but if that fails,
     * we'll ratchet down the reservation by 4 megs at a time until it works.
     * This is a defensive move that should prevent a few problems for AGP
     * aware drivers on memphis: they cannot know how large an aperture to
     * claim (cuz of weird OS restraints like the fact that
     * half the ap is reserved for UC and the other half WC etc, plus
     * random BIOS limitations.
     * We arbitrarily decide that 4 megs is the legal minimum.
     */
    while (dwSize >= 0x400000 )
    {
        dwNumPages = PAGE_COUNT(dwSize);
        if ( OsAGPReserve( hdev, dwNumPages, fIsUC, fIsWC,
                           pfpLinStart, pliDevStart, ppvReservation ) )
        {
            return dwSize;
        }

        /*
         * If the driver asked for WC but the processor doesn't support WC,
         * then OsAGPReserve will have failed. The best thing to do is try
         * again with UC...
         * If the aperture size is the problem, then this will still fail
         * and we'll back off and try again WC.
         */
        if (fIsWC)
        {
            if ( OsAGPReserve( hdev, dwNumPages, TRUE, FALSE,
                               pfpLinStart, pliDevStart, ppvReservation ) )
            {
                return dwSize;
            }
        }

        /*
         * Subtract 4 megs and try again
         */
        dwSize -= 0x400000;
    }

    return 0;
} /* AGPReserve */

#define IS_CHUNK_COMMITTED(x,y)  \
            ((x)[(y)/BITS_IN_BYTE] & (1 << ((y) % BITS_IN_BYTE)))

#define MARK_CHUNK_COMMITTED(x,y)  \
            (x)[(y)/BITS_IN_BYTE] |= (1 << ((y) % BITS_IN_BYTE))

/*
 * Initially we implemented this where each page had a bit indicating whether it
 * was committed or not, but we decided to change it so that each bit indicates
 * whether 16 pages are mapped or not for the following reasons:
 *
 * 1. In AGPCommitVirtual, we walk the entire mask everytime we create a
 *    surface.  For performance reasons, we want to keep this mask small.
 * 
 * 2. The miniport always virtually commits everything in 16 page chunks and
 *    physically commits everything in 64 page chunks regardless of what we 
 *    pass to them, so there is no real reason for page granularity.
 */

// x = byte offset
#define CHUNK_INDEX(x)                                  \
    ((x) / (DDLOCAL_AGP_MAPPING_PAGES * PAGE_SIZE))

#define PAGE_FROM_CHUNK(x)                              \
    ((x) * DDLOCAL_AGP_MAPPING_PAGES)

#define NUM_CHUNKS(x)                                   \
    ((PAGE_COUNT(x) + (DDLOCAL_AGP_MAPPING_PAGES - 1)) / DDLOCAL_AGP_MAPPING_PAGES)

// x = start chunk
// y = chunk past the end (not included in the total)
// z = heap size in bytes
#define NUM_PAGES_FROM_CHUNK(x,y,z)                     \
    (((y) == NUM_CHUNKS(z)) ?                      \
        (PAGE_COUNT(z) - PAGE_FROM_CHUNK(x)) :          \
        (((y) - (x)) * DDLOCAL_AGP_MAPPING_PAGES))


BOOL AGPCommit( HANDLE hdev, PVOID pvReservation,
                DWORD dwOffset, DWORD dwSize,
                BYTE* pAgpCommitMask,
                DWORD* pdwCommittedSize,
                DWORD dwHeapSize)
{
    DWORD         dwChunk;
    DWORD         dwLastChunk;
    BOOL          bRet = TRUE;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( NULL                 != pvReservation );
    DDASSERT( 0UL                  != dwSize );

    *pdwCommittedSize = 0;

    if( pAgpCommitMask == NULL )
    {
        return FALSE;
    }

    dwChunk = CHUNK_INDEX(dwOffset);
    dwLastChunk = CHUNK_INDEX(dwOffset + dwSize - 1);

    ASSERTGDI((dwOffset + dwSize <= dwHeapSize), 
        "Attempting to allocate beyond the heap size");

    /*
     * Now walk through all of the 16 page chunks and determine if they are
     * already committed, and if not, commit them.
     */
    while( ( dwChunk <= dwLastChunk ) && bRet )
    {
        if( IS_CHUNK_COMMITTED( pAgpCommitMask,dwChunk ) )
        {
            // Chunk is already committed.
            dwChunk++;
        }
        else
        {
            DWORD   dwEndChunk;

            // The page is not already committed, so figure out how many 
            // non-committed pages we have and we will commit them all at once.
            dwEndChunk = dwChunk + 1;
            while( ( dwEndChunk <= dwLastChunk ) &&
                   !IS_CHUNK_COMMITTED( pAgpCommitMask, dwEndChunk ) )
            {
                dwEndChunk++;
            }

            bRet = OsAGPCommit( hdev, 
                pvReservation,
                PAGE_FROM_CHUNK(dwChunk), 
                NUM_PAGES_FROM_CHUNK(dwChunk, dwEndChunk, dwHeapSize));
            if( bRet )
            {
                // If we succeeded, we need to mark the pages as being committed
                
                *pdwCommittedSize += ((dwEndChunk - dwChunk) * 
                    DDLOCAL_AGP_MAPPING_PAGES * PAGE_SIZE);
                while( dwChunk < dwEndChunk )
                {
                    MARK_CHUNK_COMMITTED( pAgpCommitMask, dwChunk );
                    dwChunk++;
                }
            }
        }
    }

    return bRet;
} /* AGPCommit */


VOID AGPUpdateCommitMask( BYTE* pAgpCommitMask, DWORD dwOffset, DWORD dwSize, DWORD dwHeapSize )
{
    DWORD   dwChunk;
    DWORD   dwLastChunk;

    dwChunk = CHUNK_INDEX(dwOffset);
    dwLastChunk = CHUNK_INDEX(dwOffset + dwSize - 1);

    ASSERTGDI((dwOffset + dwSize <= dwHeapSize), 
        "Attempting to allocate beyond the heap size");

    /*
     * Now set all of the bits indicating that they are committed.
     */
    while( dwChunk <= dwLastChunk ) 
    {
        MARK_CHUNK_COMMITTED( pAgpCommitMask, dwChunk );
        dwChunk++;
    }
}


BOOL AGPDecommitAll( HANDLE hdev, PVOID pvReservation, 
                     BYTE* pAgpCommitMask, DWORD dwAgpCommitMaskSize,
                     DWORD* pdwDecommittedSize,
                     DWORD dwHeapSize)
{
    DWORD   dwNumChunks;
    DWORD   dwChunk;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );

    *pdwDecommittedSize = 0;
 
    /*
     * Walk the mask and decomit all of the previously committed chunks of
     * pages.  Do not decommit them one by one as this is fairly slow.
     */
    dwNumChunks = NUM_CHUNKS(dwHeapSize);
    dwChunk = 0;
    while( dwChunk < dwNumChunks )
    {
        if( !IS_CHUNK_COMMITTED( pAgpCommitMask, dwChunk ) )
        {
            // Page is not committed.
            dwChunk++;
        }
        else
        {
            DWORD   dwEndChunk;

            // We are at the start of a block of committed chunks, so figure
            // out how many chunks are in this block and decommit them all.
            dwEndChunk = dwChunk + 1;
            while( ( dwEndChunk < dwNumChunks ) &&
                   IS_CHUNK_COMMITTED( pAgpCommitMask, dwEndChunk ) )
            {
                dwEndChunk++;
            }

            OsAGPDecommit( hdev, pvReservation,
                PAGE_FROM_CHUNK(dwChunk), 
                NUM_PAGES_FROM_CHUNK(dwChunk, dwEndChunk, dwHeapSize));

            *pdwDecommittedSize += ((dwEndChunk - dwChunk) * 
                    DDLOCAL_AGP_MAPPING_PAGES * PAGE_SIZE);

            dwChunk = dwEndChunk;
        }
    }
    RtlZeroMemory( pAgpCommitMask, dwAgpCommitMaskSize );
    return TRUE;

} /* AGPDecommitAll */

BOOL AGPFree( HANDLE hdev, PVOID pvReservation )
{
    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );

    return OsAGPFree( hdev, pvReservation );
} /* AGPFree */


DWORD AGPGetChunkCount( DWORD dwSize )
{
    return NUM_CHUNKS(dwSize);
}


BOOL AGPCommitAllVirtual( EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal, VIDEOMEMORY* lpVidMem, int iHeapIndex)
{
    DWORD                   i, j;
    DWORD                   dwNumChunks;
    BOOL                    bSuccess = TRUE;
    BYTE*                   pPhysicalCommitMask;
    BYTE*                   pVirtualCommitMask;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING*        peMap;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    dwNumChunks = NUM_CHUNKS(lpVidMem->lpHeap->dwTotalSize);
    pPhysicalCommitMask = lpVidMem->lpHeap->pAgpCommitMask;
    if (peDirectDrawLocal->ppeMapAgp != NULL)
    {
        peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
        if (peMap != NULL)
        {
            pVirtualCommitMask = peMap->pAgpVirtualCommitMask;

            for (i = 0; (i < dwNumChunks) && bSuccess; i++)
            {
                if (IS_CHUNK_COMMITTED(pPhysicalCommitMask, i) &&
                    !IS_CHUNK_COMMITTED(pVirtualCommitMask, i))
                {
                    // We have found a page that needs to be committed.
                    // Now find the last page in the block to commit.
                    for (j = i + 1; j < dwNumChunks; j++)
                    {
                        if (!IS_CHUNK_COMMITTED(pPhysicalCommitMask,j) ||
                            IS_CHUNK_COMMITTED(pVirtualCommitMask,j))
                        {
                            break;
                        }
                    }

                    if (peDirectDrawGlobal->AgpInterface.AgpServices.
                        AgpCommitVirtual(peDirectDrawGlobal->AgpInterface.Context,
                                 peMap->pvReservation, 
                                 NUM_PAGES_FROM_CHUNK(i, j, lpVidMem->lpHeap->dwTotalSize),
                                 PAGE_FROM_CHUNK(i)) == NULL)
                    {
                        bSuccess = FALSE;
                    }
                    else
                    {
                        // If we succeeded in committing the block, then mark the pages
                        // as committed.
                        while (i < j)
                        {
                            MARK_CHUNK_COMMITTED(pVirtualCommitMask,i);
                            i++;
                        }
                    }
                }
            }
        }
    }
    else
    {
        bSuccess = FALSE;
    }
    return bSuccess;
}


BOOL AGPCommitVirtual( EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal, 
                       VIDEOMEMORY* lpVidMem, 
                       int iHeapIndex, 
                       DWORD dwOffset,
                       DWORD dwSize )
{
    DWORD                   i, j;
    DWORD                   dwNumChunks;
    BYTE*                   pVirtualCommitMask;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING*        peMap;
    BOOL                    bSuccess = TRUE;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
    if (peDirectDrawLocal->ppeMapAgp != NULL)
    {
        peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
        if (peMap != NULL)
        {
            DWORD dwChunk = CHUNK_INDEX(dwOffset);
            DWORD dwLastChunk = CHUNK_INDEX(dwOffset + dwSize - 1);
            
            pVirtualCommitMask = peMap->pAgpVirtualCommitMask;
            if (peDirectDrawGlobal->AgpInterface.AgpServices.
                AgpCommitVirtual(peDirectDrawGlobal->AgpInterface.Context,
                             peMap->pvReservation, 
                             NUM_PAGES_FROM_CHUNK(dwChunk, dwLastChunk + 1, lpVidMem->lpHeap->dwTotalSize),
                             PAGE_FROM_CHUNK(dwChunk)) != NULL)
            {
                while( dwChunk <= dwLastChunk ) 
                {
                    MARK_CHUNK_COMMITTED( pVirtualCommitMask, dwChunk );
                    dwChunk++;
                }
            }
            else
            {
                bSuccess = FALSE;
            }
        }
    }
    return bSuccess;
}

BOOL AGPDecommitVirtual( EDD_VMEMMAPPING*        peMap,
                         EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
                         EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
                         DWORD                   dwHeapSize)
{
    DWORD   i, j;
    DWORD   dwNumChunks;
    BYTE*   pVirtualCommitMask;
    DWORD   dwCommitMaskSize;

    pVirtualCommitMask = peMap->pAgpVirtualCommitMask;
    dwCommitMaskSize = peMap->dwAgpVirtualCommitMaskSize;
    dwNumChunks = NUM_CHUNKS(dwHeapSize);

    for (i = 0; i < dwNumChunks; i++)
    {
        if (IS_CHUNK_COMMITTED(pVirtualCommitMask,i))
        {
            // We have found a chunk that needs to be decommitted.
            // Now find the last chunk in the block to commit.
            for (j = i + 1; j < dwNumChunks; j++)
            {
                if (!IS_CHUNK_COMMITTED(pVirtualCommitMask,j))
                {
                    break;
                }
            }

            peDirectDrawGlobal->AgpInterface.AgpServices.
                AgpFreeVirtual(peDirectDrawGlobal->AgpInterface.Context,
                           peMap->pvReservation,
                           NUM_PAGES_FROM_CHUNK(i, j, dwHeapSize),
                           PAGE_FROM_CHUNK(i));
            i = j;
        }
    }
    RtlZeroMemory( pVirtualCommitMask, dwCommitMaskSize );

    return TRUE;
}

NTSTATUS AGPMapToDummy( EDD_VMEMMAPPING*        peMap, 
                        EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
                        PVOID                   pDummyPage )
{
    BYTE*       pVirtualCommitMask;
    ULONG       ulOffs;
    VOID*       pvVirtAddr;
    NTSTATUS    Status = STATUS_SUCCESS;
    DWORD       dwNumChunks;
    DWORD       i;
    DWORD       j;

    pVirtualCommitMask = peMap->pAgpVirtualCommitMask;
    dwNumChunks = NUM_CHUNKS(peDirectDrawGlobal->pvmList[peMap->iHeapIndex].lpHeap->dwTotalSize);

    for (i = 0; i < dwNumChunks; i++)
    {
        // This takes a little bit of explaining.  Even though AGPCommitVirtual
        // passes in as many pages as it wants to get mapped at any given time,
        // videoport.sys always breaks these down and maps them in 16 page 
        // chunks.  Therefore, we need to re-amp them in 16 page chunks in order
        // for MmMapUserAddress to work correctly.
        
        if (IS_CHUNK_COMMITTED(pVirtualCommitMask,i))
        {
            pvVirtAddr = (VOID*)((PAGE_FROM_CHUNK(i) * PAGE_SIZE) + (ULONG_PTR) peMap->pvVirtAddr);
            Status = MmMapUserAddressesToPage(
                        pvVirtAddr, 0, gpDummyPage);
        }

        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }

    return Status;
}


#ifndef __NTDDKCOMP__

#define OSR2_POINT_0_BUILD_NUMBER           1111
#define OSR2_BUILD_NUMBER_A                 1212
#define OSR2_BUILD_NUMBER_B                 1214

/*
 * Does this operating system understand AGP?
 *
 * NOTE: There may be a better way of determining this but for now I will
 * assumed that Memphis and NT 5.0 class operating systems are AGP aware.
 *
 * NOTE: The VXD handle is (obviously) only important on Win95. On NT
 * NULL should be passed.
 */
BOOL OSIsAGPAware( HANDLE hvxd )
{
    OSVERSIONINFO osvi;
    BOOL          success;
    BOOL          fIsVMMAGPAware;

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    success = GetVersionEx(&osvi);
    DDASSERT( success );

    if( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {
	DPF( 8, "Major version = %d", osvi.dwMajorVersion );
	DPF( 8, "Minor version = %d", osvi.dwMinorVersion );
	DPF( 8, "Build number  = %d", LOWORD(osvi.dwBuildNumber) );

	if( ( osvi.dwMajorVersion > 4UL ) ||
	    ( ( osvi.dwMajorVersion == 4UL ) &&
	      ( osvi.dwMinorVersion >= 10UL ) &&
	      ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
	{
	    /*
	     * Memphis or greater version of Win95. AGP support assumed.
	     */
	    DPF( 5, "AGP aware Windows95 detected. Enabling AGP" );
	    return TRUE;
	}
	else if( ( osvi.dwMajorVersion == 4UL ) &&
	         ( osvi.dwMinorVersion == 0UL ) &&
		 ( ( LOWORD( osvi.dwBuildNumber ) == OSR2_BUILD_NUMBER_A ) ||
  		   ( LOWORD( osvi.dwBuildNumber ) == OSR2_BUILD_NUMBER_B ) ||
  		   ( LOWORD( osvi.dwBuildNumber ) == OSR2_POINT_0_BUILD_NUMBER ) ) )
	{
	    DPF( 5, "Win95 OSR 2.1 detected. Checking VMM for AGP services" );

	    fIsVMMAGPAware = FALSE;
	    #ifdef    WIN95
		DDASSERT( INVALID_HANDLE_VALUE != hvxd );
		fIsVMMAGPAware = vxdIsVMMAGPAware( hvxd );
	    #else  /* WIN95 */
		/*
		 * Should never occur as this would mean we are running an NT
		 * binary on a 95 system.
		 */
		DDASSERT(FALSE);
	    #endif /* WIN95 */

	    if( fIsVMMAGPAware )
	    {
		/*
		 * AGP services are present in the VMM. Enable AGP.
		 */
		DPF( 5, "OSR 2.1 VMM has AGP services. Enabled AGP" );
		return TRUE;
	    }
	    else
	    {
		/*
		 * No AGP services. Disable AGP.
		 */
		DPF( 5, "OSR 2.1 VMM has no AGP services. AGP not available" );
		return FALSE;
	    }
	}
	else
	{
	    DPF( 5, "Win95 Gold, OSR 1.0 or OSR 2.0 detected. No AGP support available" );
	    return FALSE;
	}

    }
    else if( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        /*
         * AGP support assumed in NT 5.0 and above.
         */
        if( osvi.dwMajorVersion >= 5UL )
        {
            DPF( 4, "AGP aware WindowsNT detected. Enabling AGP" );
            return TRUE;
        }
    }

    /*
     * If we got to here we failed the AGP aware test.
     */
    DPF( 5, "Operating system is not AGP aware. Disabling AGP" );
    return FALSE;
} /* OSIsAGPAware */

#endif // __NTDDKCOMP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddguids.c ===
/******************************Module*Header*******************************\
* Module Name: ddguids.c
*
* This file contains the actual data declarations for all GUIDs used by
* GDI and device drivers.
*
* Created: 15-Feb-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/

#define GUID_DEFS_ONLY
#define INITGUID
#include <guiddef.h>
#include <ddrawint.h>
#include <dxmini.h>
// #include <dvp.h>
#include <agp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddagp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.h
 *  Content:	AGP memory header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDAGP_INCLUDED__
#define __DDAGP_INCLUDED__

// This value controls how big a chunk of GART memory to commit each time
// we need to (rather than commiting just what we need to satisfy a surface
// request). This value is in bytes.  Currently 256KB.
#define DEFAULT_AGP_COMMIT_DELTA (256 * 1024)

#define BITS_IN_BYTE    8


extern DWORD dwAGPPolicyMaxBytes;
extern DWORD dwAGPPolicyCommitDelta;

//
// OS-specific functions for AGP manipulation.
//

#ifdef WIN95
#define OsGetAGPDeviceHandle(pHeap) GetDXVxdHandle()
#define OsCloseAGPDeviceHandle(h) CloseHandle(h)
#else
#define OsGetAGPDeviceHandle(pHeap) ((pHeap)->hdevAGP)
#define OsCloseAGPDeviceHandle(h)
#endif

BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   PVOID *ppvReservation );
BOOL OsAGPCommit( HANDLE hdev, PVOID pvReservation,
                  DWORD dwPageOffset, DWORD dwNumPages );
BOOL OsAGPDecommit( HANDLE hdev, PVOID pvReservation, DWORD dwPageOffset,
                    DWORD dwNumPages );
BOOL OsAGPFree( HANDLE hdev, PVOID pvReservation );

//
// Generic functions that use the OS-specific functions.
//

DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  PVOID *ppvReservation );
BOOL AGPCommit( HANDLE hdev, PVOID pvReservation,
                DWORD dwOffset, DWORD dwSize, BYTE* pAgpCommitMask,
                DWORD* pdwCommittedSize, DWORD dwHeapSize );
BOOL AGPDecommitAll( HANDLE hdev, PVOID pvReservation, 
                     BYTE* pAgpCommitMask, DWORD dwAgpCommitMaksSize,
                     DWORD* pdwDecommittedSize,
                     DWORD dwHeapSize);
BOOL AGPFree( HANDLE hdev, PVOID pvReservation );
DWORD AGPGetChunkCount( DWORD dwSize );
VOID AGPUpdateCommitMask( BYTE* pAgpCommitMask, DWORD dwOffset, 
                          DWORD dwSize, DWORD dwHeapSize );
BOOL AGPCommitVirtual( EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal, 
                       VIDEOMEMORY* lpVidMem, 
                       int iHeapIndex, 
                       DWORD dwOffset,
                       DWORD dwSize );
BOOL AGPDecommitVirtual( EDD_VMEMMAPPING*        peMap,
                         EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
                         EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
                         DWORD                   dwHeapSize);
NTSTATUS AGPMapToDummy( EDD_VMEMMAPPING*        peMap, 
                        EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
                        PVOID                   pDummyPage);
BOOL AGPCommitAllVirtual( EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal, 
                          VIDEOMEMORY* lpVidMem, 
                          int iHeapIndex);

VOID InitAgpHeap( EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
                  DWORD                   dwHeapIndex,
                  HANDLE                  hdev);
BOOL bDdMapAgpHeap( EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
                    VIDEOMEMORY*            pvmHeap);
    
#ifndef __NTDDKCOMP__

#ifdef WIN95
BOOL vxdIsVMMAGPAware ( HANDLE hvxd );
#endif

BOOL OSIsAGPAware( HANDLE hdev );
#endif

#endif // __DDAGP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxapi\dxapi.cxx ===
/******************************Module*Header*******************************\
* Module Name: dxapi.cxx
*
* Contains the public kernel-mode APIs for DirectX.
*
* All of the stuff that has to happen at raised IRQL happens here, because
* win32k is entirely pageable.
*
* Created: 11-Apr-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

#if DBG
    #define RIPDX(x) { KdPrint((x)); DbgBreakPoint();}
    #define ASSERTDX(x, y) if (!(x)) RIPDX(y)
#else
    #define RIPDX(x)
    #define ASSERTDX(x, y)
#endif

extern "C" {

VOID
APIENTRY
DxIrqCallBack(
    DX_IRQDATA* pIrqData
    );

NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

VOID
APIENTRY
DxGetVersionNumber(
    DWORD               dwNotUsed,
    DDGETVERSIONNUMBER* pGetVersionNumber
    );

BOOL
bDxModifyPassiveEventList(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    BOOL                bAdd,
    DWORD               dwEvent,
    LPDD_NOTIFYCALLBACK pfnCallBack,
    PVOID               pContext
    );

DWORD
dwDxRegisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    BOOL                bRegister
    );

VOID
APIENTRY
DxRegisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    DWORD*              pdwRet
    );

VOID
APIENTRY
DxUnregisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    DWORD*              pdwRet
    );

VOID
APIENTRY
DxOpenDirectDraw(
    DDOPENDIRECTDRAWIN*     pOpenDirectDrawIn,
    DDOPENDIRECTDRAWOUT*    pOpenDirectDrawOut
    );

VOID
APIENTRY
DxApiInitialize(
    PFNDXAPIOPENDIRECTDRAW    pfnOpenDirectDraw,
    PFNDXAPIOPENVIDEOPORT     pfnOpenVideoPort,
    PFNDXAPIOPENSURFACE       pfnOpenSurface,
    PFNDXAPICLOSEHANDLE       pfnCloseHandle,
    PFNDXAPIGETKERNELCAPS     pfnGetKernelCaps,
    PFNDXAPIOPENCAPTUREDEVICE pfnOpenCaptureDevice,
    PFNDXAPILOCKDEVICE        pfnLockDevice,
    PFNDXAPIUNLOCKDEVICE      pfnUnlockDevice
    );

DWORD
APIENTRY
DxApi(
    DWORD   iFunction,
    VOID*   pInBuffer,
    DWORD   cInBuffer,
    VOID*   pOutBuffer,
    DWORD   cOutBuffer
    );

VOID
APIENTRY
DxAutoflipDpc(
    DWORD   dwEvent,
    PVOID   pContext,
    DWORD   dwParam1,
    DWORD   dwParam2
    );

VOID
APIENTRY
DxAutoflipUpdate(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXSURFACE**     apeDxSurfaceVideo,
    ULONG               cSurfacesVideo,
    EDD_DXSURFACE**     apeDxSurfaceVbi,
    ULONG               cSurfacesVbi
    );

VOID
APIENTRY
DxLoseObject(
    VOID*   pvObject,
    LOTYPE  loType
    );

VOID
APIENTRY
DxEnableIRQ(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    BOOL		bEnable
    );

VOID
APIENTRY
DxUpdateCapture(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXCAPTURE*      peDxCapture,
    BOOL                bRemove
    );

DWORD
APIENTRY
DxApiGetVersion(
    VOID
    );

}; // end "extern "C"


// Marke whatever we can as pageable:

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,DxGetVersionNumber)
#pragma alloc_text(PAGE,bDxModifyPassiveEventList)
#pragma alloc_text(PAGE,dwDxRegisterEvent)
#pragma alloc_text(PAGE,DxRegisterEvent)
#pragma alloc_text(PAGE,DxUnregisterEvent)
#pragma alloc_text(PAGE,DxOpenDirectDraw)
#pragma alloc_text(PAGE,DxApiInitialize)
#pragma alloc_text(PAGE,DxApiGetVersion)
#endif

PFNDXAPIOPENDIRECTDRAW  gpfnOpenDirectDraw;
PFNDXAPILOCKDEVICE      gpfnLockDevice;
PFNDXAPIUNLOCKDEVICE    gpfnUnlockDevice;

/***************************************************************************\
* NTSTATUS DriverEntry
*
* This routine is never actually called, but we need it to link.
*
\***************************************************************************/

extern "C"
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    return(STATUS_SUCCESS);
}

/******************************Public*Routine******************************\
* DWORD DxGetVersionNumber
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetVersionNumber(
    DWORD               dwNotUsed,
    DDGETVERSIONNUMBER* pGetVersionNumber
    )
{
    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DxGetVersionNumber: Call only at passive level (it's not pageable)");

    pGetVersionNumber->dwMajorVersion = DXAPI_MAJORVERSION;
    pGetVersionNumber->dwMinorVersion = DXAPI_MINORVERSION;
    pGetVersionNumber->ddRVal = DD_OK;
}

/******************************Public*Routine******************************\
* VOID DxGetFieldNumber
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetFieldNumber(
    DDGETFIELDNUMIN*    pGetFieldNumIn,
    DDGETFIELDNUMOUT*   pGetFieldNumOut
    )
{
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;

    pGetFieldNumOut->ddRVal = DDERR_INVALIDPARAMS;
    if (pGetFieldNumIn == NULL)
    {
        return;
    }

    pDxObjDirectDraw = (DXOBJ*) pGetFieldNumIn->hDirectDraw;
    if (pDxObjDirectDraw != NULL)
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;

        pDxObjVideoPort  = (DXOBJ*) pGetFieldNumIn->hVideoPort;
        if (pDxObjVideoPort != NULL)
        {
            peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

            ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
                "Invalid DirectDraw object");
            ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
                "Invalid VideoPort object");
            ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
                "VideoPort and DirectDraw objects don't match");

            if (peDxVideoPort->peDxDirectDraw->dwIRQCaps & DDIRQ_VPORT0_VSYNC )
            {
                pGetFieldNumOut->dwFieldNum = peDxVideoPort->dwCurrentField;
                pGetFieldNumOut->ddRVal = DD_OK;
            }
            else
            {
                KdPrint(("DxGetFieldNumber: Device doesn't support an interrupt\n"));
                pGetFieldNumOut->ddRVal = DDERR_UNSUPPORTED;
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxSetFieldNumber
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxSetFieldNumber(
    DDSETFIELDNUM*  pSetFieldNum,
    DWORD*          pdwRet
    )
{
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;

    *pdwRet = DDERR_INVALIDPARAMS;
    if (pSetFieldNum == NULL)
    {
        return;
    }

    pDxObjDirectDraw = (DXOBJ*) pSetFieldNum->hDirectDraw;
    if (pDxObjDirectDraw != NULL)
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;

        pDxObjVideoPort  = (DXOBJ*) pSetFieldNum->hVideoPort;
        if (pDxObjVideoPort != NULL)
        {
            peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

            ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
                "Invalid DirectDraw object");
            ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
                "Invalid VideoPort object");
            ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
                "VideoPort and DirectDraw objects don't match");

            if (peDxVideoPort->peDxDirectDraw->dwIRQCaps & DDIRQ_VPORT0_VSYNC )
            {
                peDxVideoPort->dwCurrentField = pSetFieldNum->dwFieldNum;
                *pdwRet = DD_OK;
            }
            else
            {
                KdPrint(("DxSetFieldNumber: Device doesn't support an interrupt\n"));
                *pdwRet = DDERR_UNSUPPORTED;
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxSetSkipPattern
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxSetSkipPattern(
    DDSETSKIPFIELD*   pSetSkipPattern,
    DWORD*            pdwRet
    )
{
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    KIRQL               OldIrql;
    DWORD               dwStartField;

    *pdwRet = DDERR_INVALIDPARAMS;
    if (pSetSkipPattern == NULL)
    {
        return;
    }

    pDxObjDirectDraw = (DXOBJ*) pSetSkipPattern->hDirectDraw;
    if (pDxObjDirectDraw != NULL)
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;

        pDxObjVideoPort  = (DXOBJ*) pSetSkipPattern->hVideoPort;
        if (pDxObjVideoPort != NULL)
        {
            peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

            ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
                "Invalid DirectDraw object");
            ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
                "Invalid VideoPort object");
            ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
                "VideoPort and DirectDraw objects don't match");

            // Acquire the spinlock while we muck around

            KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

            // We assume that we are called during the VSYNC callback notification
            // so all that we do is store the value and do the actual skipping
            // during the AutoflipDpc call.

            dwStartField = pSetSkipPattern->dwStartField;
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIP_SET )
            {
                if( peDxVideoPort->dwFieldToSkip > dwStartField )
                {
                    peDxVideoPort->dwNextFieldToSkip = peDxVideoPort->dwFieldToSkip;
                    peDxVideoPort->dwFieldToSkip = dwStartField;
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET;
                }
                else if ( dwStartField != peDxVideoPort->dwFieldToSkip )
                {
                    peDxVideoPort->dwFieldToSkip = dwStartField;
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET;
                }
            }
            else
            {
                peDxVideoPort->dwFieldToSkip = dwStartField;
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_SKIP_SET;
            }

            KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

            *pdwRet = DX_OK;
        }
    }
}

/******************************Public*Routine******************************\
* VOID EffectStateChange
*
*  09-Jan-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID EffectStateChange( EDD_DXVIDEOPORT* peDxVideoPort,
        EDD_DXSURFACE* peDxSurface, DWORD dwNewState )
{
    EDD_DXDIRECTDRAW* peDxDirectDraw;
    DDSETSTATEININFO ddStateInInfo;
    DDSETSTATEOUTINFO ddStateOutInfo;
    DWORD dwOldFlags;
    DWORD dwOldVPFlags;
    DWORD ddRVal;
    DWORD i;
    DWORD dwRet;

    dwOldVPFlags = 0;
    if( peDxVideoPort != NULL )
    {
        peDxVideoPort->dwSetStateState = 0;
        peDxSurface = peDxVideoPort->apeDxSurfaceVideo[0];
        dwOldVPFlags = peDxVideoPort->dwVPFlags;
        if( dwNewState & DDSTATE_SKIPEVENFIELDS )
        {
            peDxVideoPort->dwVPFlags |= DDVP_SKIPEVENFIELDS;
        }
        else
        {
            peDxVideoPort->dwVPFlags &= ~DDVP_SKIPEVENFIELDS;
        }
    }

    if( peDxSurface != NULL )
    {
        dwOldFlags = peDxSurface->dwOverlayFlags;
        if( dwNewState & DDSTATE_BOB )
        {
            peDxSurface->dwOverlayFlags |= DDOVER_BOB;
        }
        else if( dwNewState & ( DDSTATE_WEAVE | DDSTATE_SKIPEVENFIELDS ) )
        {
            peDxSurface->dwOverlayFlags &= ~DDOVER_BOB;
        }

        peDxDirectDraw = peDxSurface->peDxDirectDraw;

        ddStateInInfo.lpSurfaceData = peDxSurface;
        ddStateInInfo.lpVideoPortData = peDxVideoPort;
        ddStateOutInfo.bSoftwareAutoflip = 0;

        dwRet = DDERR_UNSUPPORTED;
        if (peDxDirectDraw->DxApiInterface.DxSetState != NULL)
        {
            dwRet = peDxDirectDraw->DxApiInterface.DxSetState(
                                peDxDirectDraw->HwDeviceExtension,
                                &ddStateInInfo,
                                &ddStateOutInfo);
        }
        if( dwRet != DD_OK )
    	{
            peDxSurface->dwOverlayFlags = dwOldFlags;
            if( peDxVideoPort != NULL )
            {
                peDxVideoPort->dwVPFlags = dwOldVPFlags;
            }
    	}
        peDxSurface->flFlags |= DD_DXSURFACE_FLAG_STATE_SET;
        if( peDxVideoPort != NULL )
        {
            if( peDxSurface->dwOverlayFlags & DDOVER_BOB )
            {
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_BOB;
            }
            else
            {
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_BOB;
            }

            // Do they want to switch from hardware autoflipping to
            // software autoflipping?

            if( ( ddStateOutInfo.bSoftwareAutoflip ) &&
                ( peDxVideoPort->dwVPFlags & DDVP_AUTOFLIP ) &&
                !( peDxVideoPort->flFlags & (DD_DXVIDEOPORT_FLAG_AUTOFLIP|DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI)))
            {
                if( peDxVideoPort->cAutoflipVideo > 0 )
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP;
                }
                if( peDxVideoPort->cAutoflipVbi > 0 )
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI;
                }
                if( ddStateOutInfo.dwSurfaceIndex >= peDxVideoPort->cAutoflipVideo )
                {
                    peDxVideoPort->iCurrentVideo = 0;
                }
                else
                {
                    peDxVideoPort->iCurrentVideo = ddStateOutInfo.dwSurfaceIndex;
                }
                if( ddStateOutInfo.dwVBISurfaceIndex >= peDxVideoPort->cAutoflipVbi )
                {
                    peDxVideoPort->iCurrentVbi = 0;
                }
                else
                {
                    peDxVideoPort->iCurrentVbi = ddStateOutInfo.dwVBISurfaceIndex;
                }
            }

            for( i = 0; i < peDxVideoPort->iCurrentVideo; i++ )
    	    {
                peDxSurface = peDxVideoPort->apeDxSurfaceVideo[i];
                peDxSurface->flFlags &= ~(DD_DXSURFACE_FLAG_STATE_BOB|DD_DXSURFACE_FLAG_STATE_WEAVE);
                if( dwNewState & DDSTATE_BOB )
                {
                    peDxSurface->dwOverlayFlags |= DDOVER_BOB;
                    peDxSurface->flFlags |= DD_DXSURFACE_FLAG_STATE_BOB;
                }
                else if( dwNewState & ( DDSTATE_WEAVE | DDSTATE_SKIPEVENFIELDS ) )
                {
                    peDxSurface->dwOverlayFlags &= ~DDOVER_BOB;
                    if( dwNewState == DDSTATE_WEAVE )
                    {
                        peDxSurface->flFlags |= DD_DXSURFACE_FLAG_STATE_WEAVE;
                    }
                }
                peDxSurface->flFlags |= DD_DXSURFACE_FLAG_STATE_SET;
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxGetSurfaceState
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetSurfaceState(
    DDGETSURFACESTATEIN*    pGetSurfaceStateIn,
    DDGETSURFACESTATEOUT*   pGetSurfaceStateOut
    )
{
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObjSurface;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DXSURFACE*          peDxSurface;

    pGetSurfaceStateOut->ddRVal = DDERR_INVALIDPARAMS;
    if (pGetSurfaceStateIn == NULL)
    {
        return;
    }

    pDxObjDirectDraw = (DXOBJ*) pGetSurfaceStateIn->hDirectDraw;
    pDxObjSurface    = (DXOBJ*) pGetSurfaceStateIn->hSurface;

    if ((pDxObjDirectDraw != NULL) &&
        (pDxObjSurface != NULL))
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
        peDxSurface      = pDxObjSurface->peDxSurface;

        ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
            "Invalid DirectDraw object");
        ASSERTDX(pDxObjSurface->iDxType == DXT_SURFACE,
            "Invalid Surface object");
        ASSERTDX(peDxDirectDraw == peDxSurface->peDxDirectDraw,
            "Surface and DirectDraw objects don't match");
        ASSERTDX(peDxSurface->ddsCaps & DDSCAPS_OVERLAY,
            "Surface is not an overlay surface");

        // Fill in the available caps

        pGetSurfaceStateOut->dwStateCaps = 0;
        pGetSurfaceStateOut->dwStateStatus = 0;
        peDxVideoPort = peDxSurface->peDxVideoPort;

        // If the DDOVER_OVERRIDEBOBWEAVE flag was set, the status is equal
        // to the caps.

        if( peDxSurface->dwOverlayFlags & DDOVER_OVERRIDEBOBWEAVE )
        {
            if( peDxSurface->dwOverlayFlags & DDOVER_BOB )
            {
                pGetSurfaceStateOut->dwStateStatus |= DDSTATE_BOB;
                pGetSurfaceStateOut->dwStateCaps |= DDSTATE_BOB;
            }
            else if( ( peDxVideoPort != NULL ) &&
                ( peDxVideoPort->dwVPFlags & (DDVP_SKIPEVENFIELDS|DDVP_SKIPODDFIELDS) ) )
            {
                pGetSurfaceStateOut->dwStateStatus |= DDSTATE_SKIPEVENFIELDS;
                pGetSurfaceStateOut->dwStateCaps |= DDSTATE_SKIPEVENFIELDS;
            }
            else if( ( peDxVideoPort != NULL ) &&
                ( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE ) )
            {
                pGetSurfaceStateOut->dwStateStatus |= DDSTATE_WEAVE;
                pGetSurfaceStateOut->dwStateCaps |= DDSTATE_WEAVE;
            }
            else if( ( peDxVideoPort == NULL ) &&
                ( peDxSurface->dwOverlayFlags & DDOVER_INTERLEAVED ) )
            {
                pGetSurfaceStateOut->dwStateStatus |= DDSTATE_WEAVE;
                pGetSurfaceStateOut->dwStateCaps |= DDSTATE_WEAVE;
            }
        }
        else
        {
            // The status is different from the caps

            if( ( peDxVideoPort != NULL ) &&
                ( peDxVideoPort->dwVPFlags & (DDVP_SKIPEVENFIELDS|DDVP_SKIPODDFIELDS) ) )
            {
                pGetSurfaceStateOut->dwStateStatus |= DDSTATE_SKIPEVENFIELDS;
            }
            else if( peDxSurface->dwOverlayFlags & DDOVER_BOB )
            {
                pGetSurfaceStateOut->dwStateStatus |= DDSTATE_BOB;
            }

            if( ( ( peDxVideoPort != NULL ) &&
                ( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE ) ) ||
                ( ( peDxVideoPort == NULL ) &&
                ( peDxSurface->dwOverlayFlags & DDOVER_INTERLEAVED ) ) )
            {
                pGetSurfaceStateOut->dwStateCaps |= DDSTATE_WEAVE;
                if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_CAN_BOB_INTERLEAVED )
                {
                    pGetSurfaceStateOut->dwStateCaps |= DDSTATE_BOB;
                }
                if( pGetSurfaceStateOut->dwStateStatus == 0 )
                {
                    pGetSurfaceStateOut->dwStateStatus |= DDSTATE_WEAVE;
                }
            }
            else if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_CAN_BOB_NONINTERLEAVED )
            {
                pGetSurfaceStateOut->dwStateCaps |= DDSTATE_BOB;
            }
            if( peDxVideoPort != NULL )
            {
                pGetSurfaceStateOut->dwStateCaps |= DDSTATE_SKIPEVENFIELDS;
            }
        }

        // Notify the client that the state was explicity set by a
        // kernel mode client.

        if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_STATE_SET )
        {
            pGetSurfaceStateOut->dwStateStatus |= DDSTATE_EXPLICITLY_SET;
        }

        // Tell if software autoflipping vs. hardware autofliping.  This
        // is mostly for DDraw's benefit.

        if( ( peDxVideoPort != NULL ) && ( peDxVideoPort->bSoftwareAutoflip ) )
        {
            pGetSurfaceStateOut->dwStateStatus |= DDSTATE_SOFTWARE_AUTOFLIP;
        }

        pGetSurfaceStateOut->ddRVal = DD_OK;
    }
}

/******************************Public*Routine******************************\
* VOID DxSetSurfaceState
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxSetSurfaceState(
    DDSETSURFACESTATE*  pSetSurfaceState,
    DWORD*              pdwRet
    )
{
    DWORD                   dwState;
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObjSurface;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DXSURFACE*          peDxSurface;
    DDGETSURFACESTATEIN     GetSurfaceStateIn;
    DDGETSURFACESTATEOUT    GetSurfaceStateOut;
    DDSETSTATEININFO        SetStateInInfo;
    DDSETSTATEOUTINFO       SetStateOutInfo;
    DWORD                   iCurrentVideo;
    KIRQL                   OldIrql;
    DWORD                   dwRet;
    DWORD                   dwVPFlags;

    *pdwRet = dwRet = DDERR_INVALIDPARAMS;
    if (pSetSurfaceState == NULL)
    {
        return;
    }

    pDxObjDirectDraw = (DXOBJ*) pSetSurfaceState->hDirectDraw;
    pDxObjSurface    = (DXOBJ*) pSetSurfaceState->hSurface;
    if ((pDxObjDirectDraw != NULL) &&
        (pDxObjSurface != NULL))
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
        peDxSurface      = pDxObjSurface->peDxSurface;

        GetSurfaceStateIn.hDirectDraw = pSetSurfaceState->hDirectDraw;
        GetSurfaceStateIn.hSurface    = pSetSurfaceState->hSurface;

        DxGetSurfaceState(&GetSurfaceStateIn, &GetSurfaceStateOut);

        ASSERTDX(GetSurfaceStateOut.ddRVal == DD_OK,
            "DxSetSurfaceState: Didn't expect failure from DxGetSurfaceState");

        dwState = pSetSurfaceState->dwState;

        // Get the video port if one is associated with the surface

        if( peDxSurface->peDxVideoPort == NULL )
        {
            peDxVideoPort = NULL;
            dwVPFlags = 0;
        }
        else
        {
            peDxVideoPort = peDxSurface->peDxVideoPort;
            dwVPFlags = peDxVideoPort->dwVPFlags;
        }

        if ((dwState != DDSTATE_BOB) &&
            (dwState != DDSTATE_WEAVE) &&
            (dwState != DDSTATE_SKIPEVENFIELDS))
        {
            RIPDX("DxSetSurfaceState: Invalid dwState flags");
        }
        else if ((dwState & GetSurfaceStateOut.dwStateCaps) != dwState)
        {
            RIPDX("DxSetSurfaceState: State not supported");
        }
        else if ((dwState == DDSTATE_SKIPEVENFIELDS) && (peDxVideoPort == NULL ))
        {
            RIPDX("DxSetSurfaceState: Surface not attached to video port");
        }
        else if (((dwState & DDSTATE_BOB) &&
                  (peDxSurface->dwOverlayFlags & DDOVER_BOB)) ||
                 ((dwState & DDSTATE_WEAVE) &&
                  !(peDxSurface->dwOverlayFlags & DDOVER_BOB) &&
                  !(dwVPFlags & (DDVP_SKIPEVENFIELDS|DDVP_SKIPODDFIELDS))) ||
                 ((dwState & DDSTATE_SKIPEVENFIELDS ) &&
                   (dwVPFlags & (DDVP_SKIPEVENFIELDS|DDVP_SKIPODDFIELDS))))
        {
            // Don't do nothin, it's already in the requested state.

            dwRet = DD_OK;
        }
        else if (peDxDirectDraw->DxApiInterface.DxSetState != NULL)
        {
            // Acquire the spinlock while we muck around in the 'dwSetStateState'
            // and 'dwSetStateField' members, which are accessed by the videoport
            // DPC.

            KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

            if ((peDxDirectDraw->bLost) ||
                ((peDxVideoPort != NULL) && (peDxVideoPort->bLost)) ||
                (peDxSurface->bLost))
            {
                KdPrint(("DxSetSurfaceState: Objects are lost\n"));
                dwRet = DDERR_SURFACELOST;
            }

            // If they want it to happen for the next field or we are not
            // using a video port, call the mini port now; otherwise, we'll let
            // the IRQ logoic handle this later.

            else if ((pSetSurfaceState->dwStartField == 0) ||
                (peDxVideoPort == NULL) ||
                !(peDxVideoPort->bSoftwareAutoflip))
            {
                EffectStateChange( peDxVideoPort, peDxSurface, dwState );
            }
            else
            {
                peDxVideoPort->dwSetStateState = dwState;
                peDxVideoPort->dwSetStateField = pSetSurfaceState->dwStartField;
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_NEW_STATE;
            }

            KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

            dwRet = DD_OK;
        }

        if (peDxDirectDraw->DxApiInterface.DxSetState == NULL)
        {
            dwRet = DDERR_UNSUPPORTED;
        }

        *pdwRet = dwRet;
    }
}

/******************************Public*Routine******************************\
* VOID DxLock
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxLock(
    DDLOCKIN*   pLockIn,
    DDLOCKOUT*  pLockOut
    )
{
    DWORD               dwRet;
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjSurface;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXSURFACE*      peDxSurface;
    DDLOCKININFO        LockInInfo;
    DDLOCKOUTINFO       LockOutInfo;
    KIRQL               OldIrql;

    pLockOut->ddRVal = DDERR_INVALIDPARAMS;
    if (pLockIn == NULL)
    {
        return;
    }

    dwRet = DD_OK;

    pDxObjDirectDraw = (DXOBJ*) pLockIn->hDirectDraw;
    pDxObjSurface    = (DXOBJ*) pLockIn->hSurface;
    if ((pDxObjDirectDraw != NULL) &&
        (pDxObjSurface != NULL))
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
        peDxSurface      = pDxObjSurface->peDxSurface;

        ASSERTDX(peDxDirectDraw == peDxSurface->peDxDirectDraw,
            "Surface and DirectDraw objects don't match");
        ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
            "Invalid DirectDraw object");
        ASSERTDX(pDxObjSurface->iDxType == DXT_SURFACE,
            "Invalid surface object");

        LockInInfo.lpSurfaceData = peDxSurface;
        LockOutInfo.dwSurfacePtr  = peDxSurface->fpLockPtr;

        // The display driver can set 'fpLockPtr' to NULL in its SyncSurfaceData
        // routine if it doesn't want to support a DXAPI lock.

        if (peDxSurface->fpLockPtr == NULL)
        {
            KdPrint(("DxLock: Video miniport doesn't support lock on this surface\n"));
            dwRet = DDERR_UNSUPPORTED;
        }
        else
        {
            // NOTE: The miniport should not wait for accelerator complete!

            if (peDxDirectDraw->DxApiInterface.DxLock)
            {
                KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

                if ((peDxDirectDraw->bLost) || (peDxSurface->bLost))
                {
                    KdPrint(("DxLock: Objects are lost\n"));
                    dwRet = DDERR_SURFACELOST;
                }
                else
                {
                    dwRet = peDxDirectDraw->DxApiInterface.DxLock(
                                        peDxDirectDraw->HwDeviceExtension,
                                        &LockInInfo,
                                        &LockOutInfo);
                }

                KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

                if (dwRet != DD_OK)
                {
                    KdPrint(("DxLock: Driver failed call\n"));

                    // Pass the return code on down...
                }
            }

            pLockOut->lpSurface        = (LPVOID) LockOutInfo.dwSurfacePtr;

            pLockOut->dwSurfHeight     = peDxSurface->dwHeight;
            pLockOut->dwSurfWidth      = peDxSurface->dwWidth;
            pLockOut->lSurfPitch       = peDxSurface->lPitch;
            pLockOut->SurfaceCaps      = peDxSurface->ddsCaps;
            pLockOut->dwFormatFlags    = peDxSurface->dwFormatFlags;
            pLockOut->dwFormatFourCC   = peDxSurface->dwFormatFourCC;
            pLockOut->dwFormatBitCount = peDxSurface->dwFormatBitCount;
            pLockOut->dwRBitMask       = peDxSurface->dwRBitMask;
            pLockOut->dwGBitMask       = peDxSurface->dwGBitMask;
            pLockOut->dwBBitMask       = peDxSurface->dwBBitMask;
        }

        pLockOut->ddRVal = dwRet;
    }
}

/******************************Public*Routine******************************\
* VOID DxFlipOverlay
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxFlipOverlay(
    DDFLIPOVERLAY*  pFlipOverlay,
    DWORD*          pdwRet
    )
{
    DWORD               dwRet;
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjTarget;
    DXOBJ*              pDxObjCurrent;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXSURFACE*      peDxTarget;
    EDD_DXSURFACE*      peDxCurrent;
    DDFLIPOVERLAYINFO   FlipOverlayInfo;
    KIRQL               OldIrql;

    *pdwRet = DDERR_INVALIDPARAMS;
    if (pFlipOverlay == NULL)
    {
        return;
    }

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pFlipOverlay->hDirectDraw;
    pDxObjTarget     = (DXOBJ*) pFlipOverlay->hTargetSurface;
    pDxObjCurrent    = (DXOBJ*) pFlipOverlay->hCurrentSurface;

    if ((pDxObjDirectDraw != NULL) &&
        (pDxObjTarget != NULL) &&
        (pDxObjCurrent != NULL))
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
        peDxTarget       = pDxObjTarget->peDxSurface;
        peDxCurrent      = pDxObjCurrent->peDxSurface;

        ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
            "Invalid DirectDraw object");
        ASSERTDX(pDxObjTarget->iDxType == DXT_SURFACE,
            "Invalid target object");
        ASSERTDX(pDxObjCurrent->iDxType == DXT_SURFACE,
            "Invalid current object");
        ASSERTDX((peDxDirectDraw == peDxTarget->peDxDirectDraw) &&
                 (peDxDirectDraw == peDxCurrent->peDxDirectDraw),
            "Surface and DirectDraw objects don't match");
        ASSERTDX((peDxCurrent->dwWidth == peDxTarget->dwWidth) &&
                  (peDxCurrent->dwHeight == peDxTarget->dwHeight),
            "Surfaces are different sizes");

        if (!(peDxCurrent->ddsCaps & DDSCAPS_OVERLAY) ||
            (peDxCurrent->dwOverlayFlags & DDOVER_AUTOFLIP))
        {
            RIPDX("Invalid current overlay status");
        }
        else if (!(peDxTarget->ddsCaps & DDSCAPS_OVERLAY) ||
                 (peDxTarget->dwOverlayFlags & DDOVER_AUTOFLIP))
        {
            RIPDX("Invalid target overlay status");
        }
        else
        {
            FlipOverlayInfo.lpCurrentSurface = peDxCurrent;
            FlipOverlayInfo.lpTargetSurface  = peDxTarget;
            FlipOverlayInfo.dwFlags          = pFlipOverlay->dwFlags;

            if (peDxDirectDraw->DxApiInterface.DxFlipOverlay)
            {
                KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

                if ((peDxDirectDraw->bLost) ||
                    (peDxTarget->bLost)     ||
                    (peDxCurrent->bLost))
                {
                    KdPrint(("DxFlipOverlay: Objects are lost\n"));
                    dwRet = DDERR_SURFACELOST;
                }
                else
                {
                    dwRet = peDxDirectDraw->DxApiInterface.DxFlipOverlay(
                                        peDxDirectDraw->HwDeviceExtension,
                                        &FlipOverlayInfo,
                                        NULL);
                }

                KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
            }

            if (dwRet != DD_OK)
            {
                KdPrint(("DxFlipOverlay: Driver failed call\n"));
            }
        }

        *pdwRet = dwRet;
    }
}

/******************************Public*Routine******************************\
* VOID DxFlipVideoPort
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxFlipVideoPort(
    DDFLIPVIDEOPORT*    pFlipVideoPort,
    DWORD*              pdwRet
    )
{
    DWORD               dwRet;
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    DXOBJ*              pDxObjTarget;
    DXOBJ*              pDxObjCurrent;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    EDD_DXSURFACE*      peDxTarget;
    EDD_DXSURFACE*      peDxCurrent;
    DDFLIPVIDEOPORTINFO FlipVideoPortInfo;
    KIRQL               OldIrql;

    *pdwRet = DDERR_INVALIDPARAMS;
    if (pFlipVideoPort == NULL)
    {
        return;
    }

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pFlipVideoPort->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pFlipVideoPort->hVideoPort;
    pDxObjTarget     = (DXOBJ*) pFlipVideoPort->hTargetSurface;
    pDxObjCurrent    = (DXOBJ*) pFlipVideoPort->hCurrentSurface;

    if ((pDxObjDirectDraw != NULL) &&
        (pDxObjVideoPort != NULL) &&
        (pDxObjTarget != NULL) &&
        (pDxObjCurrent != NULL))
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
        peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;
        peDxTarget       = pDxObjTarget->peDxSurface;
        peDxCurrent      = pDxObjCurrent->peDxSurface;

        ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
            "Invalid DirectDraw object");
        ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
            "Invalid VideoPort object");
        ASSERTDX(pDxObjTarget->iDxType == DXT_SURFACE,
            "Invalid target object");
        ASSERTDX(pDxObjCurrent->iDxType == DXT_SURFACE,
            "Invalid current object");
        ASSERTDX((peDxDirectDraw == peDxTarget->peDxDirectDraw) &&
                 (peDxDirectDraw == peDxCurrent->peDxDirectDraw) &&
                 (peDxDirectDraw == peDxVideoPort->peDxDirectDraw),
            "Surface, VideoPort, and DirectDraw objects don't match");
        ASSERTDX((peDxCurrent->dwWidth == peDxTarget->dwWidth) &&
                  (peDxCurrent->dwHeight == peDxTarget->dwHeight),
            "Surfaces are different sizes");
        ASSERTDX((pFlipVideoPort->dwFlags == DDVPFLIP_VIDEO) ||
                  (pFlipVideoPort->dwFlags == DDVPFLIP_VBI),
            "Invalid flags");
        ASSERTDX(!(peDxVideoPort->dwVPFlags & DDVP_AUTOFLIP),
            "Flip not available while autoflipping");

        FlipVideoPortInfo.lpVideoPortData  = peDxVideoPort;
        FlipVideoPortInfo.lpCurrentSurface = peDxCurrent;
        FlipVideoPortInfo.lpTargetSurface  = peDxTarget;
        FlipVideoPortInfo.dwFlipVPFlags    = pFlipVideoPort->dwFlags;

        if (peDxDirectDraw->DxApiInterface.DxFlipVideoPort)
        {
            KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

            if ((peDxDirectDraw->bLost) ||
                (peDxVideoPort->bLost)  ||
                (peDxTarget->bLost)     ||
                (peDxCurrent->bLost))
            {
                KdPrint(("DxFlipVideoPort: Objects are lost\n"));
                dwRet = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxFlipVideoPort(
                                        peDxDirectDraw->HwDeviceExtension,
                                        &FlipVideoPortInfo,
                                        NULL);
            }
            peDxCurrent->peDxVideoPort = NULL;
            peDxTarget->peDxVideoPort = peDxVideoPort;

            KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        }

        if (dwRet != DD_OK)
        {
            KdPrint(("DxFlipVideoPort: Driver failed call\n"));
        }

        *pdwRet = dwRet;
    }
}

/******************************Public*Routine******************************\
* VOID DxGetCurrentAutoflip
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetCurrentAutoflip(
    DDGETAUTOFLIPIN*  pGetCurrentAutoflipIn,
    DDGETAUTOFLIPOUT* pGetCurrentAutoflipOut
    )
{
    DWORD                       dwRet;
    DXOBJ*                      pDxObjDirectDraw;
    DXOBJ*                      pDxObjVideoPort;
    DXOBJ*                      pDxObjTarget;
    DXOBJ*                      pDxObjCurrent;
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    EDD_DXVIDEOPORT*            peDxVideoPort;
    EDD_DXSURFACE*              peDxTarget;
    EDD_DXSURFACE*              peDxCurrent;
    DDGETPOLARITYININFO         GetPolarityInInfo;
    DDGETPOLARITYOUTINFO        GetPolarityOutInfo;
    DDGETCURRENTAUTOFLIPININFO  GetCurrentAutoflipInInfo;
    DDGETCURRENTAUTOFLIPOUTINFO GetCurrentAutoflipOutInfo;
    KIRQL                       OldIrql;
    DWORD                       dwVideo;
    DWORD                       dwVBI;
    BOOL                        bFlipping;

    pGetCurrentAutoflipOut->ddRVal = DDERR_INVALIDPARAMS;
    if (pGetCurrentAutoflipIn == NULL)
    {
        return;
    }

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pGetCurrentAutoflipIn->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pGetCurrentAutoflipIn->hVideoPort;
    if ((pDxObjDirectDraw != NULL) &&
        (pDxObjVideoPort != NULL))
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
        peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

        ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
            "Invalid DirectDraw object");
        ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
            "Invalid VideoPort object");
        ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
            "Surface, VideoPort, and DirectDraw objects don't match");
        ASSERTDX(peDxVideoPort->dwVPFlags & DDVP_AUTOFLIP,
            "Not currently autoflipping");

        GetPolarityInInfo.lpVideoPortData = peDxVideoPort;

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        if ((peDxDirectDraw->bLost) ||
            (peDxVideoPort->bLost))
        {
            KdPrint(("DxGetCurrentAutoflip: Objects are lost\n"));
            dwRet = DDERR_SURFACELOST;
        }
        else
        {
            dwRet = DDERR_UNSUPPORTED;
            if (peDxDirectDraw->DxApiInterface.DxGetPolarity)
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxGetPolarity(
                                        peDxDirectDraw->HwDeviceExtension,
                                        &GetPolarityInInfo,
                                        &GetPolarityOutInfo);
            }

            if (dwRet != DD_OK)
            {
                KdPrint(("DxGetCurrentAutoflip: Driver failed GetPolarity\n"));
            }
            else
            {
                // Determine which field is currently receiving the data.  If they
                // are software autoflipping, I can do that myself; otherwise, I
                // have to call the HAL
                //
                // When software autoflipping, there is an issue that if this
                // function is called between the time that the IRQ occured
                // and the time that the DPC ran, this function would return
                // the wrong surface. Since fixing this requires that we do all
                // of the work at IRQ time (bad), we can probably assume that
                // this will always be the case since anybody using this
                // function would be calling it during the IRQ callback.  We
                // will therefore work around it.

                dwVideo = (DWORD) -1;
                dwVBI = (DWORD) -1;

                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP )
                {
                    dwVideo = peDxVideoPort->iCurrentVideo;
                    bFlipping = TRUE;
                    if( ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIP_SET ) &&
                        ( peDxVideoPort->dwFieldToSkip == 1 ) )
                    {
                        bFlipping = FALSE;
                    }
                    else if( !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIPPED_LAST ) &&
                              ( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE ) &&
                             !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT ) )
                    {
                        bFlipping = FALSE;
                    }
                    if( bFlipping )
                    {
                        if( ++dwVideo >= peDxVideoPort->cAutoflipVideo )
                        {
                            dwVideo = 0;
                        }
                    }
                }

                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI )
                {
                    dwVBI = peDxVideoPort->iCurrentVbi;
                    if(  ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_VBI_INTERLEAVED ) &&
                        !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI ) )
                    {
                        if( ++dwVBI >= peDxVideoPort->cAutoflipVbi )
                        {
                            dwVBI = 0;
                        }
                    }
                }

                if( ( dwVideo == (DWORD) -1 ) && ( dwVBI == (DWORD) -1 ) )
                {
                    GetCurrentAutoflipInInfo.lpVideoPortData = peDxVideoPort;
                    GetCurrentAutoflipOutInfo.dwSurfaceIndex = 0;
                    GetCurrentAutoflipOutInfo.dwVBISurfaceIndex = 0;
                    if (peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip)
                    {
                        dwRet = peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &GetCurrentAutoflipInInfo,
                                    &GetCurrentAutoflipOutInfo);
                    }
                    dwVideo = GetCurrentAutoflipOutInfo.dwSurfaceIndex;
                    dwVBI = GetCurrentAutoflipOutInfo.dwVBISurfaceIndex;
                }

                pGetCurrentAutoflipOut->hVideoSurface = NULL;
                pGetCurrentAutoflipOut->hVBISurface = NULL;
                if( ( peDxVideoPort->cAutoflipVideo > 0 ) && ( dwVideo != (DWORD) -1 ) )
                {
                    pGetCurrentAutoflipOut->hVideoSurface =
                        peDxVideoPort->apeDxSurfaceVideo[dwVideo];
                }
                if( ( peDxVideoPort->cAutoflipVbi > 0 ) && ( dwVBI != (DWORD) -1 ) )
                {
                    pGetCurrentAutoflipOut->hVBISurface =
                        peDxVideoPort->apeDxSurfaceVbi[dwVBI];
                }
                pGetCurrentAutoflipOut->bPolarity = GetPolarityOutInfo.bPolarity;
            }
        }

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

        pGetCurrentAutoflipOut->ddRVal    = dwRet;
    }
}

/******************************Public*Routine******************************\
* VOID DxGetPreviousAutoflip
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetPreviousAutoflip(
    DDGETAUTOFLIPIN*  pGetPreviousAutoflipIn,
    DDGETAUTOFLIPOUT* pGetPreviousAutoflipOut
    )
{
    DWORD                       dwRet;
    DXOBJ*                      pDxObjDirectDraw;
    DXOBJ*                      pDxObjVideoPort;
    DXOBJ*                      pDxObjTarget;
    DXOBJ*                      pDxObjCurrent;
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    EDD_DXVIDEOPORT*            peDxVideoPort;
    EDD_DXSURFACE*              peDxTarget;
    EDD_DXSURFACE*              peDxPrevious;
    DDGETPOLARITYININFO         GetPolarityInInfo;
    DDGETPOLARITYOUTINFO        GetPolarityOutInfo;
    DDGETPREVIOUSAUTOFLIPININFO GetPreviousAutoflipInInfo;
    DDGETPREVIOUSAUTOFLIPOUTINFO GetPreviousAutoflipOutInfo;
    KIRQL                       OldIrql;
    DWORD                       dwVideo;
    DWORD                       dwVBI;

    pGetPreviousAutoflipOut->ddRVal = DDERR_INVALIDPARAMS;
    if (pGetPreviousAutoflipIn == NULL)
    {
        return;
    }


    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pGetPreviousAutoflipIn->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pGetPreviousAutoflipIn->hVideoPort;
    if ((pDxObjDirectDraw != NULL) &&
        (pDxObjVideoPort != NULL))
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
        peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

        ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
            "Invalid DirectDraw object");
        ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
            "Invalid VideoPort object");
        ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
            "Surface, VideoPort, and DirectDraw objects don't match");
        ASSERTDX(peDxVideoPort->dwVPFlags & DDVP_AUTOFLIP,
            "Not currently autoflipping");

        GetPolarityInInfo.lpVideoPortData = peDxVideoPort;

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        if ((peDxDirectDraw->bLost) ||
            (peDxVideoPort->bLost))
        {
            KdPrint(("DxGetPreviousAutoflip: Objects are lost\n"));
            dwRet = DDERR_SURFACELOST;
        }
        else
        {
            dwRet = DDERR_UNSUPPORTED;
            if (peDxDirectDraw->DxApiInterface.DxGetPolarity)
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxGetPolarity(
                                        peDxDirectDraw->HwDeviceExtension,
                                        &GetPolarityInInfo,
                                        &GetPolarityOutInfo);
            }

            if (dwRet != DD_OK)
            {
                KdPrint(("DxGetPreviousAutoflip: Driver failed GetPolarity\n"));
            }
            else
            {
                // Determine which field is currently receiving the data.  If they
                // are software autoflipping, I can do that myself; otherwise, I
                // have to call the HAL
                //
                // This is complicated by the facts that:
                // 1) Skipping may be enabled.
                //  3) When interleaving, they flip every other field, but its not
                //     guarenteed that the flip always occurs between the even and the
                //     odd fields.
                //
                // When software autoflipping, there is an issue that if this
                // function is called between the time that the IRQ occured
                // and the time that the DPC ran, this function would return
                // the wrong surface. Since fixing this requires that we do all
                // of the work at IRQ time (bad), we can probably assume that
                // this will always be the case since anybody using this
                // function would be calling it during the IRQ callback.  We
                // will therefore work around it.

                dwVideo = (DWORD) -1;
                dwVBI = (DWORD) -1;
                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP )
                {
                    dwVideo = peDxVideoPort->iCurrentVideo;
                }
                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI )
                {
                    dwVBI = peDxVideoPort->iCurrentVbi;
                }
                if( ( dwVideo == (DWORD) -1 ) && ( dwVBI == (DWORD) -1 ) )
                {
                    GetPreviousAutoflipInInfo.lpVideoPortData = peDxVideoPort;
                    GetPreviousAutoflipOutInfo.dwSurfaceIndex = 0;
                    GetPreviousAutoflipOutInfo.dwVBISurfaceIndex = 0;
                    if (peDxDirectDraw->DxApiInterface.DxGetPreviousAutoflip)
                    {
                        dwRet = peDxDirectDraw->DxApiInterface.DxGetPreviousAutoflip(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &GetPreviousAutoflipInInfo,
                                    &GetPreviousAutoflipOutInfo);
                    }
                    dwVideo = GetPreviousAutoflipOutInfo.dwSurfaceIndex;
                    dwVBI = GetPreviousAutoflipOutInfo.dwVBISurfaceIndex;
                }

                pGetPreviousAutoflipOut->hVideoSurface = NULL;
                pGetPreviousAutoflipOut->hVBISurface = NULL;
                if( ( peDxVideoPort->cAutoflipVideo > 0 ) && ( dwVideo != (DWORD) -1 ) )
                {
                    pGetPreviousAutoflipOut->hVideoSurface =
                        peDxVideoPort->apeDxSurfaceVideo[dwVideo];
                }
                if( ( peDxVideoPort->cAutoflipVbi > 0 ) && ( dwVBI != (DWORD) -1 ) )
                {
                    pGetPreviousAutoflipOut->hVBISurface =
                        peDxVideoPort->apeDxSurfaceVbi[dwVBI];
                }
                pGetPreviousAutoflipOut->bPolarity =
                    ( GetPolarityOutInfo.bPolarity == FALSE );  // invert
            }
        }

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

        pGetPreviousAutoflipOut->ddRVal    = dwRet;
    }
}

/******************************Public*Routine******************************\
* BOOL bDxModifyPassiveEventList
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDxModifyPassiveEventList(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    BOOL                bAdd,           // TRUE to add, FALSE to delete
    DWORD               dwEvent,
    LPDD_NOTIFYCALLBACK pfnCallBack,
    PVOID               pContext
    )
{
    BOOL            bRet;
    DXAPI_EVENT*    pDxEvent;
    DXAPI_EVENT*    pDxEvent_New;
    DXAPI_EVENT*    pDxEvent_Previous;
    KIRQL           OldIrql;

    bRet = FALSE;                       // Assume failure

    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL, "Expected passive level");
    ASSERTDX((bAdd == FALSE) || (bAdd == TRUE), "Bad boolean");

    if (bAdd)
    {
        pDxEvent_New = (DXAPI_EVENT*) ExAllocatePoolWithTag(PagedPool,
                                                            sizeof(*pDxEvent),
                                                            'eddG');

        if (pDxEvent_New == NULL)
            return(FALSE);

        RtlZeroMemory(pDxEvent_New, sizeof(*pDxEvent_New));
    }

    // We must synchronize additions or deletions to the passive-level
    // event list via our devlock.

    ASSERTDX(gpfnLockDevice, "bDxModifyPassiveEventList: gpfnLockDevice is NULL");
    gpfnLockDevice(peDxDirectDraw->hdev);

    if (peDxDirectDraw->bLost)
    {
        KdPrint(("bDxModifyPassiveEventList: Object is lost\n"));
    }
    else
    {
        // First, try to find this event in the list:

        pDxEvent_Previous = NULL;

        for (pDxEvent = peDxDirectDraw->pDxEvent_PassiveList;
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            if ((pDxEvent->dwEvent     == dwEvent)     &&
                (pDxEvent->pfnCallBack == pfnCallBack) &&
                (pDxEvent->pContext    == pContext))
            {
                break;
            }

            pDxEvent_Previous = pDxEvent;
        }
         
        // It's a failure when:
        //
        //    1) If adding, the same event is already in the list;
        //    2) If deleting, the event is not in the list.

        if ((bAdd) == (pDxEvent == NULL))
        {
            if (bAdd)
            {
                // Add the event.

                pDxEvent_New->peDxDirectDraw = peDxDirectDraw;
                pDxEvent_New->dwEvent        = dwEvent;
                pDxEvent_New->dwIrqFlag      = 0;
                pDxEvent_New->pfnCallBack    = pfnCallBack;
                pDxEvent_New->pContext       = pContext;
                pDxEvent_New->pDxEvent_Next  = peDxDirectDraw->pDxEvent_PassiveList;

                peDxDirectDraw->pDxEvent_PassiveList = pDxEvent_New;

                bRet = TRUE;
            }
            else
            {
                // Delete the event.

                if (pDxEvent_Previous == NULL)
                {
                    ASSERTDX(peDxDirectDraw->pDxEvent_PassiveList == pDxEvent,
                        "Deletion code is confused");

                    peDxDirectDraw->pDxEvent_PassiveList = pDxEvent->pDxEvent_Next;
                }
                else
                {
                    pDxEvent_Previous->pDxEvent_Next = pDxEvent->pDxEvent_Next;
                }

                bRet = TRUE;
            }
        }
    }

    ASSERTDX(gpfnUnlockDevice, "bDxModifyPassiveEventList: gpfnUnlockDevice is NULL");
    gpfnUnlockDevice(peDxDirectDraw->hdev);

    if (bAdd)   // Add case
    {
        if (!bRet)
        {
            // Add failed, so free the new node we allocated up front:

            ExFreePool(pDxEvent_New);

            RIPDX("DD_DXAPI_REGISTER_EVENT: Event was already registered");
        }
    }
    else        // Remove case
    {
        if (bRet)
        {
            // Delete succeeded, so free the old node:

            ExFreePool(pDxEvent);
        }
        else
        {
            KdPrint(("DD_DXAPI_UNREGISTEREVENT: Couldn't find an event registered with those\n"));
            KdPrint(("same parameters, so the unregister failed.\n"));
            RIPDX("This will probably cause a leak of non-paged memory!");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bDxModifyDispatchEventList
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDxModifyDispatchEventList(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    EDD_DXVIDEOPORT*    peDxVideoPort,
    BOOL                bAdd,           // TRUE to add, FALSE to delete
    DWORD               dwEvent,
    DWORD               dwIrqFlag,
    LPDD_NOTIFYCALLBACK pfnCallBack,
    PVOID               pContext,
    DWORD               dwListEntry
    )
{
    BOOL                    bRet;
    DXAPI_EVENT*            pDxEvent;
    DXAPI_EVENT*            pDxEvent_New;
    DXAPI_EVENT*            pDxEvent_Previous;
    KIRQL                   OldIrql;

    bRet = FALSE;                       // Assume failure

    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL, "Expected passive level");
    ASSERTDX((bAdd == FALSE) || (bAdd == TRUE), "Bad boolean");

    // The event list is traversed at dispatch-level, so needs
    // to be allocated non-paged.

    if (bAdd)
    {
        pDxEvent_New = (DXAPI_EVENT*) ExAllocatePoolWithTag(NonPagedPool,
                                                            sizeof(*pDxEvent),
                                                            'eddG');
        if (pDxEvent_New == NULL)
            return(FALSE);

        RtlZeroMemory(pDxEvent_New, sizeof(*pDxEvent_New));
    }

    // We must synchronize additions or deletions to the dispatch-level
    // event list via our spin lock.  Note that this spinlock (of course)
    // raises our IRQL level, which means we can't touch any pageable code!

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    if ((peDxDirectDraw->bLost) ||
        ((peDxVideoPort != NULL) && (peDxVideoPort->bLost)))
    {
        KdPrint(("bDxModifyDispatchEventList: Objects are lost\n"));
    }
    else
    {
        // First, try to find this event in the list:

        pDxEvent_Previous = NULL;

        for (pDxEvent = peDxDirectDraw->pDxEvent_DispatchList[dwListEntry];
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            if ((pDxEvent->dwEvent     == dwEvent)     &&
                (pDxEvent->dwIrqFlag   == dwIrqFlag)   &&
                (pDxEvent->pfnCallBack == pfnCallBack) &&
                (pDxEvent->pContext    == pContext))
            {
                break;
            }

            pDxEvent_Previous = pDxEvent;
        }

        // It's a failure when:
        //
        //    1) If adding, the same event is already in the list;
        //    2) If deleting, the event is not in the list.

        if ((bAdd) == (pDxEvent == NULL))
        {
            if (bAdd)
            {
                // Add the event.

                pDxEvent_New->peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
                pDxEvent_New->peDxVideoPort  = peDxVideoPort;
                pDxEvent_New->dwEvent        = dwEvent;
                pDxEvent_New->dwIrqFlag      = dwIrqFlag;
                pDxEvent_New->pfnCallBack    = pfnCallBack;
                pDxEvent_New->pContext       = pContext;
                pDxEvent_New->pDxEvent_Next  = peDxDirectDraw->pDxEvent_DispatchList[dwListEntry];

                peDxDirectDraw->pDxEvent_DispatchList[dwListEntry] = pDxEvent_New;

                bRet = TRUE;
            }
            else
            {
                // Delete the event.

                if (pDxEvent_Previous == NULL)
                {
                    ASSERTDX(peDxDirectDraw->pDxEvent_DispatchList[dwListEntry] == pDxEvent,
                        "Deletion code is confused");

                    peDxDirectDraw->pDxEvent_DispatchList[dwListEntry]
                        = pDxEvent->pDxEvent_Next;
                }
                else
                {
                    pDxEvent_Previous->pDxEvent_Next = pDxEvent->pDxEvent_Next;
                }

                bRet = TRUE;
            }
        }
    }

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    if (bAdd)   // Add case
    {
        if (!bRet)
        {
            // Add failed, so free the new node we allocated up front:

            ExFreePool(pDxEvent_New);
        }
    }
    else        // Remove case
    {
        if (bRet)
        {
            // Delete succeeded, so free the old node:

            ExFreePool(pDxEvent);
        }
        else
        {
            KdPrint(("DD_DXAPI_UNREGISTEREVENT: Couldn't find an event registered with those\n"));
            KdPrint(("same parameters, so the unregister failed.\n"));
            RIPDX("This will probably cause a leak of non-paged memory!");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vDxEnableInterrupts
*
* NOTE: Drivers may not fail DxEnableIrq.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDxEnableInterrupts(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    DWORD               dwLine
    )
{
    DWORD           dwIRQSources = 0;
    KIRQL           OldIrql;
    DXAPI_EVENT*    pDxEvent;
    DDENABLEIRQINFO EnableIrqInfo;
    DWORD           dwRet;
    DWORD           i;

    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL, "Expected passive level");
    ASSERTDX(peDxDirectDraw->DxApiInterface.DxEnableIrq != NULL,
        "DxEnableIrq must be hooked if supporting interrupts.");

    // We acquire both the devlock and the spinlock to ensure that no other
    // activity in the driver is occurring while interrupts are enabled.
    //
    // The motivation for acquiring both (the spinlock could have been
    // sufficient) is that we want to allow drivers to touch the CRTC
    // registers in their interrupt enable routine (typically, both the
    // display driver and the enable interrupt routine use CRTC registers,
    // the usage of which must be synchronized).

    ASSERTDX(gpfnLockDevice, "vDxEnableInterrupts: gpfnLockDevice is NULL");
    gpfnLockDevice(peDxDirectDraw->hdev);

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    // Compute the interrupts that are to be enabled by traversing the
    // active event list:

    for( i = 0; i < NUM_DISPATCH_LISTS; i++ )
    {
        for (pDxEvent = peDxDirectDraw->pDxEvent_DispatchList[i];
            pDxEvent != NULL;
            pDxEvent = pDxEvent->pDxEvent_Next)
        {
            dwIRQSources |= pDxEvent->dwIrqFlag;
        }
    }

    EnableIrqInfo.dwIRQSources = dwIRQSources;
    EnableIrqInfo.dwLine       = dwLine;
    EnableIrqInfo.IRQCallback  = DxIrqCallBack;
    EnableIrqInfo.lpIRQData    = &peDxDirectDraw->IrqData;

    dwRet = peDxDirectDraw->DxApiInterface.DxEnableIrq(
                                peDxDirectDraw->HwDeviceExtension,
                                &EnableIrqInfo,
                                NULL);

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    ASSERTDX(gpfnUnlockDevice, "vDxEnableInterrupts: gpfnUnlockDevice is NULL");
    gpfnUnlockDevice(peDxDirectDraw->hdev);

    ASSERTDX(dwRet == DD_OK, "vDxEnableInterrupts: Driver failed DxEnableIrq");
}

/******************************Public*Routine******************************\
* DWORD dwDxRegisterEvent
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
dwDxRegisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    BOOL                bRegister       // TRUE if register, FALSE if unregister
    )
{
    DWORD               dwRet;
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    DWORD               dwEvent;
    DWORD               dwIrqFlag;
    BOOL                bPassiveEvent;
    BOOL                bDispatchEvent;
    DWORD               dwLine;

    dwRet = DDERR_GENERIC;              // Assume failure

    // Passive level is required because we have to acquire the devlock
    // for the RESCHANGE and DOSBOX notifications.

    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL, "Expected passive level");
    ASSERTDX(pRegisterEvent->pfnCallback != NULL, "Null callback specified");
    ASSERTDX(pRegisterEvent->hDirectDraw != NULL, "Null hDirectDraw specified");

    pDxObjDirectDraw = (DXOBJ*) pRegisterEvent->hDirectDraw;
    if (pDxObjDirectDraw != NULL)
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;

        // Note that we don't support the hooking of DDEVENT_CLOSEDIRECTDRAW,
        // DDEVENT_CLOSESURFACE, or DDEVENT_CLOSEVIDEOPORT because those are
        // always explictly registered with the object open call.  If multiple
        // clients want object close notification, they should each open their
        // own object instances.

        dwEvent = pRegisterEvent->dwEvents;

        // Memphis doesn't bother checking to verify that 'dwParam1' and
        // 'dwParam2' are zero when unused, so we won't either.

        bPassiveEvent = FALSE;
        bDispatchEvent = FALSE;
        peDxVideoPort = NULL;
        dwLine = 0;
        dwIrqFlag = 0;

        switch (dwEvent)
        {
        case DDEVENT_VP_VSYNC:
        case DDEVENT_VP_LINE:

            ASSERTDX(pRegisterEvent->dwParam1 != NULL,
                "dwParam1 should be videoport handle");

            pDxObjVideoPort = (DXOBJ*) pRegisterEvent->dwParam1;
            if (pDxObjVideoPort != NULL)
            {
                peDxVideoPort   = pDxObjVideoPort->peDxVideoPort;

                ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
                    "dwParam1 should be videoport handle");

                if (dwEvent == DDEVENT_VP_LINE)
                {
                    dwIrqFlag = DDIRQ_VPORT0_LINE;      // We're going to shift this...

                    // We make it so that the 'dwLine' parameter is non-zero only
                    // when the event is registered, not unregistered,

                    dwLine = (bRegister) ? (DWORD) pRegisterEvent->dwParam2 : 0;
                }
                else
                {
                    dwIrqFlag = DDIRQ_VPORT0_VSYNC;     // We're going to shift this...
                }

                dwIrqFlag <<= (2 * peDxVideoPort->dwVideoPortID);

                bDispatchEvent = TRUE;
            }
            break;

        case DDEVENT_DISPLAY_VSYNC:

            dwIrqFlag = DDIRQ_DISPLAY_VSYNC;
            bDispatchEvent = TRUE;
            break;

        case DDEVENT_PRERESCHANGE:
        case DDEVENT_POSTRESCHANGE:
        case DDEVENT_PREDOSBOX:
        case DDEVENT_POSTDOSBOX:

            bPassiveEvent = TRUE;
            break;

        default:

            KdPrint(("dwDxRegisterEvent: Invalid dwEvents specified\n"));
            dwRet = DDERR_UNSUPPORTED;
            break;
        }

        if (bPassiveEvent)
        {
            if (bDxModifyPassiveEventList(peDxDirectDraw,
                                          bRegister,
                                          dwEvent,
                                          pRegisterEvent->pfnCallback,
                                          pRegisterEvent->pContext))
            {
                dwRet = DD_OK;
            }
        }
        else if (bDispatchEvent)
        {
            // First, verify that the requested interrupt is supported:

            if (!(peDxDirectDraw->dwIRQCaps & dwIrqFlag))
            {
                KdPrint(("dwDxRegisterEvent: Interrupt not supported by driver.\n"));
                dwRet = DDERR_UNSUPPORTED;
            }
            else
            {
                if (bDxModifyDispatchEventList(peDxDirectDraw,
                                               peDxVideoPort,
                                               bRegister,
                                               dwEvent,
                                               dwIrqFlag,
                                               pRegisterEvent->pfnCallback,
                                               pRegisterEvent->pContext,
                                               CLIENT_DISPATCH_LIST))
                {
                    vDxEnableInterrupts(peDxDirectDraw, dwLine);
                    dwRet = DD_OK;
                }
            }
        }
    }
    return(dwRet);
}

/******************************Public*Routine******************************\
* VOID DxRegisterEvent
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxRegisterEvent(
    DDREGISTERCALLBACK*    pRegisterEvent,
    DWORD*              pdwRet
    )
{
    if (pRegisterEvent == NULL)
    {
        *pdwRet = DDERR_INVALIDPARAMS;
    }
    else
    {
        *pdwRet = dwDxRegisterEvent(pRegisterEvent, TRUE);
    }
}

/******************************Public*Routine******************************\
* VOID DxUnregisterEvent
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxUnregisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    DWORD*              pdwRet
    )
{
    if (pRegisterEvent == NULL)
    {
        *pdwRet = DDERR_INVALIDPARAMS;
    }
    else
    {
        *pdwRet = dwDxRegisterEvent(pRegisterEvent, FALSE);
    }
}

/******************************Public*Routine******************************\
* VOID DxGetPolarity
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetPolarity(
    DDGETPOLARITYIN*    pGetPolarityIn,
    DDGETPOLARITYOUT*   pGetPolarityOut
    )
{
    DWORD                       dwRet;
    DXOBJ*                      pDxObjDirectDraw;
    DXOBJ*                      pDxObjVideoPort;
    DXOBJ*                      pDxObjTarget;
    DXOBJ*                      pDxObjCurrent;
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    EDD_DXVIDEOPORT*            peDxVideoPort;
    DDGETPOLARITYININFO         GetPolarityInInfo;
    DDGETPOLARITYOUTINFO        GetPolarityOutInfo;
    KIRQL                       OldIrql;

    pGetPolarityOut->ddRVal = DDERR_INVALIDPARAMS;
    if (pGetPolarityIn == NULL)
    {
        return;
    }

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pGetPolarityIn->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pGetPolarityIn->hVideoPort;
    if ((pDxObjDirectDraw != NULL) &&
        (pDxObjVideoPort != NULL))
    {
        peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
        peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

        ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
            "Invalid DirectDraw object");
        ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
            "Invalid VideoPort object");
        ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
            "Surface, VideoPort, and DirectDraw objects don't match");

        GetPolarityInInfo.lpVideoPortData = peDxVideoPort;
        GetPolarityOutInfo.bPolarity = 0;

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        if ((peDxDirectDraw->bLost) ||
            (peDxVideoPort->bLost))
        {
            KdPrint(("DxGetPolarity: Objects are lost\n"));
            dwRet = DDERR_SURFACELOST;
        }
        else
        {
            if (peDxDirectDraw->DxApiInterface.DxGetPolarity)
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxGetPolarity(
                                        peDxDirectDraw->HwDeviceExtension,
                                        &GetPolarityInInfo,
                                        &GetPolarityOutInfo);
            }
        }

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

        pGetPolarityOut->ddRVal = dwRet;
        pGetPolarityOut->bPolarity = GetPolarityOutInfo.bPolarity;
    }
}

/******************************Public*Routine******************************\
* VOID DxAddVpCaptureBuffer
*
*  01-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxAddVpCaptureBuffer(
    DDADDVPCAPTUREBUFF* pAddCaptureBuff,
    DWORD*   		pdwRet
    )
{
    DXOBJ*                      pDxObjCapture;
    EDD_DXCAPTURE*              peDxCapture;
    EDD_DXVIDEOPORT*            peDxVideoPort;
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    DWORD                       dwTop;
    KIRQL                       OldIrql;

    *pdwRet = DDERR_INVALIDPARAMS;
    if (pAddCaptureBuff == NULL)
    {
        return;
    }

    pDxObjCapture = (DXOBJ*) pAddCaptureBuff->hCapture;
    if (pDxObjCapture != NULL)
    {
        peDxCapture   = pDxObjCapture->peDxCapture;

        ASSERTDX(pDxObjCapture->iDxType == DXT_CAPTURE,
            "Invalid Capture object");
        ASSERTDX(pAddCaptureBuff->pKEvent != NULL,
            "No KEvent specified");
        ASSERTDX(pAddCaptureBuff->pMDL != NULL,
            "No MDL specified");
        ASSERTDX((pAddCaptureBuff->dwFlags != 0 ) &&
                 !(pAddCaptureBuff->dwFlags & ~(DDADDBUFF_SYSTEMMEMORY|DDADDBUFF_NONLOCALVIDMEM|DDADDBUFF_INVERT)),
            "Invalid flags specified");
        ASSERTDX(pAddCaptureBuff->lpBuffInfo != NULL,
            "lpBuffInfo not specified");

        *pdwRet = DDERR_INVALIDOBJECT;
        peDxVideoPort = peDxCapture->peDxVideoPort;
        if( peDxVideoPort != NULL )
        {
            peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

            KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

            if( !( peDxVideoPort->bLost ) &&
                !( peDxCapture->bLost ) )
            {
                // Is the queue full?

                dwTop = peDxCapture->dwTop;
                if( ( peDxCapture->CaptureQueue[dwTop].flFlags & DD_DXCAPTUREBUFF_FLAG_IN_USE ) ||
                    !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON ) )
                {
                    *pdwRet = DDERR_CURRENTLYNOTAVAIL;
                }
                else
                {
                    // Save the new buffer in the queque

                    peDxCapture->CaptureQueue[dwTop].dwClientFlags =
                        pAddCaptureBuff->dwFlags;
                    peDxCapture->CaptureQueue[dwTop].pBuffMDL =
                        pAddCaptureBuff->pMDL;
                    peDxCapture->CaptureQueue[dwTop].pBuffKEvent =
                        pAddCaptureBuff->pKEvent;
                    peDxCapture->CaptureQueue[dwTop].lpBuffInfo =
                        (PVOID) pAddCaptureBuff->lpBuffInfo;
                    peDxCapture->CaptureQueue[dwTop].flFlags = DD_DXCAPTUREBUFF_FLAG_IN_USE;
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_CAPTURING;

                    if( ++(peDxCapture->dwTop) >= DXCAPTURE_MAX_CAPTURE_BUFFS )
                    {
                        peDxCapture->dwTop = 0;
                    }
                    *pdwRet = DD_OK;
                }
            }
            KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxInternalFlushVpCaptureBuffs
*
*  12-Apr-1999 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxInternalFlushVpCaptureBuffs(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXCAPTURE*      peDxCapture
    )
{
    DDTRANSFERININFO    ddTransferIn;
    DDTRANSFEROUTINFO   ddTransferOut;
    LPDDCAPBUFFINFO     lpBuffInfo;
    DWORD               i;

    // Turn off all video port capture if nobody else is capturing

    if( peDxVideoPort->peDxCapture && ( peDxCapture->peDxCaptureNext == NULL ) )
    {
        peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_CAPTURING;
    }

    // If a buffer is in the queue and the busmaster has not yet been
    // initiated, clear it now so we don't do it. If the busmaster has
    // already been initiated, we will tell the miniport to stop it now.

    peDxCapture->dwTop = peDxCapture->dwBottom = 0;
    for( i = 0; i < DXCAPTURE_MAX_CAPTURE_BUFFS; i++ )
    {
        if( peDxCapture->CaptureQueue[i].flFlags & DD_DXCAPTUREBUFF_FLAG_IN_USE )
        {
            if( peDxCapture->CaptureQueue[i].flFlags & DD_DXCAPTUREBUFF_FLAG_WAITING )
            {
                ddTransferIn.dwStartLine = 0;
                ddTransferIn.dwEndLine = 0;
                ddTransferIn.dwTransferFlags = DDTRANSFER_CANCEL;
                ddTransferIn.lpDestMDL = NULL;
                ddTransferIn.lpSurfaceData = NULL;
                ddTransferIn.dwTransferID = ((ULONG_PTR)peDxCapture & ~0xf) + i;

                if (peDxDirectDraw->DxApiInterface.DxTransfer)
                {
                    peDxDirectDraw->DxApiInterface.DxTransfer(
                        peDxDirectDraw->HwDeviceExtension,
                        &ddTransferIn,
                        &ddTransferOut);
                }

                peDxCapture->CaptureQueue[i].peDxSurface->flFlags
                    &= ~DD_DXSURFACE_FLAG_TRANSFER;
            }

            lpBuffInfo = (LPDDCAPBUFFINFO) peDxCapture->CaptureQueue[i].lpBuffInfo;
            lpBuffInfo->bPolarity = 0;
            lpBuffInfo->dwFieldNumber = 0;
            lpBuffInfo->ddRVal = (DWORD) DDERR_GENERIC;
            peDxCapture->CaptureQueue[i].flFlags = 0;

            KeSetEvent( peDxCapture->CaptureQueue[i].pBuffKEvent, 0, 0 );
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxFlushVpCaptureBuffs
*
*  01-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxFlushVpCaptureBuffs(
    DWORD**     hCapture,
    DWORD*   	pdwRet
    )
{
    DXOBJ*              pDxObjCapture;
    EDD_DXCAPTURE*      peDxCapture;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    KIRQL               OldIrql;

    *pdwRet = DDERR_INVALIDPARAMS;
    if (hCapture == NULL)
    {
        return;
    }

    ASSERTDX(KeGetCurrentIrql() <= DISPATCH_LEVEL,
        "DxFlushCaptureBuffs: Call less than or equl to DISPATCH_LEVEL (it accesses the dispatch table)");

    pDxObjCapture = (DXOBJ*) (*hCapture);
    if (pDxObjCapture != NULL)
    {
        peDxCapture   = pDxObjCapture->peDxCapture;
        peDxVideoPort = peDxCapture->peDxVideoPort;
        peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        DxInternalFlushVpCaptureBuffs( peDxDirectDraw, peDxVideoPort, peDxCapture );

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

        *pdwRet = DD_OK;
    }
}

/******************************Public*Routine******************************\
* VOID DxIrqCallBack
*
* This routine is called by the miniport at interrupt time to notify us
* of interrupt-based events.  We simply queue a DPC to handle the request
* at the more appropriate dispatch level, instead of interrupt level that
* we're currently at.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxIrqCallBack(
    DX_IRQDATA* pIrqData
    )
{
    EDD_DXDIRECTDRAW* peDxDirectDraw;

    // We always tell the miniport to call us back with the pointer to
    // &peDxDirectDraw->IrqData, so we can get back to the original
    // peDxDirectDraw by subtracting the offset.  If we ever need to
    // change this in the future, we can simply add a field to DX_IRQDATA
    // to point to the context:

    peDxDirectDraw = (EDD_DXDIRECTDRAW*)
        ((BYTE*) pIrqData - offsetof(EDD_DXDIRECTDRAW, IrqData));

    // It's okay if KeInsertQueueDpc fails because the same DPC for a
    // previous interrupt is still queued -- the miniport always ORs
    // its interrupt flags into pIrqData->dwIrqflags.

    KeInsertQueueDpc(&peDxDirectDraw->EventDpc, pIrqData, NULL);
}

/******************************Public*Routine******************************\
* VOID DxGetIrqFlags
*
* Out interrupt processing code runs at DPC level, and can be interrupt
* by an ISR.  Consequently, when we look at the interrupt status, we
* must synchronize with the ISR.  This is accomplished by having
* VideoPortSynchronizeExecution (which does a KeSynchronizeExecution)
* call-back to this routine.
*
* All we do here is copy the flags to the device extension (actually,
* we use the EDD_DXDIRECTDRAW which is allocated one-to-one with the
* device extension).
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOLEAN
DxGetIrqFlags(
    PVOID   pvContext
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;

    peDxDirectDraw = (EDD_DXDIRECTDRAW*) pvContext;

    // Copy the flags to a safe place:

    peDxDirectDraw->dwSynchedIrqFlags = peDxDirectDraw->IrqData.dwIrqFlags;

    // We have to zero the current flags because the miniport always ORs
    // its flags in:

    peDxDirectDraw->IrqData.dwIrqFlags = 0;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DxEventDpc
*
* This routine does all the work of handling interrupt notification
* from the miniport.  It makes the synchronous call-backs to anyone
* who has hooked the particular event.
*
* Note that to be synchronous we're making the call-backs at dispatch
* level.  So if a callee doesn't require a truly synchronous notification,
* they should do nothing but kick off an event.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

// We can't call KeSynchronizeExecution directly, because we don't
// have the device's interrupt object.  Videoport.sys does, however.
// Unfortunately, 'video.h', which is used to access the videoport.sys
// routines, was never intended to be mixed with GDI and USER header
// files (among other problems, there are conflicts in the PEVENT and
// PVIDEO_POWER_MANAGEMENT structures).  So we define what prototypes
// we need here:

extern "C" {

typedef enum VIDEO_SYNCHRONIZE_PRIORITY {
    VpLowPriority,
    VpMediumPriority,
    VpHighPriority
} VIDEO_SYNCHRONIZE_PRIORITY, *PVIDEO_SYNCHRONIZE_PRIORITY;

typedef
BOOLEAN
(*PMINIPORT_SYNCHRONIZE_ROUTINE)(
    PVOID Context
    );

VOID
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE synchronizeRoutine,
    PVOID Context
    );

};

VOID
DxEventDpc(
    PKDPC   pDpc,
    PVOID   pvContext,
    PVOID   pvArgument1,
    PVOID   pvArgument2
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DX_IRQDATA*         pIrqData;
    DXAPI_EVENT*        pDxEvent;
    DWORD               dwIrqFlags;
    DWORD               i;

    pIrqData = (DX_IRQDATA*) pvArgument1;
    peDxDirectDraw = (EDD_DXDIRECTDRAW*) pvContext;

    // The ISR can be triggered even while we're processing the DPC for
    // its previous interrupt.  Consequently, we have to access the
    // interrupt flags in a routine that is synchronized to the ISR
    // routine.
    //
    // Note that we don't call KeSynchronizeExecution directly, because
    // we don't have the device's interrupt object.

    VideoPortSynchronizeExecution(peDxDirectDraw->HwDeviceExtension,
                                  VpMediumPriority,
                                  DxGetIrqFlags,
                                  peDxDirectDraw);

    dwIrqFlags = peDxDirectDraw->dwSynchedIrqFlags;

    // We must acquire a spinlock while traversing the event list to
    // protect against simultaneous modifications to the list.

    KeAcquireSpinLockAtDpcLevel(&peDxDirectDraw->SpinLock);

    // We call the callbacks registered by the client before we
    // call the ones that we registered so we give the client a chance
    // to skip fields before we execute our skip logic.  This is why
    // we keep two dispatch lists.

    for (i = 0; i < NUM_DISPATCH_LISTS; i++)
    {
        for (pDxEvent = peDxDirectDraw->pDxEvent_DispatchList[i];
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            if (pDxEvent->dwIrqFlag & dwIrqFlags)
            {
                pDxEvent->pfnCallBack(pDxEvent->dwEvent, pDxEvent->pContext, 0, 0);
            }
        }
    }

    // If it was a busmaster IRQ, take care of them as well

    if (dwIrqFlags & DDIRQ_BUSMASTER)
    {
        for (pDxEvent = peDxDirectDraw->pDxEvent_CaptureList;
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            pDxEvent->pfnCallBack(pDxEvent->dwEvent, pDxEvent->pContext, 0, 0);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&peDxDirectDraw->SpinLock);
}

/******************************Public*Routine******************************\
* VOID vDxFlip
*
* Assumes the spinlock is held.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDxFlip(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    DWORD               dwFlags
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DWORD               iOldVideo;
    DWORD               iOldVbi;
    DWORD               iOldOverlay;
    DWORD               iNewVideo;
    DWORD               iNewVbi;
    DWORD               iNewOverlay;
    DDFLIPVIDEOPORTINFO FlipVideoPortInfo;
    DDFLIPOVERLAYINFO   FlipOverlayInfo;
    DWORD               dwRet;
    DWORD               dwTemp;

    ASSERTDX(KeGetCurrentIrql() == DISPATCH_LEVEL, "Expected held spinlock");

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    if( dwFlags == DDVPFLIP_VBI )
    {
        if (peDxVideoPort->cAutoflipVbi != 0)
        {
            // Flip videoport VBI surface:

            iOldVbi = peDxVideoPort->iCurrentVbi;
            iNewVbi = iOldVbi + 1;
            if (iNewVbi >= peDxVideoPort->cAutoflipVbi)
                iNewVbi = 0;
            peDxVideoPort->iCurrentVbi = iNewVbi;

            FlipVideoPortInfo.lpVideoPortData
                            = peDxVideoPort;
            FlipVideoPortInfo.lpCurrentSurface
                            = peDxVideoPort->apeDxSurfaceVbi[iOldVbi];
            FlipVideoPortInfo.lpTargetSurface
                            = peDxVideoPort->apeDxSurfaceVbi[iNewVbi];
            FlipVideoPortInfo.dwFlipVPFlags = DDVPFLIP_VBI;

            if (peDxDirectDraw->DxApiInterface.DxFlipVideoPort)
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxFlipVideoPort(
                        peDxDirectDraw->HwDeviceExtension,
                        &FlipVideoPortInfo,
                        NULL);
            }
        }
    }

    else if( dwFlags == DDVPFLIP_VIDEO )
    {
        if (peDxVideoPort->cAutoflipVideo != 0)
        {
            // Flip videoport video surface:

            iOldVideo = peDxVideoPort->iCurrentVideo;
            iNewVideo = iOldVideo + 1;
            if (iNewVideo >= peDxVideoPort->cAutoflipVideo)
                iNewVideo = 0;
            peDxVideoPort->iCurrentVideo = iNewVideo;

            FlipVideoPortInfo.lpVideoPortData
                            = peDxVideoPort;
            FlipVideoPortInfo.lpCurrentSurface
                            = peDxVideoPort->apeDxSurfaceVideo[iOldVideo];
            FlipVideoPortInfo.lpTargetSurface
                            = peDxVideoPort->apeDxSurfaceVideo[iNewVideo];
            FlipVideoPortInfo.dwFlipVPFlags
                            = DDVPFLIP_VIDEO;

            if (peDxDirectDraw->DxApiInterface.DxFlipVideoPort)
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxFlipVideoPort(
                        peDxDirectDraw->HwDeviceExtension,
                        &FlipVideoPortInfo,
                        NULL);
            }

            // Flip overlay surface:

            if( ( peDxVideoPort->apeDxSurfaceVideo[0] != NULL ) &&
                ( peDxVideoPort->apeDxSurfaceVideo[0]->ddsCaps & DDSCAPS_OVERLAY ) &&
                ( ( peDxVideoPort->apeDxSurfaceVideo[0]->dwOverlayFlags & DDOVER_AUTOFLIP ) ||
                ( peDxVideoPort->bSoftwareAutoflip ) ) )
            {
                // If there are two surfaces, flip to the opposite surface.  If
                // there are more than two surfaces, flip to dwNumAutoflip - 2.

                dwTemp = 1;
                if( peDxVideoPort->cAutoflipVideo != 2 )
                {
                    dwTemp++;
                }
                dwTemp  = peDxVideoPort->iCurrentVideo +
                    peDxVideoPort->cAutoflipVideo - dwTemp;
                if( dwTemp >= peDxVideoPort->cAutoflipVideo )
                {
                    dwTemp -= peDxVideoPort->cAutoflipVideo;
                }

                FlipOverlayInfo.lpTargetSurface
                            = peDxVideoPort->apeDxSurfaceVideo[dwTemp];
                if( dwTemp == 0 )
                {
                    dwTemp = peDxVideoPort->cAutoflipVideo;
                }
                FlipOverlayInfo.lpCurrentSurface
                            = peDxVideoPort->apeDxSurfaceVideo[--dwTemp];
                FlipOverlayInfo.dwFlags = 0;

                if (peDxDirectDraw->DxApiInterface.DxFlipOverlay)
                {
                    dwRet = peDxDirectDraw->DxApiInterface.DxFlipOverlay(
                        peDxDirectDraw->HwDeviceExtension,
                        &FlipOverlayInfo,
                        NULL);
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDxBob
*
* Assumes the spinlock is held.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDxBob(
    EDD_DXVIDEOPORT*    peDxVideoPort
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DDBOBNEXTFIELDINFO  BobNextFieldInfo;
    DWORD               dwRet;
    DWORD               dwTemp;

    ASSERTDX(KeGetCurrentIrql() == DISPATCH_LEVEL, "Expected held spinlock");

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    // Get the current surface handle.  This is tricky because
    // dwCurrentBuffer tells us which surface the video port is
    // writting to - not which surface has the overlay.  Therefore,
    // we re-create the algorithm used in DoFlip to get the surface.

    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP )
    {
        dwTemp = 1;
        if( peDxVideoPort->cAutoflipVideo != 2 )
        {
	    dwTemp++;
        }
        dwTemp  = peDxVideoPort->iCurrentVideo +
            peDxVideoPort->cAutoflipVideo - dwTemp;
        if( dwTemp >= peDxVideoPort->cAutoflipVideo )
        {
            dwTemp -= peDxVideoPort->cAutoflipVideo;
        }
    }
    else
    {
        dwTemp = 0;
    }

    BobNextFieldInfo.lpSurface = peDxVideoPort->apeDxSurfaceVideo[dwTemp];

    if (peDxDirectDraw->DxApiInterface.DxBobNextField)
    {
        dwRet = peDxDirectDraw->DxApiInterface.DxBobNextField(
                    peDxDirectDraw->HwDeviceExtension,
                    &BobNextFieldInfo,
                    NULL);
    }
}

/******************************Public*Routine******************************\
* VOID vDxSkip
*
* Assumes the spinlock is held.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDxSkip(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    DWORD               dwFlags
    )
{
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    DDSKIPNEXTFIELDINFO     SkipNextFieldInfo;
    DWORD                   dwRet;

    ASSERTDX(KeGetCurrentIrql() == DISPATCH_LEVEL, "Expected held spinlock");

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    if (peDxDirectDraw->DxApiInterface.DxSkipNextField)
    {
        SkipNextFieldInfo.lpVideoPortData = peDxVideoPort;
        SkipNextFieldInfo.dwSkipFlags     = dwFlags;

        dwRet = peDxDirectDraw->DxApiInterface.DxSkipNextField(
                        peDxDirectDraw->HwDeviceExtension,
                        &SkipNextFieldInfo,
                        NULL);
    }
}

/******************************Public*Routine******************************\
* VOID IRQCapture
*
* This routine initiates video/VBI capture based on a video port VSYNC.
*
* NOTE: The spinlock is already held.
*
*  10-Jan-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID IRQCapture(
    EDD_DXVIDEOPORT* peDxVideoPort,
    EDD_DXDIRECTDRAW* peDxDirectDraw
    )
{
    DDGETCURRENTAUTOFLIPININFO  ddAutoflipInInfo;
    DDGETCURRENTAUTOFLIPOUTINFO ddAutoflipOutInfo;
    EDD_DXCAPTURE*       peDxCapture;
    LPDDCAPBUFFINFO      lpBuffInfo;
    DXCAPTUREBUFF*       lpBuff;
    DDTRANSFERININFO     ddTransferIn;
    DDTRANSFEROUTINFO    ddTransferOut;
    ULONGLONG            ullTimeStamp;
    PULONGLONG           pullTemp;
    ULONGLONG            rate;
    DWORD                dwVBIIndex;
    DWORD                dwVideoIndex;
    BOOL                 bStarved = TRUE;
    DWORD                ddRVal;

    // Get the current time stamp

    ullTimeStamp = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;
    ullTimeStamp = (ullTimeStamp & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ullTimeStamp & 0xFFFFFFFF) * 10000000 / rate;

    // If either the VBI or video is being hardware autoflipped, figure out
    // the correct buffers.

    dwVBIIndex = 0;
    dwVideoIndex = 0;
    if( ( ( peDxVideoPort->cAutoflipVbi > 1 ) &&
        !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI ) ) ||
        ( ( peDxVideoPort->cAutoflipVideo > 1 ) &&
        !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP ) ) )
    {
        ddAutoflipInInfo.lpVideoPortData = peDxVideoPort;
        ddAutoflipOutInfo.dwSurfaceIndex = 0;
        if (peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip)
        {
            ddRVal = peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip(
                            peDxDirectDraw->HwDeviceExtension,
                            &ddAutoflipInInfo,
                            &ddAutoflipOutInfo);
        }
        if( peDxVideoPort->cAutoflipVideo > 0 )
        {
            dwVideoIndex = ddAutoflipOutInfo.dwSurfaceIndex;
            if( dwVideoIndex-- == 0 )
            {
                dwVideoIndex = peDxVideoPort->cAutoflipVideo - 1;
            }
        }
        if( peDxVideoPort->cAutoflipVbi > 0 )
        {
            dwVBIIndex = ddAutoflipOutInfo.dwVBISurfaceIndex;
            if( dwVBIIndex-- == 0 )
            {
                dwVBIIndex = peDxVideoPort->cAutoflipVbi - 1;
            }
        }
    }

    // Which is the surface containing the most recent VBI data?

    if( ( peDxVideoPort->cAutoflipVbi > 0 ) &&
        ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI ) )
    {
        dwVBIIndex = peDxVideoPort->iCurrentVbi;
        if( dwVBIIndex-- == 0 )
        {
            dwVBIIndex = peDxVideoPort->cAutoflipVbi - 1;
        }
    }

    // Which is the surface containing the most recent video data?

    if( ( peDxVideoPort->cAutoflipVideo > 0 ) &&
        ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP ) )
    {
        dwVideoIndex = peDxVideoPort->iCurrentVideo;
        if( dwVideoIndex-- == 0 )
        {
            dwVideoIndex = peDxVideoPort->cAutoflipVideo - 1;
        }
    }

    // Look at each capture device to determine if it has to do a busmaster
    // or not

    peDxCapture = peDxVideoPort->peDxCapture;
    while( peDxCapture != NULL )
    {
        if( ( peDxCapture->CaptureQueue[peDxCapture->dwBottom].flFlags & DD_DXCAPTUREBUFF_FLAG_IN_USE ) &&
            !( peDxCapture->CaptureQueue[peDxCapture->dwBottom].flFlags & DD_DXCAPTUREBUFF_FLAG_WAITING ) )
        {
            bStarved = FALSE;

            if( peDxCapture->dwCaptureCountDown-- == 1 )
            {
                peDxCapture->dwCaptureCountDown = peDxCapture->dwCaptureEveryNFields;
                lpBuff = &(peDxCapture->CaptureQueue[peDxCapture->dwBottom]);

                // Fill in the buffer info

                lpBuffInfo = (LPDDCAPBUFFINFO) lpBuff->lpBuffInfo;
                lpBuffInfo->dwFieldNumber = peDxVideoPort->dwCurrentField;
                pullTemp = (PULONGLONG) &(lpBuffInfo->liTimeStamp);
                *pullTemp = ullTimeStamp;

                // Tell mini port to do the transfer

                ddTransferIn.dwStartLine = peDxCapture->dwStartLine;
                ddTransferIn.dwEndLine = peDxCapture->dwEndLine;
                ddTransferIn.dwTransferFlags = lpBuff->dwClientFlags;
                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_HALFLINES )
                {
                    ddTransferIn.dwTransferFlags |= DDTRANSFER_HALFLINES;
                }
                ddTransferIn.lpDestMDL = lpBuff->pBuffMDL;
                if( peDxCapture->flFlags & DD_DXCAPTURE_FLAG_VIDEO )
                {
                    ddTransferIn.lpSurfaceData = peDxVideoPort->apeDxSurfaceVideo[dwVideoIndex];
                }
                else
                {
                    ddTransferIn.lpSurfaceData = peDxVideoPort->apeDxSurfaceVbi[dwVBIIndex];
                }

                if (ddTransferIn.lpSurfaceData)
                {
                    ddTransferIn.dwTransferID = (ULONG_PTR) peDxCapture;
                    ddTransferIn.dwTransferID &= ~0xf;
                    ddTransferIn.dwTransferID |= peDxCapture->dwBottom;

                    ddRVal = DDERR_UNSUPPORTED;
                    if (peDxDirectDraw->DxApiInterface.DxTransfer)
                    {
                        ddRVal = peDxDirectDraw->DxApiInterface.DxTransfer(
                                peDxDirectDraw->HwDeviceExtension,
                                &ddTransferIn,
                                &ddTransferOut);
                    }
                }
                else
                {
                    ddRVal = DDERR_INVALIDPARAMS;
                }

                lpBuffInfo->ddRVal = ddRVal;
                if( ddRVal != DD_OK )
                {
                    // Set the KEvent now

                    KeSetEvent( lpBuff->pBuffKEvent, 0, 0 );
                    lpBuff->flFlags = 0;
                    lpBuff->pBuffKEvent = 0;
                }
                else
                {
                    // Mark the lucky surface as doing a transfer

                    lpBuffInfo->bPolarity = ddTransferOut.dwBufferPolarity;
                    lpBuff->peDxSurface = (EDD_DXSURFACE*) ddTransferIn.lpSurfaceData;
                    lpBuff->peDxSurface->flFlags |= DD_DXSURFACE_FLAG_TRANSFER;
                    lpBuff->flFlags |= DD_DXCAPTUREBUFF_FLAG_WAITING;
                }

                // Next time use the next buffer

                if( ++( peDxCapture->dwBottom ) >= DXCAPTURE_MAX_CAPTURE_BUFFS )
                {
                    peDxCapture->dwBottom = 0;
                }
            }
        }
        peDxCapture = peDxCapture->peDxCaptureNext;
    }

    if( bStarved )
    {
        peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_CAPTURING;
    }
}

/******************************Public*Routine******************************\
* VOID DxAutoflipDpc
*
* This routine handles 'software autoflipping' and is called at dispatch
* level when the miniport's videoport interrupt is triggered.  This routine
* can't be kept in 'win32k.sys' because it needs to be non-pageable.
*
* NOTE: The spinlock is already held.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxAutoflipDpc(
    DWORD       dwEvent,
    PVOID       pContext,
    DWORD       dwParam1,
    DWORD       dwParam2
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    DWORD               dwCurrentField;
    BOOL                bAdjustFirstWeave;
    BOOL                bSkipped;
    BOOL                bFlipped;

    ASSERTDX(KeGetCurrentIrql() == DISPATCH_LEVEL, "Expected dispath level");
    ASSERTDX(dwEvent == DDEVENT_VP_VSYNC, "Expected VP_VSYNC event");

    peDxVideoPort = (EDD_DXVIDEOPORT*) pContext;
    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    // If capturing, do it now

    if( ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_CAPTURING ) &&
        ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON ) )
    {
        IRQCapture(peDxVideoPort, peDxDirectDraw);
    }

    // Do we need to notify user mode that a vsync occurred?

    if ((peDxVideoPort->pNotifyEvent != NULL) &&
        (peDxVideoPort->pNotifyBuffer != NULL) &&
        (1 == InterlockedExchange( &peDxVideoPort->pNotifyBuffer->lDone, 0 ) ) )
    {
        DDGETCURRENTAUTOFLIPININFO  ddAutoflipInInfo;
        DDGETCURRENTAUTOFLIPOUTINFO ddAutoflipOutInfo;

        ULONGLONG                   ullTimeStamp;
        ULONGLONG                   rate;
        UINT                        dwVideoIndex;

        // Fill in the buffer

        peDxVideoPort->pNotifyBuffer->lField = -1;
        if ( peDxDirectDraw->DxApiInterface.DxGetPolarity )
        {
            DDGETPOLARITYININFO ddPolarityInInfo;
            DDGETPOLARITYOUTINFO ddPolarityOutInfo;
            ddPolarityInInfo.lpVideoPortData = peDxVideoPort;
            peDxDirectDraw->DxApiInterface.DxGetPolarity( peDxDirectDraw->HwDeviceExtension,
                &ddPolarityInInfo, &ddPolarityOutInfo );
            peDxVideoPort->pNotifyBuffer->lField = ddPolarityOutInfo.bPolarity ? 1 : 0;
        }

        dwVideoIndex = 0;
        if (peDxVideoPort->cAutoflipVideo > 1 ) 
        {
            if (peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP)
            {
                dwVideoIndex = peDxVideoPort->iCurrentVideo;
            }
            else
            {
                ddAutoflipInInfo.lpVideoPortData = peDxVideoPort;
                ddAutoflipOutInfo.dwSurfaceIndex = 0;
                if (peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip)
                {
                    peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip(
                        peDxDirectDraw->HwDeviceExtension,
                        &ddAutoflipInInfo,
                        &ddAutoflipOutInfo);
                }
                dwVideoIndex = ddAutoflipOutInfo.dwSurfaceIndex;
            }
            if( dwVideoIndex-- == 0 )
            {
                dwVideoIndex = peDxVideoPort->cAutoflipVideo - 1;
            }
        }
        peDxVideoPort->pNotifyBuffer->dwSurfaceIndex = dwVideoIndex;

        ullTimeStamp = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;
        ullTimeStamp = (ullTimeStamp & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ullTimeStamp & 0xFFFFFFFF) * 10000000 / rate;
	*((ULONGLONG*)&(peDxVideoPort->pNotifyBuffer->ApproximateTimeStamp)) = ullTimeStamp;

        KeSetEvent (peDxVideoPort->pNotifyEvent, IO_NO_INCREMENT, FALSE);
    }

    // Note that it is okay to modify 'dwCurrentField' outside of a spinlock,
    // as the only other routine that modifies it is 'DxSetFieldNumber' and
    // it always does an atomic write.

    dwCurrentField = InterlockedIncrement((LONG*) &peDxVideoPort->dwCurrentField);

    // Check for posted state changes

    bAdjustFirstWeave = FALSE;
    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_NEW_STATE )
    {
        if( peDxVideoPort->dwSetStateField-- == 0 )
        {
            peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_NEW_STATE;

            // If we'll be weaving, we need to make sure that
            // we only flip at the beginning of a frame and not
            // during the middle.  We assume that we're told to
            // star weaving at the beginning of the frame.

            if( ( peDxVideoPort->dwSetStateState & DDSTATE_WEAVE ) &&
                !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT ) )
            {
                bAdjustFirstWeave = TRUE;
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
            }
            EffectStateChange( peDxVideoPort, NULL, peDxVideoPort->dwSetStateState );
        }
    }

    // Check the skip logic

    bSkipped = FALSE;
    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIP_SET )
    {
        if( peDxVideoPort->dwFieldToSkip-- == 0 )
        {
            // Tell the MiniPort to skip the next field

            vDxSkip( peDxVideoPort, DDSKIP_SKIPNEXT );
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_SKIPPED_LAST;
            bSkipped = TRUE;

            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET )
            {
                peDxVideoPort->dwFieldToSkip = peDxVideoPort->dwNextFieldToSkip;
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET;
            }
            else
            {
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_SKIP_SET;
            }
        }
        else if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET )
        {
            peDxVideoPort->dwNextFieldToSkip--;
        }
    }
    if( ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIPPED_LAST ) && !bSkipped )
    {
        // Tell the MiniPort to un-skip the next field

        vDxSkip( peDxVideoPort, DDSKIP_ENABLENEXT );
        peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_SKIPPED_LAST;

        // This next part is a hack.We keep track of which fields
        // to flip on in weave mode during the ISR, but what if we
        // happen to miss an IRQ (due to DOS box, etc.)?  We can't
        // use to polarity to re-sync because field skipping screws
        // that up, so this code assume that the repeat field will
        // always be the last field of a frame and so the following
        // field will be the first field.  This will make it re-sync
        // if we ever miss an IRQ.

        peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
    }

    // Now do all of the autoflipping

    if( peDxVideoPort->flFlags & (DD_DXVIDEOPORT_FLAG_AUTOFLIP|
        DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI|DD_DXVIDEOPORT_FLAG_BOB ) )
    {
        // Check for autoflipping the VBI surface in which case we
        // don't care about the skip logic

        if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI )
        {
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_VBI_INTERLEAVED )
            {
                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI )
                {
                    peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI;
                    vDxFlip( peDxVideoPort, DDVPFLIP_VBI );
                }
                else
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI;
                }
            }
            else
            {
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI;
                vDxFlip( peDxVideoPort, DDVPFLIP_VBI );
            }
        }

        // Autoflip the vhe video if we are not skipping this field

        if( !bSkipped )
        {
            bFlipped = FALSE;
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP )
            {
                if( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE )
                {
                    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT )
                    {
                        peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
                        if( !bAdjustFirstWeave )
                        {
                            vDxFlip( peDxVideoPort, DDVPFLIP_VIDEO );
                            bFlipped = TRUE;
                        }
                    }
                    else
                    {
                        peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
                    }
                }
                else
                {
                    vDxFlip( peDxVideoPort, DDVPFLIP_VIDEO );
                    bFlipped = TRUE;
                    peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
                }
            }

            // They may be bobbing even when not autoflipping
            // (they may have one interleaved buffer that they
            // use for bob - technically this is not a flip since
            // only one surface is involved).

            if( ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_BOB ) &&
                !bFlipped )
            {
                vDxBob( peDxVideoPort );
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxBusmasterDpc
*
* This routine handles the video capture and is called when one of
* the buffers is filled.  It figures out which one and then sets the
* compeletion event for that buffer.
*
* NOTE: The spinlock is already held.
*
*  10-Jan-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxBusmasterDpc(
    DWORD       dwEvent,
    PVOID       pContext,
    DWORD       dwParam1,
    DWORD       dwParam2
    )
{
    DDGETTRANSFERSTATUSOUTINFO ddGetTransferStatus;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXCAPTURE*      peDxCapture;
    DWORD               ddRVal;
    ULONG_PTR           dwTempId;
    DWORD               dwTempIndex;

    // Call the miniport to get the transfer ID of the completed busmaster

    ddRVal = DDERR_UNSUPPORTED;
    peDxVideoPort = (EDD_DXVIDEOPORT*) pContext;
    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
    if (peDxDirectDraw->DxApiInterface.DxGetTransferStatus)
    {
        ddRVal = peDxDirectDraw->DxApiInterface.DxGetTransferStatus(
            peDxDirectDraw->HwDeviceExtension,
            NULL,
            &ddGetTransferStatus);
    }
    if( ddRVal == DD_OK )
    {
        // Find the capture object.  It may not even be associated with this
        // video port if multiple vidoe ports exist in the system.

        dwTempId = ddGetTransferStatus.dwTransferID & ~0xf;
        peDxCapture = peDxVideoPort->peDxCapture;
        while (peDxCapture && (((ULONG_PTR)peDxCapture & ~0xf) != dwTempId))
        {
            peDxCapture = peDxCapture->peDxCaptureNext;
        }

        if (peDxCapture != NULL)
        {
            // We've found the capture object

            dwTempIndex = (DWORD)(ddGetTransferStatus.dwTransferID & 0xf);
            if (peDxCapture->CaptureQueue[dwTempIndex].flFlags & DD_DXCAPTUREBUFF_FLAG_WAITING )
            {
                peDxCapture->CaptureQueue[dwTempIndex].flFlags = 0;
                KeSetEvent(peDxCapture->CaptureQueue[dwTempIndex].pBuffKEvent, 0, 0);
            }

            // Mark the lucky surface as being done w/ the transfer

            peDxCapture->CaptureQueue[dwTempIndex].peDxSurface->flFlags
                &= ~DD_DXSURFACE_FLAG_TRANSFER;
            peDxCapture->CaptureQueue[dwTempIndex].peDxSurface = NULL;
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxAutoflipUpdate
*
* This routine handles 'software autoflipping' and is called at dispatch
* level when the miniport's videoport interrupt is triggered.  This routine
* can't be kept in 'win32k.sys' because it needs to be non-pageable.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxAutoflipUpdate(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXSURFACE**     apeDxSurfaceVideo,
    ULONG               cSurfacesVideo,
    EDD_DXSURFACE**     apeDxSurfaceVbi,
    ULONG               cSurfacesVbi
    )
{
    KIRQL   OldIrql;
    ULONG   i;

    KeAcquireSpinLock(&peDxVideoPort->peDxDirectDraw->SpinLock, &OldIrql);

    peDxVideoPort->cAutoflipVideo = cSurfacesVideo;
    for (i = 0; i < cSurfacesVideo; i++)
    {
        peDxVideoPort->apeDxSurfaceVideo[i] = apeDxSurfaceVideo[i];
        peDxVideoPort->apeDxSurfaceVideo[i]->peDxVideoPort = peDxVideoPort;
    }
    peDxVideoPort->cAutoflipVbi = cSurfacesVbi;
    for (i = 0; i < cSurfacesVbi; i++)
    {
        peDxVideoPort->apeDxSurfaceVbi[i] = apeDxSurfaceVbi[i];
        peDxVideoPort->apeDxSurfaceVbi[i]->peDxVideoPort = peDxVideoPort;
    }

    KeReleaseSpinLock(&peDxVideoPort->peDxDirectDraw->SpinLock, OldIrql);
}

/******************************Public*Routine******************************\
* VOID DxLoseObject
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxLoseObject(
    VOID*   pvObject,
    LOTYPE  loType
    )
{
    KIRQL               OldIrql;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    EDD_DXSURFACE*      peDxSurface;
    EDD_DXCAPTURE*      peDxCapture;
    DXAPI_EVENT*        pDxEvent;
    DDENABLEIRQINFO 	EnableIrqInfo;
    DWORD               dwRet;

    switch (loType)
    {
    case LO_DIRECTDRAW:
        peDxDirectDraw = (EDD_DXDIRECTDRAW*) pvObject;

        peDxDirectDraw->peDirectDrawGlobal->peDxDirectDraw = NULL;  // Passive

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        peDxDirectDraw->bLost              = TRUE;
        peDxDirectDraw->peDirectDrawGlobal = NULL;

        if (peDxDirectDraw->DxApiInterface.DxEnableIrq)
        {
            // Make sure all IRQs are disabled

            EnableIrqInfo.dwIRQSources = 0;
            EnableIrqInfo.dwLine       = 0;
            EnableIrqInfo.IRQCallback  = NULL;
            EnableIrqInfo.lpIRQData    = NULL;

            peDxDirectDraw->DxApiInterface.DxEnableIrq(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &EnableIrqInfo,
                                    NULL);
        }

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        break;

    case LO_VIDEOPORT:
        peDxVideoPort = (EDD_DXVIDEOPORT*) pvObject;
        peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

        peDxVideoPort->peVideoPort->peDxVideoPort = NULL;           // Passive

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        peDxVideoPort->bLost       = TRUE;
        peDxVideoPort->peVideoPort = NULL;
        peDxVideoPort->peDxCapture = NULL;

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        break;

    case LO_SURFACE:
        peDxSurface = (EDD_DXSURFACE*) pvObject;
        peDxDirectDraw = peDxSurface->peDxDirectDraw;

        peDxSurface->peSurface->peDxSurface = NULL;                 // Passive

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        peDxSurface->bLost     = TRUE;
        peDxSurface->peSurface = NULL;
        peDxSurface->peDxVideoPort = NULL;

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        break;

    case LO_CAPTURE:
        peDxCapture = (EDD_DXCAPTURE*) pvObject;
        peDxVideoPort = peDxCapture->peDxVideoPort;
        if( peDxVideoPort != NULL )
        {
            peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

            KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

            // First flush the capture buffers

            DxInternalFlushVpCaptureBuffs( peDxDirectDraw, peDxVideoPort, peDxCapture );

            // Disassociate the capture object from the video port

            peDxCapture->peDxVideoPort = NULL;
            peDxCapture->bLost       = TRUE;
            if( peDxVideoPort->peDxCapture == peDxCapture )
            {
                peDxVideoPort->peDxCapture = peDxCapture->peDxCaptureNext;
            }
            else
            {
                EDD_DXCAPTURE* peDxTemp;

                for( peDxTemp = peDxVideoPort->peDxCapture;
                    ( peDxTemp != NULL ) &&
                    ( peDxTemp->peDxCaptureNext != peDxCapture );
                    peDxTemp = peDxTemp->peDxCaptureNext );
                if( peDxTemp != NULL )
                {
                    peDxTemp->peDxCaptureNext = peDxCapture->peDxCaptureNext;
                }
                else
                {
                    RIPDX("Capture object not in video port list");
                }
            }

            // If there are no more capture objects associated with the
            // video port, remove the video port from the capture list.

            pDxEvent = NULL;
            if( peDxVideoPort->peDxCapture == NULL )
            {
                if( peDxDirectDraw->pDxEvent_CaptureList->peDxVideoPort == peDxVideoPort )
                {
                    pDxEvent = peDxDirectDraw->pDxEvent_CaptureList;
                    peDxDirectDraw->pDxEvent_CaptureList = pDxEvent->pDxEvent_Next;
                }
                else
                {
                    for( pDxEvent = peDxDirectDraw->pDxEvent_CaptureList;
                        (pDxEvent != NULL) &&
                        (pDxEvent->pDxEvent_Next->peDxVideoPort != peDxVideoPort);
                        pDxEvent = pDxEvent->pDxEvent_Next );
                    if( pDxEvent != NULL )
                    {
                        pDxEvent->pDxEvent_Next =
                            pDxEvent->pDxEvent_Next->pDxEvent_Next;
                        pDxEvent = pDxEvent->pDxEvent_Next;
                    }
                }
            }

            KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

            if( pDxEvent != NULL )
            {
                ExFreePool(pDxEvent);
            }
        }
        break;

    default:
        RIPDX("Unexpected type");
    }
}

/******************************Public*Routine******************************\
* VOID DxUpdateCapture
*
* This routine inserts capture devices intot he list handling off of the
* video port.  Since this list is walked at DPC level, we need to
* synchronize this with the DPC.
*
*  10-Jan-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxUpdateCapture(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXCAPTURE*      peDxCapture,
    BOOL                bRemove
    )
{
    KIRQL             OldIrql;
    EDD_DXCAPTURE*    peDxTemp;
    EDD_DXDIRECTDRAW* peDxDirectDraw;
    DXAPI_EVENT*      pDxEvent_New;
    DXAPI_EVENT*      pDxEvent_Temp = NULL;
    DWORD             dwRet;

    // If adding to the list, also an event to the capture list so we
    // can get the busmaster complete notification.  Allocate the
    // memory for this now.

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
    if( !bRemove )
    {
        pDxEvent_New = (DXAPI_EVENT*) ExAllocatePoolWithTag(NonPagedPool,
                                                        sizeof(*pDxEvent_New),
                                                        'eddG');
        if (pDxEvent_New == NULL)
            return;

        RtlZeroMemory(pDxEvent_New, sizeof(*pDxEvent_New));
        pDxEvent_New->peDxDirectDraw = peDxDirectDraw;
        pDxEvent_New->peDxVideoPort  = peDxVideoPort;
        pDxEvent_New->pfnCallBack    = (LPDD_NOTIFYCALLBACK) DxBusmasterDpc;
        pDxEvent_New->pContext       = peDxVideoPort;
    }

    KeAcquireSpinLock(&peDxVideoPort->peDxDirectDraw->SpinLock, &OldIrql);

    if( bRemove )
    {
        // First flush the capture buffers

        DxInternalFlushVpCaptureBuffs( peDxDirectDraw, peDxVideoPort, peDxCapture );

        // Disassociate the capture object with the video port

        if( peDxVideoPort->peDxCapture == peDxCapture )
        {
            peDxVideoPort->peDxCapture = peDxCapture->peDxCaptureNext;
        }
        else
        {
            for( peDxTemp = peDxVideoPort->peDxCapture;
                ( peDxTemp != NULL ) &&
                ( peDxTemp->peDxCaptureNext != peDxCapture );
                peDxTemp = peDxTemp->peDxCaptureNext );
            if( peDxTemp != NULL )
            {
                peDxTemp->peDxCaptureNext = peDxCapture->peDxCaptureNext;
            }
        }
        peDxCapture->peDxVideoPort = NULL;

        // If there are no more capture objects associated with the
        // video port, remove the video port from the capture list.

        if( peDxVideoPort->peDxCapture == NULL )
        {
            pDxEvent_Temp = NULL;
            if( peDxDirectDraw->pDxEvent_CaptureList->peDxVideoPort == peDxVideoPort )
            {
                pDxEvent_Temp = peDxDirectDraw->pDxEvent_CaptureList;
                peDxDirectDraw->pDxEvent_CaptureList = pDxEvent_Temp->pDxEvent_Next;
            }
            else
            {
                for( pDxEvent_Temp = peDxDirectDraw->pDxEvent_CaptureList;
                    (pDxEvent_Temp != NULL) &&
                    (pDxEvent_Temp->pDxEvent_Next->peDxVideoPort != NULL);
                    pDxEvent_Temp = pDxEvent_Temp->pDxEvent_Next );
                if( pDxEvent_Temp != NULL )
                {
                    pDxEvent_Temp->pDxEvent_Next =
                        pDxEvent_Temp->pDxEvent_Next->pDxEvent_Next;
                    pDxEvent_Temp = pDxEvent_Temp->pDxEvent_Next;
                }
            }
        }
    }
    else
    {
        // Associate the capture object with the video port

        peDxCapture->peDxCaptureNext = peDxVideoPort->peDxCapture;
        peDxVideoPort->peDxCapture = peDxCapture;

        // Add an event to the capture list so we can get the busmaster
        // complete notification.  First check to see if it's already in
        // in the list.

        for (pDxEvent_Temp = peDxDirectDraw->pDxEvent_CaptureList;
             pDxEvent_Temp != NULL;
             pDxEvent_Temp = pDxEvent_Temp->pDxEvent_Next)
        {
            if (pDxEvent_Temp->peDxVideoPort == peDxVideoPort)
            {
                break;
            }
        }
        if( pDxEvent_Temp == NULL )
        {
            // Not already in list - add it

            pDxEvent_New->pDxEvent_Next = peDxDirectDraw->pDxEvent_CaptureList;
            peDxDirectDraw->pDxEvent_CaptureList = pDxEvent_New;
        }
    }

    KeReleaseSpinLock(&peDxVideoPort->peDxDirectDraw->SpinLock, OldIrql);

    if( bRemove && ( pDxEvent_Temp != NULL ) )
    {
        ExFreePool(pDxEvent_Temp);
    }
    else if( pDxEvent_Temp != NULL )
    {
        ExFreePool(pDxEvent_New);
    }
}

/******************************Public*Routine******************************\
* DWORD DxOpenDirectDraw
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxOpenDirectDraw(
    DDOPENDIRECTDRAWIN*     pOpenDirectDrawIn,
    DDOPENDIRECTDRAWOUT*    pOpenDirectDrawOut
    )
{
    pOpenDirectDrawOut->ddRVal = DDERR_UNSUPPORTED;
    if (pOpenDirectDrawIn != NULL)
    {
        if (gpfnOpenDirectDraw != NULL)
        {
            gpfnOpenDirectDraw(pOpenDirectDrawIn,
                               pOpenDirectDrawOut,
                               DxEventDpc,
                               DXAPI_PRIVATE_VERSION_NUMBER);
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxEnableIRQ
*
* This routine enables/disables the video port VSYNC IRQ  and is
* is called at dispatch level.
*
*  17-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxEnableIRQ(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    BOOL		bEnable
    )
{
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*      peDirectDrawGlobal;
    DWORD                       dwBit;

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
    peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;
    dwBit = DDIRQ_VPORT0_VSYNC << ( peDxVideoPort->dwVideoPortID * 2);

    /*
     * Don't enable or disable of the IRQ isn't supported
     */
    if( ( peDirectDrawGlobal != NULL ) &&
        ( peDirectDrawGlobal->DDKernelCaps.dwIRQCaps & dwBit ) )
    {
        if( bEnable )
        {
            if( !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_REGISTERED_IRQ ) )
            {
                bDxModifyDispatchEventList(peDxDirectDraw,
                                   peDxVideoPort,
                                   bEnable,
                                   DDEVENT_VP_VSYNC,
                                   dwBit,
                                   (LPDD_NOTIFYCALLBACK) DxAutoflipDpc,
                                   (PVOID)peDxVideoPort,
                                   INTERNAL_DISPATCH_LIST);
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_REGISTERED_IRQ;
            }
        }
        else
        {
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_REGISTERED_IRQ )
            {
                bDxModifyDispatchEventList(peDxDirectDraw,
                                   peDxVideoPort,
                                   bEnable,
                                   DDEVENT_VP_VSYNC,
                                   dwBit,
                                   (LPDD_NOTIFYCALLBACK) DxAutoflipDpc,
                                   (PVOID)peDxVideoPort,
                                   INTERNAL_DISPATCH_LIST);
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_REGISTERED_IRQ;
            }
        }
        vDxEnableInterrupts( peDxDirectDraw, 0 );
    }
}

/******************************Public*Routine******************************\
* DxApi
*
* Single entry point for all DXAPI.SYS public functionality.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

typedef VOID (APIENTRY* PDX_FUNCTION)(VOID*, VOID*);

typedef struct _DXAPI_ENTRY_POINT {
    PDX_FUNCTION    pfn;
    DWORD           cInBuffer;
    DWORD           cOutBuffer;
    BOOLEAN         bMapProcess;
} DXAPI_ENTRY_POINT;

#define DX(fn, structin, structout, boolean) \
    (PDX_FUNCTION) fn, structin, sizeof(structout), boolean

DXAPI_ENTRY_POINT gDxApiEntryPoint[] = {
    DX(DxGetVersionNumber,    0,                              DDGETVERSIONNUMBER,       FALSE ), // 0
    DX(NULL,                  sizeof(DDCLOSEHANDLE),          DWORD,                    TRUE  ), // 1
    DX(DxOpenDirectDraw,      sizeof(DDOPENDIRECTDRAWIN),     DDOPENDIRECTDRAWOUT,      FALSE ), // 2
    DX(NULL,                  sizeof(DDOPENSURFACEIN),        DDOPENSURFACEOUT,         TRUE  ), // 3
    DX(NULL,                  sizeof(DDOPENVIDEOPORTIN),      DDOPENVIDEOPORTOUT,       TRUE  ), // 4
    DX(NULL,                  sizeof(DWORD),                  DDGETKERNELCAPSOUT,       TRUE  ), // 5
    DX(DxGetFieldNumber,      sizeof(DDGETFIELDNUMIN),        DDGETFIELDNUMOUT,         FALSE ), // 6
    DX(DxSetFieldNumber,      sizeof(DDSETFIELDNUM),          DWORD,                    FALSE ), // 7
    DX(DxSetSkipPattern,      sizeof(DDSETSKIPFIELD),         DWORD,                    FALSE ), // 8
    DX(DxGetSurfaceState,     sizeof(DDGETSURFACESTATEIN),    DDGETSURFACESTATEOUT,     FALSE ), // 9
    DX(DxSetSurfaceState,     sizeof(DDSETSURFACESTATE),      DWORD,                    FALSE ), // 10
    DX(DxLock,                sizeof(DDLOCKIN),               DDLOCKOUT,                FALSE ), // 11
    DX(DxFlipOverlay,         sizeof(DDFLIPOVERLAY),          DWORD,                    FALSE ), // 12
    DX(DxFlipVideoPort,       sizeof(DDFLIPVIDEOPORT),        DWORD,                    FALSE ), // 13
    DX(DxGetCurrentAutoflip,  sizeof(DDGETAUTOFLIPIN),        DDGETAUTOFLIPOUT,         FALSE ), // 14
    DX(DxGetPreviousAutoflip, sizeof(DDGETAUTOFLIPIN),        DDGETAUTOFLIPOUT,         FALSE ), // 15
    DX(DxRegisterEvent,       sizeof(DDREGISTERCALLBACK),     DWORD,                    FALSE ), // 16
    DX(DxUnregisterEvent,     sizeof(DDREGISTERCALLBACK),     DWORD,                    FALSE ), // 17
    DX(DxGetPolarity,         sizeof(DDGETPOLARITYIN),        DDGETPOLARITYOUT,         FALSE ), // 18
    DX(NULL,                  sizeof(DDOPENVPCAPTUREDEVICEIN),DDOPENVPCAPTUREDEVICEOUT, TRUE  ), // 19
    DX(DxAddVpCaptureBuffer,  sizeof(DDADDVPCAPTUREBUFF),     DWORD,                    FALSE ), // 20
    DX(DxFlushVpCaptureBuffs, sizeof(DWORD),                  DWORD,                    FALSE ), // 21
};

DWORD
APIENTRY
DxApi(
    DWORD   iFunction,
    VOID*   pInBuffer,
    DWORD   cInBuffer,
    VOID*   pOutBuffer,
    DWORD   cOutBuffer
    )
{
    DWORD dwRet;
    BOOL  bProcessAttached = FALSE;

    dwRet = 0;

    iFunction -= DD_FIRST_DXAPI;

    if ((iFunction >= sizeof(gDxApiEntryPoint) / sizeof(DXAPI_ENTRY_POINT)) ||
        (gDxApiEntryPoint[iFunction].pfn == NULL))
    {
        KdPrint(("DxApi: Invalid function\n"));
    }
    else if ((cInBuffer  < gDxApiEntryPoint[iFunction].cInBuffer) ||
             (cOutBuffer < gDxApiEntryPoint[iFunction].cOutBuffer))
    {
        KdPrint(("DxApi: Input or output buffer too small\n"));
    }
    else if (pOutBuffer == NULL)
    {
        KdPrint(("DxApi: Invalid output buffer specified\n"));
    }
    else
    {
        if (gDxApiEntryPoint[iFunction].bMapProcess)
        {
            PEPROCESS pepSession;

            switch (iFunction)
            {
            case (DD_DXAPI_CLOSEHANDLE - DD_FIRST_DXAPI):
            case (DD_DXAPI_OPENSURFACE - DD_FIRST_DXAPI):
            case (DD_DXAPI_OPENVIDEOPORT - DD_FIRST_DXAPI):
            case (DD_DXAPI_OPENVPCAPTUREDEVICE - DD_FIRST_DXAPI):

                // pInBuffer is a pointer to a structure that has
                // a pointer to DXOBJ as its first element.

                pepSession = ((DXOBJ *)(*(HANDLE *)pInBuffer))->pepSession;
                break;

            case (DD_DXAPI_GETKERNELCAPS - DD_FIRST_DXAPI):

                // pInBuffer is a pointer to DXOBJ.

                pepSession = ((DXOBJ *)pInBuffer)->pepSession;
                break;

            default:
                return (dwRet);
            }

            if (!KeIsAttachedProcess())
            {
                KeAttachProcess(PsGetProcessPcb(pepSession));
                bProcessAttached = TRUE;
            }
        }

        // The return value is the size of the output buffer:

        dwRet = gDxApiEntryPoint[iFunction].cOutBuffer;

        // Call the actual routine:

        gDxApiEntryPoint[iFunction].pfn(pInBuffer, pOutBuffer);

        if (bProcessAttached)
        {
            KeDetachProcess();
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* VOID DxApiInitialize
*
* Called by win32k.sys to initialize dxapi.sys state.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxApiInitialize(
    PFNDXAPIOPENDIRECTDRAW    pfnOpenDirectDraw,
    PFNDXAPIOPENVIDEOPORT     pfnOpenVideoPort,
    PFNDXAPIOPENSURFACE       pfnOpenSurface,
    PFNDXAPICLOSEHANDLE       pfnCloseHandle,
    PFNDXAPIGETKERNELCAPS     pfnGetKernelCaps,
    PFNDXAPIOPENCAPTUREDEVICE pfnOpenCaptureDevice,
    PFNDXAPILOCKDEVICE        pfnLockDevice,
    PFNDXAPIUNLOCKDEVICE      pfnUnlockDevice
    )
{
    gpfnOpenDirectDraw = pfnOpenDirectDraw;
    gpfnLockDevice     = pfnLockDevice;
    gpfnUnlockDevice   = pfnUnlockDevice;

    gDxApiEntryPoint[DD_DXAPI_OPENVIDEOPORT - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnOpenVideoPort;

    gDxApiEntryPoint[DD_DXAPI_OPENSURFACE - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnOpenSurface;

    gDxApiEntryPoint[DD_DXAPI_CLOSEHANDLE - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnCloseHandle;

    gDxApiEntryPoint[DD_DXAPI_GETKERNELCAPS - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnGetKernelCaps;

    gDxApiEntryPoint[DD_DXAPI_OPENVPCAPTUREDEVICE - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnOpenCaptureDevice;
}

/******************************Public*Routine******************************\
* ULONG DxApiGetVersion
*
* The original Memphis DXAPI had this entry point and although it doesn't
* do anything usefull, some drivers called it so we have to support it
* for those drivers to load.  It does not return a real version number
* because the original incorrectly returned the DSOUND version 4.02,
* which has no correlation to the DxApi version number.  If we return the
* real version, however, we risk breaking drivers.
*
*  16-Apr-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

ULONG
APIENTRY
DxApiGetVersion(
    VOID
    )
{
    return( 0x402 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddagpnt.cxx ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagpnt.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw on NT
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "precomp.hxx"

#ifndef WIN95

// Currently the hdev passed in is the DirectDraw global, so
// look up the AGP interface in it.
#define GET_AGPI(hdev) (&((EDD_DIRECTDRAW_GLOBAL *)hdev)->AgpInterface)

#define CHECK_GET_AGPI(hdev, pvai) \
    (pvai) = GET_AGPI(hdev); \
    ASSERTGDI((pvai)->Context != NULL, "No AGP context");

// Offset to use for biasing AGP heaps.
#define DDNLV_HEAP_BIAS PAGE_SIZE

/*
 * OsAGPReserve
 *
 * Reserve resources for use as an AGP aperture.
 */
BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   PVOID *ppvReservation )
{
    AGP_INTERFACE *pai;
    VIDEO_PORT_CACHE_TYPE Cached;

    CHECK_GET_AGPI(hdev, pai);

    if (fIsUC)
    {
        Cached = VpNonCached;
    }
    else
    {
        Cached = VpWriteCombined;
    }

    // On NT heaps are kept with offsets rather than pointers so
    // always return a base offset as the starting address.  The
    // base offset is non-zero so that successful heap allocations
    // always have a non-zero value.
    *pfpLinStart = DDNLV_HEAP_BIAS;
    
    *pliDevStart = pai->AgpServices.
        AgpReservePhysical(pai->Context, dwNumPages,
                           Cached, ppvReservation);
    return *ppvReservation != NULL;

} /* OsAGPReserve */

/*
 * OsAGPCommit
 *
 * Commit memory to the given portion of a previously reserved range.
 */
BOOL OsAGPCommit( HANDLE hdev, PVOID pvReservation, DWORD dwPageOffset,
                  DWORD dwNumPages )
{
    AGP_INTERFACE *pai;

    CHECK_GET_AGPI(hdev, pai);

    return pai->AgpServices.AgpCommitPhysical(pai->Context,
                                              pvReservation,
                                              dwNumPages, dwPageOffset);

} /* OsAGPCommit */

/*
 * OsAGPDecommitAll
 *
 * Decommit everything in a reserved area.
 */
BOOL OsAGPDecommit( HANDLE hdev, PVOID pvReservation, DWORD dwPageOffset,
                    DWORD dwNumPages )
{
    AGP_INTERFACE *pai;

    CHECK_GET_AGPI(hdev, pai);

    // Decommit memory.
    pai->AgpServices.AgpFreePhysical(pai->Context, pvReservation,
                                     dwNumPages, dwPageOffset );
    return TRUE;
} /* OsAGPDecommitAll */

/*
 * OsAGPFree
 *
 * Free a previously reserved range.
 */
BOOL OsAGPFree( HANDLE hdev, PVOID pvReservation )
{
    AGP_INTERFACE *pai;
    
    CHECK_GET_AGPI(hdev, pai);

    pai->AgpServices.AgpReleasePhysical(pai->Context,
                                        pvReservation);
    return TRUE;
} /* OsAGPFree */

#endif // !WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddheap.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.h
 *  Content:	Heap manager header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDHEAP_INCLUDED__
#define __DDHEAP_INCLUDED__

#include "dmemmgr.h"

BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end );
void linVidMemFini( LPVMEMHEAP pvmh );
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch );
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh );
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh );
    
BOOL rectVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, DWORD width, DWORD height,
                     DWORD stride );
void rectVidMemFini( LPVMEMHEAP pvmh );
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment );
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh );

BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 );

#define DDHA_SKIPRECTANGULARHEAPS       0x0001
#define DDHA_ALLOWNONLOCALMEMORY        0x0002
#define DDHA_ALLOWNONLOCALTEXTURES      0x0004
#define DDHA_USEALTCAPS                 0x0008

FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize);

LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width,
                              DWORD height, DWORD pitch );
void WINAPI VidMemFini( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );

LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem, DWORD pitch, HANDLE hdev,
                                  LPHEAPALIGNMENT phad);
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev );
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize );

FLATPTR WINAPI DdHeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch );
void WINAPI    DdHeapVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

DWORD GetHeapSizeInPages(LPVIDMEM lpVidMem, LONG pitch);
VOID CleanupAgpCommits(LPVIDMEM lpVidMem, HANDLE hdev, EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal, int iHeapIndex);
void SwapHeaps(LPVIDMEM pOldVidMem, LPVIDMEM pNewVidMem);

#endif // __DDHEAP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddheap.cxx ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.c
 *  Content:    Top-level heap routines.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-dec-94  craige  initial implementation
 *   06-jan-95  craige  integrated into DDRAW
 *   20-mar-95  craige  prepare for rectangular memory manager
 *   27-mar-95  craige  linear or rectangular vidmem
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   15-may-95  craige  made separate VMEM struct for rect & linear
 *   10-jun-95  craige  exported fns
 *   02-jul-95  craige  fail if VidMemInit if linear or rect. fail;
 *                      removed linFindMemBlock
 *   17-jul-95  craige  added VidMemLargestFree
 *   01-dec-95  colinmc added VidMemAmountAllocated
 *   11-dec-95  kylej   added VidMemGetRectStride
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   03-Feb-98  DrewB   Made portable between user and kernel.
 *
 ***************************************************************************/

#include "precomp.hxx"


/*
 * VidMemInit - initialize video memory manager heap
 */
LPVMEMHEAP WINAPI VidMemInit(
		DWORD   flags,
		FLATPTR start,
		FLATPTR width_or_end,
		DWORD   height,
		DWORD   pitch )
{
    LPVMEMHEAP  pvmh;

    pvmh = (LPVMEMHEAP)MemAlloc( sizeof( VMEMHEAP ) );
    if( pvmh == NULL )
    {
	return NULL;
    }
    pvmh->dwFlags = flags;
    ZeroMemory( & pvmh->Alignment.ddsCaps, sizeof(pvmh->Alignment.ddsCaps) );

    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	if( !linVidMemInit( pvmh, start, width_or_end ) )
	{
	    MemFree( pvmh );
	    return NULL;
	}
    }
    else
    {
	if( !rectVidMemInit( pvmh, start, (DWORD) width_or_end, height,
                             pitch ) )
	{
	    MemFree( pvmh );
	    return NULL;
	}
    }
    return pvmh;

} /* VidMemInit */

/*
 * VidMemFini - done with video memory manager
 */
void WINAPI VidMemFini( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	linVidMemFini( pvmh );
    }
    else
    {
	rectVidMemFini( pvmh );
    }

} /* VidMemFini */

/*
 * InternalVidMemAlloc - alloc some flat video memory and give us back the size
 * we allocated
 */
FLATPTR WINAPI InternalVidMemAlloc( LPVMEMHEAP pvmh, DWORD x, DWORD y,
                                    LPDWORD lpdwSize,
                                    LPSURFACEALIGNMENT lpAlignment,
                                    LPLONG lpNewPitch )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAlloc( pvmh, x, y, lpdwSize, lpAlignment, lpNewPitch );
    }
    else
    {
	FLATPTR lp = rectVidMemAlloc( pvmh, x, y, lpdwSize, lpAlignment );
        if (lp && lpNewPitch )
        {
            *lpNewPitch = (LONG) pvmh->stride;
        }
        return lp;
    }
    return (FLATPTR) NULL;

} /* InternalVidMemAlloc */

/*
 * VidMemAlloc - alloc some flat video memory
 */
FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD x, DWORD y )
{
    DWORD dwSize;

    /*
     * We are not interested in the size here.
     */
    return InternalVidMemAlloc( pvmh, x, y, &dwSize , NULL , NULL );
} /* VidMemAlloc */

/*
 * DxDdHeapVidMemFree = free some flat video memory
 */
void WINAPI DxDdHeapVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	linVidMemFree( pvmh, ptr );
    }
    else
    {
	rectVidMemFree( pvmh, ptr );
    }

} /* VidMemFree */

/*
 * VidMemAmountAllocated
 */
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAmountAllocated( pvmh );
    }
    else
    {
	return rectVidMemAmountAllocated( pvmh );
    }
 
} /* VidMemAmountAllocated */

/*
 * VidMemAmountFree
 */
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAmountFree( pvmh );
    }
    else
    {
	return rectVidMemAmountFree( pvmh );
    }
 
} /* VidMemAmountFree */

/*
 * VidMemLargestFree
 */
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemLargestFree( pvmh );
    }
    else
    {
	return 0;
    }

} /* VidMemLargestFree */

/*
 * HeapVidMemInit
 *
 * Top level heap initialization code which handles AGP stuff.
 */
LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem,
		                  DWORD    pitch,
		                  HANDLE   hdev,
                                  LPHEAPALIGNMENT pgad)
{
    DWORD         dwSize;

    DDASSERT( NULL != lpVidMem );

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        /*
         * We do not actually call AGPReserve at this time since that would
         * mean calling it each time a mode change occurred.  Insted, we defer
         * this until later when we call InitAgpHeap.
         */

        /*
         * Compute the size of the heap.
         */
        if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
        {
            dwSize = (DWORD)(lpVidMem->fpEnd - lpVidMem->fpStart) + 1UL;
        }
        else
        {
            DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
            dwSize = (pitch * lpVidMem->dwHeight);
        }
        DDASSERT( 0UL != dwSize );

        /*
         * Update the heap for the new start address
         * (and end address for a linear heap).
         */
        lpVidMem->fpStart = 0;
        if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
        {
            lpVidMem->fpEnd = dwSize - 1UL;
        }
        else
        {
            DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
            DDASSERT( pitch );
            lpVidMem->dwHeight = dwSize / pitch;
        }
    }

    if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
    {
	VDPF(( 1,V, "VidMemInit: Linear:      fpStart = 0x%08x fpEnd = 0x%08x",
	     lpVidMem->fpStart, lpVidMem->fpEnd ));
	lpVidMem->lpHeap = VidMemInit( VMEMHEAP_LINEAR, lpVidMem->fpStart,
                                       lpVidMem->fpEnd, 0, 0 );
    }
    else
    {
        // We have no way of testing a rectangular AGP heap, so I'm disabling
        // it for now.
        
        if( !( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL ) )
        {
	    VDPF(( 1,V, "VidMemInit: Rectangular: fpStart = 0x%08x "
                   "dwWidth = %ld dwHeight = %ld, pitch = %ld",
	         lpVidMem->fpStart, lpVidMem->dwWidth, lpVidMem->dwHeight,
                   pitch  ));
	    lpVidMem->lpHeap = VidMemInit( VMEMHEAP_RECTANGULAR, lpVidMem->fpStart,
				           lpVidMem->dwWidth, lpVidMem->dwHeight,
                                           pitch );
        }
    }

    /*
     * Modify the caps and alt-caps so that you don't allocate local
     * video memory surfaces out of AGP memory and vice-verse.
     */
    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
	/*
	 * Its an AGP heap. So don't let explict LOCAL video memory
	 * be allocated out of this heap.
	 */
	lpVidMem->ddsCaps.dwCaps    |= DDSCAPS_LOCALVIDMEM;
	lpVidMem->ddsCapsAlt.dwCaps |= DDSCAPS_LOCALVIDMEM;
    }
    else
    {
	/*
	 * Its a local video memory heap. So don't let explicity NON-LOCAL
	 * video memory be allocated out of this heap.
	 */
	lpVidMem->ddsCaps.dwCaps    |= DDSCAPS_NONLOCALVIDMEM;
	lpVidMem->ddsCapsAlt.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
    }

    /*
     * Copy any extended alignment data into the private heap structure
     */
    if ( lpVidMem->lpHeap )
    {
        if ( pgad )
        {
            lpVidMem->lpHeap->dwFlags |= VMEMHEAP_ALIGNMENT;
            lpVidMem->lpHeap->Alignment = *pgad;
            VDPF((5,V,"Extended alignment turned on for this heap."));
            VDPF((6,V,"Alignments are turned on for:"));
            VDPF((6,V,"  %08X",pgad->ddsCaps));
        }
        else
        {
            /*
             * This means the allocation routines will do no alignment modifications
             */
            VDPF((5,V,"Extended alignment turned OFF for this heap."));
            lpVidMem->lpHeap->dwFlags &= ~VMEMHEAP_ALIGNMENT;
        }
    }

    return lpVidMem->lpHeap;
} /* HeapVidMemInit */

/*
 * HeapVidMemFini
 *
 * Top level heap release code. Handle AGP stuff
 */
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev )
{
    DWORD dwCommittedSize = 0UL;
    PVOID pvReservation;
    BYTE* pAgpCommitMask = NULL;
    DWORD dwAgpCommitMaskSize;
    DWORD dwTotalSize;

    /*
     * Remember how much memory we committed to the AGP heap.
     */
    DDASSERT( NULL != lpVidMem->lpHeap );
    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        dwCommittedSize = lpVidMem->lpHeap->dwCommitedSize;
        pvReservation = lpVidMem->lpHeap->pvPhysRsrv;
        pAgpCommitMask = lpVidMem->lpHeap->pAgpCommitMask;
        dwAgpCommitMaskSize = lpVidMem->lpHeap->dwAgpCommitMaskSize;
        dwTotalSize = lpVidMem->lpHeap->dwTotalSize;
    }

    /*
     * Free the memory manager
     */
    VidMemFini( lpVidMem->lpHeap );
    lpVidMem->lpHeap = NULL;

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        BOOL fSuccess = TRUE;
        
        /*
         * If this is a non-local (AGP) heap then decommit and
         * free the GART memory now.
         */
        if( ( 0UL != dwCommittedSize ) &&
            ( pAgpCommitMask != NULL ) )
        {
            DWORD dwTemp;

            /*
             * Only decommit if we actually bothered to commit something
             * in the first place.
             */
            fSuccess = AGPDecommitAll( hdev, pvReservation, 
                                       pAgpCommitMask, 
                                       dwAgpCommitMaskSize,
                                       &dwTemp,
                                       dwTotalSize);

            /*
             * Should never fail and not much we can do if it does apart
             * from assert that something bad is happening.
             */
            DDASSERT( fSuccess );
        }

        if( pAgpCommitMask != NULL ) 
        {
            VFREEMEM(pAgpCommitMask);
        }

        if( pvReservation != NULL )
        {
            fSuccess = AGPFree( hdev, pvReservation );
        }

        /*
         * Again this should only fail if the OS is in an unstable state
         * or if I have screwed up (sadly the later is all too likely)
         * so assert.
         */
        DDASSERT( fSuccess );
    }   
} /* HeapVidMemFini */

/*
 * This is an external entry point which can be used by drivers to allocate 
 * aligned surfaces.
 */
FLATPTR WINAPI DxDdHeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch )
{
    HANDLE  hdev;
    FLATPTR ptr;
    DWORD   dwSize;


    if ( lpVidMem == NULL ||
         lpVidMem->lpHeap == NULL ||
         (lpVidMem->dwFlags & VIDMEM_HEAPDISABLED))
    {
	return (FLATPTR) NULL;
    }

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        if( lpVidMem->lpHeap->pvPhysRsrv == NULL )
        {
            LPVIDMEM    pHeap;
            DWORD       dwHeap;

            // If we haven't yet initialized the AGP heap, then we will
            // do so now.  This could be dangerous since initializing the
            // heap causes the driver to get re-entered by the 
            // UpdateNonLocalVidMemHeap call.

            EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal = 
                (EDD_DIRECTDRAW_GLOBAL*) OsGetAGPDeviceHandle(lpVidMem->lpHeap);

            pHeap = peDirectDrawGlobal->pvmList;
            for (dwHeap = 0;
                dwHeap < peDirectDrawGlobal->dwNumHeaps;
                pHeap++, dwHeap++)
            {
                if( pHeap == lpVidMem )
                {
                    break;
                }
            }

            if( dwHeap < peDirectDrawGlobal->dwNumHeaps )
            {
                InitAgpHeap( peDirectDrawGlobal,
                             dwHeap,
                             (HANDLE) peDirectDrawGlobal );
            }

            if( ( lpVidMem->lpHeap->pvPhysRsrv == NULL ) ||
                ( lpVidMem->dwFlags & VIDMEM_HEAPDISABLED ) )
            {
                return (FLATPTR) NULL;
            }
        }

        /*
         * As we may need to commit AGP memory we need a device handle
         * to communicate with the AGP controller. Rather than hunting
         * through the driver object list hoping we will find a
         * local object for this process we just create a handle
         * and discard it after the allocation. This should not be
         * performance critical code to start with.
         */
        hdev = OsGetAGPDeviceHandle(lpVidMem->lpHeap);
        if (hdev == NULL)
        {
            return 0;
        }
    }
    else
    {
        hdev = NULL;
    }

    /* Pass NULL Alignment and new pitch pointer */
    ptr = HeapVidMemAlloc( lpVidMem, dwWidth, dwHeight,
                           hdev, lpAlignment, lpNewPitch, &dwSize );

    if( hdev != NULL )
    {
        OsCloseAGPDeviceHandle( hdev );
    }

    return ptr; 
}

/*
 * HeapVidMemAlloc
 *
 * Top level video memory allocation function. Handles AGP stuff
 */
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize )
{
    FLATPTR fpMem;
    DWORD   dwSize;

    DDASSERT( NULL != lpVidMem );
    DDASSERT( NULL != lpVidMem->lpHeap );

    /*
     * Validate the reserved and flags fields of the alignment structure
     */
    if( lpAlignment )
    {
        if( ( lpAlignment->Linear.dwReserved2 != 0 ) ||
            ( lpAlignment->Linear.dwFlags & ~( SURFACEALIGN_DISCARDABLE ) ) )
        {
            return NULL;
        }
    }

    if( ( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL ) &&
        ( lpVidMem->lpHeap->pvPhysRsrv == NULL ) )
    {
        return NULL;
    }

    fpMem = InternalVidMemAlloc( lpVidMem->lpHeap, x, y, &dwSize,
                                 lpAlignment, lpNewPitch );
    if( 0UL == fpMem )
    {
	return fpMem;
    }

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        DWORD dwCommittedSize;
        BOOL  fSuccess;
        DWORD dwOffset;

        dwOffset = (DWORD)(fpMem - lpVidMem->fpStart);

        /*
         * Okay, we have the offset and the size we need to commit. So ask
         * the OS to commit memory to that portion of this previously
         * reserved GART range.
         */
        fSuccess = AGPCommit( hdev, lpVidMem->lpHeap->pvPhysRsrv,
                              dwOffset, dwSize, 
                              lpVidMem->lpHeap->pAgpCommitMask,
                              &dwCommittedSize,
                              lpVidMem->lpHeap->dwTotalSize );
        if( !fSuccess )
        {
            /*
             * Couldn't commit. Must be out of memory.
             * Put the allocated memory back and fail.
             */
            DxDdHeapVidMemFree( lpVidMem->lpHeap, fpMem );
            return (FLATPTR) NULL;
        }
        lpVidMem->lpHeap->dwCommitedSize += dwCommittedSize;

        /*
         * Now we need to vitually commit the memory for all of the
         * DirectDrawLocals that we have.  This is because some drivers
         * (nvidia) allocate a single buffer and then hand out pointers
         * into that buffer to multimple processes.
         */
        EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal = 
            (EDD_DIRECTDRAW_GLOBAL*) OsGetAGPDeviceHandle(lpVidMem->lpHeap);
        EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal; 
        LPVIDMEM    pHeap;
        DWORD       dwHeap;

        pHeap = peDirectDrawGlobal->pvmList;
        for (dwHeap = 0;
            dwHeap < peDirectDrawGlobal->dwNumHeaps;
            pHeap++, dwHeap++)
        {
            if( pHeap == lpVidMem )
            {
                break;
            }
        }
        if( dwHeap < peDirectDrawGlobal->dwNumHeaps )
        {
            peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
            while( ( peDirectDrawLocal != NULL ) && fSuccess )
            {
                if( !( peDirectDrawLocal->fl & DD_LOCAL_DISABLED ) )
                {
                    fSuccess = AGPCommitVirtual( peDirectDrawLocal,
                                                 lpVidMem,
                                                 dwHeap,
                                                 dwOffset,
                                                 dwSize);
                }
                peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext;
            }
        }
        else
        {
            fSuccess = FALSE;
        }
        if( !fSuccess )
        {
            /*
             * Something went wrong on the virtual commit, so fail the allocation.
             */
            DxDdHeapVidMemFree( lpVidMem->lpHeap, fpMem );
            return (FLATPTR) NULL;
        }
    }

    if (pdwSize != NULL)
    {
        *pdwSize = dwSize;
    }
    
    return fpMem;
} /* HeapVidMemAlloc */

/*
 * IsDifferentPixelFormat
 *
 * determine if two pixel formats are the same or not
 *
 * (CMcC) 12/14/95 Really useful - so no longer static
 *
 * This function really shouldn't be in a heap file but it's
 * needed by both the user and kernel code so this is a convenient
 * place to put it to have it shared.
 */
BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 )
{
    /*
     * same flags?
     */
    if( pdpf1->dwFlags != pdpf2->dwFlags )
    {
	VDPF(( 8, S, "Flags differ!" ));
	return TRUE;
    }

    /*
     * same bitcount for non-YUV surfaces?
     */
    if( !(pdpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)) )
    {
	if( pdpf1->dwRGBBitCount != pdpf2->dwRGBBitCount )
	{
	    VDPF(( 8, S, "RGB Bitcount differs!" ));
	    return TRUE;
	}
    }

    /*
     * same RGB properties?
     */
    if( pdpf1->dwFlags & DDPF_RGB )
    {
	if( pdpf1->dwRBitMask != pdpf2->dwRBitMask )
	{
	    VDPF(( 8, S, "RBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwGBitMask != pdpf2->dwGBitMask )
	{
	    VDPF(( 8, S, "GBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwBBitMask != pdpf2->dwBBitMask )
	{
	    VDPF(( 8, S, "BBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwRGBAlphaBitMask != pdpf2->dwRGBAlphaBitMask )
	{
	    VDPF(( 8, S, "RGBAlphaBitMask differs!" ));
	    return TRUE;
	}
    }

    /*
     * same YUV properties?
     */
    if( pdpf1->dwFlags & DDPF_YUV )
    {
	VDPF(( 8, S, "YUV???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVBitCount != pdpf2->dwYUVBitCount )
	{
	    return TRUE;
	}
	if( pdpf1->dwYBitMask != pdpf2->dwYBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwUBitMask != pdpf2->dwUBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwVBitMask != pdpf2->dwVBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVAlphaBitMask != pdpf2->dwYUVAlphaBitMask )
	{
	    return TRUE;
	}
    }

    /*
     * Possible to use FOURCCs w/o setting the DDPF_YUV flag
     * ScottM 7/11/96
     */
    else if( pdpf1->dwFlags & DDPF_FOURCC )
    {
	VDPF(( 8, S, "FOURCC???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
    }

    /*
     *	If Interleaved Z then check Z bit masks are the same
     */
    if( pdpf1->dwFlags & DDPF_ZPIXELS )
    {
	VDPF(( 8, S, "ZPIXELS???" ));
	if( pdpf1->dwRGBZBitMask != pdpf2->dwRGBZBitMask )
	    return TRUE;
    }

    return FALSE;

} /* IsDifferentPixelFormat */

/*
 * SurfaceCapsToAlignment
 *
 * Return a pointer to the appropriate alignment element in a VMEMHEAP
 * structure given surface caps.
 *
 */
LPSURFACEALIGNMENT SurfaceCapsToAlignment(
    LPVIDMEM			lpVidmem ,
    LPDDRAWI_DDRAWSURFACE_LCL	lpSurfaceLcl,
    LPVIDMEMINFO                lpVidMemInfo)
{
    LPVMEMHEAP			lpHeap;
    LPDDSCAPS			lpCaps;
    LPDDRAWI_DDRAWSURFACE_GBL	lpSurfaceGbl;

    DDASSERT( lpVidmem );
    DDASSERT( lpSurfaceLcl );
    DDASSERT( lpVidMemInfo );
    DDASSERT( lpVidmem->lpHeap );

    if ( !lpVidmem->lpHeap )
        return NULL;

    lpCaps = &lpSurfaceLcl->ddsCaps;
    lpHeap = lpVidmem->lpHeap;
    lpSurfaceGbl = lpSurfaceLcl->lpGbl;

    if ( (lpHeap->dwFlags & VMEMHEAP_ALIGNMENT) == 0 )
        return NULL;

    if ( lpCaps->dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            VDPF((6,V,"Aligning surface as execute buffer"));
            return & lpHeap->Alignment.ExecuteBuffer;
        }
        /*
         * If the surface is an execute buffer, then no other
         * alignment can apply
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_OVERLAY )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_OVERLAY )
        {
            VDPF((6,V,"Aligning surface as overlay"));
            return & lpHeap->Alignment.Overlay;
        }
        /*
         * If the surface is an overlay, then no other alignment can apply
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_TEXTURE )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_TEXTURE )
        {
            VDPF((6,V,"Aligning surface as texture"));
            return & lpHeap->Alignment.Texture;
        }
        /*
         * If it's a texture, it can't be an offscreen or any of the others
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_ZBUFFER )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
        {
            VDPF((6,V,"Aligning surface as Z buffer"));
            return & lpHeap->Alignment.ZBuffer;
        }
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_ALPHA )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_ALPHA )
        {
            VDPF((6,V,"Aligning surface as alpha buffer"));
            return & lpHeap->Alignment.AlphaBuffer;
        }
        return NULL;
    }

    /*
     * We need to give a surface which may potentially become a back buffer
     * the alignment which is reserved for potentially visible back buffers.
     * This includes any surface which has made it through the above checks
     * and has the same dimensions as the primary.
     * Note we check only the dimensions of the primary. There's an outside
     * chance that an app could create its back buffer before it creates
     * the primary
     */
    do
    {
	if ( lpSurfaceLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	{
	    if (IsDifferentPixelFormat( &lpVidMemInfo->ddpfDisplay,
                                        &lpSurfaceGbl->ddpfSurface ))
	    {
		/*
		 * Different pixel format from primary means this surface
                 * cannot be part of primary chain
		 */
		break;
	    }

	}

	if ( (DWORD)lpSurfaceGbl->wWidth != lpVidMemInfo->dwDisplayWidth )
	    break;

	if ( (DWORD)lpSurfaceGbl->wHeight != lpVidMemInfo->dwDisplayHeight )
	    break;


	/*
	 * This surface could potentially be part of primary chain.
         * It has the same
	 * pixel format as the primary and the same dimensions.
	 */
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_FLIP )
        {
            VDPF((6,V,"Aligning surface as potential primary surface"));
            return & lpHeap->Alignment.FlipTarget;
        }

	/*
	 * Drop through and check for offscreen if driver specified no
         * part-of-primary-chain alignment
	 */
	break;
    } while (0);

    if ( lpCaps->dwCaps & DDSCAPS_OFFSCREENPLAIN )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN )
        {
            VDPF((6,V,"Aligning surface as offscreen plain"));
            return & lpHeap->Alignment.Offscreen;
        }
    }

    VDPF((6,V,"No extended alignment for surface"));
    return NULL;
}

/*
 * DdHeapAlloc
 *
 * Search all heaps for one that has space and the appropriate
 * caps for the requested surface type and size.
 *
 * We AND the caps bits required and the caps bits not allowed
 * by the video memory.   If the result is zero, it is OK.
 *
 * This is called in 2 passes.   Pass1 is the preferred memory state,
 * pass2 is the "oh no no memory" state.
 *
 * On pass1, we use ddsCaps in the VIDMEM struct.
 * On pass2, we use ddsCapsAlt in the VIDMEM struct.
 *
 */
FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize)
{
    LPVIDMEM	pvm;
    DWORD	vm_caps;
    int		i;
    FLATPTR	pvidmem;
    HANDLE      hvxd;
    LPDDSCAPS	lpCaps;

    LPDDSCAPSEX lpExtendedRestrictions;
    LPDDSCAPSEX lpExtendedCaps;

    DDASSERT( NULL != pdwNewCaps );
    DDASSERT( NULL != lpSurfaceLcl );

    lpCaps = &lpSurfaceLcl->ddsCaps;
    lpExtendedCaps = &lpSurfaceLcl->lpSurfMore->ddsCapsEx;

    for( i = 0 ; i < (int)dwNumHeaps ; i++ )
    {
	pvm = &pvmHeaps[i];

        // Skip disabled heaps.
        if (pvm->dwFlags & VIDMEM_HEAPDISABLED)
        {
            continue;
        }
        
        /*
         * Skip rectangular heaps if we were told to.
         */
        if (dwFlags & DDHA_SKIPRECTANGULARHEAPS)
        {
            if (pvm->dwFlags & VIDMEM_ISRECTANGULAR)
            {
                continue;
            }
        }

	/*
	 * If local or non-local video memory has been explicity
	 * specified then ignore heaps which don't match the required
	 * memory type.
	 */
	if( ( lpCaps->dwCaps & DDSCAPS_LOCALVIDMEM ) &&
            ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
	{
	    VDPF(( 4, V, "Local video memory was requested but heap is "
                   "non local. Ignoring heap %d", i ));
	    continue;
	}

	if( ( lpCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
            !( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
	{
	    VDPF(( 4, V, "Non-local video memory was requested but "
                   "heap is local. Ignoring heap %d", i ));
	    continue;
	}

	if( !( lpCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
	     ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) &&
             ( dwFlags & DDHA_ALLOWNONLOCALMEMORY ) )
	{
            /*
             * We can allow textures to fail over to DMA model cards
             * if the card exposes an appropriate heap. This won't
             * affect cards which can't texture from nonlocal, because
             * they won't expose such a heap. This mod doesn't affect
             * execute model because all surfaces fail over to nonlocal
             * for them.
             * Note that we should only fail over to nonlocal if the
             * surface wasn't explicitly requested in local. There is a
             * clause a few lines up which guarantees this.
             */
            if ( !(lpCaps->dwCaps & DDSCAPS_TEXTURE) )
            {
	        VDPF(( 4, V, "Non-local memory not explicitly requested "
                       "for non-texture surface. Ignoring non-local heap %d",
                       i ));
	        continue;
            }

            /*
             * If the device can't texture out of AGP, we need to fail this
             * heap, since the app is probably expecting to texture out of
             * this surface.
             */
            if ( !(dwFlags & DDHA_ALLOWNONLOCALTEXTURES) )
            {
                continue;
            }
	}

	if( dwFlags & DDHA_USEALTCAPS )
	{
	    vm_caps = pvm->ddsCapsAlt.dwCaps;
            lpExtendedRestrictions = &(pvm->lpHeap->ddsCapsExAlt);
	}
	else
	{
	    vm_caps = pvm->ddsCaps.dwCaps;
            lpExtendedRestrictions = &(pvm->lpHeap->ddsCapsEx);
	}
        
	if( ((lpCaps->dwCaps & vm_caps) == 0) &&
            ((lpExtendedRestrictions->dwCaps2 & lpExtendedCaps->dwCaps2) == 0) &&
            ((lpExtendedRestrictions->dwCaps3 & lpExtendedCaps->dwCaps3) == 0) &&
            ((lpExtendedRestrictions->dwCaps4 & lpExtendedCaps->dwCaps4) == 0))
	{
	    pvidmem = HeapVidMemAlloc(
		pvm,
                dwWidth,
		dwHeight,
		hdev,
		SurfaceCapsToAlignment(pvm, lpSurfaceLcl, lpVidMemInfo),
		plNewPitch,
                pdwSize);

	    if( pvidmem != (FLATPTR) NULL )
	    {
		*ppvmHeap = pvm;

		if( pvm->dwFlags & VIDMEM_ISNONLOCAL )
		    *pdwNewCaps |= DDSCAPS_NONLOCALVIDMEM;
		else
		    *pdwNewCaps |= DDSCAPS_LOCALVIDMEM;
		return pvidmem;
	    }
	}
    }
    return (FLATPTR) NULL;

} /* DdHeapAlloc */

/*
 * GetHeapSizeInPages
 *
 * This is called to determine how much memory should be allocated
 * for the commit mask.  Initially the mask had an entry for each page,
 * so it returned the number of pages in the heap, but the commit mask now has
 * a bit for each 16 page chunk, so we now return the number of chunks in the
 * heap.
 */
DWORD GetHeapSizeInPages(LPVIDMEM lpVidMem, LONG pitch)
{
    DWORD dwSize;

    if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
    {
        dwSize = (DWORD)(lpVidMem->fpEnd - lpVidMem->fpStart) + 1UL;
    }
    else
    {
        DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
        dwSize = (pitch * lpVidMem->dwHeight);
    }
    return AGPGetChunkCount(dwSize);
}

/*
 * CleanupAgpCommits
 *
 * Some drivers leave outstanding allocates after an app exits so that we
 * cannot completely cleanup the AGP heap, so what this function does is
 * decommit as much of the physical AGP memory as it can.  To do this, it
 * determines what memory is still allocated and then decommits everything
 * esle.
 */
VOID CleanupAgpCommits(LPVIDMEM lpVidMem, HANDLE hdev, EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal, int iHeapIndex)
{
    BYTE*   pGoodCommits;
    BYTE*   pAgpCommitMask;
    BYTE*   pVirtCommitMask;
    BYTE*   pTempMask;
    DWORD   dwAgpCommitMaskSize;
    DWORD   i;
    DWORD   dwOffset;
    DWORD   dwSize;
    DWORD   dwDecommittedSize;
    EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal; 
    EDD_VMEMMAPPING*      peMap;

    if( ( lpVidMem->lpHeap == NULL ) ||
        ( lpVidMem->lpHeap->pAgpCommitMask == NULL ) ||
        ( lpVidMem->lpHeap->dwAgpCommitMaskSize == 0 ) ||
        ( lpVidMem->lpHeap->dwCommitedSize == 0 ) ||
        ( lpVidMem->lpHeap->pvPhysRsrv == NULL ) )
    {
        return;
    }
    pAgpCommitMask = lpVidMem->lpHeap->pAgpCommitMask;
    dwAgpCommitMaskSize = lpVidMem->lpHeap->dwAgpCommitMaskSize; 

    pGoodCommits = (BYTE*) PALLOCMEM(dwAgpCommitMaskSize,
                      'pddG');
    if( pGoodCommits == NULL )
    {
        return;
    }
    pVirtCommitMask = (BYTE*) PALLOCMEM(dwAgpCommitMaskSize,
                      'pddG');
    if( pVirtCommitMask == NULL )
    {
        VFREEMEM(pGoodCommits);
        return;
    }

    /*
     * Walk the alloc list and build the list of all the pages that should
     * be committed.
     */
    if( lpVidMem->lpHeap->dwFlags & VMEMHEAP_LINEAR )
    {
        LPVMEML pAlloc = (LPVMEML) lpVidMem->lpHeap->allocList;

        while( pAlloc != NULL )
        {
            dwOffset = (DWORD)(pAlloc->ptr - lpVidMem->fpStart);
            dwSize = pAlloc->size;

            AGPUpdateCommitMask( pGoodCommits, dwOffset, dwSize, lpVidMem->lpHeap->dwTotalSize );

            pAlloc = pAlloc->next;
        }
    }
    else
    {
        LPVMEMR pAlloc = (LPVMEMR) lpVidMem->lpHeap->allocList;

        /*
         * This is a circular list where the end of the list is denoted by
         * a node containing a sentinel value of 0x7fffffff
         */
        while(( pAlloc != NULL ) &&
              ( pAlloc->size != 0x7fffffff ))
        {
            dwOffset = (DWORD)(pAlloc->ptr - lpVidMem->fpStart);
            dwSize = (lpVidMem->lpHeap->stride * 
                (pAlloc->cy - 1)) + pAlloc->cx;

            AGPUpdateCommitMask( pGoodCommits, dwOffset, dwSize, lpVidMem->lpHeap->dwTotalSize );

            pAlloc = pAlloc->next;
        }
    }

    /*
     * Check here to verify that every page that we think should be committed
     * actually is committed.
     */
#if DBG
    {
        BYTE    bit;
        DWORD   dwPage;
        DWORD   dwNumPages;

        bit = 1;
        dwNumPages = dwAgpCommitMaskSize * BITS_IN_BYTE;
        dwPage = 0;
        while( dwPage < dwNumPages )
        {
            ASSERTGDI(!((!(pAgpCommitMask[dwPage/BITS_IN_BYTE] & bit)&&(pGoodCommits[dwPage/BITS_IN_BYTE] & bit))),
                "Page not commited when we think it should be!");

            if( bit == 0x80 )  
            {                   
                bit = 1;        
            }                   
            else                
            {                   
                bit <<= 1;      
            }
            dwPage++;
        }
    }
#endif

    /*
     * Now build a list of pages that are committed but that don't need to be.
     * To save space, we will re-use pAgpCommitMask for this purpose.
     */
    for( i = 0; i < dwAgpCommitMaskSize; i++ )
    {
        pAgpCommitMask[i] ^= pGoodCommits[i];
    }

    /*
     * We don't want to physically decommit the memory w/o first virtually
     * decommitting it for each processs.
     */
    peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
    while( peDirectDrawLocal != NULL )
    {
        if (peDirectDrawLocal->ppeMapAgp != NULL)
        {
            peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
            if ((peMap != NULL) && !(peDirectDrawLocal->fl & DD_LOCAL_DISABLED))
            {
                // Replace the committed mask with the mask that we want to decommit

                ASSERTGDI((dwAgpCommitMaskSize == peMap->dwAgpVirtualCommitMaskSize) ,
                    "Virtual AGP mask size does not equal physical mask size");

                memcpy( pVirtCommitMask, pAgpCommitMask, dwAgpCommitMaskSize );
                pTempMask = peMap->pAgpVirtualCommitMask;
                peMap->pAgpVirtualCommitMask = pVirtCommitMask;

                // pVirtCommitMask now contains all of the pages that are
                // physically committed but that don't need to be, but that
                // doesn't mean that these are virtually commited, so we AND
                // out the pages that are not virtually committed.

                for( i = 0; i < dwAgpCommitMaskSize; i++ )
                {
                    pVirtCommitMask[i] &= pTempMask[i];
                }
                
                AGPDecommitVirtual( peMap,
                                    peDirectDrawLocal->peDirectDrawGlobal,
                                    peDirectDrawLocal,
                                    lpVidMem->lpHeap->dwTotalSize); 

                // pTempMask contains all of the pages that used to be virtually
                // committed but are not neccessarily committed now.  pGoodCommits
                // contains all of the physical pages that need to kept, so ANDing
                // them will give us the pages that are currently committed.

                peMap->pAgpVirtualCommitMask = pTempMask;
                for( i = 0; i < dwAgpCommitMaskSize; i++ )
                {
                    pTempMask[i] &= pGoodCommits[i];
                }
            }
        }
        peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext;
    }

    AGPDecommitAll( hdev, 
                    lpVidMem->lpHeap->pvPhysRsrv, 
                    pAgpCommitMask, 
                    dwAgpCommitMaskSize,
                    &dwDecommittedSize,
                    lpVidMem->lpHeap->dwTotalSize);
    lpVidMem->lpHeap->dwCommitedSize -= dwDecommittedSize;
    memcpy( pAgpCommitMask, pGoodCommits, dwAgpCommitMaskSize );
    VFREEMEM(pGoodCommits);
    VFREEMEM(pVirtCommitMask);
}

/*
 * SwapHeaps
 *
 * During a mode change, we create a new heap and copy it over the old heap.
 * For AGP heaps, however, we really only want one instance of the heap 
 * active at any given time, so the new heap is not fully initialized.  This
 * means that we just swapped our good heap with a abd one, which means that
 * we need to selectively swap certain elements of the heap back.
 */
void SwapHeaps( LPVIDMEM pOldVidMem, LPVIDMEM pNewVidMem )
{
    LPVMEMHEAP      pOldHeap = pOldVidMem->lpHeap;
    LPVMEMHEAP      pNewHeap = pNewVidMem->lpHeap;
    FLATPTR         fpTemp;
    DWORD           dwTemp;
    LPVOID          pvTemp;
    LARGE_INTEGER   liTemp;

    fpTemp = pOldVidMem->fpStart;
    pOldVidMem->fpStart = pNewVidMem->fpStart;
    pNewVidMem->fpStart = fpTemp;

    fpTemp = pOldVidMem->fpEnd;
    pOldVidMem->fpEnd = pNewVidMem->fpEnd;
    pNewVidMem->fpEnd = fpTemp;

    dwTemp = pOldHeap->stride;
    pOldHeap->stride = pNewHeap->stride;
    pNewHeap->stride = dwTemp;

    pvTemp = pOldHeap->freeList;
    pOldHeap->freeList = pNewHeap->freeList;
    pNewHeap->freeList = pvTemp;

    pvTemp = pOldHeap->allocList;
    pOldHeap->allocList = pNewHeap->allocList;
    pNewHeap->allocList = pvTemp;

    pOldHeap->dwTotalSize = min(pOldHeap->dwTotalSize,pNewHeap->dwTotalSize);
    
    fpTemp = pOldHeap->fpGARTLin;
    pOldHeap->fpGARTLin = pNewHeap->fpGARTLin;
    pNewHeap->fpGARTLin = fpTemp;

    fpTemp = pOldHeap->fpGARTDev;
    pOldHeap->fpGARTDev = pNewHeap->fpGARTDev;
    pNewHeap->fpGARTDev = fpTemp;

    dwTemp = pOldHeap->dwCommitedSize;
    pOldHeap->dwCommitedSize = pNewHeap->dwCommitedSize;
    pNewHeap->dwCommitedSize = dwTemp;

    liTemp = pOldHeap->liPhysAGPBase;
    pOldHeap->liPhysAGPBase = pNewHeap->liPhysAGPBase;
    pNewHeap->liPhysAGPBase = liTemp;

    pvTemp = pOldHeap->pvPhysRsrv;
    pOldHeap->pvPhysRsrv = pNewHeap->pvPhysRsrv;
    pNewHeap->pvPhysRsrv = pvTemp;

    pvTemp = (LPVOID) pOldHeap->pAgpCommitMask;
    pOldHeap->pAgpCommitMask = pNewHeap->pAgpCommitMask;
    pNewHeap->pAgpCommitMask = (BYTE*) pvTemp;

    dwTemp = pOldHeap->dwAgpCommitMaskSize;
    pOldHeap->dwAgpCommitMaskSize = pNewHeap->dwAgpCommitMaskSize;
    pNewHeap->dwAgpCommitMaskSize = dwTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddheapr.cxx ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   ddheapr.c
 *  Content:    Rectangular heap manager
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   30-mar-95  kylej   initial implementation
 *   07-apr-95  kylej   Added rectVidMemAmountFree
 *   15-may-95  craige  made separate VMEM struct for rect & linear
 *   18-jun-95  craige  specific pitch
 *   02-jul-95  craige  have rectVidMemInit return a BOOL
 *   28-nov-95  colinmc new function to return amount of allocated memory
 *                      in a heap
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   18-jan-97  colinmc Work Item: AGP support
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   03-Feb-98  DrewB   Made portable between user and kernel.
 *
 ***************************************************************************/

#include "precomp.hxx"

/****************************************************************************

 This memory manager manages allocation of rectangular blocks of 
 video memory.  It has essentially the same interface as the linear
 video memory manager implemented in vmemmgr.c.  Memory allocations
 are tracked by nodes on two circular, doubly-linked lists; the free
 list and the alloc list.  Each list has a special node called the 
 sentinel which contains a special memory size.  The head of each
 list always points to the sentinel node and the first member of the
 list (if there is one) is pointed to by the sentinel node.  Block
 adjacency information is kept in each node so that several free nodes 
 can be coalesced into larger free nodes.  This takes place every 
 time a block of memory is freed.
 
 This memory manager is designed to have no impact on video memory usage.
 Global memory is used to maintain the allocation and free lists.  Because
 of this choice, merging of free blocks is a more expensive operation.
 The assumption is that in general, the speed of creating/destroying these
 memory blocks is not a high usage item and so it is OK to be slower.

 ****************************************************************************/

/*
 * IS_FREE and NOT_FREE are used to set the free flag in the flags
 * field of each VMEM node.  The free flag is the lsb of this field.
 */
  
#define IS_FREE  0x00000001
#define NOT_FREE 0xfffffffe
 
/*
 * SENTINEL is the value stuffed into the size field of a VMEM
 * node to identify it as the sentinel node.  This value makes
 * the assumption that no rectangle sized 0x7fff by 0xffff will
 * ever be requested.
 */
  
#define SENTINEL 0x7fffffff

/*
 * MIN_DIMENSION_SIZE determines the smallest valid dimension for a 
 * free memory block.  If dividing a rectangle will result in a 
 * rectangle with a dimension less then MIN_DIMENSION_SIZE, the 
 * rectangle is not divided.
 */

#define MIN_DIMENSION_SIZE 4

/*
 * BLOCK_BOUNDARY must be a power of 2, and at least 4.  This gives
 * us the alignment of memory blocks.   
 */
#define BLOCK_BOUNDARY  4

// This macro results in the free list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/*
 * Debugging helpers
 */
#define DPFVMEMR(str,p) VDPF((0,V,"%s: %d,%d (%dx%d) ptr:%08x, block:%08x",str,p->x,p->y,p->cx,p->cy,p->ptr,p))
#define CHECK_HEAP(a,b) ;

/*
 * insertIntoDoubleList - add an item to the a list. The list is
 *      kept in order of increasing size and is doubly linked.  The
 *      list is circular with a sentinel node indicating the end
 *      of the list.  The sentinel node has its size field set 
 *      to SENTINEL.
 */
void insertIntoDoubleList( LPVMEMR pnew, LPVMEMR listhead )
{
    LPVMEMR pvmem = listhead;

    #ifdef DEBUG
    if( pnew->size == 0 )
    {
        VDPF(( 1, V, "block size = 0\n" ));
    }
    #endif

    /*
     * run through the list (sorted from smallest to largest) looking
     * for the first item bigger than the new item.  If the sentinel
     * is encountered, insert the new item just before the sentinel.
     */

    while( pvmem->size != SENTINEL ) 
    {
    if( pnew->size < pvmem->size )
    {
        break;
    }
    pvmem = pvmem->next;
    }

    // insert the new item before the found one.
    pnew->prev = pvmem->prev;
    pnew->next = pvmem;
    pvmem->prev->next = pnew;
    pvmem->prev = pnew;

} /* insertIntoDoubleList */

/*
 * rectVidMemInit - initialize rectangular video memory manager
 */
BOOL rectVidMemInit(
        LPVMEMHEAP pvmh,
        FLATPTR start,
        DWORD width,
        DWORD height,
        DWORD pitch )
{
    LPVMEMR newNode;

    VDPF(( 2, V, "rectVidMemInit(start=%08lx,width=%ld,height=%ld,pitch=%ld)", start, width, height, pitch));

    pvmh->dwTotalSize = pitch * height;

    // Store the pitch for future address calculations.
    pvmh->stride = pitch;

    // Set up the Free list and the Alloc list by inserting the sentinel.
    pvmh->freeList = MemAlloc( sizeof(VMEMR) );
    if( pvmh->freeList == NULL )
    {
        return FALSE;
    }
    ((LPVMEMR)pvmh->freeList)->size = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->cx = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->cy = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->next = (LPVMEMR)pvmh->freeList;
    ((LPVMEMR)pvmh->freeList)->prev = (LPVMEMR)pvmh->freeList;
    ((LPVMEMR)pvmh->freeList)->pLeft = NULL;
    ((LPVMEMR)pvmh->freeList)->pUp = NULL;
    ((LPVMEMR)pvmh->freeList)->pRight = NULL;
    ((LPVMEMR)pvmh->freeList)->pDown = NULL;

    pvmh->allocList = MemAlloc( sizeof(VMEMR) );
    if( pvmh->allocList == NULL )
    {
    MemFree(pvmh->freeList);
        return FALSE;
    }
    ((LPVMEMR)pvmh->allocList)->size = SENTINEL;
    ((LPVMEMR)pvmh->allocList)->next = (LPVMEMR)pvmh->allocList;
    ((LPVMEMR)pvmh->allocList)->prev = (LPVMEMR)pvmh->allocList;

    // Initialize the free list with the whole chunk of memory
    newNode = (LPVMEMR)MemAlloc( sizeof( VMEMR ) );
    if( newNode == NULL )
    {
    MemFree(pvmh->freeList);
        MemFree(pvmh->allocList);
        return FALSE;
    }
    newNode->ptr = start;
    newNode->size = CXCY(width, height);
    newNode->x = 0;
    newNode->y = 0;
    newNode->cx = width;
    newNode->cy = height;
    newNode->flags |= IS_FREE;
    newNode->pLeft = (LPVMEMR)pvmh->freeList;
    newNode->pUp = (LPVMEMR)pvmh->freeList;
    newNode->pRight = (LPVMEMR)pvmh->freeList;
    newNode->pDown = (LPVMEMR)pvmh->freeList;
    insertIntoDoubleList( newNode, ((LPVMEMR) pvmh->freeList)->next );

    return TRUE;
} /* rectVidMemInit */

/*
 * rectVidMemFini - done with rectangular video memory manager
 */
void rectVidMemFini( LPVMEMHEAP pvmh )
{
    LPVMEMR curr;
    LPVMEMR next;

    if( pvmh != NULL )
    {
    // free all memory allocated for the free list
    curr = ((LPVMEMR)pvmh->freeList)->next;
    while( curr->size != SENTINEL )
    {
        next = curr->next;
        MemFree( curr );
        curr = next;
    }
    MemFree( curr );
    pvmh->freeList = NULL;

    // free all memory allocated for the allocation list
    curr = ((LPVMEMR)pvmh->allocList)->next;
    while( curr->size != SENTINEL )
    {
        next = curr->next;
        MemFree( curr );
        curr = next;
    }
    MemFree( curr );
    pvmh->allocList = NULL;

    // free the heap data
    MemFree( pvmh );
    }
}   /* rectVidMemFini */

/*
 * GetBeforeWastage.
 * Align the surface in the given block. Return the size of the holes
 * on the left side of the surface.
 * Fail if alignment would cause surface to spill out of block.
 * Works for horizontal and vertical alignment.
 * IN:  dwBlockSize , dwBlockStart: Parameters of the block in which
 *                                  the surface hopes to fit
 *      dwSurfaceSize               Width or height of the surface
 *      dwAlignment                 Expected alignment. 0 means don't care
 * OUT: pdwBeforeWastage
 */
BOOL GetBeforeWastage(
    DWORD dwBlockSize,
    DWORD dwBlockStart,
    DWORD dwSurfaceSize, 
    LPDWORD pdwBeforeWastage, 
    DWORD dwAlignment )
{

    if (!dwAlignment)
    {
        *pdwBeforeWastage=0;
        /*
         * If no alignment requirement, then check if the surface fits
         */
        if (dwBlockSize >= dwSurfaceSize)
        {
            return TRUE;
        }
        return FALSE;
    }
    /*
     * There's an alignment.
     */
    *pdwBeforeWastage = (dwAlignment - (dwBlockStart % dwAlignment)) % dwAlignment;

    if ( *pdwBeforeWastage + dwSurfaceSize > dwBlockSize )
    {
            return FALSE;
    }

    DDASSERT( (dwBlockStart + *pdwBeforeWastage) % dwAlignment == 0 );
    return TRUE;
}

/*
 * rectVidMemAlloc - alloc some rectangular flat video memory
 */
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment )
{
    LPVMEMR pvmem;
    DWORD   cyRem;
    DWORD   cxRem;
    DWORD   cxBelow;
    DWORD   cyBelow;
    DWORD   cxBeside;
    DWORD   cyBeside;
    LPVMEMR pnewBeside;
    LPVMEMR pnewBelow;
    DWORD       dwXAlignment=0;
    DWORD       dwYAlignment=0;
    DWORD       dwLeftWastage=0;
    DWORD       dwTopWastage=0;
    BOOL        bDiscardable = FALSE;


    if((cxThis == 0) || (cyThis == 0) || (pvmh == NULL))
    return (FLATPTR) NULL;

    // Make sure the size of the block is a multiple of BLOCK_BOUNDARY
    // If every block allocated has a width which is a multiple of
    // BLOCK_BOUNDARY, it guarantees that all blocks will be allocated
    // on block boundaries.

    /*
     * Bump to new alignment
     */
    if( (cxThis >= (SENTINEL>>16) ) || (cyThis >= (SENTINEL&0xffff) ) )
    return (FLATPTR) NULL;


    if (lpAlignment)
    {
        dwXAlignment = lpAlignment->Rectangular.dwXAlignment;
        dwYAlignment = lpAlignment->Rectangular.dwYAlignment;
        
        if( lpAlignment->Rectangular.dwFlags & SURFACEALIGN_DISCARDABLE ) 
        {
            bDiscardable = TRUE;
        }
    }
    if (dwXAlignment < 4)
    {
        dwXAlignment = 4;
    }


    
    cxThis = (cxThis+(BLOCK_BOUNDARY-1)) & ~(BLOCK_BOUNDARY-1);

    /*
     * run through free list, looking for the closest matching block
     */

    pvmem = ((LPVMEMR)pvmh->freeList)->next;
    while (pvmem->size != SENTINEL)
    {
        if (!GetBeforeWastage( pvmem->cx, pvmem->x, cxThis, &dwLeftWastage, dwXAlignment ))
        {
        pvmem = pvmem->next;
            continue; //X size or alignment makes surface spill out of block
        }
        // Now see if size/alignment works for Y
        if (!GetBeforeWastage( pvmem->cy, pvmem->y, cyThis, &dwTopWastage, dwYAlignment ))
        {
        pvmem = pvmem->next;
            continue; //Y size alignment makes surface spill out of block
        }
        //success:
        break;
    }

    if(pvmem->size == SENTINEL)
    {
    // There was no rectangle large enough
    return (FLATPTR) NULL;
    }

    // pvmem now points to a rectangle that is the same size or larger
    // than the requested rectangle.  We're going to use the upper-left
    // corner of the found rectangle and divide the unused remainder into
    // two rectangles which will go on the available list.

    // grow allocation by the wastage which makes the top-left aligned
    cxThis += dwLeftWastage;
    cyThis += dwTopWastage;

    // Compute the width of the unused rectangle to the right and the 
    // height of the unused rectangle below:

    cyRem = pvmem->cy - cyThis;
    cxRem = pvmem->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are 
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
    cxBelow = cxThis + cxRem;
    cyBeside = cyThis;
    }
    else
    {
    cxBelow = cxThis;
    cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and 
    // bottom portions if they're greater in dimension than MIN_DIMENSION_SIZE.
    // It hardly makes sense to do the book-work to keep around a 
    // two pixel wide available space, for example.

    pnewBeside = NULL;
    if (cxBeside >= MIN_DIMENSION_SIZE)
    {
    pnewBeside = (LPVMEMR)MemAlloc( sizeof(VMEMR) );
    if( pnewBeside == NULL)
        return (FLATPTR) NULL;

    // Update the adjacency information along with the other required
    // information in this new node and then insert it into the free
    // list which is sorted in ascending cxcy.

    // size information
    pnewBeside->size = CXCY(cxBeside, cyBeside);
    pnewBeside->x = pvmem->x + cxThis;
    pnewBeside->y = pvmem->y;
    pnewBeside->ptr = pvmem->ptr + cxThis;
    pnewBeside->cx = cxBeside;
    pnewBeside->cy = cyBeside;
    pnewBeside->flags |= IS_FREE;

    // adjacency information
    pnewBeside->pLeft = pvmem;
    pnewBeside->pUp = pvmem->pUp;
    pnewBeside->pRight = pvmem->pRight;
    pnewBeside->pDown = pvmem->pDown;
    }

    pnewBelow = NULL;
    if (cyBelow >= MIN_DIMENSION_SIZE)
    {
    pnewBelow = (LPVMEMR) MemAlloc( sizeof(VMEMR) );
    if (pnewBelow == NULL)
        {
            if( pnewBeside != NULL )
            {
                MemFree( pnewBeside );
            }
        return (FLATPTR) NULL;
        }

    // Update the adjacency information along with the other required
    // information in this new node and then insert it into the free
    // list which is sorted in ascending cxcy.

    // size information
    pnewBelow->size = CXCY(cxBelow, cyBelow);
    pnewBelow->x = pvmem->x;
    pnewBelow->y = pvmem->y + cyThis;
    pnewBelow->ptr = pvmem->ptr + cyThis*pvmh->stride;
    pnewBelow->cx = cxBelow;
    pnewBelow->cy = cyBelow;
    pnewBelow->flags |= IS_FREE;

    // adjacency information
    pnewBelow->pLeft = pvmem->pLeft;
    pnewBelow->pUp = pvmem;
    pnewBelow->pRight = pvmem->pRight;
    pnewBelow->pDown = pvmem->pDown;
    }

    // Remove this node from the available list
    pvmem->next->prev = pvmem->prev;
    pvmem->prev->next = pvmem->next;

    // Update adjacency information for the current node

    if(pnewBelow != NULL)
    {
    insertIntoDoubleList( pnewBelow, ((LPVMEMR) pvmh->freeList)->next );

    // Modify the current node to reflect the changes we've made:

    pvmem->cy = cyThis;
    pvmem->pDown = pnewBelow;
    if((pnewBeside != NULL) && (cyBeside == pvmem->cy))
        pnewBeside->pDown = pnewBelow;
    }

    if(pnewBeside != NULL)
    {
    insertIntoDoubleList( pnewBeside, ((LPVMEMR) pvmh->freeList)->next);

    // Modify the current node to reflect the changes we've made:

    pvmem->cx = cxThis;
    pvmem->pRight = pnewBeside;
    if ((pnewBelow != NULL) && (cxBelow == pvmem->cx))
        pnewBelow->pRight = pnewBeside;
    }

    // set up new pointers (pBits is the value returned to the client, pvmem
    // points to the actual top-left of the block).
    pvmem->pBits = pvmem->ptr + dwLeftWastage + dwTopWastage*pvmh->stride;
    pvmem->flags &= NOT_FREE;
    pvmem->size = CXCY(pvmem->cx, pvmem->cy);
    pvmem->bDiscardable = bDiscardable;

    // Now insert it into the alloc list.
    insertIntoDoubleList( pvmem, ((LPVMEMR) pvmh->allocList)->next );

    if( NULL != lpdwSize )
    {
    /*
     * Note this is the total number of bytes needed for this surface
     * including the stuff off the left and right hand sides due to
     * pitch not being equal to width. This is different from the
     * size computed above which is simply the number of bytes within
     * the boundary of the surface itself.
     *
     * The formula below calculates the number of bytes from the first
     * byte in the rectangular surface to the first byte after it
     * taking the pitch into account. Complex I know but it works.
     */
    DDASSERT( 0UL != pvmem->cy );
    *lpdwSize = (pvmh->stride * (pvmem->cy - 1)) + pvmem->cx;
    }

    CHECK_HEAP("After rectVidMemAlloc",pvmh);
    return pvmem->pBits;

} /* rectVidMemAlloc */

/*
 * rectVidMemFree = free some rectangular flat video memory
 */
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    LPVMEMR pvmem;
    LPVMEMR pBeside;

    // Find the node in the allocated list which matches ptr
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
    pvmem = pvmem->next)
    if(pvmem->pBits == ptr)
        break;

    if(pvmem->size == SENTINEL)   // couldn't find allocated rectangle?
    {
    VDPF(( 1, V, "Couldn't find node requested freed!\n"));
    return;
    }

    // pvmem now points to the node which must be freed.  Attempt to 
    // coalesce rectangles around this node until no more action
    // is possible.

    while(1)
    {
    // Try merging with the right sibling:

    pBeside = pvmem->pRight;
    if ((pBeside->flags & IS_FREE)       &&
        (pBeside->cy    == pvmem->cy)    &&
        (pBeside->pUp   == pvmem->pUp)   &&
        (pBeside->pDown == pvmem->pDown) &&
        (pBeside->pRight->pLeft != pBeside))
    {
        // Add the right rectangle to ours:

        pvmem->cx    += pBeside->cx;
        pvmem->pRight = pBeside->pRight;

        // Remove pBeside from the list and free it.
        pBeside->next->prev = pBeside->prev;
        pBeside->prev->next = pBeside->next;
        MemFree(pBeside);
        continue;       // go back and try again
    }

    // Try merging with the lower sibling:

    pBeside = pvmem->pDown;
    if ((pBeside->flags & IS_FREE)         &&
        (pBeside->cx     == pvmem->cx)     &&
        (pBeside->pLeft  == pvmem->pLeft)  &&
        (pBeside->pRight == pvmem->pRight) &&
        (pBeside->pDown->pUp != pBeside))
    {
        pvmem->cy   += pBeside->cy;
        pvmem->pDown = pBeside->pDown;

        // Remove pBeside from the list and free it.
        pBeside->next->prev = pBeside->prev;
        pBeside->prev->next = pBeside->next;
        MemFree(pBeside);
        continue;       // go back and try again
    }

    // Try merging with the left sibling:

    pBeside = pvmem->pLeft;
    if ((pBeside->flags & IS_FREE)        &&
        (pBeside->cy     == pvmem->cy)    &&
        (pBeside->pUp    == pvmem->pUp)   &&
        (pBeside->pDown  == pvmem->pDown) &&
        (pBeside->pRight == pvmem)        &&
        (pvmem->pRight->pLeft != pvmem))
    {
        // We add our rectangle to the one to the left:

        pBeside->cx    += pvmem->cx;
        pBeside->pRight = pvmem->pRight;

        // Remove 'pvmem' from the list and free it:
        pvmem->next->prev = pvmem->prev;
        pvmem->prev->next = pvmem->next;
        MemFree(pvmem);
        pvmem = pBeside;
        continue;
    }

    // Try merging with the upper sibling:

    pBeside = pvmem->pUp;
    if ((pBeside->flags & IS_FREE)         &&
        (pBeside->cx       == pvmem->cx)   &&
        (pBeside->pLeft  == pvmem->pLeft)  &&
        (pBeside->pRight == pvmem->pRight) &&
        (pBeside->pDown  == pvmem)         &&
        (pvmem->pDown->pUp != pvmem))
    {
        pBeside->cy      += pvmem->cy;
        pBeside->pDown  = pvmem->pDown;

        // Remove 'pvmem' from the list and free it:
        pvmem->next->prev = pvmem->prev;
        pvmem->prev->next = pvmem->next;
        MemFree(pvmem);
        pvmem = pBeside;
        continue;
    }

    // Remove the node from its current list.

    pvmem->next->prev = pvmem->prev;
    pvmem->prev->next = pvmem->next;

    pvmem->size = CXCY(pvmem->cx, pvmem->cy);
    pvmem->flags |= IS_FREE;

    // Insert the node into the free list:
    insertIntoDoubleList( pvmem, ((LPVMEMR) pvmh->freeList)->next );

    // No more area coalescing can be done, return.

        CHECK_HEAP("After rectVidMemFree",pvmh);
    return;
    }
}

/*
 * rectVidMemAmountAllocated
 */
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    LPVMEMR pvmem;
    DWORD   size;

    size = 0;
    // Traverse the alloc list and add up all the used space.
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
    pvmem = pvmem->next)
    {
        if( !( pvmem->bDiscardable ) )
        {
        size += pvmem->cx * pvmem->cy;
        }
    }

    return size;

} /* rectVidMemAmountAllocated */

/*
 * rectVidMemAmountFree
 */
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh )
{
    LPVMEMR pvmem;
    DWORD   size;

    size = 0;
    // Traverse the free list and add up all the empty space.
    for(pvmem=((LPVMEMR)pvmh->freeList)->next; pvmem->size != SENTINEL;
    pvmem = pvmem->next)
    {
    size += pvmem->cx * pvmem->cy;
    }

    // Now traverse the alloced list and add in all of the memory
    // that's discardable
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
    pvmem = pvmem->next)
    {
        if( pvmem->bDiscardable )
        {
        size += pvmem->cx * pvmem->cy;
        }
    }

    return size;

} /* rectVidMemAmountFree */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddheapl.cxx ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheapl.c
 *  Content:    Linear heap manager
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   03-Feb-98  DrewB   Split from old vmemmgr.c for user/kernel code.
 *
 ***************************************************************************/

#include "precomp.hxx"

/****************************************************************************

 This memory manager is designed to have no impact on video memory usage.
 Global memory is used to maintain the allocation and free lists.  Because
 of this choice, merging of free blocks is a more expensive operation.
 The assumption is that in general, the speed of creating/destroying these
 memory blocks is not a high usage item and so it is OK to be slower.

 ****************************************************************************/

/*
 * MIN_SPLIT_SIZE determines the minimum size of a free block - if splitting
 * a block will result in less than MIN_SPLIT_SIZE bytes left, then
 * those bytes are just left as part of the new block.
 */
#define MIN_SPLIT_SIZE  15

/*
 * BLOCK_BOUNDARY must be a power of 2, and at least 4.  This gives
 * us the alignment of memory blocks.   
 */
#define BLOCK_BOUNDARY  4

/*
 * linVidMemInit - initialize video memory manager
 */
BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end )
{
    DWORD       size;

    VDPF((2,V, "linVidMemInit(%08lx,%08lx)", start, end ));

    /*
     * get the size of the heap (and verify its alignment for debug builds)
     */
    size = (DWORD)(end - start) + 1;
    #ifdef DEBUG
    if( (size & (BLOCK_BOUNDARY-1)) != 0 )
    {
        VDPF(( 1, V, "Invalid size: %08lx (%ld)\n", size, size ));
        return FALSE;
    }
    #endif

    pvmh->dwTotalSize = size;

    /*
     * set up a free list with the whole chunk of memory on the block
     */
    pvmh->freeList = MemAlloc( sizeof( VMEML ) );
    if( pvmh->freeList == NULL )
    {
    return FALSE;
    }
    ((LPVMEML)pvmh->freeList)->next = NULL;
    ((LPVMEML)pvmh->freeList)->ptr = start;
    ((LPVMEML)pvmh->freeList)->size = size;

    pvmh->allocList = NULL;

    return TRUE;

} /* linVidMemInit */

/*
 * linVidMemFini - done with video memory manager
 */
void linVidMemFini( LPVMEMHEAP pvmh )
{
    LPVMEML     curr;
    LPVMEML     next;

    if( pvmh != NULL )
    {
    /*
     * free all memory allocated for the free list
     */
    curr = (LPVMEML)pvmh->freeList;
    while( curr != NULL )
    {
        next = curr->next;
        MemFree( curr );
        curr = next;
    }
    pvmh->freeList = NULL;

    /*
     * free all memory allocated for the allocation list
     */
    curr = (LPVMEML)pvmh->allocList;
    while( curr != NULL )
    {
        next = curr->next;
        MemFree( curr );
        curr = next;
    }
    pvmh->allocList = NULL;

    /*
     * free the heap data
     */
    MemFree( pvmh );
    }

} /* linVidMemFini */

/*
 * insertIntoList - add an item to the allocation list. list is kept in
 *                  order of increasing size
 */
void insertIntoList( LPVMEML pnew, LPLPVMEML listhead )
{
    LPVMEML     pvmem;
    LPVMEML     prev;

    #ifdef DEBUG
    if( pnew->size == 0 )
    {
        VDPF(( 1, V, "block size = 0\n" ));
    }
    #endif

    /*
     * run through the list (sorted from smallest to largest) looking
     * for the first item bigger than the new item
     */
    pvmem = *listhead;
    prev = NULL;
    while( pvmem != NULL )
    {
    if( pnew->size < pvmem->size )
    {
        break;
    }
    prev = pvmem;
    pvmem = pvmem->next;
    }

    /*
     * insert the new item item (before the found one)
     */
    if( prev != NULL )
    {
    pnew->next = pvmem;
    prev->next = pnew;
    }
    else
    {
    pnew->next = *listhead;
    *listhead = pnew;
    }

} /* insertIntoList */

/*
 * coalesceFreeBlocks - add a new item to the free list and coalesce
 */
LPVMEML coalesceFreeBlocks( LPVMEMHEAP pvmh, LPVMEML pnew )
{
    LPVMEML     pvmem;
    LPVMEML     prev;
    FLATPTR     end;
    BOOL        done;

    pvmem = (LPVMEML)pvmh->freeList;
    pnew->next = NULL;
    end = pnew->ptr + pnew->size;
    prev = NULL;
    done = FALSE;

    /*
     * try to merge the new block "pnew"
     */
    while( pvmem != NULL )
    {
    if( pnew->ptr == (pvmem->ptr + pvmem->size) )
    {
        /*
         * new block starts where another ended
         */
        pvmem->size += pnew->size;
        done = TRUE;
    }
    else if( end == pvmem->ptr )
    {
        /*
         * new block ends where another starts
         */
        pvmem->ptr = pnew->ptr;
        pvmem->size += pnew->size;
        done = TRUE;
    }
    /*
     * if we are joining 2 blocks, remove the merged on from the
     * list and return so that it can be re-tried (we don't recurse
     * since we could get very deep)
     */
    if( done )
    {
        if( prev != NULL )
        {
        prev->next = pvmem->next;
        }
        else
        {
        pvmh->freeList = pvmem->next;
        }
        MemFree( pnew );
        return pvmem;
    }
    prev = pvmem;
    pvmem = pvmem->next;
    }

    /*
     * couldn't merge, so just add to the free list
     */
    insertIntoList( pnew, (LPLPVMEML) &pvmh->freeList );
    return NULL;

} /* coalesceFreeBlocks */

/*
 * linVidMemFree = free some flat video memory
 */
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    LPVMEML     pvmem;
    LPVMEML     prev;

    if( ptr == (FLATPTR) NULL )
    {
    return;
    }

    #ifdef DEBUG
    if( pvmh == NULL )
    {
        VDPF(( 1, V, "VidMemAlloc: NULL heap handle!\n" ));
        return;
    }
    #endif

    pvmem = (LPVMEML)pvmh->allocList;
    prev = NULL;

    /*
     * run through the allocation list and look for this ptr
     * (O(N), bummer; that's what we get for not using video memory...)
     */
    while( pvmem != NULL )
    {
    if( pvmem->ptr == ptr )
    {
        /*
         * remove from allocation list
         */
        if( prev != NULL )
        {
        prev->next = pvmem->next;
        }
        else
        {
        pvmh->allocList = pvmem->next;
        }
        /*
         * keep coalescing until we can't coalesce anymore
         */
        while( pvmem != NULL )
        {
        pvmem = coalesceFreeBlocks( pvmh, pvmem );
        }
        return;
    }
    prev = pvmem;
    pvmem = pvmem->next;
    }

} /* linVidMemFree */

/*
 * linVidMemAlloc - alloc some flat video memory
 */
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch )
{
    LPVMEML     pvmem;
    LPVMEML     prev;
    LPVMEML     pnew_free;

    DWORD       dwBeforeWastage;
    DWORD       dwAfterWastage;
    FLATPTR     pAligned;
    BOOL        bDiscardable = FALSE;

    LONG        lNewPitch;

    DWORD       size;

    if( xsize == 0 || ysize == 0 || pvmh == NULL )
    {
    return (FLATPTR) NULL;
    }

    if( lpAlignment && 
        ( lpAlignment->Linear.dwFlags & SURFACEALIGN_DISCARDABLE ) )
    {
        bDiscardable = TRUE;
    }

    lNewPitch = (LONG) xsize;
    if (lpAlignment && lpAlignment->Linear.dwPitchAlignment )
    {
        if (lNewPitch % lpAlignment->Linear.dwPitchAlignment)
        {
            lNewPitch += lpAlignment->Linear.dwPitchAlignment - lNewPitch % lpAlignment->Linear.dwPitchAlignment;
        }
    }
    /*
     * This weird size calculation doesn't include the little bit on the 'bottom right' of the surface
     */
    size = (DWORD) lNewPitch * (ysize-1) + xsize;
    size = (size+(BLOCK_BOUNDARY-1)) & ~(BLOCK_BOUNDARY-1);

    /*
     * run through free list, looking for the closest matching block
     */
    prev = NULL;
    pvmem = (LPVMEML)pvmh->freeList;
    while( pvmem != NULL )
    {
    while( pvmem->size >= size ) //Using while as a try block
    {
            /*
             * Setup for no alignment changes..
             */
            pAligned = pvmem->ptr;
            dwBeforeWastage = 0;
            dwAfterWastage = pvmem->size - size;
            if( lpAlignment )
            {
                //get wastage if we put the new block at the beginning or at the end of the free block
                if( lpAlignment->Linear.dwStartAlignment )
                {
                    /*
                     * The before wastage is how much we'd have to skip at the beginning to align the surface
                     */

                    dwBeforeWastage = (lpAlignment->Linear.dwStartAlignment - ((DWORD)pvmem->ptr % lpAlignment->Linear.dwStartAlignment)) % lpAlignment->Linear.dwStartAlignment;
                    //if ( dwBeforeWastage+size > pvmem->size )
                    //    break;
                    /*
                     * The after wastage is the bit between the end of the used surface and the end of the block
                     * if we snuggle this surface as close to the end of the block as possible.
                     */
                    dwAfterWastage = ( (DWORD)pvmem->ptr + pvmem->size - size ) % lpAlignment->Linear.dwStartAlignment;
                    //if ( dwAfterWastage + size > pvmem->size )
                    //    break;
                }
                /*
                 * Reassign before/after wastage to meaningful values based on where the block will actually go.
                 * Also check that aligning won't spill the surface off either end of the block.
                 */
                if ( dwBeforeWastage <= dwAfterWastage )
                {
                    if (pvmem->size < size + dwBeforeWastage)
                    {
                        /*
                         * Alignment pushes end of surface off end of block
                         */
                        break;
                    }
                    dwAfterWastage = pvmem->size - (size + dwBeforeWastage);
                    pAligned = pvmem->ptr + dwBeforeWastage;
                }
                else
                {
                    if (pvmem->size < size + dwAfterWastage)
                    {
                        /*
                         * Alignment pushes end of surface off beginning of block
                         */
                        break;
                    }
                    dwBeforeWastage = pvmem->size - (size + dwAfterWastage);
                    pAligned = pvmem->ptr + dwBeforeWastage;
                }
            }
            DDASSERT(size + dwBeforeWastage + dwAfterWastage == pvmem->size );
            DDASSERT(pAligned >= pvmem->ptr );
            DDASSERT(pAligned + size <= pvmem->ptr + pvmem->size );
            /*
             * Remove the old free block from the free list.
             */
        if( prev != NULL )
        {
        prev->next = pvmem->next;
        }
        else
        {
        pvmh->freeList = pvmem->next;
        }

            /*
             * If the after wastage is less than a small amount, smush it into
             * this block.
             */
            if (dwAfterWastage <= MIN_SPLIT_SIZE)
            {
                size += dwAfterWastage;
                dwAfterWastage=0;
            }
            /*
             * Add the new block to the used list, using the old free block
             */
        pvmem->size = size;
        pvmem->ptr = pAligned;
            pvmem->bDiscardable = bDiscardable;
        if( NULL != lpdwSize )
        *lpdwSize = size;
            if (NULL != lpNewPitch)
                *lpNewPitch = lNewPitch;
        insertIntoList( pvmem, (LPLPVMEML) &pvmh->allocList );

            /*
             * Add a new free block for before wastage
             */
            if (dwBeforeWastage)
            {
        pnew_free = (LPVMEML)MemAlloc( sizeof( VMEML ) );
        if( pnew_free == NULL )
        {
            return (FLATPTR) NULL;
        }
        pnew_free->size = dwBeforeWastage;
        pnew_free->ptr = pAligned-dwBeforeWastage;
        insertIntoList( pnew_free, (LPLPVMEML) &pvmh->freeList );
            }
            /*
             * Add a new free block for after wastage
             */
            if (dwAfterWastage)
            {
        pnew_free = (LPVMEML)MemAlloc( sizeof( VMEML ) );
        if( pnew_free == NULL )
        {
            return (FLATPTR) NULL;
        }
        pnew_free->size = dwAfterWastage;
        pnew_free->ptr = pAligned+size;
        insertIntoList( pnew_free, (LPLPVMEML) &pvmh->freeList );
            }
#ifdef DEBUG
            if( lpAlignment )
            {
                if (lpAlignment->Linear.dwStartAlignment)
                {
                    VDPF((6,V,"Alignment for start is %d",lpAlignment->Linear.dwStartAlignment));
                    DDASSERT(pvmem->ptr % lpAlignment->Linear.dwStartAlignment == 0);
                }
                if (lpAlignment->Linear.dwPitchAlignment)
                {
                    VDPF((6,V,"Alignment for pitch is %d",lpAlignment->Linear.dwPitchAlignment));
                    DDASSERT(lNewPitch % lpAlignment->Linear.dwPitchAlignment == 0);
                }
            }
#endif
        return pvmem->ptr;
    }
    prev = pvmem;
    pvmem = pvmem->next;
    }
    return (FLATPTR) NULL;

} /* linVidMemAlloc */

/*
 * linVidMemAmountAllocated
 */
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;
    DWORD       size;

    pvmem = (LPVMEML)pvmh->allocList;
    size = 0;
    while( pvmem != NULL )
    {
        if( !( pvmem->bDiscardable ) )
        {
        size += pvmem->size;
        }
        pvmem = pvmem->next;
    }
    return size;

} /* linVidMemAmountAllocated */

/*
 * linVidMemAmountFree
 */
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;
    DWORD       size;

    pvmem = (LPVMEML)pvmh->freeList;
    size = 0;
    while( pvmem != NULL )
    {
    size += pvmem->size;
    pvmem = pvmem->next;
    }

    /*
     * Now add in the memory that's allocated but discardable
     */
    pvmem = (LPVMEML)pvmh->allocList;
    while( pvmem != NULL )
    {
        if( pvmem->bDiscardable )
        {
        size += pvmem->size;
        }
        pvmem = pvmem->next;
    }
    return size;

} /* linVidMemAmountFree */

/*
 * linVidMemLargestFree - alloc some flat video memory
 */
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;

    if( pvmh == NULL )
    {
    return 0;
    }

    pvmem = (LPVMEML)pvmh->freeList;

    if( pvmem == NULL )
    {
    return 0;
    }
    
    while( 1 )
    {
    if( pvmem->next == NULL )
    {
        return pvmem->size;
    }
    pvmem = pvmem->next;
    }
    
} /* linVidMemLargestFree */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddhmgr.cxx ===
/******************************Module*Header*******************************\
* Module Name: DdHmgr.cxx
*
* DirectDraw handle manager API entry points
*
* Created: 30-Apr-1999 23:03:03
* Author: Lindsay Steventon [linstev]
*
* Copyright (c) 1989-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

ULONG          gcSizeDdHmgr = DD_TABLESIZE_DELTA;      // Start table size
DD_ENTRY      *gpentDdHmgrLast = NULL;  // Previous handle table
DD_ENTRY      *gpentDdHmgr = NULL;      // Points to handle table
HDD_OBJ        ghFreeDdHmgr;            // Free handle
ULONG          gcMaxDdHmgr;             // Max handle alloc-ed so far
HSEMAPHORE     ghsemHmgr = NULL;        // Synchronization of the handle manager
PLARGE_INTEGER gpLockShortDelay;

// Prototype for a handy debugging routine.
#if DBG
    extern "C"
    VOID
    DdHmgPrintBadHandle(
        HDD_OBJ    hobj,
        DD_OBJTYPE objt
        );
#else
    #define DdHmgPrintBadHandle(hobj, objt)
#endif

HDD_OBJ          hDdGetFreeHandle(DD_OBJTYPE objt);
VOID             DdFreeObject(PVOID pvFree, ULONG ulType);
HDD_OBJ FASTCALL DdHmgNextOwned(HDD_OBJ hobj, W32PID pid);

/*****************************Exported*Routine*****************************\
* DdHmgCreate()
*
* Initializes a new handle manager with an initial allocation.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

BOOL 
DdHmgCreate()
{
    //
    // Initialize the handle manager allocation database.
    //

    ghFreeDdHmgr = 0;                    // No free handles
    gcMaxDdHmgr  = DD_HMGR_HANDLE_BASE;  // Initialize with handle index base

    //
    // Create memory block for handle table
    //

    gpentDdHmgr  = (DD_ENTRY *)PALLOCMEM(sizeof(DD_ENTRY) * gcSizeDdHmgr, 'ddht');
    if (gpentDdHmgr == NULL) 
    {
        WARNING("Could not allocated DDraw handle table.");   
        return(FALSE);
    }

    //
    // Initialize exclusion stuff.
    //

    if ((ghsemHmgr = EngCreateSemaphore()) == NULL)
    {
        WARNING("Could not allocated DDraw handle semaphore.");   
        VFREEMEM(gpentDdHmgr);
        gpentDdHmgr = NULL;
        return(FALSE);
    }

    //
    // allocate and initialize the timeout lock for the handle manager.
    //

    gpLockShortDelay = (PLARGE_INTEGER) PALLOCNONPAGED(sizeof(LARGE_INTEGER),
                                                       'iniG');

    if (gpLockShortDelay == NULL)
    {
        WARNING("Could not allocated DDraw shortdelay.");   
        EngDeleteSemaphore(ghsemHmgr);
        ghsemHmgr = NULL;
        VFREEMEM(gpentDdHmgr);
        gpentDdHmgr = NULL;
        return(FALSE);
    }

    gpLockShortDelay->LowPart = (ULONG) -100000;
    gpLockShortDelay->HighPart = -1;

    return(TRUE);
}

/*****************************Exported*Routine*****************************\
* DdHmgDestroy()
*
* Free memory allocated by the handle manager. This happens on system 
* shutdown. Always succeeds.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

BOOL 
DdHmgDestroy()
{
    ghFreeDdHmgr  = 0;         // Zero free handles
    gcMaxDdHmgr   = 0;         // Zero current last handle
    gcSizeDdHmgr  = 0;         // Handle table size
    gpentDdHmgrLast = NULL;    // Zero previos handle table pointer

    if (gpentDdHmgr)           // Free handle table
    {
        VFREEMEM(gpentDdHmgr); 
        gpentDdHmgr = NULL;
    }

    if (ghsemHmgr)
    {
        EngDeleteSemaphore(ghsemHmgr);
        ghsemHmgr = NULL;
    }
    
    return(TRUE);
}

/*****************************Exported*Routine*****************************\
* DdHmgCloseProcess()
*
* Free handles in handle table from process. Occurs on process cleanup.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

BOOL 
DdHmgCloseProcess(W32PID W32Pid)
{
    BOOL bRes = TRUE;

    HDD_OBJ hobj;

    DdHmgAcquireHmgrSemaphore();

    hobj = DdHmgNextOwned((HDD_OBJ) 0, W32Pid);

    DdHmgReleaseHmgrSemaphore();

    while (hobj != (HDD_OBJ) NULL)
    {
        switch (DdHmgObjtype(hobj))
        {
        case DD_DIRECTDRAW_TYPE:
            bRes = bDdDeleteDirectDrawObject((HANDLE)hobj, TRUE);
            break;

        case DD_SURFACE_TYPE:
            bRes = bDdDeleteSurfaceObject((HANDLE)hobj, NULL);
            break;

        case DD_MOTIONCOMP_TYPE:
            bRes = bDdDeleteMotionCompObject((HANDLE)hobj, NULL);
            break;

        case DD_VIDEOPORT_TYPE:
            bRes = bDdDeleteVideoPortObject((HANDLE)hobj, NULL);
            break;

        case D3D_HANDLE_TYPE:
            HRESULT hr;
            bRes = D3dDeleteHandle((HANDLE)hobj, 0, NULL, &hr) ==
                DDHAL_DRIVER_HANDLED;
            break;

        default:
            bRes = FALSE;
            break;
        }

        #if DBG
            if (bRes == FALSE)
            {
                DbgPrint("DDRAW ERROR: DdHmgCloseProcess couldn't delete "
                         "obj = %p, type j=%lx\n", hobj, DdHmgObjtype(hobj));
            }
        #endif

        // Move on to next object.

        DdHmgAcquireHmgrSemaphore();

        hobj = DdHmgNextOwned(hobj, W32Pid);

        DdHmgReleaseHmgrSemaphore();
    }

    return (bRes);
}

/******************************Public*Routine******************************\
* DdHmgValidHandle
*
* Returns TRUE if the handle is valid, FALSE if not.
*
* Note we don't need to lock the semaphore, we aren't changing anything,
* we are just looking.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

BOOL
DdHmgValidHandle(
    HDD_OBJ    hobj,
    DD_OBJTYPE objt)
{
    BOOL      bRes = FALSE;
    PDD_ENTRY pentTmp;
    UINT      uiIndex = (UINT) (UINT) DdHmgIfromH(hobj);

    //
    // Acquire the handle manager lock before touching gpentDdHmgr
    //

    DdHmgAcquireHmgrSemaphore();

    if ((uiIndex < gcMaxDdHmgr) &&
        ((pentTmp = &gpentDdHmgr[uiIndex])->Objt == objt) &&
        (pentTmp->FullUnique == DdHmgUfromH(hobj)))
    {
        ASSERTGDI(pentTmp->einfo.pobj != (PDD_OBJ) NULL, "ERROR how can it be NULL");
        bRes = TRUE;
    }

    DdHmgReleaseHmgrSemaphore();

    return (bRes);
}

/******************************Public*Routine******************************\
* DdHmgRemoveObject
*
* Removes an object from the handle table if certain conditions are met.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

PVOID
DdHmgRemoveObject(
    HDD_OBJ    hobj,
    LONG       cExclusiveLock,
    LONG       cShareLock,
    BOOL       bIgnoreUndeletable,
    DD_OBJTYPE objt)
{
    PDD_OBJ pobj;
    UINT    uiIndex = (UINT) DdHmgIfromH(hobj);

    if (uiIndex < gcMaxDdHmgr)
    {
        //
        // Acquire the handle manager lock before touching gpentDdHmgr
        //

        DdHmgAcquireHmgrSemaphore();

        //
        // lock handle
        //

        PDD_ENTRY pentTmp = &gpentDdHmgr[uiIndex];

        if (VerifyObjectOwner(pentTmp))
        {
            //
            // verify objt and unique
            //

            if ((pentTmp->Objt == objt) &&
                (pentTmp->FullUnique == DdHmgUfromH(hobj)))
            {
                pobj = pentTmp->einfo.pobj;

                if ((pobj->cExclusiveLock == (USHORT)cExclusiveLock) &&
                    (pobj->ulShareCount   == (ULONG)cShareLock))
                {
                    if (bIgnoreUndeletable || (!(pentTmp->Flags & DD_HMGR_ENTRY_UNDELETABLE)))
                    {
                        //
                        // set the handle in the object to NULL
                        // to prevent/catch accidental decrement of the
                        // shared reference count
                        //

                        pobj->hHmgr = NULL;

                        //
                        // free the handle
                        //

                        ((DD_ENTRYOBJ *) pentTmp)->vFree(uiIndex);
                    }
                    else
                    {
                        WARNING1("DdHmgRemove failed object is undeletable\n");
                        pobj = NULL;
                    }
                }
                else
                {
                    //
                    // object is busy
                    //

                     WARNING1("DdHmgRemove failed - object busy elsewhere\n");
                     pobj = NULL;
                }
            }
            else
            {
                WARNING1("DdHmgRemove: bad objt or unique\n");
                pobj = NULL;
            }
        }
        else
        {
            WARNING1("DdHmgRemove: failed to lock handle\n");
            pobj = NULL;
        }

        DdHmgReleaseHmgrSemaphore();
    }
    else
    {
        WARNING1("DdHmgRemove failed invalid index\n");
        pobj = NULL;
    }

    return((PVOID)pobj);
}

/******************************Public*Routine******************************\
* DdAllocateObject
*
* Allocates an object out of the heap.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

//
// This struct and the following union can be thrown away
// when someone fixes the BASEOBJECT cExclusiveLock and BaseFlags sharing
// the same DWORD.
//

struct SplitLockAndFlags {
  USHORT c_cExclusiveLock;
  USHORT c_BaseFlags;
};

union SplitOrCombinedLockAndFlags {
  SplitLockAndFlags S;
  ULONG W;
};

PVOID
DdAllocateObject(
    ULONG cBytes,
    ULONG ulType,
    BOOL bZero)
{

    PVOID pvReturn = NULL;

    ASSERTGDI(ulType != DD_DEF_TYPE, "DdAllocateObject ulType is bad");
    ASSERTGDI(cBytes >= sizeof(DD_BASEOBJECT), "DdAllocateObject cBytes is bad");

    //
    // Debug check to avoid assert in ExAllocatePool
    //

    #if DBG
        if (cBytes >= (PAGE_SIZE * 10000))
        {
            WARNING("DdAllocateObject: cBytes >= 10000 pages");
            return(NULL);
        }
    #endif


    ULONG ulTag = '0 hD';
    ulTag += ulType << 24;

    //
    // BASEOBJECT is always zero-initialized.
    //

    if (bZero)
    {
        pvReturn = PALLOCMEM(cBytes, ulTag);
    }
    else
    {
        pvReturn = PALLOCNOZ(cBytes, ulTag);

        //
        // At least the BASEOBJECT should be initialized.
        //

        if (pvReturn)
        {
            RtlZeroMemory(pvReturn, (UINT) sizeof(DD_BASEOBJECT));
        }
    }

    //
    // If the allocation failed again, then set the extended
    // error status and return an invalid handle.
    //

    if (!pvReturn)
    {
        KdPrint(("DXG: DdAllocateObject failed alloc of %lu bytes\n", (cBytes)));
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    return(pvReturn);
}

/******************************Public*Routine******************************\
* DdHmgAlloc
*
* Allocate an object from Handle Manager.
*
* WARNING:
* --------
*
* If the object is share-lockable via an API, you MUST use DdHmgInsertObject
* instead.  If the object is only exclusive-lockable via an API, you MUST
* either use DdHmgInsertObject or specify HMGR_ALLOC_LOCK.
*
* (This is because if you use DdHmgAlloc, a malicious multi-threaded
* application could guess the handle and cause it to be dereferenced
* b