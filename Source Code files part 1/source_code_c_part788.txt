_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRegistrar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRegistrar __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddReplacement )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearReplacements )( 
            IRegistrar __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceRegisterSz )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceUnregisterSz )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR fileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR fileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StringRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StringUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        END_INTERFACE
    } IRegistrarVtbl;

    interface IRegistrar
    {
        CONST_VTBL struct IRegistrarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegistrar_AddReplacement(This,key,item)	\
    (This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrar_ClearReplacements(This)	\
    (This)->lpVtbl -> ClearReplacements(This)

#define IRegistrar_ResourceRegisterSz(This,resFileName,szID,szType)	\
    (This)->lpVtbl -> ResourceRegisterSz(This,resFileName,szID,szType)

#define IRegistrar_ResourceUnregisterSz(This,resFileName,szID,szType)	\
    (This)->lpVtbl -> ResourceUnregisterSz(This,resFileName,szID,szType)

#define IRegistrar_FileRegister(This,fileName)	\
    (This)->lpVtbl -> FileRegister(This,fileName)

#define IRegistrar_FileUnregister(This,fileName)	\
    (This)->lpVtbl -> FileUnregister(This,fileName)

#define IRegistrar_StringRegister(This,data)	\
    (This)->lpVtbl -> StringRegister(This,data)

#define IRegistrar_StringUnregister(This,data)	\
    (This)->lpVtbl -> StringUnregister(This,data)

#define IRegistrar_ResourceRegister(This,resFileName,nID,szType)	\
    (This)->lpVtbl -> ResourceRegister(This,resFileName,nID,szType)

#define IRegistrar_ResourceUnregister(This,resFileName,nID,szType)	\
    (This)->lpVtbl -> ResourceUnregister(This,resFileName,nID,szType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_AddReplacement_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR key,
    /* [in] */ LPCOLESTR item);


void __RPC_STUB IRegistrar_AddReplacement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ClearReplacements_Proxy( 
    IRegistrar __RPC_FAR * This);


void __RPC_STUB IRegistrar_ClearReplacements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegisterSz_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregisterSz_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_FileRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_FileUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_StringRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_StringUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegistrar_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlres.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLRES_H__
#define __ATLRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif //APSTUDIO_INVOKED

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif //!WINVER

#ifndef UNDER_CE
#include <winresrc.h>

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#else // CE specific
#include <windows.h>
#endif //!UNDER_CE

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif //IDC_STATIC
#define IDC_STATIC      (-1)

#endif //!_INC_WINDOWS
#endif //RC_INVOKED

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// ATL resource types

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif //RC_INVOKED

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard window components

#define ID_SEPARATOR                    0       // special separator value

#ifndef RC_INVOKED  // code only
// standard control bars (IDW = window ID)
#define ATL_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define ATL_IDW_STATUS_BAR              0xE801  // Status bar window

// parts of a frame window
#define ATL_IDW_CLIENT                  0xE900
#define ATL_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define ATL_IDW_PANE_LAST               0xE9ff
#define ATL_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define ATL_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define ATL_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define ATL_IDW_PANE_SAVE               0xEA21  // to shift ATL_IDW_PANE_FIRST
#endif //!RC_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define ATL_IDM_WINDOW_FIRST            0xE130
#define ATL_IDM_WINDOW_LAST             0xE13F
#define ATL_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif //IDC_STATIC
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

// idle status bar message
#define ATL_IDS_IDLEMESSAGE             0xE001

#ifndef RC_INVOKED      // code only
#define ATL_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define ATL_IDS_SCSIZE                  0xEF00
#define ATL_IDS_SCMOVE                  0xEF01
#define ATL_IDS_SCMINIMIZE              0xEF02
#define ATL_IDS_SCMAXIMIZE              0xEF03
#define ATL_IDS_SCNEXTWINDOW            0xEF04
#define ATL_IDS_SCPREVWINDOW            0xEF05
#define ATL_IDS_SCCLOSE                 0xEF06
#define ATL_IDS_SCRESTORE               0xEF12
#define ATL_IDS_SCTASKLIST              0xEF13

#define ATL_IDS_MDICHILD                0xEF1F
#define ATL_IDS_MRU_FILE                0xEFDA

/////////////////////////////////////////////////////////////////////////////
// Misc. control IDs

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define ATL_IDC_TAB_CONTROL             0x3020


#endif //__ATLRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atltmp.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// atltmp.h - temporary location for these classes

#ifndef __ATLTMP_H__
#define __ATLTMP_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atltmp.h requires atlbase.h to be included first
#endif


#pragma once

#ifndef _ATL_TMP_NO_CSTRING
#include <limits.h>
#include <stdio.h>
#endif //!_ATL_TMP_NO_CSTRING

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CSize;
class CPoint;
class CRect;
#ifndef _ATL_TMP_NO_CSTRING
class CString;
#endif //!_ATL_TMP_NO_CSTRING

/////////////////////////////////////////////////////////////////////////////
// CSize - An extent, similar to Windows SIZE structure.

class CSize : public tagSIZE
{
public:
// Constructors
	CSize();
	CSize(int initCX, int initCY);
	CSize(SIZE initSize);
	CSize(POINT initPt);
	CSize(DWORD dwSize);

// Operations
	BOOL operator==(SIZE size) const;
	BOOL operator!=(SIZE size) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);

// Operators returning CSize values
	CSize operator+(SIZE size) const;
	CSize operator-(SIZE size) const;
	CSize operator-() const;

// Operators returning CPoint values
	CPoint operator+(POINT point) const;
	CPoint operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};

/////////////////////////////////////////////////////////////////////////////
// CPoint - A 2-D point, similar to Windows POINT structure.

class CPoint : public tagPOINT
{
public:
// Constructors
	CPoint();
	CPoint(int initX, int initY);
	CPoint(POINT initPt);
	CPoint(SIZE initSize);
	CPoint(DWORD dwPoint);

// Operations
	void Offset(int xOffset, int yOffset);
	void Offset(POINT point);
	void Offset(SIZE size);
	BOOL operator==(POINT point) const;
	BOOL operator!=(POINT point) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
	void operator+=(POINT point);
	void operator-=(POINT point);

// Operators returning CPoint values
	CPoint operator+(SIZE size) const;
	CPoint operator-(SIZE size) const;
	CPoint operator-() const;
	CPoint operator+(POINT point) const;

// Operators returning CSize values
	CSize operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};

/////////////////////////////////////////////////////////////////////////////
// CRect - A 2-D rectangle, similar to Windows RECT structure.

//typedef const RECT* LPCRECT;    // pointer to read/only RECT

class CRect : public tagRECT
{
public:
// Constructors
	CRect();
	CRect(int l, int t, int r, int b);
	CRect(const RECT& srcRect);
	CRect(LPCRECT lpSrcRect);
	CRect(POINT point, SIZE size);
	CRect(POINT topLeft, POINT bottomRight);

// Attributes (in addition to RECT members)
	int Width() const;
	int Height() const;
	CSize Size() const;
	CPoint& TopLeft();
	CPoint& BottomRight();
	const CPoint& TopLeft() const;
	const CPoint& BottomRight() const;
	CPoint CenterPoint() const;

	// convert between CRect and LPRECT/LPCRECT (no need for &)
	operator LPRECT();
	operator LPCRECT() const;

	BOOL IsRectEmpty() const;
	BOOL IsRectNull() const;
	BOOL PtInRect(POINT point) const;

// Operations
	void SetRect(int x1, int y1, int x2, int y2);
	void SetRect(POINT topLeft, POINT bottomRight);
	void SetRectEmpty();
	void CopyRect(LPCRECT lpSrcRect);
	BOOL EqualRect(LPCRECT lpRect) const;

	void InflateRect(int x, int y);
	void InflateRect(SIZE size);
	void InflateRect(LPCRECT lpRect);
	void InflateRect(int l, int t, int r, int b);
	void DeflateRect(int x, int y);
	void DeflateRect(SIZE size);
	void DeflateRect(LPCRECT lpRect);
	void DeflateRect(int l, int t, int r, int b);

	void OffsetRect(int x, int y);
	void OffsetRect(SIZE size);
	void OffsetRect(POINT point);
	void NormalizeRect();

	// operations that fill '*this' with result
	BOOL IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL UnionRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2);

// Additional Operations
	void operator=(const RECT& srcRect);
	BOOL operator==(const RECT& rect) const;
	BOOL operator!=(const RECT& rect) const;
	void operator+=(POINT point);
	void operator+=(SIZE size);
	void operator+=(LPCRECT lpRect);
	void operator-=(POINT point);
	void operator-=(SIZE size);
	void operator-=(LPCRECT lpRect);
	void operator&=(const RECT& rect);
	void operator|=(const RECT& rect);

// Operators returning CRect values
	CRect operator+(POINT point) const;
	CRect operator-(POINT point) const;
	CRect operator+(LPCRECT lpRect) const;
	CRect operator+(SIZE size) const;
	CRect operator-(SIZE size) const;
	CRect operator-(LPCRECT lpRect) const;
	CRect operator&(const RECT& rect2) const;
	CRect operator|(const RECT& rect2) const;
	CRect MulDiv(int nMultiplier, int nDivisor) const;
};

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _ATL_TMP_NO_CSTRING

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
	typedef LPSTR BSTR;
#else
	typedef LPWSTR BSTR; // must (semantically) match typedef in oleauto.h
#endif
#endif

int __stdcall AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf);

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString __stdcall operator+(const CString& string1, const CString& string2);
	friend CString __stdcall operator+(const CString& string, TCHAR ch);
	friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString __stdcall operator+(const CString& string, char ch);
	friend CString __stdcall operator+(char ch, const CString& string);
#endif
	friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void __cdecl Format(LPCTSTR lpszFormat, ...);
	void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	BOOL AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	BOOL AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool __stdcall operator==(const CString& s1, const CString& s2);
bool __stdcall operator==(const CString& s1, LPCTSTR s2);
bool __stdcall operator==(LPCTSTR s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, LPCTSTR s2);
bool __stdcall operator!=(LPCTSTR s1, const CString& s2);
bool __stdcall operator<(const CString& s1, const CString& s2);
bool __stdcall operator<(const CString& s1, LPCTSTR s2);
bool __stdcall operator<(LPCTSTR s1, const CString& s2);
bool __stdcall operator>(const CString& s1, const CString& s2);
bool __stdcall operator>(const CString& s1, LPCTSTR s2);
bool __stdcall operator>(LPCTSTR s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, LPCTSTR s2);
bool __stdcall operator<=(LPCTSTR s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, LPCTSTR s2);
bool __stdcall operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals

// afxChNil is left for backward compatibility
_declspec(selectany) TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
_declspec(selectany) int rgInitData[] = { -1, 0, 0, 0 };
_declspec(selectany) CStringData* afxDataNil = (CStringData*)&rgInitData;
_declspec(selectany) LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));

inline const CString& __stdcall AfxGetEmptyString()
	{ return *(CString*)&afxPchNil; }
#define afxEmptyString AfxGetEmptyString()

#endif //!_ATL_TMP_NO_CSTRING

/////////////////////////////////////////////////////////////////////////////
// Implementation

// CSize
inline CSize::CSize()
	{ /* random filled */ }
inline CSize::CSize(int initCX, int initCY)
	{ cx = initCX; cy = initCY; }
inline CSize::CSize(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CSize::CSize(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CSize::CSize(DWORD dwSize)
	{
		cx = (short)LOWORD(dwSize);
		cy = (short)HIWORD(dwSize);
	}
inline BOOL CSize::operator==(SIZE size) const
	{ return (cx == size.cx && cy == size.cy); }
inline BOOL CSize::operator!=(SIZE size) const
	{ return (cx != size.cx || cy != size.cy); }
inline void CSize::operator+=(SIZE size)
	{ cx += size.cx; cy += size.cy; }
inline void CSize::operator-=(SIZE size)
	{ cx -= size.cx; cy -= size.cy; }
inline CSize CSize::operator+(SIZE size) const
	{ return CSize(cx + size.cx, cy + size.cy); }
inline CSize CSize::operator-(SIZE size) const
	{ return CSize(cx - size.cx, cy - size.cy); }
inline CSize CSize::operator-() const
	{ return CSize(-cx, -cy); }
inline CPoint CSize::operator+(POINT point) const
	{ return CPoint(cx + point.x, cy + point.y); }
inline CPoint CSize::operator-(POINT point) const
	{ return CPoint(cx - point.x, cy - point.y); }
inline CRect CSize::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CSize::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CPoint
inline CPoint::CPoint()
	{ /* random filled */ }
inline CPoint::CPoint(int initX, int initY)
	{ x = initX; y = initY; }
inline CPoint::CPoint(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CPoint::CPoint(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CPoint::CPoint(DWORD dwPoint)
	{
		x = (short)LOWORD(dwPoint);
		y = (short)HIWORD(dwPoint);
	}
inline void CPoint::Offset(int xOffset, int yOffset)
	{ x += xOffset; y += yOffset; }
inline void CPoint::Offset(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::Offset(SIZE size)
	{ x += size.cx; y += size.cy; }
inline BOOL CPoint::operator==(POINT point) const
	{ return (x == point.x && y == point.y); }
inline BOOL CPoint::operator!=(POINT point) const
	{ return (x != point.x || y != point.y); }
inline void CPoint::operator+=(SIZE size)
	{ x += size.cx; y += size.cy; }
inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
inline void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
inline CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
inline CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
inline CPoint CPoint::operator-() const
	{ return CPoint(-x, -y); }
inline CPoint CPoint::operator+(POINT point) const
	{ return CPoint(x + point.x, y + point.y); }
inline CSize CPoint::operator-(POINT point) const
	{ return CSize(x - point.x, y - point.y); }
inline CRect CPoint::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CPoint::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CRect
inline CRect::CRect()
	{ /* random filled */ }
inline CRect::CRect(int l, int t, int r, int b)
	{ left = l; top = t; right = r; bottom = b; }
inline CRect::CRect(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline CRect::CRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline CRect::CRect(POINT point, SIZE size)
	{ right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }
inline CRect::CRect(POINT topLeft, POINT bottomRight)
	{ left = topLeft.x; top = topLeft.y;
		right = bottomRight.x; bottom = bottomRight.y; }
inline int CRect::Width() const
	{ return right - left; }
inline int CRect::Height() const
	{ return bottom - top; }
inline CSize CRect::Size() const
	{ return CSize(right - left, bottom - top); }
inline CPoint& CRect::TopLeft()
	{ return *((CPoint*)this); }
inline CPoint& CRect::BottomRight()
	{ return *((CPoint*)this+1); }
inline const CPoint& CRect::TopLeft() const
	{ return *((CPoint*)this); }
inline const CPoint& CRect::BottomRight() const
	{ return *((CPoint*)this+1); }
inline CPoint CRect::CenterPoint() const
	{ return CPoint((left+right)/2, (top+bottom)/2); }
inline CRect::operator LPRECT()
	{ return this; }
inline CRect::operator LPCRECT() const
	{ return this; }
inline BOOL CRect::IsRectEmpty() const
	{ return ::IsRectEmpty(this); }
inline BOOL CRect::IsRectNull() const
	{ return (left == 0 && right == 0 && top == 0 && bottom == 0); }
inline BOOL CRect::PtInRect(POINT point) const
	{ return ::PtInRect(this, point); }
inline void CRect::SetRect(int x1, int y1, int x2, int y2)
	{ ::SetRect(this, x1, y1, x2, y2); }
inline void CRect::SetRect(POINT topLeft, POINT bottomRight)
	{ ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
inline void CRect::SetRectEmpty()
	{ ::SetRectEmpty(this); }
inline void CRect::CopyRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline BOOL CRect::EqualRect(LPCRECT lpRect) const
	{ return ::EqualRect(this, lpRect); }
inline void CRect::InflateRect(int x, int y)
	{ ::InflateRect(this, x, y); }
inline void CRect::InflateRect(SIZE size)
	{ ::InflateRect(this, size.cx, size.cy); }
inline void CRect::DeflateRect(int x, int y)
	{ ::InflateRect(this, -x, -y); }
inline void CRect::DeflateRect(SIZE size)
	{ ::InflateRect(this, -size.cx, -size.cy); }
inline void CRect::OffsetRect(int x, int y)
	{ ::OffsetRect(this, x, y); }
inline void CRect::OffsetRect(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::OffsetRect(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline BOOL CRect::IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::IntersectRect(this, lpRect1, lpRect2);}
inline BOOL CRect::UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::UnionRect(this, lpRect1, lpRect2); }
inline void CRect::operator=(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline BOOL CRect::operator==(const RECT& rect) const
	{ return ::EqualRect(this, &rect); }
inline BOOL CRect::operator!=(const RECT& rect) const
	{ return !::EqualRect(this, &rect); }
inline void CRect::operator+=(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::operator+=(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline void CRect::operator+=(LPCRECT lpRect)
	{ InflateRect(lpRect); }
inline void CRect::operator-=(POINT point)
	{ ::OffsetRect(this, -point.x, -point.y); }
inline void CRect::operator-=(SIZE size)
	{ ::OffsetRect(this, -size.cx, -size.cy); }
inline void CRect::operator-=(LPCRECT lpRect)
	{ DeflateRect(lpRect); }
inline void CRect::operator&=(const RECT& rect)
	{ ::IntersectRect(this, this, &rect); }
inline void CRect::operator|=(const RECT& rect)
	{ ::UnionRect(this, this, &rect); }
inline CRect CRect::operator+(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, pt.x, pt.y); return rect; }
inline CRect CRect::operator-(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, -pt.x, -pt.y); return rect; }
inline CRect CRect::operator+(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, size.cx, size.cy); return rect; }
inline CRect CRect::operator-(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, -size.cx, -size.cy); return rect; }
inline CRect CRect::operator+(LPCRECT lpRect) const
	{ CRect rect(this); rect.InflateRect(lpRect); return rect; }
inline CRect CRect::operator-(LPCRECT lpRect) const
	{ CRect rect(this); rect.DeflateRect(lpRect); return rect; }
inline CRect CRect::operator&(const RECT& rect2) const
	{ CRect rect; ::IntersectRect(&rect, this, &rect2);
		return rect; }
inline CRect CRect::operator|(const RECT& rect2) const
	{ CRect rect; ::UnionRect(&rect, this, &rect2);
		return rect; }
inline BOOL CRect::SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
	{ return ::SubtractRect(this, lpRectSrc1, lpRectSrc2); }

inline void CRect::NormalizeRect()
{
	int nTemp;
	if (left > right)
	{
		nTemp = left;
		left = right;
		right = nTemp;
	}
	if (top > bottom)
	{
		nTemp = top;
		top = bottom;
		bottom = nTemp;
	}
}

inline void CRect::InflateRect(LPCRECT lpRect)
{
	left -= lpRect->left;
	top -= lpRect->top;
	right += lpRect->right;
	bottom += lpRect->bottom;
}

inline void CRect::InflateRect(int l, int t, int r, int b)
{
	left -= l;
	top -= t;
	right += r;
	bottom += b;
}

inline void CRect::DeflateRect(LPCRECT lpRect)
{
	left += lpRect->left;
	top += lpRect->top;
	right -= lpRect->right;
	bottom -= lpRect->bottom;
}

inline void CRect::DeflateRect(int l, int t, int r, int b)
{
	left += l;
	top += t;
	right -= r;
	bottom -= b;
}

inline CRect CRect::MulDiv(int nMultiplier, int nDivisor) const
{
	return CRect(
		::MulDiv(left, nMultiplier, nDivisor),
		::MulDiv(top, nMultiplier, nDivisor),
		::MulDiv(right, nMultiplier, nDivisor),
		::MulDiv(bottom, nMultiplier, nDivisor));
}


#ifndef _ATL_TMP_NO_CSTRING

// CString
inline CStringData* CString::GetData() const
	{ ATLASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
inline void CString::Init()
	{ m_pchData = afxEmptyString.m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString __stdcall operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString __stdcall operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool __stdcall operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool __stdcall operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool __stdcall operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool __stdcall operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool __stdcall operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool __stdcall operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

inline BOOL __stdcall AfxIsValidString(LPCWSTR lpsz, int nLength)
{
	if(lpsz == NULL)
		return FALSE;
	return !::IsBadStringPtrW(lpsz, nLength);
}

inline BOOL __stdcall AfxIsValidString(LPCSTR lpsz, int nLength)
{
	if(lpsz == NULL)
		return FALSE;
	return !::IsBadStringPtrA(lpsz, nLength);
}

inline BOOL __stdcall AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

inline CString::CString()
{
	Init();
}

inline CString::CString(const CString& stringSrc)
{
	ATLASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ATLASSERT(stringSrc.GetData() != afxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

inline BOOL CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ATLASSERT(nLen >= 0);
	ATLASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CStringData* pData = NULL;
		ATLTRY(pData = (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)]);
		if(pData == NULL)
			return FALSE;

		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}

	return TRUE;
}

inline void CString::Release()
{
	if (GetData() != afxDataNil)
	{
		ATLASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

inline void PASCAL CString::Release(CStringData* pData)
{
	if (pData != afxDataNil)
	{
		ATLASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

inline void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &afxChNil;
	ATLASSERT(GetData()->nDataLength == 0);
	ATLASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

inline void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		if(AllocBuffer(pData->nDataLength))
			memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ATLASSERT(GetData()->nRefs <= 1);
}

inline BOOL CString::AllocBeforeWrite(int nLen)
{
	BOOL bRet = TRUE;
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		bRet = AllocBuffer(nLen);
	}
	ATLASSERT(GetData()->nRefs <= 1);
	return bRet;
}

inline CString::~CString()
//  free any attached data
{
	if (GetData() != afxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

inline void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		if(dest.AllocBuffer(nNewLen))
			memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

inline CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
		UINT nID = LOWORD((DWORD_PTR)lpsz);
		if (!LoadString(nID))
#if (_ATL_VER >= 0x0300)
			ATLTRACE2(atlTraceGeneral, 0, _T("Warning: implicit LoadString(%u) in CString failed\n"), nID);
#else
			ATLTRACE2(atlTraceGeneral, 0, _T("Warning: implicit LoadString in CString failed\n"));
#endif //(_ATL_VER >= 0x0300)
	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			if(AllocBuffer(nLen))
				memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

#ifdef _UNICODE
inline CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen))
		{
			_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
			ReleaseBuffer();
		}
	}
}
#else //_UNICODE
inline CString::CString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen*2))
		{
			_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
			ReleaseBuffer();
		}
	}
}
#endif //!_UNICODE

// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

inline void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if(AllocBeforeWrite(nSrcLen))
	{
		memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength = nSrcLen;
		m_pchData[nSrcLen] = '\0';
	}
}

inline const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ATLASSERT(stringSrc.GetData() != afxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

inline const CString& CString::operator=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

#ifdef _UNICODE
inline const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen))
	{
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
	return *this;
}
#else //!_UNICODE
inline const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen*2))
	{
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!_UNICODE

// Concatenation
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

inline void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		if(AllocBuffer(nNewLen))
		{
			memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
			memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
		}
	}
}

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CString::SafeStrlen(lpsz), lpsz);
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

inline void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ATLASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

inline const CString& CString::operator+=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

inline const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

inline const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

inline LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ATLASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		if(AllocBuffer(nMinBufLength))
		{
			memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
			GetData()->nDataLength = nOldLen;
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ATLASSERT(m_pchData != NULL);
	return m_pchData;
}

inline void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ATLASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

inline LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ATLASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

inline void CString::FreeExtra()
{
	ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		if(AllocBuffer(GetData()->nDataLength))
		{
			memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
			ATLASSERT(m_pchData[GetData()->nDataLength] == '\0');
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData() != NULL);
}

inline LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

inline void CString::UnlockBuffer()
{
	ATLASSERT(GetData()->nRefs == -1);
	if (GetData() != afxDataNil)
		GetData()->nRefs = 1;
}

inline int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

inline void CString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

inline void CString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

inline void CString::SetAt(int nIndex, TCHAR ch)
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
inline void CString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
inline void CString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

// CString conversion helpers (these use the current system locale)

inline int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ATLASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

inline int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, count);
	ATLASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

inline CString::CString(TCHAR ch, int nLength)
{
	ATLASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		if(AllocBuffer(nLength))
		{
#ifdef _UNICODE
			for (int i = 0; i < nLength; i++)
				m_pchData[i] = ch;
#else
			memset(m_pchData, ch, nLength);
#endif
		}
	}
}

inline CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ATLASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		if(AllocBuffer(nLength))
			memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

inline const CString& CString::operator=(TCHAR ch)
{
	ATLASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

inline CString __stdcall operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

inline CString __stdcall operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

inline CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

inline CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

inline CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
inline CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
inline CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(_tcscspn(m_pchData, lpszCharSet));
}

inline int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
inline int CString::Find(LPCTSTR lpszSub) const
{
	ATLASSERT(AfxIsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

#if defined(_X86_)
	#define DOUBLE_ARG  _AFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

inline void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ATLASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += _tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ATLASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ATLASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = FORCE_ANSI;
			lpsz = _tcsinc(lpsz);
			break;
		case 'l':
			nModifier = FORCE_UNICODE;
			lpsz = _tcsinc(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = _tcsinc(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = lstrlen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
#ifndef _UNICODE
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#else
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#endif
			break;
		}

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'f':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ATLASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
	int nRet = _vstprintf(m_pchData, lpszFormat, argListSave);
	nRet;	// ref
	ATLASSERT(nRet <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
inline void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	ATLASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

inline void __cdecl CString::Format(UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
inline BOOL __cdecl CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline BOOL __cdecl CString::FormatMessage(UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

inline void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

inline BOOL CString::LoadString(UINT nID)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[256];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = AfxLoadString(nID, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = 256;
	do
	{
		nSize += 256;
		nLen = AfxLoadString(nID, GetBuffer(nSize-1), nSize);
	} while (nSize - nLen <= CHAR_FUDGE);
	ReleaseBuffer();

	return nLen > 0;
}

inline int __stdcall AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
	ATLASSERT(AfxIsValidAddress(lpszBuf, nMaxBuf*sizeof(TCHAR)));
#ifdef _DEBUG
	// LoadString without annoying warning from the Debug kernel if the
	//  segment containing the string is not present
	if (::FindResource(_Module.GetResourceInstance(),
	   MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
	{
		lpszBuf[0] = '\0';
		return 0; // not found
	}
#endif //_DEBUG
	int nLen = ::LoadString(_Module.GetResourceInstance(), nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

#ifndef _ATL_NO_COM
inline BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	BSTR bstr = ::SysAllocStringLen(NULL, nLen);
	if(bstr != NULL)
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, bstr, nLen);
#endif
	return bstr;
}

inline BSTR CString::SetSysString(BSTR* pbstr) const
{
	ATLASSERT(AfxIsValidAddress(pbstr, sizeof(BSTR)));

#if defined(_UNICODE) || defined(OLE2ANSI)
	::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	if(::SysReAllocStringLen(pbstr, NULL, nLen))
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, *pbstr, nLen);
#endif
	ATLASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif //!_ATL_NO_COM

#endif //!_ATL_TMP_NO_CSTRING

}; //namespace ATL

#endif // __ATLTMP_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlwin.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN_H__
	#error atlwin.cpp requires atlwin.h to be included first
#endif

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// CWindow

HWND CWindow::GetDescendantWindow(int nID) const
{
	_ASSERTE(::IsWindow(m_hWnd));

	// GetDlgItem recursive (return first found)
	// breadth-first for 1 level, then depth-first for next level

	// use GetDlgItem since it is a fast USER function
	HWND hWndChild, hWndTmp;
	CWindow wnd;
	if((hWndChild = ::GetDlgItem(m_hWnd, nID)) != NULL)
	{
		if(::GetTopWindow(hWndChild) != NULL)
		{
			// children with the same ID as their parent have priority
			wnd.Attach(hWndChild);
			hWndTmp = wnd.GetDescendantWindow(nID);
			if(hWndTmp != NULL)
				return hWndTmp;
		}
		return hWndChild;
	}

	// walk each child
	for(hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		wnd.Attach(hWndChild);
		hWndTmp = wnd.GetDescendantWindow(nID);
		if(hWndTmp != NULL)
			return hWndTmp;
	}

	return NULL;    // not found
}

void CWindow::SendMessageToDescendants(UINT message, WPARAM wParam/*= 0*/, LPARAM lParam/*= 0*/, BOOL bDeep/* = TRUE*/)
{
	CWindow wnd;
	for(HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		::SendMessage(hWndChild, message, wParam, lParam);

		if(bDeep && ::GetTopWindow(hWndChild) != NULL)
		{
			// send to child windows after parent
			wnd.Attach(hWndChild);
			wnd.SendMessageToDescendants(message, wParam, lParam, bDeep);
		}
	}
}

BOOL CWindow::CenterWindow(HWND hWndCenter/* = NULL*/)
{
	_ASSERTE(::IsWindow(m_hWnd));

	// determine owner window to center against
	DWORD dwStyle = GetStyle();
	if(hWndCenter == NULL)
	{
		if(dwStyle & WS_CHILD)
			hWndCenter = ::GetParent(m_hWnd);
		else
			hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
	}

	// get coordinates of the window relative to its parent
	RECT rcDlg;
	::GetWindowRect(m_hWnd, &rcDlg);
	RECT rcArea;
	RECT rcCenter;
	HWND hWndParent;
	if(!(dwStyle & WS_CHILD))
	{
		// don't center against invisible or minimized windows
		if(hWndCenter != NULL)
		{
			DWORD dwStyle = ::GetWindowLong(hWndCenter, GWL_STYLE);
			if(!(dwStyle & WS_VISIBLE) || (dwStyle & WS_MINIMIZE))
				hWndCenter = NULL;
		}

		// center within screen coordinates
		::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

		if(hWndCenter == NULL)
			rcCenter = rcArea;
		else
			::GetWindowRect(hWndCenter, &rcCenter);
	}
	else
	{
		// center within parent client coordinates
		hWndParent = ::GetParent(m_hWnd);
		_ASSERTE(::IsWindow(hWndParent));

		::GetClientRect(hWndParent, &rcArea);
		_ASSERTE(::IsWindow(hWndCenter));
		::GetClientRect(hWndCenter, &rcCenter);
		::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
	}

	int DlgWidth = rcDlg.right - rcDlg.left;
	int DlgHeight = rcDlg.bottom - rcDlg.top;

	// find dialog's upper left based on rcCenter
	int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
	int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

	// if the dialog is outside the screen, move it inside
	if(xLeft < rcArea.left)
		xLeft = rcArea.left;
	else if(xLeft + DlgWidth > rcArea.right)
		xLeft = rcArea.right - DlgWidth;

	if(yTop < rcArea.top)
		yTop = rcArea.top;
	else if(yTop + DlgHeight > rcArea.bottom)
		yTop = rcArea.bottom - DlgHeight;

	// map screen coordinates to child coordinates
	return ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, -1, -1,
		SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

BOOL CWindow::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	_ASSERTE(::IsWindow(m_hWnd));

	DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE);
	DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
	if(dwStyle == dwNewStyle)
		return FALSE;

	::SetWindowLong(m_hWnd, GWL_STYLE, dwNewStyle);
	if(nFlags != 0)
	{
		::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
			SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
	}

	return TRUE;
}

BOOL CWindow::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	_ASSERTE(::IsWindow(m_hWnd));

	DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
	DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
	if(dwStyle == dwNewStyle)
		return FALSE;

	::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwNewStyle);
	if(nFlags != 0)
	{
		::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
			SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
	}

	return TRUE;
}

BOOL CWindow::GetWindowText(BSTR& bstrText)
{
	USES_CONVERSION;
	_ASSERTE(::IsWindow(m_hWnd));

	int nLen = ::GetWindowTextLength(m_hWnd);
	if(nLen == 0)
		return FALSE;

	LPTSTR lpszText = (LPTSTR)_alloca((nLen+1)*sizeof(TCHAR));

	if(!::GetWindowText(m_hWnd, lpszText, nLen+1))
		return FALSE;

	bstrText = ::SysAllocString(T2OLE(lpszText));

	return (bstrText != NULL) ? TRUE : FALSE;
}

HWND CWindow::GetTopLevelParent() const
{
	_ASSERTE(::IsWindow(m_hWnd));

	HWND hWndParent = m_hWnd;
	HWND hWndTmp;
	while((hWndTmp = ::GetParent(hWndParent)) != NULL)
		hWndParent = hWndTmp;

	return hWndParent;
}

HWND CWindow::GetTopLevelWindow() const
{
	_ASSERTE(::IsWindow(m_hWnd));

	HWND hWndParent = m_hWnd;
	HWND hWndTmp = hWndParent;

	while(hWndTmp != NULL)
	{
		hWndTmp = (::GetWindowLong(hWndParent, GWL_STYLE) & WS_CHILD) ? ::GetParent(hWndParent) : ::GetWindow(hWndParent, GW_OWNER);
		hWndParent = hWndTmp;
	}

	return hWndParent;
}

/////////////////////////////////////////////////////////////////////////////
// CDynamicChain

CDynamicChain::~CDynamicChain()
{
	if(m_pChainEntry != NULL)
	{
		for(int i = 0; i < m_nEntries; i++)
		{
			if(m_pChainEntry[i] != NULL)
				delete m_pChainEntry[i];
		}

		delete [] m_pChainEntry;
	}
}

BOOL CDynamicChain::SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID /* = 0 */)
{
// first search for an existing entry

	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
		{
			m_pChainEntry[i]->m_pObject = pObject;
			m_pChainEntry[i]->m_dwMsgMapID = dwMsgMapID;
			return TRUE;
		}
	}

// create a new one

	ATL_CHAIN_ENTRY* pEntry = NULL;
	ATLTRY(pEntry = new ATL_CHAIN_ENTRY);

	if(pEntry == NULL)
		return FALSE;

// search for an empty one

	for(i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] == NULL)
		{
			m_pChainEntry[i] = pEntry;
			return TRUE;
		}
	}

// add a new one

	ATL_CHAIN_ENTRY** ppNew = NULL;
	ATLTRY(ppNew = new ATL_CHAIN_ENTRY*[m_nEntries + 1]);

	if(ppNew == NULL)
	{
		delete pEntry;
		return FALSE;
	}

	pEntry->m_dwChainID = dwChainID;
	pEntry->m_pObject = pObject;
	pEntry->m_dwMsgMapID = dwMsgMapID;

	if(m_pChainEntry != NULL)
	{
		memcpy(ppNew, m_pChainEntry, m_nEntries * sizeof(ATL_CHAIN_ENTRY*));
		delete [] m_pChainEntry;
	}

	m_pChainEntry = ppNew;

	m_pChainEntry[m_nEntries] = pEntry;

	m_nEntries++;

	return TRUE;
}

BOOL CDynamicChain::RemoveChainEntry(DWORD dwChainID)
{
	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
		{
			delete m_pChainEntry[i];
			m_pChainEntry[i] = NULL;
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CDynamicChain::CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
{
	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
			return (m_pChainEntry[i]->m_pObject)->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, m_pChainEntry[i]->m_dwMsgMapID);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWndClassInfo

ATOM CWndClassInfo::Register(WNDPROC* pProc)
{
	if (m_atom == 0)
	{
		::EnterCriticalSection(&_Module.m_csWindowCreate);
		__try 
		{
			if(m_atom == 0)
			{
				HINSTANCE hInst = _Module.GetModuleInstance();
				if (m_lpszOrigName != NULL)
				{
					_ASSERTE(pProc != NULL);
					LPCTSTR lpsz = m_wc.lpszClassName;
					WNDPROC proc = m_wc.lpfnWndProc;

					WNDCLASSEX wc;
					wc.cbSize = sizeof(WNDCLASSEX);
					if(!::GetClassInfoEx(NULL, m_lpszOrigName, &wc))
					{
						::LeaveCriticalSection(&_Module.m_csWindowCreate);
						return 0;
					}
					memcpy(&m_wc, &wc, sizeof(WNDCLASSEX));
					pWndProc = m_wc.lpfnWndProc;
					m_wc.lpszClassName = lpsz;
					m_wc.lpfnWndProc = proc;
				}
				else
				{
					m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst,
						m_lpszCursorID);
				}

				m_wc.hInstance = hInst;
				m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
				if (m_wc.lpszClassName == NULL)
				{
#ifdef _WIN64       // %p isn't available on Win2k/Win9x
                                        wsprintf(m_szAutoName, _T("ATL:%p"), &m_wc);
#else
                                        wsprintf(m_szAutoName, _T("ATL:%8.8X"), PtrToUlong(&m_wc));
#endif
					m_wc.lpszClassName = m_szAutoName;
				}
				WNDCLASSEX wcTemp;
				memcpy(&wcTemp, &m_wc, sizeof(WNDCLASSEX));
				m_atom = (ATOM) ::GetClassInfoEx(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);
				if (m_atom == 0)
					m_atom = ::RegisterClassEx(&m_wc);
			}
		}
		__finally 
		{
			::LeaveCriticalSection(&_Module.m_csWindowCreate);
		}
	}

	if (m_lpszOrigName != NULL)
	{
		_ASSERTE(pProc != NULL);
		_ASSERTE(pWndProc != NULL);
		*pProc = pWndProc;
	}
	return m_atom;
}

/////////////////////////////////////////////////////////////////////////////
// CWindowImpl

LRESULT CALLBACK CWindowImplBase::StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBase* pT = (CWindowImplBase*)_Module.ExtractCreateWndData();
	_ASSERTE(pT != NULL);
	pT->m_hWnd = hWnd;
	pT->m_thunk.Init(WindowProc, pT);
	WNDPROC pProc = (WNDPROC)(pT->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	// if somebody has subclassed us already we can't do anything,
	// so discard return value from SetWindowLong
	return pProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CWindowImplBase::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBase* pT = (CWindowImplBase*)hWnd;
	LRESULT lRes;
	BOOL bRet = pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	if(uMsg == WM_NCDESTROY)
	{
		pT->m_hWnd = NULL;
		return 0;
	}
	if(bRet)
		return lRes;
	return pT->DefWindowProc(uMsg, wParam, lParam);
}

#ifdef _WIN64
static LONG g_nNextWindowID;  // Intentionally left uninitialized.
#endif

HWND CWindowImplBase::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
		DWORD dwStyle, DWORD dwExStyle, UINT_PTR nID, ATOM atom)
{
	_ASSERTE(m_hWnd == NULL);

	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
   {
#ifdef _WIN64
      nID = InterlockedIncrement( &g_nNextWindowID );
      nID |= 0x80000000;  // Make sure the ID isn't zero
#else
      nID = (UINT)this;
#endif
   }

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
		dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
		rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID,
		_Module.GetModuleInstance(), NULL);

	_ASSERTE(m_hWnd == hWnd);

	return hWnd;
}

BOOL CWindowImplBase::SubclassWindow(HWND hWnd)
{
	_ASSERTE(m_hWnd == NULL);
	_ASSERTE(::IsWindow(hWnd));
	m_thunk.Init(WindowProc, this);
	WNDPROC pProc = (WNDPROC)(m_thunk.thunk.pThunk);
	WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

HWND CWindowImplBase::UnsubclassWindow()
{
	_ASSERTE(m_hWnd != NULL);

	if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
		return NULL;

	m_pfnSuperWindowProc = ::DefWindowProc;

	HWND hWnd = m_hWnd;
	m_hWnd = NULL;

	return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogImplBase

INT_PTR CALLBACK CDialogImplBase::StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBase* pT = (CDialogImplBase*)_Module.ExtractCreateWndData();
	_ASSERTE(pT != NULL);
	pT->m_hWnd = hWnd;
	pT->m_thunk.Init((WNDPROC)DialogProc, pT);
	WNDPROC pProc = (WNDPROC)(pT->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);
	// check if somebody has subclassed us already since we don't hold onto it
	ATLTRACE(_T("Subclassing through a hook discarded.\n"));
	return pProc(hWnd, uMsg, wParam, lParam);
}

INT_PTR CALLBACK CDialogImplBase::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBase* pT = (CDialogImplBase*)hWnd;
	LRESULT lRes;
	if(pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0))
	{
		switch (uMsg)
		{
		case WM_COMPAREITEM:
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_INITDIALOG:
		case WM_QUERYDRAGICON:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			return lRes;
			break;
		}
		if (lRes != 0)
			::SetWindowLongPtr(pT->m_hWnd, DWLP_MSGRESULT, lRes);
		return TRUE;
	}
	return FALSE;
}

BOOL CDialogImplBase::EndDialog(int nRetCode)
{
	_ASSERTE(m_hWnd);
	return ::EndDialog(m_hWnd, nRetCode);
}

/////////////////////////////////////////////////////////////////////////////
// CContainedWindow

LRESULT CALLBACK CContainedWindow::StartWindowProc(HWND hWnd, UINT uMsg,
	WPARAM wParam, LPARAM lParam)
{
	CContainedWindow* pThis = (CContainedWindow*)_Module.ExtractCreateWndData();
	_ASSERTE(pThis != NULL);
	pThis->m_hWnd = hWnd;
	pThis->m_thunk.Init(pThis->WindowProc, pThis);
	WNDPROC pProc = (WNDPROC)(pThis->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	// check if somebody has subclassed us already since we don't hold onto it
	ATLTRACE(_T("Subclassing through a hook discarded.\n"));
	return pProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CContainedWindow::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	CContainedWindow* pT = (CContainedWindow*)hWnd;
	_ASSERTE(pT->m_hWnd != NULL);
	_ASSERTE(pT->m_pObject != NULL);

	LRESULT lRes;
	BOOL bRet = pT->m_pObject->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, pT->m_dwMsgMapID);
	if(uMsg == WM_NCDESTROY)
	{
		pT->m_hWnd = NULL;
		return 0;
	}
	if(bRet)
		return lRes;
	return pT->DefWindowProc(uMsg, wParam, lParam);
}

ATOM CContainedWindow::RegisterWndSuperclass()
{
	ATOM atom = 0;
	LPTSTR szBuff = (LPTSTR)_alloca((lstrlen(m_lpszClassName) + 14) * sizeof(TCHAR));

	WNDCLASSEX wc;
	wc.cbSize = sizeof(WNDCLASSEX);

	if(::GetClassInfoEx(NULL, m_lpszClassName, &wc))
	{
		m_pfnSuperWindowProc = wc.lpfnWndProc;

		wsprintf(szBuff, _T("ATL:%s"), m_lpszClassName);

		WNDCLASSEX wc1;
		wc1.cbSize = sizeof(WNDCLASSEX);
		atom = (ATOM)::GetClassInfoEx(_Module.GetModuleInstance(), szBuff, &wc1);

		if(atom == 0)   // register class
		{
			wc.lpszClassName = szBuff;
			wc.lpfnWndProc = StartWindowProc;
			wc.hInstance = _Module.GetModuleInstance();
			wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes

			atom = ::RegisterClassEx(&wc);
		}
	}

	return atom;
}

HWND CContainedWindow::Create(HWND hWndParent, RECT& rcPos,
	LPCTSTR szWindowName, DWORD dwStyle, DWORD dwExStyle, UINT nID)
{
	_ASSERTE(m_hWnd == NULL);

	ATOM atom = RegisterWndSuperclass();
	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
   {
#ifdef _WIN64
      nID = InterlockedIncrement( &g_nNextWindowID );
      nID |= 0x80000000;  // Make sure the ID isn't zero
#else
      nID = (UINT)this;
#endif
   }

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
							dwStyle,
							rcPos.left, rcPos.top,
							rcPos.right - rcPos.left,
							rcPos.bottom - rcPos.top,
							hWndParent, (HMENU)(DWORD_PTR)nID,
							_Module.GetModuleInstance(), this);

	_ASSERTE(m_hWnd == hWnd);
	return hWnd;
}

BOOL CContainedWindow::SubclassWindow(HWND hWnd)
{
	_ASSERTE(m_hWnd == NULL);
	_ASSERTE(::IsWindow(hWnd));

	m_thunk.Init(WindowProc, this);
	WNDPROC pProc = (WNDPROC)m_thunk.thunk.pThunk;
   WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

HWND CContainedWindow::UnsubclassWindow()
{
	_ASSERTE(m_hWnd != NULL);

   if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
		return NULL;
	m_pfnSuperWindowProc = ::DefWindowProc;

	HWND hWnd = m_hWnd;
	m_hWnd = NULL;

	return hWnd;
}

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

///////////////////////////////////////////////////////////////////////////////
//All Global stuff goes below this line
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlimpl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
	#error atlimpl.cpp requires atlbase.h to be included first
#endif

extern "C" const DECLSPEC_SELECTANY IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
#ifndef _ATL_DLL_IMPL
extern "C" const DECLSPEC_SELECTANY CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
#endif

#include <atlconv.cpp>
#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

// used in thread pooling
DECLSPEC_SELECTANY UINT CComApartment::ATL_CREATE_OBJECT = 0;

#if _MSC_VER < 1200
#pragma comment(linker, "/merge:.CRT=.data")
#endif

#ifdef __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
// AtlReportError

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
}

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID,
		lpszHelpFile, iid, hRes, hInst);
}

#ifndef OLE2ANSI
HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	DWORD dwHelpID, LPCSTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	USES_CONVERSION_EX;
	_ASSERTE(lpszDesc != NULL);
	if (lpszDesc == NULL) // lpszDesc should not be NULL
	{
		return E_POINTER;
	}

	LPCOLESTR lpcoleDesc = A2COLE_EX(lpszDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if (lpcoleDesc == NULL)
	{
		return E_OUTOFMEMORY;
	}
	
	LPCOLESTR lpcoleHelpFile;
	if (lpszHelpFile != NULL) // lpszHelpFile could be NULL
	{
		lpcoleHelpFile = A2CW_EX(lpszHelpFile, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (lpcoleHelpFile == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		lpcoleHelpFile = NULL;
	}
	return AtlSetErrorInfo(clsid, lpcoleDesc, dwHelpID, lpcoleHelpFile,
		iid, hRes, NULL);
}

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	_ASSERTE(lpszDesc != NULL);
	USES_CONVERSION_EX;
	if (lpszDesc == NULL)
	{
		return E_POINTER;
	}

	LPCOLESTR lpcoleDesc = A2COLE_EX(lpszDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if (lpcoleDesc == NULL)
	{
		return E_OUTOFMEMORY;
	}
	return AtlSetErrorInfo(clsid, lpcoleDesc, 0, NULL, iid, hRes, NULL);
}
#endif

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL);
}

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL);
}

#endif //__ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

CComBSTR& CComBSTR::operator=(const CComBSTR& src)
{
	if (m_str != src.m_str)
	{
		if (m_str)
			::SysFreeString(m_str);
		m_str = src.Copy();
	}
	return *this;
}

CComBSTR& CComBSTR::operator=(LPCOLESTR pSrc)
{
	::SysFreeString(m_str);
	m_str = ::SysAllocString(pSrc);
	return *this;
}

HRESULT CComBSTR::Append(LPCOLESTR lpsz, int nLen)
{
	if(lpsz == NULL)
	{
		if(nLen != 0)
			return E_INVALIDARG;
		else
			return S_OK;
	}

	int n1 = Length();
	BSTR b = SysAllocStringLen(NULL, n1+nLen);
	if (b == NULL)
	{
		return E_OUTOFMEMORY;
	}
	memcpy(b, m_str, n1*sizeof(OLECHAR));
	memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
	b[n1+nLen] = NULL;
	SysFreeString(m_str);
	m_str = b;
	return S_OK;
}

#ifndef OLE2ANSI
HRESULT CComBSTR::Append(LPCSTR lpsz)
{
	USES_CONVERSION_EX;
	if (lpsz == NULL)
	{
		return S_OK;
	}

	LPCOLESTR lpo = A2COLE_EX(lpsz, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if (lpo == NULL)
	{
		return E_OUTOFMEMORY;	
	}
	return Append(lpo, (int) ocslen(lpo));
}

CComBSTR::CComBSTR(LPCSTR pSrc)
{
	m_str = A2WBSTR(pSrc);
}

CComBSTR::CComBSTR(int nSize, LPCSTR sz)
{
	m_str = A2WBSTR(sz, nSize);
}

CComBSTR& CComBSTR::operator=(LPCSTR pSrc)
{
	::SysFreeString(m_str);
	m_str = A2WBSTR(pSrc);
	return *this;
}
#endif

HRESULT CComBSTR::ReadFromStream(IStream* pStream)
{
	_ASSERTE(pStream != NULL);
	_ASSERTE(m_str == NULL); // should be empty
	ULONG cb;
	ULONG cbStrLen;
	HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), &cb);
	if (FAILED(hr))
		return hr;
	if (cbStrLen != 0)
	{
		//subtract size for terminating NULL which we wrote out
		//since SysAllocStringByteLen overallocates for the NULL
		m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
		if (m_str == NULL)
			hr = E_OUTOFMEMORY;
		else
			hr = pStream->Read((void*) m_str, cbStrLen, &cb);
	}
	return hr;
}

HRESULT CComBSTR::WriteToStream(IStream* pStream)
{
	_ASSERTE(pStream != NULL);
	ULONG cb;
	ULONG cbStrLen = (ULONG)(m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0);
	HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
	if (FAILED(hr))
		return hr;
	return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CComVariant

CComVariant& CComVariant::operator=(BSTR bstrSrc)
{
	InternalClear();
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(bstrSrc);
	if (bstrVal == NULL && bstrSrc != NULL)
	{
		vt = VT_ERROR;
		scode = E_OUTOFMEMORY;
	}
	return *this;
}

CComVariant& CComVariant::operator=(LPCOLESTR lpszSrc)
{
	InternalClear();
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(lpszSrc);

	if (bstrVal == NULL && lpszSrc != NULL)
	{
		vt = VT_ERROR;
		scode = E_OUTOFMEMORY;
	}
	return *this;
}

#ifndef OLE2ANSI
CComVariant& CComVariant::operator=(LPCSTR lpszSrc)
{
	USES_CONVERSION_EX;
	InternalClear();
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(A2COLE_EX(lpszSrc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));

	if (bstrVal == NULL && lpszSrc != NULL)
	{
		vt = VT_ERROR;
		scode = E_OUTOFMEMORY;
	}
	return *this;
}
#endif

#if _MSC_VER>1020
CComVariant& CComVariant::operator=(bool bSrc)
{
	if (vt != VT_BOOL)
	{
		InternalClear();
		vt = VT_BOOL;
	}
#pragma warning(disable: 4310) // cast truncates constant value
	boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return *this;
}
#endif

CComVariant& CComVariant::operator=(int nSrc)
{
	if (vt != VT_I4)
	{
		InternalClear();
		vt = VT_I4;
	}
	lVal = nSrc;

	return *this;
}

CComVariant& CComVariant::operator=(BYTE nSrc)
{
	if (vt != VT_UI1)
	{
		InternalClear();
		vt = VT_UI1;
	}
	bVal = nSrc;
	return *this;
}

CComVariant& CComVariant::operator=(short nSrc)
{
	if (vt != VT_I2)
	{
		InternalClear();
		vt = VT_I2;
	}
	iVal = nSrc;
	return *this;
}

CComVariant& CComVariant::operator=(long nSrc)
{
	if (vt != VT_I4)
	{
		InternalClear();
		vt = VT_I4;
	}
	lVal = nSrc;
	return *this;
}

CComVariant& CComVariant::operator=(float fltSrc)
{
	if (vt != VT_R4)
	{
		InternalClear();
		vt = VT_R4;
	}
	fltVal = fltSrc;
	return *this;
}

CComVariant& CComVariant::operator=(double dblSrc)
{
	if (vt != VT_R8)
	{
		InternalClear();
		vt = VT_R8;
	}
	dblVal = dblSrc;
	return *this;
}

CComVariant& CComVariant::operator=(CY cySrc)
{
	if (vt != VT_CY)
	{
		InternalClear();
		vt = VT_CY;
	}
	cyVal.Hi = cySrc.Hi;
	cyVal.Lo = cySrc.Lo;
	return *this;
}

CComVariant& CComVariant::operator=(IDispatch* pSrc)
{
	InternalClear();
	vt = VT_DISPATCH;
	pdispVal = pSrc;
	// Need to AddRef as VariantClear will Release
	if (pdispVal != NULL)
		pdispVal->AddRef();
	return *this;
}

CComVariant& CComVariant::operator=(IUnknown* pSrc)
{
	InternalClear();
	vt = VT_UNKNOWN;
	punkVal = pSrc;

	// Need to AddRef as VariantClear will Release
	if (punkVal != NULL)
		punkVal->AddRef();
	return *this;
}

#if _MSC_VER>1020
bool CComVariant::operator==(const VARIANT& varSrc)
{
	if (this == &varSrc)
		return true;

	// Variants not equal if types don't match
	if (vt != varSrc.vt)
		return false;

	// Check type specific values
	switch (vt)
	{
		case VT_EMPTY:
		case VT_NULL:
			return true;

		case VT_BOOL:
			return boolVal == varSrc.boolVal;

		case VT_UI1:
			return bVal == varSrc.bVal;

		case VT_I2:
			return iVal == varSrc.iVal;

		case VT_I4:
			return lVal == varSrc.lVal;

		case VT_R4:
			return fltVal == varSrc.fltVal;

		case VT_R8:
			return dblVal == varSrc.dblVal;

		case VT_BSTR:
			return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
					(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

		case VT_ERROR:
			return scode == varSrc.scode;

		case VT_DISPATCH:
			return pdispVal == varSrc.pdispVal;

		case VT_UNKNOWN:
			return punkVal == varSrc.punkVal;

		default:
			_ASSERTE(false);
			// fall through
	}

	return false;
}
#else
BOOL CComVariant::operator==(const VARIANT& varSrc)
{
	if (this == &varSrc)
		return TRUE;

	// Variants not equal if types don't match
	if (vt != varSrc.vt)
		return FALSE;

	// Check type specific values
	switch (vt)
	{
		case VT_EMPTY:
		case VT_NULL:
			return TRUE;

		case VT_BOOL:
			return boolVal == varSrc.boolVal;

		case VT_UI1:
			return bVal == varSrc.bVal;

		case VT_I2:
			return iVal == varSrc.iVal;

		case VT_I4:
			return lVal == varSrc.lVal;

		case VT_R4:
			return fltVal == varSrc.fltVal;

		case VT_R8:
			return dblVal == varSrc.dblVal;

		case VT_BSTR:
			return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
					(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

		case VT_ERROR:
			return scode == varSrc.scode;

		case VT_DISPATCH:
			return pdispVal == varSrc.pdispVal;

		case VT_UNKNOWN:
			return punkVal == varSrc.punkVal;

		default:
			_ASSERTE(FALSE);
			// fall through
	}

	return FALSE;
}
#endif

HRESULT CComVariant::Attach(VARIANT* pSrc)
{
	// Clear out the variant
	HRESULT hr = Clear();
	if (!FAILED(hr))
	{
		// Copy the contents and give control to CComVariant
		memcpy(this, pSrc, sizeof(VARIANT));
		VariantInit(pSrc);
		hr = S_OK;
	}
	return hr;
}

HRESULT CComVariant::Detach(VARIANT* pDest)
{
	// Clear out the variant
	HRESULT hr = ::VariantClear(pDest);
	if (!FAILED(hr))
	{
		// Copy the contents and remove control from CComVariant
		memcpy(pDest, this, sizeof(VARIANT));
		vt = VT_EMPTY;
		hr = S_OK;
	}
	return hr;
}

HRESULT CComVariant::ChangeType(VARTYPE vtNew, const VARIANT* pSrc)
{
	VARIANT* pVar = const_cast<VARIANT*>(pSrc);
	// Convert in place if pSrc is NULL
	if (pVar == NULL)
		pVar = this;
	// Do nothing if doing in place convert and vts not different
	return ::VariantChangeType(this, pVar, 0, vtNew);
}

HRESULT CComVariant::InternalClear()
{
	HRESULT hr = Clear();
	_ASSERTE(SUCCEEDED(hr));
	if (FAILED(hr))
	{
		vt = VT_ERROR;
		scode = hr;
	}
	return hr;
}

void CComVariant::InternalCopy(const VARIANT* pSrc)
{
	HRESULT hr = Copy(pSrc);
	if (FAILED(hr))
	{
		vt = VT_ERROR;
		scode = hr;
	}
}


HRESULT CComVariant::WriteToStream(IStream* pStream)
{
	HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	int cbWrite = 0;
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			CComPtr<IPersistStream> spStream;
			if (punkVal != NULL)
			{
				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
				if (FAILED(hr))
					return hr;
			}
			if (spStream != NULL)
				return OleSaveToStream(spStream, pStream);
			else
				return WriteClassStm(pStream, CLSID_NULL);
		}
	case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	if (cbWrite != 0)
		return pStream->Write((void*) &bVal, cbWrite, NULL);

	CComBSTR bstrWrite;
	CComVariant varBSTR;
	if (vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
		bstrWrite = bstrVal;

	return bstrWrite.WriteToStream(pStream);
}

HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
	_ASSERTE(pStream != NULL);
	HRESULT hr;
	hr = VariantClear(this);
	if (FAILED(hr))
		return hr;
	VARTYPE vtRead;
	hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			punkVal = NULL;
			hr = OleLoadFromStream(pStream,
				(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
				(void**)&punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	default:
		break;
	}
	if (cbRead != 0)
		return pStream->Read((void*) &bVal, cbRead, NULL);
	CComBSTR bstrRead;

	hr = bstrRead.ReadFromStream(pStream);
	if (FAILED(hr))
		return hr;
	vt = VT_BSTR;
	bstrVal = bstrRead.Detach();
	if (vtRead != VT_BSTR)
		hr = ChangeType(vtRead);
	return hr;
}

#ifdef __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
// CComTypeInfoHolder

void CComTypeInfoHolder::AddRef()
{
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	m_dwRef++;
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void CComTypeInfoHolder::Release()
{
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (--m_dwRef == 0)
	{
		if (m_pInfo != NULL)
			m_pInfo->Release();
		m_pInfo = NULL;
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT CComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
	//If this assert occurs then most likely didn't initialize properly
	_ASSERTE(m_plibid != NULL && m_pguid != NULL);
	_ASSERTE(ppInfo != NULL);
	*ppInfo = NULL;

	HRESULT hRes = E_FAIL;
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			ITypeInfo* pTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
			if (SUCCEEDED(hRes))
				m_pInfo = pTypeInfo;
			pTypeLib->Release();
		}
	}
	*ppInfo = m_pInfo;
	if (m_pInfo != NULL)
	{
		m_pInfo->AddRef();
		hRes = S_OK;
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
	return hRes;
}

HRESULT CComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
	ITypeInfo** pptinfo)
{
	HRESULT hRes = E_POINTER;
	if (pptinfo != NULL)
		hRes = GetTI(lcid, pptinfo);
	return hRes;
}

HRESULT CComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
	UINT cNames, LCID lcid, DISPID* rgdispid)
{
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
		pInfo->Release();
	}
	return hRes;
}

HRESULT CComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
	LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
	EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	SetErrorInfo(0, NULL);
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		pInfo->Release();
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// QI implementation

#ifdef _ATL_DEBUG_QI
HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
	USES_CONVERSION_EX;
	CRegKey key;
	TCHAR szName[100];
	DWORD dwType,dw = sizeof(szName);

	LPOLESTR pszGUID = NULL;
	StringFromCLSID(iid, &pszGUID);
	OutputDebugString(pszClassName);
	OutputDebugString(_T(" - "));

	// Attempt to find it in the interfaces section
	key.Open(HKEY_CLASSES_ROOT, _T("Interface"));
	if (key.Open(key, OLE2T_EX(pszGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(szName);
		goto cleanup;
	}
	// Attempt to find it in the clsid section
	key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
	if (key.Open(key, OLE2T_EX(pszGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(_T("(CLSID\?\?\?) "));
		OutputDebugString(szName);
		goto cleanup;
	}
	OutputDebugString(OLE2T_EX(pszGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
cleanup:
	if (hr != S_OK)
		OutputDebugString(_T(" - failed"));
	OutputDebugString(_T("\n"));
	CoTaskMemFree(pszGUID);
	return hr;
}
#endif

HRESULT WINAPI CComObjectRootBase::_Break(void* /* pv */, REFIID iid, void** /* ppvObject */, DWORD_PTR /* dw */)
{
	iid;
	_ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK);
	DebugBreak();
	return S_FALSE;
}

HRESULT WINAPI CComObjectRootBase::_NoInterface(void* /* pv */, REFIID /* iid */, void** /* ppvObject */, DWORD_PTR /* dw */)
{
	return E_NOINTERFACE;
}

HRESULT WINAPI CComObjectRootBase::_Creator(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
{
	_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
	return pcd->pFunc(pv, iid, ppvObject);
}

HRESULT WINAPI CComObjectRootBase::_Delegate(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
{
	HRESULT hRes = E_NOINTERFACE;
	IUnknown* p = *(IUnknown**)((ULONG_PTR)pv + dw);
	if (p != NULL)
		hRes = p->QueryInterface(iid, ppvObject);
	return hRes;
}

HRESULT WINAPI CComObjectRootBase::_Chain(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
{
	_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
	void* p = (void*)((ULONG_PTR)pv + pcd->dwOffset);
	return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
}

HRESULT WINAPI CComObjectRootBase::_Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
{
	HRESULT hRes = E_NOINTERFACE;
	_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
	IUnknown** pp = (IUnknown**)((ULONG_PTR)pv + pcd->dwOffsetVar);
	if (*pp == NULL)
		hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
	if (*pp != NULL)
		hRes = (*pp)->QueryInterface(iid, ppvObject);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// CComClassFactory

STDMETHODIMP CComClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
	REFIID riid, void** ppvObj)
{
	_ASSERTE(m_pfnCreateInstance != NULL);
	HRESULT hRes = E_POINTER;
	if (ppvObj != NULL)
	{
		*ppvObj = NULL;
		// can't ask for anything other than IUnknown when aggregating
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			hRes = CLASS_E_NOAGGREGATION;
		else
			hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	return hRes;
}

STDMETHODIMP CComClassFactory::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

STDMETHODIMP CComClassFactory2Base::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

DWORD CComDynamicUnkArray::Add(IUnknown* pUnk)
{
   ULONG iIndex;
	IUnknown** pp = NULL;
	if (m_nSize == 0) // no connections
	{
		m_pUnk = pUnk;
		m_nSize = 1;
		return 1;
	}
	else if (m_nSize == 1)
	{
		//create array
		pp = (IUnknown**)malloc(sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		if (pp == NULL)
			return 0;
		memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		*pp = m_pUnk;
		m_ppUnk = pp;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
            iIndex = ULONG((pp-begin()));
			return iIndex+1;
		}
	}
	int nAlloc = m_nSize*2;
	pp = (IUnknown**)realloc(m_ppUnk, sizeof(IUnknown*)*nAlloc);
	if (pp == NULL)
		return 0;
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize);
	m_ppUnk[m_nSize] = pUnk;
   iIndex = m_nSize;
	m_nSize = nAlloc;
	return iIndex+1;
}

BOOL CComDynamicUnkArray::Remove(DWORD dwCookie)
{
   ULONG iIndex;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
   iIndex = dwCookie-1;
   if (iIndex >= (ULONG)m_nSize)
   {
      return FALSE;
   }
	if (m_nSize == 1)
	{
		m_nSize = 0;
		return TRUE;
	}
   begin()[iIndex] = NULL;
   return TRUE;
}

#endif //!_ATL_NO_CONNECTION_POINTS

#endif //__ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
// Object Registry Support

static HRESULT WINAPI AtlRegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID);
	if (lRes == ERROR_SUCCESS)
	{
		keyProgID.SetValue(lpszUserDesc);
		keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
		return S_OK;
	}
	return HRESULT_FROM_WIN32(lRes);
}

void CComModule::AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
{
	if(pObject == NULL)
		_AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);

	::EnterCriticalSection(&m_csWindowCreate);
	pData->m_pThis = pObject;
	pData->m_dwThreadID = ::GetCurrentThreadId();
	pData->m_pNext = m_pCreateWndList;
	m_pCreateWndList = pData;
	::LeaveCriticalSection(&m_csWindowCreate);
}

void* CComModule::ExtractCreateWndData()
{
	void * retVal = NULL;
	::EnterCriticalSection(&m_csWindowCreate);
	__try
	{
		_AtlCreateWndData* pEntry = m_pCreateWndList;
		DWORD dwThreadID = 0;
		_AtlCreateWndData* pPrev = NULL;
		if (pEntry == NULL)
		{
			goto leaveFunction;
		}

		dwThreadID = ::GetCurrentThreadId();
		while(pEntry != NULL)
		{
			if(pEntry->m_dwThreadID == dwThreadID)
			{
				if(pPrev == NULL)
					m_pCreateWndList = pEntry->m_pNext;
				else
					pPrev->m_pNext = pEntry->m_pNext;
				retVal = pEntry->m_pThis;
				goto leaveFunction;
			}
			pPrev = pEntry;
			pEntry = pEntry->m_pNext;
		}
leaveFunction:
		;
	}
	__finally
	{
		::LeaveCriticalSection(&m_csWindowCreate);
	}

	return retVal;
}

#ifdef _ATL_STATIC_REGISTRY
// Statically linking to Registry Ponent
HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION_EX;
	CRegObject ro;
	TCHAR szModule[_MAX_PATH+1] = {0};
	if (!GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH))
        return HRESULT_FROM_WIN32(GetLastError());
	LPOLESTR pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	ro.AddReplacement(OLESTR("Module"), pszModule);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
			ro.ResourceUnregister(pszModule, nResID, szType);
}

HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION_EX;
	CRegObject ro;
	TCHAR szModule[_MAX_PATH+1] = {0};
	if (!GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH))
        return HRESULT_FROM_WIN32(GetLastError());
    LPOLESTR pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	ro.AddReplacement(OLESTR("Module"), pszModule);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	LPCOLESTR pszRes = T2COLE_EX(lpszRes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
			ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif // _ATL_STATIC_REGISTRY

HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
	if (bRegister)
	{
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
			dwFlags);
	}
	else
		return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION_EX;
	HRESULT hRes = S_OK;
	TCHAR szDesc[256];
	LoadString(m_hInst, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH+1] = {0};
	if (!GetModuleFileName(m_hInst, szModule, _MAX_PATH))
        return HRESULT_FROM_WIN32(GetLastError());

	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T_EX(lpOleStr, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	hRes = AtlRegisterProgID(lpsz, lpszProgID, szDesc);
	if (hRes == S_OK)
		hRes = AtlRegisterProgID(lpsz, lpszVerIndProgID, szDesc);
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpsz);
			if (lRes == ERROR_SUCCESS)
			{
				key.SetValue(szDesc);
				key.SetKeyValue(szProgID, lpszProgID);
				key.SetKeyValue(szVIProgID, lpszVerIndProgID);

				if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
					key.SetKeyValue(szLS32, szModule);
				else
				{
					key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
					LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
						(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
					if (lpszModel != NULL)
						key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = HRESULT_FROM_WIN32(lRes);
	return hRes;
}

HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION_EX;
	CRegKey key;

	key.Attach(HKEY_CLASSES_ROOT);
	if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
		key.RecurseDeleteKey(lpszProgID);
	if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
		key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T_EX(lpOleStr, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if (key.Open(key, _T("CLSID")) == ERROR_SUCCESS)
		key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	_ASSERTE(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	_ASSERTE(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		_ASSERTE(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
	_ASSERTE(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

HRESULT CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

#ifdef __ATLCOM_H__
#ifndef _ATL_NO_SECURITY

CSecurityDescriptor::CSecurityDescriptor()
{
	m_pSD = NULL;
	m_pOwner = NULL;
	m_pGroup = NULL;
	m_pDACL = NULL;
	m_pSACL= NULL;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
	if (m_pSD)
		delete m_pSD;
	if (m_pOwner)
		free(m_pOwner);
	if (m_pGroup)
		free(m_pGroup);
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSACL)
		free(m_pSACL);
}

HRESULT CSecurityDescriptor::Initialize()
{
	if (m_pSD)
	{
		delete m_pSD;
		m_pSD = NULL;
	}
	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}
	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}

	ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
	if (m_pSD == NULL)
		return E_OUTOFMEMORY;

	if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		delete m_pSD;
		m_pSD = NULL;
		_ASSERTE(FALSE);
		return hr;
	}
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
	PSID pUserSid = NULL;
	PSID pGroupSid = NULL;
	
	HRESULT hr = Initialize();
	if (FAILED(hr))
		return hr;
	hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (SUCCEEDED(hr))
	{
		hr = SetOwner(pUserSid, bDefaulted);
		if (SUCCEEDED(hr))
			hr = SetGroup(pGroupSid, bDefaulted);
	}
	if (pUserSid != NULL)
		free(pUserSid);
	if (pGroupSid != NULL)
		free(pGroupSid);

	if (FAILED(hr))
	{
		delete m_pSD;
		m_pSD = NULL;
		
		free(m_pOwner);
		m_pOwner = NULL;
		
		_ASSERTE(FALSE);		
	}
	return hr;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
	PSID pUserSid = NULL;
	PSID pGroupSid = NULL;
	
	HRESULT hr = Initialize();
	if (FAILED(hr))
		return hr;
	
	hr = GetThreadSids(&pUserSid, &pGroupSid);
	if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
		hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (SUCCEEDED(hr))
	{
		hr = SetOwner(pUserSid, bDefaulted);
		if (SUCCEEDED(hr))
			hr = SetGroup(pGroupSid, bDefaulted);
	}
	if (pUserSid != NULL)
		free(pUserSid);
	if (pGroupSid != NULL)
		free(pGroupSid);

	if (FAILED(hr))
	{
		delete m_pSD;
		m_pSD = NULL;
		
		free(m_pOwner);
		m_pOwner = NULL;
		
		_ASSERTE(FALSE);		
	}
	return hr;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no owner
	if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}

	// If they asked for no owner don't do the copy
	if (pOwnerSid == NULL)
		return S_OK;

	if (!IsValidSid(pOwnerSid))
	{
		return E_INVALIDARG;
	}
	
	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pOwnerSid);

	m_pOwner = (PSID) malloc(dwSize);
	if (m_pOwner == NULL)
		return E_OUTOFMEMORY;
	if (!CopySid(dwSize, m_pOwner, pOwnerSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pOwner));

	if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no Group
	if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}

	// If they asked for no Group don't do the copy
	if (pGroupSid == NULL)
		return S_OK;

	if (!IsValidSid(pGroupSid))
	{
		return E_INVALIDARG;
	}
	
	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pGroupSid);

	m_pGroup = (PSID) malloc(dwSize);
	if (m_pGroup == NULL)
		return E_OUTOFMEMORY;
	if (!CopySid(dwSize, m_pGroup, pGroupSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pGroup));

	if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
	{
		if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
		{
			hr = AtlHresultFromLastError();
		}
	}
	return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
	{
		if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
		{
			hr = AtlHresultFromLastError();
		}
	}
	return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
	if (SUCCEEDED(hr))
	{
		if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
		{
			hr = AtlHresultFromLastError();
		}
	}
	return hr;
}

HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	if (!bRes)
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	CloseHandle(hToken);
	return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
	if (!bRes)
	{
		// Couldn't open thread token
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	CloseHandle(hToken);
	return hr;
}

HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
	DWORD dwSize = 0;
	HRESULT hr = E_FAIL;
	DWORD dwErr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		dwErr = GetLastError();
		if (dwErr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = AtlHresultFromWin32(dwErr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) malloc(dwSize);
		if (ptkUser == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid;
		pSid = (PSID) malloc(dwSize);
		if (pSid == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			free(pSid);
			_ASSERTE(FALSE);
            free(pSid);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));
		*ppUserSid = pSid;
		free(ptkUser);
		ptkUser = NULL;
	}
	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		dwErr = GetLastError();
		if (dwErr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = AtlHresultFromWin32(dwErr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
		if (ptkGroup == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid;
		pSid = (PSID) malloc(dwSize);
		if (pSid == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			free(pSid);
			_ASSERTE(FALSE);
            free(pSid);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));

		*ppGroupSid = pSid;
		free(ptkGroup);
		ptkGroup = NULL;
	}

	return S_OK;

failed:
	if (ptkUser)
		free(ptkUser);
	if (ptkGroup)
		free (ptkGroup);
	return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
	HANDLE tkHandle;
	
	if (ppSid == NULL)
	{
		return E_POINTER;
	}

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser;
		DWORD tkSize;
		DWORD sidLength;

		// Call to get size information for alloc
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		DWORD dwErr = GetLastError();
		if (dwErr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			HRESULT hr = AtlHresultFromWin32(dwErr);
			_ASSERTE(FALSE);			
			CloseHandle(tkHandle);
			return hr;
		}		
		tkUser = (TOKEN_USER *) malloc(tkSize);
		if (tkUser == NULL)
		{
			CloseHandle(tkHandle);
			return E_OUTOFMEMORY;
		}

		// Now make the real call
		if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
		{
			sidLength = GetLengthSid(tkUser->User.Sid);
			*ppSid = (PSID) malloc(sidLength);
			if (*ppSid == NULL)
			{
				CloseHandle(tkHandle);
				free(tkUser);				
				return E_OUTOFMEMORY;
			}
			if (!CopySid(sidLength, *ppSid, tkUser->User.Sid))
			{
				HRESULT hr = AtlHresultFromWin32(dwErr);
				CloseHandle(tkHandle);
				free(tkUser);
				free(*ppSid);
				*ppSid = NULL;
				return hr;
			}

			CloseHandle(tkHandle);
			free(tkUser);
			return S_OK;
		}
		else
		{
			HRESULT hr = AtlHresultFromLastError();		
			CloseHandle(tkHandle);
			free(tkUser);
			return hr;
		}
	}
	return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;
	
	if (ppSid == NULL)
	{
		return E_POINTER;
	}
	if (pszPrincipal == NULL)
	{
		return E_INVALIDARG;
	}

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

	DWORD dwErr = GetLastError();
	if (dwErr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(dwErr);

	ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
	if (pszRefDomain == NULL)
		return E_OUTOFMEMORY;

	*ppSid = (PSID) malloc(dwSidSize);
	if (*ppSid != NULL)
	{
		if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
		{
			HRESULT hr = AtlHresultFromLastError();		
			free(*ppSid);
			*ppSid = NULL;
			delete[] pszRefDomain;
			return hr;
		}
		delete[] pszRefDomain;
		return S_OK;
	}
	delete[] pszRefDomain;
	return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	PACL    m_pDACL = NULL;
	PSID    pUserSid;
	PSID    pGroupSid;
	
	if (pSelfRelativeSD == NULL ||!IsValidSecurityDescriptor(pSelfRelativeSD))
		return E_INVALIDARG;

	HRESULT hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
		goto failed;

	if (bDACLPresent)
	{
		if (pDACL)
		{
			// allocate new DACL.
			m_pDACL = (PACL) malloc(pDACL->AclSize);
			if (m_pDACL == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto failedMemory;
			}

			// initialize the DACL
			if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			hr = CopyACL(m_pDACL, pDACL);
			if (FAILED(hr))
				goto failedMemory;

			if (!IsValidAcl(m_pDACL))
				goto failed;
		}

		// set the DACL
		if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
			goto failed;
	}

	// get the existing SACL.
	if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
		goto failed;

	if (bSACLPresent)
	{
		if (pSACL)
		{
			// allocate new SACL.
			m_pSACL = (PACL) malloc(pSACL->AclSize);
			if (m_pSACL == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto failedMemory;
			}

			// initialize the SACL
			if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			hr = CopyACL(m_pSACL, pSACL);
			if (FAILED(hr))
				goto failedMemory;

			if (!IsValidAcl(m_pSACL))
				goto failed;
		}

		// set the SACL
		if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
			goto failed;
	}

	if (!GetSecurityDescriptorOwner(pSelfRelativeSD, &pUserSid, &bDefaulted))
		goto failed;

	if (FAILED(SetOwner(pUserSid, bDefaulted)))
		goto failed;

	if (!GetSecurityDescriptorGroup(pSelfRelativeSD, &pGroupSid, &bDefaulted))
		goto failed;

	if (FAILED(SetGroup(pGroupSid, bDefaulted)))
		goto failed;

	if (!IsValidSecurityDescriptor(m_pSD))
	{
		hr = E_FAIL;
		goto failedMemory;
	}

	return S_OK;

failed:
	hr = AtlHresultFromLastError();

failedMemory:
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}
	if (m_pSD)
	{
		free(m_pSD);
		m_pSD = NULL;
	}
	return hr;
}

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
	HRESULT hr;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

	DWORD dwErr = GetLastError();
	if (dwErr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(dwErr);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);
	if (pSD == NULL)
		return E_OUTOFMEMORY;

	if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		free(pSD);
		return hr;
	}

	hr = Attach(pSD);
	free(pSD);
	return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pDest == NULL)
		return E_POINTER;
	if (pSrc == NULL)
		return S_OK;
	
	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return HRESULT_FROM_WIN32(GetLastError());
	
	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return HRESULT_FROM_WIN32(GetLastError());

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	PSID principalSID;
	PACL oldACL, newACL = NULL;
	
	if (ppAcl == NULL)
		return E_POINTER;
		
	if (pszPrincipal == NULL)
		return E_INVALIDARG;

	oldACL = *ppAcl;

	HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(hr))
		return hr;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL && 
		!GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
	{
		free(principalSID);		
		return AtlHresultFromLastError();
	}

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) +	// size of original ACL
		sizeof(ACCESS_DENIED_ACE) + 					// size of ACE
		GetLengthSid(principalSID) - 					// Actual size of SID
		sizeof(DWORD);									// subtract size of placeholder variable 
														// for SID in ACCESS_*_ACE structure

	newACL = (PACL) malloc(aclSize);
	if (newACL == NULL)
	{
		free(principalSID);	
		return E_OUTOFMEMORY;
	}

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		hr = AtlHresultFromLastError();
		free(newACL);
		free(principalSID);
		return hr;
	}

	if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		hr = AtlHresultFromLastError();
		free(newACL);
		free(principalSID);
		return hr;
	}

	hr = CopyACL(newACL, oldACL);
	if (FAILED(hr))
	{
		free(newACL);
		free(principalSID);
		return hr;
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	PSID principalSID;
	PACL oldACL, newACL = NULL;
	
	if (ppAcl == NULL)
		return E_POINTER;
		
	if (pszPrincipal == NULL)
		return E_INVALIDARG;

	oldACL = *ppAcl;

	HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(hr))
		return hr;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL && 
		!GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return AtlHresultFromLastError();

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + // size of original ACL
		sizeof(ACCESS_ALLOWED_ACE) + 					// size of ACE
		GetLengthSid(principalSID) - 					// Actual size of SID
		sizeof(DWORD);									// subtract size of placeholder variable 
														// for SID in ACCESS_*_ACE structure

	newACL = (PACL) malloc(aclSize);
	if (newACL == NULL)
	{
		free(principalSID);	
		return E_OUTOFMEMORY;
	}

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		hr = AtlHresultFromLastError();
		free(newACL);
		free(principalSID);
		return hr;
	}

	if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		hr = AtlHresultFromLastError();
		free(newACL);
		free(principalSID);
		return hr;
	}

	hr = CopyACL(newACL, oldACL);
	if (FAILED(hr))
	{
		free(newACL);
		free(principalSID);
		return hr;
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}

HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
	if (pAcl == NULL || pszPrincipal == NULL)
		return E_INVALIDARG;

	PSID principalSID;
	HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(hr))
		return hr;

	ACL_SIZE_INFORMATION aclSizeInfo;
	if (!GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
	{
		hr = AtlHresultFromLastError();
		aclSizeInfo.AceCount = 0;
	}

		
	for (ULONG i = aclSizeInfo.AceCount; i > 0; i--)
	{
		ULONG uIndex = i - 1;
		LPVOID ace;	
		if (!GetAce(pAcl, uIndex, &ace))
		{
			hr = AtlHresultFromLastError();
			break;
		}

		ACE_HEADER *aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			ACCESS_ALLOWED_ACE *accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;
			if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, uIndex);
			}
		} 
		else if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			ACCESS_DENIED_ACE *accessDeniedAce = (ACCESS_DENIED_ACE *) ace;
			if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, uIndex);
			}
		} 
		else if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			SYSTEM_AUDIT_ACE *systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;
			if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, uIndex);
			}
		}
	}
	free(principalSID);
	return hr;
}

HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
	HRESULT hr;
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	DWORD  cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID   luid;
	HANDLE hTokenUsed;

	// if no token specified open process token
	if (hToken == 0)
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			return hr;
		}
	}
	else
		hTokenUsed = hToken;

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	else
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

	if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}
	return S_OK;
}

#endif //_ATL_NO_SECURITY
#endif //__ATLCOM_H__

#ifdef _DEBUG

void _cdecl AtlTrace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	_ASSERTE(nBuf != -1 && nBuf < sizeof(szBuffer));
	
	if(nBuf == -1 || nBuf >= sizeof(szBuffer))
	{
		TCHAR szContinued[] = _T("...");
		
		lstrcpy(szBuffer + (sizeof(szBuffer) - sizeof(szContinued)), szContinued);
	}
	
	OutputDebugString(szBuffer);
	va_end(args);
}
#endif

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

///////////////////////////////////////////////////////////////////////////////
//All Global stuff goes below this line
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Minimize CRT
// Specify DllMain as EntryPoint
// Turn off exception handling
// Define _ATL_MIN_CRT

#ifdef _ATL_MIN_CRT
/////////////////////////////////////////////////////////////////////////////
// Startup Code

#if defined(_WINDLL) || defined(_USRDLL)

// Declare DllMain
extern "C" BOOL WINAPI DllMain(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved);

extern "C" BOOL WINAPI _DllMainCRTStartup(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved)
{
	return DllMain(hDllHandle, dwReason, lpReserved);
}

#else

// wWinMain is not defined in winbase.h.
extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')


#ifdef _UNICODE
extern "C" void wWinMainCRTStartup()
#else // _UNICODE
extern "C" void WinMainCRTStartup()
#endif // _UNICODE
{
	LPTSTR lpszCommandLine = ::GetCommandLine();
	if(lpszCommandLine == NULL)
		::ExitProcess((UINT)-1);

	// Skip past program name (first token in command line).
	// Check for and handle quoted program name.
	if(*lpszCommandLine == DQUOTECHAR)
	{
		// Scan, and skip over, subsequent characters until
		// another double-quote or a null is encountered.
		do
		{
			lpszCommandLine = ::CharNext(lpszCommandLine);
		}
		while((*lpszCommandLine != DQUOTECHAR) && (*lpszCommandLine != _T('\0')));

		// If we stopped on a double-quote (usual case), skip over it.
		if(*lpszCommandLine == DQUOTECHAR)
			lpszCommandLine = ::CharNext(lpszCommandLine);
	}
	else
	{
		while(*lpszCommandLine > SPACECHAR)
			lpszCommandLine = ::CharNext(lpszCommandLine);
	}

	// Skip past any white space preceeding the second token.
	while(*lpszCommandLine && (*lpszCommandLine <= SPACECHAR))
		lpszCommandLine = ::CharNext(lpszCommandLine);

	STARTUPINFO StartupInfo;
	StartupInfo.dwFlags = 0;
	::GetStartupInfo(&StartupInfo);

	int nRet = _tWinMain(::GetModuleHandle(NULL), NULL, lpszCommandLine,
		(StartupInfo.dwFlags & STARTF_USESHOWWINDOW) ?
		StartupInfo.wShowWindow : SW_SHOWDEFAULT);

	::ExitProcess((UINT)nRet);
}

#endif // defined(_WINDLL) | defined(_USRDLL)

/////////////////////////////////////////////////////////////////////////////
// Heap Allocation

#ifndef _DEBUG

#ifndef _MERGE_PROXYSTUB
//rpcproxy.h does the same thing as this
int __cdecl _purecall()
{
	DebugBreak();
	return 0;
}
#endif

#if !defined(_M_ALPHA) && !defined(_M_PPC)
//RISC always initializes floating point and always defines _fltused
extern "C" const int _fltused = 0;
#endif

void* __cdecl malloc(size_t n)
{
	if (_Module.m_hHeap == NULL)
	{
		_Module.m_hHeap = HeapCreate(0, 0, 0);
		if (_Module.m_hHeap == NULL)
			return NULL;
	}
	_ASSERTE(_Module.m_hHeap != NULL);

#ifdef _MALLOC_ZEROINIT
	return HeapAlloc(_Module.m_hHeap, HEAP_ZERO_MEMORY, n);
#else
	return HeapAlloc(_Module.m_hHeap, 0, n);
#endif
}

void* __cdecl calloc(size_t n, size_t s)
{
	return malloc(n * s);
}

#pragma prefast(push)
#pragma prefast(suppress:308, "prefast bug 538")
void* __cdecl realloc(void* p, size_t n)
{
	_ASSERTE(_Module.m_hHeap != NULL);
#ifdef _MALLOC_ZEROINIT
	return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, HEAP_ZERO_MEMORY, p, n);
#else
	return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, 0, p, n);
#endif
}
#pragma prefast(pop)

void __cdecl free(void* p)
{
	_ASSERTE(_Module.m_hHeap != NULL);
	HeapFree(_Module.m_hHeap, 0, p);
}

void* __cdecl operator new(size_t n)
{
	return malloc(n);
}

void __cdecl operator delete(void* p)
{
	free(p);
}

#endif  //_DEBUG

#endif //_ATL_MIN_CRT

#ifndef _ATL_DLL

#ifndef ATL_NO_NAMESPACE
#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	_ASSERTE(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextO(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return UINT(lpszTemp-lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	_ASSERTE(pThis != NULL);
	// First entry in the com map should be a simple map entry
	_ASSERTE(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((LONG_PTR)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return S_OK;
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
			{
				_ASSERTE(!bBlind);
				IUnknown* pUnk = (IUnknown*)((LONG_PTR)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return S_OK;
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return hRes;
			}
		}
		pEntries++;
	}
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
	if (pStream != NULL)
	{
		CoReleaseMarshalData(pStream);
		pStream->Release();
	}
	return S_OK;
}

ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}

ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
	DWORD dwRet;
	MSG msg;

	while(1)
	{
		dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

		if (dwRet == WAIT_OBJECT_0)
			return TRUE;    // The event was signaled

		if (dwRet != WAIT_OBJECT_0 + 1)
			break;          // Something else happened

		// There is one or more window message available. Dispatch them
		while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
				return TRUE; // Event is now signaled.
		}
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	USES_CONVERSION_EX;
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
   if (ULONG_PTR( lpszDesc ) < 0x10000) // id
	{
		UINT nID = LOWORD((ULONG_PTR)lpszDesc);
		_ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
		if (LoadString(hInst, nID, szDesc, 1024) == 0)
		{
			_ASSERTE(FALSE);
			lstrcpy(szDesc, _T("Unknown Error"));
		}
		lpszDesc = T2OLE_EX(szDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (hRes == 0)
			hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	}

	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		if (dwHelpID != 0 && lpszHelpFile != NULL)
		{
			pICEI->SetHelpContext(dwHelpID);
			pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
		}
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
//#ifdef _DEBUG
//  USES_CONVERSION;
//  ATLTRACE(_T("AtlReportError: Description=\"%s\" returning %x\n"), OLE2CT(lpszDesc), hRes);
//#endif
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	if (pM->cbSize < sizeof(_ATL_MODULE))
		return E_INVALIDARG;
	pM->m_pObjMap = p;
	pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
	pM->m_nLockCnt=0L;
	pM->m_hHeap = NULL;
	
	__try {
		InitializeCriticalSection(&pM->m_csTypeInfoHolder);
	}
	__except (GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
	{
		return E_OUTOFMEMORY;
	}

	__try
	{
		InitializeCriticalSection(&pM->m_csWindowCreate);
	}
	__except (GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
	{
		DeleteCriticalSection(&pM->m_csTypeInfoHolder);
		return E_OUTOFMEMORY;
	}
	
	__try
	{
		InitializeCriticalSection(&pM->m_csObjMap);
	}
	__except (GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
	{
		DeleteCriticalSection(&pM->m_csTypeInfoHolder);
		DeleteCriticalSection(&pM->m_csWindowCreate);
		return E_OUTOFMEMORY;
	} 
	return S_OK;
}

ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
		pEntry++;
	}
	return hRes;
}

ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RevokeClassObject();
		pEntry++;
	}
	return hRes;
}

ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	if (ppv == NULL)
		return E_POINTER;
	while (pEntry->pclsid != NULL)
	{
		if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
		{
			if (pEntry->pCF == NULL)
			{
				EnterCriticalSection(&pM->m_csObjMap);
				__try
				{
					if (pEntry->pCF == NULL)
						hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
				}
				__finally
				{
					LeaveCriticalSection(&pM->m_csObjMap);
				}
			}
			if (pEntry->pCF != NULL)
				hRes = pEntry->pCF->QueryInterface(riid, ppv);
			break;
		}
		pEntry++;
	}
	if (*ppv == NULL && hRes == S_OK)
		hRes = CLASS_E_CLASSNOTAVAILABLE;
	return hRes;
}

ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_hInst != NULL);
	if (pM->m_pObjMap != NULL)
	{
		_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
			pEntry++;
		}
	}
	DeleteCriticalSection(&pM->m_csTypeInfoHolder);
	DeleteCriticalSection(&pM->m_csWindowCreate);
	DeleteCriticalSection(&pM->m_csObjMap);
	if (pM->m_hHeap != NULL)
		HeapDestroy(pM->m_hHeap);
	return S_OK;
}

ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_hInst != NULL);
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	for (;pEntry->pclsid != NULL; pEntry++)
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription() != NULL)
				continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		hRes = pEntry->pfnUpdateRegistry(TRUE);
		if (FAILED(hRes))
			break;
	}
	if (SUCCEEDED(hRes) && bRegTypeLib)
		hRes = AtlModuleRegisterTypeLib(pM, 0);
	return hRes;
}

ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_hInst != NULL);
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	for (;pEntry->pclsid != NULL; pEntry++)
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription() != NULL)
				continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		pEntry->pfnUpdateRegistry(FALSE); //unregister
	}
	return S_OK;
}

ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
	USES_CONVERSION_EX;
	_ASSERTE(pM != NULL);
	HRESULT hRes = S_OK;
	CComPtr<IRegistrar> p;
	if (pReg != NULL)
		p = pReg;
	else
	{
		hRes = CoCreateInstance(CLSID_Registrar, NULL,
			CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
	}
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH+1] = {0};
        if (!GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH)) {
            hRes = HRESULT_FROM_WIN32(GetLastError());
        } else {
            p->AddReplacement(OLESTR("Module"), T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
    
            if (NULL != pMapEntries)
            {
                while (NULL != pMapEntries->szKey)
                {
                    _ASSERTE(NULL != pMapEntries->szData);
                    p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
                    pMapEntries++;
                }
            }
            LPCOLESTR szType = OLESTR("REGISTRY");
            ZeroMemory(szModule, sizeof(szModule));
            if (GetModuleFileName(pM->m_hInstResource, szModule, _MAX_PATH))
            {
                LPOLESTR pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                if (ULONG_PTR(lpszRes) < 0x10000)
                {
                    if (bRegister)
                        hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((ULONG_PTR)lpszRes)), szType);
                    else
                        hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((ULONG_PTR)lpszRes)), szType);
                }
                else
                {
                    if (bRegister)
                        hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
                    else
                        hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
                }
            }
        }
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
	_ASSERTE(pM != NULL);
	USES_CONVERSION_EX;
	_ASSERTE(pM->m_hInstTypeLib != NULL);
	TCHAR szModule[_MAX_PATH+10] = {0};
	OLECHAR szDir[_MAX_PATH+1] = {0};
    if (!GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH))
        return HRESULT_FROM_WIN32(GetLastError());
	if (lpszIndex != NULL)
	{
		LPCTSTR lpctIndex = OLE2CT_EX(lpszIndex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (lpctIndex == NULL)
		{
			return E_OUTOFMEMORY;
		}
		if ((lstrlen(szModule) + lstrlen(lpctIndex)) < (_MAX_PATH + 10))
		{
			lstrcat(szModule, lpctIndex);
		}
		else
		{
			return E_FAIL;
		}
	}
	ITypeLib* pTypeLib;
	LPOLESTR lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if (lpszModule == NULL)
	{
		return E_OUTOFMEMORY;
	}
	HRESULT hr = LoadTypeLib(lpszModule, &pTypeLib);
	if (!SUCCEEDED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = NULL;
		LPTSTR lpsz;
		for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
		{
			if (*lpsz == _T('.'))
				lpszExt = lpsz;
		}
		if (lpszExt == NULL)
			lpszExt = lpsz;

		if ((lpszExt - szModule) > (_MAX_PATH + 5))
		{
			return E_FAIL;
		}
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (lpszModule == NULL)
		{
			return E_OUTOFMEMORY;
		}
		hr = LoadTypeLib(lpszModule, &pTypeLib);
	}
	if (SUCCEEDED(hr))
	{
		ocscpy(szDir, lpszModule);
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, lpszModule, szDir);
	}
	if (pTypeLib != NULL)
		pTypeLib->Release();
	return hr;
}

#ifndef ATL_NO_NAMESPACE
#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif
#endif

#endif //!_ATL_DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlwin.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN_H__
#define __ATLWIN_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
        #error atlwin.h requires atlbase.h to be included first
#endif

#ifndef WS_EX_NOINHERITLAYOUT
#define WS_EX_NOINHERITLAYOUT                   0x00100000L // Disable inheritence of mirroring by children
#endif
#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL                         0x00400000L // Right to left mirroring
#endif
#ifndef NOMIRRORBITMAP
#define NOMIRRORBITMAP                          (DWORD)0x80000000 // Do not Mirror the bitmap in this call
#endif
#ifndef LAYOUT_RTL
#define LAYOUT_RTL                              0x00000001 // Right to left
#endif
#ifndef LAYOUT_BTT
#define LAYOUT_BTT                              0x00000002 // Bottom to top
#endif
#ifndef LAYOUT_VBH
#define LAYOUT_VBH                              0x00000004 // Vertical before horizontal
#endif
#ifndef LAYOUT_ORIENTATIONMASK
#define LAYOUT_ORIENTATIONMASK                  LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH
#endif
#ifndef LAYOUT_BITMAPORIENTATIONPRESERVED
#define LAYOUT_BITMAPORIENTATIONPRESERVED       0x00000008
#endif

#ifdef SubclassWindow
#pragma push_macro( "SubclassWindow" )
#define _ATL_REDEF_SUBCLASSWINDOW
#undef SubclassWindow
#endif

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CWindow;
class CMessageMap;
class CDynamicChain;
class CWndClassInfo;
template <class T> class CWindowImpl;
template <class T> class CDialogImpl;
class CContainedWindow;

/////////////////////////////////////////////////////////////////////////////
// CWindow - client side for a Windows window

class CWindow
{
public:
        HWND m_hWnd;

        CWindow(HWND hWnd = NULL)
        {
                m_hWnd = hWnd;
        }

        CWindow& operator=(HWND hWnd)
        {
                m_hWnd = hWnd;
                return *this;
        }

        void Attach(HWND hWndNew)
        {
                _ASSERTE(::IsWindow(hWndNew));
                m_hWnd = hWndNew;
        }

        HWND Detach()
        {
                HWND hWnd = m_hWnd;
                m_hWnd = NULL;
                return hWnd;
        }

        BOOL DestroyWindow()
        {
                _ASSERTE(::IsWindow(m_hWnd));

                if(!::DestroyWindow(m_hWnd))
                        return FALSE;

                m_hWnd = NULL;
                return TRUE;
        }

// Attributes

        operator HWND() const { return m_hWnd; }

        DWORD GetStyle() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return (DWORD)::GetWindowLong(m_hWnd, GWL_STYLE);
        }

        DWORD GetExStyle() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return (DWORD)::GetWindowLong(m_hWnd, GWL_EXSTYLE);
        }

        BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);
        BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);

        LONG GetWindowLong(int nIndex) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindowLong(m_hWnd, nIndex);
        }

        LONG SetWindowLong(int nIndex, LONG dwNewLong)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetWindowLong(m_hWnd, nIndex, dwNewLong);
        }

        WORD GetWindowWord(int nIndex) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindowWord(m_hWnd, nIndex);
        }

        WORD SetWindowWord(int nIndex, WORD wNewWord)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetWindowWord(m_hWnd, nIndex, wNewWord);
        }

// Message Functions

        LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SendMessage(m_hWnd,message,wParam,lParam);
        }

        BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::PostMessage(m_hWnd,message,wParam,lParam);
        }

        BOOL SendNotifyMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SendNotifyMessage(m_hWnd, message, wParam, lParam);
        }

// Window Text Functions

        BOOL SetWindowText(LPCTSTR lpszString)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetWindowText(m_hWnd, lpszString);
        }

        int GetWindowText(LPTSTR lpszStringBuf, int nMaxCount) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindowText(m_hWnd, lpszStringBuf, nMaxCount);
        }

        int GetWindowTextLength() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindowTextLength(m_hWnd);
        }

        BOOL GetWindowText(BSTR& bstrText);

// Font Functions

        void SetFont(HFONT hFont, BOOL bRedraw = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
        }

        HFONT GetFont() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return (HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0);
        }

// Menu Functions (non-child windows only)
#if defined(_WINUSER_) && !defined(NOMENUS)
        HMENU GetMenu() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetMenu(m_hWnd);
        }

        BOOL SetMenu(HMENU hMenu)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetMenu(m_hWnd, hMenu);
        }

        BOOL DrawMenuBar()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::DrawMenuBar(m_hWnd);
        }

        HMENU GetSystemMenu(BOOL bRevert) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetSystemMenu(m_hWnd, bRevert);
        }

        BOOL HiliteMenuItem(HMENU hMenu, UINT uItemHilite, UINT uHilite)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::HiliteMenuItem(m_hWnd, hMenu, uItemHilite, uHilite);
        }
#endif
// Window Size and Position Functions

        BOOL IsIconic() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::IsIconic(m_hWnd);
        }

        BOOL IsZoomed() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::IsZoomed(m_hWnd);
        }

        BOOL MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint);
        }

        BOOL MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::MoveWindow(m_hWnd, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, bRepaint);
        }

        BOOL SetWindowPos(HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetWindowPos(m_hWnd, hWndInsertAfter, x, y, cx, cy, nFlags);
        }

        BOOL SetWindowPos(HWND hWndInsertAfter, LPCRECT lpRect, UINT nFlags)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetWindowPos(m_hWnd, hWndInsertAfter, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, nFlags);
        }

#if defined(_WINUSER_) && !defined(NOMDI)
        UINT ArrangeIconicWindows()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ArrangeIconicWindows(m_hWnd);
        }
#endif
        BOOL BringWindowToTop()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::BringWindowToTop(m_hWnd);
        }

        BOOL GetWindowRect(LPRECT lpRect) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindowRect(m_hWnd, lpRect);
        }

        BOOL GetClientRect(LPRECT lpRect) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetClientRect(m_hWnd, lpRect);
        }

        BOOL GetWindowPlacement(WINDOWPLACEMENT FAR* lpwndpl) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindowPlacement(m_hWnd, lpwndpl);
        }

        BOOL SetWindowPlacement(const WINDOWPLACEMENT FAR* lpwndpl)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetWindowPlacement(m_hWnd, lpwndpl);
        }

// Coordinate Mapping Functions

        BOOL ClientToScreen(LPPOINT lpPoint) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ClientToScreen(m_hWnd, lpPoint);
        }

        BOOL ClientToScreen(LPRECT lpRect) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                if(!::ClientToScreen(m_hWnd, (LPPOINT)lpRect))
                        return FALSE;
                if(!::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1))
                    return FALSE;
                if (GetExStyle() & WS_EX_LAYOUTRTL) {
                    // Swap left and right
                    LONG temp = lpRect->left;
                    lpRect->left = lpRect->right;
                    lpRect->right = temp;
                }
                return TRUE;
        }

        BOOL ScreenToClient(LPPOINT lpPoint) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ScreenToClient(m_hWnd, lpPoint);
        }

        BOOL ScreenToClient(LPRECT lpRect) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                if(!::ScreenToClient(m_hWnd, (LPPOINT)lpRect))
                        return FALSE;
                if(!::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1))
                        return FALSE;
                if (GetExStyle() & WS_EX_LAYOUTRTL) {
                    // Swap left and right
                    LONG temp = lpRect->left;
                    lpRect->left = lpRect->right;
                    lpRect->right = temp;
                }
                return TRUE;
        }

        int MapWindowPoints(HWND hWndTo, LPPOINT lpPoint, UINT nCount) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::MapWindowPoints(m_hWnd, hWndTo, lpPoint, nCount);
        }

        int MapWindowPoints(HWND hWndTo, LPRECT lpRect) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::MapWindowPoints(m_hWnd, hWndTo, (LPPOINT)lpRect, 2);
        }

// Update and Painting Functions

        HDC BeginPaint(LPPAINTSTRUCT lpPaint)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::BeginPaint(m_hWnd, lpPaint);
        }

        void EndPaint(LPPAINTSTRUCT lpPaint)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                ::EndPaint(m_hWnd, lpPaint);
        }

        HDC GetDC()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetDC(m_hWnd);
        }

        HDC GetWindowDC()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindowDC(m_hWnd);
        }

        int ReleaseDC(HDC hDC)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ReleaseDC(m_hWnd, hDC);
        }

        void Print(HDC hDC, DWORD dwFlags) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_PRINT, (WPARAM)hDC, dwFlags);
        }

        void PrintClient(HDC hDC, DWORD dwFlags) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)hDC, dwFlags);
        }

        BOOL UpdateWindow()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::UpdateWindow(m_hWnd);
        }

        void SetRedraw(BOOL bRedraw = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_SETREDRAW, (WPARAM)bRedraw, 0);
        }

        BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetUpdateRect(m_hWnd, lpRect, bErase);
        }

        int GetUpdateRgn(HRGN hRgn, BOOL bErase = FALSE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetUpdateRgn(m_hWnd, hRgn, bErase);
        }

        BOOL Invalidate(BOOL bErase = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::InvalidateRect(m_hWnd, NULL, bErase);
        }

        BOOL InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::InvalidateRect(m_hWnd, lpRect, bErase);
        }

        void InvalidateRgn(HRGN hRgn, BOOL bErase = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                ::InvalidateRgn(m_hWnd, hRgn, bErase);
        }

        BOOL ValidateRect(LPCRECT lpRect)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ValidateRect(m_hWnd, lpRect);
        }

        BOOL ValidateRgn(HRGN hRgn)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ValidateRgn(m_hWnd, hRgn);
        }

        BOOL ShowWindow(int nCmdShow)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ShowWindow(m_hWnd, nCmdShow);
        }

        BOOL IsWindowVisible() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::IsWindowVisible(m_hWnd);
        }

        BOOL ShowOwnedPopups(BOOL bShow = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ShowOwnedPopups(m_hWnd, bShow);
        }

        HDC GetDCEx(HRGN hRgnClip, DWORD flags)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetDCEx(m_hWnd, hRgnClip, flags);
        }

        BOOL LockWindowUpdate(BOOL bLock = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::LockWindowUpdate(bLock ? m_hWnd : NULL);
        }

        BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL, HRGN hRgnUpdate = NULL, UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::RedrawWindow(m_hWnd, lpRectUpdate, hRgnUpdate, flags);
        }

// Timer Functions

        UINT_PTR SetTimer(UINT_PTR nIDEvent, UINT nElapse, void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD))
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetTimer(m_hWnd, nIDEvent, nElapse, (TIMERPROC)lpfnTimer);
        }

        BOOL KillTimer(UINT_PTR nIDEvent)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::KillTimer(m_hWnd, nIDEvent);
        }

// Window State Functions

        BOOL IsWindowEnabled() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::IsWindowEnabled(m_hWnd);
        }

        BOOL EnableWindow(BOOL bEnable = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::EnableWindow(m_hWnd, bEnable);
        }

        HWND SetActiveWindow()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetActiveWindow(m_hWnd);
        }

        HWND SetCapture()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetCapture(m_hWnd);
        }

        HWND SetFocus()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetFocus(m_hWnd);
        }

// Dialog-Box Item Functions

        BOOL CheckDlgButton(int nIDButton, UINT nCheck)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::CheckDlgButton(m_hWnd, nIDButton, nCheck);
        }

        BOOL CheckRadioButton(int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton);
        }

        int DlgDirList(LPTSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT nFileType)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox, nIDStaticPath, nFileType);
        }

        int DlgDirListComboBox(LPTSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT nFileType)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::DlgDirListComboBox(m_hWnd, lpPathSpec, nIDComboBox, nIDStaticPath, nFileType);
        }

        BOOL DlgDirSelect(LPTSTR lpString, int nCount, int nIDListBox)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::DlgDirSelectEx(m_hWnd, lpString, nCount, nIDListBox);
        }

        BOOL DlgDirSelectComboBox(LPTSTR lpString, int nCount, int nIDComboBox)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, nCount, nIDComboBox);
        }

        UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL, BOOL bSigned = TRUE) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);
        }

        UINT GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);
        }

        BOOL GetDlgItemText(int nID, BSTR& bstrText) const
        {
                _ASSERTE(::IsWindow(m_hWnd));

                HWND hWndCtl = GetDlgItem(nID);
                if(hWndCtl == NULL)
                        return FALSE;

                return CWindow(hWndCtl).GetWindowText(bstrText);
        }

        HWND GetNextDlgGroupItem(HWND hWndCtl, BOOL bPrevious = FALSE) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetNextDlgGroupItem(m_hWnd, hWndCtl, bPrevious);
        }

        HWND GetNextDlgTabItem(HWND hWndCtl, BOOL bPrevious = FALSE) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetNextDlgTabItem(m_hWnd, hWndCtl, bPrevious);
        }

        UINT IsDlgButtonChecked(int nIDButton) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::IsDlgButtonChecked(m_hWnd, nIDButton);
        }

        LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam);
        }

        BOOL SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned);
        }

        BOOL SetDlgItemText(int nID, LPCTSTR lpszString)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetDlgItemText(m_hWnd, nID, lpszString);
        }

// Scrolling Functions

        int GetScrollPos(int nBar) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetScrollPos(m_hWnd, nBar);
        }

        BOOL GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetScrollRange(m_hWnd, nBar, lpMinPos, lpMaxPos);
        }

        BOOL ScrollWindow(int xAmount, int yAmount, LPCRECT lpRect = NULL, LPCRECT lpClipRect = NULL)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ScrollWindow(m_hWnd, xAmount, yAmount, lpRect, lpClipRect);
        }

        int ScrollWindowEx(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate, UINT flags)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, flags);
        }

        int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetScrollPos(m_hWnd, nBar, nPos, bRedraw);
        }

        BOOL SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetScrollRange(m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
        }

        BOOL ShowScrollBar(UINT nBar, BOOL bShow = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ShowScrollBar(m_hWnd, nBar, bShow);
        }

        BOOL EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::EnableScrollBar(m_hWnd, uSBFlags, uArrowFlags);
        }

// Window Access Functions

        HWND ChildWindowFromPoint(POINT point) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ChildWindowFromPoint(m_hWnd, point);
        }

        HWND ChildWindowFromPointEx(POINT point, UINT uFlags) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ChildWindowFromPointEx(m_hWnd, point, uFlags);
        }

        HWND GetTopWindow() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetTopWindow(m_hWnd);
        }

        HWND GetWindow(UINT nCmd) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindow(m_hWnd, nCmd);
        }

        HWND GetLastActivePopup() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetLastActivePopup(m_hWnd);
        }

        BOOL IsChild(HWND hWnd) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::IsChild(m_hWnd, hWnd);
        }

        HWND GetParent() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetParent(m_hWnd);
        }

        HWND SetParent(HWND hWndNewParent)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetParent(m_hWnd, hWndNewParent);
        }

// Window Tree Access

        int GetDlgCtrlID() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetDlgCtrlID(m_hWnd);
        }

        int SetDlgCtrlID(int nID)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return (int)::SetWindowLong(m_hWnd, GWL_ID, nID);
        }

        HWND GetDlgItem(int nID) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetDlgItem(m_hWnd, nID);
        }

        HWND GetDescendantWindow(int nID) const;

        void SendMessageToDescendants(UINT message, WPARAM wParam = 0, LPARAM lParam = 0, BOOL bDeep = TRUE);

// Alert Functions

        BOOL FlashWindow(BOOL bInvert)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::FlashWindow(m_hWnd, bInvert);
        }

        int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL, UINT nType = MB_OK)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::MessageBox(m_hWnd, lpszText, lpszCaption, nType);
        }

// Clipboard Functions

        BOOL ChangeClipboardChain(HWND hWndNewNext)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ChangeClipboardChain(m_hWnd, hWndNewNext);
        }

        HWND SetClipboardViewer()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetClipboardViewer(m_hWnd);
        }

        BOOL OpenClipboard()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::OpenClipboard(m_hWnd);
        }

// Caret Functions

        BOOL CreateCaret(HBITMAP hBitmap)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::CreateCaret(m_hWnd, hBitmap, 0, 0);
        }

        BOOL CreateSolidCaret(int nWidth, int nHeight)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight);
        }

        BOOL CreateGrayCaret(int nWidth, int nHeight)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight);
        }

        BOOL HideCaret()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::HideCaret(m_hWnd);
        }

        BOOL ShowCaret()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::ShowCaret(m_hWnd);
        }

// Drag-Drop Functions
#ifdef _INC_SHELLAPI
        void DragAcceptFiles(BOOL bAccept = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd)); ::DragAcceptFiles(m_hWnd, bAccept);
        }
#endif
// Icon Functions

        HICON SetIcon(HICON hIcon, BOOL bBigIcon = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon);
        }

        HICON GetIcon(BOOL bBigIcon = TRUE) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0);
        }

// Help Functions
#if defined(_WINUSER_) && !defined(NOHELP)

        BOOL WinHelp(LPCTSTR lpszHelp, UINT nCmd = HELP_CONTEXT, DWORD_PTR dwData = 0)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::WinHelp(m_hWnd, lpszHelp, nCmd, dwData);
        }

        BOOL SetWindowContextHelpId(DWORD dwContextHelpId)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId);
        }

        DWORD GetWindowContextHelpId() const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return ::GetWindowContextHelpId(m_hWnd);
        }
#endif
// Hot Key Functions

        int SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return (int)::SendMessage(m_hWnd, WM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0);
        }

        DWORD GetHotKey(WORD& /* wVirtualKeyCode */, WORD& /* wModifiers */) const
        {
                _ASSERTE(::IsWindow(m_hWnd));
                return (DWORD)::SendMessage(m_hWnd, WM_GETHOTKEY, 0, 0);
        }

// Misc. Operations

        BOOL CenterWindow(HWND hWndCenter = NULL);

        HWND GetTopLevelParent() const;
        HWND GetTopLevelWindow() const;
};

/////////////////////////////////////////////////////////////////////////////
// Thunks for __stdcall member functions

#if defined(_M_IX86)
#pragma pack(push,1)
struct _stdcallthunk
{
        DWORD   m_mov;          // mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)
        DWORD   m_this;         //
        BYTE    m_jmp;          // jmp WndProc
        DWORD   m_relproc;      // relative jmp
        void Init(DWORD_PTR proc, void* pThis)
        {
                m_mov = 0x042444C7;  //C7 44 24 0C
                m_this = PtrToUlong(pThis);
                m_jmp = 0xe9;
                m_relproc = DWORD((INT_PTR)proc - ((INT_PTR)this+sizeof(_stdcallthunk)));
                // write block from data cache and
                //  flush from instruction cache
                FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
        }
};
#pragma pack(pop)
#elif defined (_M_AMD64)
#pragma pack(push,2)
struct _stdcallthunk
{
    USHORT  RcxMov;         // mov rcx, pThis
    ULONG64 RcxImm;         // 
    USHORT  RaxMov;         // mov rax, target
    ULONG64 RaxImm;         //
    USHORT  RaxJmp;         // jmp target
    void Init(DWORD_PTR proc, void *pThis)
    {
        RcxMov = 0xb948;          // mov rcx, pThis
        RcxImm = (ULONG64)pThis;  // 
        RaxMov = 0xb848;          // mov rax, target
        RaxImm = (ULONG64)proc;   //
        RaxJmp = 0xe0ff;          // jmp rax
        FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
    }
};
#pragma pack(pop)
#elif defined(_M_IA64)
#pragma pack(push,8)
extern "C" LRESULT CALLBACK _WndProcThunkProc( HWND, UINT, WPARAM, LPARAM );
struct _FuncDesc
{
        void* pfn;
        void* gp;
};
struct _stdcallthunk
{
        _FuncDesc m_funcdesc;
        void* m_pFunc;
        void* m_pThis;
        void Init(DWORD_PTR proc, void* pThis)
        {
                const _FuncDesc* pThunkProc;

                pThunkProc = reinterpret_cast< const _FuncDesc* >( _WndProcThunkProc );
                m_funcdesc.pfn = pThunkProc->pfn;
                m_funcdesc.gp = &m_pFunc;
                m_pFunc = reinterpret_cast< void* >( proc );
                m_pThis = pThis;
                ::FlushInstructionCache( GetCurrentProcess(), this, sizeof( _stdcallthunk ) );
        }
};
#pragma pack(pop)
#else
#error Only AMD64, IA64, and X86 supported
#endif

class CDynamicStdCallThunk
{
public:
        _stdcallthunk *pThunk;

        CDynamicStdCallThunk()
        {
                pThunk = NULL;
        }

        ~CDynamicStdCallThunk()
        {
                if (pThunk)
                        HeapFree(GetProcessHeap(), 0, pThunk);
        }

        void Init(DWORD_PTR proc, void *pThis)
        {
            if (!pThunk) {
                pThunk = static_cast<_stdcallthunk *>(HeapAlloc(GetProcessHeap(), 
                        HEAP_GENERATE_EXCEPTIONS, sizeof(_stdcallthunk)));
            }
            ATLASSERT(pThunk);
            pThunk->Init(proc, pThis);
        }
};
typedef CDynamicStdCallThunk CStdCallThunk;

/////////////////////////////////////////////////////////////////////////////
// WindowProc thunks

class CWndProcThunk
{
public:
        _AtlCreateWndData cd;
        CStdCallThunk thunk;

        void Init(WNDPROC proc, void* pThis)
        {
            thunk.Init((DWORD_PTR)proc, pThis);
        }
};

/////////////////////////////////////////////////////////////////////////////
// CMessageMap - abstract class that provides an interface for message maps

class ATL_NO_VTABLE CMessageMap
{
public:
        virtual BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                LRESULT& lResult, DWORD dwMsgMapID) = 0;
};


/////////////////////////////////////////////////////////////////////////////
// Message map

#define BEGIN_MSG_MAP(theClass) \
public: \
        BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0) \
        { \
                BOOL bHandled = TRUE; \
                hWnd; \
                switch(dwMsgMapID) \
                { \
                case 0:

#define ALT_MSG_MAP(msgMapID) \
                break; \
                case msgMapID:

#define MESSAGE_HANDLER(msg, func) \
        if(uMsg == msg) \
        { \
                bHandled = TRUE; \
                lResult = func(uMsg, wParam, lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define MESSAGE_RANGE_HANDLER(msgFirst, msgLast, func) \
        if(uMsg >= msgFirst && uMsg <= msgLast) \
        { \
                bHandled = TRUE; \
                lResult = func(uMsg, wParam, lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define COMMAND_HANDLER(id, code, func) \
        if(uMsg == WM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
        { \
                bHandled = TRUE; \
                lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define COMMAND_ID_HANDLER(id, func) \
        if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
        { \
                bHandled = TRUE; \
                lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define COMMAND_CODE_HANDLER(code, func) \
        if(uMsg == WM_COMMAND && code == HIWORD(wParam)) \
        { \
                bHandled = TRUE; \
                lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
        if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
        { \
                bHandled = TRUE; \
                lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define NOTIFY_HANDLER(id, cd, func) \
        if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
        { \
                bHandled = TRUE; \
                lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define NOTIFY_ID_HANDLER(id, func) \
        if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
        { \
                bHandled = TRUE; \
                lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define NOTIFY_CODE_HANDLER(cd, func) \
        if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
        { \
                bHandled = TRUE; \
                lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
        if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
        { \
                bHandled = TRUE; \
                lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP(theChainClass) \
        { \
                if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_MEMBER(theChainMember) \
        { \
                if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_ALT(theChainClass, msgMapID) \
        { \
                if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_ALT_MEMBER(theChainMember, msgMapID) \
        { \
                if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_DYNAMIC(dynaChainID) \
        { \
                if(CDynamicChain::CallChain(dynaChainID, hWnd, uMsg, wParam, lParam, lResult)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_ALT_DYNAMIC(dynaChainID, msgMapID) \
        { \
                if(CDynamicChain::CallChain(dynaChainID, hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
                        return TRUE; \
        }

#define END_MSG_MAP() \
                        break; \
                default: \
                        ATLTRACE(_T("Invalid message map ID (%i)\n"), dwMsgMapID); \
                        _ASSERTE(FALSE); \
                        break; \
                } \
                return FALSE; \
        }


// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


/////////////////////////////////////////////////////////////////////////////
// CDynamicChain - provides support for dynamic chaining

class CDynamicChain
{
public:
        struct ATL_CHAIN_ENTRY
        {
                DWORD m_dwChainID;
                CMessageMap* m_pObject;
                DWORD m_dwMsgMapID;
        };

        int m_nEntries;
        ATL_CHAIN_ENTRY** m_pChainEntry;

        CDynamicChain() : m_nEntries(0), m_pChainEntry(NULL)
        { }

        ~CDynamicChain();
        BOOL SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID = 0);
        BOOL RemoveChainEntry(DWORD dwChainID);
        BOOL CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult);
};


/////////////////////////////////////////////////////////////////////////////
// CWndClassInfo - Manages Windows class information

class CWndClassInfo
{
public:
        WNDCLASSEX m_wc;
        LPCTSTR m_lpszOrigName;
        WNDPROC pWndProc;
        LPCTSTR m_lpszCursorID;
        BOOL m_bSystemCursor;
        ATOM m_atom;
        TCHAR m_szAutoName[sizeof("ATL:") + (sizeof(PVOID)*2)+1];
        ATOM Register(WNDPROC*);
};

#define DECLARE_WND_CLASS(WndClassName) \
static CWndClassInfo& GetWndClassInfo() \
{ \
        static CWndClassInfo wc = \
        { \
                { sizeof(WNDCLASSEX), CS_HREDRAW|CS_VREDRAW, StartWindowProc, \
                  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, WndClassName, 0 }, \
                NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
        }; \
        return wc; \
}

#define DECLARE_WND_SUPERCLASS(WndClassName, OrigWndClassName) \
static CWndClassInfo& GetWndClassInfo() \
{ \
        static CWndClassInfo wc = \
        { \
                { sizeof(WNDCLASSEX), NULL, StartWindowProc, \
                  0, 0, 0, 0, 0, NULL, 0, WndClassName, 0 }, \
                OrigWndClassName, NULL, NULL, TRUE, 0, _T("") \
        }; \
        return wc; \
}

/////////////////////////////////////////////////////////////////////////////
// CWindowImpl - Implements a window

class ATL_NO_VTABLE CWindowImplBase : public CWindow, public CMessageMap
{
public:
        CWndProcThunk m_thunk;
        WNDPROC m_pfnSuperWindowProc;

        CWindowImplBase() : m_pfnSuperWindowProc(::DefWindowProc)
        {}

        static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
                        DWORD dwStyle, DWORD dwExStyle, UINT_PTR nID, ATOM atom);
        BOOL SubclassWindow(HWND hWnd);
        HWND UnsubclassWindow();

        LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
        {
#ifdef STRICT
                return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
                return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
        }
};

template <class T>
class ATL_NO_VTABLE CWindowImpl : public CWindowImplBase
{
public:
        DECLARE_WND_CLASS(NULL)

        HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
                        DWORD dwStyle = WS_CHILD | WS_VISIBLE, DWORD dwExStyle = 0,
                        UINT_PTR nID = 0)
        {
                ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);
                return CWindowImplBase::Create(hWndParent, rcPos, szWindowName, dwStyle, dwExStyle,
                        nID, atom);
        }
};

/////////////////////////////////////////////////////////////////////////////
// CDialog - Implements a dialog box

class ATL_NO_VTABLE CDialogImplBase : public CWindow, public CMessageMap
{
public:
        CWndProcThunk m_thunk;

        static INT_PTR CALLBACK StartDialogProc(HWND hWnd, UINT uMsg,
                WPARAM wParam, LPARAM lParam);
        static INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        BOOL EndDialog(int nRetCode);
};

template <class T>
class ATL_NO_VTABLE CDialogImpl : public CDialogImplBase
{
public:
        INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
        {
                _ASSERTE(m_hWnd == NULL);
                _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
                INT_PTR nRet = ::DialogBoxParam(_Module.GetResourceInstance(),
                                MAKEINTRESOURCE(T::IDD),
                                hWndParent,
                                T::StartDialogProc,
                                NULL);
                m_hWnd = NULL;
                return nRet;
        }

        HWND Create(HWND hWndParent)
        {
                _ASSERTE(m_hWnd == NULL);
                _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
                HWND hWnd = ::CreateDialogParam(_Module.GetResourceInstance(),
                                MAKEINTRESOURCE(T::IDD),
                                hWndParent,
                                T::StartDialogProc,
                                NULL);
                _ASSERTE(m_hWnd == hWnd);
                return hWnd;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CContainedWindow - Implements a contained window

class CContainedWindow : public CWindow
{
public:
        CWndProcThunk m_thunk;
        LPTSTR m_lpszClassName;
        WNDPROC m_pfnSuperWindowProc;
        CMessageMap* m_pObject;
        DWORD m_dwMsgMapID;

        CContainedWindow(LPTSTR lpszClassName, CMessageMap* pObject, DWORD dwMsgMapID = 0)
                : m_lpszClassName(lpszClassName),
                m_pfnSuperWindowProc(::DefWindowProc),
                m_pObject(pObject), m_dwMsgMapID(dwMsgMapID)
        { }

        void SwitchMessageMap(DWORD dwMsgMapID)
        {
                m_dwMsgMapID = dwMsgMapID;
        }

        static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg,
                WPARAM wParam, LPARAM lParam);
        static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        ATOM RegisterWndSuperclass();
        HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
                DWORD dwStyle = WS_CHILD | WS_VISIBLE, DWORD dwExStyle = 0,
                UINT nID = 0);
        BOOL SubclassWindow(HWND hWnd);
        HWND UnsubclassWindow();

        LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
        {
#ifdef STRICT
                return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
                return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
        }
};


#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

#ifdef _ATL_REDEF_SUBCLASSWINDOW
#pragma pop_macro( "SubclassWindow" )
#undef _ATL_REDEF_SUBCLASSWINDOW
#endif

#endif // __ATLWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlwin21.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN21_H__
#define __ATLWIN21_H__

#ifndef __cplusplus
    #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef __ATLWIN_H__
    #error atlwin21.h should be included instead of atlwin.h
#endif

#if (_ATL_VER < 0x0200) && (_ATL_VER >= 0x0300)
    #error atlwin21.h should be used only with ATL 2.0/2.1
#endif //(_ATL_VER < 0x0200) && (_ATL_VER >= 0x0300)

// Redefine class names and include old atlwin.h

#define CWindow     CWindowOld
#define _WndProcThunk   _WndProcThunkOld
#define _FuncDesc   _FuncDescOld
#define CWndProcThunk   CWndProcThunkOld
#define _stdcallthunk _stdcallthunkOld
#define CDynamicStdCallThunk CDynamicStdCallThunkOld
#define CStdCallThunk CStdCallThunkOld
#define CWindowImplBase CWindowImplBaseOld
#define CWindowImpl CWindowImplOld
#define CDialogImplBase CDialogImplBaseOld
#define CDialogImpl CDialogImplOld

#include <atlwin.h>

#undef CWindow
#undef _FuncDesc
#undef _WndProcThunk
#undef CWndProcThunk
#undef _stdcallthunk
#undef CDynamicStdCallThunk
#undef CStdCallThunk
#undef CWindowImplBase
#undef CWindowImpl
#undef CDialogImplBase
#undef CDialogImpl


#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#ifndef ATLTRACE2
#define ATLTRACE2(cat, lev, msg)    ATLTRACE(msg)
#endif

namespace ATL
{

#pragma pack(push, _ATL_PACKING)


/////////////////////////////////////////////////////////////////////////////
// CWindow - client side for a Windows window

class CWindow : public CWindowOld
{
public:
    static RECT rcDefault;

// Construction and creation
    CWindow(HWND hWnd = NULL)
    {
        m_hWnd = hWnd;
    }

    CWindow& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(LPCTSTR lpstrWndClass, HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        m_hWnd = ::CreateWindowEx(dwExStyle, lpstrWndClass, szWindowName,
            dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
            rcPos.bottom - rcPos.top, hWndParent, (HMENU)(UINT_PTR)nID,
            _Module.GetModuleInstance(), lpCreateParam);
        return m_hWnd;
    }

    HWND Create(LPCTSTR lpstrWndClass, HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        if(lpRect == NULL)
            lpRect = &rcDefault;
        m_hWnd = ::CreateWindowEx(dwExStyle, lpstrWndClass, szWindowName,
            dwStyle, lpRect->left, lpRect->top, lpRect->right - lpRect->left,
            lpRect->bottom - lpRect->top, hWndParent, hMenu,
            _Module.GetModuleInstance(), lpCreateParam);
        return m_hWnd;
    }

// Attributes
    operator HWND() const { return m_hWnd; }

    static LPCTSTR GetWndClassName()
    {
        return NULL;
    }

// Operations
    // support for C style macros
    static LRESULT SendMessage(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
        ATLASSERT(::IsWindow(hWnd));
        return ::SendMessage(hWnd, message, wParam, lParam);
    }

    // this one is here just so it's not hidden
    LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, message, wParam, lParam);
    }

    BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::GetScrollInfo(m_hWnd, nBar, lpScrollInfo);
    }
    BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SetScrollInfo(m_hWnd, nBar, lpScrollInfo, bRedraw);
    }
    BOOL IsDialogMessage(LPMSG lpMsg)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::IsDialogMessage(m_hWnd, lpMsg);
    }

    void NextDlgCtrl() const
        {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0L);
    }
    void PrevDlgCtrl() const
        {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0L);
    }
    void GotoDlgCtrl(HWND hWndCtrl) const
        {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)hWndCtrl, 1L);
    }

    BOOL ResizeClient(int nWidth, int nHeight, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));

        RECT rcWnd;
        if(!GetClientRect(&rcWnd))
            return FALSE;

        if(nWidth != -1)
            rcWnd.right = nWidth;
        if(nHeight != -1)
            rcWnd.bottom = nHeight;

        if(!::AdjustWindowRectEx(&rcWnd, GetStyle(), (!(GetStyle() & WS_CHILD) && (GetMenu() != NULL)), GetExStyle()))
            return FALSE;

        UINT uFlags = SWP_NOZORDER | SWP_NOMOVE;
        if(!bRedraw)
            uFlags |= SWP_NOREDRAW;

        return SetWindowPos(NULL, 0, 0, rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top, uFlags);
    }

#ifndef UNDER_CE
    int GetWindowRgn(HRGN hRgn)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::GetWindowRgn(m_hWnd, hRgn);
    }
    int SetWindowRgn(HRGN hRgn, BOOL bRedraw = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SetWindowRgn(m_hWnd, hRgn, bRedraw);
    }
    HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::DeferWindowPos(hWinPosInfo, m_hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
    }
#endif //!UNDER_CE
    DWORD GetWindowThreadID()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::GetWindowThreadProcessId(m_hWnd, NULL);
    }
    DWORD GetWindowProcessID()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        DWORD dwProcessID;
        ::GetWindowThreadProcessId(m_hWnd, &dwProcessID);
        return dwProcessID;
    }
    BOOL IsWindow()
    {
        return ::IsWindow(m_hWnd);
    }
#ifndef UNDER_CE
    BOOL IsWindowUnicode()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::IsWindowUnicode(m_hWnd);
    }
    BOOL ShowWindowAsync(int nCmdShow)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::ShowWindowAsync(m_hWnd, nCmdShow);
    }
#endif //!UNDER_CE
};

_declspec(selectany) RECT CWindow::rcDefault = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };

/////////////////////////////////////////////////////////////////////////////
// Thunks for __stdcall member functions

#if defined(_M_IX86)
#pragma pack(push,1)
struct _stdcallthunk
{
        DWORD   m_mov;          // mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)
        DWORD   m_this;         //
        BYTE    m_jmp;          // jmp WndProc
        DWORD   m_relproc;      // relative jmp
        void Init(DWORD_PTR proc, void* pThis)
        {
                m_mov = 0x042444C7;  //C7 44 24 0C
                m_this = PtrToUlong(pThis);
                m_jmp = 0xe9;
                m_relproc = DWORD((INT_PTR)proc - ((INT_PTR)this+sizeof(_stdcallthunk)));
                // write block from data cache and
                //  flush from instruction cache
                FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
        }
};
#pragma pack(pop)
#elif defined (_M_AMD64)
#pragma pack(push,2)
struct _stdcallthunk
{
    USHORT  RcxMov;         // mov rcx, pThis
    ULONG64 RcxImm;         // 
    USHORT  RaxMov;         // mov rax, target
    ULONG64 RaxImm;         //
    USHORT  RaxJmp;         // jmp target
    void Init(DWORD_PTR proc, void *pThis)
    {
        RcxMov = 0xb948;          // mov rcx, pThis
        RcxImm = (ULONG64)pThis;  // 
        RaxMov = 0xb848;          // mov rax, target
        RaxImm = (ULONG64)proc;   //
        RaxJmp = 0xe0ff;          // jmp rax
        FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
    }
};
#pragma pack(pop)

#elif defined(_M_IA64)
#pragma pack(push,8)
extern "C" LRESULT CALLBACK _WndProcThunkProc( HWND, UINT, WPARAM, LPARAM );
struct _FuncDesc
{
        void* pfn;
        void* gp;
};
struct _stdcallthunk
{
        _FuncDesc m_funcdesc;
        void* m_pFunc;
        void* m_pThis;
        void Init(DWORD_PTR proc, void* pThis)
        {
                const _FuncDesc* pThunkProc;

                pThunkProc = reinterpret_cast< const _FuncDesc* >( _WndProcThunkProc );
                m_funcdesc.pfn = pThunkProc->pfn;
                m_funcdesc.gp = &m_pFunc;
                m_pFunc = reinterpret_cast< void* >( proc );
                m_pThis = pThis;
                ::FlushInstructionCache( GetCurrentProcess(), this, sizeof( _stdcallthunk ) );
        }
};
#pragma pack(pop)
#else
#error Only AMD64, IA64, and X86 supported
#endif

class CDynamicStdCallThunk
{
public:
        _stdcallthunk *pThunk;

        CDynamicStdCallThunk()
        {
                pThunk = NULL;
        }

        ~CDynamicStdCallThunk()
        {
                if (pThunk)
                        HeapFree(GetProcessHeap(), 0, pThunk);
        }

        void Init(DWORD_PTR proc, void *pThis)
        {
            if (!pThunk) {
                pThunk = static_cast<_stdcallthunk *>(HeapAlloc(GetProcessHeap(), 
                        HEAP_GENERATE_EXCEPTIONS, sizeof(_stdcallthunk)));
            }
            ATLASSERT(pThunk);
            pThunk->Init(proc, pThis);
        }
};
typedef CDynamicStdCallThunk CStdCallThunk;

/////////////////////////////////////////////////////////////////////////////
// WindowProc thunks

class CWndProcThunk
{
public:
        _AtlCreateWndData cd;
        CStdCallThunk thunk;

        void Init(WNDPROC proc, void* pThis)
        {
            thunk.Init((DWORD_PTR)proc, pThis);
        }
};

/////////////////////////////////////////////////////////////////////////////
// New message map macros

// Empty message map macro

#define DECLARE_EMPTY_MSG_MAP() \
public: \
    BOOL ProcessWindowMessage(HWND, UINT, WPARAM, LPARAM, LRESULT&, DWORD) \
    { \
        return FALSE; \
    }

// Message reflection macros

#define REFLECT_NOTIFICATIONS() \
    { \
        bHandled = TRUE; \
        lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
        if(bHandled) \
            return TRUE; \
    }

#define DEFAULT_REFLECTION_HANDLER() \
    if(DefaultReflectionHandler(hWnd, uMsg, wParam, lParam, lResult)) \
        return TRUE;


/////////////////////////////////////////////////////////////////////////////
// CWinTraits - Defines various default values for a window

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0>
class CWinTraits
{
public:
    static DWORD GetWndStyle(DWORD dwStyle)
    {
        return dwStyle == 0 ? t_dwStyle : dwStyle;
    }
    static DWORD GetWndExStyle(DWORD dwExStyle)
    {
        return dwExStyle == 0 ? t_dwExStyle : dwExStyle;
    }
};

typedef CWinTraits<WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0>        CControlWinTraits;
#ifndef UNDER_CE
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE>         CFrameWinTraits;
#else
typedef CWinTraits<WS_OVERLAPPED | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_CAPTION | WS_SYSMENU | WS_BORDER, WS_EX_WINDOWEDGE>   CFrameWinTraits;
#endif //!UNDER_CE
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_MDICHILD> CMDIChildWinTraits;

typedef CWinTraits<0, 0> CNullTraits;

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0, class TWinTraits = CControlWinTraits>
class CWinTraitsOR
{
public:
    static DWORD GetWndStyle(DWORD dwStyle)
    {
        return dwStyle | t_dwStyle | TWinTraits::GetWndStyle(dwStyle);
    }
    static DWORD GetWndExStyle(DWORD dwExStyle)
    {
        return dwExStyle | t_dwExStyle | TWinTraits::GetWndExStyle(dwExStyle);
    }
};


/////////////////////////////////////////////////////////////////////////////
// CWindowImpl - Implements a window

template <class TBase = CWindow>
class ATL_NO_VTABLE CWindowImplRoot : public TBase, public CMessageMap
{
public:
    CWndProcThunk m_thunk;

// Destructor
    ~CWindowImplRoot()
    {
        ATLASSERT(m_hWnd == NULL);  // should be cleared in WindowProc
    }

// Message reflection support
    LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    static BOOL DefaultReflectionHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult);
};

template <class TBase>
LRESULT CWindowImplRoot< TBase >::ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND hWndChild = NULL;

    switch(uMsg)
    {
    case WM_COMMAND:
        if(lParam != NULL)  // not from a menu
            hWndChild = (HWND)lParam;
        break;
    case WM_NOTIFY:
        hWndChild = ((LPNMHDR)lParam)->hwndFrom;
        break;
#ifndef UNDER_CE
    case WM_PARENTNOTIFY:
        switch(LOWORD(wParam))
        {
        case WM_CREATE:
        case WM_DESTROY:
            hWndChild = (HWND)lParam;
            break;
        default:
            hWndChild = GetDlgItem(HIWORD(wParam));
            break;
        }
        break;
#endif //!UNDER_CE
    case WM_DRAWITEM:
        if(wParam)  // not from a menu
            hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
        break;
    case WM_MEASUREITEM:
        if(wParam)  // not from a menu
            hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
        break;
    case WM_COMPAREITEM:
        if(wParam)  // not from a menu
            hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
        break;
    case WM_DELETEITEM:
        if(wParam)  // not from a menu
            hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
        break;
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
    case WM_HSCROLL:
    case WM_VSCROLL:
        hWndChild = (HWND)lParam;
        break;
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
        hWndChild = (HWND)lParam;
        break;
    default:
        break;
    }

    if(hWndChild == NULL)
    {
        bHandled = FALSE;
        return 1;
    }

    ATLASSERT(::IsWindow(hWndChild));
    return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
}

template <class TBase>
BOOL CWindowImplRoot< TBase >::DefaultReflectionHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
{
    switch(uMsg)
    {
    case OCM_COMMAND:
    case OCM_NOTIFY:
#ifndef UNDER_CE
    case OCM_PARENTNOTIFY:
#endif //!UNDER_CE
    case OCM_DRAWITEM:
    case OCM_MEASUREITEM:
    case OCM_COMPAREITEM:
    case OCM_DELETEITEM:
    case OCM_VKEYTOITEM:
    case OCM_CHARTOITEM:
    case OCM_HSCROLL:
    case OCM_VSCROLL:
    case OCM_CTLCOLORBTN:
    case OCM_CTLCOLORDLG:
    case OCM_CTLCOLOREDIT:
    case OCM_CTLCOLORLISTBOX:
    case OCM_CTLCOLORMSGBOX:
    case OCM_CTLCOLORSCROLLBAR:
    case OCM_CTLCOLORSTATIC:
        lResult = ::DefWindowProc(hWnd, uMsg - OCM__BASE, wParam, lParam);
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

template <class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowImplBaseT : public CWindowImplRoot< TBase >
{
public:
    WNDPROC m_pfnSuperWindowProc;

    CWindowImplBaseT() : m_pfnSuperWindowProc(::DefWindowProc)
    {}

    static DWORD GetWndStyle(DWORD dwStyle)
    {
        return TWinTraits::GetWndStyle(dwStyle);
    }
    static DWORD GetWndExStyle(DWORD dwExStyle)
    {
        return TWinTraits::GetWndExStyle(dwExStyle);
    }

    virtual WNDPROC GetWindowProc()
    {
        return WindowProc;
    }
    static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
            DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom, LPVOID lpCreateParam = NULL);
    BOOL DestroyWindow()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::DestroyWindow(m_hWnd);
    }
    BOOL SubclassWindow(HWND hWnd);
    HWND UnsubclassWindow(BOOL bForce = FALSE);

    LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
#ifdef STRICT
        return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
        return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
    }

    virtual void OnFinalMessage(HWND /*hWnd*/)
    {
        // override to do something, if needed
    }
};

typedef CWindowImplBaseT<CWindow>   CWindowImplBase;

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)_Module.ExtractCreateWndData();
    ATLASSERT(pThis != NULL);
    pThis->m_hWnd = hWnd;
    pThis->m_thunk.Init(pThis->GetWindowProc(), pThis);
    WNDPROC pProc = (WNDPROC)(pThis->m_thunk.thunk.pThunk);
    WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
    // check if somebody has subclassed us already since we discard it
    if(pOldProc != StartWindowProc)
        ATLTRACE(_T("ATL: Subclassing through a hook discarded.\n"));
#else
    pOldProc;   // avoid unused warning
#endif
    return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)hWnd;
    LRESULT lRes;
    if(pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0) == FALSE)
    {
#ifndef UNDER_CE
        if(uMsg != WM_NCDESTROY)
#else // CE specific
        if(uMsg != WM_DESTROY)
#endif //!UNDER_CE
            lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
        else
        {
            // unsubclass, if needed
            LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
            lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
            if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
                ::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
            // clear out window handle
            HWND hWnd = pThis->m_hWnd;
            pThis->m_hWnd = NULL;
            // clean up after window is destroyed
            pThis->OnFinalMessage(hWnd);
        }
    }
    return lRes;
}

template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
        DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom, LPVOID lpCreateParam)
{
    static LONG s_nNextChildID = 1;

    ATLASSERT(m_hWnd == NULL);

    if(atom == 0)
        return NULL;

    _Module.AddCreateWndData(&m_thunk.cd, this);

    if(nID == 0 && (dwStyle & WS_CHILD))
    {
#ifdef _WIN64
        nID = InterlockedIncrement( &s_nNextChildID );
        nID |= 0x80000000;
#else
        nID = (UINT)this;
#endif
    }

    HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)MAKELONG(atom, 0), szWindowName,
        dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
        rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID,
        _Module.GetModuleInstance(), lpCreateParam);

    ATLASSERT(m_hWnd == hWnd);

    return hWnd;
}

template <class TBase, class TWinTraits>
BOOL CWindowImplBaseT< TBase, TWinTraits >::SubclassWindow(HWND hWnd)
{
    ATLASSERT(m_hWnd == NULL);
    ATLASSERT(::IsWindow(hWnd));
    m_thunk.Init(GetWindowProc(), this);
    WNDPROC pProc = (WNDPROC)(m_thunk.thunk.pThunk);
    WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
    if(pfnWndProc == NULL)
        return FALSE;
    m_pfnSuperWindowProc = pfnWndProc;
    m_hWnd = hWnd;
    return TRUE;
}

// Use only if you want to subclass before window is destroyed,
// WindowProc will automatically subclass when  window goes away
template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::UnsubclassWindow(BOOL bForce /*= FALSE*/)
{
    ATLASSERT(m_hWnd != NULL);

    WNDPROC pOurProc = (WNDPROC)(m_thunk.thunk.pThunk);
    WNDPROC pActiveProc = (WNDPROC)::GetWindowLongPtr(m_hWnd, GWLP_WNDPROC);

    HWND hWnd = NULL;
    if (bForce || pOurProc == pActiveProc)
    {
        if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
            return NULL;

        m_pfnSuperWindowProc = ::DefWindowProc;
        hWnd = m_hWnd;
        m_hWnd = NULL;
    }
    return hWnd;
}

template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowImpl : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
    DECLARE_WND_CLASS(NULL)

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        if (T::GetWndClassInfo().m_lpszOrigName == NULL)
            T::GetWndClassInfo().m_lpszOrigName = GetWndClassName();
        ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

        dwStyle = T::GetWndStyle(dwStyle);
        dwExStyle = T::GetWndExStyle(dwExStyle);

        return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rcPos, szWindowName,
            dwStyle, dwExStyle, nID, atom, lpCreateParam);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CDialogImpl - Implements a dialog box

template <class TBase = CWindow>
class ATL_NO_VTABLE CDialogImplBaseT : public CWindowImplRoot< TBase >
{
public:
    virtual DLGPROC GetDialogProc()
    {
        return DialogProc;
    }
    static INT_PTR CALLBACK StartDialogProc(HWND hWnd, UINT uMsg,
        WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL MapDialogRect(LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::MapDialogRect(m_hWnd, lpRect);
    }
    virtual void OnFinalMessage(HWND /*hWnd*/)
    {
        // override to do something, if needed
    }
    // has no meaning for a dialog, but needed for handlers that use it
    LRESULT DefWindowProc()
    {
        return 0;
    }
};

template <class TBase>
INT_PTR CALLBACK CDialogImplBaseT< TBase >::StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)_Module.ExtractCreateWndData();
    ATLASSERT(pThis != NULL);
    pThis->m_hWnd = hWnd;
    pThis->m_thunk.Init((WNDPROC)pThis->GetDialogProc(), pThis);
    WNDPROC pProc = (WNDPROC)(pThis->m_thunk.thunk.pThunk);
    WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
    // check if somebody has subclassed us already since we discard it
    if(pOldProc != StartDialogProc)
        ATLTRACE(_T("ATL: Subclassing through a hook discarded.\n"));
#endif
    return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase>
INT_PTR CALLBACK CDialogImplBaseT< TBase >::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)hWnd;
    LRESULT lRes;
    if(pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0))
    {
        switch (uMsg)
        {
        case WM_COMPAREITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_INITDIALOG:
        case WM_QUERYDRAGICON:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
            return lRes;
            break;
        }
        ::SetWindowLongPtr(pThis->m_hWnd, DWLP_MSGRESULT, lRes);
        return TRUE;
    }
#ifndef UNDER_CE
    if(uMsg == WM_NCDESTROY)
#else // CE specific
    if(uMsg == WM_DESTROY)
#endif //!UNDER_CE
    {
        // clear out window handle
        HWND hWnd = pThis->m_hWnd;
        pThis->m_hWnd = NULL;
        // clean up after dialog is destroyed
        pThis->OnFinalMessage(hWnd);
    }
    return FALSE;
}

typedef CDialogImplBaseT<CWindow>   CDialogImplBase;

template <class T, class TBase = CWindow>
class ATL_NO_VTABLE CDialogImpl : public CDialogImplBaseT< TBase >
{
public:
#ifdef _DEBUG
    bool m_bModal;
    CDialogImpl() : m_bModal(false) { }
#endif //_DEBUG
    // modal dialogs
    INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
    {
        ATLASSERT(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
        m_bModal = true; // set to true for _DEBUG only
#endif // _DEBUG
        return ::DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
                    hWndParent, T::StartDialogProc, dwInitParam);
    }
    BOOL EndDialog(int nRetCode)
    {
        ATLASSERT(::IsWindow(m_hWnd));
#ifdef _DEBUG
        ATLASSERT(m_bModal);    // must be a modal dialog
#endif // _DEBUG
        return ::EndDialog(m_hWnd, nRetCode);
    }
    // modeless dialogs
    HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
    {
        ATLASSERT(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
        m_bModal = false; // set to false for _DEBUG only
#endif // _DEBUG
        HWND hWnd = ::CreateDialogParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
                    hWndParent, T::StartDialogProc, dwInitParam);
        ATLASSERT(m_hWnd == hWnd);
        return hWnd;
    }
    // for CComControl
    HWND Create(HWND hWndParent, RECT&, LPARAM dwInitParam = NULL)
    {
        return Create(hWndParent, dwInitParam);
    }
    BOOL DestroyWindow()
    {
        ATLASSERT(::IsWindow(m_hWnd));
#ifdef _DEBUG
        ATLASSERT(!m_bModal);   // must not be a modal dialog
#endif // _DEBUG
        return ::DestroyWindow(m_hWnd);
    }
};

}; //namespace ATL

#endif // __ATLWIN21_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlwin21.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN21_H__
	#error atlwin21.cpp requires atlwin21.h to be included first
#endif

#if (_ATL_VER < 0x0200) && (_ATL_VER >= 0x0300)
	#error atlwin21.cpp should be used only with ATL 2.0/2.1
#endif //(_ATL_VER < 0x0200) && (_ATL_VER >= 0x0300)

// Redefine class names and include old atlwin.cpp

#define CWindow		CWindowOld
#define _WndProcThunk	_WndProcThunkOld
#define CWndProcThunk	CWndProcThunkOld
#define CWindowImplBase	CWindowImplBaseOld
#define CWindowImpl	CWindowImplOld
#define CDialogImplBase	CDialogImplBaseOld
#define CDialogImpl	CDialogImplOld

#include <atlwin.cpp>

#undef CWindow
#undef _WndProcThunk
#undef CWndProcThunk
#undef CWindowImplBase
#undef CWindowImpl
#undef CDialogImplBase
#undef CDialogImpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\build_.h ===
// ATL Julian date build numbers (YDDD)

#define _ATL_BUILD 7024
#define _ATL_USER_BUILD "7024"
#define _ATL_PRODUCT_VERSION 5,0,0,0 
#define _ATL_FILE_VERSION 2,00 
#define _ATL_USER_PRODVER "5.00.0000" 
#define _ATL_USER_FILEVER "2.00."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlconv.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCONV_H__
#define __ATLCONV_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atldef.h>

#ifndef _INC_MALLOC
#include <malloc.h>
#endif // _INC_MALLOC

#pragma pack(push,8)

namespace ATL
{
namespace _ATL_SAFE_ALLOCA_IMPL
{
// Following code is to avoid alloca causing a stack overflow.
// It is intended for use from the _ATL_SAFE_ALLOCA macros 
// or Conversion macros.
__declspec(selectany) DWORD _Atlosplatform = 0;
inline BOOL _AtlGetVersionEx()
{
        OSVERSIONINFO osi;
        memset(&osi, 0, sizeof(OSVERSIONINFO));
        osi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&osi);
        _Atlosplatform = osi.dwPlatformId;
        return TRUE;
}

// From VC7 CRT sources.
#define _ATL_MIN_STACK_REQ_WIN9X 0x11000
#define _ATL_MIN_STACK_REQ_WINNT 0x2000

/***
* void _resetstkoflw(void) - Recovers from Stack Overflow
*
* Purpose:
*       Sets the guard page to its position before the stack overflow.
*
* Exit:
*       Returns nonzero on success, zero on failure
*
*******************************************************************************/

inline int _Atlresetstkoflw(void)
{
        static BOOL bTemp = _AtlGetVersionEx();
        
    LPBYTE pStack, pGuard, pStackBase, pMaxGuard, pMinGuard;
    MEMORY_BASIC_INFORMATION mbi;
    SYSTEM_INFO si;
    DWORD PageSize;
    DWORD flNewProtect;
    DWORD flOldProtect;

    // Use _alloca() to get the current stack pointer

    pStack = (LPBYTE)_alloca(1);

    // Find the base of the stack.

    if (VirtualQuery(pStack, &mbi, sizeof mbi) == 0)
        return 0;
    pStackBase = (LPBYTE)mbi.AllocationBase;

    // Find the page just below where the stack pointer currently points.
    // This is the highest potential guard page.

    GetSystemInfo(&si);
    PageSize = si.dwPageSize;

    pMaxGuard = (LPBYTE) (((DWORD_PTR)pStack & ~(DWORD_PTR)(PageSize - 1))
                       - PageSize);

    // If the potential guard page is too close to the start of the stack
    // region, abandon the reset effort for lack of space.  Win9x has a
    // larger reserved stack requirement.

    pMinGuard = pStackBase + ((_Atlosplatform == VER_PLATFORM_WIN32_WINDOWS)
                              ? _ATL_MIN_STACK_REQ_WIN9X
                              : _ATL_MIN_STACK_REQ_WINNT);

    if (pMaxGuard < pMinGuard)
        return 0;

    // On a non-Win9x system, do nothing if a guard page is already present,
    // else set up the guard page to the bottom of the committed range.
    // For Win9x, just set guard page below the current stack page.

    if (_Atlosplatform != VER_PLATFORM_WIN32_WINDOWS) {

        // Find first block of committed memory in the stack region

        pGuard = pStackBase;
        do {
            if (VirtualQuery(pGuard, &mbi, sizeof mbi) == 0)
                return 0;
            pGuard = pGuard + mbi.RegionSize;
        } while ((mbi.State & MEM_COMMIT) == 0);
        pGuard = (LPBYTE)mbi.BaseAddress;

        // If first committed block is already marked as a guard page,
        // there is nothing that needs to be done, so return success.

        if (mbi.Protect & PAGE_GUARD)
            return 1;

        // Fail if the first committed block is above the highest potential
        // guard page.  Should never happen.

        if (pMaxGuard < pGuard)
            return 0;

                // Make sure to leave enough room so the next overflow will have
        // the proper reserved stack requirement available.

        if (pGuard < pMinGuard)
            pGuard = pMinGuard;

        VirtualAlloc(pGuard, PageSize, MEM_COMMIT, PAGE_READWRITE);
    }
    else {
        pGuard = pMaxGuard;
    }

    // Enable the new guard page.

    flNewProtect = _Atlosplatform == VER_PLATFORM_WIN32_WINDOWS
                   ? PAGE_NOACCESS
                   : PAGE_READWRITE | PAGE_GUARD;

    return VirtualProtect(pGuard, PageSize, flNewProtect, &flOldProtect);
}

#ifndef _ATL_STACK_MARGIN
#define        _ATL_STACK_MARGIN        0x2000 // Minimum stack space available after allocaiton with _ATL_SAFE_ALLOCA
#endif

// Verifies if sufficient space is available on the stack.
inline bool _AtlVerifyStackAvailable(SIZE_T Size)
{
    bool bStackAvailable = true;

    __try
    {
        PVOID p = _alloca(Size + _ATL_STACK_MARGIN);
        p;
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH)
    {
        bStackAvailable = false;
        _Atlresetstkoflw();
    }
    return bStackAvailable;
}

// Helper Classes to manage heap buffers for _ATL_SAFE_ALLOCA

// Default allocator used by ATL
class _CCRTAllocator
{
public :
        static void * Allocate(SIZE_T nRequestedSize)
        {
                return malloc(nRequestedSize);
        }
        static void Free(void* p)
        {
                free(p);
        }
};

template < class Allocator>
class CAtlSafeAllocBufferManager
{
private :
        struct CAtlSafeAllocBufferNode
        {
                CAtlSafeAllocBufferNode* m_pNext;
#ifdef _WIN64
                BYTE _pad[8];
#else
                BYTE _pad[4];
#endif
                void* GetData()
                {
                        return (this + 1);
                }
        };

        CAtlSafeAllocBufferNode* m_pHead;
public :
        
        CAtlSafeAllocBufferManager() : m_pHead(NULL) {};
        void* Allocate(SIZE_T nRequestedSize)
        {
                CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));
                if (p == NULL)
                        return NULL;
                
                // Add buffer to the list
                p->m_pNext = m_pHead;
                m_pHead = p;
                
                return p->GetData();
        }
        ~CAtlSafeAllocBufferManager()
        {
                // Walk the list and free the buffers
                while (m_pHead != NULL)
                {
                        CAtlSafeAllocBufferNode* p = m_pHead;
                        m_pHead = m_pHead->m_pNext;
                        Allocator::Free(p);
                }
        }
};

// Use one of the following macros before using _ATL_SAFE_ALLOCA
// EX version allows specifying a different heap allocator
#define USES_ATL_SAFE_ALLOCA_EX(x)        ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<x> _AtlSafeAllocaManager

#ifndef USES_ATL_SAFE_ALLOCA
#define USES_ATL_SAFE_ALLOCA                USES_ATL_SAFE_ALLOCA_EX(ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator)
#endif

// nRequestedSize - requested size in bytes 
// nThreshold - size in bytes beyond which memory is allocated from the heap.

// Defining _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE always allocates the size specified
// for threshold if the stack space is available irrespective of requested size.
// This available for testing purposes. It will help determine the max stack usage due to _alloca's

#ifdef _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE
#define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)        \
        (((nRequestedSize) <= (nThreshold) && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold) ) ?        \
                _alloca(nThreshold) :        \
                ((ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold)) ? _alloca(nThreshold) : 0),        \
                        _AtlSafeAllocaManager.Allocate(nRequestedSize))
#else
#define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)        \
        (((nRequestedSize) <= (nThreshold) && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nRequestedSize) ) ?        \
                _alloca(nRequestedSize) :        \
                _AtlSafeAllocaManager.Allocate(nRequestedSize))
#endif

// Use 1024 bytes as the default threshold in ATL
#ifndef _ATL_SAFE_ALLOCA_DEF_THRESHOLD
#define _ATL_SAFE_ALLOCA_DEF_THRESHOLD        1024
#endif

}        // namespace _ATL_SAFE_ALLOCA_IMPL

}        // namespace ATL

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #ifndef _DEBUG
                #define USES_CONVERSION int _convert; _convert; UINT _acp = GetACP(); _acp; LPCWSTR _lpw; _lpw; LPCSTR _lpa; _lpa
        #else
                #define USES_CONVERSION int _convert = 0; _convert; UINT _acp = GetACP(); _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa
        #endif
#else
        #ifndef _DEBUG
                #define USES_CONVERSION int _convert; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw; _lpw; LPCSTR _lpa; _lpa
        #else
                #define USES_CONVERSION int _convert = 0; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa
        #endif
#endif

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #ifndef _DEBUG
                #define USES_CONVERSION_EX int _convert_ex; _convert_ex; UINT _acp_ex = GetACP(); _acp_ex; LPCWSTR _lpw_ex; _lpw_ex; LPCSTR _lpa_ex; _lpa_ex; USES_ATL_SAFE_ALLOCA
        #else
                #define USES_CONVERSION_EX int _convert_ex = 0; _convert_ex; UINT _acp_ex = GetACP(); _acp_ex; LPCWSTR _lpw_ex = NULL; _lpw_ex; LPCSTR _lpa_ex = NULL; _lpa_ex; USES_ATL_SAFE_ALLOCA
        #endif
#else
        #ifndef _DEBUG
                #define USES_CONVERSION_EX int _convert_ex; _convert_ex; UINT _acp_ex = CP_ACP; _acp_ex; LPCWSTR _lpw_ex; _lpw_ex; LPCSTR _lpa_ex; _lpa_ex; USES_ATL_SAFE_ALLOCA
        #else
                #define USES_CONVERSION_EX int _convert_ex = 0; _convert_ex; UINT _acp_ex = CP_ACP; _acp_ex; LPCWSTR _lpw_ex = NULL; _lpw_ex; LPCSTR _lpa_ex = NULL; _lpa_ex; USES_ATL_SAFE_ALLOCA
        #endif
#endif


#ifdef _WINGDI_
        ATLAPI_(LPDEVMODEA) AtlDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW);
#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
        ATLASSERT(lpa != NULL);
        ATLASSERT(lpw != NULL);
        if (lpw == NULL || lpa == NULL)
                return NULL;
        // verify that no illegal character present
        // since lpw was allocated based on the size of lpa
        // don't worry about the number of chars
        lpw[0] = '\0';
        int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
        if(ret == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }                
        return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
        ATLASSERT(lpw != NULL);
        ATLASSERT(lpa != NULL);
        if (lpa == NULL || lpw == NULL)
                return NULL;
        // verify that no illegal character present
        // since lpa was allocated based on the size of lpw
        // don't worry about the number of chars
        lpa[0] = '\0';
        int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
        if(ret == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
        return lpa;
}
inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
        return AtlA2WHelper(lpw, lpa, nChars, CP_ACP);
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
        return AtlW2AHelper(lpa, lpw, nChars, CP_ACP);
}

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #ifdef ATLA2WHELPER
                #undef ATLA2WHELPER
                #undef ATLW2AHELPER
        #endif
        #define ATLA2WHELPER AtlA2WHelper
        #define ATLW2AHELPER AtlW2AHelper
#else
        #ifndef ATLA2WHELPER
                #define ATLA2WHELPER AtlA2WHelper
                #define ATLW2AHELPER AtlW2AHelper
        #endif
#endif

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #define A2W(lpa) (\
                ((_lpa = lpa) == NULL) ? NULL : (\
                        _convert = (lstrlenA(_lpa)+1),\
                        ATLA2WHELPER((LPWSTR)alloca(_convert*2), _lpa, _convert, _acp)))
#else
        #define A2W(lpa) (\
                ((_lpa = lpa) == NULL) ? NULL : (\
                        _convert = (lstrlenA(_lpa)+1),\
                        ATLA2WHELPER((LPWSTR)alloca(_convert*2), _lpa, _convert)))
#endif

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #define W2A(lpw) (\
                ((_lpw = lpw) == NULL) ? NULL : (\
                        _convert = (lstrlenW(_lpw)+1)*2,\
                        ATLW2AHELPER((LPSTR)alloca(_convert) , _lpw, _convert, _acp)))
#else
        #define W2A(lpw) (\
                ((_lpw = lpw) == NULL) ? NULL : (\
                        _convert = (lstrlenW(_lpw)+1)*2,\
                        ATLW2AHELPER((LPSTR)alloca(_convert), _lpw, _convert)))
#endif

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

// The call to _alloca will not cause stack overflow if _AtlVerifyStackAvailable returns TRUE.
#ifdef _CONVERSION_USES_THREAD_LOCALE
        #define A2W_EX(lpa, nThreshold) (\
                ((_lpa_ex = lpa) == NULL) ? NULL : (\
                        _convert_ex = (lstrlenA(_lpa_ex)+1),\
                        ATLA2WHELPER(        \
                                (LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex * sizeof(WCHAR), nThreshold), \
                                _lpa_ex, \
                                _convert_ex, \
                                _acp_ex)))
#else
        #define A2W_EX(lpa, nThreshold) (\
                ((_lpa_ex = lpa) == NULL) ? NULL : (\
                        _convert_ex = (lstrlenA(_lpa_ex)+1),\
                        ATLA2WHELPER(        \
                                (LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex * sizeof(WCHAR), nThreshold), \
                                _lpa_ex, \
                                _convert_ex)))
#endif

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #define W2A_EX(lpw, nThreshold) (\
                ((_lpw_ex = lpw) == NULL) ? NULL : (\
                        _convert_ex = (lstrlenW(_lpw_ex)+1) * sizeof(WCHAR),\
                        ATLW2AHELPER(        \
                                (LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, nThreshold), \
                                _lpw_ex, \
                                _convert_ex, \
                                _acp_ex)))
#else
        #define W2A_EX(lpw, nThreshold) (\
                ((_lpw_ex = lpw) == NULL) ? NULL : (\
                        _convert_ex = (lstrlenW(_lpw_ex)+1) * sizeof(WCHAR),\
                        ATLW2AHELPER(        \
                                (LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, nThreshold), \
                                _lpw_ex, \
                                _convert_ex)))
#endif

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW_EX(lpa, nChar) ((LPCWSTR)A2W_EX(lpa, nChar))
#define W2CA_EX(lpw, nChar) ((LPCSTR)W2A_EX(lpw, nChar))

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline int ocslen(LPCOLESTR x) { return lstrlenW(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpyW(dest, src); }
        inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) { return lstrcatW(dest, src); }
        
        inline LPCOLESTR T2COLE_EX(LPCTSTR lp, UINT) { return lp; }
        inline LPCTSTR OLE2CT_EX(LPCOLESTR lp, UINT) { return lp; }
        inline LPOLESTR T2OLE_EX(LPTSTR lp, UINT) { return lp; }
        inline LPTSTR OLE2T_EX(LPOLESTR lp, UINT) { return lp; }        

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
        inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
        inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
        inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }        

#endif         // _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNextW(lp);}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline int ocslen(LPCOLESTR x) { return lstrlen(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpy(dest, src); }
        inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) { return ocscpy(dest+ocslen(dest), src); }

        inline LPCOLESTR T2COLE_EX(LPCTSTR lp, UINT) { return lp; }
        inline LPCTSTR OLE2CT_EX(LPCOLESTR lp, UINT) { return lp; }
        inline LPOLESTR T2OLE_EX(LPTSTR lp, UINT) { return lp; }
        inline LPTSTR OLE2T_EX(LPOLESTR lp, UINT) { return lp; }
        
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
        inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
        inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
        inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY
        
        inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNext(lp);}
#else
        inline int ocslen(LPCOLESTR x) { return lstrlenW(x); }
        //lstrcpyW doesn't work on Win95, so we do this
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src)
        {return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));}
        inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) { return ocscpy(dest+ocslen(dest), src); }
        //CharNextW doesn't work on Win95 so we use this
        
        #define T2COLE_EX(lpa, nChar) A2CW_EX(lpa, nChar)
        #define T2OLE_EX(lpa, nChar) A2W_EX(lpa, nChar)
        #define OLE2CT_EX(lpo, nChar) W2CA_EX(lpo, nChar)
        #define OLE2T_EX(lpo, nChar) W2A_EX(lpo, nChar)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        #define T2COLE(lpa) A2CW(lpa)
        #define T2OLE(lpa) A2W(lpa)
        #define OLE2CT(lpo) W2CA(lpo)
        #define OLE2T(lpo) W2A(lpo)

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPOLESTR CharNextO(LPCOLESTR lp) {return (LPOLESTR) ((*lp) ? (lp+1) : lp);}
#endif

#ifdef OLE2ANSI
        inline LPOLESTR A2OLE_EX(LPSTR lp, UINT) { return lp;}
        inline LPSTR OLE2A_EX(LPOLESTR lp, UINT) { return lp;}
        #define W2OLE_EX W2A_EX
        #define OLE2W_EX A2W_EX
        inline LPCOLESTR A2COLE_EX(LPCSTR lp, UINT) { return lp;}
        inline LPCSTR OLE2CA_EX(LPCOLESTR lp, UINT) { return lp;}
        #define W2COLE_EX W2CA_EX
        #define OLE2CW_EX A2CW_EX

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPOLESTR A2OLE(LPSTR lp) { return lp;}
        inline LPSTR OLE2A(LPOLESTR lp) { return lp;}
        #define W2OLE W2A
        #define OLE2W A2W
        inline LPCOLESTR A2COLE(LPCSTR lp) { return lp;}
        inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp;}
        #define W2COLE W2CA
        #define OLE2CW A2CW
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#else
        inline LPOLESTR W2OLE_EX(LPWSTR lp, UINT) { return lp; }
        inline LPWSTR OLE2W_EX(LPOLESTR lp, UINT) { return lp; }
        #define A2OLE_EX A2W_EX
        #define OLE2A_EX W2A_EX
        inline LPCOLESTR W2COLE_EX(LPCWSTR lp, UINT) { return lp; }
        inline LPCWSTR OLE2CW_EX(LPCOLESTR lp, UINT) { return lp; }
        #define A2COLE_EX A2CW_EX
        #define OLE2CA_EX W2CA_EX

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
        inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
        #define A2OLE A2W
        #define OLE2A W2A
        inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
        inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
        #define A2COLE A2CW
        #define OLE2CA W2CA
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

#ifdef _UNICODE
        #define T2A_EX W2A_EX
        #define A2T_EX A2W_EX
        inline LPWSTR T2W_EX(LPTSTR lp, UINT) { return lp; }
        inline LPTSTR W2T_EX(LPWSTR lp, UINT) { return lp; }
        #define T2CA_EX W2CA_EX
        #define A2CT_EX A2CW_EX
        inline LPCWSTR T2CW_EX(LPCTSTR lp, UINT) { return lp; }
        inline LPCTSTR W2CT_EX(LPCWSTR lp, UINT) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        #define T2A W2A
        #define A2T A2W
        inline LPWSTR T2W(LPTSTR lp) { return lp; }
        inline LPTSTR W2T(LPWSTR lp) { return lp; }
        #define T2CA W2CA
        #define A2CT A2CW
        inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
        inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#else
        #define T2W_EX A2W_EX
        #define W2T_EX W2A_EX
        inline LPSTR T2A_EX(LPTSTR lp, UINT) { return lp; }
        inline LPTSTR A2T_EX(LPSTR lp, UINT) { return lp; }
        #define T2CW_EX A2CW_EX
        #define W2CT_EX W2CA_EX
        inline LPCSTR T2CA_EX(LPCTSTR lp, UINT) { return lp; }
        inline LPCTSTR A2CT_EX(LPCSTR lp, UINT) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        #define T2W A2W
        #define W2T W2A
        inline LPSTR T2A(LPTSTR lp) { return lp; }
        inline LPTSTR A2T(LPSTR lp) { return lp; }
        #define T2CW A2CW
        #define W2CT W2CA
        inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
        inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

inline BSTR A2WBSTR(LPCSTR lp, int nLen = -1)
{
        if (lp == NULL || nLen == 0)
                return NULL;
        USES_CONVERSION_EX;
        BSTR str = NULL;
        int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp,
                nLen, NULL, NULL);
        int nAllocLen = nConvertedLen;
        if (nLen == -1)
                nAllocLen -= 1;  // Don't allocate terminating '\0'
        str = ::SysAllocStringLen(NULL, nAllocLen);
        if (str != NULL)
        {
                int nResult;
                nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);
                ATLASSERT(nResult == nConvertedLen);
                if(nResult != nConvertedLen)
                {
                        SysFreeString(str);
                        return NULL;
                }
        }
        return str;
}

inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline BSTR T2BSTR_EX(LPCTSTR lp) {return ::SysAllocString(lp);}
        inline BSTR A2BSTR_EX(LPCSTR lp) {return A2WBSTR(lp);}
        inline BSTR W2BSTR_EX(LPCWSTR lp) {return ::SysAllocString(lp);}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
        inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
        inline BSTR W2BSTR(LPCWSTR lp) {return W2BSTR_EX(lp); }

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline BSTR T2BSTR_EX(LPCTSTR lp) {return ::SysAllocString(lp);}
        inline BSTR A2BSTR_EX(LPCSTR lp) {return ::SysAllocString(lp);}
        inline BSTR W2BSTR_EX(LPCWSTR lp) {USES_CONVERSION_EX; return ::SysAllocString(W2COLE_EX(lp));}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
        inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
        inline BSTR W2BSTR(LPCWSTR lp) {USES_CONVERSION; return ::SysAllocString(W2COLE(lp));}
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#else
        inline BSTR T2BSTR_EX(LPCTSTR lp) {return A2WBSTR(lp);}
        inline BSTR A2BSTR_EX(LPCSTR lp) {return A2WBSTR(lp);}
        inline BSTR W2BSTR_EX(LPCWSTR lp) {return ::SysAllocString(lp);}
        
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
        inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
        inline BSTR W2BSTR(LPCWSTR lp) {return W2BSTR_EX(lp); }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

#ifdef _WINGDI_
/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPDEVMODEW AtlDevModeA2W(LPDEVMODEW lpDevModeW, LPDEVMODEA lpDevModeA)
{
        USES_CONVERSION_EX;
        ATLASSERT(lpDevModeW != NULL);
        if (lpDevModeA == NULL || lpDevModeW == NULL)
                return NULL;
        AtlA2WHelper(lpDevModeW->dmDeviceName, (LPCSTR)lpDevModeA->dmDeviceName, 32, _acp_ex);
        memcpy(&lpDevModeW->dmSpecVersion, &lpDevModeA->dmSpecVersion,
                offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion));
        AtlA2WHelper(lpDevModeW->dmFormName, (LPCSTR)lpDevModeA->dmFormName, 32, _acp_ex);
        memcpy(&lpDevModeW->dmLogPixels, &lpDevModeA->dmLogPixels,
                sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels));
        if (lpDevModeA->dmDriverExtra != 0)
                memcpy(lpDevModeW+1, lpDevModeA+1, lpDevModeA->dmDriverExtra);
        lpDevModeW->dmSize = sizeof(DEVMODEW);
        return lpDevModeW;
}

inline LPTEXTMETRICW AtlTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA lptmA)
{
        USES_CONVERSION_EX;
        ATLASSERT(lptmW != NULL);
        if (lptmA == NULL || lptmW == NULL)
                return NULL;
        memcpy(lptmW, lptmA, sizeof(LONG) * 11);
        memcpy(&lptmW->tmItalic, &lptmA->tmItalic, sizeof(BYTE) * 5);

        if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmFirstChar, 1, &lptmW->tmFirstChar, 1) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
                
        if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmLastChar, 1, &lptmW->tmLastChar, 1) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
                
        if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmDefaultChar, 1, &lptmW->tmDefaultChar, 1)== 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
                
        if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmBreakChar, 1, &lptmW->tmBreakChar, 1) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
        
        return lptmW;
}

inline LPTEXTMETRICA AtlTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW lptmW)
{
        USES_CONVERSION_EX;
        ATLASSERT(lptmA != NULL);
        if (lptmW == NULL || lptmA == NULL)
                return NULL;
        memcpy(lptmA, lptmW, sizeof(LONG) * 11);
        memcpy(&lptmA->tmItalic, &lptmW->tmItalic, sizeof(BYTE) * 5);
        
        if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmFirstChar, 1, (LPSTR)&lptmA->tmFirstChar, 1, NULL, NULL) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }

        if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmLastChar, 1, (LPSTR)&lptmA->tmLastChar, 1, NULL, NULL) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }

        if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmDefaultChar, 1, (LPSTR)&lptmA->tmDefaultChar, 1, NULL, NULL) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }

        if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmBreakChar, 1, (LPSTR)&lptmA->tmBreakChar, 1, NULL, NULL) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }

        return lptmA;
}

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AtlDevModeA2W
#define ATLDEVMODEW2A AtlDevModeW2A
#define ATLTEXTMETRICA2W AtlTextMetricA2W
#define ATLTEXTMETRICW2A AtlTextMetricW2A
#endif

// Requires USES_CONVERSION_EX or USES_ATL_SAFE_ALLOCA macro before using the _EX versions of the macros
#define DEVMODEW2A_EX(lpw)\
        ((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)_ATL_SAFE_ALLOCA(sizeof(DEVMODEA)+lpw->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lpw))
#define DEVMODEA2W_EX(lpa)\
        ((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)_ATL_SAFE_ALLOCA(sizeof(DEVMODEW)+lpa->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lpa))
#define TEXTMETRICW2A_EX(lptmw)\
        ((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICA), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lptmw))
#define TEXTMETRICA2W_EX(lptma)\
        ((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICW), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lptma))

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define DEVMODEW2A(lpw)\
        ((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)alloca(sizeof(DEVMODEA)+lpw->dmDriverExtra), lpw))
#define DEVMODEA2W(lpa)\
        ((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)alloca(sizeof(DEVMODEW)+lpa->dmDriverExtra), lpa))
#define TEXTMETRICW2A(lptmw)\
        ((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)alloca(sizeof(TEXTMETRICA)), lptmw))
#define TEXTMETRICA2W(lptma)\
        ((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)alloca(sizeof(TEXTMETRICW)), lptma))
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef OLE2ANSI
        #define DEVMODEOLE DEVMODEA
        #define LPDEVMODEOLE LPDEVMODEA
        #define TEXTMETRICOLE TEXTMETRICA
        #define LPTEXTMETRICOLE LPTEXTMETRICA
#else
        #define DEVMODEOLE DEVMODEW
        #define LPDEVMODEOLE LPDEVMODEW
        #define TEXTMETRICOLE TEXTMETRICW
        #define LPTEXTMETRICOLE LPTEXTMETRICW
#endif

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline LPDEVMODEW DEVMODEOLE2T_EX(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE_EX(LPDEVMODEW lp) { return lp; }
        inline LPTEXTMETRICW TEXTMETRICOLE2T_EX(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE_EX(LPTEXTMETRICW lp) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; }
        inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY
        
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline LPDEVMODE DEVMODEOLE2T_EX(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE_EX(LPDEVMODE lp) { return lp; }
        inline LPTEXTMETRIC TEXTMETRICOLE2T_EX(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE_EX(LPTEXTMETRIC lp) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPDEVMODE DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODE lp) { return lp; }
        inline LPTEXTMETRIC TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRIC lp) { return lp; }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#else
        #define DEVMODEOLE2T_EX(lpo) DEVMODEW2A_EX(lpo)
        #define DEVMODET2OLE_EX(lpa) DEVMODEA2W_EX(lpa)
        #define TEXTMETRICOLE2T_EX(lptmw) TEXTMETRICW2A_EX(lptmw)
        #define TEXTMETRICT2OLE_EX(lptma) TEXTMETRICA2W_EX(lptma)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        #define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
        #define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
        #define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
        #define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

#endif //_WINGDI_

#pragma pack(pop)

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLCONV_IMPL
#endif
#endif

#endif // __ATLCONV_H__

/////////////////////////////////////////////////////////////////////////////

#ifdef _ATLCONV_IMPL

#ifdef _WINGDI_

ATLINLINE ATLAPI_(LPDEVMODEA) AtlDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW)
{
        USES_CONVERSION_EX;
        ATLASSERT(lpDevModeA != NULL);
        if (lpDevModeW == NULL || lpDevModeA == NULL)
                return NULL;
        AtlW2AHelper((LPSTR)lpDevModeA->dmDeviceName, lpDevModeW->dmDeviceName, 32, _acp_ex);
        memcpy(&lpDevModeA->dmSpecVersion, &lpDevModeW->dmSpecVersion,
                offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
        AtlW2AHelper((LPSTR)lpDevModeA->dmFormName, lpDevModeW->dmFormName, 32, _acp_ex);
        memcpy(&lpDevModeA->dmLogPixels, &lpDevModeW->dmLogPixels,
                sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
        if (lpDevModeW->dmDriverExtra != 0)
                memcpy(lpDevModeA+1, lpDevModeW+1, lpDevModeW->dmDriverExtra);
        lpDevModeA->dmSize = sizeof(DEVMODEA);
        return lpDevModeA;
}

#endif //_WINGDI

//Prevent pulling in second time
#undef _ATLCONV_IMPL

#endif // _ATLCONV_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4268) // const static/global data initialized to zeros
#pragma warning(disable: 4291) // allow placement new
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <atldef.h>

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <comcat.h>
#include <stddef.h>

#ifdef new
#pragma push_macro("new")
#define _ATL_REDEF_NEW
#undef new
#endif

#include <tchar.h>
#include <malloc.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
        #include <crtdbg.h>
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#include <atlconv.h>

#include <shlwapi.h>

#define _ATL_TYPELIB_INDEX_LENGTH 10
#define _ATL_QUOTES_SPACE 2

#pragma pack(push, _ATL_PACKING)

#if defined(_ATL_DLL)
        #pragma comment(lib, "atl.lib")
#endif

extern "C" const __declspec(selectany) GUID LIBID_ATLLib = {0x44EC0535,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindow = {0xb6ea2050,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatch = {0xb6ea2051,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IInternalConnection = {0x72AD0770,0x6A9F,0x11d1,{0xBC,0xEC,0x00,0x60,0x08,0x8F,0x44,0x4E}};
extern "C" const __declspec(selectany) IID IID_IDocHostUIHandlerDispatch = {0x425B5AF0,0x65F1,0x11d1,{0x96,0x11,0x00,0x00,0xF8,0x1E,0x0D,0x0D}};

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD_PTR dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(DWORD_PTR dw);

struct _ATL_TERMFUNC_ELEM
{
        _ATL_TERMFUNC* pFunc;
        DWORD_PTR dw;
        _ATL_TERMFUNC_ELEM* pNext;
};

struct _ATL_OBJMAP_ENTRY
{
        const CLSID* pclsid;
        HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
        _ATL_CREATORFUNC* pfnGetClassObject;
        _ATL_CREATORFUNC* pfnCreateInstance;
        IUnknown* pCF;
        DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
        _ATL_CATMAPFUNC* pfnGetCategoryMap;
        HRESULT WINAPI RevokeClassObject()
        {
                return CoRevokeClassObject(dwRegister);
        }
        HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
        {
                IUnknown* p = NULL;
                if (pfnGetClassObject == NULL)
                        return S_OK;
                HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
                if (SUCCEEDED(hRes))
                        hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
                if (p != NULL)
                        p->Release();
                return hRes;
        }
// Added in ATL 3.0
        void (WINAPI *pfnObjectMain)(bool bStarting);
};

struct _ATL_REGMAP_ENTRY
{
        LPCOLESTR     szKey;
        LPCOLESTR     szData;
};

struct _AtlCreateWndData
{
        void* m_pThis;
        DWORD m_dwThreadID;
        _AtlCreateWndData* m_pNext;
};

struct _ATL_MODULE_21
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        union
        {
                CRITICAL_SECTION m_csTypeInfoHolder;
                CRITICAL_SECTION m_csStaticDataInit;
        };
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
};

struct _ATL_MODULE_30
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        union
        {
                CRITICAL_SECTION m_csTypeInfoHolder;
                CRITICAL_SECTION m_csStaticDataInit;
        };
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
        DWORD dwAtlBuildVer;
        _AtlCreateWndData* m_pCreateWndList;
        bool m_bDestroyHeap;
        GUID* pguidVer;
        DWORD m_dwHeaps;    // Number of heaps we have (-1)
        HANDLE* m_phHeaps;
        int m_nHeap;        // Which heap to choose from
        _ATL_TERMFUNC_ELEM* m_pTermFuncs;
};

#if _ATL_VER == 0x0300
typedef _ATL_MODULE_30 _ATL_MODULE;
#else
struct _ATL_MODULE
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        union
        {
                CRITICAL_SECTION m_csTypeInfoHolder;
                CRITICAL_SECTION m_csStaticDataInit;
        };
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
        DWORD dwAtlBuildVer;
        _AtlCreateWndData* m_pCreateWndList;
        bool m_bDestroyHeap;
        GUID* pguidVer;
        DWORD m_dwHeaps;    // Number of heaps we have (-1)
        HANDLE* m_phHeaps;
        int m_nHeap;        // Which heap to choose from
        _ATL_TERMFUNC_ELEM* m_pTermFuncs;
// Stuff added in ATL 6.1
        LONG m_nNextWindowID;
};
#endif

const int _nAtlModuleVer21Size = sizeof( _ATL_MODULE_21 );
const int _nAtlModuleVer30Size = sizeof( _ATL_MODULE_30 );

//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
        const IID* piid;       // the interface id (IID)
        DWORD_PTR dw;
        _ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// Thunks for __stdcall member functions


#if defined(_M_IX86)
#pragma pack(push,1)
struct _stdcallthunk
{
        DWORD   m_mov;          // mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)
        DWORD   m_this;         //
        BYTE    m_jmp;          // jmp WndProc
        DWORD   m_relproc;      // relative jmp
        void Init(DWORD_PTR proc, void* pThis)
        {
                m_mov = 0x042444C7;  //C7 44 24 0C
                m_this = PtrToUlong(pThis);
                m_jmp = 0xe9;
                m_relproc = DWORD((INT_PTR)proc - ((INT_PTR)this+sizeof(_stdcallthunk)));
                // write block from data cache and
                //  flush from instruction cache
                FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
        }
};
#pragma pack(pop)
#elif defined (_M_AMD64)
#pragma pack(push,2)
struct _stdcallthunk
{
    USHORT  RcxMov;         // mov rcx, pThis
    ULONG64 RcxImm;         // 
    USHORT  RaxMov;         // mov rax, target
    ULONG64 RaxImm;         //
    USHORT  RaxJmp;         // jmp target
    void Init(DWORD_PTR proc, void *pThis)
    {
        RcxMov = 0xb948;          // mov rcx, pThis
        RcxImm = (ULONG64)pThis;  // 
        RaxMov = 0xb848;          // mov rax, target
        RaxImm = (ULONG64)proc;   //
        RaxJmp = 0xe0ff;          // jmp rax
        FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
    }
};
#pragma pack(pop)
#elif defined(_M_IA64)
#pragma pack(push,8)
extern "C" LRESULT CALLBACK _WndProcThunkProc( HWND, UINT, WPARAM, LPARAM );
struct _FuncDesc
{
        void* pfn;
        void* gp;
};
struct _stdcallthunk
{
        _FuncDesc m_funcdesc;
        void* m_pFunc;
        void* m_pThis;
        void Init(DWORD_PTR proc, void* pThis)
        {
                const _FuncDesc* pThunkProc;

                pThunkProc = reinterpret_cast< const _FuncDesc* >( _WndProcThunkProc );
                m_funcdesc.pfn = pThunkProc->pfn;
                m_funcdesc.gp = &m_pFunc;
                m_pFunc = reinterpret_cast< void* >( proc );
                m_pThis = pThis;
                ::FlushInstructionCache( GetCurrentProcess(), this, sizeof( _stdcallthunk ) );
        }
};
#pragma pack(pop)
#else
#error Only AMD64, IA64, and X86 supported
#endif

class CDynamicStdCallThunk
{
public:
        _stdcallthunk *pThunk;

        CDynamicStdCallThunk()
        {
                pThunk = NULL;
        }

        ~CDynamicStdCallThunk()
        {
                if (pThunk)
                        HeapFree(GetProcessHeap(), 0, pThunk);
        }

        void Init(DWORD_PTR proc, void *pThis)
        {
                if (!pThunk) {
                    pThunk = static_cast<_stdcallthunk *>(HeapAlloc(GetProcessHeap(), 
                            HEAP_GENERATE_EXCEPTIONS, sizeof(_stdcallthunk)));
                }
                ATLASSERT(pThunk);
                pThunk->Init(proc, pThis);
        }
};
typedef CDynamicStdCallThunk CStdCallThunk;

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
        const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

ATLAPI AtlFreeMarshalStream(IStream* pStream);
ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
        DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
        HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags);
ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM);
ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv);
ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes,
        BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL);
ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib);

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h);
ATLAPI AtlModuleTerm(_ATL_MODULE* pM);
ATLAPI_(DWORD) AtlGetVersion(void* pReserved);
ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject);
ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM);
ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD_PTR dw);

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Error to HRESULT helpers

inline HRESULT AtlHresultFromLastError()
{
        DWORD dwErr = ::GetLastError();
        return HRESULT_FROM_WIN32(dwErr);
}

inline HRESULT AtlHresultFromWin32(DWORD nError)
{
        return( HRESULT_FROM_WIN32( nError ) );
}

inline void __declspec(noreturn) _AtlRaiseException( DWORD dwExceptionCode, DWORD dwExceptionFlags = EXCEPTION_NONCONTINUABLE )
{
        RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );
}

enum atlTraceFlags
{
        // Application defined categories
        atlTraceUser        = 0x00000001,
        atlTraceUser2       = 0x00000002,
        atlTraceUser3       = 0x00000004,
        atlTraceUser4       = 0x00000008,
        // ATL defined categories
        atlTraceGeneral     = 0x00000020,
        atlTraceCOM         = 0x00000040,
        atlTraceQI      = 0x00000080,
        atlTraceRegistrar   = 0x00000100,
        atlTraceRefcount    = 0x00000200,
        atlTraceWindowing   = 0x00000400,
        atlTraceControls    = 0x00000800,
        atlTraceHosting     = 0x00001000,
        atlTraceDBClient    = 0x00002000,
        atlTraceDBProvider  = 0x00004000,
        atlTraceSnapin      = 0x00008000,
        atlTraceNotImpl     = 0x00010000,
};

#ifndef ATL_TRACE_CATEGORY
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#endif

#ifdef _DEBUG

#ifndef ATL_TRACE_LEVEL
#define ATL_TRACE_LEVEL 0
#endif

inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        char szBuffer[512];

        nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
        ATLASSERT(nBuf != -1 && nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)
        
        if(nBuf == -1 || nBuf >= sizeof(szBuffer))
        {
                char szContinued[] = "...";
                
                lstrcpyA(szBuffer + sizeof(szBuffer) - sizeof(szContinued), szContinued);
        }                
        
        OutputDebugStringA(szBuffer);
                
        va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
        if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
        {
                va_list args;
                va_start(args, lpszFormat);

                int nBuf;
                char szBuffer[512];

                nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
                ATLASSERT(nBuf != -1 && nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

                if(nBuf == -1 || nBuf >= sizeof(szBuffer))
                {
                        char szContinued[] = "...";
                        
                        lstrcpyA(szBuffer + sizeof(szBuffer) - sizeof(szContinued), szContinued);
                }                

                OutputDebugStringA("ATL: ");
                OutputDebugStringA(szBuffer);
                va_end(args);
        }
}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        WCHAR szBuffer[512];

        nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
        ATLASSERT(nBuf != -1 && nBuf < sizeof(szBuffer)/sizeof(WCHAR));//Output truncated as it was > sizeof(szBuffer)/sizeof(WCHAR)

        if(nBuf == -1 || nBuf >= sizeof(szBuffer)/sizeof(WCHAR))
        {
                WCHAR szContinued[] = L"...";
                
                ocscpy(szBuffer + sizeof(szBuffer)/sizeof(WCHAR) - sizeof(szContinued)/sizeof(WCHAR), szContinued);
        }                

        OutputDebugStringW(szBuffer);
        va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
        if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
        {
                va_list args;
                va_start(args, lpszFormat);

                int nBuf;
                WCHAR szBuffer[512];

                nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
                ATLASSERT(nBuf != -1 && nBuf < sizeof(szBuffer)/sizeof(WCHAR));//Output truncated as it was > sizeof(szBuffer)/sizeof(WCHAR)

                if(nBuf == -1 || nBuf >= sizeof(szBuffer)/sizeof(WCHAR))
                {
                        WCHAR szContinued[] = L"...";
                        
                        ocscpy(szBuffer + sizeof(szBuffer)/sizeof(WCHAR) - sizeof(szContinued)/sizeof(WCHAR), szContinued);
                }                

                OutputDebugStringW(L"ATL: ");
                OutputDebugStringW(szBuffer);
                va_end(args);
        }
}
#endif //!OLE2ANSI


#ifndef ATLTRACE
#define ATLTRACE            AtlTrace
#define ATLTRACE2           AtlTrace2
#endif
#define ATLTRACENOTIMPL(funcname)   ATLTRACE2(atlTraceNotImpl, 2, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl AtlTrace(LPCSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef ATLTRACE
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACE2           1 ? (void)0 : AtlTrace2
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

// Validation macro for OUT pointer
// Used in QI and CreateInstance
#define _ATL_VALIDATE_OUT_POINTER(x)        ATLASSERT(x != NULL);        \
        if (x == NULL)        \
                return E_POINTER;        \
        *x = NULL

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#ifndef _WIN64
#pragma comment(lib, "olepro32.lib")
#endif
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")

static HRESULT AtlSetChildSite(IUnknown* punkChild, IUnknown* punkParent)
{
        if (punkChild == NULL)
                return E_POINTER;

        HRESULT hr;
        IObjectWithSite* pChildSite = NULL;
        hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&pChildSite);
        if (SUCCEEDED(hr) && pChildSite != NULL)
        {
                hr = pChildSite->SetSite(punkParent);
                pChildSite->Release();
        }
        return hr;
}

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
        private:
                STDMETHOD_(ULONG, AddRef)()=0;
                STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
        typedef T _PtrClass;
        CComPtr()
        {
                p=NULL;
        }
        CComPtr(T* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComPtr(const CComPtr<T>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        ~CComPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator T*() const
        {
                return (T*)p;
        }
        T& operator*() const
        {
                ATLASSERT(p!=NULL);
                return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        T** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        T* operator=(T* lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
        }
        T* operator=(const CComPtr<T>& lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(T* pT) const
        {
                return p < pT;
        }
        bool operator==(T* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        void Attach(T* p2)
        {
                if (p)
                        p->Release();
                p = p2;
        }
        T* Detach()
        {
                T* pt = p;
                p = NULL;
                return pt;
        }
        HRESULT CopyTo(T** ppT)
        {
                ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp) const
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
        T* p;
};


template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
        typedef T _PtrClass;
        CComQIPtr()
        {
                p=NULL;
        }
        CComQIPtr(T* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComQIPtr(const CComQIPtr<T,piid>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        CComQIPtr(IUnknown* lp)
        {
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(*piid, (void **)&p);
        }
        ~CComQIPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator T*() const
        {
                return p;
        }
        T& operator*() const
        {
                ATLASSERT(p!=NULL); return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        T** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        T* operator=(T* lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
        }
        T* operator=(const CComQIPtr<T,piid>& lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        T* operator=(IUnknown* lp)
        {
                return (T*)AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(T* pT) const
        {
                return p < pT;
        }
        bool operator==(T* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        void Attach(T* p2)
        {
                if (p)
                        p->Release();
                p = p2;
        }
        T* Detach()
        {
                T* pt = p;
                p = NULL;
                return pt;
        }
        HRESULT CopyTo(T** ppT)
        {
                ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp)
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
        T* p;
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown>
{
public:
        typedef IUnknown _PtrClass;
        CComQIPtr()
        {
                p=NULL;
        }
        CComQIPtr(IUnknown* lp)
        {
                //Actually do a QI to get identity
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(IID_IUnknown, (void **)&p);
        }
        CComQIPtr(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        ~CComQIPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator IUnknown*() const
        {
                return p;
        }
        IUnknown& operator*() const
        {
                ATLASSERT(p!=NULL);
                return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        IUnknown** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<IUnknown>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<IUnknown>*)p;
        }
        IUnknown* operator=(IUnknown* lp)
        {
                //Actually do a QI to get identity
                return (IUnknown*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IUnknown);
        }
        IUnknown* operator=(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
        {
                return (IUnknown*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(IUnknown* pT) const
        {
                return p < pT;
        }
        bool operator==(IUnknown* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        IUnknown* Detach()
        {
                IUnknown* pt = p;
                p = NULL;
                return pt;
        }
        HRESULT CopyTo(IUnknown** ppT)
        {
                ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp)
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
        IUnknown* p;
};

#define com_cast CComQIPtr

/////////////////////////////////////////////////////////////
// Class to Adapt CComBSTR and CComPtr for use with STL containers
// the syntax to use it is
// std::vector< CAdapt <CComBSTR> > vect;

template <class T>
class CAdapt
{
public:
        CAdapt()
        {
        }
        CAdapt(const T& rSrc)
        {
                m_T = rSrc;
        }

        CAdapt(const CAdapt& rSrCA)
        {
                m_T = rSrCA.m_T;
        }

        CAdapt& operator=(const T& rSrc)
        {
                m_T = rSrc;
                return *this;
        }
        bool operator<(const T& rSrc) const
        {
                return m_T < rSrc;
        }
        bool operator==(const T& rSrc) const
        {
                return m_T == rSrc;
        }
        operator T&()
        {
                return m_T;
        }

        operator const T&() const
        {
                return m_T;
        }

        T m_T;
};

/////////////////////////////////////////////////////////////////////////////
// GUID comparison

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
          ((PLONG) &rguid1)[0] == 0 &&
          ((PLONG) &rguid1)[1] == 0 &&
#ifdef _ATL_BYTESWAP
          ((PLONG) &rguid1)[2] == 0xC0000000 &&
          ((PLONG) &rguid1)[3] == 0x00000046);
#else
          ((PLONG) &rguid1)[2] == 0x000000C0 &&
          ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
        void Lock() {EnterCriticalSection(&m_sec);}
        void Unlock() {LeaveCriticalSection(&m_sec);}
        void Init() {InitializeCriticalSection(&m_sec);}
        void Term() {DeleteCriticalSection(&m_sec);}
        CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
        void Lock() {EnterCriticalSection(&m_sec);}
        void Unlock() {LeaveCriticalSection(&m_sec);}
        CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
        ~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
        CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
        void Lock() {}
        void Unlock() {}
        void Init() {}
        void Term() {}
};

class CComMultiThreadModelNoCS
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
        static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
        typedef CComFakeCriticalSection AutoCriticalSection;
        typedef CComFakeCriticalSection CriticalSection;
        typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
        static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
        typedef CComAutoCriticalSection AutoCriticalSection;
        typedef CComCriticalSection CriticalSection;
        typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
        static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
        typedef CComFakeCriticalSection AutoCriticalSection;
        typedef CComFakeCriticalSection CriticalSection;
        typedef CComSingleThreadModel ThreadModelNoCS;
};

#if defined(_ATL_SINGLE_THREADED)
        typedef CComSingleThreadModel CComObjectThreadModel;
        typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
        typedef CComSingleThreadModel CComObjectThreadModel;
        typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
        typedef CComMultiThreadModel CComObjectThreadModel;
        typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);

#ifdef _ATL_DEBUG_INTERFACES
struct _QIThunk
{
        STDMETHOD(QueryInterface)(REFIID iid, void** pp)
        {
                ATLASSERT(m_dwRef >= 0);
                return pUnk->QueryInterface(iid, pp);
        }
        STDMETHOD_(ULONG, AddRef)()
        {
                if (bBreak)
                        DebugBreak();
                pUnk->AddRef();
                return InternalAddRef();
        }
        ULONG InternalAddRef()
        {
                if (bBreak)
                        DebugBreak();
                ATLASSERT(m_dwRef >= 0);
                long l = InterlockedIncrement(&m_dwRef);
                ATLTRACE(_T("%d> "), m_dwRef);
                AtlDumpIID(iid, lpszClassName, S_OK);
                if (l > m_dwMaxRef)
                        m_dwMaxRef = l;
                return l;
        }
        STDMETHOD_(ULONG, Release)();

        STDMETHOD(f3)();
        STDMETHOD(f4)();
        STDMETHOD(f5)();
        STDMETHOD(f6)();
        STDMETHOD(f7)();
        STDMETHOD(f8)();
        STDMETHOD(f9)();
        STDMETHOD(f10)();
        STDMETHOD(f11)();
        STDMETHOD(f12)();
        STDMETHOD(f13)();
        STDMETHOD(f14)();
        STDMETHOD(f15)();
        STDMETHOD(f16)();
        STDMETHOD(f17)();
        STDMETHOD(f18)();
        STDMETHOD(f19)();
        STDMETHOD(f20)();
        STDMETHOD(f21)();
        STDMETHOD(f22)();
        STDMETHOD(f23)();
        STDMETHOD(f24)();
        STDMETHOD(f25)();
        STDMETHOD(f26)();
        STDMETHOD(f27)();
        STDMETHOD(f28)();
        STDMETHOD(f29)();
        STDMETHOD(f30)();
        STDMETHOD(f31)();
        STDMETHOD(f32)();
        STDMETHOD(f33)();
        STDMETHOD(f34)();
        STDMETHOD(f35)();
        STDMETHOD(f36)();
        STDMETHOD(f37)();
        STDMETHOD(f38)();
        STDMETHOD(f39)();
        STDMETHOD(f40)();
        STDMETHOD(f41)();
        STDMETHOD(f42)();
        STDMETHOD(f43)();
        STDMETHOD(f44)();
        STDMETHOD(f45)();
        STDMETHOD(f46)();
        STDMETHOD(f47)();
        STDMETHOD(f48)();
        STDMETHOD(f49)();
        STDMETHOD(f50)();
        STDMETHOD(f51)();
        STDMETHOD(f52)();
        STDMETHOD(f53)();
        STDMETHOD(f54)();
        STDMETHOD(f55)();
        STDMETHOD(f56)();
        STDMETHOD(f57)();
        STDMETHOD(f58)();
        STDMETHOD(f59)();
        STDMETHOD(f60)();
        STDMETHOD(f61)();
        STDMETHOD(f62)();
        STDMETHOD(f63)();
        STDMETHOD(f64)();
        STDMETHOD(f65)();
        STDMETHOD(f66)();
        STDMETHOD(f67)();
        STDMETHOD(f68)();
        STDMETHOD(f69)();
        STDMETHOD(f70)();
        STDMETHOD(f71)();
        STDMETHOD(f72)();
        STDMETHOD(f73)();
        STDMETHOD(f74)();
        STDMETHOD(f75)();
        STDMETHOD(f76)();
        STDMETHOD(f77)();
        STDMETHOD(f78)();
        STDMETHOD(f79)();
        STDMETHOD(f80)();
        STDMETHOD(f81)();
        STDMETHOD(f82)();
        STDMETHOD(f83)();
        STDMETHOD(f84)();
        STDMETHOD(f85)();
        STDMETHOD(f86)();
        STDMETHOD(f87)();
        STDMETHOD(f88)();
        STDMETHOD(f89)();
        STDMETHOD(f90)();
        STDMETHOD(f91)();
        STDMETHOD(f92)();
        STDMETHOD(f93)();
        STDMETHOD(f94)();
        STDMETHOD(f95)();
        STDMETHOD(f96)();
        STDMETHOD(f97)();
        STDMETHOD(f98)();
        STDMETHOD(f99)();
        STDMETHOD(f100)();
        STDMETHOD(f101)();
        STDMETHOD(f102)();
        STDMETHOD(f103)();
        STDMETHOD(f104)();
        STDMETHOD(f105)();
        STDMETHOD(f106)();
        STDMETHOD(f107)();
        STDMETHOD(f108)();
        STDMETHOD(f109)();
        STDMETHOD(f110)();
        STDMETHOD(f111)();
        STDMETHOD(f112)();
        STDMETHOD(f113)();
        STDMETHOD(f114)();
        STDMETHOD(f115)();
        STDMETHOD(f116)();
        STDMETHOD(f117)();
        STDMETHOD(f118)();
        STDMETHOD(f119)();
        STDMETHOD(f120)();
        STDMETHOD(f121)();
        STDMETHOD(f122)();
        STDMETHOD(f123)();
        STDMETHOD(f124)();
        STDMETHOD(f125)();
        STDMETHOD(f126)();
        STDMETHOD(f127)();
        STDMETHOD(f128)();
        STDMETHOD(f129)();
        STDMETHOD(f130)();
        STDMETHOD(f131)();
        STDMETHOD(f132)();
        STDMETHOD(f133)();
        STDMETHOD(f134)();
        STDMETHOD(f135)();
        STDMETHOD(f136)();
        STDMETHOD(f137)();
        STDMETHOD(f138)();
        STDMETHOD(f139)();
        STDMETHOD(f140)();
        STDMETHOD(f141)();
        STDMETHOD(f142)();
        STDMETHOD(f143)();
        STDMETHOD(f144)();
        STDMETHOD(f145)();
        STDMETHOD(f146)();
        STDMETHOD(f147)();
        STDMETHOD(f148)();
        STDMETHOD(f149)();
        STDMETHOD(f150)();
        STDMETHOD(f151)();
        STDMETHOD(f152)();
        STDMETHOD(f153)();
        STDMETHOD(f154)();
        STDMETHOD(f155)();
        STDMETHOD(f156)();
        STDMETHOD(f157)();
        STDMETHOD(f158)();
        STDMETHOD(f159)();
        STDMETHOD(f160)();
        STDMETHOD(f161)();
        STDMETHOD(f162)();
        STDMETHOD(f163)();
        STDMETHOD(f164)();
        STDMETHOD(f165)();
        STDMETHOD(f166)();
        STDMETHOD(f167)();
        STDMETHOD(f168)();
        STDMETHOD(f169)();
        STDMETHOD(f170)();
        STDMETHOD(f171)();
        STDMETHOD(f172)();
        STDMETHOD(f173)();
        STDMETHOD(f174)();
        STDMETHOD(f175)();
        STDMETHOD(f176)();
        STDMETHOD(f177)();
        STDMETHOD(f178)();
        STDMETHOD(f179)();
        STDMETHOD(f180)();
        STDMETHOD(f181)();
        STDMETHOD(f182)();
        STDMETHOD(f183)();
        STDMETHOD(f184)();
        STDMETHOD(f185)();
        STDMETHOD(f186)();
        STDMETHOD(f187)();
        STDMETHOD(f188)();
        STDMETHOD(f189)();
        STDMETHOD(f190)();
        STDMETHOD(f191)();
        STDMETHOD(f192)();
        STDMETHOD(f193)();
        STDMETHOD(f194)();
        STDMETHOD(f195)();
        STDMETHOD(f196)();
        STDMETHOD(f197)();
        STDMETHOD(f198)();
        STDMETHOD(f199)();
        STDMETHOD(f200)();
        STDMETHOD(f201)();
        STDMETHOD(f202)();
        STDMETHOD(f203)();
        STDMETHOD(f204)();
        STDMETHOD(f205)();
        STDMETHOD(f206)();
        STDMETHOD(f207)();
        STDMETHOD(f208)();
        STDMETHOD(f209)();
        STDMETHOD(f210)();
        STDMETHOD(f211)();
        STDMETHOD(f212)();
        STDMETHOD(f213)();
        STDMETHOD(f214)();
        STDMETHOD(f215)();
        STDMETHOD(f216)();
        STDMETHOD(f217)();
        STDMETHOD(f218)();
        STDMETHOD(f219)();
        STDMETHOD(f220)();
        STDMETHOD(f221)();
        STDMETHOD(f222)();
        STDMETHOD(f223)();
        STDMETHOD(f224)();
        STDMETHOD(f225)();
        STDMETHOD(f226)();
        STDMETHOD(f227)();
        STDMETHOD(f228)();
        STDMETHOD(f229)();
        STDMETHOD(f230)();
        STDMETHOD(f231)();
        STDMETHOD(f232)();
        STDMETHOD(f233)();
        STDMETHOD(f234)();
        STDMETHOD(f235)();
        STDMETHOD(f236)();
        STDMETHOD(f237)();
        STDMETHOD(f238)();
        STDMETHOD(f239)();
        STDMETHOD(f240)();
        STDMETHOD(f241)();
        STDMETHOD(f242)();
        STDMETHOD(f243)();
        STDMETHOD(f244)();
        STDMETHOD(f245)();
        STDMETHOD(f246)();
        STDMETHOD(f247)();
        STDMETHOD(f248)();
        STDMETHOD(f249)();
        STDMETHOD(f250)();
        STDMETHOD(f251)();
        STDMETHOD(f252)();
        STDMETHOD(f253)();
        STDMETHOD(f254)();
        STDMETHOD(f255)();
        STDMETHOD(f256)();
        STDMETHOD(f257)();
        STDMETHOD(f258)();
        STDMETHOD(f259)();
        STDMETHOD(f260)();
        STDMETHOD(f261)();
        STDMETHOD(f262)();
        STDMETHOD(f263)();
        STDMETHOD(f264)();
        STDMETHOD(f265)();
        STDMETHOD(f266)();
        STDMETHOD(f267)();
        STDMETHOD(f268)();
        STDMETHOD(f269)();
        STDMETHOD(f270)();
        STDMETHOD(f271)();
        STDMETHOD(f272)();
        STDMETHOD(f273)();
        STDMETHOD(f274)();
        STDMETHOD(f275)();
        STDMETHOD(f276)();
        STDMETHOD(f277)();
        STDMETHOD(f278)();
        STDMETHOD(f279)();
        STDMETHOD(f280)();
        STDMETHOD(f281)();
        STDMETHOD(f282)();
        STDMETHOD(f283)();
        STDMETHOD(f284)();
        STDMETHOD(f285)();
        STDMETHOD(f286)();
        STDMETHOD(f287)();
        STDMETHOD(f288)();
        STDMETHOD(f289)();
        STDMETHOD(f290)();
        STDMETHOD(f291)();
        STDMETHOD(f292)();
        STDMETHOD(f293)();
        STDMETHOD(f294)();
        STDMETHOD(f295)();
        STDMETHOD(f296)();
        STDMETHOD(f297)();
        STDMETHOD(f298)();
        STDMETHOD(f299)();
        STDMETHOD(f300)();
        STDMETHOD(f301)();
        STDMETHOD(f302)();
        STDMETHOD(f303)();
        STDMETHOD(f304)();
        STDMETHOD(f305)();
        STDMETHOD(f306)();
        STDMETHOD(f307)();
        STDMETHOD(f308)();
        STDMETHOD(f309)();
        STDMETHOD(f310)();
        STDMETHOD(f311)();
        STDMETHOD(f312)();
        STDMETHOD(f313)();
        STDMETHOD(f314)();
        STDMETHOD(f315)();
        STDMETHOD(f316)();
        STDMETHOD(f317)();
        STDMETHOD(f318)();
        STDMETHOD(f319)();
        STDMETHOD(f320)();
        STDMETHOD(f321)();
        STDMETHOD(f322)();
        STDMETHOD(f323)();
        STDMETHOD(f324)();
        STDMETHOD(f325)();
        STDMETHOD(f326)();
        STDMETHOD(f327)();
        STDMETHOD(f328)();
        STDMETHOD(f329)();
        STDMETHOD(f330)();
        STDMETHOD(f331)();
        STDMETHOD(f332)();
        STDMETHOD(f333)();
        STDMETHOD(f334)();
        STDMETHOD(f335)();
        STDMETHOD(f336)();
        STDMETHOD(f337)();
        STDMETHOD(f338)();
        STDMETHOD(f339)();
        STDMETHOD(f340)();
        STDMETHOD(f341)();
        STDMETHOD(f342)();
        STDMETHOD(f343)();
        STDMETHOD(f344)();
        STDMETHOD(f345)();
        STDMETHOD(f346)();
        STDMETHOD(f347)();
        STDMETHOD(f348)();
        STDMETHOD(f349)();
        STDMETHOD(f350)();
        STDMETHOD(f351)();
        STDMETHOD(f352)();
        STDMETHOD(f353)();
        STDMETHOD(f354)();
        STDMETHOD(f355)();
        STDMETHOD(f356)();
        STDMETHOD(f357)();
        STDMETHOD(f358)();
        STDMETHOD(f359)();
        STDMETHOD(f360)();
        STDMETHOD(f361)();
        STDMETHOD(f362)();
        STDMETHOD(f363)();
        STDMETHOD(f364)();
        STDMETHOD(f365)();
        STDMETHOD(f366)();
        STDMETHOD(f367)();
        STDMETHOD(f368)();
        STDMETHOD(f369)();
        STDMETHOD(f370)();
        STDMETHOD(f371)();
        STDMETHOD(f372)();
        STDMETHOD(f373)();
        STDMETHOD(f374)();
        STDMETHOD(f375)();
        STDMETHOD(f376)();
        STDMETHOD(f377)();
        STDMETHOD(f378)();
        STDMETHOD(f379)();
        STDMETHOD(f380)();
        STDMETHOD(f381)();
        STDMETHOD(f382)();
        STDMETHOD(f383)();
        STDMETHOD(f384)();
        STDMETHOD(f385)();
        STDMETHOD(f386)();
        STDMETHOD(f387)();
        STDMETHOD(f388)();
        STDMETHOD(f389)();
        STDMETHOD(f390)();
        STDMETHOD(f391)();
        STDMETHOD(f392)();
        STDMETHOD(f393)();
        STDMETHOD(f394)();
        STDMETHOD(f395)();
        STDMETHOD(f396)();
        STDMETHOD(f397)();
        STDMETHOD(f398)();
        STDMETHOD(f399)();
        STDMETHOD(f400)();
        STDMETHOD(f401)();
        STDMETHOD(f402)();
        STDMETHOD(f403)();
        STDMETHOD(f404)();
        STDMETHOD(f405)();
        STDMETHOD(f406)();
        STDMETHOD(f407)();
        STDMETHOD(f408)();
        STDMETHOD(f409)();
        STDMETHOD(f410)();
        STDMETHOD(f411)();
        STDMETHOD(f412)();
        STDMETHOD(f413)();
        STDMETHOD(f414)();
        STDMETHOD(f415)();
        STDMETHOD(f416)();
        STDMETHOD(f417)();
        STDMETHOD(f418)();
        STDMETHOD(f419)();
        STDMETHOD(f420)();
        STDMETHOD(f421)();
        STDMETHOD(f422)();
        STDMETHOD(f423)();
        STDMETHOD(f424)();
        STDMETHOD(f425)();
        STDMETHOD(f426)();
        STDMETHOD(f427)();
        STDMETHOD(f428)();
        STDMETHOD(f429)();
        STDMETHOD(f430)();
        STDMETHOD(f431)();
        STDMETHOD(f432)();
        STDMETHOD(f433)();
        STDMETHOD(f434)();
        STDMETHOD(f435)();
        STDMETHOD(f436)();
        STDMETHOD(f437)();
        STDMETHOD(f438)();
        STDMETHOD(f439)();
        STDMETHOD(f440)();
        STDMETHOD(f441)();
        STDMETHOD(f442)();
        STDMETHOD(f443)();
        STDMETHOD(f444)();
        STDMETHOD(f445)();
        STDMETHOD(f446)();
        STDMETHOD(f447)();
        STDMETHOD(f448)();
        STDMETHOD(f449)();
        STDMETHOD(f450)();
        STDMETHOD(f451)();
        STDMETHOD(f452)();
        STDMETHOD(f453)();
        STDMETHOD(f454)();
        STDMETHOD(f455)();
        STDMETHOD(f456)();
        STDMETHOD(f457)();
        STDMETHOD(f458)();
        STDMETHOD(f459)();
        STDMETHOD(f460)();
        STDMETHOD(f461)();
        STDMETHOD(f462)();
        STDMETHOD(f463)();
        STDMETHOD(f464)();
        STDMETHOD(f465)();
        STDMETHOD(f466)();
        STDMETHOD(f467)();
        STDMETHOD(f468)();
        STDMETHOD(f469)();
        STDMETHOD(f470)();
        STDMETHOD(f471)();
        STDMETHOD(f472)();
        STDMETHOD(f473)();
        STDMETHOD(f474)();
        STDMETHOD(f475)();
        STDMETHOD(f476)();
        STDMETHOD(f477)();
        STDMETHOD(f478)();
        STDMETHOD(f479)();
        STDMETHOD(f480)();
        STDMETHOD(f481)();
        STDMETHOD(f482)();
        STDMETHOD(f483)();
        STDMETHOD(f484)();
        STDMETHOD(f485)();
        STDMETHOD(f486)();
        STDMETHOD(f487)();
        STDMETHOD(f488)();
        STDMETHOD(f489)();
        STDMETHOD(f490)();
        STDMETHOD(f491)();
        STDMETHOD(f492)();
        STDMETHOD(f493)();
        STDMETHOD(f494)();
        STDMETHOD(f495)();
        STDMETHOD(f496)();
        STDMETHOD(f497)();
        STDMETHOD(f498)();
        STDMETHOD(f499)();
        STDMETHOD(f500)();
        STDMETHOD(f501)();
        STDMETHOD(f502)();
        STDMETHOD(f503)();
        STDMETHOD(f504)();
        STDMETHOD(f505)();
        STDMETHOD(f506)();
        STDMETHOD(f507)();
        STDMETHOD(f508)();
        STDMETHOD(f509)();
        STDMETHOD(f510)();
        STDMETHOD(f511)();
        STDMETHOD(f512)();
        STDMETHOD(f513)();
        STDMETHOD(f514)();
        STDMETHOD(f515)();
        STDMETHOD(f516)();
        STDMETHOD(f517)();
        STDMETHOD(f518)();
        STDMETHOD(f519)();
        STDMETHOD(f520)();
        STDMETHOD(f521)();
        STDMETHOD(f522)();
        STDMETHOD(f523)();
        STDMETHOD(f524)();
        STDMETHOD(f525)();
        STDMETHOD(f526)();
        STDMETHOD(f527)();
        STDMETHOD(f528)();
        STDMETHOD(f529)();
        STDMETHOD(f530)();
        STDMETHOD(f531)();
        STDMETHOD(f532)();
        STDMETHOD(f533)();
        STDMETHOD(f534)();
        STDMETHOD(f535)();
        STDMETHOD(f536)();
        STDMETHOD(f537)();
        STDMETHOD(f538)();
        STDMETHOD(f539)();
        STDMETHOD(f540)();
        STDMETHOD(f541)();
        STDMETHOD(f542)();
        STDMETHOD(f543)();
        STDMETHOD(f544)();
        STDMETHOD(f545)();
        STDMETHOD(f546)();
        STDMETHOD(f547)();
        STDMETHOD(f548)();
        STDMETHOD(f549)();
        STDMETHOD(f550)();
        STDMETHOD(f551)();
        STDMETHOD(f552)();
        STDMETHOD(f553)();
        STDMETHOD(f554)();
        STDMETHOD(f555)();
        STDMETHOD(f556)();
        STDMETHOD(f557)();
        STDMETHOD(f558)();
        STDMETHOD(f559)();
        STDMETHOD(f560)();
        STDMETHOD(f561)();
        STDMETHOD(f562)();
        STDMETHOD(f563)();
        STDMETHOD(f564)();
        STDMETHOD(f565)();
        STDMETHOD(f566)();
        STDMETHOD(f567)();
        STDMETHOD(f568)();
        STDMETHOD(f569)();
        STDMETHOD(f570)();
        STDMETHOD(f571)();
        STDMETHOD(f572)();
        STDMETHOD(f573)();
        STDMETHOD(f574)();
        STDMETHOD(f575)();
        STDMETHOD(f576)();
        STDMETHOD(f577)();
        STDMETHOD(f578)();
        STDMETHOD(f579)();
        STDMETHOD(f580)();
        STDMETHOD(f581)();
        STDMETHOD(f582)();
        STDMETHOD(f583)();
        STDMETHOD(f584)();
        STDMETHOD(f585)();
        STDMETHOD(f586)();
        STDMETHOD(f587)();
        STDMETHOD(f588)();
        STDMETHOD(f589)();
        STDMETHOD(f590)();
        STDMETHOD(f591)();
        STDMETHOD(f592)();
        STDMETHOD(f593)();
        STDMETHOD(f594)();
        STDMETHOD(f595)();
        STDMETHOD(f596)();
        STDMETHOD(f597)();
        STDMETHOD(f598)();
        STDMETHOD(f599)();
        STDMETHOD(f600)();
        STDMETHOD(f601)();
        STDMETHOD(f602)();
        STDMETHOD(f603)();
        STDMETHOD(f604)();
        STDMETHOD(f605)();
        STDMETHOD(f606)();
        STDMETHOD(f607)();
        STDMETHOD(f608)();
        STDMETHOD(f609)();
        STDMETHOD(f610)();
        STDMETHOD(f611)();
        STDMETHOD(f612)();
        STDMETHOD(f613)();
        STDMETHOD(f614)();
        STDMETHOD(f615)();
        STDMETHOD(f616)();
        STDMETHOD(f617)();
        STDMETHOD(f618)();
        STDMETHOD(f619)();
        STDMETHOD(f620)();
        STDMETHOD(f621)();
        STDMETHOD(f622)();
        STDMETHOD(f623)();
        STDMETHOD(f624)();
        STDMETHOD(f625)();
        STDMETHOD(f626)();
        STDMETHOD(f627)();
        STDMETHOD(f628)();
        STDMETHOD(f629)();
        STDMETHOD(f630)();
        STDMETHOD(f631)();
        STDMETHOD(f632)();
        STDMETHOD(f633)();
        STDMETHOD(f634)();
        STDMETHOD(f635)();
        STDMETHOD(f636)();
        STDMETHOD(f637)();
        STDMETHOD(f638)();
        STDMETHOD(f639)();
        STDMETHOD(f640)();
        STDMETHOD(f641)();
        STDMETHOD(f642)();
        STDMETHOD(f643)();
        STDMETHOD(f644)();
        STDMETHOD(f645)();
        STDMETHOD(f646)();
        STDMETHOD(f647)();
        STDMETHOD(f648)();
        STDMETHOD(f649)();
        STDMETHOD(f650)();
        STDMETHOD(f651)();
        STDMETHOD(f652)();
        STDMETHOD(f653)();
        STDMETHOD(f654)();
        STDMETHOD(f655)();
        STDMETHOD(f656)();
        STDMETHOD(f657)();
        STDMETHOD(f658)();
        STDMETHOD(f659)();
        STDMETHOD(f660)();
        STDMETHOD(f661)();
        STDMETHOD(f662)();
        STDMETHOD(f663)();
        STDMETHOD(f664)();
        STDMETHOD(f665)();
        STDMETHOD(f666)();
        STDMETHOD(f667)();
        STDMETHOD(f668)();
        STDMETHOD(f669)();
        STDMETHOD(f670)();
        STDMETHOD(f671)();
        STDMETHOD(f672)();
        STDMETHOD(f673)();
        STDMETHOD(f674)();
        STDMETHOD(f675)();
        STDMETHOD(f676)();
        STDMETHOD(f677)();
        STDMETHOD(f678)();
        STDMETHOD(f679)();
        STDMETHOD(f680)();
        STDMETHOD(f681)();
        STDMETHOD(f682)();
        STDMETHOD(f683)();
        STDMETHOD(f684)();
        STDMETHOD(f685)();
        STDMETHOD(f686)();
        STDMETHOD(f687)();
        STDMETHOD(f688)();
        STDMETHOD(f689)();
        STDMETHOD(f690)();
        STDMETHOD(f691)();
        STDMETHOD(f692)();
        STDMETHOD(f693)();
        STDMETHOD(f694)();
        STDMETHOD(f695)();
        STDMETHOD(f696)();
        STDMETHOD(f697)();
        STDMETHOD(f698)();
        STDMETHOD(f699)();
        STDMETHOD(f700)();
        STDMETHOD(f701)();
        STDMETHOD(f702)();
        STDMETHOD(f703)();
        STDMETHOD(f704)();
        STDMETHOD(f705)();
        STDMETHOD(f706)();
        STDMETHOD(f707)();
        STDMETHOD(f708)();
        STDMETHOD(f709)();
        STDMETHOD(f710)();
        STDMETHOD(f711)();
        STDMETHOD(f712)();
        STDMETHOD(f713)();
        STDMETHOD(f714)();
        STDMETHOD(f715)();
        STDMETHOD(f716)();
        STDMETHOD(f717)();
        STDMETHOD(f718)();
        STDMETHOD(f719)();
        STDMETHOD(f720)();
        STDMETHOD(f721)();
        STDMETHOD(f722)();
        STDMETHOD(f723)();
        STDMETHOD(f724)();
        STDMETHOD(f725)();
        STDMETHOD(f726)();
        STDMETHOD(f727)();
        STDMETHOD(f728)();
        STDMETHOD(f729)();
        STDMETHOD(f730)();
        STDMETHOD(f731)();
        STDMETHOD(f732)();
        STDMETHOD(f733)();
        STDMETHOD(f734)();
        STDMETHOD(f735)();
        STDMETHOD(f736)();
        STDMETHOD(f737)();
        STDMETHOD(f738)();
        STDMETHOD(f739)();
        STDMETHOD(f740)();
        STDMETHOD(f741)();
        STDMETHOD(f742)();
        STDMETHOD(f743)();
        STDMETHOD(f744)();
        STDMETHOD(f745)();
        STDMETHOD(f746)();
        STDMETHOD(f747)();
        STDMETHOD(f748)();
        STDMETHOD(f749)();
        STDMETHOD(f750)();
        STDMETHOD(f751)();
        STDMETHOD(f752)();
        STDMETHOD(f753)();
        STDMETHOD(f754)();
        STDMETHOD(f755)();
        STDMETHOD(f756)();
        STDMETHOD(f757)();
        STDMETHOD(f758)();
        STDMETHOD(f759)();
        STDMETHOD(f760)();
        STDMETHOD(f761)();
        STDMETHOD(f762)();
        STDMETHOD(f763)();
        STDMETHOD(f764)();
        STDMETHOD(f765)();
        STDMETHOD(f766)();
        STDMETHOD(f767)();
        STDMETHOD(f768)();
        STDMETHOD(f769)();
        STDMETHOD(f770)();
        STDMETHOD(f771)();
        STDMETHOD(f772)();
        STDMETHOD(f773)();
        STDMETHOD(f774)();
        STDMETHOD(f775)();
        STDMETHOD(f776)();
        STDMETHOD(f777)();
        STDMETHOD(f778)();
        STDMETHOD(f779)();
        STDMETHOD(f780)();
        STDMETHOD(f781)();
        STDMETHOD(f782)();
        STDMETHOD(f783)();
        STDMETHOD(f784)();
        STDMETHOD(f785)();
        STDMETHOD(f786)();
        STDMETHOD(f787)();
        STDMETHOD(f788)();
        STDMETHOD(f789)();
        STDMETHOD(f790)();
        STDMETHOD(f791)();
        STDMETHOD(f792)();
        STDMETHOD(f793)();
        STDMETHOD(f794)();
        STDMETHOD(f795)();
        STDMETHOD(f796)();
        STDMETHOD(f797)();
        STDMETHOD(f798)();
        STDMETHOD(f799)();
        STDMETHOD(f800)();
        STDMETHOD(f801)();
        STDMETHOD(f802)();
        STDMETHOD(f803)();
        STDMETHOD(f804)();
        STDMETHOD(f805)();
        STDMETHOD(f806)();
        STDMETHOD(f807)();
        STDMETHOD(f808)();
        STDMETHOD(f809)();
        STDMETHOD(f810)();
        STDMETHOD(f811)();
        STDMETHOD(f812)();
        STDMETHOD(f813)();
        STDMETHOD(f814)();
        STDMETHOD(f815)();
        STDMETHOD(f816)();
        STDMETHOD(f817)();
        STDMETHOD(f818)();
        STDMETHOD(f819)();
        STDMETHOD(f820)();
        STDMETHOD(f821)();
        STDMETHOD(f822)();
        STDMETHOD(f823)();
        STDMETHOD(f824)();
        STDMETHOD(f825)();
        STDMETHOD(f826)();
        STDMETHOD(f827)();
        STDMETHOD(f828)();
        STDMETHOD(f829)();
        STDMETHOD(f830)();
        STDMETHOD(f831)();
        STDMETHOD(f832)();
        STDMETHOD(f833)();
        STDMETHOD(f834)();
        STDMETHOD(f835)();
        STDMETHOD(f836)();
        STDMETHOD(f837)();
        STDMETHOD(f838)();
        STDMETHOD(f839)();
        STDMETHOD(f840)();
        STDMETHOD(f841)();
        STDMETHOD(f842)();
        STDMETHOD(f843)();
        STDMETHOD(f844)();
        STDMETHOD(f845)();
        STDMETHOD(f846)();
        STDMETHOD(f847)();
        STDMETHOD(f848)();
        STDMETHOD(f849)();
        STDMETHOD(f850)();
        STDMETHOD(f851)();
        STDMETHOD(f852)();
        STDMETHOD(f853)();
        STDMETHOD(f854)();
        STDMETHOD(f855)();
        STDMETHOD(f856)();
        STDMETHOD(f857)();
        STDMETHOD(f858)();
        STDMETHOD(f859)();
        STDMETHOD(f860)();
        STDMETHOD(f861)();
        STDMETHOD(f862)();
        STDMETHOD(f863)();
        STDMETHOD(f864)();
        STDMETHOD(f865)();
        STDMETHOD(f866)();
        STDMETHOD(f867)();
        STDMETHOD(f868)();
        STDMETHOD(f869)();
        STDMETHOD(f870)();
        STDMETHOD(f871)();
        STDMETHOD(f872)();
        STDMETHOD(f873)();
        STDMETHOD(f874)();
        STDMETHOD(f875)();
        STDMETHOD(f876)();
        STDMETHOD(f877)();
        STDMETHOD(f878)();
        STDMETHOD(f879)();
        STDMETHOD(f880)();
        STDMETHOD(f881)();
        STDMETHOD(f882)();
        STDMETHOD(f883)();
        STDMETHOD(f884)();
        STDMETHOD(f885)();
        STDMETHOD(f886)();
        STDMETHOD(f887)();
        STDMETHOD(f888)();
        STDMETHOD(f889)();
        STDMETHOD(f890)();
        STDMETHOD(f891)();
        STDMETHOD(f892)();
        STDMETHOD(f893)();
        STDMETHOD(f894)();
        STDMETHOD(f895)();
        STDMETHOD(f896)();
        STDMETHOD(f897)();
        STDMETHOD(f898)();
        STDMETHOD(f899)();
        STDMETHOD(f900)();
        STDMETHOD(f901)();
        STDMETHOD(f902)();
        STDMETHOD(f903)();
        STDMETHOD(f904)();
        STDMETHOD(f905)();
        STDMETHOD(f906)();
        STDMETHOD(f907)();
        STDMETHOD(f908)();
        STDMETHOD(f909)();
        STDMETHOD(f910)();
        STDMETHOD(f911)();
        STDMETHOD(f912)();
        STDMETHOD(f913)();
        STDMETHOD(f914)();
        STDMETHOD(f915)();
        STDMETHOD(f916)();
        STDMETHOD(f917)();
        STDMETHOD(f918)();
        STDMETHOD(f919)();
        STDMETHOD(f920)();
        STDMETHOD(f921)();
        STDMETHOD(f922)();
        STDMETHOD(f923)();
        STDMETHOD(f924)();
        STDMETHOD(f925)();
        STDMETHOD(f926)();
        STDMETHOD(f927)();
        STDMETHOD(f928)();
        STDMETHOD(f929)();
        STDMETHOD(f930)();
        STDMETHOD(f931)();
        STDMETHOD(f932)();
        STDMETHOD(f933)();
        STDMETHOD(f934)();
        STDMETHOD(f935)();
        STDMETHOD(f936)();
        STDMETHOD(f937)();
        STDMETHOD(f938)();
        STDMETHOD(f939)();
        STDMETHOD(f940)();
        STDMETHOD(f941)();
        STDMETHOD(f942)();
        STDMETHOD(f943)();
        STDMETHOD(f944)();
        STDMETHOD(f945)();
        STDMETHOD(f946)();
        STDMETHOD(f947)();
        STDMETHOD(f948)();
        STDMETHOD(f949)();
        STDMETHOD(f950)();
        STDMETHOD(f951)();
        STDMETHOD(f952)();
        STDMETHOD(f953)();
        STDMETHOD(f954)();
        STDMETHOD(f955)();
        STDMETHOD(f956)();
        STDMETHOD(f957)();
        STDMETHOD(f958)();
        STDMETHOD(f959)();
        STDMETHOD(f960)();
        STDMETHOD(f961)();
        STDMETHOD(f962)();
        STDMETHOD(f963)();
        STDMETHOD(f964)();
        STDMETHOD(f965)();
        STDMETHOD(f966)();
        STDMETHOD(f967)();
        STDMETHOD(f968)();
        STDMETHOD(f969)();
        STDMETHOD(f970)();
        STDMETHOD(f971)();
        STDMETHOD(f972)();
        STDMETHOD(f973)();
        STDMETHOD(f974)();
        STDMETHOD(f975)();
        STDMETHOD(f976)();
        STDMETHOD(f977)();
        STDMETHOD(f978)();
        STDMETHOD(f979)();
        STDMETHOD(f980)();
        STDMETHOD(f981)();
        STDMETHOD(f982)();
        STDMETHOD(f983)();
        STDMETHOD(f984)();
        STDMETHOD(f985)();
        STDMETHOD(f986)();
        STDMETHOD(f987)();
        STDMETHOD(f988)();
        STDMETHOD(f989)();
        STDMETHOD(f990)();
        STDMETHOD(f991)();
        STDMETHOD(f992)();
        STDMETHOD(f993)();
        STDMETHOD(f994)();
        STDMETHOD(f995)();
        STDMETHOD(f996)();
        STDMETHOD(f997)();
        STDMETHOD(f998)();
        STDMETHOD(f999)();
        STDMETHOD(f1000)();
        STDMETHOD(f1001)();
        STDMETHOD(f1002)();
        STDMETHOD(f1003)();
        STDMETHOD(f1004)();
        STDMETHOD(f1005)();
        STDMETHOD(f1006)();
        STDMETHOD(f1007)();
        STDMETHOD(f1008)();
        STDMETHOD(f1009)();
        STDMETHOD(f1010)();
        STDMETHOD(f1011)();
        STDMETHOD(f1012)();
        STDMETHOD(f1013)();
        STDMETHOD(f1014)();
        STDMETHOD(f1015)();
        STDMETHOD(f1016)();
        STDMETHOD(f1017)();
        STDMETHOD(f1018)();
        STDMETHOD(f1019)();
        STDMETHOD(f1020)();
        STDMETHOD(f1021)();
        STDMETHOD(f1022)();
        STDMETHOD(f1023)();
#ifndef _WIN64
        STDMETHOD(f1024)();
#endif
        _QIThunk(IUnknown* pOrig, LPCTSTR p, const IID& i, UINT n, bool b)
        {
                lpszClassName = p;
                iid = i;
                nIndex = n;
                m_dwRef = 0;
                m_dwMaxRef = 0;
                pUnk = pOrig;
                bBreak = b;
                bNonAddRefThunk = false;
        }
        IUnknown* pUnk;
        long m_dwRef;
        long m_dwMaxRef;
        LPCTSTR lpszClassName;
        IID iid;
        UINT nIndex;
        bool bBreak;
        bool bNonAddRefThunk;
        void Dump()
        {
                TCHAR buf[256];
                if (m_dwRef != 0)
                {
                        wsprintf(buf, _T("INTERFACE LEAK: RefCount = %d, MaxRefCount = %d, {Allocation = %d} "), m_dwRef, m_dwMaxRef, nIndex);
                        OutputDebugString(buf);
                        AtlDumpIID(iid, lpszClassName, S_OK);
                }
                else
                {
                        wsprintf(buf, _T("NonAddRef Thunk LEAK: {Allocation = %d}\n"), nIndex);
                        OutputDebugString(buf);
                }
        }
};
#endif


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
        T* m_aT;
        int m_nSize;
        int m_nAllocSize;

// Construction/destruction
        CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
        { }

        ~CSimpleArray()
        {
                RemoveAll();
        }

// Operations
        int GetSize() const
        {
                return m_nSize;
        }
        BOOL Add(T& t)
        {
                if(m_nSize == m_nAllocSize)
                {
                        T* aT;
                        int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
                        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
                        if(aT == NULL)
                                return FALSE;
                        m_nAllocSize = nNewAllocSize;
                        m_aT = aT;
                }
                m_nSize++;
                SetAtIndex(m_nSize - 1, t);
                return TRUE;
        }
        BOOL Remove(T& t)
        {
                int nIndex = Find(t);
                if(nIndex == -1)
                        return FALSE;
                return RemoveAt(nIndex);
        }
        BOOL RemoveAt(int nIndex)
        {
                if(nIndex < 0 || nIndex >= m_nSize)
                        return FALSE;
                        
                m_aT[nIndex].~T();
                if(nIndex != (m_nSize - 1))
                        memmove((void*)(m_aT + nIndex), (void*)(m_aT + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(T));
                m_nSize--;
                return TRUE;
        }
        void RemoveAll()
        {
                if(m_aT != NULL)
                {
                        for(int i = 0; i < m_nSize; i++) 
                        {
                                m_aT[i].~T();
                        }
                        free(m_aT);
                        m_aT = NULL;
                }
                m_nSize = 0;
                m_nAllocSize = 0;
        }
        T& operator[] (int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                if(nIndex < 0 || nIndex >= m_nSize)
                {
                        _AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);                                        
                }
                return m_aT[nIndex];
        }
        T* GetData() const
        {
                return m_aT;
        }

// Implementation
        class Wrapper
        {
        public:
                Wrapper(T& _t) : t(_t)
                {
                }
                template <class _Ty>
                void *operator new(size_t, _Ty* p)
                {
                        return p;
                }
                T t;
        };
        void SetAtIndex(int nIndex, T& t)
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                new(m_aT + nIndex) Wrapper(t);
        }
        int Find(T& t) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aT[i] == t)
                                return i;
                }
                return -1;  // not found
        }
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
        BOOL Add(T t)
        {
                return CSimpleArray< T >::Add(t);
        }
        BOOL Remove(T t)
        {
                return CSimpleArray< T >::Remove(t);
        }
        T operator[] (int nIndex) const
        {
                return CSimpleArray< T >::operator[](nIndex);
        }
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
        TKey* m_aKey;
        TVal* m_aVal;
        int m_nSize;

// Construction/destruction
        CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
        { }

        ~CSimpleMap()
        {
                RemoveAll();
        }

// Operations
        int GetSize() const
        {
                return m_nSize;
        }
        BOOL Add(TKey key, TVal val)
        {
                TKey* pKey;
                pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
                if(pKey == NULL)
                        return FALSE;
                m_aKey = pKey;
                TVal* pVal;
                pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
                if(pVal == NULL)
                        return FALSE;
                m_aVal = pVal;
                m_nSize++;
                SetAtIndex(m_nSize - 1, key, val);
                return TRUE;
        }
        BOOL Remove(TKey key)
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return FALSE;
                m_aKey[nIndex].~TKey();
                m_aVal[nIndex].~TVal();                        
                if(nIndex != (m_nSize - 1))
                {
                        memmove((void*)(m_aKey + nIndex), (void*)(m_aKey + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TKey));
                        memmove((void*)(m_aVal + nIndex), (void*)(m_aVal + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TVal));
                }
                TKey* pKey;
                pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
                if(pKey != NULL || m_nSize == 1)
                        m_aKey = pKey;
                TVal* pVal;
                pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
                if(pVal != NULL || m_nSize == 1)
                        m_aVal = pVal;
                m_nSize--;
                return TRUE;
        }
        void RemoveAll()
        {
                if(m_aKey != NULL)
                {
                        for(int i = 0; i < m_nSize; i++)
                        {
                                m_aKey[i].~TKey();
#if _MSC_VER >= 1200
                                m_aVal[i].~TVal();
#else
                TVal * t1;
                t1 = &m_aVal[i];
                t1->~TVal();
#endif
                        }
                        free(m_aKey);
                        m_aKey = NULL;
                }
                if(m_aVal != NULL)
                {
                        free(m_aVal);
                        m_aVal = NULL;
                }

                m_nSize = 0;
        }
        BOOL SetAt(TKey key, TVal val)
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return FALSE;
                SetAtIndex(nIndex, key, val);
                return TRUE;
        }
        TVal Lookup(TKey key) const
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return NULL;    // must be able to convert
                return GetValueAt(nIndex);
        }
        TKey ReverseLookup(TVal val) const
        {
                int nIndex = FindVal(val);
                if(nIndex == -1)
                        return NULL;    // must be able to convert
                return GetKeyAt(nIndex);
        }
        TKey& GetKeyAt(int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                if(nIndex < 0 || nIndex >= m_nSize)
                        _AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
                        
                return m_aKey[nIndex];
        }
        TVal& GetValueAt(int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                if(nIndex < 0 || nIndex >= m_nSize)
                        _AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);        
                        
                return m_aVal[nIndex];
        }

// Implementation

        template <typename T>
        class Wrapper
        {
        public:
                Wrapper(T& _t) : t(_t)
                {
                }
                template <typename _Ty>
                void *operator new(size_t, _Ty* p)
                {
                        return p;
                }
                T t;
        };
        void SetAtIndex(int nIndex, TKey& key, TVal& val)
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                new(m_aKey + nIndex) Wrapper<TKey>(key);
                new(m_aVal + nIndex) Wrapper<TVal>(val);
        }
        int FindKey(TKey& key) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aKey[i] == key)
                                return i;
                }
                return -1;  // not found
        }
        int FindVal(TVal& val) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aVal[i] == val)
                                return i;
                }
                return -1;  // not found
        }
};


class CComModule;
__declspec(selectany) CComModule* _pModule=NULL;

// {B62F5910-6528-11d1-9611-0000F81E0D0D}
_declspec(selectany) GUID GUID_ATLVer30 = { 0xb62f5910, 0x6528, 0x11d1, { 0x96, 0x11, 0x0, 0x0, 0xf8, 0x1e, 0xd, 0xd } };

class CComModule : public _ATL_MODULE
{
// Operations
public:
        static GUID m_libid;
#ifdef _ATL_DEBUG_INTERFACES
        UINT m_nIndexQI;
        UINT m_nIndexBreakAt;
        CSimpleArray<_QIThunk*>* m_paThunks;
#endif // _ATL_DEBUG_INTERFACES

        void AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
        {
                AtlModuleAddCreateWndData(this, pData, pObject);
        }
        void* ExtractCreateWndData()
        {
                return AtlModuleExtractCreateWndData(this);
        }

#if _ATL_VER > 0x0300
        LONG GetNextWindowID()
        {
                LONG nID;

                nID = InterlockedIncrement(&m_nNextWindowID);

                return nID;
        }
#endif

        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL)
        {
                pguidVer = &GUID_ATLVer30;
                _pModule = this;
                cbSize = sizeof(_ATL_MODULE);
                dwAtlBuildVer = _ATL_VER;

// Initialize variables
#ifdef _ATL_MIN_CRT
#ifndef _ATL_NO_MP_HEAP
                m_phHeaps = NULL;
                m_dwHeaps = 0;
#endif
#endif

#ifdef _ATL_DEBUG_INTERFACES
                m_nIndexQI = 0;
                m_nIndexBreakAt = 0;
                m_paThunks = NULL;
#endif

                HRESULT hr = AtlModuleInit(this, p, h);
                if (FAILED(hr))
                        return hr;
                if (plibid != NULL)
                        memcpy((void*)&m_libid, plibid, sizeof(GUID));
#if _ATL_VER > 0x0300
                m_nNextWindowID = 1;
#endif
#ifdef _ATL_MIN_CRT
                // Create a base heap
                m_hHeap = HeapCreate(0, 0, 0);
                if (m_hHeap == NULL)
                {
                        Term();
                        return E_OUTOFMEMORY;
                }

#ifndef _ATL_NO_MP_HEAP
                OSVERSIONINFO ver;
                SYSTEM_INFO si;
                memset( &ver, 0, sizeof( ver ) );
                ver.dwOSVersionInfoSize = sizeof( ver );
                GetVersionEx( &ver );
                GetSystemInfo(&si);
                if( ((ver.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
                        (ver.dwMajorVersion < 5)) && (si.dwNumberOfProcessors > 1) )
                {
                        DWORD dwHeaps = si.dwNumberOfProcessors * 2;
                        m_dwHeaps = 0xFFFFFFFF;
                        for (int bits = 0; bits < 32; bits++)
                        {
                                if (dwHeaps & 0x80000000)
                                        break;
                                dwHeaps <<= 1;
                                m_dwHeaps >>= 1;
                        }
                        m_dwHeaps >>= 1;

                        // Allocate more heaps for each processor
                        m_phHeaps = (HANDLE*) HeapAlloc(m_hHeap, _ATL_HEAPFLAGS, sizeof(HANDLE) * (m_dwHeaps + 1));
                        if (m_phHeaps == NULL)
                        {
                                Term();
                                return E_OUTOFMEMORY;
                        }
                        memset(m_phHeaps, 0, sizeof(HANDLE) * (m_dwHeaps + 1));
                        for (DWORD i = 0; i <= m_dwHeaps; i++)
                        {
                                m_phHeaps[i] = HeapCreate(0, 0, 0);
                                if (m_phHeaps[i] == NULL)
                                {
                                        Term();
                                        return E_OUTOFMEMORY;
                                }
                        }
                }
                else
#endif
                {
                        m_phHeaps = NULL;
                        m_dwHeaps = 0;
                }
#endif
#ifdef _ATL_DEBUG_INTERFACES
                ATLTRY(m_paThunks = new CSimpleArray<_QIThunk*>);
                if (m_paThunks == NULL)
                {
                        Term();
                        return E_OUTOFMEMORY;
                }
#endif // _ATL_DEBUG_INTERFACES
                return S_OK;
        }
#ifdef _ATL_DEBUG_INTERFACES
        HRESULT AddThunk(IUnknown** pp, LPCTSTR lpsz, REFIID iid)
        {
                if ((pp == NULL) || (*pp == NULL))
                        return E_POINTER;
                IUnknown* p = *pp;
                _QIThunk* pThunk = NULL;
                EnterCriticalSection(&m_csObjMap);
                // Check if exists already for identity
                if (InlineIsEqualUnknown(iid))
                {
                        for (int i = 0; i < m_paThunks->GetSize(); i++)
                        {
                                if (m_paThunks->operator[](i)->pUnk == p)
                                {
                                        m_paThunks->operator[](i)->InternalAddRef();
                                        pThunk = m_paThunks->operator[](i);
                                        break;
                                }
                        }
                }
                if (pThunk == NULL)
                {
                        ++m_nIndexQI;
                        if (m_nIndexBreakAt == m_nIndexQI)
                                DebugBreak();
                        ATLTRY(pThunk = new _QIThunk(p, lpsz, iid, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
                        if (pThunk == NULL)
                        {
                                LeaveCriticalSection(&m_csObjMap);
                                return E_OUTOFMEMORY;
                        }
                        pThunk->InternalAddRef();
                        m_paThunks->Add(pThunk);
                }
                LeaveCriticalSection(&m_csObjMap);
                *pp = (IUnknown*)pThunk;
                return S_OK;
        }
        HRESULT AddNonAddRefThunk(IUnknown* p, LPCTSTR lpsz, IUnknown** ppThunkRet)
        {
                _ATL_VALIDATE_OUT_POINTER(ppThunkRet);
                
                _QIThunk* pThunk = NULL;
                EnterCriticalSection(&m_csObjMap);
                // Check if exists already for identity
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        if (m_paThunks->operator[](i)->pUnk == p)
                        {
                                m_paThunks->operator[](i)->bNonAddRefThunk = true;
                                pThunk = m_paThunks->operator[](i);
                                break;
                        }
                }
                if (pThunk == NULL)
                {
                        ++m_nIndexQI;
                        if (m_nIndexBreakAt == m_nIndexQI)
                                DebugBreak();
                        ATLTRY(pThunk = new _QIThunk(p, lpsz, IID_IUnknown, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
                        if (pThunk == NULL)
                        {
                                *ppThunkRet = NULL;
                                LeaveCriticalSection(&m_csObjMap);
                                return E_OUTOFMEMORY;
                        }
                        pThunk->bNonAddRefThunk = true;
                        m_paThunks->Add(pThunk);
                }
                LeaveCriticalSection(&m_csObjMap);
                *ppThunkRet = (IUnknown*)pThunk;
                return S_OK;;
        }
        void DeleteNonAddRefThunk(IUnknown* pUnk)
        {
                EnterCriticalSection(&m_csObjMap);
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        if (m_paThunks->operator[](i)->pUnk == pUnk)
                        {
                                delete m_paThunks->operator[](i);
                                m_paThunks->RemoveAt(i);
                                break;
                        }
                }
                LeaveCriticalSection(&m_csObjMap);
        }
        void DeleteThunk(_QIThunk* p)
        {
                EnterCriticalSection(&m_csObjMap);
                int nIndex = m_paThunks->Find(p);
                if (nIndex != -1)
                {
                        delete m_paThunks->operator[](nIndex);
                        m_paThunks->RemoveAt(nIndex);
                }
                LeaveCriticalSection(&m_csObjMap);
        }
        bool DumpLeakedThunks()
        {
                bool b = false;
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        b = true;
                        m_paThunks->operator[](i)->Dump();
                        delete m_paThunks->operator[](i);
                }
                m_paThunks->RemoveAll();
                return b;
        }
#endif // _ATL_DEBUG_INTERFACES
        void Term()
        {
#ifdef _ATL_DEBUG_INTERFACES
                m_bDestroyHeap = false; // prevent heap from going away
                AtlModuleTerm(this);
                DumpLeakedThunks();
                delete m_paThunks;
#ifndef _ATL_NO_MP_HEAP
                if (m_phHeaps != NULL)
                {
                        for (DWORD i = 0; i <= m_dwHeaps; i++)
                        {
                                if (m_phHeaps[i] != NULL)
                                        HeapDestroy(m_phHeaps[i]);
                        }
                }
#endif
                if (m_hHeap != NULL)
                        HeapDestroy(m_hHeap);
#else
                AtlModuleTerm(this);
#endif // _ATL_DEBUG_INTERFACES
        }

        HRESULT AddTermFunc(_ATL_TERMFUNC* pFunc, DWORD_PTR dw)
        {
                return AtlModuleAddTermFunc(this, pFunc, dw);
        }

        LONG Lock()
        {
                return CComGlobalsThreadModel::Increment(&m_nLockCnt);
        }
        LONG Unlock()
        {
                return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
        }
        LONG GetLockCount()
        {
                return m_nLockCnt;
        }

        HINSTANCE GetModuleInstance() {return m_hInst;}
        HINSTANCE GetResourceInstance() {return m_hInstResource;}
        HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;}

        // Registry support (helpers)
        HRESULT RegisterTypeLib()
        {
                return AtlModuleRegisterTypeLib(this, NULL);
        }
        HRESULT RegisterTypeLib(LPCTSTR lpszIndex)
        {
                USES_CONVERSION_EX;
                LPCOLESTR p = NULL;
                if(lpszIndex != NULL)
                {
                        p = T2COLE_EX(lpszIndex,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE                        
                        if(p == NULL) 
                                return E_OUTOFMEMORY;
#endif                        
                }
                return AtlModuleRegisterTypeLib(this,p );
        }
        HRESULT UnRegisterTypeLib()
        {
                return AtlModuleUnRegisterTypeLib(this, NULL);
        }
        HRESULT UnRegisterTypeLib(LPCTSTR lpszIndex)
        {
                USES_CONVERSION_EX;
                
                LPCOLESTR p = NULL;
                if(lpszIndex != NULL)
                {
                        p = T2COLE_EX(lpszIndex,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE                        
                        if(p == NULL) 
                                return E_OUTOFMEMORY;
#endif
                }
                return AtlModuleUnRegisterTypeLib(this,p );
        }
        HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
        {
                return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID);
        }

        HRESULT UnregisterServer(const CLSID* pCLSID = NULL)
        {
                return AtlModuleUnregisterServer(this, pCLSID);
        }
        HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL)
        {
                return AtlModuleUnregisterServerEx(this, bUnRegTypeLib, pCLSID);
        }

        // Resource-based Registration
        HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
        {
                if(lpszRes == NULL)
                        return E_INVALIDARG;
                
                USES_CONVERSION_EX;                        
                LPCOLESTR p = T2COLE_EX(lpszRes,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifdef _UNICODE
                if(p == NULL) 
                        return E_OUTOFMEMORY;
#endif                
                return AtlModuleUpdateRegistryFromResourceD(this, p, bRegister,        pMapEntries);
        }
        HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
        {
                return AtlModuleUpdateRegistryFromResourceD(this,
                        (LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
        }

#ifdef _ATL_STATIC_REGISTRY
        // Statically linking to Registry Ponent
        HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
        HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
#endif

        // Standard Registration
        HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
        HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
        HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID);

        // Register/Revoke All Class Factories with the OS (EXE only)
        HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
        {
                return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags);
        }
        HRESULT RevokeClassObjects()
        {
                return AtlModuleRevokeClassObjects(this);
        }

        // Obtain a Class Factory (DLL only)
        HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
        {
                return AtlModuleGetClassObject(this, rclsid, riid, ppv);
        }

        // Only used in CComAutoThreadModule
        HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/)
        {
                ATLASSERT(FALSE);
                return E_NOTIMPL;
        }
        static HRESULT RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc);

        static HRESULT ReplaceSingleQuote(LPOLESTR lpDest, LPCOLESTR lp)
        {
                if (lp == NULL || lpDest == NULL)
                        return E_INVALIDARG;
                        
                while (*lp)
                {
                        *lpDest++ = *lp;
                        if (*lp == OLESTR('\''))
                                *lpDest++ = *lp;
                        lp++;
                }
                *lpDest = NULL;
                
                return S_OK;
        }
};

#ifdef _ATL_DEBUG_INTERFACES
inline ULONG _QIThunk::Release()
{
        if (bBreak)
                DebugBreak();
        ATLASSERT(m_dwRef > 0);
        ULONG l = InterlockedDecrement(&m_dwRef);
        ATLTRACE(_T("%d< "), m_dwRef);
        AtlDumpIID(iid, lpszClassName, S_OK);
        pUnk->Release();
        if (l == 0 && !bNonAddRefThunk)
                _pModule->DeleteThunk(this);
        return l;
}

inline static void atlBadThunkCall()
{
        ATLASSERT(FALSE && "Call through deleted thunk");
}

#ifdef _M_IX86
#define IMPL_THUNK(n)\
__declspec(naked) inline HRESULT _QIThunk::f##n()\
{\
        __asm mov eax, [esp+4]\
        __asm cmp dword ptr [eax+8], 0\
        __asm jg goodref\
        __asm call atlBadThunkCall\
        __asm goodref:\
        __asm mov eax, [esp+4]\
        __asm mov eax, dword ptr [eax+4]\
        __asm mov [esp+4], eax\
        __asm mov eax, dword ptr [eax]\
        __asm mov eax, dword ptr [eax+4*n]\
        __asm jmp eax\
}

#else
#define IMPL_THUNK(x)
#endif

IMPL_THUNK(3)
IMPL_THUNK(4)
IMPL_THUNK(5)
IMPL_THUNK(6)
IMPL_THUNK(7)
IMPL_THUNK(8)
IMPL_THUNK(9)
IMPL_THUNK(10)
IMPL_THUNK(11)
IMPL_THUNK(12)
IMPL_THUNK(13)
IMPL_THUNK(14)
IMPL_THUNK(15)
IMPL_THUNK(16)
IMPL_THUNK(17)
IMPL_THUNK(18)
IMPL_THUNK(19)
IMPL_THUNK(20)
IMPL_THUNK(21)
IMPL_THUNK(22)
IMPL_THUNK(23)
IMPL_THUNK(24)
IMPL_THUNK(25)
IMPL_THUNK(26)
IMPL_THUNK(27)
IMPL_THUNK(28)
IMPL_THUNK(29)
IMPL_THUNK(30)
IMPL_THUNK(31)
IMPL_THUNK(32)
IMPL_THUNK(33)
IMPL_THUNK(34)
IMPL_THUNK(35)
IMPL_THUNK(36)
IMPL_THUNK(37)
IMPL_THUNK(38)
IMPL_THUNK(39)
IMPL_THUNK(40)
IMPL_THUNK(41)
IMPL_THUNK(42)
IMPL_THUNK(43)
IMPL_THUNK(44)
IMPL_THUNK(45)
IMPL_THUNK(46)
IMPL_THUNK(47)
IMPL_THUNK(48)
IMPL_THUNK(49)
IMPL_THUNK(50)
IMPL_THUNK(51)
IMPL_THUNK(52)
IMPL_THUNK(53)
IMPL_THUNK(54)
IMPL_THUNK(55)
IMPL_THUNK(56)
IMPL_THUNK(57)
IMPL_THUNK(58)
IMPL_THUNK(59)
IMPL_THUNK(60)
IMPL_THUNK(61)
IMPL_THUNK(62)
IMPL_THUNK(63)
IMPL_THUNK(64)
IMPL_THUNK(65)
IMPL_THUNK(66)
IMPL_THUNK(67)
IMPL_THUNK(68)
IMPL_THUNK(69)
IMPL_THUNK(70)
IMPL_THUNK(71)
IMPL_THUNK(72)
IMPL_THUNK(73)
IMPL_THUNK(74)
IMPL_THUNK(75)
IMPL_THUNK(76)
IMPL_THUNK(77)
IMPL_THUNK(78)
IMPL_THUNK(79)
IMPL_THUNK(80)
IMPL_THUNK(81)
IMPL_THUNK(82)
IMPL_THUNK(83)
IMPL_THUNK(84)
IMPL_THUNK(85)
IMPL_THUNK(86)
IMPL_THUNK(87)
IMPL_THUNK(88)
IMPL_THUNK(89)
IMPL_THUNK(90)
IMPL_THUNK(91)
IMPL_THUNK(92)
IMPL_THUNK(93)
IMPL_THUNK(94)
IMPL_THUNK(95)
IMPL_THUNK(96)
IMPL_THUNK(97)
IMPL_THUNK(98)
IMPL_THUNK(99)
IMPL_THUNK(100)
IMPL_THUNK(101)
IMPL_THUNK(102)
IMPL_THUNK(103)
IMPL_THUNK(104)
IMPL_THUNK(105)
IMPL_THUNK(106)
IMPL_THUNK(107)
IMPL_THUNK(108)
IMPL_THUNK(109)
IMPL_THUNK(110)
IMPL_THUNK(111)
IMPL_THUNK(112)
IMPL_THUNK(113)
IMPL_THUNK(114)
IMPL_THUNK(115)
IMPL_THUNK(116)
IMPL_THUNK(117)
IMPL_THUNK(118)
IMPL_THUNK(119)
IMPL_THUNK(120)
IMPL_THUNK(121)
IMPL_THUNK(122)
IMPL_THUNK(123)
IMPL_THUNK(124)
IMPL_THUNK(125)
IMPL_THUNK(126)
IMPL_THUNK(127)
IMPL_THUNK(128)
IMPL_THUNK(129)
IMPL_THUNK(130)
IMPL_THUNK(131)
IMPL_THUNK(132)
IMPL_THUNK(133)
IMPL_THUNK(134)
IMPL_THUNK(135)
IMPL_THUNK(136)
IMPL_THUNK(137)
IMPL_THUNK(138)
IMPL_THUNK(139)
IMPL_THUNK(140)
IMPL_THUNK(141)
IMPL_THUNK(142)
IMPL_THUNK(143)
IMPL_THUNK(144)
IMPL_THUNK(145)
IMPL_THUNK(146)
IMPL_THUNK(147)
IMPL_THUNK(148)
IMPL_THUNK(149)
IMPL_THUNK(150)
IMPL_THUNK(151)
IMPL_THUNK(152)
IMPL_THUNK(153)
IMPL_THUNK(154)
IMPL_THUNK(155)
IMPL_THUNK(156)
IMPL_THUNK(157)
IMPL_THUNK(158)
IMPL_THUNK(159)
IMPL_THUNK(160)
IMPL_THUNK(161)
IMPL_THUNK(162)
IMPL_THUNK(163)
IMPL_THUNK(164)
IMPL_THUNK(165)
IMPL_THUNK(166)
IMPL_THUNK(167)
IMPL_THUNK(168)
IMPL_THUNK(169)
IMPL_THUNK(170)
IMPL_THUNK(171)
IMPL_THUNK(172)
IMPL_THUNK(173)
IMPL_THUNK(174)
IMPL_THUNK(175)
IMPL_THUNK(176)
IMPL_THUNK(177)
IMPL_THUNK(178)
IMPL_THUNK(179)
IMPL_THUNK(180)
IMPL_THUNK(181)
IMPL_THUNK(182)
IMPL_THUNK(183)
IMPL_THUNK(184)
IMPL_THUNK(185)
IMPL_THUNK(186)
IMPL_THUNK(187)
IMPL_THUNK(188)
IMPL_THUNK(189)
IMPL_THUNK(190)
IMPL_THUNK(191)
IMPL_THUNK(192)
IMPL_THUNK(193)
IMPL_THUNK(194)
IMPL_THUNK(195)
IMPL_THUNK(196)
IMPL_THUNK(197)
IMPL_THUNK(198)
IMPL_THUNK(199)
IMPL_THUNK(200)
IMPL_THUNK(201)
IMPL_THUNK(202)
IMPL_THUNK(203)
IMPL_THUNK(204)
IMPL_THUNK(205)
IMPL_THUNK(206)
IMPL_THUNK(207)
IMPL_THUNK(208)
IMPL_THUNK(209)
IMPL_THUNK(210)
IMPL_THUNK(211)
IMPL_THUNK(212)
IMPL_THUNK(213)
IMPL_THUNK(214)
IMPL_THUNK(215)
IMPL_THUNK(216)
IMPL_THUNK(217)
IMPL_THUNK(218)
IMPL_THUNK(219)
IMPL_THUNK(220)
IMPL_THUNK(221)
IMPL_THUNK(222)
IMPL_THUNK(223)
IMPL_THUNK(224)
IMPL_THUNK(225)
IMPL_THUNK(226)
IMPL_THUNK(227)
IMPL_THUNK(228)
IMPL_THUNK(229)
IMPL_THUNK(230)
IMPL_THUNK(231)
IMPL_THUNK(232)
IMPL_THUNK(233)
IMPL_THUNK(234)
IMPL_THUNK(235)
IMPL_THUNK(236)
IMPL_THUNK(237)
IMPL_THUNK(238)
IMPL_THUNK(239)
IMPL_THUNK(240)
IMPL_THUNK(241)
IMPL_THUNK(242)
IMPL_THUNK(243)
IMPL_THUNK(244)
IMPL_THUNK(245)
IMPL_THUNK(246)
IMPL_THUNK(247)
IMPL_THUNK(248)
IMPL_THUNK(249)
IMPL_THUNK(250)
IMPL_THUNK(251)
IMPL_THUNK(252)
IMPL_THUNK(253)
IMPL_THUNK(254)
IMPL_THUNK(255)
IMPL_THUNK(256)
IMPL_THUNK(257)
IMPL_THUNK(258)
IMPL_THUNK(259)
IMPL_THUNK(260)
IMPL_THUNK(261)
IMPL_THUNK(262)
IMPL_THUNK(263)
IMPL_THUNK(264)
IMPL_THUNK(265)
IMPL_THUNK(266)
IMPL_THUNK(267)
IMPL_THUNK(268)
IMPL_THUNK(269)
IMPL_THUNK(270)
IMPL_THUNK(271)
IMPL_THUNK(272)
IMPL_THUNK(273)
IMPL_THUNK(274)
IMPL_THUNK(275)
IMPL_THUNK(276)
IMPL_THUNK(277)
IMPL_THUNK(278)
IMPL_THUNK(279)
IMPL_THUNK(280)
IMPL_THUNK(281)
IMPL_THUNK(282)
IMPL_THUNK(283)
IMPL_THUNK(284)
IMPL_THUNK(285)
IMPL_THUNK(286)
IMPL_THUNK(287)
IMPL_THUNK(288)
IMPL_THUNK(289)
IMPL_THUNK(290)
IMPL_THUNK(291)
IMPL_THUNK(292)
IMPL_THUNK(293)
IMPL_THUNK(294)
IMPL_THUNK(295)
IMPL_THUNK(296)
IMPL_THUNK(297)
IMPL_THUNK(298)
IMPL_THUNK(299)
IMPL_THUNK(300)
IMPL_THUNK(301)
IMPL_THUNK(302)
IMPL_THUNK(303)
IMPL_THUNK(304)
IMPL_THUNK(305)
IMPL_THUNK(306)
IMPL_THUNK(307)
IMPL_THUNK(308)
IMPL_THUNK(309)
IMPL_THUNK(310)
IMPL_THUNK(311)
IMPL_THUNK(312)
IMPL_THUNK(313)
IMPL_THUNK(314)
IMPL_THUNK(315)
IMPL_THUNK(316)
IMPL_THUNK(317)
IMPL_THUNK(318)
IMPL_THUNK(319)
IMPL_THUNK(320)
IMPL_THUNK(321)
IMPL_THUNK(322)
IMPL_THUNK(323)
IMPL_THUNK(324)
IMPL_THUNK(325)
IMPL_THUNK(326)
IMPL_THUNK(327)
IMPL_THUNK(328)
IMPL_THUNK(329)
IMPL_THUNK(330)
IMPL_THUNK(331)
IMPL_THUNK(332)
IMPL_THUNK(333)
IMPL_THUNK(334)
IMPL_THUNK(335)
IMPL_THUNK(336)
IMPL_THUNK(337)
IMPL_THUNK(338)
IMPL_THUNK(339)
IMPL_THUNK(340)
IMPL_THUNK(341)
IMPL_THUNK(342)
IMPL_THUNK(343)
IMPL_THUNK(344)
IMPL_THUNK(345)
IMPL_THUNK(346)
IMPL_THUNK(347)
IMPL_THUNK(348)
IMPL_THUNK(349)
IMPL_THUNK(350)
IMPL_THUNK(351)
IMPL_THUNK(352)
IMPL_THUNK(353)
IMPL_THUNK(354)
IMPL_THUNK(355)
IMPL_THUNK(356)
IMPL_THUNK(357)
IMPL_THUNK(358)
IMPL_THUNK(359)
IMPL_THUNK(360)
IMPL_THUNK(361)
IMPL_THUNK(362)
IMPL_THUNK(363)
IMPL_THUNK(364)
IMPL_THUNK(365)
IMPL_THUNK(366)
IMPL_THUNK(367)
IMPL_THUNK(368)
IMPL_THUNK(369)
IMPL_THUNK(370)
IMPL_THUNK(371)
IMPL_THUNK(372)
IMPL_THUNK(373)
IMPL_THUNK(374)
IMPL_THUNK(375)
IMPL_THUNK(376)
IMPL_THUNK(377)
IMPL_THUNK(378)
IMPL_THUNK(379)
IMPL_THUNK(380)
IMPL_THUNK(381)
IMPL_THUNK(382)
IMPL_THUNK(383)
IMPL_THUNK(384)
IMPL_THUNK(385)
IMPL_THUNK(386)
IMPL_THUNK(387)
IMPL_THUNK(388)
IMPL_THUNK(389)
IMPL_THUNK(390)
IMPL_THUNK(391)
IMPL_THUNK(392)
IMPL_THUNK(393)
IMPL_THUNK(394)
IMPL_THUNK(395)
IMPL_THUNK(396)
IMPL_THUNK(397)
IMPL_THUNK(398)
IMPL_THUNK(399)
IMPL_THUNK(400)
IMPL_THUNK(401)
IMPL_THUNK(402)
IMPL_THUNK(403)
IMPL_THUNK(404)
IMPL_THUNK(405)
IMPL_THUNK(406)
IMPL_THUNK(407)
IMPL_THUNK(408)
IMPL_THUNK(409)
IMPL_THUNK(410)
IMPL_THUNK(411)
IMPL_THUNK(412)
IMPL_THUNK(413)
IMPL_THUNK(414)
IMPL_THUNK(415)
IMPL_THUNK(416)
IMPL_THUNK(417)
IMPL_THUNK(418)
IMPL_THUNK(419)
IMPL_THUNK(420)
IMPL_THUNK(421)
IMPL_THUNK(422)
IMPL_THUNK(423)
IMPL_THUNK(424)
IMPL_THUNK(425)
IMPL_THUNK(426)
IMPL_THUNK(427)
IMPL_THUNK(428)
IMPL_THUNK(429)
IMPL_THUNK(430)
IMPL_THUNK(431)
IMPL_THUNK(432)
IMPL_THUNK(433)
IMPL_THUNK(434)
IMPL_THUNK(435)
IMPL_THUNK(436)
IMPL_THUNK(437)
IMPL_THUNK(438)
IMPL_THUNK(439)
IMPL_THUNK(440)
IMPL_THUNK(441)
IMPL_THUNK(442)
IMPL_THUNK(443)
IMPL_THUNK(444)
IMPL_THUNK(445)
IMPL_THUNK(446)
IMPL_THUNK(447)
IMPL_THUNK(448)
IMPL_THUNK(449)
IMPL_THUNK(450)
IMPL_THUNK(451)
IMPL_THUNK(452)
IMPL_THUNK(453)
IMPL_THUNK(454)
IMPL_THUNK(455)
IMPL_THUNK(456)
IMPL_THUNK(457)
IMPL_THUNK(458)
IMPL_THUNK(459)
IMPL_THUNK(460)
IMPL_THUNK(461)
IMPL_THUNK(462)
IMPL_THUNK(463)
IMPL_THUNK(464)
IMPL_THUNK(465)
IMPL_THUNK(466)
IMPL_THUNK(467)
IMPL_THUNK(468)
IMPL_THUNK(469)
IMPL_THUNK(470)
IMPL_THUNK(471)
IMPL_THUNK(472)
IMPL_THUNK(473)
IMPL_THUNK(474)
IMPL_THUNK(475)
IMPL_THUNK(476)
IMPL_THUNK(477)
IMPL_THUNK(478)
IMPL_THUNK(479)
IMPL_THUNK(480)
IMPL_THUNK(481)
IMPL_THUNK(482)
IMPL_THUNK(483)
IMPL_THUNK(484)
IMPL_THUNK(485)
IMPL_THUNK(486)
IMPL_THUNK(487)
IMPL_THUNK(488)
IMPL_THUNK(489)
IMPL_THUNK(490)
IMPL_THUNK(491)
IMPL_THUNK(492)
IMPL_THUNK(493)
IMPL_THUNK(494)
IMPL_THUNK(495)
IMPL_THUNK(496)
IMPL_THUNK(497)
IMPL_THUNK(498)
IMPL_THUNK(499)
IMPL_THUNK(500)
IMPL_THUNK(501)
IMPL_THUNK(502)
IMPL_THUNK(503)
IMPL_THUNK(504)
IMPL_THUNK(505)
IMPL_THUNK(506)
IMPL_THUNK(507)
IMPL_THUNK(508)
IMPL_THUNK(509)
IMPL_THUNK(510)
IMPL_THUNK(511)
IMPL_THUNK(512)
IMPL_THUNK(513)
IMPL_THUNK(514)
IMPL_THUNK(515)
IMPL_THUNK(516)
IMPL_THUNK(517)
IMPL_THUNK(518)
IMPL_THUNK(519)
IMPL_THUNK(520)
IMPL_THUNK(521)
IMPL_THUNK(522)
IMPL_THUNK(523)
IMPL_THUNK(524)
IMPL_THUNK(525)
IMPL_THUNK(526)
IMPL_THUNK(527)
IMPL_THUNK(528)
IMPL_THUNK(529)
IMPL_THUNK(530)
IMPL_THUNK(531)
IMPL_THUNK(532)
IMPL_THUNK(533)
IMPL_THUNK(534)
IMPL_THUNK(535)
IMPL_THUNK(536)
IMPL_THUNK(537)
IMPL_THUNK(538)
IMPL_THUNK(539)
IMPL_THUNK(540)
IMPL_THUNK(541)
IMPL_THUNK(542)
IMPL_THUNK(543)
IMPL_THUNK(544)
IMPL_THUNK(545)
IMPL_THUNK(546)
IMPL_THUNK(547)
IMPL_THUNK(548)
IMPL_THUNK(549)
IMPL_THUNK(550)
IMPL_THUNK(551)
IMPL_THUNK(552)
IMPL_THUNK(553)
IMPL_THUNK(554)
IMPL_THUNK(555)
IMPL_THUNK(556)
IMPL_THUNK(557)
IMPL_THUNK(558)
IMPL_THUNK(559)
IMPL_THUNK(560)
IMPL_THUNK(561)
IMPL_THUNK(562)
IMPL_THUNK(563)
IMPL_THUNK(564)
IMPL_THUNK(565)
IMPL_THUNK(566)
IMPL_THUNK(567)
IMPL_THUNK(568)
IMPL_THUNK(569)
IMPL_THUNK(570)
IMPL_THUNK(571)
IMPL_THUNK(572)
IMPL_THUNK(573)
IMPL_THUNK(574)
IMPL_THUNK(575)
IMPL_THUNK(576)
IMPL_THUNK(577)
IMPL_THUNK(578)
IMPL_THUNK(579)
IMPL_THUNK(580)
IMPL_THUNK(581)
IMPL_THUNK(582)
IMPL_THUNK(583)
IMPL_THUNK(584)
IMPL_THUNK(585)
IMPL_THUNK(586)
IMPL_THUNK(587)
IMPL_THUNK(588)
IMPL_THUNK(589)
IMPL_THUNK(590)
IMPL_THUNK(591)
IMPL_THUNK(592)
IMPL_THUNK(593)
IMPL_THUNK(594)
IMPL_THUNK(595)
IMPL_THUNK(596)
IMPL_THUNK(597)
IMPL_THUNK(598)
IMPL_THUNK(599)
IMPL_THUNK(600)
IMPL_THUNK(601)
IMPL_THUNK(602)
IMPL_THUNK(603)
IMPL_THUNK(604)
IMPL_THUNK(605)
IMPL_THUNK(606)
IMPL_THUNK(607)
IMPL_THUNK(608)
IMPL_THUNK(609)
IMPL_THUNK(610)
IMPL_THUNK(611)
IMPL_THUNK(612)
IMPL_THUNK(613)
IMPL_THUNK(614)
IMPL_THUNK(615)
IMPL_THUNK(616)
IMPL_THUNK(617)
IMPL_THUNK(618)
IMPL_THUNK(619)
IMPL_THUNK(620)
IMPL_THUNK(621)
IMPL_THUNK(622)
IMPL_THUNK(623)
IMPL_THUNK(624)
IMPL_THUNK(625)
IMPL_THUNK(626)
IMPL_THUNK(627)
IMPL_THUNK(628)
IMPL_THUNK(629)
IMPL_THUNK(630)
IMPL_THUNK(631)
IMPL_THUNK(632)
IMPL_THUNK(633)
IMPL_THUNK(634)
IMPL_THUNK(635)
IMPL_THUNK(636)
IMPL_THUNK(637)
IMPL_THUNK(638)
IMPL_THUNK(639)
IMPL_THUNK(640)
IMPL_THUNK(641)
IMPL_THUNK(642)
IMPL_THUNK(643)
IMPL_THUNK(644)
IMPL_THUNK(645)
IMPL_THUNK(646)
IMPL_THUNK(647)
IMPL_THUNK(648)
IMPL_THUNK(649)
IMPL_THUNK(650)
IMPL_THUNK(651)
IMPL_THUNK(652)
IMPL_THUNK(653)
IMPL_THUNK(654)
IMPL_THUNK(655)
IMPL_THUNK(656)
IMPL_THUNK(657)
IMPL_THUNK(658)
IMPL_THUNK(659)
IMPL_THUNK(660)
IMPL_THUNK(661)
IMPL_THUNK(662)
IMPL_THUNK(663)
IMPL_THUNK(664)
IMPL_THUNK(665)
IMPL_THUNK(666)
IMPL_THUNK(667)
IMPL_THUNK(668)
IMPL_THUNK(669)
IMPL_THUNK(670)
IMPL_THUNK(671)
IMPL_THUNK(672)
IMPL_THUNK(673)
IMPL_THUNK(674)
IMPL_THUNK(675)
IMPL_THUNK(676)
IMPL_THUNK(677)
IMPL_THUNK(678)
IMPL_THUNK(679)
IMPL_THUNK(680)
IMPL_THUNK(681)
IMPL_THUNK(682)
IMPL_THUNK(683)
IMPL_THUNK(684)
IMPL_THUNK(685)
IMPL_THUNK(686)
IMPL_THUNK(687)
IMPL_THUNK(688)
IMPL_THUNK(689)
IMPL_THUNK(690)
IMPL_THUNK(691)
IMPL_THUNK(692)
IMPL_THUNK(693)
IMPL_THUNK(694)
IMPL_THUNK(695)
IMPL_THUNK(696)
IMPL_THUNK(697)
IMPL_THUNK(698)
IMPL_THUNK(699)
IMPL_THUNK(700)
IMPL_THUNK(701)
IMPL_THUNK(702)
IMPL_THUNK(703)
IMPL_THUNK(704)
IMPL_THUNK(705)
IMPL_THUNK(706)
IMPL_THUNK(707)
IMPL_THUNK(708)
IMPL_THUNK(709)
IMPL_THUNK(710)
IMPL_THUNK(711)
IMPL_THUNK(712)
IMPL_THUNK(713)
IMPL_THUNK(714)
IMPL_THUNK(715)
IMPL_THUNK(716)
IMPL_THUNK(717)
IMPL_THUNK(718)
IMPL_THUNK(719)
IMPL_THUNK(720)
IMPL_THUNK(721)
IMPL_THUNK(722)
IMPL_THUNK(723)
IMPL_THUNK(724)
IMPL_THUNK(725)
IMPL_THUNK(726)
IMPL_THUNK(727)
IMPL_THUNK(728)
IMPL_THUNK(729)
IMPL_THUNK(730)
IMPL_THUNK(731)
IMPL_THUNK(732)
IMPL_THUNK(733)
IMPL_THUNK(734)
IMPL_THUNK(735)
IMPL_THUNK(736)
IMPL_THUNK(737)
IMPL_THUNK(738)
IMPL_THUNK(739)
IMPL_THUNK(740)
IMPL_THUNK(741)
IMPL_THUNK(742)
IMPL_THUNK(743)
IMPL_THUNK(744)
IMPL_THUNK(745)
IMPL_THUNK(746)
IMPL_THUNK(747)
IMPL_THUNK(748)
IMPL_THUNK(749)
IMPL_THUNK(750)
IMPL_THUNK(751)
IMPL_THUNK(752)
IMPL_THUNK(753)
IMPL_THUNK(754)
IMPL_THUNK(755)
IMPL_THUNK(756)
IMPL_THUNK(757)
IMPL_THUNK(758)
IMPL_THUNK(759)
IMPL_THUNK(760)
IMPL_THUNK(761)
IMPL_THUNK(762)
IMPL_THUNK(763)
IMPL_THUNK(764)
IMPL_THUNK(765)
IMPL_THUNK(766)
IMPL_THUNK(767)
IMPL_THUNK(768)
IMPL_THUNK(769)
IMPL_THUNK(770)
IMPL_THUNK(771)
IMPL_THUNK(772)
IMPL_THUNK(773)
IMPL_THUNK(774)
IMPL_THUNK(775)
IMPL_THUNK(776)
IMPL_THUNK(777)
IMPL_THUNK(778)
IMPL_THUNK(779)
IMPL_THUNK(780)
IMPL_THUNK(781)
IMPL_THUNK(782)
IMPL_THUNK(783)
IMPL_THUNK(784)
IMPL_THUNK(785)
IMPL_THUNK(786)
IMPL_THUNK(787)
IMPL_THUNK(788)
IMPL_THUNK(789)
IMPL_THUNK(790)
IMPL_THUNK(791)
IMPL_THUNK(792)
IMPL_THUNK(793)
IMPL_THUNK(794)
IMPL_THUNK(795)
IMPL_THUNK(796)
IMPL_THUNK(797)
IMPL_THUNK(798)
IMPL_THUNK(799)
IMPL_THUNK(800)
IMPL_THUNK(801)
IMPL_THUNK(802)
IMPL_THUNK(803)
IMPL_THUNK(804)
IMPL_THUNK(805)
IMPL_THUNK(806)
IMPL_THUNK(807)
IMPL_THUNK(808)
IMPL_THUNK(809)
IMPL_THUNK(810)
IMPL_THUNK(811)
IMPL_THUNK(812)
IMPL_THUNK(813)
IMPL_THUNK(814)
IMPL_THUNK(815)
IMPL_THUNK(816)
IMPL_THUNK(817)
IMPL_THUNK(818)
IMPL_THUNK(819)
IMPL_THUNK(820)
IMPL_THUNK(821)
IMPL_THUNK(822)
IMPL_THUNK(823)
IMPL_THUNK(824)
IMPL_THUNK(825)
IMPL_THUNK(826)
IMPL_THUNK(827)
IMPL_THUNK(828)
IMPL_THUNK(829)
IMPL_THUNK(830)
IMPL_THUNK(831)
IMPL_THUNK(832)
IMPL_THUNK(833)
IMPL_THUNK(834)
IMPL_THUNK(835)
IMPL_THUNK(836)
IMPL_THUNK(837)
IMPL_THUNK(838)
IMPL_THUNK(839)
IMPL_THUNK(840)
IMPL_THUNK(841)
IMPL_THUNK(842)
IMPL_THUNK(843)
IMPL_THUNK(844)
IMPL_THUNK(845)
IMPL_THUNK(846)
IMPL_THUNK(847)
IMPL_THUNK(848)
IMPL_THUNK(849)
IMPL_THUNK(850)
IMPL_THUNK(851)
IMPL_THUNK(852)
IMPL_THUNK(853)
IMPL_THUNK(854)
IMPL_THUNK(855)
IMPL_THUNK(856)
IMPL_THUNK(857)
IMPL_THUNK(858)
IMPL_THUNK(859)
IMPL_THUNK(860)
IMPL_THUNK(861)
IMPL_THUNK(862)
IMPL_THUNK(863)
IMPL_THUNK(864)
IMPL_THUNK(865)
IMPL_THUNK(866)
IMPL_THUNK(867)
IMPL_THUNK(868)
IMPL_THUNK(869)
IMPL_THUNK(870)
IMPL_THUNK(871)
IMPL_THUNK(872)
IMPL_THUNK(873)
IMPL_THUNK(874)
IMPL_THUNK(875)
IMPL_THUNK(876)
IMPL_THUNK(877)
IMPL_THUNK(878)
IMPL_THUNK(879)
IMPL_THUNK(880)
IMPL_THUNK(881)
IMPL_THUNK(882)
IMPL_THUNK(883)
IMPL_THUNK(884)
IMPL_THUNK(885)
IMPL_THUNK(886)
IMPL_THUNK(887)
IMPL_THUNK(888)
IMPL_THUNK(889)
IMPL_THUNK(890)
IMPL_THUNK(891)
IMPL_THUNK(892)
IMPL_THUNK(893)
IMPL_THUNK(894)
IMPL_THUNK(895)
IMPL_THUNK(896)
IMPL_THUNK(897)
IMPL_THUNK(898)
IMPL_THUNK(899)
IMPL_THUNK(900)
IMPL_THUNK(901)
IMPL_THUNK(902)
IMPL_THUNK(903)
IMPL_THUNK(904)
IMPL_THUNK(905)
IMPL_THUNK(906)
IMPL_THUNK(907)
IMPL_THUNK(908)
IMPL_THUNK(909)
IMPL_THUNK(910)
IMPL_THUNK(911)
IMPL_THUNK(912)
IMPL_THUNK(913)
IMPL_THUNK(914)
IMPL_THUNK(915)
IMPL_THUNK(916)
IMPL_THUNK(917)
IMPL_THUNK(918)
IMPL_THUNK(919)
IMPL_THUNK(920)
IMPL_THUNK(921)
IMPL_THUNK(922)
IMPL_THUNK(923)
IMPL_THUNK(924)
IMPL_THUNK(925)
IMPL_THUNK(926)
IMPL_THUNK(927)
IMPL_THUNK(928)
IMPL_THUNK(929)
IMPL_THUNK(930)
IMPL_THUNK(931)
IMPL_THUNK(932)
IMPL_THUNK(933)
IMPL_THUNK(934)
IMPL_THUNK(935)
IMPL_THUNK(936)
IMPL_THUNK(937)
IMPL_THUNK(938)
IMPL_THUNK(939)
IMPL_THUNK(940)
IMPL_THUNK(941)
IMPL_THUNK(942)
IMPL_THUNK(943)
IMPL_THUNK(944)
IMPL_THUNK(945)
IMPL_THUNK(946)
IMPL_THUNK(947)
IMPL_THUNK(948)
IMPL_THUNK(949)
IMPL_THUNK(950)
IMPL_THUNK(951)
IMPL_THUNK(952)
IMPL_THUNK(953)
IMPL_THUNK(954)
IMPL_THUNK(955)
IMPL_THUNK(956)
IMPL_THUNK(957)
IMPL_THUNK(958)
IMPL_THUNK(959)
IMPL_THUNK(960)
IMPL_THUNK(961)
IMPL_THUNK(962)
IMPL_THUNK(963)
IMPL_THUNK(964)
IMPL_THUNK(965)
IMPL_THUNK(966)
IMPL_THUNK(967)
IMPL_THUNK(968)
IMPL_THUNK(969)
IMPL_THUNK(970)
IMPL_THUNK(971)
IMPL_THUNK(972)
IMPL_THUNK(973)
IMPL_THUNK(974)
IMPL_THUNK(975)
IMPL_THUNK(976)
IMPL_THUNK(977)
IMPL_THUNK(978)
IMPL_THUNK(979)
IMPL_THUNK(980)
IMPL_THUNK(981)
IMPL_THUNK(982)
IMPL_THUNK(983)
IMPL_THUNK(984)
IMPL_THUNK(985)
IMPL_THUNK(986)
IMPL_THUNK(987)
IMPL_THUNK(988)
IMPL_THUNK(989)
IMPL_THUNK(990)
IMPL_THUNK(991)
IMPL_THUNK(992)
IMPL_THUNK(993)
IMPL_THUNK(994)
IMPL_THUNK(995)
IMPL_THUNK(996)
IMPL_THUNK(997)
IMPL_THUNK(998)
IMPL_THUNK(999)
IMPL_THUNK(1000)
IMPL_THUNK(1001)
IMPL_THUNK(1002)
IMPL_THUNK(1003)
IMPL_THUNK(1004)
IMPL_THUNK(1005)
IMPL_THUNK(1006)
IMPL_THUNK(1007)
IMPL_THUNK(1008)
IMPL_THUNK(1009)
IMPL_THUNK(1010)
IMPL_THUNK(1011)
IMPL_THUNK(1012)
IMPL_THUNK(1013)
IMPL_THUNK(1014)
IMPL_THUNK(1015)
IMPL_THUNK(1016)
IMPL_THUNK(1017)
IMPL_THUNK(1018)
IMPL_THUNK(1019)
IMPL_THUNK(1020)
IMPL_THUNK(1021)
IMPL_THUNK(1022)
IMPL_THUNK(1023)
IMPL_THUNK(1024)

#endif

__declspec(selectany) GUID CComModule::m_libid = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
        _ATL_CREATORFUNC* pfnCreateInstance;
        const IID* piid;
        HANDLE hEvent;
        LPSTREAM pStream;
        HRESULT hRes;
};

class CComApartment
{
public:
        CComApartment()
        {
                m_nLockCnt = 0;
        }
        static UINT ATL_CREATE_OBJECT;
        static DWORD WINAPI _Apartment(void* pv)
        {
                ATLASSERT(pv != NULL);
                return ((CComApartment*)pv)->Apartment();
        }
        DWORD Apartment()
        {
                CoInitialize(NULL);
                MSG msg;
                while(GetMessage(&msg, 0, 0, 0))
                {
                        if (msg.message == ATL_CREATE_OBJECT)
                        {
                                _AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
                                IUnknown* pUnk = NULL;
                                pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
                                if (SUCCEEDED(pdata->hRes))
                                        pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
                                if (SUCCEEDED(pdata->hRes))
                                {
                                        pUnk->Release();
                                        ATLTRACE2(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
                                }
                                SetEvent(pdata->hEvent);
                        }
                        DispatchMessage(&msg);
                }
                CoUninitialize();
                return 0;
        }
        LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
        LONG Unlock(){return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
        }
        LONG GetLockCount() {return m_nLockCnt;}

        DWORD m_dwThreadID;
        HANDLE m_hThread;
        LONG m_nLockCnt;
};

__declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;

class CComSimpleThreadAllocator
{
public:
        CComSimpleThreadAllocator()
        {
                m_nThread = 0;
        }
        int GetThread(CComApartment* /*pApt*/, int nThreads)
        {
                if (++m_nThread == nThreads)
                        m_nThread = 0;
                return m_nThread;
        }
        int m_nThread;
};

template <class ThreadAllocator = CComSimpleThreadAllocator>
class CComAutoThreadModule : public CComModule
{
public:
        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL, int nThreads = GetDefaultThreads());
        ~CComAutoThreadModule();
        HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj);
        LONG Lock();
        LONG Unlock();
        DWORD dwThreadID;
        int m_nThreads;
        CComApartment* m_pApartments;
        ThreadAllocator m_Allocator;
        static int GetDefaultThreads()
        {
                SYSTEM_INFO si;
                GetSystemInfo(&si);
                return si.dwNumberOfProcessors * 4;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
        BSTR m_str;
        CComBSTR()
        {
                m_str = NULL;
        }
        /*explicit*/ CComBSTR(int nSize)
        {
                m_str = ::SysAllocStringLen(NULL, nSize);
        }
        /*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
        {
                m_str = ::SysAllocStringLen(sz, nSize);
        }
        /*explicit*/ CComBSTR(LPCOLESTR pSrc)
        {
                m_str = ::SysAllocString(pSrc);
        }
        /*explicit*/ CComBSTR(const CComBSTR& src)
        {
                m_str = src.Copy();
        }
        /*explicit*/ CComBSTR(REFGUID src)
        {
                LPOLESTR szGuid;
                StringFromCLSID(src, &szGuid);
                m_str = ::SysAllocString(szGuid);
                CoTaskMemFree(szGuid);
        }
        CComBSTR& operator=(const CComBSTR& src)
        {
                if (m_str != src.m_str)
                {
                        if (m_str)
                                ::SysFreeString(m_str);
                        m_str = src.Copy();
                }
                return *this;
        }

        CComBSTR& operator=(LPCOLESTR pSrc)
        {
                ::SysFreeString(m_str);
                m_str = ::SysAllocString(pSrc);
                return *this;
        }

        ~CComBSTR()
        {
                ::SysFreeString(m_str);
        }
        unsigned int Length() const
        {
                return (m_str == NULL)? 0 : SysStringLen(m_str);
        }
        operator BSTR() const
        {
                return m_str;
        }
        BSTR* operator&()
        {
                return &m_str;
        }
        BSTR Copy() const
        {
                return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
        }
        HRESULT CopyTo(BSTR* pbstr)
        {
                ATLASSERT(pbstr != NULL);
                if (pbstr == NULL)
                        return E_POINTER;
                *pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
                if (*pbstr == NULL)
                        return E_OUTOFMEMORY;
                return S_OK;
        }
        void Attach(BSTR src)
        {
                ATLASSERT(m_str == NULL);
                m_str = src;
        }
        BSTR Detach()
        {
                BSTR s = m_str;
                m_str = NULL;
                return s;
        }
        void Empty()
        {
                ::SysFreeString(m_str);
                m_str = NULL;
        }
        bool operator!() const
        {
                return (m_str == NULL);
        }
        HRESULT Append(const CComBSTR& bstrSrc)
        {
                return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
        }
        HRESULT Append(LPCOLESTR lpsz)
        {
                return Append(lpsz, ocslen(lpsz));
        }
        // a BSTR is just a LPCOLESTR so we need a special version to signify
        // that we are appending a BSTR
        HRESULT AppendBSTR(BSTR p)
        {
                return Append(p, SysStringLen(p));
        }
        HRESULT Append(LPCOLESTR lpsz, int nLen)
        {
                if(lpsz == NULL)
                {
                        if(nLen != 0)
                                return E_INVALIDARG;
                        else
                                return S_OK;
                }
                        
                int n1 = Length();
                BSTR b;
                b = ::SysAllocStringLen(NULL, n1+nLen);
                if (b == NULL)
                        return E_OUTOFMEMORY;

                if(m_str != NULL)
                        memcpy(b, m_str, n1*sizeof(OLECHAR));
                        
                memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
                b[n1+nLen] = NULL;
                SysFreeString(m_str);
                m_str = b;
                return S_OK;
        }
        HRESULT ToLower()
        {
                if (m_str != NULL)
                {
#ifdef _UNICODE                        
                        CharLower(m_str);
#else
                        USES_CONVERSION_EX;
                        LPSTR pszA = OLE2A_EX(m_str, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                        if(pszA == NULL) 
                                return E_OUTOFMEMORY;

                        CharLower(pszA);
                        BSTR b = A2BSTR_EX(pszA);
                        if(b == NULL) 
                                return E_OUTOFMEMORY;
                        SysFreeString(m_str);
                        m_str = b;
#endif        // _UNICODE                        
                }
                return S_OK;
        }
        HRESULT ToUpper()
        {
                if (m_str != NULL)
                {
#ifdef _UNICODE                        
                        CharUpper(m_str);
#else
                        USES_CONVERSION_EX;
                        LPSTR pszA = OLE2A_EX(m_str, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                        if(pszA == NULL) 
                                return E_OUTOFMEMORY;

                        CharUpper(pszA);
                        BSTR b = A2BSTR_EX(pszA);
                        if(b == NULL) 
                                return E_OUTOFMEMORY;
                        SysFreeString(m_str);
                        m_str = b;
#endif        // _UNICODE                        
                }
                return S_OK;
        }
        bool LoadString(HINSTANCE hInst, UINT nID)
        {
                Empty();
                
                TCHAR sz[513];
                UINT nLen = ::LoadString(hInst, nID, sz, 512);
                if(nLen == 0)
                        return false;
                
                if(nLen == 511)
                {
                        nLen = ::LoadString(hInst, nID, sz, 513);
                        if(nLen == 512)
                        {
                                // String too long to fit in the buffer
                                ATLASSERT(FALSE); 
                                return false;
                        }
                }
                
                USES_CONVERSION_EX;
                LPOLESTR p = T2OLE_EX(sz,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                if(p == NULL)
                {
                        ATLASSERT(FALSE);
                        return false;
                }
#endif                
                m_str = SysAllocString(p);
                return (m_str != NULL);
        }
        bool LoadString(UINT nID)
        {
                return LoadString(_pModule->m_hInstResource, nID);
        }

        CComBSTR& operator+=(const CComBSTR& bstrSrc)
        {
                AppendBSTR(bstrSrc.m_str);
                return *this;
        }
        bool operator<(BSTR bstrSrc) const
        {
                if (bstrSrc == NULL && m_str == NULL)
                        return false;
                if (bstrSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, bstrSrc) < 0;
                return m_str == NULL;
        }
        bool operator==(BSTR bstrSrc) const
        {
                if (bstrSrc == NULL && m_str == NULL)
                        return true;
                if (bstrSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, bstrSrc) == 0;
                return false;
        }
        bool operator<(LPCSTR pszSrc) const
        {
                if (pszSrc == NULL && m_str == NULL)
                        return false;

                if (pszSrc != NULL && m_str != NULL)
                {
                        USES_CONVERSION_EX;
                        LPWSTR p = A2W_EX(pszSrc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                        if(p == NULL)
                                _AtlRaiseException((DWORD)STATUS_NO_MEMORY);
                        return wcscmp(m_str, p) < 0;
                }

                return m_str == NULL;
        }
        bool operator==(LPCSTR pszSrc) const
        {
                if (pszSrc == NULL && m_str == NULL)
                        return true;

                if (pszSrc != NULL && m_str != NULL)
                {
                        USES_CONVERSION_EX;
                        LPWSTR p = A2W_EX(pszSrc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                        if(p == NULL)
                                _AtlRaiseException((DWORD)STATUS_NO_MEMORY);
                        return wcscmp(m_str, p) == 0;
                }
                return false;
        }
#ifndef OLE2ANSI
        CComBSTR(LPCSTR pSrc)
        {
                m_str = A2WBSTR(pSrc);
        }

        CComBSTR(int nSize, LPCSTR sz)
        {
                m_str = A2WBSTR(sz, nSize);
        }

        HRESULT Append(LPCSTR lpsz)
        {
                USES_CONVERSION_EX;
                LPCOLESTR lpo = A2COLE_EX(lpsz, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                if(lpo == NULL) 
                        return E_OUTOFMEMORY;
                return Append(lpo, ocslen(lpo));
        }

        CComBSTR& operator=(LPCSTR pSrc)
        {
                ::SysFreeString(m_str);
                m_str = A2WBSTR(pSrc);
                return *this;
        }
#endif
        HRESULT WriteToStream(IStream* pStream)
        {
                ATLASSERT(pStream != NULL);
                
                if(pStream == NULL)
                        return E_INVALIDARG;
                        
                ULONG cb;
                ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+(ULONG)sizeof(OLECHAR) : 0;
                HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
                if (FAILED(hr))
                        return hr;
                return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
        }
        HRESULT ReadFromStream(IStream* pStream)
        {
                ATLASSERT(pStream != NULL);
                
                if(pStream == NULL)
                        return E_INVALIDARG;
                        
                ATLASSERT(m_str == NULL); // should be empty
                Empty();
                
                ULONG cbStrLen = 0;
                HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
                if ((hr == S_OK) && (cbStrLen != 0))
                {
                        //subtract size for terminating NULL which we wrote out
                        //since SysAllocStringByteLen overallocates for the NULL
        
                        m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
                        if (m_str == NULL)
                                hr = E_OUTOFMEMORY;
                        else
                                hr = pStream->Read((void*) m_str, cbStrLen, NULL);
                }
                if (hr == S_FALSE)
                        hr = E_FAIL;
                return hr;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
        CComVariant()
        {
                vt = VT_EMPTY;
        }
        ~CComVariant()
        {
                Clear();
        }

        CComVariant(const VARIANT& varSrc)
        {
                vt = VT_EMPTY;
                InternalCopy(&varSrc);
        }

        CComVariant(const CComVariant& varSrc)
        {
                vt = VT_EMPTY;
                InternalCopy(&varSrc);
        }

        CComVariant(BSTR bstrSrc)
        {
                vt = VT_EMPTY;
                *this = bstrSrc;
        }
        CComVariant(LPCOLESTR lpszSrc)
        {
                vt = VT_EMPTY;
                *this = lpszSrc;
        }

#ifndef OLE2ANSI
        CComVariant(LPCSTR lpszSrc)
        {
                vt = VT_EMPTY;
                *this = lpszSrc;
        }
#endif

        CComVariant(bool bSrc)
        {
                vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
                boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
        }

        CComVariant(int nSrc)
        {
                vt = VT_I4;
                lVal = nSrc;
        }
        CComVariant(BYTE nSrc)
        {
                vt = VT_UI1;
                bVal = nSrc;
        }
        CComVariant(short nSrc)
        {
                vt = VT_I2;
                iVal = nSrc;
        }
        CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
        {
                ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
                vt = vtSrc;
                lVal = nSrc;
        }
        CComVariant(float fltSrc)
        {
                vt = VT_R4;
                fltVal = fltSrc;
        }
        CComVariant(double dblSrc)
        {
                vt = VT_R8;
                dblVal = dblSrc;
        }
        CComVariant(CY cySrc)
        {
                vt = VT_CY;
                cyVal.Hi = cySrc.Hi;
                cyVal.Lo = cySrc.Lo;
        }
        CComVariant(IDispatch* pSrc)
        {
                vt = VT_DISPATCH;
                pdispVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (pdispVal != NULL)
                        pdispVal->AddRef();
        }
        CComVariant(IUnknown* pSrc)
        {
                vt = VT_UNKNOWN;
                punkVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (punkVal != NULL)
                        punkVal->AddRef();
        }

// Assignment Operators
public:
        CComVariant& operator=(const CComVariant& varSrc)
        {
                InternalCopy(&varSrc);
                return *this;
        }
        CComVariant& operator=(const VARIANT& varSrc)
        {
                InternalCopy(&varSrc);
                return *this;
        }

        CComVariant& operator=(BSTR bstrSrc)
        {
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(bstrSrc);
                if (bstrVal == NULL && bstrSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }

        CComVariant& operator=(LPCOLESTR lpszSrc)
        {
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(lpszSrc);

                if (bstrVal == NULL && lpszSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }

        #ifndef OLE2ANSI
        CComVariant& operator=(LPCSTR lpszSrc)
        {
                USES_CONVERSION_EX;
                InternalClear();
                vt = VT_BSTR;
                
                bstrVal = ::SysAllocString(A2COLE_EX(lpszSrc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));

                if (bstrVal == NULL && lpszSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }
        #endif

        CComVariant& operator=(bool bSrc)
        {
                if (vt != VT_BOOL)
                {
                        InternalClear();
                        vt = VT_BOOL;
                }
        #pragma warning(disable: 4310) // cast truncates constant value
                boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
        #pragma warning(default: 4310) // cast truncates constant value
                return *this;
        }

        CComVariant& operator=(int nSrc)
        {
                if (vt != VT_I4)
                {
                        InternalClear();
                        vt = VT_I4;
                }
                lVal = nSrc;

                return *this;
        }

        CComVariant& operator=(BYTE nSrc)
        {
                if (vt != VT_UI1)
                {
                        InternalClear();
                        vt = VT_UI1;
                }
                bVal = nSrc;
                return *this;
        }

        CComVariant& operator=(short nSrc)
        {
                if (vt != VT_I2)
                {
                        InternalClear();
                        vt = VT_I2;
                }
                iVal = nSrc;
                return *this;
        }

        CComVariant& operator=(long nSrc)
        {
                if (vt != VT_I4)
                {
                        InternalClear();
                        vt = VT_I4;
                }
                lVal = nSrc;
                return *this;
        }

        CComVariant& operator=(float fltSrc)
        {
                if (vt != VT_R4)
                {
                        InternalClear();
                        vt = VT_R4;
                }
                fltVal = fltSrc;
                return *this;
        }

        CComVariant& operator=(double dblSrc)
        {
                if (vt != VT_R8)
                {
                        InternalClear();
                        vt = VT_R8;
                }
                dblVal = dblSrc;
                return *this;
        }

        CComVariant& operator=(CY cySrc)
        {
                if (vt != VT_CY)
                {
                        InternalClear();
                        vt = VT_CY;
                }
                cyVal.Hi = cySrc.Hi;
                cyVal.Lo = cySrc.Lo;
                return *this;
        }

        CComVariant& operator=(IDispatch* pSrc)
        {
                InternalClear();
                vt = VT_DISPATCH;
                pdispVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (pdispVal != NULL)
                        pdispVal->AddRef();
                return *this;
        }

        CComVariant& operator=(IUnknown* pSrc)
        {
                InternalClear();
                vt = VT_UNKNOWN;
                punkVal = pSrc;

                // Need to AddRef as VariantClear will Release
                if (punkVal != NULL)
                        punkVal->AddRef();
                return *this;
        }


// Comparison Operators
public:
        bool operator==(const VARIANT& varSrc) const
        {
                if (this == &varSrc)
                        return true;

                // Variants not equal if types don't match
                if (vt != varSrc.vt)
                        return false;

                // Check type specific values
                switch (vt)
                {
                        case VT_EMPTY:
                        case VT_NULL:
                                return true;

                        case VT_BOOL:
                                return boolVal == varSrc.boolVal;

                        case VT_UI1:
                                return bVal == varSrc.bVal;

                        case VT_I2:
                                return iVal == varSrc.iVal;

                        case VT_I4:
                                return lVal == varSrc.lVal;

                        case VT_R4:
                                return fltVal == varSrc.fltVal;

                        case VT_R8:
                                return dblVal == varSrc.dblVal;

                        case VT_BSTR:
                                return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
                                                (::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

                        case VT_ERROR:
                                return scode == varSrc.scode;

                        case VT_DISPATCH:
                                return pdispVal == varSrc.pdispVal;

                        case VT_UNKNOWN:
                                return punkVal == varSrc.punkVal;

                        default:
                                ATLASSERT(false);
                                // fall through
                }

                return false;
        }
        bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
        bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_LT;}
        bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_GT;}

// Operations
public:
        HRESULT Clear() { return ::VariantClear(this); }
        HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
        HRESULT Attach(VARIANT* pSrc)
        {
                if(pSrc == NULL)
                        return E_INVALIDARG;
                        
                // Clear out the variant
                HRESULT hr = Clear();
                if (!FAILED(hr))
                {
                        // Copy the contents and give control to CComVariant
                        memcpy(this, pSrc, sizeof(VARIANT));
                        pSrc->vt = VT_EMPTY;
                        hr = S_OK;
                }
                return hr;
        }

        HRESULT Detach(VARIANT* pDest)
        {
                if(pDest == NULL)
                        return E_POINTER;
                        
                // Clear out the variant
                HRESULT hr = ::VariantClear(pDest);
                if (!FAILED(hr))
                {
                        // Copy the contents and remove control from CComVariant
                        memcpy(pDest, this, sizeof(VARIANT));
                        vt = VT_EMPTY;
                        hr = S_OK;
                }
                return hr;
        }

        HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
        {
                VARIANT* pVar = const_cast<VARIANT*>(pSrc);
                // Convert in place if pSrc is NULL
                if (pVar == NULL)
                        pVar = this;
                // Do nothing if doing in place convert and vts not different
                return ::VariantChangeType(this, pVar, 0, vtNew);
        }

        HRESULT WriteToStream(IStream* pStream);
        HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
        HRESULT InternalClear()
        {
                HRESULT hr = Clear();
                ATLASSERT(SUCCEEDED(hr));
                if (FAILED(hr))
                {
                        vt = VT_ERROR;
                        scode = hr;
                }
                return hr;
        }

        void InternalCopy(const VARIANT* pSrc)
        {
                HRESULT hr = Copy(pSrc);
                if (FAILED(hr))
                {
                        vt = VT_ERROR;
                        scode = hr;
                }
        }
};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
        if(pStream == NULL)
                return E_INVALIDARG;
                
        HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
        if (FAILED(hr))
                return hr;

        int cbWrite = 0;
        switch (vt)
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:
                {
                        CComPtr<IPersistStream> spStream;
                        if (punkVal != NULL)
                        {
                                hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
                                if (FAILED(hr))
                                        return hr;
                        }
                        if (spStream != NULL)
                                return OleSaveToStream(spStream, pStream);
                        else
                                return WriteClassStm(pStream, CLSID_NULL);
                }
        case VT_UI1:
        case VT_I1:
                cbWrite = sizeof(BYTE);
                break;
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
                cbWrite = sizeof(short);
                break;
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_INT:
        case VT_UINT:
        case VT_ERROR:
                cbWrite = sizeof(long);
                break;
        case VT_R8:
        case VT_CY:
        case VT_DATE:
                cbWrite = sizeof(double);
                break;
        default:
                break;
        }
        if (cbWrite != 0)
                return pStream->Write((void*) &bVal, cbWrite, NULL);

        CComBSTR bstrWrite;
        CComVariant varBSTR;
        if (vt != VT_BSTR)
        {
                hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
                if (FAILED(hr))
                        return hr;
                bstrWrite = varBSTR.bstrVal;
        }
        else
                bstrWrite = bstrVal;

        return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
        ATLASSERT(pStream != NULL);
        
        if(pStream == NULL)
                return E_INVALIDARG;
                
        HRESULT hr;
        hr = VariantClear(this);
        if (FAILED(hr))
                return hr;
        VARTYPE vtRead;
        hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
        if (hr == S_FALSE)
                hr = E_FAIL;
        if (FAILED(hr))
                return hr;

        vt = vtRead;
        int cbRead = 0;
        switch (vtRead)
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:
                {
                        punkVal = NULL;
                        hr = OleLoadFromStream(pStream,
                                (vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
                                (void**)&punkVal);
                        if (hr == REGDB_E_CLASSNOTREG)
                                hr = S_OK;
                        return S_OK;
                }
        case VT_UI1:
        case VT_I1:
                cbRead = sizeof(BYTE);
                break;
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
                cbRead = sizeof(short);
                break;
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_INT:
        case VT_UINT:
        case VT_ERROR:
                cbRead = sizeof(long);
                break;
        case VT_R8:
        case VT_CY:
        case VT_DATE:
                cbRead = sizeof(double);
                break;
        default:
                break;
        }
        if (cbRead != 0)
        {
                hr = pStream->Read((void*) &bVal, cbRead, NULL);
                if (hr == S_FALSE)
                        hr = E_FAIL;
                return hr;
        }
        CComBSTR bstrRead;

        hr = bstrRead.ReadFromStream(pStream);
        if (FAILED(hr))
                return hr;
        vt = VT_BSTR;
        bstrVal = bstrRead.Detach();
        if (vtRead != VT_BSTR)
                hr = ChangeType(vtRead);
        return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
        CRegKey();
        ~CRegKey();

// Attributes
public:
        operator HKEY() const;
        HKEY m_hKey;

// Operations
public:
        LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
        LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
        LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
        LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

        LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
        static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
                LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

        LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
                LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
                REGSAM samDesired = KEY_ALL_ACCESS,
                LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
                LPDWORD lpdwDisposition = NULL);
        LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
                REGSAM samDesired = KEY_ALL_ACCESS);
        LONG Close();
        HKEY Detach();
        void Attach(HKEY hKey);
        LONG DeleteSubKey(LPCTSTR lpszSubKey);
        LONG RecurseDeleteKey(LPCTSTR lpszKey);
        LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline HKEY CRegKey::Detach()
{
        HKEY hKey = m_hKey;
        m_hKey = NULL;
        return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
        ATLASSERT(m_hKey == NULL);
        m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
        ATLASSERT(m_hKey != NULL);
        return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
        ATLASSERT(m_hKey != NULL);
        return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close()
{
        LONG lRes = ERROR_SUCCESS;
        if (m_hKey != NULL)
        {
                lRes = RegCloseKey(m_hKey);
                m_hKey = NULL;
        }
        return lRes;
}

inline LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
        LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
        ATLASSERT(hKeyParent != NULL);
        DWORD dw;
        HKEY hKey = NULL;
        LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
                lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
        if (lpdwDisposition != NULL)
                *lpdwDisposition = dw;
        if (lRes == ERROR_SUCCESS)
        {
                lRes = Close();
                m_hKey = hKey;
        }
        return lRes;
}

inline LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
        ATLASSERT(hKeyParent != NULL);
        HKEY hKey = NULL;
        LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
                lRes = Close();
                ATLASSERT(lRes == ERROR_SUCCESS);
                m_hKey = hKey;
        }
        return lRes;
}

inline LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
        DWORD dwType = NULL;
        DWORD dwCount = sizeof(DWORD);
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
                (LPBYTE)&dwValue, &dwCount);
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
        if (dwType != REG_DWORD)
                return ERROR_INVALID_DATA;
        return lRes;
}

inline LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
        ATLASSERT(pdwCount != NULL);
        DWORD dwType = NULL;
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
                (LPBYTE)szValue, pdwCount);
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
                         (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
        switch(dwType)
        {
                case REG_SZ:
                case REG_EXPAND_SZ:
                        if ((*pdwCount) % sizeof(TCHAR) != 0 || (szValue != NULL && szValue[(*pdwCount) / sizeof(TCHAR) -1] != 0))
                                 return ERROR_INVALID_DATA;
                        break;
                case REG_MULTI_SZ:
                        if ((*pdwCount) % sizeof(TCHAR) != 0 || (*pdwCount) / sizeof(TCHAR) < 2 || (szValue != NULL && (szValue[(*pdwCount) / sizeof(TCHAR) -1] != 0 || szValue[(*pdwCount) / sizeof(TCHAR) - 2] != 0)) )
                                return ERROR_INVALID_DATA;
                        break;
                default:
                        return ERROR_INVALID_DATA;
        }
         return lRes;
}

inline LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        CRegKey key;
        LONG lRes = key.Create(hKeyParent, lpszKeyName);
        if (lRes == ERROR_SUCCESS)
                lRes = key.SetValue(lpszValue, lpszValueName);
        return lRes;
}

inline LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        CRegKey key;
        LONG lRes = key.Create(m_hKey, lpszKeyName);
        if (lRes == ERROR_SUCCESS)
                lRes = key.SetValue(lpszValue, lpszValueName);
        return lRes;
}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
        ATLASSERT(m_hKey != NULL);
        return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
                (BYTE * const)&dwValue, sizeof(DWORD));
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        ATLASSERT(m_hKey != NULL);
        return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
                (BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
        CRegKey key;
        LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
                return lRes;
        FILETIME time;
        DWORD dwSize = 256;
        TCHAR szBuffer[256];
        while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
                &time)==ERROR_SUCCESS)
        {
                lRes = key.RecurseDeleteKey(szBuffer);
                if (lRes != ERROR_SUCCESS)
                        return lRes;
                dwSize = 256;
        }
        key.Close();
        return DeleteSubKey(lpszKey);
}

inline HRESULT CComModule::RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
        CRegKey keyProgID;
        LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE);
        if (lRes == ERROR_SUCCESS)
        {
                keyProgID.SetValue(lpszUserDesc);
                keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
                return S_OK;
        }
        return HRESULT_FROM_WIN32(lRes);
}

#ifdef _ATL_STATIC_REGISTRY
}        // namespace ATL

#define _ATL_NAMESPACE_BUG_FIXED

#include <statreg.h>

namespace ATL
{


// Statically linking to Registry Ponent
inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
        struct _ATL_REGMAP_ENTRY* pMapEntries)
{
        USES_CONVERSION_EX;
        ATL::CRegObject ro;
        TCHAR szModule[_MAX_PATH+1] = {0};
        
        // If the ModuleFileName's length is equal or greater than the 3rd parameter
        // (length of the buffer passed),GetModuleFileName fills the buffer (truncates
        // if neccessary), but doesn't null terminate it. It returns the same value as 
        // the 3rd parameter passed. So if the return value is the same as the 3rd param
        // then you have a non null terminated buffer (which may or may not be truncated)
        
        int ret = GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);
        
        if(ret == _MAX_PATH)
                return AtlHresultFromWin32(ERROR_BUFFER_OVERFLOW);
        
        if(ret == 0)
                return AtlHresultFromLastError();
        
        LPOLESTR pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if(pszModule == NULL) 
                return E_OUTOFMEMORY;
#endif

        // Buffer Size is Multiplied by 2 because we are calling ReplaceSingleQuote
        OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2]; 
        ReplaceSingleQuote(pszModuleQuote, pszModule);
        
        HRESULT hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
        if(FAILED(hRes))
                return hRes;
                
        if (NULL != pMapEntries)
        {
                while (NULL != pMapEntries->szKey)
                {
                        ATLASSERT(NULL != pMapEntries->szData);

                        hRes = ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
                        if(FAILED(hRes))
                                return hRes;
                        pMapEntries++;
                }
        }

        LPCOLESTR szType = OLESTR("REGISTRY");
        return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
                        ro.ResourceUnregister(pszModule, nResID, szType);
}

inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
        struct _ATL_REGMAP_ENTRY* pMapEntries)
{
        USES_CONVERSION_EX;
        ATL::CRegObject ro;
        TCHAR szModule[_MAX_PATH+1] = {0};

        // If the ModuleFileName's length is equal or greater than the 3rd parameter
        // (length of the buffer passed),GetModuleFileName fills the buffer (truncates
        // if neccessary), but doesn't null terminate it. It returns the same value as 
        // the 3rd parameter passed. So if the return value is the same as the 3rd param
        // then you have a non null terminated buffer (which may or may not be truncated)
        int ret = GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);
        
        if(ret == _MAX_PATH)
                return AtlHresultFromWin32(ERROR_BUFFER_OVERFLOW);
        
        if(ret == 0)
                return AtlHresultFromLastError();
        
        LPOLESTR pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if(pszModule == NULL) 
                return E_OUTOFMEMORY;
#endif

        // Buffer Size is Multiplied by 2 because we are calling ReplaceSingleQuote
        OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
        ReplaceSingleQuote(pszModuleQuote, pszModule);

        HRESULT hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
        if(FAILED(hRes))
                return hRes;

        if (NULL != pMapEntries)
        {
                while (NULL != pMapEntries->szKey)
                {
                        ATLASSERT(NULL != pMapEntries->szData);
                        hRes = ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
                        if(FAILED(hRes))
                                return hRes;
                        pMapEntries++;
                }
        }

        LPCOLESTR szType = OLESTR("REGISTRY");
        LPCOLESTR pszRes = T2COLE_EX(lpszRes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE        
        if(pszRes == NULL) 
                return E_OUTOFMEMORY;
#endif        
        return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
                        ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif //_ATL_STATIC_REGISTRY

inline HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
        if (bRegister)
        {
                return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
                        dwFlags);
        }
        else
                return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
        static const TCHAR szProgID[] = _T("ProgID");
        static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
        static const TCHAR szLS32[] = _T("LocalServer32");
        static const TCHAR szIPS32[] = _T("InprocServer32");
        static const TCHAR szThreadingModel[] = _T("ThreadingModel");
        static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
        static const TCHAR szApartment[] = _T("Apartment");
        static const TCHAR szBoth[] = _T("both");
        USES_CONVERSION_EX;
        HRESULT hRes = S_OK;
        TCHAR szDesc[256];
        LoadString(m_hInst, nDescID, szDesc, 256);
        
        TCHAR szModule[_MAX_PATH + _ATL_QUOTES_SPACE];

        // If the ModuleFileName's length is equal or greater than the 3rd parameter
        // (length of the buffer passed),GetModuleFileName fills the buffer (truncates
        // if neccessary), but doesn't null terminate it. It returns the same value as 
        // the 3rd parameter passed. So if the return value is the same as the 3rd param
        // then you have a non null terminated buffer (which may or may not be truncated)
        // We pass (szModule + 1) because in case it's an EXE we need to quote the PATH
        // The quote is done later in this method before the SetKeyValue is called
        int ret = GetModuleFileName(m_hInst, szModule + 1, _MAX_PATH);

        if(ret == _MAX_PATH)
                return AtlHresultFromWin32(ERROR_BUFFER_OVERFLOW);
        
        if(ret == 0)
                return AtlHresultFromLastError();

        LPOLESTR lpOleStr;
        hRes = StringFromCLSID(clsid, &lpOleStr);
        if(FAILED(hRes))
        {
                return hRes;
        }
        LPTSTR lpsz = OLE2T_EX(lpOleStr, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if(lpsz == NULL)
        {
                CoTaskMemFree(lpOleStr);
                return E_OUTOFMEMORY;
        }
#endif
        hRes = RegisterProgID(lpsz, lpszProgID, szDesc);
        if (hRes == S_OK)
                hRes = RegisterProgID(lpsz, lpszVerIndProgID, szDesc);
        LONG lRes = ERROR_SUCCESS;
        if (hRes == S_OK)
        {
                CRegKey key;
                lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ | KEY_WRITE);

                if (lRes == ERROR_SUCCESS)
                {
                        lRes = key.Create(key, lpsz, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
                        if (lRes == ERROR_SUCCESS)
                        {
                                key.SetValue(szDesc);
                                key.SetKeyValue(szProgID, lpszProgID);
                                key.SetKeyValue(szVIProgID, lpszVerIndProgID);

                                if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
                                {
                                        // If Registering as an EXE, then we quote the resultant path.
                                        // We don't do it for a DLL, because LoadLibrary fails if the path is
                                        // quoted
                                        szModule[0] = _T('\"');
                                        szModule[ret + 1] = _T('\"');
                                        szModule[ret + 2] = 0;

                                        key.SetKeyValue(szLS32, szModule);
                                }
                                else
                                {
                                        key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule + 1);
                                        LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
                                                (dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
                                        if (lpszModel != NULL)
                                                key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
                                }
                        }
                }
        }
        CoTaskMemFree(lpOleStr);
        if (lRes != ERROR_SUCCESS)
                hRes = HRESULT_FROM_WIN32(lRes);
        return hRes;
}

inline HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID)
{
        USES_CONVERSION_EX;
        CRegKey key;

        key.Attach(HKEY_CLASSES_ROOT);
        if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
                key.RecurseDeleteKey(lpszProgID);
        if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
                key.RecurseDeleteKey(lpszVerIndProgID);
        LPOLESTR lpOleStr;
        HRESULT hRes = StringFromCLSID(clsid, &lpOleStr);
        if(FAILED(hRes))
                return hRes;
                
        LPTSTR lpsz = OLE2T_EX(lpOleStr, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

#ifndef _UNICODE
        if(lpsz == NULL)
        {
                CoTaskMemFree(lpOleStr);
                return E_OUTOFMEMORY;
        }
#endif        
        if (key.Open(key, _T("CLSID"), KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
                key.RecurseDeleteKey(lpsz);
        CoTaskMemFree(lpOleStr);
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer


template <class T>
class CVBufHelper
{
public:
        virtual T* operator()(T* pCurrent) {return pCurrent;}
};

template <class T>
class CVirtualBuffer
{
protected:
        CVirtualBuffer() {}
        T* m_pBase;
        T* m_pCurrent;
        T* m_pTop;
        int m_nMaxElements;
public:
        CVirtualBuffer(int nMaxElements)
        {
                if (nMaxElements < 0 || (nMaxElements > (MAXULONG_PTR / sizeof(T)))) {
                        _AtlRaiseException((DWORD)STATUS_NO_MEMORY);
                }
                m_pBase = (T*) VirtualAlloc(NULL, sizeof(T) * nMaxElements,
                        MEM_RESERVE, PAGE_READWRITE);
                if(m_pBase == NULL)
                {
                        _AtlRaiseException((DWORD)STATUS_NO_MEMORY);
                }
                m_nMaxElements = nMaxElements;
                m_pTop = m_pCurrent = m_pBase;
                // Commit first page - chances are this is all that will be used
                VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
        }
        ~CVirtualBuffer()
        {
                VirtualFree(m_pBase, 0, MEM_RELEASE);
        }
        int Except(LPEXCEPTION_POINTERS lpEP)
        {
                EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
                if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
                        return EXCEPTION_CONTINUE_SEARCH;
                BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];

                if ((pAddress >= (LPBYTE)m_pBase) || (pAddress < (LPBYTE)(&m_pBase[m_nMaxElements]))) {
                    VirtualAlloc(pAddress, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
                    return EXCEPTION_CONTINUE_EXECUTION;
                } else {
                    return EXCEPTION_CONTINUE_SEARCH;
                }

        }
        void Seek(int nElement)
        {
                if(nElement < 0 || nElement >= m_nMaxElements)
                        _AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);                
                        
                m_pCurrent = &m_pBase[nElement];
        }
        void SetAt(int nElement, const T& Element)
        {
                if(nElement < 0 || nElement >= m_nMaxElements)
                        _AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);                
                __try
                {
                        T* p = &m_pBase[nElement];
                        *p = Element;
                        m_pTop = p > m_pTop ? p : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }

        }
        template <class Q>
        void WriteBulk(Q& helper)
        {
                __try
                {
                        m_pCurrent = helper(m_pBase);
                        m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }
        }
        void Write(const T& Element)
        {
            if (m_pCurrent < &m_pBase[m_nMaxElements]) {
                __try
                {
                    *m_pCurrent = Element;
                    m_pCurrent++;
                    m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop; 
                }
                __except(Except(GetExceptionInformation()))
                {
                }
            }
        }
        T& Read()
        {
                return *m_pCurrent;
        }
        operator BSTR()
        {
                BSTR bstrTemp = NULL ;
                __try
                {
                        bstrTemp = SysAllocStringByteLen((char*) m_pBase,
                                (UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
                }
                __except(Except(GetExceptionInformation()))
                {
                }
                return bstrTemp;
        }
        const T& operator[](int nElement) const
        {
                if(nElement < 0 || nElement >= m_nMaxElements)
                        _AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);                
        
                return m_pBase[nElement];
        }
        operator T*()
        {
                return m_pBase;
        }
};

typedef CVirtualBuffer<BYTE> CVirtualBytes;


inline HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
        if (atlTraceQI & ATL_TRACE_CATEGORY)
        {
                USES_CONVERSION_EX;
                CRegKey key;
                TCHAR szName[100];
                DWORD dwType,dw = sizeof(szName);

                LPOLESTR pszGUID = NULL;
                if(FAILED(StringFromCLSID(iid, &pszGUID)))
                {
                        return hr;
                }
                
                OutputDebugString(pszClassName);
                OutputDebugString(_T(" - "));

                // Attempt to find it in the interfaces section
                key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ);
                LPTSTR lpszGUID = OLE2T_EX(pszGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                if(lpszGUID == NULL)
                {
                        CoTaskMemFree(pszGUID);
                        return hr;
                }
#endif
                if (key.Open(key, lpszGUID, KEY_READ) == S_OK)
                {
                        *szName = 0;
                        RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
                        OutputDebugString(szName);
                        goto cleanup;
                }
                // Attempt to find it in the clsid section
                key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
                if (key.Open(key, lpszGUID, KEY_READ) == S_OK)
                {
                        *szName = 0;
                        RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
                        OutputDebugString(_T("(CLSID\?\?\?) "));
                        OutputDebugString(szName);
                        goto cleanup;
                }
                OutputDebugString(lpszGUID);
        cleanup:                
                if (hr != S_OK)
                        OutputDebugString(_T(" - failed"));
                OutputDebugString(_T("\n"));

                CoTaskMemFree(pszGUID);
        }
        return hr;
}

#pragma pack(pop)

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG       0x037F

}; //namespace ATL
using namespace ATL;

//only pull in definition if static linking
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLBASE_IMPL
#endif
#endif

#ifdef _ATL_REDEF_NEW
#pragma pop_macro("new")
#undef _ATL_REDEF_NEW
#endif

#endif // __ATLBASE_H__

//All exports go here
#ifdef _ATLBASE_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
        ATLASSERT(lpszPathName != NULL);
        
        if(lpszPathName == NULL)
                return 0;
                
        // always capture the complete file name including extension (if present)
        LPCOLESTR lpszTemp = lpszPathName;
        for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
        {
                LPCOLESTR lp = CharNextO(lpsz);
                // remember last directory/drive separator
                if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
                        lpszTemp = lp;
                lpsz = lp;
        }

        return UINT(lpszTemp-lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLINLINE ATLAPI AtlInternalQueryInterface(void* pThis,
        const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
        ATLASSERT(pThis != NULL);
        ATLASSERT(pEntries!= NULL);
        
        if(pThis == NULL || pEntries == NULL)
                return E_INVALIDARG ;
                
        // First entry in the com map should be a simple map entry
        ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
        if (ppvObject == NULL)
                return E_POINTER;
        *ppvObject = NULL;
        if (InlineIsEqualUnknown(iid)) // use first interface
        {
                        IUnknown* pUnk = (IUnknown*)((DWORD_PTR)pThis+pEntries->dw);
                        pUnk->AddRef();
                        *ppvObject = pUnk;
                        return S_OK;
        }
        while (pEntries->pFunc != NULL)
        {
                BOOL bBlind = (pEntries->piid == NULL);
                if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
                {
                        if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
                        {
                                ATLASSERT(!bBlind);
                                IUnknown* pUnk = (IUnknown*)((DWORD_PTR)pThis+pEntries->dw);
                                pUnk->AddRef();
                                *ppvObject = pUnk;
                                return S_OK;
                        }
                        else //actual function call
                        {
                                HRESULT hRes = pEntries->pFunc(pThis,
                                        iid, ppvObject, pEntries->dw);
                                if (hRes == S_OK || (!bBlind && FAILED(hRes)))
                                        return hRes;
                        }
                }
                pEntries++;
        }
        return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLINLINE ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
        if(pp == NULL)
                return NULL;
                
        if (lp != NULL)
                lp->AddRef();
        
        if (*pp)
                (*pp)->Release();
        *pp = lp;
        return lp;
}

ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
        if(pp == NULL)
                return NULL;
                
        IUnknown* pTemp = *pp;
        *pp = NULL;
        if (lp != NULL)
                lp->QueryInterface(riid, (void**)pp);
        if (pTemp)
                pTemp->Release();
        return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

//This API should be called from the same thread that called
//AtlMarshalPtrInProc
ATLINLINE ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
        if (pStream != NULL)
        {
                LARGE_INTEGER l;
                l.QuadPart = 0;
                pStream->Seek(l, STREAM_SEEK_SET, NULL);
                CoReleaseMarshalData(pStream);
                pStream->Release();
        }
        return S_OK;
}

ATLINLINE ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
        _ATL_VALIDATE_OUT_POINTER(ppStream);
                
        HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
        if (SUCCEEDED(hRes))
        {
                hRes = CoMarshalInterface(*ppStream, iid,
                        pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
                if (FAILED(hRes))
                {
                        (*ppStream)->Release();
                        *ppStream = NULL;
                }
        }
        return hRes;
}

ATLINLINE ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
        _ATL_VALIDATE_OUT_POINTER(ppUnk);
                
        *ppUnk = NULL;
        HRESULT hRes = E_INVALIDARG;
        if (pStream != NULL)
        {
                LARGE_INTEGER l;
                l.QuadPart = 0;
                pStream->Seek(l, STREAM_SEEK_SET, NULL);
                hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
        }
        return hRes;
}

ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
        DWORD dwRet;
        MSG msg;

        while(1)
        {
                dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

                if (dwRet == WAIT_OBJECT_0)
                        return TRUE;    // The event was signaled

                if (dwRet != WAIT_OBJECT_0 + 1)
                        break;          // Something else happened

                // There is one or more window message available. Dispatch them
                while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                        if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
                                return TRUE; // Event is now signaled.
                }
        }
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLINLINE ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
        if(pUnkCP == NULL)
                return E_INVALIDARG;
                
        CComPtr<IConnectionPointContainer> pCPC;
        CComPtr<IConnectionPoint> pCP;
        HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
        if (SUCCEEDED(hRes))
                hRes = pCPC->FindConnectionPoint(iid, &pCP);
        if (SUCCEEDED(hRes))
                hRes = pCP->Advise(pUnk, pdw);
        return hRes;
}

ATLINLINE ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
        if(pUnkCP == NULL)
                return E_INVALIDARG;
                
        CComPtr<IConnectionPointContainer> pCPC;
        CComPtr<IConnectionPoint> pCP;
        HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
        if (SUCCEEDED(hRes))
                hRes = pCPC->FindConnectionPoint(iid, &pCP);
        if (SUCCEEDED(hRes))
                hRes = pCP->Unadvise(dw);
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
        LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
        USES_CONVERSION_EX;
        TCHAR szDesc[1024];
        szDesc[0] = NULL;
        // For a valid HRESULT the id should be in the range [0x0200, 0xffff]
        if (IS_INTRESOURCE(lpszDesc)) //id
        {
                UINT nID = LOWORD((DWORD_PTR)lpszDesc);
                ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
                if (LoadString(hInst, nID, szDesc, 1024) == 0)
                {
                        ATLASSERT(FALSE);
                        lstrcpy(szDesc, _T("Unknown Error"));
                }
                lpszDesc = T2OLE_EX(szDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                if(lpszDesc == NULL) 
                        return E_OUTOFMEMORY;
#endif                        
                if (hRes == 0)
                        hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
        }

        CComPtr<ICreateErrorInfo> pICEI;
        if (SUCCEEDED(CreateErrorInfo(&pICEI)))
        {
                CComPtr<IErrorInfo> pErrorInfo;
                pICEI->SetGUID(iid);
                LPOLESTR lpsz;
                ProgIDFromCLSID(clsid, &lpsz);
                if (lpsz != NULL)
                        pICEI->SetSource(lpsz);
                if (dwHelpID != 0 && lpszHelpFile != NULL)
                {
                        pICEI->SetHelpContext(dwHelpID);
                        pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
                }
                CoTaskMemFree(lpsz);
                pICEI->SetDescription((LPOLESTR)lpszDesc);
                if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
                        SetErrorInfo(0, pErrorInfo);
        }
        return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module

struct _ATL_MODULE20
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        CRITICAL_SECTION m_csTypeInfoHolder;
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
};

typedef _ATL_MODULE _ATL_MODULE30;

struct _ATL_OBJMAP_ENTRY20
{
        const CLSID* pclsid;
        HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
        _ATL_CREATORFUNC* pfnGetClassObject;
        _ATL_CREATORFUNC* pfnCreateInstance;
        IUnknown* pCF;
        DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
};

typedef _ATL_OBJMAP_ENTRY _ATL_OBJMAP_ENTRY30;

inline _ATL_OBJMAP_ENTRY* _NextObjectMapEntry(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* pEntry)
{
        if (pM->cbSize == sizeof(_ATL_MODULE20))
                return (_ATL_OBJMAP_ENTRY*)(((BYTE*)pEntry) + sizeof(_ATL_OBJMAP_ENTRY20));
        return pEntry+1;
}

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLINLINE ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
#ifdef _ATL_DLL_IMPL
        if ((pM->cbSize != _nAtlModuleVer21Size) && (pM->cbSize != _nAtlModuleVer30Size) &&
                (pM->cbSize != sizeof(_ATL_MODULE)))
                return E_INVALIDARG;
#else
        ATLASSERT(pM->cbSize == sizeof(_ATL_MODULE));
#endif
        pM->m_pObjMap = p;
        pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
        pM->m_nLockCnt=0L;
        pM->m_hHeap = NULL;
        __try {
            InitializeCriticalSection(&pM->m_csTypeInfoHolder);
        } __except (GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            return STATUS_NO_MEMORY;
        }

        __try {
            InitializeCriticalSection(&pM->m_csWindowCreate);
        } __except (GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            DeleteCriticalSection(&pM->m_csTypeInfoHolder);
            return STATUS_NO_MEMORY;
        }

        __try {
            InitializeCriticalSection(&pM->m_csObjMap);
        } __except (GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            DeleteCriticalSection(&pM->m_csTypeInfoHolder);
            DeleteCriticalSection(&pM->m_csWindowCreate);
            return STATUS_NO_MEMORY;
        }
#ifdef _ATL_DLL_IMPL
        if (pM->cbSize > _nAtlModuleVer21Size)
#endif
        {
                pM->m_pCreateWndList = NULL;
                pM->m_bDestroyHeap = true;
                pM->m_dwHeaps = 0;
                pM->m_nHeap = 0;
                pM->m_phHeaps = NULL;
                pM->m_pTermFuncs = NULL;
                if (pM->m_pObjMap != NULL)
                {
                        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
                        while (pEntry->pclsid != NULL)
                        {
                                pEntry->pfnObjectMain(true); //initialize class resources
                                pEntry = _NextObjectMapEntry(pM, pEntry);
                        }
                }
        }
#ifdef _ATL_DLL_IMPL
        if (pM->cbSize > _nAtlModuleVer30Size)
#endif
        {
#if _ATL_VER > 0x0300
                pM->m_nNextWindowID = 1;
#endif
        }

        return S_OK;
}

ATLINLINE ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        if(pM->m_pObjMap == NULL)
                return S_OK;
                
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        while (pEntry->pclsid != NULL && hRes == S_OK)
        {
                hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }

        return hRes;
}

ATLINLINE ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        if(pM->m_pObjMap == NULL)
                return S_OK;
                
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        while (pEntry->pclsid != NULL && hRes == S_OK)
        {
                hRes = pEntry->RevokeClassObject();
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }

        return hRes;
}

ATLINLINE ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);

        if(pM->m_pObjMap == NULL)
                return CLASS_E_CLASSNOTAVAILABLE;
                
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        if (ppv == NULL)
                return E_POINTER;
        *ppv = NULL;

        while (pEntry->pclsid != NULL)
        {
                if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
                {
                        if (pEntry->pCF == NULL)
                        {
                                EnterCriticalSection(&pM->m_csObjMap);
                                __try
                                {
                                        if (pEntry->pCF == NULL)
                                                hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
                                }
                                __finally
                                {
                                        LeaveCriticalSection(&pM->m_csObjMap);
                                }
                        }
                        if (pEntry->pCF != NULL)
                                hRes = pEntry->pCF->QueryInterface(riid, ppv);
                        break;
                }
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }

        if (*ppv == NULL && hRes == S_OK)
                hRes = CLASS_E_CLASSNOTAVAILABLE;
        return hRes;
}

ATLINLINE ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        if (pM->m_pObjMap != NULL)
        {
                _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
                while (pEntry->pclsid != NULL)
                {
                        if (pEntry->pCF != NULL)
                                pEntry->pCF->Release();
                        pEntry->pCF = NULL;
#ifdef _ATL_DLL_IMPL
                        if (pM->cbSize > _nAtlModuleVer21Size)
#endif
                                pEntry->pfnObjectMain(false); //cleanup class resources
                        pEntry = _NextObjectMapEntry(pM, pEntry);
                }
        }
        DeleteCriticalSection(&pM->m_csTypeInfoHolder);
        DeleteCriticalSection(&pM->m_csWindowCreate);
        DeleteCriticalSection(&pM->m_csObjMap);

#ifdef _ATL_DLL_IMPL
        if (pM->cbSize > _nAtlModuleVer21Size)
#endif
        {
                _ATL_TERMFUNC_ELEM* pElem = pM->m_pTermFuncs;
                _ATL_TERMFUNC_ELEM* pNext = NULL;
                while (pElem != NULL)
                {
                        pElem->pFunc(pElem->dw);
                        pNext = pElem->pNext;
                        delete pElem;
                        pElem = pNext;
                }
                if (pM->m_hHeap != NULL && pM->m_bDestroyHeap)
                {
#ifndef _ATL_NO_MP_HEAP
                        if (pM->m_phHeaps != NULL)
                        {
                                for (DWORD i = 0; i <= pM->m_dwHeaps; i++)
                                {
                                        if (pM->m_phHeaps[i] != NULL)
                                                HeapDestroy(pM->m_phHeaps[i]);
                                }
                        }
#endif
                        HeapDestroy(pM->m_hHeap);
                }
        }
        return S_OK;
}

ATLINLINE ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD_PTR dw)
{
        if (pM == NULL)
                return E_INVALIDARG;
                
        HRESULT hr = S_OK;
        _ATL_TERMFUNC_ELEM* pNew = NULL;
        ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
        if (pNew == NULL)
                hr = E_OUTOFMEMORY;
        else
        {
                pNew->pFunc = pFunc;
                pNew->dw = dw;
                EnterCriticalSection(&pM->m_csStaticDataInit);
                pNew->pNext = pM->m_pTermFuncs;
                pM->m_pTermFuncs = pNew;
                LeaveCriticalSection(&pM->m_csStaticDataInit);
        }
        return hr;
}

ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid,
   const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister )
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
          return( S_OK );
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
          CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
          // Since not all systems have the category manager installed, we'll allow
          // the registration to succeed even though we didn't register our
          // categories.  If you really want to register categories on a system
          // without the category manager, you can either manually add the
          // appropriate entries to your registry script (.rgs), or you can
          // redistribute comcat.dll.
          return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
          catid = *pEntry->pcatid;
          if( bRegister )
          {
                 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
                 {
                        hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
                           &catid );
                 }
                 else
                 {
                        ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
                        hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
                           &catid );
                 }
                 if( FAILED( hResult ) )
                 {
                        return( hResult );
                 }
          }
          else
          {
                 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
                 {
                        pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
                 }
                 else
                 {
                        ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
                        pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
                 }
          }
          pEntry++;
   }

   return( S_OK );
}

ATLINLINE ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;

        ATLASSERT(pM->m_hInst != NULL);
        ATLASSERT(pM->m_pObjMap != NULL);

        if(pM->m_pObjMap == NULL)
                return S_OK;
                
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
        {
                if (pCLSID == NULL)
                {
                        if (pEntry->pfnGetObjectDescription != NULL &&
                                pEntry->pfnGetObjectDescription() != NULL)
                                        continue;
                }
                else
                {
                        if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
                                continue;
                }
                hRes = pEntry->pfnUpdateRegistry(TRUE);
                if (FAILED(hRes))
                        break;
                if (pM->cbSize == sizeof(_ATL_MODULE))
                {
                        hRes = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
                                pEntry->pfnGetCategoryMap(), TRUE );
                        if (FAILED(hRes))
                                break;
                }
        }
        if (SUCCEEDED(hRes) && bRegTypeLib)
                hRes = AtlModuleRegisterTypeLib(pM, 0);
        return hRes;
}

ATLINLINE ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        ATLASSERT(pM->m_pObjMap != NULL);
        
        if(pM->m_pObjMap == NULL)
                return S_OK;
                
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
        {
                if (pCLSID == NULL)
                {
                        if (pEntry->pfnGetObjectDescription != NULL
                                && pEntry->pfnGetObjectDescription() != NULL)
                                continue;
                }
                else
                {
                        if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
                                continue;
                }
                pEntry->pfnUpdateRegistry(FALSE); //unregister
                if (pM->cbSize == sizeof(_ATL_MODULE) && pEntry->pfnGetCategoryMap != NULL)
                        AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
                                pEntry->pfnGetCategoryMap(), FALSE );
        }
        if (bUnRegTypeLib)
                AtlModuleUnRegisterTypeLib(pM, 0);
        return S_OK;
}

ATLINLINE ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
        return AtlModuleUnregisterServerEx(pM, FALSE, pCLSID);
}

ATLINLINE ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
        BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
        USES_CONVERSION_EX;
        ATLASSERT(pM != NULL);
        
        if(pM == NULL)
                return E_INVALIDARG;
                
        HRESULT hRes = S_OK;
        CComPtr<IRegistrar> p;
        if (pReg != NULL)
                p = pReg;
        else
        {
                hRes = CoCreateInstance(CLSID_Registrar, NULL,
                        CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
        }
        
        if (SUCCEEDED(hRes))
        {
                TCHAR szModule[_MAX_PATH+1] = {0};

                // If the ModuleFileName's length is equal or greater than the 3rd parameter
                // (length of the buffer passed),GetModuleFileName fills the buffer (truncates
                // if neccessary), but doesn't null terminate it. It returns the same value as 
                // the 3rd parameter passed. So if the return value is the same as the 3rd param
                // then you have a non null terminated buffer (which may or may not be truncated)
                int ret = GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);

        if(ret == _MAX_PATH)
                return AtlHresultFromWin32(ERROR_BUFFER_OVERFLOW);
        
        if(ret == 0)
                return AtlHresultFromLastError();

                LPOLESTR pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                if(pszModule == NULL) 
                        return E_OUTOFMEMORY;
#endif
                
                // Buffer Size is Multiplied by 2 because we are calling ReplaceSingleQuote
                OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
                CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
                
                hRes = p->AddReplacement(OLESTR("Module"), pszModuleQuote);
                if(FAILED(hRes))
                        return hRes;

                if (NULL != pMapEntries)
                {
                        while (NULL != pMapEntries->szKey)
                        {
                                ATLASSERT(NULL != pMapEntries->szData);
                                hRes = p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
                                if(FAILED(hRes))
                                        return hRes;
                                pMapEntries++;
                        }
                }
                LPCOLESTR szType = OLESTR("REGISTRY");
                if (DWORD_PTR(lpszRes)<=0xffff)
                {
                        if (bRegister)
                                hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
                        else
                                hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
                }
                else
                {
                        if (bRegister)
                                hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
                        else
                                hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
                }

        }
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

// The argument to LoadTypeLib can be in the form
// ITypeLib *ptlib;
// LoadTypeLib("C:\\Temp\\EXE\\proj1.EXE\\3", &ptlib) 
// This statement loads the type library resource 3 from the file proj1.exe file.
// The #define __ATL_MAX_PATH_PLUS_INDEX takes care of this

#define _ATL_MAX_PATH_PLUS_INDEX (_MAX_PATH + _ATL_TYPELIB_INDEX_LENGTH)

ATLINLINE ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)
{
        _ATL_VALIDATE_OUT_POINTER(pbstrPath);
        _ATL_VALIDATE_OUT_POINTER(ppTypeLib);
                
        ATLASSERT(pM != NULL);
        
        if(pM == NULL)
                return E_INVALIDARG;
                
        USES_CONVERSION_EX;
        ATLASSERT(pM->m_hInstTypeLib != NULL);
        TCHAR szModule[_ATL_MAX_PATH_PLUS_INDEX];
        
        // If the ModuleFileName's length is equal or greater than the 3rd parameter
        // (length of the buffer passed),GetModuleFileName fills the buffer (truncates
        // if neccessary), but doesn't null terminate it. It returns the same value as 
        // the 3rd parameter passed. So if the return value is the same as the 3rd param
        // then you have a non null terminated buffer (which may or may not be truncated)
        int ret = GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH);
        
        if(ret == _MAX_PATH)
                return AtlHresultFromWin32(ERROR_BUFFER_OVERFLOW);
        
        if(ret == 0)
                return AtlHresultFromLastError();
        
        if (lpszIndex != NULL)
        {
                LPCTSTR lpcszIndex = OLE2CT_EX(lpszIndex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                if(lpcszIndex == NULL) 
                        return E_OUTOFMEMORY;
#endif                
                int nIndexLen = lstrlen(lpcszIndex);
                
                if( ret + nIndexLen >= _ATL_MAX_PATH_PLUS_INDEX )
                        return E_FAIL;
                lstrcpy(szModule + ret,lpcszIndex);
        }
        
        LPOLESTR lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if(lpszModule == NULL) 
                return E_OUTOFMEMORY;
#endif        
        HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
        if (!SUCCEEDED(hr))
        {
                // typelib not in module, try <module>.tlb instead
                LPTSTR lpszExt = NULL;
                LPTSTR lpsz;
                
                for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
                {
                        if(*lpsz == _T('\\') || *lpsz == _T('/'))
                        {
                                lpszExt = NULL;
                                continue;
                        }

                        if(*lpsz == _T('.'))
                                lpszExt = lpsz;
                        
                }
                
                if (lpszExt == NULL)
                        lpszExt = lpsz;

                TCHAR szExt[] = _T(".tlb");
                if ((lpszExt - szModule + sizeof(szExt)/sizeof(TCHAR)) > _MAX_PATH)
                        return E_FAIL;
                        
                lstrcpy(lpszExt, szExt);
                lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                if(lpszModule == NULL) 
                        return E_OUTOFMEMORY;
#endif                
                hr = LoadTypeLib(lpszModule, ppTypeLib);
        }
        
        if (SUCCEEDED(hr))
                *pbstrPath = OLE2BSTR(lpszModule);
        
        return hr;
}

ATLINLINE ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
        typedef HRESULT (WINAPI *PFNRTL)(REFGUID, WORD, WORD, LCID, SYSKIND);
        CComBSTR bstrPath;
        CComPtr<ITypeLib> pTypeLib;
        HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
        if (SUCCEEDED(hr))
        {
                TLIBATTR* ptla;
                hr = pTypeLib->GetLibAttr(&ptla);
                if (SUCCEEDED(hr))
                {
                        HINSTANCE h = LoadLibrary(_T("oleaut32.dll"));
                        if (h != NULL)
                        {
                                PFNRTL pfn = (PFNRTL) GetProcAddress(h, "UnRegisterTypeLib");
                                if (pfn != NULL)
                                        hr = pfn(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
                                FreeLibrary(h);
                        }
                        pTypeLib->ReleaseTLibAttr(ptla);
                }
        }
        return hr;
}

ATLINLINE ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
        CComBSTR bstrPath;
        CComPtr<ITypeLib> pTypeLib;
        HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
        
        if (SUCCEEDED(hr))
        {
                OLECHAR szDir[_MAX_PATH];
                
                if(SysStringLen(bstrPath) > _MAX_PATH - 1 )
                        return CO_E_PATHTOOLONG;

                ocscpy(szDir, bstrPath);
                szDir[AtlGetDirLen(szDir)] = 0;
                hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);
        }
        return hr;
}

ATLINLINE ATLAPI_(DWORD) AtlGetVersion(void* /* pReserved */)
{
        return _ATL_VER;
}

ATLINLINE ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject)
{
        if(pData == NULL || pObject == NULL)
                _AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);
                
        pData->m_pThis = pObject;
        pData->m_dwThreadID = ::GetCurrentThreadId();
        ::EnterCriticalSection(&pM->m_csWindowCreate);
        pData->m_pNext = pM->m_pCreateWndList;
        pM->m_pCreateWndList = pData;
        ::LeaveCriticalSection(&pM->m_csWindowCreate);
}

ATLINLINE ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM)
{
        void* pv = NULL;
        ::EnterCriticalSection(&pM->m_csWindowCreate);
        _AtlCreateWndData* pEntry = pM->m_pCreateWndList;
        if(pEntry != NULL)
        {
                DWORD dwThreadID = ::GetCurrentThreadId();
                _AtlCreateWndData* pPrev = NULL;
                while(pEntry != NULL)
                {
                        if(pEntry->m_dwThreadID == dwThreadID)
                        {
                                if(pPrev == NULL)
                                        pM->m_pCreateWndList = pEntry->m_pNext;
                                else
                                        pPrev->m_pNext = pEntry->m_pNext;
                                pv = pEntry->m_pThis;
                                break;
                        }
                        pPrev = pEntry;
                        pEntry = pEntry->m_pNext;
                }
        }
        ::LeaveCriticalSection(&pM->m_csWindowCreate);
        return pv;
}

/////////////////////////////////////////////////////////////////////////////
// General DLL Version Helpers

inline HRESULT AtlGetDllVersion(HINSTANCE hInstDLL, DLLVERSIONINFO* pDllVersionInfo)
{
        ATLASSERT(pDllVersionInfo != NULL);
        if(pDllVersionInfo == NULL)
                return E_INVALIDARG;

        // We must get this function explicitly because some DLLs don't implement it.
        DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");
        if(pfnDllGetVersion == NULL)
                return E_NOTIMPL;

        return (*pfnDllGetVersion)(pDllVersionInfo);
}

inline HRESULT AtlGetDllVersion(LPCTSTR lpstrDllName, DLLVERSIONINFO* pDllVersionInfo)
{
        HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
        if(hInstDLL == NULL)
                return E_FAIL;
        HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
        ::FreeLibrary(hInstDLL);
        return hRet;
}

// Common Control Versions:
//   Win95/WinNT 4.0    maj=4 min=00
//   IE 3.x     maj=4 min=70
//   IE 4.0     maj=4 min=71
inline HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
        ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
        if(pdwMajor == NULL || pdwMinor == NULL)
                return E_INVALIDARG;

        DLLVERSIONINFO dvi;
        ::ZeroMemory(&dvi, sizeof(dvi));
        dvi.cbSize = sizeof(dvi);
        HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);

        if(SUCCEEDED(hRet))
        {
                *pdwMajor = dvi.dwMajorVersion;
                *pdwMinor = dvi.dwMinorVersion;
        }
        else if(hRet == E_NOTIMPL)
        {
                // If DllGetVersion is not there, then the DLL is a version
                // previous to the one shipped with IE 3.x
                *pdwMajor = 4;
                *pdwMinor = 0;
                hRet = S_OK;
        }

        return hRet;
}

// Shell Versions:
//   Win95/WinNT 4.0                    maj=4 min=00
//   IE 3.x, IE 4.0 without Web Integrated Desktop  maj=4 min=00
//   IE 4.0 with Web Integrated Desktop         maj=4 min=71
//   IE 4.01 with Web Integrated Desktop        maj=4 min=72
inline HRESULT AtlGetShellVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
        ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
        if(pdwMajor == NULL || pdwMinor == NULL)
                return E_INVALIDARG;

        DLLVERSIONINFO dvi;
        ::ZeroMemory(&dvi, sizeof(dvi));
        dvi.cbSize = sizeof(dvi);
        HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);

        if(SUCCEEDED(hRet))
        {
                *pdwMajor = dvi.dwMajorVersion;
                *pdwMinor = dvi.dwMinorVersion;
        }
        else if(hRet == E_NOTIMPL)
        {
                // If DllGetVersion is not there, then the DLL is a version
                // previous to the one shipped with IE 4.x
                *pdwMajor = 4;
                *pdwMinor = 0;
                hRet = S_OK;
        }

        return hRet;
}

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time
#undef _ATLBASE_IMPL

#endif // _ATLBASE_IMPL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlconv.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\statreg.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H
#define __STATREG_H

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

const TCHAR  chSemiColon         = _T(';');
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chEscape            = _T('\\');
const TCHAR  chComma             = _T(',');
const TCHAR  chDelete            = _T('~');
const TCHAR  chEOS               = _T('\0');
const TCHAR  chTab               = _T('\t');
const TCHAR  chLF                = _T('\n');
const TCHAR  chCR                = _T('\r');
const TCHAR  chSpace             = _T(' ');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chVarLead           = _T('%');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
//const LPCTSTR  szRightBracket  = _T("}");
//const LPCTSTR  szLeftBracket   = _T("{");
//const LPCTSTR  szEquals            = _T("=");
//const LPCTSTR  szDirSep          = _T("\\");
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");

struct EXPANDER
{
	LPOLESTR    szKey;
	LPOLESTR    szValue;
};

class CExpansionVector
{
public:
	CExpansionVector()
	{
		m_cEls = 0;
		m_nSize=10;
		m_p=(EXPANDER**)malloc(m_nSize*sizeof(EXPANDER*));
	}
	HRESULT Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue);
	LPCOLESTR Find(LPTSTR lpszKey);
	HRESULT ClearReplacements();


private:
	EXPANDER** m_p;
	int m_cEls;
	int m_nSize;
};


#if defined(_ATL_DLL) | defined(_ATL_DLL_IMPL)
class ATL_NO_VTABLE CRegObject
 : public IRegistrar
#else
class CRegObject
#endif
{
public:

	~CRegObject(){ClearReplacements();}
	HRESULT FinalConstruct() {return S_OK;}
	void FinalRelease() {}


	// Map based methods
	HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem);
	HRESULT STDMETHODCALLTYPE ClearReplacements();
	LPCOLESTR StrFromMap(LPTSTR lpszKey);

	// Register via a given mechanism
	HRESULT STDMETHODCALLTYPE ResourceRegister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceRegisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE FileRegister(LPCOLESTR pszFileName);
	HRESULT STDMETHODCALLTYPE FileUnregister(LPCOLESTR pszFileName);
	HRESULT STDMETHODCALLTYPE StringRegister(LPCOLESTR pszData);
	HRESULT STDMETHODCALLTYPE StringUnregister(LPCOLESTR pszData);

protected:

	HRESULT MemMapAndRegister(LPCOLESTR pszFileName, BOOL bRegister);
	HRESULT RegisterFromResource(LPCOLESTR pszFileName, LPCTSTR pszID, LPCTSTR pszType, BOOL bRegister);
	HRESULT RegisterWithString(LPCOLESTR pszData, BOOL bRegister);


	static HRESULT GenerateError(UINT nID);

	CExpansionVector                                m_RepMap;
	CComObjectThreadModel::AutoCriticalSection      m_csMap;
};


class CRegParser
{
public:
	CRegParser(CRegObject* pRegObj);

	HRESULT  PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg);
	HRESULT  RegisterBuffer(LPTSTR szReg, BOOL bRegister);

protected:

	void    SkipWhiteSpace();
	HRESULT NextToken(LPTSTR szToken);
	HRESULT AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken);
	BOOL    CanForceRemoveKey(LPCTSTR szKey);
	BOOL    HasSubKeys(HKEY hkey);
	BOOL    HasValues(HKEY hkey);
	HRESULT RegisterSubkeys(HKEY hkParent, BOOL bRegister, BOOL bInRecovery = FALSE);
	BOOL    IsSpace(TCHAR ch);
	void    IncrementLinePos();
	void    IncrementLineCount(){m_cLines++;}


	LPTSTR  m_pchCur;
	int     m_cLines;

	CRegObject*     m_pRegObj;

	HRESULT GenerateError(UINT nID);
	HRESULT HandleReplacements(LPTSTR& szToken);
	HRESULT SkipAssignment(LPTSTR szToken);

	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }

};

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

#endif //__STATREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\statreg.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////
#define RET_ON_ERROR(x) \
		if (FAILED(hr = x))\
			return hr;
///////////////////////////////////////
#define BREAK_ON_ERROR(x) \
		if (FAILED(hr = x))\
			break;
///////////////////////////////////////
#ifdef _DEBUG
#define REPORT_ERROR(name, func) \
		if (func != ERROR_SUCCESS)\
			ATLTRACE(_T("NON CRITICAL ERROR : %s failed\n"), name);
#define REG_TRACE_RECOVER() \
		if (!bRecover) \
			ATLTRACE(_T("Opened Key %s\n"), szToken); \
		else \
			ATLTRACE(_T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
#else //!_DEBUG
#define REG_TRACE_RECOVER()
#define REPORT_ERROR(name, func) \
		func;
#endif //_DEBUG

///////////////////////////////////////
#define MAX_TYPE            MAX_VALUE
#define MAX_VALUE           4096

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

class CParseBuffer
{
public:
	int nPos;
	int nSize;
	LPTSTR p;
	CParseBuffer(int nInitial);
	~CParseBuffer() {CoTaskMemFree(p);}
	BOOL AddChar(TCHAR ch);
	BOOL AddString(LPCOLESTR lpsz);
	LPTSTR Detach();

};

LPCTSTR   rgszNeverDelete[] = //Component Catagories
{
	_T("CLSID"), _T("TYPELIB")
};

const int   cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);

static LPTSTR StrChr(LPTSTR lpsz, TCHAR ch)
{
	LPTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

static HKEY WINAPI HKeyFromString(LPTSTR szToken)
{
	struct keymap
	{
		LPCTSTR lpsz;
		HKEY hkey;
	};
	static const keymap map[] = {
		{_T("HKCR"), HKEY_CLASSES_ROOT},
		{_T("HKCU"), HKEY_CURRENT_USER},
		{_T("HKLM"), HKEY_LOCAL_MACHINE},
		{_T("HKU"),  HKEY_USERS},
		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
		{_T("HKDD"), HKEY_DYN_DATA},
		{_T("HKCC"), HKEY_CURRENT_CONFIG},
		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
		{_T("HKEY_USERS"), HKEY_USERS},
		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
	};

	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
	{
		if (!lstrcmpi(szToken, map[i].lpsz))
			return map[i].hkey;
	}
	return NULL;
}

static HKEY HKeyFromCompoundString(LPTSTR szToken, LPTSTR& szTail)
{
	if (NULL == szToken)
		return NULL;

	LPTSTR lpsz = StrChr(szToken, chDirSep);

	if (NULL == lpsz)
		return NULL;

	szTail = CharNext(lpsz);
	*lpsz = chEOS;
	HKEY hKey = HKeyFromString(szToken);
	*lpsz = chDirSep;
	return hKey;
}

static LPVOID QueryValue(HKEY hKey, LPCTSTR szValName, DWORD& dwType)
{
	DWORD dwCount = 0;

	if (RegQueryValueEx(hKey, szValName, NULL, &dwType, NULL, &dwCount) != ERROR_SUCCESS)
	{
		ATLTRACE(_T("RegQueryValueEx failed for Value %s\n"), szValName);
		return NULL;
	}

	if (!dwCount)
	{
		ATLTRACE(_T("RegQueryValueEx returned 0 bytes\n"));
		return NULL;
	}

	// Not going to Check for fail on CoTaskMemAlloc & RegQueryValueEx as NULL
	// will be returned regardless if anything failed

	LPVOID pData = CoTaskMemAlloc(dwCount);
	RegQueryValueEx(hKey, szValName, NULL, &dwType, (LPBYTE) pData, &dwCount);
	return pData;
}

/////////////////////////////////////////////////////////////////////////////
//

HRESULT CRegParser::GenerateError(UINT nID)
{
//  m_re.m_nID   = nID;
//  m_re.m_cLines = m_cLines;
	return DISP_E_EXCEPTION;
}


CRegParser::CRegParser(CRegObject* pRegObj)
{
	m_pRegObj           = pRegObj;
	m_pchCur            = NULL;
	m_cLines            = 1;
}

BOOL CRegParser::IsSpace(TCHAR ch)
{
	switch (ch)
	{
		case chSpace:
		case chTab:
		case chCR:
		case chLF:
				return TRUE;
	}

	return FALSE;
}

void CRegParser::IncrementLinePos()
{
	m_pchCur = CharNext(m_pchCur);
	if (chLF == *m_pchCur)
		IncrementLineCount();
}

void CRegParser::SkipWhiteSpace()
{
	while(IsSpace(*m_pchCur))
		IncrementLinePos();
}

HRESULT CRegParser::NextToken(LPTSTR szToken)
{
	USES_CONVERSION;

	UINT ichToken = 0;

	SkipWhiteSpace();

	// NextToken cannot be called at EOS
	if (chEOS == *m_pchCur)
		return GenerateError(E_ATL_UNEXPECTED_EOS);

	// handle quoted value / key
	LPCTSTR szOrig = szToken;
	if (chQuote == *m_pchCur)
	{


		IncrementLinePos(); // Skip Quote

		while (chEOS != *m_pchCur && !EndOfVar())
		{
			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
				IncrementLinePos();   // as it has been escaped

			LPTSTR pchPrev = m_pchCur;
			IncrementLinePos();

			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		if (chEOS == *m_pchCur)
		{
			ATLTRACE(_T("NextToken : Unexpected End of File\n"));
			return GenerateError(E_ATL_UNEXPECTED_EOS);
		}

		*szToken = chEOS;
		IncrementLinePos(); // Skip end quote
	}

	else
	{   // Handle non-quoted ie parse up till first "White Space"
		while (chEOS != *m_pchCur && !IsSpace(*m_pchCur))
		{
			LPTSTR pchPrev = m_pchCur;
			IncrementLinePos();
			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		*szToken = chEOS;
	}
	return S_OK;
}

static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE& vt)
{
	struct typemap
	{
		LPCTSTR lpsz;
		VARTYPE vt;
	};
	static const typemap map[] = {
		{szStringVal, VT_BSTR},
		{szDwordVal,  VT_I4}
	};

	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
	{
		if (!lstrcmpi(szValueType, map[i].lpsz))
		{
			vt = map[i].vt;
			return TRUE;
		}
	}

	return FALSE;

}

HRESULT CRegParser::AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken)
{
	USES_CONVERSION;
	HRESULT hr;

	TCHAR       *szTypeToken;
	VARTYPE     vt;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

    szTypeToken = (TCHAR *)malloc(sizeof(TCHAR)*MAX_TYPE);
    if (!szTypeToken) {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr = NextToken(szTypeToken))) {
        free(szTypeToken);
        return hr;
    }
	if (!VTFromRegType(szTypeToken, vt))
	{
		ATLTRACE(_T("%s Type not supported\n"), szTypeToken);
        free(szTypeToken);
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

	TCHAR *szValue;
    szValue = (TCHAR *)malloc(sizeof(TCHAR) * MAX_VALUE);
    if (!szValue) {
        free(szTypeToken);
        return E_OUTOFMEMORY;
    }
	SkipWhiteSpace();
    
    if (FAILED(hr = NextToken(szValue))) {
        free(szValue);
        free(szTypeToken);
        return hr;
    }

	long lVal;

	switch (vt)
	{
	case VT_BSTR:
		lRes = rkParent.SetValue(szValue, szValueName);
		ATLTRACE(_T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
		break;
	case VT_I4:
		VarI4FromStr(T2OLE(szValue), 0, 0, &lVal);
		lRes = rkParent.SetValue(lVal, szValueName);
		ATLTRACE(_T("Setting Value %d at %s\n"), lVal, !szValueName ? _T("default") : szValueName);
		break;
	}

	if (ERROR_SUCCESS != lRes)
	{
		nIDRes = E_ATL_VALUE_SET_FAILED;
		hr = HRESULT_FROM_WIN32(lRes);
	}

    if (FAILED(hr = NextToken(szToken))) {
        free(szValue);
        free(szTypeToken);
        return hr;
    }
    
    free(szValue);
    free(szTypeToken);

	return S_OK;
}

BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey)
{
	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
			 return FALSE;                       // We cannot delete it

	return TRUE;
}

BOOL CRegParser::HasSubKeys(HKEY hkey)
{
	DWORD       cbSubKeys = 0;

	if (FAILED(RegQueryInfoKey(hkey, NULL, NULL, NULL,
							   &cbSubKeys, NULL, NULL,
							   NULL, NULL, NULL, NULL, NULL)))
	{
		ATLTRACE(_T("Should not be here!!\n"));
		_ASSERTE(FALSE);
		return FALSE;
	}

	return cbSubKeys > 0;
}

BOOL CRegParser::HasValues(HKEY hkey)
{
	DWORD       cbValues = 0;

	LONG lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL,
								  NULL, NULL, NULL,
								  &cbValues, NULL, NULL, NULL, NULL);
	if (ERROR_SUCCESS != lResult)
	{
		ATLTRACE(_T("RegQueryInfoKey Failed "));
		_ASSERTE(FALSE);
		return FALSE;
	}

	if (1 == cbValues)
	{
		DWORD cbData = 0;
		lResult = RegQueryValueEx(hkey, NULL, NULL, NULL, NULL, &cbData);

		if (ERROR_SUCCESS == lResult)
			return !cbData;
		else
			return TRUE;
	}

	return cbValues > 0;
}

HRESULT CRegParser::SkipAssignment(LPTSTR szToken)
{
	HRESULT hr;
	TCHAR szValue[MAX_VALUE];

	if (*szToken == chEquals)
	{
		RET_ON_ERROR(NextToken(szToken))
		// Skip assignment
		SkipWhiteSpace();
		RET_ON_ERROR(NextToken(szValue));
		RET_ON_ERROR(NextToken(szToken))
	}

	return S_OK;
}


HRESULT CRegParser::RegisterSubkeys(HKEY hkParent, BOOL bRegister, BOOL bRecover)
{
	CRegKey keyCur;
	TCHAR   szToken[MAX_VALUE];
	LONG    lRes;
	TCHAR   szKey[MAX_VALUE];
	BOOL    bDelete = TRUE;
	BOOL    bInRecovery = bRecover;
	HRESULT hr = S_OK;

	ATLTRACE(_T("Num Els = %d\n"), cbNeverDelete);
	RET_ON_ERROR(NextToken(szToken))  // Should be key name


	while (*szToken != chRightBracket) // Continue till we see a }
	{
		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)
		{
			BREAK_ON_ERROR(NextToken(szToken))

			if (bRegister)
			{
				CRegKey rkForceRemove;

				if (StrChr(szToken, chDirSep) != NULL)
					return GenerateError(E_ATL_COMPOUND_KEY);

				if (CanForceRemoveKey(szToken))
				{
					rkForceRemove.Attach(hkParent);
					rkForceRemove.RecurseDeleteKey(szToken);
					rkForceRemove.Detach();
				}
				if (bTokenDelete)
				{
					BREAK_ON_ERROR(NextToken(szToken))
					BREAK_ON_ERROR(SkipAssignment(szToken))
					goto EndCheck;
				}
			}

		}

		if (!lstrcmpi(szToken, szNoRemove))
		{
			bDelete = FALSE;    // set even for register
			BREAK_ON_ERROR(NextToken(szToken))
		}

		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
		{
			TCHAR  szValueName[_MAX_PATH];

			BREAK_ON_ERROR(NextToken(szValueName))
			BREAK_ON_ERROR(NextToken(szToken))

			if (*szToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			if (bRegister)
			{
				CRegKey rk;

				rk.Attach(hkParent);
				hr = AddValue(rk, szValueName, szToken);
				rk.Detach();

				if (FAILED(hr))
					return hr;

				goto EndCheck;
			}
			else
			{
				if (!bRecover)
				{
					ATLTRACE(_T("Deleting %s\n"), szValueName);
					REPORT_ERROR(_T("RegDeleteValue"), RegDeleteValue(hkParent, szValueName))
				}

				BREAK_ON_ERROR(SkipAssignment(szToken)) // Strip off type
				continue;  // can never have a subkey
			}
		}

		if (StrChr(szToken, chDirSep) != NULL)
			return GenerateError(E_ATL_COMPOUND_KEY);

		if (bRegister)
		{
			lRes = keyCur.Open(hkParent, szToken, KEY_ALL_ACCESS);
			if (ERROR_SUCCESS != lRes)
			{
				// Failed all access try read only
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
				if (ERROR_SUCCESS != lRes)
				{
					// Finally try creating it
					ATLTRACE(_T("Creating key %s\n"), szToken);
					lRes = keyCur.Create(hkParent, szToken);
					if (ERROR_SUCCESS != lRes)
						return GenerateError(E_ATL_CREATE_KEY_FAILED);
				}
			}

			BREAK_ON_ERROR(NextToken(szToken))

			if (*szToken == chEquals)
				BREAK_ON_ERROR(AddValue(keyCur, NULL, szToken)) // NULL == default
		}
		else
		{
			if (!bRecover && keyCur.Open(hkParent, szToken) != ERROR_SUCCESS)
				bRecover = TRUE;

			// TRACE out Key open status and if in recovery mode
			REG_TRACE_RECOVER()

			// Remember Subkey
			lstrcpyn(szKey, szToken, _MAX_PATH);

			// If in recovery mode

			if (bRecover || HasSubKeys(keyCur) || HasValues(keyCur))
			{
				BREAK_ON_ERROR(NextToken(szToken))
				BREAK_ON_ERROR(SkipAssignment(szToken))

				if (*szToken == chLeftBracket)
				{
					BREAK_ON_ERROR(RegisterSubkeys(keyCur.m_hKey, bRegister, bRecover))
					if (bRecover) // Turn off recovery if we are done
					{
						bRecover = bInRecovery;
						ATLTRACE(_T("Ending Recovery Mode\n"));
						BREAK_ON_ERROR(NextToken(szToken))
						BREAK_ON_ERROR(SkipAssignment(szToken))
						continue;
					}
				}

				if (!bRecover && HasSubKeys(keyCur))
				{
					// See if the KEY is in the NeverDelete list and if so, don't
					if (CanForceRemoveKey(szKey))
					{
						ATLTRACE(_T("Deleting non-empty subkey %s by force\n"), szKey);
						REPORT_ERROR(_T("RecurseDeleteKey"), keyCur.RecurseDeleteKey(szKey))
					}
					BREAK_ON_ERROR(NextToken(szToken))
					continue;
				}

				if (bRecover)
					continue;
			}

			if (!bRecover && keyCur.Close() != ERROR_SUCCESS)
			   return GenerateError(E_ATL_CLOSE_KEY_FAILED);

			if (!bRecover && bDelete)
			{
				ATLTRACE(_T("Deleting Key %s\n"), szKey);
				REPORT_ERROR(_T("RegDeleteKey"), RegDeleteKey(hkParent, szKey))
			}

			BREAK_ON_ERROR(NextToken(szToken))
			BREAK_ON_ERROR(SkipAssignment(szToken))
		}

EndCheck:

		if (bRegister)
		{
			if (*szToken == chLeftBracket)
			{
				BREAK_ON_ERROR(RegisterSubkeys(keyCur.m_hKey, bRegister, FALSE))
				BREAK_ON_ERROR(NextToken(szToken))
			}
		}
	}

	return hr;
}

LPTSTR CParseBuffer::Detach()
{
	LPTSTR lp = p;
	p = NULL;
	return lp;
}

CParseBuffer::CParseBuffer(int nInitial)
{
	nPos = 0;
	nSize = nInitial;
	p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));
    if (!p) {
        nSize = 0;
    }
}

BOOL CParseBuffer::AddString(LPCOLESTR lpsz)
{
	USES_CONVERSION;
	LPCTSTR lpszT = OLE2CT(lpsz);
	while (*lpszT)
	{
		if (!AddChar(*lpszT))
            return FALSE;
		lpszT++;
	}
	return TRUE;
}

BOOL CParseBuffer::AddChar(TCHAR ch)
{
	if (nPos == nSize) // realloc
	{
		p = (LPTSTR) CoTaskMemRealloc(p, nSize*2*sizeof(TCHAR));
        if (p) {
            nSize *= 2;
        } else {
            return FALSE;
        }
	}
	p[nPos++] = ch;
	return TRUE;
}

HRESULT CRegParser::PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg)
{
	USES_CONVERSION;
	_ASSERTE(lpszReg != NULL);
	_ASSERTE(ppszReg != NULL);
	*ppszReg = NULL;
	int nSize = lstrlen(lpszReg)*2;
	CParseBuffer pb(nSize);
	if (pb.p == NULL)
		return E_OUTOFMEMORY;
	m_pchCur = lpszReg;
	HRESULT hr = S_OK;

	while (*m_pchCur != NULL) // look for end
	{
		if (*m_pchCur == _T('%'))
		{
			IncrementLinePos();
			if (*m_pchCur == _T('%'))
				pb.AddChar(*m_pchCur);
			else
			{
				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));
				if (lpszNext == NULL)
				{
					ATLTRACE(_T("Error no closing % found\n"));
					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
					break;
				}
				int nLength = int(lpszNext - m_pchCur);
				if (nLength > 31)
				{
					hr = E_FAIL;
					break;
				}
				TCHAR buf[32];
				lstrcpyn(buf, m_pchCur, nLength+1);
				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);
				if (lpszVar == NULL)
				{
					hr = GenerateError(E_ATL_NOT_IN_MAP);
					break;
				}
				pb.AddString(lpszVar);
				while (m_pchCur != lpszNext)
					IncrementLinePos();
			}
		}
		else
			pb.AddChar(*m_pchCur);
		IncrementLinePos();
	}
	pb.AddChar(NULL);
	if (SUCCEEDED(hr))
		*ppszReg = pb.Detach();
	return hr;
}

HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister)
{
	TCHAR   szToken[_MAX_PATH];
	HRESULT hr = S_OK;

	LPTSTR szReg = NULL;
	hr = PreProcessBuffer(szBuffer, &szReg);
	if (FAILED(hr))
		return hr;

	m_pchCur = szReg;

	// Preprocess szReg

	while (chEOS != *m_pchCur)
	{
		BREAK_ON_ERROR(NextToken(szToken))
		HKEY hkBase;
		if ((hkBase = HKeyFromString(szToken)) == NULL)
		{
			ATLTRACE(_T("HKeyFromString failed on %s\n"), szToken);
			hr = GenerateError(E_ATL_BAD_HKEY);
			break;
		}

		BREAK_ON_ERROR(NextToken(szToken))

		if (chLeftBracket != *szToken)
		{
			ATLTRACE(_T("Syntax error, expecting a {, found a %s\n"), szToken);
			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
			break;
		}
		if (bRegister)
		{
			LPTSTR szRegAtRegister = m_pchCur;
			hr = RegisterSubkeys(hkBase, bRegister);
			if (FAILED(hr))
			{
				ATLTRACE(_T("Failed to register, cleaning up!\n"));
				m_pchCur = szRegAtRegister;
				RegisterSubkeys(hkBase, FALSE);
				break;
			}
		}
		else
		{
			BREAK_ON_ERROR(RegisterSubkeys(hkBase, bRegister))
		}

		SkipWhiteSpace();
	}
	CoTaskMemFree(szReg);
	return hr;
}

HRESULT CExpansionVector::Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;

	EXPANDER* pExpand = NULL;
	ATLTRY(pExpand = new EXPANDER);
	if (pExpand == NULL)
		return E_OUTOFMEMORY;

	DWORD cbKey = (DWORD)((ocslen(lpszKey)+1)*sizeof(OLECHAR));
	DWORD cbValue = (DWORD)((ocslen(lpszValue)+1)*sizeof(OLECHAR));
	pExpand->szKey = (LPOLESTR)CoTaskMemAlloc(cbKey);
	pExpand->szValue = (LPOLESTR)CoTaskMemAlloc(cbValue);
	if (pExpand->szKey == NULL || pExpand->szValue == NULL)
	{
		CoTaskMemFree(pExpand->szKey);
		CoTaskMemFree(pExpand->szValue);
		delete pExpand;
		return E_OUTOFMEMORY;
	}
	memcpy(pExpand->szKey, lpszKey, cbKey);
	memcpy(pExpand->szValue, lpszValue, cbValue);

	if (m_cEls == m_nSize)
	{
        EXPANDER ** pEx;
		pEx = (EXPANDER**)realloc(m_p, m_nSize*2*sizeof(EXPANDER*));
        if (pEx) {
            m_p = pEx;
            m_nSize*=2;
        } else {
            CoTaskMemFree(pExpand->szKey);
            CoTaskMemFree(pExpand->szValue);
            delete pExpand;
            return E_OUTOFMEMORY;
        }
	}

	if (NULL != m_p)
	{
		m_p[m_cEls] = pExpand;
		m_cEls++;
	}
	else
		hr = E_OUTOFMEMORY;

	return hr;

}

LPCOLESTR CExpansionVector::Find(LPTSTR lpszKey)
{
	USES_CONVERSION;
	for (int iExpand = 0; iExpand < m_cEls; iExpand++)
	{
		if (!lstrcmpi(OLE2T(m_p[iExpand]->szKey), lpszKey)) //are equal
			return m_p[iExpand]->szValue;
	}
	return NULL;
}

HRESULT CExpansionVector::ClearReplacements()
{
	for (int iExpand = 0; iExpand < m_cEls; iExpand++)
	{
		EXPANDER* pExp = m_p[iExpand];
		CoTaskMemFree(pExp->szValue);
		CoTaskMemFree(pExp->szKey);
		delete pExp;
	}
	m_cEls = 0;
	return S_OK;
}

HRESULT CRegObject::GenerateError(UINT nID)
{
//  re.m_nID    = nID;
//  re.m_cLines = -1;

	return DISP_E_EXCEPTION;
}

HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem)
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.Add(lpszKey, lpszItem);
	m_csMap.Unlock();
	return hr;
}

HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID,
										 LPCTSTR szType, BOOL bRegister)
{
	USES_CONVERSION;

	HRESULT     hr;
	CRegParser  parser(this);
	HINSTANCE   hInstResDll;
	HRSRC       hrscReg;
	HGLOBAL     hReg;
	DWORD       dwSize;
	LPSTR       szRegA;
	LPTSTR      szReg;

	hInstResDll = LoadLibraryEx(OLE2CT(bstrFileName), NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (NULL == hInstResDll)
	{
		ATLTRACE(_T("Failed to LoadLibrary on %s\n"), OLE2CT(bstrFileName));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

	if (NULL == hrscReg)
	{
		ATLTRACE(_T("Failed to FindResource on ID:%s TYPE:%s\n"), szID, szType);
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	if (NULL == hReg)
	{
		ATLTRACE(_T("Failed to LoadResource \n"));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
	szRegA = (LPSTR)hReg;
	if (szRegA[dwSize] != NULL)
	{
		szRegA = (LPSTR)_alloca(dwSize+1);
		memcpy(szRegA, (void*)hReg, dwSize+1);
		szRegA[dwSize] = NULL;
	}

	szReg = A2T(szRegA);

#if defined(_DEBUG) && defined(DEBUG_REGISTRATION)
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

	hr = parser.RegisterBuffer(szReg, bRegister);

ReturnHR:

	if (NULL != hInstResDll)
		FreeLibrary((HMODULE)hInstResDll);
	return hr;
}

HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), TRUE);
}

HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;

	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), TRUE);
}

HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), FALSE);
}

HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), FALSE);
}

HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister)
{
	USES_CONVERSION;
	CRegParser  parser(this);


	LPCTSTR szReg = OLE2CT(bstrData);

#if defined(_DEBUG) && defined(DEBUG_REGISTRATION)
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

    if (szReg) {
    	HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);
        return hr;
    } else {
        return S_OK;
    }
}

HRESULT CRegObject::ClearReplacements()
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.ClearReplacements();
	m_csMap.Unlock();
	return hr;
}


LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey)
{
	m_csMap.Lock();
	LPCOLESTR lpsz = m_RepMap.Find(lpszKey);
	if (lpsz == NULL) // not found!!
		ATLTRACE(_T("Map Entry not found\n"));
	m_csMap.Unlock();
	return lpsz;
}

HRESULT CRegObject::MemMapAndRegister(LPCOLESTR bstrFileName, BOOL bRegister)
{
	USES_CONVERSION;

	CRegParser  parser(this);

	HANDLE hFile = CreateFile(OLE2CT(bstrFileName), GENERIC_READ, 0, NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_READONLY,
							  NULL);

	if (INVALID_HANDLE_VALUE == hFile)
	{
		ATLTRACE(_T("Failed to CreateFile on %s\n"), OLE2CT(bstrFileName));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required

	HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

	if (NULL == hMapping)
	{
		ATLTRACE(_T("Failed to CreateFileMapping\n"));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	LPVOID pMap = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);

	if (NULL == pMap)
	{
		ATLTRACE(_T("Failed to MapViewOfFile\n"));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	LPTSTR szReg = A2T((char*)pMap);

	if (chEOS != szReg[cbFile]) //ensure buffer is NULL terminated
	{
		ATLTRACE(_T("ERROR : Bad or missing End of File\n"));
		return E_FAIL; // make a real error
	}

#if defined(_DEBUG) && defined(DEBUG_REGISTRATION)
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

	HRESULT hRes = parser.RegisterBuffer(szReg, bRegister);

//  if (FAILED(hRes))
//      re = parser.GetRegException();

	UnmapViewOfFile(pMap);
	CloseHandle(hMapping);
	CloseHandle(hFile);

	return hRes;
}

HRESULT STDMETHODCALLTYPE CRegObject::FileRegister(LPCOLESTR bstrFileName)
{
	return MemMapAndRegister(bstrFileName, TRUE);
}

HRESULT STDMETHODCALLTYPE CRegObject::FileUnregister(LPCOLESTR bstrFileName)
{
	return MemMapAndRegister(bstrFileName, FALSE);
}

HRESULT STDMETHODCALLTYPE CRegObject::StringRegister(LPCOLESTR bstrData)
{
	return RegisterWithString(bstrData, TRUE);
}

HRESULT STDMETHODCALLTYPE CRegObject::StringUnregister(LPCOLESTR bstrData)
{
	return RegisterWithString(bstrData, FALSE);
}

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlcom.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
        #error atlcom.h requires atlbase.h to be included first
#endif

#pragma pack(push, _ATL_PACKING)

EXTERN_C const IID IID_ITargetFrame;

namespace ATL
{
#define CComConnectionPointContainerImpl IConnectionPointContainerImpl
#define CComISupportErrorInfoImpl ISupportErrorInfoImpl
#define CComProvideClassInfo2Impl IProvideClassInfoImpl
#define CComDualImpl IDispatchImpl

#ifdef _ATL_DEBUG_QI
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_QI

#ifdef _ATL_DEBUG_QI
#define _ATLDUMPIID(iid, name, hr) AtlDumpIID(iid, name, hr)
#else
#define _ATLDUMPIID(iid, name, hr) hr
#endif

#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className)\
        virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
        virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

/////////////////////////////////////////////////////////////////////////////
// AtlReportError

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
        HRESULT hRes, HINSTANCE hInst)
{
        return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, DWORD dwHelpID,
        LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
        return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID,
                lpszHelpFile, iid, hRes, hInst);
}

#ifndef OLE2ANSI
inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
        DWORD dwHelpID, LPCSTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
        ATLASSERT(lpszDesc != NULL);
        if (lpszDesc == NULL)
                return E_POINTER;
        USES_CONVERSION_EX;
        LPCOLESTR pwszDesc = A2COLE_EX(lpszDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
        if(pwszDesc == NULL)
                return E_OUTOFMEMORY;
        
        LPCWSTR pwzHelpFile = NULL;
        if(lpszHelpFile != NULL)
        {
                pwzHelpFile = A2CW_EX(lpszHelpFile, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                if(pwzHelpFile == NULL)
                        return E_OUTOFMEMORY;
        }
                
        return AtlSetErrorInfo(clsid, pwszDesc, dwHelpID, pwzHelpFile, iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
        const IID& iid, HRESULT hRes)
{
        ATLASSERT(lpszDesc != NULL);
        if (lpszDesc == NULL)
                return E_POINTER;
        USES_CONVERSION_EX;
        LPCOLESTR pwszDesc = A2COLE_EX(lpszDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
        if(pwszDesc == NULL)
                return E_OUTOFMEMORY;
                
        return AtlSetErrorInfo(clsid, pwszDesc, 0, NULL, iid, hRes, NULL);
}
#endif

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
        const IID& iid, HRESULT hRes)
{
        return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
        LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
        return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL);
}

//////////////////////////////////////////////////////////////////////////////
// IPersistImpl
template <class T>
class ATL_NO_VTABLE IPersistImpl : public IPersist
{
public:
        STDMETHOD(GetClassID)(CLSID *pClassID)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistImpl::GetClassID\n"));
                if (pClassID == NULL)
                        return E_FAIL;
                *pClassID = T::GetObjectCLSID();
                return S_OK;
        }
};


//////////////////////////////////////////////////////////////////////////////
// CComDispatchDriver / Specialization of CComQIPtr<IDispatch, IID_IDispatch>
class CComDispatchDriver
{
public:
        CComDispatchDriver()
        {
                p = NULL;
        }
        CComDispatchDriver(IDispatch* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComDispatchDriver(IUnknown* lp)
        {
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(IID_IDispatch, (void **)&p);
        }
        ~CComDispatchDriver() { if (p) p->Release(); }
        void Release() {if (p) p->Release(); p=NULL;}
        operator IDispatch*() {return p;}
        IDispatch& operator*() {ATLASSERT(p!=NULL); return *p; }
        IDispatch** operator&() {ATLASSERT(p==NULL); return &p; }
        IDispatch* operator->() {ATLASSERT(p!=NULL); return p; }
        IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp);}
        IDispatch* operator=(IUnknown* lp)
        {
                return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IDispatch);
        }
        BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}

        HRESULT GetPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
        {
                ATLASSERT(p);
                ATLASSERT(pVar);
                DISPID dwDispID;
                HRESULT hr = GetIDOfName(lpsz, &dwDispID);
                if (SUCCEEDED(hr))
                        hr = GetProperty(p, dwDispID, pVar);
                return hr;
        }
        HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar)
        {
                ATLASSERT(p);
                return GetProperty(p, dwDispID, pVar);
        }
        HRESULT PutPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
        {
                ATLASSERT(p);
                ATLASSERT(pVar);
                DISPID dwDispID;
                HRESULT hr = GetIDOfName(lpsz, &dwDispID);
                if (SUCCEEDED(hr))
                        hr = PutProperty(p, dwDispID, pVar);
                return hr;
        }
        HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar)
        {
                ATLASSERT(p);
                return PutProperty(p, dwDispID, pVar);
        }
        HRESULT GetIDOfName(LPCOLESTR lpsz, DISPID* pdispid)
        {
                return p->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpsz, 1, LOCALE_USER_DEFAULT, pdispid);
        }
        // Invoke a method by DISPID with no parameters
        HRESULT Invoke0(DISPID dispid, VARIANT* pvarRet = NULL)
        {
                DISPPARAMS dispparams = { NULL, NULL, 0, 0};
                return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
        }
        // Invoke a method by name with no parameters
        HRESULT Invoke0(LPCOLESTR lpszName, VARIANT* pvarRet = NULL)
        {
                HRESULT hr;
                DISPID dispid;
                hr = GetIDOfName(lpszName, &dispid);
                if (SUCCEEDED(hr))
                        hr = Invoke0(dispid, pvarRet);
                return hr;
        }
        // Invoke a method by DISPID with a single parameter
        HRESULT Invoke1(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
        {
                DISPPARAMS dispparams = { pvarParam1, NULL, 1, 0};
                return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
        }
        // Invoke a method by name with a single parameter
        HRESULT Invoke1(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
        {
                HRESULT hr;
                DISPID dispid;
                hr = GetIDOfName(lpszName, &dispid);
                if (SUCCEEDED(hr))
                        hr = Invoke1(dispid, pvarParam1, pvarRet);
                return hr;
        }
        // Invoke a method by DISPID with two parameters
        HRESULT Invoke2(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
        {
                if(pvarParam1 == NULL || pvarParam2 == NULL)
                        return E_INVALIDARG;
                        
                CComVariant varArgs[2] = { *pvarParam2, *pvarParam1 };
                DISPPARAMS dispparams = { &varArgs[0], NULL, 2, 0};
                return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
        }
        // Invoke a method by name with two parameters
        HRESULT Invoke2(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
        {
                HRESULT hr;
                DISPID dispid;
                hr = GetIDOfName(lpszName, &dispid);
                if (SUCCEEDED(hr))
                        hr = Invoke2(dispid, pvarParam1, pvarParam2, pvarRet);
                return hr;
        }
        // Invoke a method by DISPID with N parameters
        HRESULT InvokeN(DISPID dispid, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
        {
                DISPPARAMS dispparams = { pvarParams, NULL, nParams, 0};
                return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
        }
        // Invoke a method by name with Nparameters
        HRESULT InvokeN(LPCOLESTR lpszName, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
        {
                HRESULT hr;
                DISPID dispid;
                hr = GetIDOfName(lpszName, &dispid);
                if (SUCCEEDED(hr))
                        hr = InvokeN(dispid, pvarParams, nParams, pvarRet);
                return hr;
        }
        static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID,
                VARIANT* pVar)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::GetProperty\n"));
                ATLASSERT(pVar != NULL);
                if (pVar == NULL)
                        return E_POINTER;
                
                if(pDisp == NULL)
                        return E_INVALIDARG;
                        
                DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
                return pDisp->Invoke(dwDispID, IID_NULL,
                                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                                &dispparamsNoArgs, pVar, NULL, NULL);
        }

        static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID,
                VARIANT* pVar)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::PutProperty\n"));
                ATLASSERT(pVar != NULL);
                if (pVar == NULL)
                        return E_POINTER;

                if(pDisp == NULL)
                        return E_INVALIDARG;
                        
                DISPPARAMS dispparams = {NULL, NULL, 1, 1};
                dispparams.rgvarg = pVar;
                DISPID dispidPut = DISPID_PROPERTYPUT;
                dispparams.rgdispidNamedArgs = &dispidPut;

                if (pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH ||
                        (pVar->vt & VT_ARRAY) || (pVar->vt & VT_BYREF))
                {
                        HRESULT hr = pDisp->Invoke(dwDispID, IID_NULL,
                                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF,
                                &dispparams, NULL, NULL, NULL);
                        if (SUCCEEDED(hr))
                                return hr;
                }

                return pDisp->Invoke(dwDispID, IID_NULL,
                                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
                                &dispparams, NULL, NULL, NULL);
        }

        IDispatch* p;
};

//////////////////////////////////////////////////////////////////////////////
// CFakeFirePropNotifyEvent
class CFakeFirePropNotifyEvent
{
public:
        static HRESULT FireOnRequestEdit(IUnknown* /*pUnk*/, DISPID /*dispID*/)
        {
                return S_OK;
        }
        static HRESULT FireOnChanged(IUnknown* /*pUnk*/, DISPID /*dispID*/)
        {
                return S_OK;
        }
};
typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;

//////////////////////////////////////////////////////////////////////////////
// ATL Persistence

struct ATL_PROPMAP_ENTRY
{
        LPCOLESTR szDesc;
        DISPID dispid;
        const CLSID* pclsidPropPage;
        const IID* piidDispatch;
        size_t dwOffsetData;
        DWORD dwSizeData;
        VARTYPE vt;
};

// This one is DEPRECATED and is used for ATL 2.X controls
// it includes an implicit m_sizeExtent
#define BEGIN_PROPERTY_MAP(theClass) \
        typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
        typedef theClass _PropMapClass; \
        static ATL_PROPMAP_ENTRY* GetPropertyMap()\
        {\
                static ATL_PROPMAP_ENTRY pPropMap[] = \
                { \
                        {OLESTR("_cx"), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, m_sizeExtent.cx), sizeof(long), VT_UI4}, \
                        {OLESTR("_cy"), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, m_sizeExtent.cy), sizeof(long), VT_UI4},

// This one can be used on any type of object, but does not
// include the implicit m_sizeExtent
#define BEGIN_PROP_MAP(theClass) \
        typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
        typedef theClass _PropMapClass; \
        static ATL_PROPMAP_ENTRY* GetPropertyMap()\
        {\
                static ATL_PROPMAP_ENTRY pPropMap[] = \
                {

#define PROP_ENTRY(szDesc, dispid, clsid) \
                {OLESTR(szDesc), dispid, &clsid, &IID_IDispatch, 0, 0, 0},

#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
                {OLESTR(szDesc), dispid, &clsid, &iidDispatch, 0, 0, 0},

#define PROP_PAGE(clsid) \
                {NULL, NULL, &clsid, &IID_NULL, 0, 0, 0},

#define PROP_DATA_ENTRY(szDesc, member, vt) \
                {OLESTR(szDesc), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, member), sizeof(((_PropMapClass*)0)->member), vt},

#define END_PROPERTY_MAP() \
                        {NULL, 0, NULL, &IID_NULL, 0, 0, 0} \
                }; \
                return pPropMap; \
        }

#define END_PROP_MAP() \
                        {NULL, 0, NULL, &IID_NULL, 0, 0, 0} \
                }; \
                return pPropMap; \
        }


#ifdef _ATL_DLL
ATLAPI AtlIPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
        ATLASSERT(pMap != NULL);
        if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
                return E_INVALIDARG;

        HRESULT hr = S_OK;
        DWORD dwVer;
        hr = pStm->Read(&dwVer, sizeof(DWORD), NULL);
        if (FAILED(hr))
                return hr;
        if (dwVer > _ATL_VER)
                return E_FAIL;

        CComPtr<IDispatch> pDispatch;
        const IID* piidOld = NULL;
        for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
        {
                if (pMap[i].szDesc == NULL)
                        continue;

                // check if raw data entry
                if (pMap[i].dwSizeData != 0)
                {
                        void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
                        hr = pStm->Read(pData, pMap[i].dwSizeData, NULL);
                        if (FAILED(hr))
                                return hr;
                        continue;
                }

                CComVariant var;

                hr = var.ReadFromStream(pStm);
                if (FAILED(hr))
                        break;

                if (pMap[i].piidDispatch != piidOld)
                {
                        pDispatch.Release();
                        if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
                        {
                                ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
                                hr = E_FAIL;
                                break;
                        }
                        piidOld = pMap[i].piidDispatch;
                }

                if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
                {
                        ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
                        hr = E_FAIL;
                        break;
                }
        }
        return hr;
}
#endif //_ATL_DLL

#ifdef _ATL_DLL
ATLAPI AtlIPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistStreamInit_Save(LPSTREAM pStm,
        BOOL /* fClearDirty */, ATL_PROPMAP_ENTRY* pMap,
        void* pThis, IUnknown* pUnk)
{
        ATLASSERT(pMap != NULL);
        if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
                return E_INVALIDARG;
        DWORD dw = _ATL_VER;
        HRESULT hr = pStm->Write(&dw, sizeof(DWORD), NULL);
        if (FAILED(hr))
                return hr;

        CComPtr<IDispatch> pDispatch;
        const IID* piidOld = NULL;
        for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
        {
                if (pMap[i].szDesc == NULL)
                        continue;

                // check if raw data entry
                if (pMap[i].dwSizeData != 0)
                {
                        void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
                        hr = pStm->Write(pData, pMap[i].dwSizeData, NULL);
                        if (FAILED(hr))
                                return hr;
                        continue;
                }

                CComVariant var;
                if (pMap[i].piidDispatch != piidOld)
                {
                        pDispatch.Release();
                        if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
                        {
                                ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
                                hr = E_FAIL;
                                break;
                        }
                        piidOld = pMap[i].piidDispatch;
                }

                if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
                {
                        ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
                        hr = E_FAIL;
                        break;
                }

                hr = var.WriteToStream(pStm);
                if (FAILED(hr))
                        break;
        }
        return hr;
}
#endif //_ATL_DLL


#ifdef _ATL_DLL
ATLAPI AtlIPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
        if (pPropBag == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
                return E_INVALIDARG;

        CComPtr<IDispatch> pDispatch;
        const IID* piidOld = NULL;
        for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
        {
                if (pMap[i].szDesc == NULL)
                        continue;

                CComVariant var;
                var.vt = pMap[i].vt;
                // If raw entry skip it - we don't handle it for property bags just yet
                if (pMap[i].dwSizeData != 0)
                {
                        void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
                        HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
                        if (SUCCEEDED(hr))
                        {
                                // check the type - we only deal with limited set
                                switch (pMap[i].vt)
                                {
                                case VT_UI1:
                                case VT_I1:
                                        *((BYTE*)pData) = var.bVal;
                                        break;
                                case VT_BOOL:
                                        *((VARIANT_BOOL*)pData) = var.boolVal;
                                        break;
                                case VT_UI2:
                                        *((short*)pData) = var.iVal;
                                        break;
                                case VT_UI4:
                                case VT_INT:
                                case VT_UINT:
                                        *((long*)pData) = var.lVal;
                                        break;
                                }
                        }
                        continue;
                }

                if (pMap[i].piidDispatch != piidOld)
                {
                        pDispatch.Release();
                        if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
                        {
                                ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
                                return E_FAIL;
                        }
                        piidOld = pMap[i].piidDispatch;
                }

                if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
                {
                        ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
                        return E_FAIL;
                }

                HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
                if (FAILED(hr))
                {
                        USES_CONVERSION_EX;
                        LPCTSTR lp = OLE2CT_EX(pMap[i].szDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                
                        if (hr == E_INVALIDARG)
                        {
                                if(lp == NULL)
                                        ATLTRACE2(atlTraceCOM, 0, _T("Property not in Bag\n"));
                                else
                                        ATLTRACE2(atlTraceCOM, 0, _T("Property %s not in Bag\n"), lp);
                        }
                        else
                        {
                                // Many containers return different ERROR values for Member not found
                                if(lp == NULL)
                                        ATLTRACE2(atlTraceCOM, 0, _T("Error attempting to read Property from PropertyBag \n"));
                                else
                                        ATLTRACE2(atlTraceCOM, 0, _T("Error attempting to read Property %s from PropertyBag \n"), lp);
                        }
                        continue;
                }

                if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
                {
                        ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
                        return E_FAIL;
                }
        }
        return S_OK;
}
#endif //_ATL_DLL

#ifdef _ATL_DLL
ATLAPI AtlIPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
        BOOL /* fClearDirty */, BOOL /* fSaveAllProperties */,
        ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
        if (pPropBag == NULL)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("PropBag pointer passed in was invalid\n"));
                return E_INVALIDARG;
        }
        if (pMap == NULL || pThis == NULL || pUnk == NULL)
                return E_INVALIDARG;
        
        CComPtr<IDispatch> pDispatch;
        const IID* piidOld = NULL;
        for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
        {
                if (pMap[i].szDesc == NULL)
                        continue;

                CComVariant var;

                // If raw entry skip it - we don't handle it for property bags just yet
                if (pMap[i].dwSizeData != 0)
                {
                        void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
                        // check the type - we only deal with limited set
                        bool bTypeOK = false;
                        switch (pMap[i].vt)
                        {
                        case VT_UI1:
                        case VT_I1:
                                var.bVal = *((BYTE*)pData);
                                bTypeOK = true;
                                break;
                        case VT_BOOL:
                                var.boolVal = *((VARIANT_BOOL*)pData);
                                bTypeOK = true;
                                break;
                        case VT_UI2:
                                var.iVal = *((short*)pData);
                                bTypeOK = true;
                                break;
                        case VT_UI4:
                        case VT_INT:
                        case VT_UINT:
                                var.lVal = *((long*)pData);
                                bTypeOK = true;
                                break;
                        }
                        if (bTypeOK)
                        {
                                var.vt = pMap[i].vt;
                                HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
                                if (FAILED(hr))
                                        return hr;
                        }
                        continue;
                }

                if (pMap[i].piidDispatch != piidOld)
                {
                        pDispatch.Release();
                        if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
                        {
                                ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
                                return E_FAIL;
                        }
                        piidOld = pMap[i].piidDispatch;
                }

                if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
                {
                        ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
                        return E_FAIL;
                }

                if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
                {
                        if (var.punkVal == NULL)
                        {
                                ATLTRACE2(atlTraceCOM, 0, _T("Warning skipping empty IUnknown in Save\n"));
                                continue;
                        }
                }

                HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
                if (FAILED(hr))
                        return hr;
        }
        return S_OK;
}
#endif //_ATL_DLL


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInitImpl
template <class T>
class ATL_NO_VTABLE IPersistStreamInitImpl : public IPersistStreamInit
{
public:
        // IPersist
        STDMETHOD(GetClassID)(CLSID *pClassID)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::GetClassID\n"));
                ATLASSERT(pClassID != NULL);
                if (pClassID == NULL)
                        return E_POINTER;
                *pClassID = T::GetObjectCLSID();
                return S_OK;
        }

        // IPersistStream
        STDMETHOD(IsDirty)()
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::IsDirty\n"));
                T* pT = static_cast<T*>(this);
                return (pT->m_bRequiresSave) ? S_OK : S_FALSE;
        }
        STDMETHOD(Load)(LPSTREAM pStm)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::Load\n"));
                T* pT = static_cast<T*>(this);
                return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());
        }
        STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::Save\n"));
                return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());
        }
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* /* pcbSize */)
        {
                ATLTRACENOTIMPL(_T("IPersistStreamInitImpl::GetSizeMax"));
        }

        // IPersistStreamInit
        STDMETHOD(InitNew)()
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::InitNew\n"));
                return S_OK;
        }

        HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap)
        {
                T* pT = static_cast<T*>(this);
                HRESULT hr = AtlIPersistStreamInit_Load(pStm, pMap, pT, pT->GetUnknown());
                if (SUCCEEDED(hr))
                        pT->m_bRequiresSave = FALSE;
                return hr;

        }
        HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap)
        {
                T* pT = static_cast<T*>(this);
                return AtlIPersistStreamInit_Save(pStm, fClearDirty, pMap, pT, pT->GetUnknown());
        }
};

//////////////////////////////////////////////////////////////////////////////
// IPersistStorageImpl
template <class T>
class ATL_NO_VTABLE IPersistStorageImpl : public IPersistStorage
{
public:
        // IPersist
        STDMETHOD(GetClassID)(CLSID *pClassID)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::GetClassID\n"));
                ATLASSERT(pClassID != NULL);
                if (pClassID == NULL)
                        return E_POINTER;
                *pClassID = T::GetObjectCLSID();
                return S_OK;
        }

        // IPersistStorage
        STDMETHOD(IsDirty)(void)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::IsDirty\n"));
                CComPtr<IPersistStreamInit> p;
                p.p = IPSI_GetIPersistStreamInit();
                return (p != NULL) ? p->IsDirty() : E_FAIL;
        }
        STDMETHOD(InitNew)(IStorage*)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::InitNew\n"));
                CComPtr<IPersistStreamInit> p;
                p.p = IPSI_GetIPersistStreamInit();
                return (p != NULL) ? p->InitNew() : E_FAIL;
        }
        STDMETHOD(Load)(IStorage* pStorage)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::Load\n"));
                if (pStorage == NULL)
                        return E_INVALIDARG;
                CComPtr<IPersistStreamInit> p;
                p.p = IPSI_GetIPersistStreamInit();
                HRESULT hr = E_FAIL;
                if (p != NULL)
                {
                        CComPtr<IStream> spStream;
                        hr = pStorage->OpenStream(OLESTR("Contents"), NULL,
                                STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
                        if (SUCCEEDED(hr))
                                hr = p->Load(spStream);
                }
                return hr;
        }
        STDMETHOD(Save)(IStorage* pStorage, BOOL fSameAsLoad)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::Save\n"));
                if (pStorage == NULL)
                        return E_INVALIDARG;
                CComPtr<IPersistStreamInit> p;
                p.p = IPSI_GetIPersistStreamInit();
                HRESULT hr = E_FAIL;
                if (p != NULL)
                {
                        CComPtr<IStream> spStream;
                        static LPCOLESTR vszContents = OLESTR("Contents");
                        hr = pStorage->CreateStream(vszContents,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                0, 0, &spStream);
                        if (SUCCEEDED(hr))
                                hr = p->Save(spStream, fSameAsLoad);
                }
                return hr;
        }
        STDMETHOD(SaveCompleted)(IStorage* /* pStorage */)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::SaveCompleted\n"));
                return S_OK;
        }
        STDMETHOD(HandsOffStorage)(void)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::HandsOffStorage\n"));
                return S_OK;
        }
private:
        IPersistStreamInit* IPSI_GetIPersistStreamInit();
};

template <class T>
IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
{
        T* pT = static_cast<T*>(this);
        IPersistStreamInit* p;
        if (FAILED(pT->GetUnknown()->QueryInterface(IID_IPersistStreamInit, (void**)&p)))
                pT->_InternalQueryInterface(IID_IPersistStreamInit, (void**)&p);
        return p;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBagImpl
template <class T>
class ATL_NO_VTABLE IPersistPropertyBagImpl : public IPersistPropertyBag
{
public:
        // IPersist
        STDMETHOD(GetClassID)(CLSID *pClassID)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::GetClassID\n"));
                ATLASSERT(pClassID != NULL);
                if (pClassID == NULL)
                        return E_POINTER;
                *pClassID = T::GetObjectCLSID();
                return S_OK;
        }

        // IPersistPropertyBag
        //
        STDMETHOD(InitNew)()
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::InitNew\n"));
                return S_OK;
        }
        STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::Load\n"));
                T* pT = static_cast<T*>(this);
                ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
                ATLASSERT(pMap != NULL);
                return pT->IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap);
        }
        STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::Save\n"));
                T* pT = static_cast<T*>(this);
                ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
                ATLASSERT(pMap != NULL);
                return pT->IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap);
        }
        HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
        {
                T* pT = static_cast<T*>(this);
                HRESULT hr = AtlIPersistPropertyBag_Load(pPropBag, pErrorLog, pMap, pT, pT->GetUnknown());
                if (SUCCEEDED(hr))
                        pT->m_bRequiresSave = FALSE;
                return hr;
        }
        HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap)
        {
                T* pT = static_cast<T*>(this);
                return AtlIPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap, pT, pT->GetUnknown());
        }
};

//////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor
class CSecurityDescriptor
{
public:
        CSecurityDescriptor();
        ~CSecurityDescriptor();

public:
        HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
        HRESULT AttachObject(HANDLE hObject);
        HRESULT Initialize();
        HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
        HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
        HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
        HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
        HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
        HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
        HRESULT Revoke(LPCTSTR pszPrincipal);

        // utility functions
        // Any PSID you get from these functions should be free()ed
        static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
        static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
        static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
        static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
        static HRESULT CopyACL(PACL pDest, PACL pSrc);
        static HRESULT GetCurrentUserSID(PSID *ppSid);
        static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
        static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
        static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
        static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

        operator PSECURITY_DESCRIPTOR()
        {
                return m_pSD;
        }

public:
        PSECURITY_DESCRIPTOR m_pSD;
        PSID m_pOwner;
        PSID m_pGroup;
        PACL m_pDACL;
        PACL m_pSACL;
};

inline CSecurityDescriptor::CSecurityDescriptor()
{
        m_pSD = NULL;
        m_pOwner = NULL;
        m_pGroup = NULL;
        m_pDACL = NULL;
        m_pSACL= NULL;
}

inline CSecurityDescriptor::~CSecurityDescriptor()
{
        if (m_pSD)
                delete m_pSD;
        if (m_pOwner)
                free(m_pOwner);
        if (m_pGroup)
                free(m_pGroup);
        if (m_pDACL)
                free(m_pDACL);
        if (m_pSACL)
                free(m_pSACL);
}

inline HRESULT CSecurityDescriptor::Initialize()
{
        if (m_pSD)
        {
                delete m_pSD;
                m_pSD = NULL;
        }
        if (m_pOwner)
        {
                free(m_pOwner);
                m_pOwner = NULL;
        }
        if (m_pGroup)
        {
                free(m_pGroup);
                m_pGroup = NULL;
        }
        if (m_pDACL)
        {
                free(m_pDACL);
                m_pDACL = NULL;
        }
        if (m_pSACL)
        {
                free(m_pSACL);
                m_pSACL = NULL;
        }

        ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
        if (m_pSD == NULL)
                return E_OUTOFMEMORY;

        if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pSD;
                m_pSD = NULL;
                ATLASSERT(FALSE);
                return hr;
        }
        return S_OK;
}

inline HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
        PSID pUserSid = NULL;
        PSID pGroupSid = NULL;
        
        HRESULT hr = Initialize();
        if (FAILED(hr))
                return hr;
        hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (SUCCEEDED(hr))
        {
                hr = SetOwner(pUserSid, bDefaulted);
                if (SUCCEEDED(hr))
                        hr = SetGroup(pGroupSid, bDefaulted);
        }
        if (pUserSid != NULL)
                free(pUserSid);
        if (pGroupSid != NULL)
                free(pGroupSid);

        if (FAILED(hr))
        {
                delete m_pSD;
                m_pSD = NULL;
                
                free(m_pOwner);
                m_pOwner = NULL;
                
                ATLASSERT(FALSE);                
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
        PSID pUserSid = NULL;
        PSID pGroupSid = NULL;
        
        HRESULT hr = Initialize();
        if (FAILED(hr))
                return hr;
        
        hr = GetThreadSids(&pUserSid, &pGroupSid);
        if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
                hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (SUCCEEDED(hr))
        {
                hr = SetOwner(pUserSid, bDefaulted);
                if (SUCCEEDED(hr))
                        hr = SetGroup(pGroupSid, bDefaulted);
        }
        if (pUserSid != NULL)
                free(pUserSid);
        if (pGroupSid != NULL)
                free(pGroupSid);

        if (FAILED(hr))
        {
                delete m_pSD;
                m_pSD = NULL;
                
                free(m_pOwner);
                m_pOwner = NULL;
                
                ATLASSERT(FALSE);                
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
        ATLASSERT(m_pSD);

        // Mark the SD as having no owner
        if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }

        if (m_pOwner)
        {
                free(m_pOwner);
                m_pOwner = NULL;
        }

        // If they asked for no owner don't do the copy
        if (pOwnerSid == NULL)
                return S_OK;

        if (!IsValidSid(pOwnerSid))
        {
                return E_INVALIDARG;
        }
        
        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pOwnerSid);

        m_pOwner = (PSID) malloc(dwSize);
        if (m_pOwner == NULL)
                return E_OUTOFMEMORY;
        if (!CopySid(dwSize, m_pOwner, pOwnerSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pOwner);
                m_pOwner = NULL;
                return hr;
        }

        ATLASSERT(IsValidSid(m_pOwner));

        if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pOwner);
                m_pOwner = NULL;
                return hr;
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
        ATLASSERT(m_pSD);

        // Mark the SD as having no Group
        if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }

        if (m_pGroup)
        {
                free(m_pGroup);
                m_pGroup = NULL;
        }

        // If they asked for no Group don't do the copy
        if (pGroupSid == NULL)
                return S_OK;

        if (!IsValidSid(pGroupSid))
        {
                return E_INVALIDARG;
        }
        
        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pGroupSid);

        m_pGroup = (PSID) malloc(dwSize);
        if (m_pGroup == NULL)
                return E_OUTOFMEMORY;
        if (!CopySid(dwSize, m_pGroup, pGroupSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pGroup);
                m_pGroup = NULL;
                return hr;
        }

        ATLASSERT(IsValidSid(m_pGroup));

        if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pGroup);
                m_pGroup = NULL;
                return hr;
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
        HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        if (!bRes)
        {
                // Couldn't open process token
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        CloseHandle(hToken);
        return hr;
}

inline HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
        if (!bRes)
        {
                // Couldn't open thread token
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        CloseHandle(hToken);
        return hr;
}

inline HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
        DWORD dwSize = 0;
        HRESULT hr = E_FAIL;
        DWORD dwErr;
        PTOKEN_USER ptkUser = NULL;
        PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;

        if (ppUserSid)
        {
                // Get length required for TokenUser by specifying buffer length of 0
                GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
                dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        ATLASSERT(FALSE);
                        hr = AtlHresultFromWin32(dwErr);
                        goto failed;
                }

                ptkUser = (TOKEN_USER*) malloc(dwSize);
                if (ptkUser == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkUser->User.Sid);

                PSID pSid;
                pSid = (PSID) malloc(dwSize);
                if (pSid == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        free(pSid);
                        ATLASSERT(FALSE);
                        goto failed;
                }

                ATLASSERT(IsValidSid(pSid));
                *ppUserSid = pSid;
                free(ptkUser);
                ptkUser = NULL;
        }
        if (ppGroupSid)
        {
                // Get length required for TokenPrimaryGroup by specifying buffer length of 0
                GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
                dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        ATLASSERT(FALSE);
                        hr = AtlHresultFromWin32(dwErr);
                        goto failed;
                }

                ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
                if (ptkGroup == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

                PSID pSid;
                pSid = (PSID) malloc(dwSize);
                if (pSid == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        free(pSid);
                        ATLASSERT(FALSE);
                        goto failed;
                }

                ATLASSERT(IsValidSid(pSid));

                *ppGroupSid = pSid;
                free(ptkGroup);
                ptkGroup = NULL;
        }

        return S_OK;

failed:
        if (ptkUser)
                free(ptkUser);
        if (ptkGroup)
                free (ptkGroup);
        return hr;
}


inline HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
        HANDLE tkHandle;
        
        if (ppSid == NULL)
        {
                return E_POINTER;
        }

        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
        {
                TOKEN_USER *tkUser;
                DWORD tkSize;
                DWORD sidLength;

                // Call to get size information for alloc
                GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
                DWORD dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        HRESULT hr = AtlHresultFromWin32(dwErr);
                        ATLASSERT(FALSE);                        
                        CloseHandle(tkHandle);
                        return hr;
                }                
                tkUser = (TOKEN_USER *) malloc(tkSize);
                if (tkUser == NULL)
                {
                        CloseHandle(tkHandle);
                        return E_OUTOFMEMORY;
                }

                // Now make the real call
                if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
                {
                        sidLength = GetLengthSid(tkUser->User.Sid);
                        *ppSid = (PSID) malloc(sidLength);
                        if (*ppSid == NULL)
                        {
                                CloseHandle(tkHandle);
                                free(tkUser);                                
                                return E_OUTOFMEMORY;
                        }
                        if (!CopySid(sidLength, *ppSid, tkUser->User.Sid))
                        {
                                HRESULT hr = AtlHresultFromWin32(dwErr);
                                CloseHandle(tkHandle);
                                free(tkUser);
                                free(*ppSid);
                                *ppSid = NULL;
                                return hr;
                        }

                        CloseHandle(tkHandle);
                        free(tkUser);
                        return S_OK;
                }
                else
                {
                        HRESULT hr = AtlHresultFromLastError();                
                        CloseHandle(tkHandle);
                        free(tkUser);
                        return hr;
                }
        }
        return HRESULT_FROM_WIN32(GetLastError());
}


inline HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
        LPTSTR pszRefDomain = NULL;
        DWORD dwDomainSize = 0;
        DWORD dwSidSize = 0;
        SID_NAME_USE snu;
        
        if (ppSid == NULL)
        {
                return E_POINTER;
        }
        if (pszPrincipal == NULL)
        {
                return E_INVALIDARG;
        }

        *ppSid = NULL;

        // Call to get size info for alloc
        LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(dwErr);

        ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
        if (pszRefDomain == NULL)
                return E_OUTOFMEMORY;

        *ppSid = (PSID) malloc(dwSidSize);
        if (*ppSid != NULL)
        {
                if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
                {
                        HRESULT hr = AtlHresultFromLastError();                
                        free(*ppSid);
                        *ppSid = NULL;
                        delete[] pszRefDomain;
                        return hr;
                }
                delete[] pszRefDomain;
                return S_OK;
        }
        delete[] pszRefDomain;
        return E_OUTOFMEMORY;
}


inline HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
        PACL    pDACL = NULL;
        PACL    pSACL = NULL;
        BOOL    bDACLPresent, bSACLPresent;
        BOOL    bDefaulted;
        PSID    pUserSid;
        PSID    pGroupSid;
        
        if (pSelfRelativeSD == NULL ||!IsValidSecurityDescriptor(pSelfRelativeSD))
                return E_INVALIDARG;

        HRESULT hr = Initialize();
        if(FAILED(hr))
                return hr;

        // get the existing DACL.
        if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
                goto failed;

        if (bDACLPresent)
        {
                if (pDACL)
                {
                        // allocate new DACL.
                        m_pDACL = (PACL) malloc(pDACL->AclSize);
                        if (m_pDACL == NULL)
                        {
                                hr = E_OUTOFMEMORY;
                                goto failedMemory;
                        }

                        // initialize the DACL
                        if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        hr = CopyACL(m_pDACL, pDACL);
                        if (FAILED(hr))
                                goto failedMemory;

                        if (!IsValidAcl(m_pDACL))
                                goto failed;
                }

                // set the DACL
                if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
                        goto failed;
        }

        // get the existing SACL.
        if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
                goto failed;

        if (bSACLPresent)
        {
                if (pSACL)
                {
                        // allocate new SACL.
                        m_pSACL = (PACL) malloc(pSACL->AclSize);
                        if (m_pSACL == NULL)
                        {
                                hr = E_OUTOFMEMORY;
                                goto failedMemory;
                        }

                        // initialize the SACL
                        if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        hr = CopyACL(m_pSACL, pSACL);
                        if (FAILED(hr))
                                goto failedMemory;

                        if (!IsValidAcl(m_pSACL))
                                goto failed;
                }

                // set the SACL
                if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
                        goto failed;
        }

        if (!GetSecurityDescriptorOwner(pSelfRelativeSD, &pUserSid, &bDefaulted))
                goto failed;

        if (FAILED(SetOwner(pUserSid, bDefaulted)))
                goto failed;

        if (!GetSecurityDescriptorGroup(pSelfRelativeSD, &pGroupSid, &bDefaulted))
                goto failed;

        if (FAILED(SetGroup(pGroupSid, bDefaulted)))
                goto failed;

        if (!IsValidSecurityDescriptor(m_pSD))
        {
                hr = E_FAIL;
                goto failedMemory;
        }

        return S_OK;

failed:
        hr = AtlHresultFromLastError();

failedMemory:
        if (m_pDACL)
        {
                free(m_pDACL);
                m_pDACL = NULL;
        }
        if (m_pSACL)
        {
                free(m_pSACL);
                m_pSACL = NULL;
        }
        if (m_pSD)
        {
                free(m_pSD);
                m_pSD = NULL;
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
        HRESULT hr;
        DWORD dwSize = 0;
        PSECURITY_DESCRIPTOR pSD = NULL;

        GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(dwErr);

        pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);
        if (pSD == NULL)
                return E_OUTOFMEMORY;

        if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                free(pSD);
                return hr;
        }

        hr = Attach(pSD);
        free(pSD);
        return hr;
}


inline HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        LPVOID pAce;
        ACE_HEADER *aceHeader;

        if (pDest == NULL)
                return E_POINTER;
        if (pSrc == NULL)
                return S_OK;
        
        if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
                return HRESULT_FROM_WIN32(GetLastError());
        
        // Copy all of the ACEs to the new ACL
        for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
        {
                if (!GetAce(pSrc, i, &pAce))
                        return HRESULT_FROM_WIN32(GetLastError());

                aceHeader = (ACE_HEADER *) pAce;

                if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
                        return HRESULT_FROM_WIN32(GetLastError());
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        PSID principalSID;
        PACL oldACL, newACL = NULL;
        
        if (ppAcl == NULL)
                return E_POINTER;
                
        if (pszPrincipal == NULL)
                return E_INVALIDARG;

        oldACL = *ppAcl;

        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL && 
                !GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        {
                free(principalSID);        
                return AtlHresultFromLastError();
        }

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) +        // size of original ACL
                sizeof(ACCESS_DENIED_ACE) +                                         // size of ACE
                GetLengthSid(principalSID) -                                         // Actual size of SID
                sizeof(DWORD);                                                                        // subtract size of placeholder variable 
                                                                                                                // for SID in ACCESS_*_ACE structure

        newACL = (PACL) malloc(aclSize);
        if (newACL == NULL)
        {
                free(principalSID);        
                return E_OUTOFMEMORY;
        }

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        hr = CopyACL(newACL, oldACL);
        if (FAILED(hr))
        {
                free(newACL);
                free(principalSID);
                return hr;
        }

        *ppAcl = newACL;

        if (oldACL != NULL)
                free(oldACL);
        free(principalSID);
        return S_OK;
}


inline HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        PSID principalSID;
        PACL oldACL, newACL = NULL;
        
        if (ppAcl == NULL)
                return E_POINTER;
                
        if (pszPrincipal == NULL)
                return E_INVALIDARG;

        oldACL = *ppAcl;

        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL && 
                !GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
                return AtlHresultFromLastError();

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + // size of original ACL
                sizeof(ACCESS_ALLOWED_ACE) +                                         // size of ACE
                GetLengthSid(principalSID) -                                         // Actual size of SID
                sizeof(DWORD);                                                                        // subtract size of placeholder variable 
                                                                                                                // for SID in ACCESS_*_ACE structure

        newACL = (PACL) malloc(aclSize);
        if (newACL == NULL)
        {
                free(principalSID);        
                return E_OUTOFMEMORY;
        }

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        hr = CopyACL(newACL, oldACL);
        if (FAILED(hr))
        {
                free(newACL);
                free(principalSID);
                return hr;
        }

        *ppAcl = newACL;

        if (oldACL != NULL)
                free(oldACL);
        free(principalSID);
        return S_OK;
}

inline HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
        if (pAcl == NULL || pszPrincipal == NULL)
                return E_INVALIDARG;

        PSID principalSID;
        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        ACL_SIZE_INFORMATION aclSizeInfo;
        if (!GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        {
                hr = AtlHresultFromLastError();
                aclSizeInfo.AceCount = 0;
        }
                
        for (ULONG i = aclSizeInfo.AceCount; i > 0; i--)
        {
                ULONG uIndex = i - 1;
                LPVOID ace;        
                if (!GetAce(pAcl, uIndex, &ace))
                {
                        hr = AtlHresultFromLastError();
                        break;
                }

                ACE_HEADER *aceHeader = (ACE_HEADER *) ace;

                if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
                {
                        ACCESS_ALLOWED_ACE *accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                } 
                else if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
                {
                        ACCESS_DENIED_ACE *accessDeniedAce = (ACCESS_DENIED_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                } 
                else if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
                {
                        SYSTEM_AUDIT_ACE *systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                }
        }
        free(principalSID);
        return hr;
}

inline HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
        HRESULT hr;
        TOKEN_PRIVILEGES tpPrevious;
        TOKEN_PRIVILEGES tp;
        DWORD  cbPrevious = sizeof(TOKEN_PRIVILEGES);
        LUID   luid;
        HANDLE hTokenUsed;

        // if no token specified open process token
        if (hToken == 0)
        {
                if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        return hr;
                }
        }
        else
                hTokenUsed = hToken;

        if (!LookupPrivilegeValue(NULL, privilege, &luid ))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }

        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        tp.Privileges[0].Attributes = 0;

        if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }

        tpPrevious.PrivilegeCount = 1;
        tpPrevious.Privileges[0].Luid = luid;

        if (bEnable)
                tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
        else
                tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

        if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
        void InternalFinalConstructAddRef() {InternalAddRef();}\
        void InternalFinalConstructRelease() {InternalRelease();}

template <class T1>
class CComCreator
{
public:
        static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
        {
                _ATL_VALIDATE_OUT_POINTER(ppv);
                HRESULT hRes = E_OUTOFMEMORY;
                T1* p = NULL;
                ATLTRY(p = new T1(pv))
                if (p != NULL)
                {
                        p->SetVoid(pv);
                        p->InternalFinalConstructAddRef();
                        hRes = p->FinalConstruct();
                        p->InternalFinalConstructRelease();
                        if (hRes == S_OK)
                                hRes = p->QueryInterface(riid, ppv);
                        if (hRes != S_OK)
                                delete p;
                }
                return hRes;
        }
};

template <class T1>
class CComInternalCreator
{
public:
        static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
        {
                _ATL_VALIDATE_OUT_POINTER(ppv);
                HRESULT hRes = E_OUTOFMEMORY;
                T1* p = NULL;
                ATLTRY(p = new T1(pv))
                if (p != NULL)
                {
                        p->SetVoid(pv);
                        p->InternalFinalConstructAddRef();
                        hRes = p->FinalConstruct();
                        p->InternalFinalConstructRelease();
                        if (hRes == S_OK)
                                hRes = p->_InternalQueryInterface(riid, ppv);
                        if (hRes != S_OK)
                                delete p;
                }
                return hRes;
        }
};

template <HRESULT hr>
class CComFailCreator
{
public:
        static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID* ppv)
        {
                _ATL_VALIDATE_OUT_POINTER(ppv);
                return hr;
        }
};

template <class T1, class T2>
class CComCreator2
{
public:
        static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
        {
                // Assert Only. Validation done in functions called from here
                ATLASSERT(ppv != NULL && *ppv == NULL);
                return (pv == NULL) ? 
                        T1::CreateInstance(NULL, riid, ppv) : 
                        T2::CreateInstance(pv, riid, ppv);
        }
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< CComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< CComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_ONLY_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComFailCreator<E_FAIL>, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_POLY_AGGREGATABLE(x) public:\
        typedef CComCreator< CComPolyObject< x > > _CreatorClass;

struct _ATL_CREATORDATA
{
        _ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
        static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
        DWORD dwOffsetVar;
        _ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar>
class _CComCacheData
{
public:
        static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar>::data = {dwVar, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
        DWORD_PTR dwOffset;
        const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
        static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
        {offsetofclass(base, derived), base::_GetEntries};

template <class T, const CLSID* pclsid>
class CComAggregateCreator
{
public:
        static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
        {
                // Real check will be made in the call to CoCreateInstance
                ATLASSERT(ppv != NULL && *ppv == NULL);

                ATLASSERT(pv != NULL);
                if (pv == NULL)
                        return E_INVALIDARG;
                
                T* p = (T*) pv;
                // Add the following line to your object if you get a message about
                // GetControllingUnknown() being undefined
                // DECLARE_GET_CONTROLLING_UNKNOWN()
                return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv);
        }
};

#ifdef _ATL_DEBUG
#define DEBUG_QI_ENTRY(x) \
                {NULL, \
                (DWORD_PTR)_T(#x), \
                (_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#define _ATL_DECLARE_GET_UNKNOWN(x)\
        IUnknown* GetUnknown() \
        { \
                IUnknown* p; \
                _Module.AddNonAddRefThunk(_GetRawUnknown(), _T(#x), &p); \
                return p; \
        }
#else
#define _ATL_DECLARE_GET_UNKNOWN(x) IUnknown* GetUnknown() {return _GetRawUnknown();}
#endif

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public: \
        typedef x _ComMapClass; \
        static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)\
        {\
                _ComMapClass* p = (_ComMapClass*)pv;\
                p->Lock();\
                HRESULT hRes = E_FAIL; \
                __try \
                { \
                        hRes = CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);\
                } \
                __finally \
                { \
                        p->Unlock();\
                } \
                return hRes;\
        }\
        IUnknown* _GetRawUnknown() \
        { ATLASSERT(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); return (IUnknown*)((DWORD_PTR)this+_GetEntries()->dw); } \
        _ATL_DECLARE_GET_UNKNOWN(x)\
        HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject) \
        { return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); } \
        const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() { \
        static const _ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
        virtual IUnknown* GetControllingUnknown() {return GetUnknown();}

#ifndef _ATL_NO_UUIDOF
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

#define COM_INTERFACE_ENTRY_BREAK(x)\
        {&_ATL_IIDOF(x), \
        NULL, \
        _Break},

#define COM_INTERFACE_ENTRY_NOINTERFACE(x)\
        {&_ATL_IIDOF(x), \
        NULL, \
        _NoInterface},

#define COM_INTERFACE_ENTRY(x)\
        {&_ATL_IIDOF(x), \
        offsetofclass(x, _ComMapClass), \
        _ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_IID(iid, x)\
        {&iid,\
        offsetofclass(x, _ComMapClass),\
        _ATL_SIMPLEMAPENTRY},

// The impl macros are now obsolete
#define COM_INTERFACE_ENTRY_IMPL(x)\
        COM_INTERFACE_ENTRY_IID(_ATL_IIDOF(x), x##Impl<_ComMapClass>)

#define COM_INTERFACE_ENTRY_IMPL_IID(iid, x)\
        COM_INTERFACE_ENTRY_IID(iid, x##Impl<_ComMapClass>)
//

#define COM_INTERFACE_ENTRY2(x, x2)\
        {&_ATL_IIDOF(x),\
        (DWORD_PTR)((x*)(x2*)((_ComMapClass*)8))-8,\
        _ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
        {&iid,\
        (DWORD_PTR)((x*)(x2*)((_ComMapClass*)8))-8,\
        _ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
        {&iid, \
        dw, \
        func},

#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\
        {NULL, \
        dw, \
        func},

#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\
        {&iid,\
        (DWORD_PTR)&_CComCreatorData<\
                CComInternalCreator< CComTearOffObject< x > >\
                >::data,\
        _Creator},

#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk)\
        {&iid,\
        (DWORD_PTR)&_CComCacheData<\
                CComCreator< CComCachedTearOffObject< x > >,\
                offsetof(_ComMapClass, punk)\
                >::data,\
        _Cache},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
        {&iid,\
        offsetof(_ComMapClass, punk),\
        _Delegate},

#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\
        {NULL,\
        offsetof(_ComMapClass, punk),\
        _Delegate},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid)\
        {&iid,\
        (DWORD_PTR)&_CComCacheData<\
                CComAggregateCreator<_ComMapClass, &clsid>,\
                offsetof(_ComMapClass, punk)\
                >::data,\
        _Cache},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid)\
        {NULL,\
        (DWORD_PTR)&_CComCacheData<\
                CComAggregateCreator<_ComMapClass, &clsid>,\
                offsetof(_ComMapClass, punk)\
                >::data,\
        _Cache},

#define COM_INTERFACE_ENTRY_CHAIN(classname)\
        {NULL,\
        (DWORD_PTR)&_CComChainData<classname, _ComMapClass>::data,\
        _Chain},

#ifdef _ATL_DEBUG
#define END_COM_MAP() {NULL, 0, 0}}; return &_entries[1];} \
        virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
        virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
        STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#else
#define END_COM_MAP() {NULL, 0, 0}}; return _entries;} \
        virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
        virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
        STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#endif // _ATL_DEBUG

#define BEGIN_CATEGORY_MAP(x)\
   static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {\
   static const struct _ATL_CATMAP_ENTRY pMap[] = {
#define IMPLEMENTED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_IMPLEMENTED, &catid },
#define REQUIRED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_REQUIRED, &catid },
#define END_CATEGORY_MAP()\
   { _ATL_CATMAP_ENTRY_END, NULL } };\
   return( pMap ); }

#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance, class::_CreatorClass::CreateInstance, NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain },
#define OBJECT_ENTRY_NON_CREATEABLE(class) {&CLSID_NULL, class::UpdateRegistry, NULL, NULL, NULL, 0, NULL, class::GetCategoryMap, class::ObjectMain },

#ifdef _ATL_DEBUG
extern HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);
#endif // _ATL_DEBUG


// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRootBase
{
public:
        CComObjectRootBase()
        {
                m_dwRef = 0L;
        }
        HRESULT FinalConstruct()
        {
                return S_OK;
        }
        // For library initialization only
        HRESULT _AtlFinalConstruct()
        {
                return S_OK;
        }
        void FinalRelease() {}
        void _AtlFinalRelease() {}

        //ObjectMain is called during Module::Init and Module::Term
        static void WINAPI ObjectMain(bool /* bStarting */) {}

        static HRESULT WINAPI InternalQueryInterface(void* pThis,
                const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
        {
                ATLASSERT(pThis != NULL);
                // First entry in the com map should be a simple map entry
                ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
        #if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
                LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
        #endif // _ATL_DEBUG_INTERFACES
                HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);
        #ifdef _ATL_DEBUG_INTERFACES
                _Module.AddThunk((IUnknown**)ppvObject, pszClassName, iid);
        #endif // _ATL_DEBUG_INTERFACES
                return _ATLDUMPIID(iid, pszClassName, hRes);
        }

//Outer funcs
        ULONG OuterAddRef()
        {
                return m_pOuterUnknown->AddRef();
        }
        ULONG OuterRelease()
        {
                return m_pOuterUnknown->Release();
        }
        HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
        {
                return m_pOuterUnknown->QueryInterface(iid, ppvObject);
        }

        void SetVoid(void*) {}
        void InternalFinalConstructAddRef() {}
        void InternalFinalConstructRelease()
        {
                ATLASSERT(m_dwRef == 0);
        }
        // If this assert occurs, your object has probably been deleted
        // Try using DECLARE_PROTECT_FINAL_CONSTRUCT()


        static HRESULT WINAPI _Break(void* /* pv */, REFIID iid, void** /* ppvObject */, DWORD_PTR /* dw */)
        {
                iid;
                _ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK);
                DebugBreak();
                return S_FALSE;
        }
        static HRESULT WINAPI _NoInterface(void* /* pv */, REFIID /* iid */, void** /* ppvObject */, DWORD_PTR /* dw */)
        {
                return E_NOINTERFACE;
        }
        static HRESULT WINAPI _Creator(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
        {
                _ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
                return pcd->pFunc(pv, iid, ppvObject);
        }
        static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
        {
                HRESULT hRes = E_NOINTERFACE;
                IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
                if (p != NULL)
                        hRes = p->QueryInterface(iid, ppvObject);
                return hRes;
        }
        static HRESULT WINAPI _Chain(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
        {
                _ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
                void* p = (void*)((DWORD_PTR)pv + pcd->dwOffset);
                return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
        }
        static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
        {
                HRESULT hRes = E_NOINTERFACE;
                _ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
                IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
                if (*pp == NULL)
                        hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
                if (*pp != NULL)
                        hRes = (*pp)->QueryInterface(iid, ppvObject);
                return hRes;
        }

        union
        {
                long m_dwRef;
                IUnknown* m_pOuterUnknown;
        };
};

//foward declaration
template <class ThreadModel>
class CComObjectRootEx;

template <class ThreadModel>
class CComObjectLockT
{
public:
        CComObjectLockT(CComObjectRootEx<ThreadModel>* p)
        {
                if (p)
                        p->Lock();
                m_p = p;
        }

        ~CComObjectLockT()
        {
                if (m_p)
                        m_p->Unlock();
        }
        CComObjectRootEx<ThreadModel>* m_p;
};

template <> class CComObjectLockT<CComSingleThreadModel>;

template <class ThreadModel>
class CComObjectRootEx : public CComObjectRootBase
{
public:
        typedef ThreadModel _ThreadModel;
        typename typedef _ThreadModel::AutoCriticalSection _CritSec;
        typedef CComObjectLockT<_ThreadModel> ObjectLock;

        ULONG InternalAddRef()
        {
                ATLASSERT(m_dwRef != -1L);
                return _ThreadModel::Increment(&m_dwRef);
        }
        ULONG InternalRelease()
        {
                ATLASSERT(m_dwRef > 0);
                return _ThreadModel::Decrement(&m_dwRef);
        }

        void Lock() {m_critsec.Lock();}
        void Unlock() {m_critsec.Unlock();}
private:
        _CritSec m_critsec;
};

template <>
class CComObjectRootEx<CComSingleThreadModel> : public CComObjectRootBase
{
public:
        typedef CComSingleThreadModel _ThreadModel;
        typedef _ThreadModel::AutoCriticalSection _CritSec;
        typedef CComObjectLockT<_ThreadModel> ObjectLock;

        ULONG InternalAddRef()
        {
                ATLASSERT(m_dwRef != -1L);
                return _ThreadModel::Increment(&m_dwRef);
        }
        ULONG InternalRelease()
        {
                return _ThreadModel::Decrement(&m_dwRef);
        }

        void Lock() {}
        void Unlock() {}
};

template <>
class CComObjectLockT<CComSingleThreadModel>
{
public:
        CComObjectLockT(CComObjectRootEx<CComSingleThreadModel>*) {}
        ~CComObjectLockT() {}
};

typedef CComObjectRootEx<CComObjectThreadModel> CComObjectRoot;

#if defined(_WINDLL) | defined(_USRDLL)
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectCached< cf > > _ClassFactoryCreatorClass;
#else
// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
#endif
#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory)
#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2<lic>)
#define DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(CComClassFactoryAutoThread)
#define DECLARE_CLASSFACTORY_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactorySingleton<obj>)

#define DECLARE_OBJECT_DESCRIPTION(x)\
        static LPCTSTR WINAPI GetObjectDescription()\
        {\
                return _T(x);\
        }

#define DECLARE_NO_REGISTRY()\
        static HRESULT WINAPI UpdateRegistry(BOOL /*bRegister*/)\
        {return S_OK;}

#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
        static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
        {\
                return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
                        flags, bRegister);\
        }

#define DECLARE_REGISTRY_RESOURCE(x)\
        static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
        {\
        return _Module.UpdateRegistryFromResource(_T(#x), bRegister);\
        }

#define DECLARE_REGISTRY_RESOURCEID(x)\
        static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
        {\
        return _Module.UpdateRegistryFromResource(x, bRegister);\
        }

//DECLARE_STATIC_* provided for backward compatibility
#ifdef _ATL_STATIC_REGISTRY
#define DECLARE_STATIC_REGISTRY_RESOURCE(x) DECLARE_REGISTRY_RESOURCE(x)
#define DECLARE_STATIC_REGISTRY_RESOURCEID(x) DECLARE_REGISTRY_RESOURCEID(x)
#endif //_ATL_STATIC_REGISTRY

template<class Base> class CComObject; // fwd decl

template <class Owner, class ThreadModel = CComObjectThreadModel>
class CComTearOffObjectBase : public CComObjectRootEx<ThreadModel>
{
public:
        typedef Owner _OwnerClass;
        CComObject<Owner>* m_pOwner;
        CComTearOffObjectBase() {m_pOwner = NULL;}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
        typedef Base _BaseClass;
        CComObject(void* = NULL)
        {
                _Module.Lock();
        }
        // Set refcount to 1 to protect destruction
        ~CComObject()
        {
                m_dwRef = 1L;
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
                _Module.Unlock();
        }
        //If InternalAddRef or InternalRelease is undefined then your class
        //doesn't derive from CComObjectRoot
        STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
        STDMETHOD_(ULONG, Release)()
        {
                ULONG l = InternalRelease();
                if (l == 0)
                        delete this;
                return l;
        }
        //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {return _InternalQueryInterface(iid, ppvObject);}
        template <class Q>
        HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
        {
                return QueryInterface(__uuidof(Q), (void**)pp);
        }

        static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
{
        _ATL_VALIDATE_OUT_POINTER(pp);
        
        HRESULT hRes = E_OUTOFMEMORY;
        CComObject<Base>* p = NULL;
        ATLTRY(p = new CComObject<Base>())
        if (p != NULL)
        {
                p->SetVoid(NULL);
                p->InternalFinalConstructAddRef();
                hRes = p->FinalConstruct();
                p->InternalFinalConstructRelease();
                if (hRes != S_OK)
                {
                        delete p;
                        p = NULL;
                }
        }
        *pp = p;
        return hRes;
}

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
// CComObjectCached is used primarily for class factories in DLL's
// but it is useful anytime you want to cache an object
template <class Base>
class CComObjectCached : public Base
{
public:
        typedef Base _BaseClass;
        CComObjectCached(void* = NULL){}
        // Set refcount to 1 to protect destruction
        ~CComObjectCached()
        {
                m_dwRef = 1L;
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
        }
        //If InternalAddRef or InternalRelease is undefined then your class
        //doesn't derive from CComObjectRoot
        STDMETHOD_(ULONG, AddRef)()
        {
                m_csCached.Lock();
                ULONG l = InternalAddRef();
                if (m_dwRef == 2)
                        _Module.Lock();
                m_csCached.Unlock();
                return l;
        }
        STDMETHOD_(ULONG, Release)()
        {
                m_csCached.Lock();
                InternalRelease();
                ULONG l = m_dwRef;
                m_csCached.Unlock();
                if (l == 0)
                        delete this;
                else if (l == 1)
                        _Module.Unlock();
                return l;
        }
        //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {return _InternalQueryInterface(iid, ppvObject);}
        CComGlobalsThreadModel::AutoCriticalSection m_csCached;
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
        typedef Base _BaseClass;
        CComObjectNoLock(void* = NULL){}
        // Set refcount to 1 to protect destruction
        ~CComObjectNoLock()
        {
                m_dwRef = 1L;
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
        }

        //If InternalAddRef or InternalRelease is undefined then your class
        //doesn't derive from CComObjectRoot
        STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
        STDMETHOD_(ULONG, Release)()
        {
                ULONG l = InternalRelease();
                if (l == 0)
                        delete this;
                return l;
        }
        //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {return _InternalQueryInterface(iid, ppvObject);}
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectGlobal : public Base
{
public:
        typedef Base _BaseClass;
        CComObjectGlobal(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
        ~CComObjectGlobal()
        {
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
        }

        STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();}
        STDMETHOD_(ULONG, Release)(){return _Module.Unlock();}
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {return _InternalQueryInterface(iid, ppvObject);}
        HRESULT m_hResFinalConstruct;
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectStack : public Base
{
public:
        typedef Base _BaseClass;
        CComObjectStack(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
        ~CComObjectStack()
        {
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
        }


        STDMETHOD_(ULONG, AddRef)() {ATLASSERT(FALSE);return 0;}
        STDMETHOD_(ULONG, Release)(){ATLASSERT(FALSE);return 0;}
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {ATLASSERT(FALSE);return E_NOINTERFACE;}
        HRESULT m_hResFinalConstruct;
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
        typedef Base _BaseClass;
        CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}
#ifdef _ATL_DEBUG_INTERFACES
        ~CComContainedObject()
        {
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
                _Module.DeleteNonAddRefThunk(m_pOuterUnknown);
        }
#endif

        STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
        STDMETHOD_(ULONG, Release)() {return OuterRelease();}
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
                HRESULT hr = OuterQueryInterface(iid, ppvObject);
                if (FAILED(hr) && _GetRawUnknown() != m_pOuterUnknown)
                        hr = _InternalQueryInterface(iid, ppvObject);
                return hr;
        }
        template <class Q>
        HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
        {
                return QueryInterface(__uuidof(Q), (void**)pp);
        }
        //GetControllingUnknown may be virtual if the Base class has declared
        //DECLARE_GET_CONTROLLING_UNKNOWN()
        IUnknown* GetControllingUnknown()
        {
#ifdef _ATL_DEBUG_INTERFACES
                IUnknown* p;
                _Module.AddNonAddRefThunk(m_pOuterUnknown, _T("CComContainedObject"), &p);
                return p;
#else
                return m_pOuterUnknown;
#endif
        }
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject :
        public IUnknown,
        public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
        typedef contained _BaseClass;
        CComAggObject(void* pv) : m_contained(pv)
        {
                _Module.Lock();
        }
        //If you get a message that this call is ambiguous then you need to
        // override it in your class and call each base class' version of this
        HRESULT FinalConstruct()
        {
                CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
                return m_contained.FinalConstruct();
        }
        void FinalRelease()
        {
                CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
                m_contained.FinalRelease();
        }
        // Set refcount to 1 to protect destruction
        ~CComAggObject()
        {
                m_dwRef = 1L;
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(this);
#endif
                _Module.Unlock();
        }

        STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
        STDMETHOD_(ULONG, Release)()
        {
                ULONG l = InternalRelease();
                if (l == 0)
                        delete this;
                return l;
        }
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
                HRESULT hRes = S_OK;
                if (InlineIsEqualUnknown(iid))
                {
                        if (ppvObject == NULL)
                                return E_POINTER;
                        *ppvObject = (void*)(IUnknown*)this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
                }
                else
                        hRes = m_contained._InternalQueryInterface(iid, ppvObject);
                return hRes;
        }
        template <class Q>
        HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
        {
                return QueryInterface(__uuidof(Q), (void**)pp);
        }
        static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComAggObject<contained>** pp)
        {
                _ATL_VALIDATE_OUT_POINTER(pp);
                        
                HRESULT hRes = E_OUTOFMEMORY;
                CComAggObject<contained>* p = NULL;
                ATLTRY(p = new CComAggObject<contained>(pUnkOuter))
                if (p != NULL)
                {
                        p->SetVoid(NULL);
                        p->InternalFinalConstructAddRef();
                        hRes = p->FinalConstruct();
                        p->InternalFinalConstructRelease();
                        if (hRes != S_OK)
                        {
                                delete p;
                                p = NULL;
                        }
                }
                *pp = p;
                return hRes;
        }

        CComContainedObject<contained> m_contained;
};

///////////////////////////////////////////////////////////////////////////////
// CComPolyObject can be either aggregated or not aggregated

template <class contained>
class CComPolyObject :
        public IUnknown,
        public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
        typedef contained _BaseClass;
        CComPolyObject(void* pv) : m_contained(pv ? pv : this)
        {
                _Module.Lock();
        }
        //If you get a message that this call is ambiguous then you need to
        // override it in your class and call each base class' version of this
        HRESULT FinalConstruct()
        {
                InternalAddRef();
                CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
                HRESULT hr = m_contained.FinalConstruct();
                InternalRelease();
                return hr;
        }
        void FinalRelease()
        {
                CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
                m_contained.FinalRelease();
        }
        // Set refcount to 1 to protect destruction
        ~CComPolyObject()
        {
                m_dwRef = 1L;
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(this);
#endif
                _Module.Unlock();
        }

        STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
        STDMETHOD_(ULONG, Release)()
        {
                ULONG l = InternalRelease();
                if (l == 0)
                        delete this;
                return l;
        }
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
                if (ppvObject == NULL)
                    return E_POINTER;
                *ppvObject = NULL;

                HRESULT hRes = S_OK;
                if (InlineIsEqualUnknown(iid))
                {
                        *ppvObject = (void*)(IUnknown*)this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
                }
                else
                        hRes = m_contained._InternalQueryInterface(iid, ppvObject);
                return hRes;
        }
        template <class Q>
        HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
        {
                return QueryInterface(__uuidof(Q), (void**)pp);
        }
        static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComPolyObject<contained>** pp)
        {
                _ATL_VALIDATE_OUT_POINTER(pp);

                HRESULT hRes = E_OUTOFMEMORY;
                CComPolyObject<contained>* p = NULL;
                ATLTRY(p = new CComPolyObject<contained>(pUnkOuter))
                if (p != NULL)
                {
                        p->SetVoid(NULL);
                        p->InternalFinalConstructAddRef();
                        hRes = p->FinalConstruct();
                        p->InternalFinalConstructRelease();
                        if (hRes != S_OK)
                        {
                                delete p;
                                p = NULL;
                        }
                }
                *pp = p;
                return hRes;
        }

        CComContainedObject<contained> m_contained;
};

template <class Base>
class CComTearOffObject : public Base
{
public:
        CComTearOffObject(void* pv)
        {
                ATLASSERT(m_pOwner == NULL);
                m_pOwner = reinterpret_cast<CComObject<Base::_OwnerClass>*>(pv);
                m_pOwner->AddRef();
        }
        // Set refcount to 1 to protect destruction
        ~CComTearOffObject()
        {
                m_dwRef = 1L;
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
                m_pOwner->Release();
        }

        STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
        STDMETHOD_(ULONG, Release)()
        {
                ULONG l = InternalRelease();
                if (l == 0)
                        delete this;
                return l;
        }
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
                return m_pOwner->QueryInterface(iid, ppvObject);
        }
};

template <class contained>
class CComCachedTearOffObject :
        public IUnknown,
        public CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>
{
public:
        typedef contained _BaseClass;
        CComCachedTearOffObject(void* pv) :
                m_contained(((contained::_OwnerClass*)pv)->GetControllingUnknown())
        {
                ATLASSERT(m_contained.m_pOwner == NULL);
                m_contained.m_pOwner = reinterpret_cast<CComObject<contained::_OwnerClass>*>(pv);
        }
        //If you get a message that this call is ambiguous then you need to
        // override it in your class and call each base class' version of this
        HRESULT FinalConstruct()
        {
                CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
                return m_contained.FinalConstruct();
        }
        void FinalRelease()
        {
                CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
                m_contained.FinalRelease();
        }
        // Set refcount to 1 to protect destruction
        ~CComCachedTearOffObject()
        {
                m_dwRef = 1L;
                FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
                _Module.DeleteNonAddRefThunk(this);
#endif
        }


        STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
        STDMETHOD_(ULONG, Release)()
        {
                ULONG l = InternalRelease();
                if (l == 0)
                        delete this;
                return l;
        }
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
                HRESULT hRes = S_OK;
                if (InlineIsEqualUnknown(iid))
                {
                        if (ppvObject == NULL)
                                return E_POINTER;
                        *ppvObject = (void*)(IUnknown*)this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
                }
                else
                        hRes = m_contained._InternalQueryInterface(iid, ppvObject);
                return hRes;
        }
        CComContainedObject<contained> m_contained;
};

class CComClassFactory :
        public IClassFactory,
        public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
        BEGIN_COM_MAP(CComClassFactory)
                COM_INTERFACE_ENTRY(IClassFactory)
        END_COM_MAP()

        // IClassFactory
        STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
        {
                ATLASSERT(m_pfnCreateInstance != NULL);
                HRESULT hRes = E_POINTER;
                if (ppvObj != NULL)
                {
                        *ppvObj = NULL;
                        // can't ask for anything other than IUnknown when aggregating
                        
                        if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
                        {
                                ATLTRACE2(atlTraceCOM, 0, _T("CComClassFactory: asked for non IUnknown interface while creating an aggregated object"));
                                hRes = CLASS_E_NOAGGREGATION;
                        }
                        else
                                hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
                }
                return hRes;
        }

        STDMETHOD(LockServer)(BOOL fLock)
        {
                if (fLock)
                        _Module.Lock();
                else
                        _Module.Unlock();
                return S_OK;
        }
        // helper
        void SetVoid(void* pv)
        {
                m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
        }
        _ATL_CREATORFUNC* m_pfnCreateInstance;
};

template <class license>
class CComClassFactory2 :
        public IClassFactory2,
        public CComObjectRootEx<CComGlobalsThreadModel>,
        public license
{
public:
        typedef license _LicenseClass;
        typedef CComClassFactory2<license> _ComMapClass;
BEGIN_COM_MAP(CComClassFactory2<license>)
        COM_INTERFACE_ENTRY(IClassFactory)
        COM_INTERFACE_ENTRY(IClassFactory2)
END_COM_MAP()
        // IClassFactory
        STDMETHOD(LockServer)(BOOL fLock)
        {
                if (fLock)
                        _Module.Lock();
                else
                        _Module.Unlock();
                return S_OK;
        }
        STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                REFIID riid, void** ppvObj)
        {
                ATLASSERT(m_pfnCreateInstance != NULL);
                if (ppvObj == NULL)
                        return E_POINTER;
                *ppvObj = NULL;
                if (!IsLicenseValid())
                        return CLASS_E_NOTLICENSED;

                if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
                        return CLASS_E_NOAGGREGATION;
                else
                        return m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
        }
        // IClassFactory2
        STDMETHOD(CreateInstanceLic)(IUnknown* pUnkOuter, IUnknown* pUnkReserved,
                                REFIID riid, BSTR bstrKey, void** ppvObject)
        {
                ATLASSERT(m_pfnCreateInstance != NULL);
                if (ppvObject == NULL)
                        return E_POINTER;
                *ppvObject = NULL;
                if ( ((bstrKey != NULL) && !VerifyLicenseKey(bstrKey)) ||
                         ((bstrKey == NULL) && !IsLicenseValid()) )
                        return CLASS_E_NOTLICENSED;
                if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
                        return CLASS_E_NOAGGREGATION;
                else
                        return m_pfnCreateInstance(pUnkOuter, riid, ppvObject);
        }
        STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR* pbstrKey)
        {
                if (pbstrKey == NULL)
                        return E_POINTER;
                *pbstrKey = NULL;

                if (!IsLicenseValid())
                        return CLASS_E_NOTLICENSED;
                return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL;
        }
        STDMETHOD(GetLicInfo)(LICINFO* pLicInfo)
        {
                if (pLicInfo == NULL)
                        return E_POINTER;
                pLicInfo->cbLicInfo = sizeof(LICINFO);
                pLicInfo->fLicVerified = IsLicenseValid();
                BSTR bstr = NULL;
                pLicInfo->fRuntimeKeyAvail = GetLicenseKey(0,&bstr);
                ::SysFreeString(bstr);
                return S_OK;
        }
        void SetVoid(void* pv)
        {
                m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
        }
        _ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling class factory

class CComClassFactoryAutoThread :
        public IClassFactory,
        public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
        BEGIN_COM_MAP(CComClassFactoryAutoThread)
                COM_INTERFACE_ENTRY(IClassFactory)
        END_COM_MAP()

        // helper
        void SetVoid(void* pv)
        {
                m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
        }
        STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter,
                REFIID riid, void** ppvObj)
        {
                ATLASSERT(m_pfnCreateInstance != NULL);
                HRESULT hRes = E_POINTER;
                if (ppvObj != NULL)
                {
                        *ppvObj = NULL;
                        // cannot aggregate across apartments
                        ATLASSERT(pUnkOuter == NULL);
                        if (pUnkOuter != NULL)
                                hRes = CLASS_E_NOAGGREGATION;
                        else
                                hRes = _Module.CreateInstance(m_pfnCreateInstance, riid, ppvObj);
                }
                return hRes;
        }
        STDMETHODIMP LockServer(BOOL fLock)
        {
                if (fLock)
                        _Module.Lock();
                else
                        _Module.Unlock();
                return S_OK;
        }
        _ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Singleton Class Factory
template <class T>
class CComClassFactorySingleton : public CComClassFactory
{
public:
        // IClassFactory
        STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
        {
                HRESULT hRes = E_POINTER;
                if (ppvObj != NULL)
                {
                        *ppvObj = NULL;
                        // aggregation is not supported in Singletons
                        ATLASSERT(pUnkOuter == NULL);
                        if (pUnkOuter != NULL)
                                hRes = CLASS_E_NOAGGREGATION;
                        else
                        {
                                if (m_Obj.m_hResFinalConstruct != S_OK)
                                        hRes = m_Obj.m_hResFinalConstruct;
                                else
                                        hRes = m_Obj.QueryInterface(riid, ppvObj);
                        }
                }
                return hRes;
        }
        CComObjectGlobal<T> m_Obj;
};

template <class T, const CLSID* pclsid = &CLSID_NULL>
class CComCoClass
{
public:
        DECLARE_CLASSFACTORY()
        DECLARE_AGGREGATABLE(T)
        typedef T _CoClass;
        static const CLSID& WINAPI GetObjectCLSID() {return *pclsid;}
        static LPCTSTR WINAPI GetObjectDescription() {return NULL;}
        static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {return NULL;};
        static HRESULT WINAPI Error(LPCOLESTR lpszDesc,
                const IID& iid = GUID_NULL, HRESULT hRes = 0)
        {
                return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
        }
        static HRESULT WINAPI Error(LPCOLESTR lpszDesc, DWORD dwHelpID,
                LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
        {
                return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, lpszHelpFile,
                        iid, hRes);
        }
        static HRESULT WINAPI Error(UINT nID, const IID& iid = GUID_NULL,
                HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
        {
                return AtlReportError(GetObjectCLSID(), nID, iid, hRes, hInst);
        }
        static HRESULT WINAPI Error(UINT nID, DWORD dwHelpID,
                LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL,
                HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
        {
                return AtlReportError(GetObjectCLSID(), nID, dwHelpID, lpszHelpFile,
                        iid, hRes, hInst);
        }
#ifndef OLE2ANSI
        static HRESULT WINAPI Error(LPCSTR lpszDesc,
                const IID& iid = GUID_NULL, HRESULT hRes = 0)
        {
                return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
        }
        static HRESULT WINAPI Error(LPCSTR lpszDesc, DWORD dwHelpID,
                LPCSTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
        {
                return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID,
                        lpszHelpFile, iid, hRes);
        }
#endif
        template <class Q>
        static HRESULT CreateInstance(IUnknown* punkOuter, Q** pp)
        {
                return T::_CreatorClass::CreateInstance(punkOuter, __uuidof(Q), (void**) pp);
        }
        template <class Q>
        static HRESULT CreateInstance(Q** pp)
        {
                return T::_CreatorClass::CreateInstance(NULL, __uuidof(Q), (void**) pp);
        }
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
        const GUID* m_pguid;
        const GUID* m_plibid;
        WORD m_wMajor;
        WORD m_wMinor;

        ITypeInfo* m_pInfo;
        long m_dwRef;
        struct stringdispid
        {
                CComBSTR bstr;
                int nLen;
                DISPID id;
                stringdispid() : nLen(0), id(DISPID_UNKNOWN){}
        };
        stringdispid* m_pMap;
        int m_nCount;

public:
        HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
        {
                _ATL_VALIDATE_OUT_POINTER(ppInfo);
                
                HRESULT hr = S_OK;
                if (m_pInfo == NULL)
                        hr = GetTI(lcid);
                *ppInfo = m_pInfo;
                if (m_pInfo != NULL)
                {
                        m_pInfo->AddRef();
                        hr = S_OK;
                }
                return hr;
        }
        HRESULT GetTI(LCID lcid);
        HRESULT EnsureTI(LCID lcid)
        {
                HRESULT hr = S_OK;
                if (m_pInfo == NULL || m_pMap == NULL)
                        hr = GetTI(lcid);
                return hr;
        }

        // This function is called by the module on exit
        // It is registered through _Module.AddTermFunc()
        static void __stdcall Cleanup(DWORD_PTR dw)
        {
                ATLASSERT(dw != 0);
                if (dw == 0)
                        return;
                        
                CComTypeInfoHolder* p = (CComTypeInfoHolder*) dw;
                if (p->m_pInfo != NULL)
                        p->m_pInfo->Release();
                p->m_pInfo = NULL;
                delete [] p->m_pMap;
                p->m_pMap = NULL;
        }

        HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
        {
                return GetTI(lcid, pptinfo);
        }
        HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {
                HRESULT hRes = EnsureTI(lcid);
                if (m_pInfo != NULL)
                {
                        hRes = E_FAIL;
                        if (m_pMap != NULL && cNames == 1)
                        {
                                int n = ocslen(rgszNames[0]);
                                for (int j=m_nCount-1; j>=0; j--)
                                {
                                        if ((n == m_pMap[j].nLen) &&
                                                (memcmp(m_pMap[j].bstr, rgszNames[0], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
                                        {
                                                rgdispid[0] = m_pMap[j].id;
                                                hRes = S_OK;
                                                break;
                                        }
                                }
                        }
                        if (FAILED(hRes))
                        {
                                hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                        }
                }
                return hRes;
        }

        HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr)
        {
                HRESULT hRes = EnsureTI(lcid);
                if (m_pInfo != NULL)
                        hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
                return hRes;
        }

        HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
        {
                ATLASSERT(m_pMap == NULL);
                TYPEATTR* pta;
                HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
                if (SUCCEEDED(hr))
                {
                        m_nCount = pta->cFuncs;
                        
                        stringdispid* pMap = NULL;
                        if (m_nCount != 0)
                                ATLTRY(pMap = new stringdispid[m_nCount]);
                        if (m_nCount != 0 && pMap == NULL)
                        {
                                m_nCount = 0;
                                return E_OUTOFMEMORY;
                        }
                        for (int i=0; i<m_nCount; i++)
                        {
                                FUNCDESC* pfd;
                                hr = pTypeInfo->GetFuncDesc(i, &pfd);
                                if (SUCCEEDED(hr))
                                {
                                        CComBSTR bstrName;
                                        hr = pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL);
                                        if (SUCCEEDED(hr))
                                        {
                                                pMap[i].bstr.Attach(bstrName.Detach());
                                                pMap[i].nLen = SysStringLen(pMap[i].bstr);
                                                pMap[i].id = pfd->memid;
                                        }
                                        else
                                        {
                                                delete [] m_pMap;
                                                m_pMap = NULL;
                                                m_nCount = 0;
                                                pTypeInfo->ReleaseFuncDesc(pfd);
                                                break;
                                        }
                                        pTypeInfo->ReleaseFuncDesc(pfd);
                                }
                                else
                                {
                                        delete [] m_pMap;
                                        m_pMap = NULL;
                                        m_nCount = 0;
                                        break;
                                }
                        }
                        m_pMap = pMap;                        
                        pTypeInfo->ReleaseTypeAttr(pta);
                }
                return hr;
        }
};

inline HRESULT CComTypeInfoHolder::GetTI(LCID lcid)
{
        //If this assert occurs then most likely didn't initialize properly
        ATLASSERT(m_plibid != NULL && m_pguid != NULL);
        ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

        if (m_pInfo != NULL && m_pMap != NULL)
                return S_OK;
        HRESULT hRes = S_OK;
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        if (m_pInfo == NULL)
        {
                ITypeLib* pTypeLib;
                hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
                if (SUCCEEDED(hRes))
                {
                        CComPtr<ITypeInfo> spTypeInfo;
                        hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
                        if (SUCCEEDED(hRes))
                        {
                                CComPtr<ITypeInfo> spInfo(spTypeInfo);
                                CComPtr<ITypeInfo2> spTypeInfo2;
                                if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
                                        spInfo = spTypeInfo2;

                                m_pInfo = spInfo.Detach();
                                _Module.AddTermFunc(Cleanup, (DWORD_PTR)this);
                        }
                        pTypeLib->Release();
                }
        }
        if (m_pInfo != NULL && m_pMap == NULL)
        {
                LoadNameCache(m_pInfo);
        }
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
        return hRes;
}

//////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
//
template <class T>
class ATL_NO_VTABLE IObjectWithSiteImpl : public IObjectWithSite
{
public:
        STDMETHOD(SetSite)(IUnknown *pUnkSite)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IObjectWithSiteImpl::SetSite\n"));
                T* pT = static_cast<T*>(this);
                pT->m_spUnkSite = pUnkSite;
                return S_OK;
        }
        STDMETHOD(GetSite)(REFIID riid, void **ppvSite)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IObjectWithSiteImpl::GetSite\n"));
                T* pT = static_cast<T*>(this);
                ATLASSERT(ppvSite);
                HRESULT hRes = E_POINTER;
                if (ppvSite != NULL)
                {
                        if (pT->m_spUnkSite)
                                hRes = pT->m_spUnkSite->QueryInterface(riid, ppvSite);
                        else
                        {
                                *ppvSite = NULL;
                                hRes = E_FAIL;
                        }
                }
                return hRes;
        }

        HRESULT SetChildSite(IUnknown* punkChild)
        {
                if (punkChild == NULL)
                        return E_POINTER;

                HRESULT hr;
                CComPtr<IObjectWithSite> spChildSite;
                hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&spChildSite);
                if (SUCCEEDED(hr))
                        hr = spChildSite->SetSite((IUnknown*)this);

                return hr;
        }

        static HRESULT SetChildSite(IUnknown* punkChild, IUnknown* punkParent)
        {
                return AtlSetChildSite(punkChild, punkParent);
        }

        CComPtr<IUnknown> m_spUnkSite;
};

//////////////////////////////////////////////////////////////////////////////
// IServiceProvider
//
template <class T>
class ATL_NO_VTABLE IServiceProviderImpl : public IServiceProvider
{
public:
        STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void** ppvObject)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("IServiceProviderImpl::QueryService\n"));
                _ATL_VALIDATE_OUT_POINTER(ppvObject);
                T* pT = static_cast<T*>(this);
                return pT->_InternalQueryService(guidService, riid, ppvObject);
        }
};

#define BEGIN_SERVICE_MAP(x) public: \
        HRESULT _InternalQueryService(REFGUID guidService, REFIID riid, void** ppvObject) \
        {

#define SERVICE_ENTRY(x) \
                if (InlineIsEqualGUID(guidService, x)) \
                        return QueryInterface(riid, ppvObject);

#define SERVICE_ENTRY_CHAIN(x) \
                CComQIPtr<IServiceProvider, &IID_IServiceProvider> spProvider(x); \
                if (spProvider != NULL) \
                        return spProvider->QueryService(guidService, riid, ppvObject);

#define END_SERVICE_MAP() \
                return E_NOINTERFACE; \
        }


/////////////////////////////////////////////////////////////////////////////
// IDispEventImpl

#ifdef _ATL_DLL
ATLAPI AtlGetObjectSourceInterface(IUnknown* punkObj, GUID* plibid, IID* piid, unsigned short* pdwMajor, unsigned short* pdwMinor);
#else
ATLINLINE ATLAPI AtlGetObjectSourceInterface(IUnknown* punkObj, GUID* plibid, IID* piid, unsigned short* pdwMajor, unsigned short* pdwMinor)
{
        if (plibid == NULL || piid == NULL || pdwMajor == NULL || pdwMinor == NULL)
                return E_POINTER;
                
        *plibid = GUID_NULL;
        *piid = IID_NULL;
        *pdwMajor = 0;
        *pdwMinor = 0;
        
        HRESULT hr = E_FAIL;
        if (punkObj != NULL)
        {
                CComPtr<IDispatch> spDispatch;
                hr = punkObj->QueryInterface(IID_IDispatch, (void**)&spDispatch);
                if (SUCCEEDED(hr))
                {
                        CComPtr<ITypeInfo> spTypeInfo;
                        hr = spDispatch->GetTypeInfo(0, 0, &spTypeInfo);
                        if (SUCCEEDED(hr))
                        {
                                CComPtr<ITypeLib> spTypeLib;
                                hr = spTypeInfo->GetContainingTypeLib(&spTypeLib, 0);
                                if (SUCCEEDED(hr))
                                {
                                        TLIBATTR* plibAttr;
                                        hr = spTypeLib->GetLibAttr(&plibAttr);
                                        if (SUCCEEDED(hr))
                                        {
                                                memcpy(plibid, &plibAttr->guid, sizeof(GUID));
                                                *pdwMajor = plibAttr->wMajorVerNum;
                                                *pdwMinor = plibAttr->wMinorVerNum;
                                                spTypeLib->ReleaseTLibAttr(plibAttr);
                                                // First see if the object is willing to tell us about the
                                                // default source interface via IProvideClassInfo2
                                                CComPtr<IProvideClassInfo2> spInfo;
                                                hr = punkObj->QueryInterface(IID_IProvideClassInfo2, (void**)&spInfo);
                                                if (SUCCEEDED(hr) && spInfo != NULL)
                                                        hr = spInfo->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid);
                                                else
                                                {
                                                        // No, we have to go hunt for it
                                                        CComPtr<ITypeInfo> spInfoCoClass;
                                                        // If we have a clsid, use that
                                                        // Otherwise, try to locate the clsid from IPersist
                                                        CComPtr<IPersist> spPersist;
                                                        CLSID clsid;
                                                        hr = punkObj->QueryInterface(IID_IPersist, (void**)&spPersist);
                                                        if (SUCCEEDED(hr))
                                                        {
                                                                hr = spPersist->GetClassID(&clsid);
                                                                if (SUCCEEDED(hr))
                                                                {
                                                                        hr = spTypeLib->GetTypeInfoOfGuid(clsid, &spInfoCoClass);
                                                                        if (SUCCEEDED(hr))
                                                                        {
                                                                                TYPEATTR* pAttr=NULL;
                                                                                spInfoCoClass->GetTypeAttr(&pAttr);
                                                                                if (pAttr != NULL)
                                                                                {
                                                                                        HREFTYPE hRef;
                                                                                        for (int i = 0; i < pAttr->cImplTypes; i++)
                                                                                        {
                                                                                                int nType;
                                                                                                hr = spInfoCoClass->GetImplTypeFlags(i, &nType);
                                                                                                if (SUCCEEDED(hr))
                                                                                                {
                                                                                                        if (nType == (IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE))
                                                                                                        {
                                                                                                                // we found it
                                                                                                                hr = spInfoCoClass->GetRefTypeOfImplType(i, &hRef);
                                                                                                                if (SUCCEEDED(hr))
                                                                                                                {
                                                                                                                        CComPtr<ITypeInfo> spInfo;
                                                                                                                        hr = spInfoCoClass->GetRefTypeInfo(hRef, &spInfo);
                                                                                                                        if (SUCCEEDED(hr))
                                                                                                                        {
                                                                                                                                TYPEATTR* pAttrIF;
                                                                                                                                spInfo->GetTypeAttr(&pAttrIF);
                                                                                                                                if (pAttrIF != NULL)
                                                                                                                                {
                                                                                                                                        memcpy(piid, &pAttrIF->guid, sizeof(GUID));
                                                                                                                                        spInfo->ReleaseTypeAttr(pAttrIF);                                                                                                                                        
                                                                                                                                }
                                                                                                                        }
                                                                                                                }
                                                                                                                break;
                                                                                                        }
                                                                                                }
                                                                                        }
                                                                                        spInfoCoClass->ReleaseTypeAttr(pAttr);
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }
        return hr;
}
#endif // _ATL_DLL

#if defined(_M_IA64)
template <class T>
class CComStdCallThunk
{
public:
        typedef void (__stdcall T::*TMFP)();
        void* pVtable;
        void* pFunc;
        _stdcallthunk thunk;
        void Init(TMFP dw, void* pThis)
        {
                pVtable = &pFunc;
                pFunc = &thunk;         
                union {
                        DWORD_PTR dwFunc;
                        TMFP pfn;
                } pfn;
                pfn.pfn = dw;
                thunk.Init(pfn.dwFunc, pThis);
        }
};
#elif defined(_M_AMD64) || defined(_M_IX86)
template <class T>
class CComStdCallThunk
{
public:
        typedef void (__stdcall T::*TMFP)();
        void *pVTable;
        void *pThis;
        TMFP pfn;
        void (__stdcall *pfnHelper)();

        void Init(TMFP pf, void *p);
};

#if defined(_M_AMD64)
#pragma comment(lib, "atlamd64.lib")
extern "C" void CComStdCallThunkHelper(void);
#else

inline void __declspec(naked) __stdcall CComStdCallThunkHelper()
{
        __asm
        {
                mov eax, [esp+4];       // get pThunk
                mov edx, [eax+4];       // get the pThunk->pThis
                mov [esp+4], edx;       // replace pThunk with pThis
                mov eax, [eax+8];       // get pThunk->pfn
                jmp eax;                // jump pfn
        };
}
#endif

template <class T>
void CComStdCallThunk<T>::Init(TMFP pf, void *p)
{
        pfnHelper = CComStdCallThunkHelper;
        pVTable = &pfnHelper;
        pThis = p;
        pfn = pf;
}

#else
#error "No Target Architecture"
#endif // _M_IX86

#ifndef _ATL_MAX_VARTYPES
#define _ATL_MAX_VARTYPES 8
#endif

struct _ATL_FUNC_INFO
{
        CALLCONV cc;
        VARTYPE vtReturn;
        SHORT nParams;
        VARTYPE pVarTypes[_ATL_MAX_VARTYPES];
};

class ATL_NO_VTABLE _IDispEvent
{
public:
        _IDispEvent() {m_dwEventCookie = 0xFEFEFEFE;}
        
        //this method needs a different name than QueryInterface
        STDMETHOD(_LocDEQueryInterface)(REFIID riid, void ** ppvObject) = 0;
        virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
        virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
        GUID m_libid; // used for dynamic case
        IID m_iid; // used for dynamic case
    unsigned short m_wMajorVerNum;    // Major version number. used for dynamic case
    unsigned short m_wMinorVerNum;    // Minor version number. used for dynamic case
        DWORD m_dwEventCookie;
        HRESULT DispEventAdvise(IUnknown* pUnk, const IID* piid)
        {
                ATLASSERT(m_dwEventCookie == 0xFEFEFEFE);
                return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
        }
        HRESULT DispEventUnadvise(IUnknown* pUnk, const IID* piid)
        {
                HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
                m_dwEventCookie = 0xFEFEFEFE;
                return hr;
        }
};

template <UINT nID, const IID* piid>
class ATL_NO_VTABLE _IDispEventLocator : public _IDispEvent
{
public:
};

template <UINT nID, class T, const IID* pdiid>
class ATL_NO_VTABLE IDispEventSimpleImpl : public _IDispEventLocator<nID, pdiid>
{
public:
        STDMETHOD(_LocDEQueryInterface)(REFIID riid, void ** ppvObject)
        {
                _ATL_VALIDATE_OUT_POINTER(ppvObject);
                
                if (InlineIsEqualGUID(riid, *pdiid) || 
                        InlineIsEqualUnknown(riid) ||
                        InlineIsEqualGUID(riid, IID_IDispatch) ||
                        InlineIsEqualGUID(riid, m_iid))
                {
                        *ppvObject = this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, _T("IDispEventImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
                        return S_OK;
                }
                else
                        return E_NOINTERFACE;
        }

        // These are here only to support use in non-COM objects        
        virtual ULONG STDMETHODCALLTYPE AddRef()
        {
                return 1;
        }
        virtual ULONG STDMETHODCALLTYPE Release()
        {
                return 1;
        }

        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
        {return E_NOTIMPL;}

        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
        {return E_NOTIMPL;}

        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {return E_NOTIMPL;}

        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                LCID lcid, WORD /*wFlags*/, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* /*pexcepinfo*/, UINT* /*puArgErr*/)
        {
                T* pT = static_cast<T*>(this);
                const _ATL_EVENT_ENTRY<T>* pMap = T::_GetSinkMap();
                const _ATL_EVENT_ENTRY<T>* pFound = NULL;
                void (__stdcall T::*pEvent)() = NULL;
                while (pMap->piid != NULL)
                {
                        if ((pMap->nControlID == nID) && (pMap->dispid == dispidMember) &&
                                (pMap->piid == pdiid)) //comparing pointers here should be adequate
                        {
                                pFound = pMap;
                                break;
                        }
                        pMap++;
                }
                if (pFound == NULL)
                        return S_OK;
                
                _ATL_FUNC_INFO info;
                _ATL_FUNC_INFO* pInfo;
                if (pFound->pInfo != NULL)
                        pInfo = pFound->pInfo;
                else
                {
                        pInfo = &info;
                        HRESULT hr = GetFuncInfoFromId(*pdiid, dispidMember, lcid, info);
                        if (FAILED(hr))
                                return S_OK;
                }
                return InvokeFromFuncInfo(pFound->pfn, *pInfo, pdispparams, pvarResult);
        }

        //Helper for invoking the event
        HRESULT InvokeFromFuncInfo(void (__stdcall T::*pEvent)(), _ATL_FUNC_INFO& info, DISPPARAMS* pdispparams, VARIANT* pvarResult)
        {
                T* pT = static_cast<T*>(this);
                // If this assert occurs, then add a #define _ATL_MAX_VARTYPES nnnn
                // before including atlcom.h
                ATLASSERT(info.nParams <= _ATL_MAX_VARTYPES);
                if (info.nParams > _ATL_MAX_VARTYPES)
                {
                        return E_FAIL;
                }
                VARIANTARG* rgVarArgs[_ATL_MAX_VARTYPES];
                VARIANTARG** pVarArgs = info.nParams ? rgVarArgs : 0;

                for (int i=0; i<info.nParams; i++)
                        pVarArgs[i] = &pdispparams->rgvarg[info.nParams - i - 1];

                CComStdCallThunk<T> thunk;
                thunk.Init(pEvent, pT);
                CComVariant tmpResult;
                if (pvarResult == NULL)
                        pvarResult = &tmpResult;

                HRESULT hr = DispCallFunc(
                        &thunk,
                        0,
                        info.cc,
                        info.vtReturn,
                        info.nParams,
                        info.pVarTypes,
                        pVarArgs,
                        pvarResult);
                ATLASSERT(SUCCEEDED(hr));
                return hr;
        }

        //Helper for finding the function index for a DISPID
        virtual HRESULT GetFuncInfoFromId(const IID& iid, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
        {
                return E_NOTIMPL;
        }
        //Helpers for sinking events on random IUnknown*
        HRESULT DispEventAdvise(IUnknown* pUnk, const IID* piid)
        {
                ATLASSERT(m_dwEventCookie == 0xFEFEFEFE);
                if (m_dwEventCookie != 0xFEFEFEFE)
                        return E_UNEXPECTED;
                return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
        }
        HRESULT DispEventUnadvise(IUnknown* pUnk, const IID* piid)
        {
                HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
                m_dwEventCookie = 0xFEFEFEFE;
                return hr;
        }
        HRESULT DispEventAdvise(IUnknown* pUnk)
        {
                return _IDispEvent::DispEventAdvise(pUnk, pdiid);
        }
        HRESULT DispEventUnadvise(IUnknown* pUnk)
        {
                return _IDispEvent::DispEventUnadvise(pUnk, pdiid);
        }
};

//Helper for advising connections points from a sink map
template <class T>
inline HRESULT AtlAdviseSinkMap(T* pT, bool bAdvise)
{
        ATLASSERT(::IsWindow(pT->m_hWnd));
        const _ATL_EVENT_ENTRY<T>* pEntries = T::_GetSinkMap();
        if (pEntries == NULL)
                return S_OK;
        HRESULT hr = S_OK;
        while (pEntries->piid != NULL)
        {
                _IDispEvent* pDE = (_IDispEvent*)((DWORD_PTR)pT+pEntries->nOffset);
                bool bNotAdvised = pDE->m_dwEventCookie == 0xFEFEFEFE;
                if (bAdvise ^ bNotAdvised)
                {
                        pEntries++;
                        continue;
                }
                hr = E_FAIL;
                HWND h = pT->GetDlgItem(pEntries->nControlID);
                ATLASSERT(h != NULL);
                if (h != NULL)
                {
                        CComPtr<IUnknown> spUnk;
                        AtlAxGetControl(h, &spUnk);
                        ATLASSERT(spUnk != NULL);
                        if (spUnk != NULL)
                        {
                                if (bAdvise)
                                {
                                        if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
                                                hr = pDE->DispEventAdvise(spUnk, pEntries->piid);
                                        else
                                        {
                                                AtlGetObjectSourceInterface(spUnk, &pDE->m_libid, &pDE->m_iid, &pDE->m_wMajorVerNum, &pDE->m_wMinorVerNum);
                                                hr = pDE->DispEventAdvise(spUnk, &pDE->m_iid);
                                        }
                                }
                                else
                                {
                                        if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
                                                hr = pDE->DispEventUnadvise(spUnk, pEntries->piid);
                                        else
                                                hr = pDE->DispEventUnadvise(spUnk, &pDE->m_iid);
                                }
                                ATLASSERT(hr == S_OK);
                        }
                }
                if (FAILED(hr))
                        break;
                pEntries++;
        }
        return hr;
}

template <UINT nID, class T, const IID* pdiid = &IID_NULL, const GUID* plibid = &GUID_NULL,
        WORD wMajor = 0, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispEventImpl : public IDispEventSimpleImpl<nID, T, pdiid>
{
public:
        typedef tihclass _tihclass;

        IDispEventImpl()
        {
                m_libid = *plibid;
                m_iid = *pdiid;
                m_wMajorVerNum = wMajor;
                m_wMinorVerNum = wMinor;
        }

        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
        {if( pctinfo == NULL ) return E_INVALIDARG; *pctinfo = 1; return S_OK;}

        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
        {return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

        //Helper for finding the function index for a DISPID
        HRESULT GetFuncInfoFromId(const IID& /*iid*/, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
        {
                CComPtr<ITypeInfo> spTypeInfo;
                if (InlineIsEqualGUID(*_tih.m_plibid, GUID_NULL))
                {
                        _tih.m_plibid = &m_libid;
                        _tih.m_pguid = &m_iid;
                        _tih.m_wMajor = m_wMajorVerNum;
                        _tih.m_wMinor = m_wMinorVerNum;
                }
                HRESULT hr = _tih.GetTI(lcid, &spTypeInfo);
                if (FAILED(hr))
                        return hr;
                CComQIPtr<ITypeInfo2, &IID_ITypeInfo2> spTypeInfo2 = spTypeInfo;
                FUNCDESC* pFuncDesc = NULL;
                if (spTypeInfo2 != NULL)
                {
                        UINT nIndex;
                        hr = spTypeInfo2->GetFuncIndexOfMemId(dispidMember, INVOKE_FUNC, &nIndex);
                        if (FAILED(hr))
                                return hr;
                        hr = spTypeInfo->GetFuncDesc(nIndex, &pFuncDesc);
                        if (FAILED(hr))
                                return hr;
                }
                else // search for funcdesc
                {
                        TYPEATTR* pAttr;
                        hr = spTypeInfo->GetTypeAttr(&pAttr);
                        if (FAILED(hr))
                                return hr;
                        for (int i=0;i<pAttr->cFuncs;i++)
                        {
                                hr = spTypeInfo->GetFuncDesc(i, &pFuncDesc);
                                if (FAILED(hr))
                                        return hr;
                                if (pFuncDesc->memid == dispidMember)
                                        break;
                                spTypeInfo->ReleaseFuncDesc(pFuncDesc);
                                pFuncDesc = NULL;
                        }
                        spTypeInfo->ReleaseTypeAttr(pAttr);
                        if (pFuncDesc == NULL)
                                return E_FAIL;
                }

                // If this assert occurs, then add a #define _ATL_MAX_VARTYPES nnnn
                // before including atlcom.h
                ATLASSERT(pFuncDesc->cParams <= _ATL_MAX_VARTYPES);
                if (pFuncDesc->cParams > _ATL_MAX_VARTYPES)
                        return E_FAIL;

                for (int i=0; i<pFuncDesc->cParams; i++)
                {
                        info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[i].tdesc.vt;
                        if (info.pVarTypes[i] == VT_PTR)
                                info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[i].tdesc.lptdesc->vt | VT_BYREF;
                        if (info.pVarTypes[i] == VT_USERDEFINED)
                                info.pVarTypes[i] = GetUserDefinedType(spTypeInfo,pFuncDesc->lprgelemdescParam[i].tdesc.hreftype);
                }

                VARTYPE vtReturn = pFuncDesc->elemdescFunc.tdesc.vt;
                switch(vtReturn)
                {
                case VT_INT:
                        vtReturn = VT_I4;
                        break;
                case VT_UINT:
                        vtReturn = VT_UI4;
                        break;
                case VT_VOID:
                        vtReturn = VT_EMPTY; // this is how DispCallFunc() represents void
                        break;
                case VT_HRESULT:
                        vtReturn = VT_ERROR;
                        break;
                }
                info.vtReturn = vtReturn;
                info.cc = pFuncDesc->callconv;
                info.nParams = pFuncDesc->cParams;
                spTypeInfo->ReleaseFuncDesc(pFuncDesc);
                return S_OK;
        }
        VARTYPE GetUserDefinedType(ITypeInfo *pTI, HREFTYPE hrt)
        {
                CComPtr<ITypeInfo> spTypeInfo;
                VARTYPE vt = VT_USERDEFINED;
                HRESULT hr = E_FAIL;
                hr = pTI->GetRefTypeInfo(hrt, &spTypeInfo);
                if(FAILED(hr))
                        return vt;
                TYPEATTR *pta=NULL;

                spTypeInfo->GetTypeAttr(&pta);
                if(pta && pta->typekind == TKIND_ALIAS)
                {
                        if (pta->tdescAlias.vt == VT_USERDEFINED)
                                GetUserDefinedType(spTypeInfo,pta->tdescAlias.hreftype);
                        else
                                vt = pta->tdescAlias.vt;
                }
        
                if(pta)
                        spTypeInfo->ReleaseTypeAttr(pta);
                return vt;

        }
protected:
        static _tihclass _tih;
        static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
        {return _tih.GetTI(lcid, ppInfo);}
};


template <UINT nID, class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
        {piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};

template <class T>
struct _ATL_EVENT_ENTRY
{
        UINT nControlID;                        //ID identifying object instance
        const IID* piid;                        //dispinterface IID
        INT_PTR nOffset;                        //offset of dispinterface from this pointer
        DISPID dispid;                          //DISPID of method/property
        void (__stdcall T::*pfn)();     //method to invoke
        _ATL_FUNC_INFO* pInfo;
};



//Sink map is used to set up event handling
#define BEGIN_SINK_MAP(_class)\
        static const _ATL_EVENT_ENTRY<_class>* _GetSinkMap()\
        {\
                typedef _class _atl_event_classtype;\
                static const _ATL_EVENT_ENTRY<_class> map[] = {


#define SINK_ENTRY_INFO(id, iid, dispid, fn, info) {id, &iid, (INT_PTR)(static_cast<_IDispEventLocator<id, &iid>*>((_atl_event_classtype*)8))-8, dispid, (void (__stdcall _atl_event_classtype::*)())fn, info},
#define SINK_ENTRY_EX(id, iid, dispid, fn) SINK_ENTRY_INFO(id, iid, dispid, fn, NULL)
#define SINK_ENTRY(id, dispid, fn) SINK_ENTRY_EX(id, IID_NULL, dispid, fn)
#define END_SINK_MAP() {0, NULL, 0, 0, NULL, NULL} }; return map;}

/////////////////////////////////////////////////////////////////////////////
// IDispatchImpl

template <class T, const IID* piid, const GUID* plibid = &CComModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispatchImpl : public T
{
public:
        typedef tihclass _tihclass;
// IDispatch
        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
        {
                if( pctinfo == NULL ) 
                        return E_INVALIDARG; 
                *pctinfo = 1;
                return S_OK;
        }
        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
        {
                return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
        }
        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {
                return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
        }
        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr)
        {
                return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        }
protected:
        static _tihclass _tih;
        static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
        {
                return _tih.GetTI(lcid, ppInfo);
        }
};

template <class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfoImpl
template <const CLSID* pcoclsid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfoImpl : public IProvideClassInfo
{
public:
        typedef tihclass _tihclass;

        STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
        {
                return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
        }

protected:
        static _tihclass _tih;
};

template <const CLSID* pcoclsid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};

/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfo2Impl
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfo2Impl : public IProvideClassInfo2
{
public:
        typedef tihclass _tihclass;

        STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
        {
                return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
        }
        STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID)
        {
                if (pGUID == NULL)
                        return E_POINTER;

                if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID && psrcid)
                {
                        *pGUID = *psrcid;
                        return S_OK;
                }
                *pGUID = GUID_NULL;
                return E_FAIL;
        }

protected:
        static _tihclass _tih;
};


template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfoImpl

template <const IID* piid>
class ATL_NO_VTABLE ISupportErrorInfoImpl : public ISupportErrorInfo
{
public:
        STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
        {
                return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;
        }
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
        static HRESULT copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T)); return S_OK;}
        static void init(T*) {}
        static void destroy(T*) {}
};

template<>
class _Copy<VARIANT>
{
public:
        static HRESULT copy(VARIANT* p1, VARIANT* p2) {return VariantCopy(p1, p2);}
        static void init(VARIANT* p) {p->vt = VT_EMPTY;}
        static void destroy(VARIANT* p) {VariantClear(p);}
};

template<>
class _Copy<LPOLESTR>
{
public:
        static HRESULT copy(LPOLESTR* p1, LPOLESTR* p2)
        {
                HRESULT hr = S_OK;
                (*p1) = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(*p2)+1));
                if (*p1 == NULL)
                        hr = E_OUTOFMEMORY;
                else
                        ocscpy(*p1,*p2);
                return hr;
        }
        static void init(LPOLESTR* p) {*p = NULL;}
        static void destroy(LPOLESTR* p) { CoTaskMemFree(*p);}
};

template<>
class _Copy<OLEVERB>
{
public:
        static HRESULT copy(OLEVERB* p1, OLEVERB* p2)
        {
                HRESULT hr = S_OK;
                *p1 = *p2;
                if (p2->lpszVerbName == NULL)
                        return S_OK;
                p1->lpszVerbName = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(p2->lpszVerbName)+1));
                if (p1->lpszVerbName == NULL)
                        hr = E_OUTOFMEMORY;
                else
                        ocscpy(p1->lpszVerbName,p2->lpszVerbName);
                return hr;
        }
        static void init(OLEVERB* p) { p->lpszVerbName = NULL;}
        static void destroy(OLEVERB* p) { if (p->lpszVerbName) CoTaskMemFree(p->lpszVerbName);}
};

template<>
class _Copy<CONNECTDATA>
{
public:
        static HRESULT copy(CONNECTDATA* p1, CONNECTDATA* p2)
        {
                *p1 = *p2;
                if (p1->pUnk)
                        p1->pUnk->AddRef();
                return S_OK;
        }
        static void init(CONNECTDATA* ) {}
        static void destroy(CONNECTDATA* p) {if (p->pUnk) p->pUnk->Release();}
};

template <class T>
class _CopyInterface
{
public:
        static HRESULT copy(T** p1, T** p2)
        {
                *p1 = *p2;
                if (*p1)
                        (*p1)->AddRef();
                return S_OK;
        }
        static void init(T** ) {}
        static void destroy(T** p) {if (*p) (*p)->Release();}
};

template<class T>
class ATL_NO_VTABLE CComIEnum : public IUnknown
{
public:
        STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
        STDMETHOD(Skip)(ULONG celt) = 0;
        STDMETHOD(Reset)(void) = 0;
        STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
        //see FlagBits in CComEnumImpl
        AtlFlagNoCopy = 0,
        AtlFlagTakeOwnership = 2,
        AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy>
class ATL_NO_VTABLE CComEnumImpl : public Base
{
public:
        CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0;}
        ~CComEnumImpl();
        STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void){m_iter = m_begin;return S_OK;}
        STDMETHOD(Clone)(Base** ppEnum);
        HRESULT Init(T* begin, T* end, IUnknown* pUnk,
                CComEnumFlags flags = AtlFlagNoCopy);
        CComPtr<IUnknown> m_spUnk;
        T* m_begin;
        T* m_end;
        T* m_iter;
        DWORD m_dwFlags;
protected:
        enum FlagBits
        {
                BitCopy=1,
                BitOwn=2
        };
};

template <class Base, const IID* piid, class T, class Copy>
CComEnumImpl<Base, piid, T, Copy>::~CComEnumImpl()
{
        if (m_dwFlags & BitOwn)
        {
                for (T* p = m_begin; p != m_end; p++)
                        Copy::destroy(p);
                delete [] m_begin;
        }
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Next(ULONG celt, T* rgelt,
        ULONG* pceltFetched)
{
        if ((celt == 0) && (rgelt == NULL) && (NULL != pceltFetched))
        {
                // Return the number of remaining elements
                *pceltFetched = (ULONG)(m_end - m_iter);
                return S_OK;
        }
        if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
                return E_POINTER;
        if (m_begin == NULL || m_end == NULL || m_iter == NULL)
                return E_FAIL;
        ULONG nRem = (ULONG)(m_end - m_iter);
        HRESULT hRes = S_OK;
        if (nRem < celt)
                hRes = S_FALSE;
        ULONG nMin = min(celt, nRem);
        if (pceltFetched != NULL)
                *pceltFetched = nMin;
        T* pelt = rgelt;
        while(nMin--)
        {
                HRESULT hr = Copy::copy(pelt, m_iter);
                if (FAILED(hr))
                {
                        while (rgelt < pelt)
                                Copy::destroy(rgelt++);
                        if (pceltFetched != NULL)
                                *pceltFetched = 0;
                        return hr;
                }
                pelt++;
                m_iter++;
        }
        return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(ULONG celt)
{
        m_iter += celt;
    if (m_iter > m_end)
        {
        m_iter = m_end;
        return S_FALSE;
    }
    if (m_iter < m_begin)
        {       
        m_iter = m_begin;
        return S_FALSE;
    }
    return S_OK;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(Base** ppEnum)
{
        typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
        HRESULT hRes = E_POINTER;
        if (ppEnum != NULL)
        {
                *ppEnum = NULL;
                _class* p;
                hRes = _class::CreateInstance(&p);
                if (SUCCEEDED(hRes))
                {
                        // If the data is a copy then we need to keep "this" object around
                        hRes = p->Init(m_begin, m_end, (m_dwFlags & BitCopy) ? this : m_spUnk);
                        if (SUCCEEDED(hRes))
                        {
                                p->m_iter = m_iter;
                                hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
                        }
                        if (FAILED(hRes))
                                delete p;
                }
        }
        return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
HRESULT CComEnumImpl<Base, piid, T, Copy>::Init(T* begin, T* end, IUnknown* pUnk,
        CComEnumFlags flags)
{
        if (flags == AtlFlagCopy)
        {
                ATLASSERT(m_begin == NULL); //Init called twice?
                ATLTRY(m_begin = new T[ULONG(end-begin)])
                m_iter = m_begin;
                if (m_begin == NULL)
                        return E_OUTOFMEMORY;
                for (T* i=begin; i != end; i++)
                {
                        Copy::init(m_iter);
                        HRESULT hr = Copy::copy(m_iter, i);
                        if (FAILED(hr))
                        {
                                T* p = m_begin;
                                while (p < m_iter)
                                        Copy::destroy(p++);
                                delete [] m_begin;
                                m_begin = m_end = m_iter = NULL;
                                return hr;
                        }
                        m_iter++;
                }
                m_end = m_begin + (end-begin);
        }
        else
        {
                m_begin = begin;
                m_end = end;
        }
        m_spUnk = pUnk;
        m_iter = m_begin;
        m_dwFlags = flags;
        return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnum :
        public CComEnumImpl<Base, piid, T, Copy>,
        public CComObjectRootEx< ThreadModel >
{
public:
        typedef CComEnum<Base, piid, T, Copy > _CComEnum;
        typedef CComEnumImpl<Base, piid, T, Copy > _CComEnumBase;
        BEGIN_COM_MAP(_CComEnum)
                COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
        END_COM_MAP()
};

template <class Base, const IID* piid, class T, class Copy, class CollType>
class ATL_NO_VTABLE IEnumOnSTLImpl : public Base
{
public:
        HRESULT Init(IUnknown *pUnkForRelease, CollType& collection)
        {
                m_spUnk = pUnkForRelease;
                m_pcollection = &collection;
                m_iter = m_pcollection->begin();
                return S_OK;
        }
        STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void)
        {
                if (m_pcollection == NULL)
                        return E_FAIL;
                m_iter = m_pcollection->begin();
                return S_OK;
        }
        STDMETHOD(Clone)(Base** ppEnum);
//Data
        CComPtr<IUnknown> m_spUnk;
        CollType* m_pcollection;
        typename CollType::iterator m_iter;
};

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Next(ULONG celt, T* rgelt,
        ULONG* pceltFetched)
{
        if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
                return E_POINTER;
        if (pceltFetched != NULL)
                *pceltFetched = 0;
        if (m_pcollection == NULL)
                return E_FAIL;

        ULONG nActual = 0;
        HRESULT hr = S_OK;
        T* pelt = rgelt;
        while (SUCCEEDED(hr) && m_iter != m_pcollection->end() && nActual < celt)
        {
                hr = Copy::copy(pelt, &*m_iter);
                if (FAILED(hr))
                {
                        while (rgelt < pelt)
                                Copy::destroy(rgelt++);
                        nActual = 0;
                }
                else
                {
                        pelt++;
                        m_iter++;
                        nActual++;
                }
        }
        if (SUCCEEDED(hr))
        {
                if (pceltFetched)
                        *pceltFetched = nActual;
                if (nActual < celt)
                        hr = S_FALSE;
        }                        
        return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Skip(ULONG celt)
{
        HRESULT hr = S_OK;
        while (celt--)
        {
                if (m_iter != m_pcollection->end())
                        m_iter++;
                else
                {
                        hr = S_FALSE;
                        break;
                }
        }
        return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Clone(Base** ppEnum)
{
        typedef CComObject<CComEnumOnSTL<Base, piid, T, Copy, CollType> > _class;
        HRESULT hRes = E_POINTER;
        if (ppEnum != NULL)
        {
                *ppEnum = NULL;
                _class* p;
                hRes = _class::CreateInstance(&p);
                if (SUCCEEDED(hRes))
                {
                        hRes = p->Init(m_spUnk, *m_pcollection);
                        if (SUCCEEDED(hRes))
                        {
                                p->m_iter = m_iter;
                                hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
                        }
                        if (FAILED(hRes))
                                delete p;
                }
        }
        return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnumOnSTL :
        public IEnumOnSTLImpl<Base, piid, T, Copy, CollType>,
        public CComObjectRootEx< ThreadModel >
{
public:
        typedef CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel > _CComEnum;
        typedef IEnumOnSTLImpl<Base, piid, T, Copy, CollType > _CComEnumBase;
        BEGIN_COM_MAP(_CComEnum)
                COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
        END_COM_MAP()
};

template <class T, class CollType, class ItemType, class CopyItem, class EnumType>
class ICollectionOnSTLImpl : public T
{
public:
        STDMETHOD(get_Count)(long* pcount)
        {
                if (pcount == NULL)
                        return E_POINTER;
                *pcount = m_coll.size();
                return S_OK;
        }
        STDMETHOD(get_Item)(long Index, ItemType* pvar)
        {
                //Index is 1-based
                if (pvar == NULL)
                        return E_POINTER;
                if (Index < 1)
                        return E_INVALIDARG;                        
                HRESULT hr = E_FAIL;
                Index--;
                CollType::iterator iter = m_coll.begin();
                while (iter != m_coll.end() && Index > 0)
                {
                        iter++;
                        Index--;
                }
                if (iter != m_coll.end())
                        hr = CopyItem::copy(pvar, &*iter);
                return hr;
        }
        STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
        {
                if (ppUnk == NULL)
                        return E_POINTER;
                *ppUnk = NULL;
                HRESULT hRes = S_OK;
                CComObject<EnumType>* p;
                hRes = CComObject<EnumType>::CreateInstance(&p);
                if (SUCCEEDED(hRes))
                {
                        hRes = p->Init(this, m_coll);
                        if (hRes == S_OK)
                                hRes = p->QueryInterface(IID_IUnknown, (void**)ppUnk);
                }
                if (hRes != S_OK)
                        delete p;
                return hRes;
        }
        CollType m_coll;
};

//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPagesImpl
template <class T>
class ATL_NO_VTABLE ISpecifyPropertyPagesImpl : public ISpecifyPropertyPages
{
public:
        // ISpecifyPropertyPages
        //
        STDMETHOD(GetPages)(CAUUID* pPages)
        {
                ATLTRACE2(atlTraceCOM, 0, _T("ISpecifyPropertyPagesImpl::GetPages\n"));
                ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
                return GetPagesHelper(pPages, pMap);
        }
protected:
        HRESULT GetPagesHelper(CAUUID* pPages, ATL_PROPMAP_ENTRY* pMap)
        {
                if (pPages == NULL)
                        return E_POINTER;

                ATLASSERT(pMap != NULL);
                if (pMap == NULL)
                        return E_POINTER;

                int nCnt = 0;
                int i;
                // Get count of unique pages to alloc the array
                for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
                {
                        // only allow non data entry types
                        if (pMap[i].vt == 0)
                        {
                                // Does this property have a page?  CLSID_NULL means it does not
                                if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
                                        nCnt++;
                        }
                }
                pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
                if (pPages->pElems == NULL)
                        return E_OUTOFMEMORY;
                // reset count of items we have added to the array
                nCnt = 0;
                for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
                {
                        // only allow non data entry types
                        if (pMap[i].vt == 0)
                        {
                                // Does this property have a page?  CLSID_NULL means it does not
                                if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
                                {
                                        BOOL bFound = FALSE;
                                        // Search through array we are building up to see
                                        // if it is already in there
                                        for (int j=0; j<nCnt; j++)
                                        {
                                                if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
                                                {
                                                        // It's already there, so no need to add it again
                                                        bFound = TRUE;
                                                        break;
                                                }
                                        }
                                        // If we didn't find it in there then add it
                                        if (!bFound)
                                                pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
                                }
                        }
                }
                pPages->cElems = nCnt;
                return S_OK;
        }

};

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

struct _ATL_CONNMAP_ENTRY
{
        DWORD_PTR dwOffset;
};


// We want the offset of the connection point relative to the connection
// point container base class
#define BEGIN_CONNECTION_POINT_MAP(x)\
        typedef x _atl_conn_classtype;\
        static const _ATL_CONNMAP_ENTRY* GetConnMap(int* pnEntries) {\
        static const _ATL_CONNMAP_ENTRY _entries[] = {
// CONNECTION_POINT_ENTRY computes the offset of the connection point to the
// IConnectionPointContainer interface
#define CONNECTION_POINT_ENTRY(iid){offsetofclass(_ICPLocator<&iid>, _atl_conn_classtype)-\
        offsetofclass(IConnectionPointContainerImpl<_atl_conn_classtype>, _atl_conn_classtype)},
#define END_CONNECTION_POINT_MAP() {(DWORD_PTR)-1} }; \
        if (pnEntries) *pnEntries = sizeof(_entries)/sizeof(_ATL_CONNMAP_ENTRY) - 1; \
        return _entries;}


#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComUnkArray
{
public:
        CComUnkArray()
        {
                memset(m_arr, 0, sizeof(IUnknown*)*nMaxSize);
        }
        DWORD Add(IUnknown* pUnk);
        BOOL Remove(DWORD dwCookie);
        DWORD WINAPI GetCookie(IUnknown** pp)
        {
                ULONG iIndex;

                iIndex = ULONG(pp-begin());
                return( iIndex+1 );
        }
        IUnknown* WINAPI GetUnknown(DWORD dwCookie)
        {
                if( dwCookie == 0 )
                {
                        return NULL;
                }
                
                ULONG iIndex;
                iIndex = dwCookie-1;
                return( begin()[iIndex] );
        }
        IUnknown** begin()
        {
                return &m_arr[0];
        }
        IUnknown** end()
        {
                return &m_arr[nMaxSize];
        }
protected:
        IUnknown* m_arr[nMaxSize];
};

template <unsigned int nMaxSize>
inline DWORD CComUnkArray<nMaxSize>::Add(IUnknown* pUnk)
{
        for (IUnknown** pp = begin();pp<end();pp++)
        {
                if (*pp == NULL)
                {
                        *pp = pUnk;
                        return (DWORD)((pp-begin())+1); // return cookie
                }
        }
        // If this fires then you need a larger array
        ATLASSERT(0);
        return 0;
}

template <unsigned int nMaxSize>
inline BOOL CComUnkArray<nMaxSize>::Remove(DWORD dwCookie)
{
        ULONG iIndex;

        iIndex = dwCookie-1;
        if (iIndex >= nMaxSize)
        {
                return FALSE;
        }

        begin()[iIndex] = NULL;

        return TRUE;
}

template<>
class CComUnkArray<1>
{
public:
        CComUnkArray()
        {
                m_arr[0] = NULL;
        }
        DWORD Add(IUnknown* pUnk)
        {
                if (m_arr[0] != NULL)
                {
                        // If this fires then you need a larger array
                        ATLASSERT(0);
                        return 0;
                }
                m_arr[0] = pUnk;
                return 1;
        }
        BOOL Remove(DWORD dwCookie)
        {
                if (dwCookie != 1)
                        return FALSE;
                m_arr[0] = NULL;
                return TRUE;
        }
        DWORD WINAPI GetCookie(IUnknown** /*pp*/)
        {
                return 1;
        }
        IUnknown* WINAPI GetUnknown(DWORD dwCookie)
        {
                if (dwCookie != 1)
                {
                        return NULL;
                }

                return *begin();
        }
        IUnknown** begin()
        {
                return &m_arr[0];
        }
        IUnknown** end()
        {
                return (&m_arr[0])+1;
        }
protected:
        IUnknown* m_arr[1];
};

class CComDynamicUnkArray
{
public:
        CComDynamicUnkArray()
        {
                m_nSize = 0;
                m_ppUnk = NULL;
        }

        ~CComDynamicUnkArray()
        {
                if (m_nSize > 1)
                        free(m_ppUnk);
        }
        DWORD Add(IUnknown* pUnk);
        BOOL Remove(DWORD dwCookie);
        DWORD WINAPI GetCookie(IUnknown** pp)
        {
                ULONG iIndex;
                iIndex = ULONG(pp-begin());
                return iIndex+1;
        }
        IUnknown* WINAPI GetUnknown(DWORD dwCookie)
        {
                ULONG iIndex;

                if (dwCookie == 0)
                        return NULL;

                iIndex = dwCookie-1;
                return begin()[iIndex];
        }
        IUnknown** begin()
        {
                return (m_nSize < 2) ? &m_pUnk : m_ppUnk;
        }
        IUnknown** end()
        {
                return (m_nSize < 2) ? (&m_pUnk)+m_nSize : &m_ppUnk[m_nSize];
        }

        IUnknown* GetAt(int nIndex)
        {
                if (nIndex < 0 || nIndex >= m_nSize)
                        return NULL;

                return (m_nSize < 2) ? m_pUnk : m_ppUnk[nIndex];
        }
        int GetSize() const
        {
                return m_nSize;
        }

        void clear()
        {
                if (m_nSize > 1)
                        free(m_ppUnk);
                m_nSize = 0;
        }
protected:
        union
        {
                IUnknown** m_ppUnk;
                IUnknown* m_pUnk;
        };
        int m_nSize;
};

inline DWORD CComDynamicUnkArray::Add(IUnknown* pUnk)
{
        ULONG iIndex;

        IUnknown** pp = NULL;
        if (m_nSize == 0) // no connections
        {
                m_pUnk = pUnk;
                m_nSize = 1;
                return 1;
        }
        else if (m_nSize == 1)
        {
                //create array
                pp = (IUnknown**)malloc(sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
                if (pp == NULL)
                        return 0;
                memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
                *pp = m_pUnk;
                m_ppUnk = pp;
                m_nSize = _DEFAULT_VECTORLENGTH;
        }
        for (pp = begin();pp<end();pp++)
        {
                if (*pp == NULL)
                {
                        *pp = pUnk;
                        iIndex = ULONG(pp-begin());
                        return iIndex+1;
                }
        }
        int nAlloc = m_nSize*2;
        pp = (IUnknown**)realloc(m_ppUnk, sizeof(IUnknown*)*nAlloc);
        if (pp == NULL)
                return 0;
        m_ppUnk = pp;
        memset(&m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize);
        m_ppUnk[m_nSize] = pUnk;
        iIndex = m_nSize;
        m_nSize = nAlloc;
        return iIndex+1;
}

inline BOOL CComDynamicUnkArray::Remove(DWORD dwCookie)
{
        ULONG iIndex;
        if (dwCookie == NULL)
                return FALSE;
        if (m_nSize == 0)
                return FALSE;
        iIndex = dwCookie-1;
        if (iIndex >= (ULONG)m_nSize)
                return FALSE;
        if (m_nSize == 1)
        {
                m_nSize = 0;
                return TRUE;
        }
        begin()[iIndex] = NULL;

        return TRUE;
}

template <const IID* piid>
class ATL_NO_VTABLE _ICPLocator
{
public:
        //this method needs a different name than QueryInterface
        STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject) = 0;
        virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
        virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
};

template <class T, const IID* piid, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IConnectionPointImpl : public _ICPLocator<piid>
{
public:
        typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
                _Copy<CONNECTDATA> > CComEnumConnections;
        typedef CDV _CDV;
        ~IConnectionPointImpl();
        STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject)
        {
                _ATL_VALIDATE_OUT_POINTER(ppvObject);
                
                if (InlineIsEqualGUID(riid, IID_IConnectionPoint) || InlineIsEqualUnknown(riid))
                {
                        *ppvObject = this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, _T("IConnectionPointImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
                        return S_OK;
                }
                else
                        return E_NOINTERFACE;
        }

        STDMETHOD(GetConnectionInterface)(IID* piid2)
        {
                if (piid2 == NULL)
                        return E_POINTER;
                *piid2 = *piid;
                return S_OK;
        }
        STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC)
        {
                T* pT = static_cast<T*>(this);
                // No need to check ppCPC for NULL since QI will do that for us
                return pT->QueryInterface(IID_IConnectionPointContainer, (void**)ppCPC);
        }
        STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
        STDMETHOD(Unadvise)(DWORD dwCookie);
        STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);
        CDV m_vec;
};

template <class T, const IID* piid, class CDV>
IConnectionPointImpl<T, piid, CDV>::~IConnectionPointImpl()
{
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
                if (*pp != NULL)
                        (*pp)->Release();
                pp++;
        }
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Advise(IUnknown* pUnkSink,
        DWORD* pdwCookie)
{
        T* pT = static_cast<T*>(this);
        IUnknown* p;
        HRESULT hRes = S_OK;
        if (pdwCookie != NULL)
            *pdwCookie = 0;
        if (pUnkSink == NULL || pdwCookie == NULL)
                return E_POINTER;
        IID iid;
        GetConnectionInterface(&iid);
        hRes = pUnkSink->QueryInterface(iid, (void**)&p);
        if (SUCCEEDED(hRes))
        {
                pT->Lock();
                *pdwCookie = m_vec.Add(p);
                hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;
                pT->Unlock();
                if (hRes != S_OK)
                        p->Release();
        }
        else if (hRes == E_NOINTERFACE)
                hRes = CONNECT_E_CANNOTCONNECT;
        if (FAILED(hRes))
                *pdwCookie = 0;
        return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Unadvise(DWORD dwCookie)
{
        T* pT = static_cast<T*>(this);
        pT->Lock();
        IUnknown* p = m_vec.GetUnknown(dwCookie);
        HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
        pT->Unlock();
        if (hRes == S_OK && p != NULL)
                p->Release();
        return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::EnumConnections(
        IEnumConnections** ppEnum)
{
        if (ppEnum == NULL)
                return E_POINTER;
        *ppEnum = NULL;
        CComObject<CComEnumConnections>* pEnum = NULL;
        ATLTRY(pEnum = new CComObject<CComEnumConnections>)
        if (pEnum == NULL)
                return E_OUTOFMEMORY;
        T* pT = static_cast<T*>(this);
        pT->Lock();
        CONNECTDATA* pcd = NULL;
        ATLTRY(pcd = new CONNECTDATA[ULONG(m_vec.end()-m_vec.begin())])
        if (pcd == NULL)
        {
                delete pEnum;
                pT->Unlock();
                return E_OUTOFMEMORY;
        }
        CONNECTDATA* pend = pcd;
        // Copy the valid CONNECTDATA's
        for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)
        {
                if (*pp != NULL)
                {
                        (*pp)->AddRef();
                        pend->pUnk = *pp;
                        pend->dwCookie = m_vec.GetCookie(pp);
                        pend++;
                }
        }
        // don't copy the data, but transfer ownership to it
        pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
        pT->Unlock();
        HRESULT hRes = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
        if (FAILED(hRes))
                delete pEnum;
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IConnectionPointContainerImpl

template <class T>
class ATL_NO_VTABLE IConnectionPointContainerImpl : public IConnectionPointContainer
{
        typedef CComEnum<IEnumConnectionPoints,
                &IID_IEnumConnectionPoints, IConnectionPoint*,
                _CopyInterface<IConnectionPoint> >
                CComEnumConnectionPoints;
public:
        STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum)
        {
                if (ppEnum == NULL)
                        return E_POINTER;
                *ppEnum = NULL;
                CComEnumConnectionPoints* pEnum = NULL;
                ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
                if (pEnum == NULL)
                        return E_OUTOFMEMORY;

                int nCPCount;
                const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(&nCPCount);
                
                // allocate an initialize a vector of connection point object pointers
                USES_ATL_SAFE_ALLOCA;
                IConnectionPoint** ppCP = (IConnectionPoint**)_ATL_SAFE_ALLOCA(sizeof(IConnectionPoint*)*nCPCount, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                if (ppCP == NULL)
                {
                        delete pEnum;
                        return E_OUTOFMEMORY;
                }

                int i = 0;
                while (pEntry->dwOffset != (DWORD_PTR)-1)
                {
                        ppCP[i++] = (IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
                        pEntry++;
                }

                // copy the pointers: they will AddRef this object
                HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
                        (IConnectionPoint**)&ppCP[nCPCount],
                        reinterpret_cast<IConnectionPointContainer*>(this), AtlFlagCopy);
                if (FAILED(hRes))
                {
                        delete pEnum;
                        return hRes;
                }
                hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
                if (FAILED(hRes))
                        delete pEnum;
                return hRes;
        }
        STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP)
        {
                if (ppCP == NULL)
                        return E_POINTER;
                *ppCP = NULL;
                HRESULT hRes = CONNECT_E_NOCONNECTION;
                const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(NULL);
                IID iid;
                while (pEntry->dwOffset != (DWORD_PTR)-1)
                {
                        IConnectionPoint* pCP =
                                (IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
                        if (SUCCEEDED(pCP->GetConnectionInterface(&iid)) &&
                                InlineIsEqualGUID(riid, iid))
                        {
                                *ppCP = pCP;
                                pCP->AddRef();
                                hRes = S_OK;
                                break;
                        }
                        pEntry++;
                }
                return hRes;
        }
};


#endif //!_ATL_NO_CONNECTION_POINTS

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CComAutoThreadModule

template <class ThreadAllocator>
inline HRESULT CComAutoThreadModule<ThreadAllocator>::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid, int nThreads)
{
        m_nThreads = nThreads;
        m_pApartments = NULL;
        ATLTRY(m_pApartments = new CComApartment[m_nThreads]);
        ATLASSERT(m_pApartments != NULL);
        if(m_pApartments == NULL)
                return E_OUTOFMEMORY;
        for (int i = 0; i < nThreads; i++)
        {
                m_pApartments[i].m_hThread = CreateThread(NULL, 0, CComApartment::_Apartment, (void*)&m_pApartments[i], 0, &m_pApartments[i].m_dwThreadID);
                if(m_pApartments[i].m_hThread == NULL)
                        return AtlHresultFromLastError();
        }
                
        CComApartment::ATL_CREATE_OBJECT = RegisterWindowMessage(_T("ATL_CREATE_OBJECT"));
        return CComModule::Init(p, h, plibid);
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Lock()
{
        LONG l = CComModule::Lock();
        DWORD dwThreadID = GetCurrentThreadId();
        for (int i=0; i < m_nThreads; i++)
        {
                if (m_pApartments[i].m_dwThreadID == dwThreadID)
                {
                        m_pApartments[i].Lock();
                        break;
                }
        }
        return l;
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Unlock()
{
        LONG l = CComModule::Unlock();
        DWORD dwThreadID = GetCurrentThreadId();
        for (int i=0; i < m_nThreads; i++)
        {
                if (m_pApartments[i].m_dwThreadID == dwThreadID)
                {
                        m_pApartments[i].Unlock();
                        break;
                }
        }
        return l;
}

template <class ThreadAllocator>
HRESULT CComAutoThreadModule<ThreadAllocator>::CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj)
{
        _ATL_CREATORFUNC* pFunc = (_ATL_CREATORFUNC*) pfnCreateInstance;
        _AtlAptCreateObjData data;
        data.pfnCreateInstance = pFunc;
        data.piid = &riid;
        data.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        data.hRes = S_OK;
        int nThread = m_Allocator.GetThread(m_pApartments, m_nThreads);
        
        int nIterations = 0;
        while(::PostThreadMessage(m_pApartments[nThread].m_dwThreadID, CComApartment::ATL_CREATE_OBJECT, 0, (LPARAM)&data) == 0
                        && ++ nIterations < 100)
        {
                Sleep(100);
        }
        
        if (nIterations < 100)
        {
                AtlWaitWithMessageLoop(data.hEvent);
        }
        else
        {
                data.hRes = AtlHresultFromLastError();
        }
        
        CloseHandle(data.hEvent);
        if (SUCCEEDED(data.hRes))
                data.hRes = CoGetInterfaceAndReleaseStream(data.pStream, riid, ppvObj);
        return data.hRes;
}

template <class ThreadAllocator>
CComAutoThreadModule<ThreadAllocator>::~CComAutoThreadModule()
{
        for (int i=0; i < m_nThreads; i++)
        {
                ::PostThreadMessage(m_pApartments[i].m_dwThreadID, WM_QUIT, 0, 0);
                ::WaitForSingleObject(m_pApartments[i].m_hThread, INFINITE);
                ::CloseHandle(m_pApartments[i].m_hThread);
        }
        delete[] m_pApartments;
}


}; //namespace ATL

#endif // __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlctl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atldef.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDEF_H__
#define __ATLDEF_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef UNDER_CE
        #error ATL not currently supported for CE
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif

#ifdef _ATL_DEBUG_REFCOUNT
#ifndef _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_INTERFACES
#endif
#endif

#ifdef _ATL_DEBUG_INTERFACES
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_INTERFACES

#ifndef _ATL_HEAPFLAGS
#ifdef _MALLOC_ZEROINIT
#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
#else
#define _ATL_HEAPFLAGS 0
#endif
#endif

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif

#ifdef _WIN64
        #if defined(_ATL_DLL)
                #define ATLAPI extern "C" HRESULT __declspec(dllimport)
                #define ATLAPI_(x) extern "C" __declspec(dllimport) x
                #define ATLINLINE
        #elif defined(_ATL_DLL_IMPL)
                #define ATLAPI extern "C" HRESULT __declspec(dllexport)
                #define ATLAPI_(x) extern "C" __declspec(dllexport) x
                #define ATLINLINE
        #else
                #define ATLAPI HRESULT
                #define ATLAPI_(x) x
                #define ATLINLINE inline
        #endif
#else
        #if defined(_ATL_DLL)
                #define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
                #define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
                #define ATLINLINE
        #elif defined(_ATL_DLL_IMPL)
                #define ATLAPI extern "C" HRESULT __declspec(dllexport) __stdcall
                #define ATLAPI_(x) extern "C" __declspec(dllexport) x __stdcall
                #define ATLINLINE
        #else
                #define ATLAPI HRESULT __stdcall
                #define ATLAPI_(x) x __stdcall
                #define ATLINLINE inline
        #endif
#endif

#if defined (_CPPUNWIND) & (defined(_ATL_EXCEPTIONS) | defined(_AFX))
#define ATLTRY(x) try{x;} catch(...) {}
#else
#define ATLTRY(x) x;
#endif

#define offsetofclass(base, derived) ((DWORD_PTR)(static_cast<base*>((derived*)_ATL_PACKING))-_ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#ifdef _WIN64
#define _ATL_VER 0x0301 // Active Template Library version 3.0
#else
#define _ATL_VER 0x0300 // Active Template Library version 3.0
#endif

/////////////////////////////////////////////////////////////////////////////
// Threading

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

#endif // __ATLDEF_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atldbsch.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////////////////////////////////////////
// ATLDBSCH.H : Declarations for OLE DB Schema Rowset Consumer Support
//

#ifndef __ATLDBSCH_H__
#define __ATLDBSCH_H__

namespace ATL
{

template <ULONG nRestrictions>
class _CStoreRestrictions
{
public:
        _CStoreRestrictions()
        {
                m_pvarRestrictions = NULL;
                ATLTRY(m_pvarRestrictions = new CComVariant[nRestrictions]);
        }
        ~_CStoreRestrictions()
        {
                delete [] m_pvarRestrictions;
        }
        HRESULT GetRowset(const CSession& session, const GUID& guidSchema, IRowset** ppRowset)
        {
                ATLASSERT(session.m_spOpenRowset != NULL);
                CComPtr<IDBSchemaRowset> spSchemaRowset;
                HRESULT hr;

                hr = session.m_spOpenRowset->QueryInterface(IID_IDBSchemaRowset, (void**)&spSchemaRowset);
                if (FAILED(hr))
                        return hr;

                return spSchemaRowset->GetRowset(NULL, guidSchema, nRestrictions,
                        m_pvarRestrictions, IID_IRowset, 0, NULL, (IUnknown**)ppRowset);
        }

        CComVariant* m_pvarRestrictions;
};

template <>
class _CStoreRestrictions<0>
{
public:
        HRESULT GetRowset(const CSession& session, const GUID& guidSchema, IRowset** ppRowset)
        {
                ATLASSERT(session.m_spOpenRowset != NULL);
                CComPtr<IDBSchemaRowset> spSchemaRowset;
                HRESULT hr;

                hr = session.m_spOpenRowset->QueryInterface(IID_IDBSchemaRowset, (void**)&spSchemaRowset);
                if (FAILED(hr))
                        return hr;

                return spSchemaRowset->GetRowset(NULL, guidSchema, 0,
                        NULL, IID_IRowset, 0, NULL, (IUnknown**)ppRowset);
        }
};

///////////////////////////////////////////////////////////////////////////
// class CSchemaRowset
template <class T, short nRestrictions>
class CSchemaRowset :
        public CAccessorRowset<T, CRowset>,
        public _CStoreRestrictions<nRestrictions>

{
public:
// Operations
        HRESULT Open(const CSession& session, const GUID& guidSchema, bool bBind = true )
        {
                HRESULT hr;

                hr = GetRowset(session, guidSchema, &m_spRowset);
                if (SUCCEEDED(hr) && bBind)
                        hr = Bind();

                return hr;
        }
};

 ///////////////////////////////////////////////////////////////////////////
// class CRestrictions

template <class T, short nRestrictions, const GUID* pguid>
class CRestrictions : public CSchemaRowset<T, nRestrictions>
{
public:
        HRESULT Open(const CSession& session, LPCTSTR lpszParam1 = NULL, LPCTSTR lpszParam2 = NULL,
                        LPCTSTR lpszParam3 = NULL, LPCTSTR lpszParam4 = NULL,
                        LPCTSTR lpszParam5 = NULL, LPCTSTR lpszParam6 = NULL,
                        LPCTSTR lpszParam7 = NULL, bool bBind = true )
        {
                USES_CONVERSION;
                CComVariant* pVariant;

                if (m_pvarRestrictions == NULL)
                        return E_OUTOFMEMORY;

                if (lpszParam1 != NULL)
                {
                        m_pvarRestrictions->vt = VT_BSTR;
                        m_pvarRestrictions->bstrVal = ::SysAllocString(T2COLE(lpszParam1));
                }

                if (lpszParam2 != NULL)
                {
                        pVariant = m_pvarRestrictions + 1;
                        pVariant->vt = VT_BSTR;
                        pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam2));
                }

                if (lpszParam3 != NULL)
                {
                        pVariant = m_pvarRestrictions + 2;
                        pVariant->vt = VT_BSTR;
                        pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam3));
                }

                if (lpszParam4 != NULL)
                {
                        pVariant = m_pvarRestrictions + 3;
                        pVariant->vt = VT_BSTR;
                        pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam4));
                }

                if (lpszParam5 != NULL)
                {
                        pVariant = m_pvarRestrictions + 4;
                        pVariant->vt = VT_BSTR;
                        pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam5));
                }

                if (lpszParam6 != NULL)
                {
                        pVariant = m_pvarRestrictions + 5;
                        pVariant->vt = VT_BSTR;
                        pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam6));
                }

                if (lpszParam7 != NULL)
                {
                        pVariant = m_pvarRestrictions + 6;
                        pVariant->vt = VT_BSTR;
                        pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam7));
                }

                return CSchemaRowset<T, nRestrictions>::Open(session, *pguid, bBind);
        }
};


///////////////////////////////////////////////////////////////////////////
// CSchemas

class CSchemas
{
public:
        CSchemas()
        {
                m_nSchemas          = 0;
                m_pSchemaGuids      = NULL;
                m_pulRestrictions   = NULL;
        };

        ~CSchemas()
        {
                // Clean up allocated memory
                if (m_pSchemaGuids != NULL)
                {
                        CoTaskMemFree(m_pSchemaGuids);
                        CoTaskMemFree(m_pulRestrictions);
                }
        };

// Operations
        HRESULT GetSchemas(const CSession& session)
        {
                CComPtr<IDBSchemaRowset> spSchemaRowset;
                HRESULT hr;

                ATLASSERT(session.m_spOpenRowset != NULL);

                hr = session.m_spOpenRowset->QueryInterface(IID_IDBSchemaRowset,
                        (void**)&spSchemaRowset);
                if (FAILED(hr))
                        return hr;

                return spSchemaRowset->GetSchemas(&m_nSchemas, &m_pSchemaGuids,
                                &m_pulRestrictions);
        };

// Attributes
        ULONG   m_nSchemas;
        LPGUID  m_pSchemaGuids;
        ULONG*  m_pulRestrictions;
};


///////////////////////////////////////////////////////////////////////////
// CAssertionInfo

class CAssertionInfo
{
public:
        CAssertionInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szCatalog[129];
        TCHAR           m_szSchema[129];
        TCHAR           m_szName[129];
        VARIANT_BOOL    m_bIsDeferrable;
        VARIANT_BOOL    m_bInitiallyDeferred;
        TCHAR           m_szDescription[129];

// Binding Map
BEGIN_COLUMN_MAP(CAssertionInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_bIsDeferrable)
        COLUMN_ENTRY(5, m_bInitiallyDeferred)
        COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCatalogInfo

class CCatalogInfo
{
public:
        CCatalogInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szName[129];
        TCHAR   m_szDescription[129];

// Binding Info
BEGIN_COLUMN_MAP(CCatalogInfo)
        COLUMN_ENTRY(1, m_szName)
        COLUMN_ENTRY(2, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCharacterSetInfo

class CCharacterSetInfo
{
public:
        CCharacterSetInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szCatalog[129];
        TCHAR           m_szSchema[129];
        TCHAR           m_szName[129];
        TCHAR           m_szFormOfUse[129];
        LARGE_INTEGER   m_nNumCharacters;
        TCHAR           m_szCollateCatalog[129];
        TCHAR           m_szCollateSchema[129];
        TCHAR           m_szCollateName[129];

// Binding Info
BEGIN_COLUMN_MAP(CCharacterSetInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szFormOfUse)
        COLUMN_ENTRY(5, m_nNumCharacters)
        COLUMN_ENTRY(6, m_szCollateCatalog)
        COLUMN_ENTRY(7, m_szCollateSchema)
        COLUMN_ENTRY(8, m_szCollateName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCheckConstraintInfo

class CCheckConstraintInfo
{
public:
        CCheckConstraintInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        TCHAR   m_szCheckClause[129];
        TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CCheckConstraintInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szCheckClause)
        COLUMN_ENTRY(5, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCollationInfo

class CCollationInfo
{
public:
// Constructors
        CCollationInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        TCHAR   m_szCharSetCatalog[129];
        TCHAR   m_szCharSetSchema[129];
        TCHAR   m_szCharSetName[129];
        TCHAR   m_szPadAttribute[10];

// Binding Maps
BEGIN_COLUMN_MAP(CCollationInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szCharSetCatalog)
        COLUMN_ENTRY(5, m_szCharSetSchema)
        COLUMN_ENTRY(6, m_szCharSetName)
        COLUMN_ENTRY(7, m_szPadAttribute)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnDomainUsageInfo

class CColumnDomainUsageInfo
{
public:
// Constructor
        CColumnDomainUsageInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        TCHAR   m_szTableCatalog[129];
        TCHAR   m_szTableSchema[129];
        TCHAR   m_szTableName[129];
        TCHAR   m_szColumnName[129];
        GUID    m_guidColumn;
        ULONG   m_nColumnPropID;

// Binding Maps
BEGIN_COLUMN_MAP(CColumnDomainUsageInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szTableCatalog)
        COLUMN_ENTRY(5, m_szTableSchema)
        COLUMN_ENTRY(6, m_szTableName)
        COLUMN_ENTRY(7, m_szColumnName)
        COLUMN_ENTRY(8, m_guidColumn)
        COLUMN_ENTRY(9, m_nColumnPropID)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnPrivilegeInfo

class CColumnPrivilegeInfo
{
public:
// Constructor
        CColumnPrivilegeInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szGrantor[129];
        TCHAR           m_szGrantee[129];
        TCHAR           m_szTableCatalog[129];
        TCHAR           m_szTableSchema[129];
        TCHAR           m_szTableName[129];
        TCHAR           m_szColumnName[129];
        GUID            m_guidColumn;
        ULONG           m_nColumnPropID;
        TCHAR           m_szPrivilegeType[20];
        VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CColumnPrivilegeInfo)
        COLUMN_ENTRY(1,  m_szGrantor)
        COLUMN_ENTRY(2,  m_szGrantee)
        COLUMN_ENTRY(3,  m_szTableCatalog)
        COLUMN_ENTRY(4,  m_szTableSchema)
        COLUMN_ENTRY(5,  m_szTableName)
        COLUMN_ENTRY(6,  m_szColumnName)
        COLUMN_ENTRY(7,  m_guidColumn)
        COLUMN_ENTRY(8,  m_nColumnPropID)
        COLUMN_ENTRY(9,  m_szPrivilegeType)
        COLUMN_ENTRY(10, m_bIsGrantable)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnsInfo

class CColumnsInfo
{
public:
// Constructors and Destructors
        CColumnsInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Operations
        TCHAR           m_szTableCatalog[129];
        TCHAR           m_szTableSchema[129];
        TCHAR           m_szTableName[129];
        TCHAR           m_szColumnName[129];
        GUID            m_guidColumn;
        ULONG           m_nColumnPropID;
        ULONG           m_nOrdinalPosition;
        VARIANT_BOOL    m_bColumnHasDefault;
        TCHAR           m_szColumnDefault[129];
        ULONG           m_nColumnFlags;
        VARIANT_BOOL    m_bIsNullable;
        USHORT          m_nDataType;
        GUID            m_guidType;
        ULONG           m_nMaxLength;
        ULONG           m_nOctetLength;
        USHORT          m_nNumericPrecision;
        SHORT           m_nNumericScale;
        ULONG           m_nDateTimePrecision;
        TCHAR           m_szCharSetCatalog[129];
        TCHAR           m_szCharSetSchema[129];
        TCHAR           m_szCharSetName[129];
        TCHAR           m_szCollationCatalog[129];
        TCHAR           m_szCollationSchema[129];
        TCHAR           m_szCollationName[129];
        TCHAR           m_szDomainCatalog[129];
        TCHAR           m_szDomainSchema[129];
        TCHAR           m_szDomainName[129];
        TCHAR           m_szDescription[129];

BEGIN_COLUMN_MAP(CColumnsInfo)
        COLUMN_ENTRY(1, m_szTableCatalog)
        COLUMN_ENTRY(2, m_szTableSchema)
        COLUMN_ENTRY(3, m_szTableName)
        COLUMN_ENTRY(4, m_szColumnName)
        COLUMN_ENTRY(5, m_guidColumn)
        COLUMN_ENTRY(6, m_nColumnPropID)
        COLUMN_ENTRY(7, m_nOrdinalPosition)
        COLUMN_ENTRY(8, m_bColumnHasDefault)
        COLUMN_ENTRY(9, m_szColumnDefault)
        COLUMN_ENTRY(10, m_nColumnFlags)
        COLUMN_ENTRY(11, m_bIsNullable)
        COLUMN_ENTRY(12, m_nDataType)
        COLUMN_ENTRY(13, m_guidType)
        COLUMN_ENTRY(14, m_nMaxLength)
        COLUMN_ENTRY(15, m_nOctetLength)
        COLUMN_ENTRY(16, m_nNumericPrecision)
        COLUMN_ENTRY(17, m_nNumericScale)
        COLUMN_ENTRY(18, m_nDateTimePrecision)
        COLUMN_ENTRY(19, m_szCharSetCatalog)
        COLUMN_ENTRY(20, m_szCharSetSchema)
        COLUMN_ENTRY(21, m_szCharSetName)
        COLUMN_ENTRY(22, m_szCollationCatalog)
        COLUMN_ENTRY(23, m_szCollationSchema)
        COLUMN_ENTRY(24, m_szCollationName)
        COLUMN_ENTRY(25, m_szDomainCatalog)
        COLUMN_ENTRY(26, m_szDomainSchema)
        COLUMN_ENTRY(27, m_szDomainName)
        COLUMN_ENTRY(28, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CConstraintColumnUsageInfo

class CConstraintColumnUsageInfo
{
public:
// Constructor
        CConstraintColumnUsageInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szTableCatalog[129];
        TCHAR   m_szTableSchema[129];
        TCHAR   m_szTableName[129];
        TCHAR   m_szColumnName[129];
        GUID    m_guidColumn;
        ULONG   m_nColumnPropID;
        TCHAR   m_szConstraintCatalog[129];
        TCHAR   m_szConstraintSchema[129];
        TCHAR   m_szConstraintName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CConstraintColumnUsageInfo)
        COLUMN_ENTRY(1, m_szTableCatalog)
        COLUMN_ENTRY(2, m_szTableSchema)
        COLUMN_ENTRY(3, m_szTableName)
        COLUMN_ENTRY(4, m_szColumnName)
        COLUMN_ENTRY(5, m_guidColumn)
        COLUMN_ENTRY(6, m_nColumnPropID)
        COLUMN_ENTRY(7, m_szConstraintCatalog)
        COLUMN_ENTRY(8, m_szConstraintSchema)
        COLUMN_ENTRY(9, m_szConstraintName)
END_COLUMN_MAP()
};

///////////////////////////////////////////////////////////////////////////
// class CConstraintColumnUsageInfo

class CConstraintTableUsageInfo
{
public:
// Constructor
        CConstraintTableUsageInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szTableCatalog[129];
        TCHAR   m_szTableSchema[129];
        TCHAR   m_szTableName[129];
        TCHAR   m_szConstraintCatalog[129];
        TCHAR   m_szConstraintSchema[129];
        TCHAR   m_szConstraintName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CConstraintTableUsageInfo)
        COLUMN_ENTRY(1, m_szTableCatalog)
        COLUMN_ENTRY(2, m_szTableSchema)
        COLUMN_ENTRY(3, m_szTableName)
        COLUMN_ENTRY(4, m_szConstraintCatalog)
        COLUMN_ENTRY(5, m_szConstraintSchema)
        COLUMN_ENTRY(6, m_szConstraintName)
END_COLUMN_MAP()
};

///////////////////////////////////////////////////////////////////////////
// class CForeignKeysInfo

class CForeignKeysInfo
{
public:
// Constructor
        CForeignKeysInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szPKTableCatalog[129];
        TCHAR   m_szPKTableSchema[129];
        TCHAR   m_szPKTableName[129];
        TCHAR   m_szPKColumnName[129];
        GUID    m_guidPKColumn;
        ULONG   m_nPKColumnPropID;
        TCHAR   m_szFKTableCatalog[129];
        TCHAR   m_szFKTableSchema[129];
        TCHAR   m_szFKTableName[129];
        TCHAR   m_szFKColumnName[129];
        GUID    m_guidFKColumn;
        ULONG   m_nFKColumnPropID;
        ULONG   m_nOrdinal;
        TCHAR   m_szUpdateRule[12];
        TCHAR   m_szDeleteRule[12];

// Binding Info
BEGIN_COLUMN_MAP(CForeignKeysInfo)
        COLUMN_ENTRY(1, m_szPKTableCatalog)
        COLUMN_ENTRY(2, m_szPKTableSchema)
        COLUMN_ENTRY(3, m_szPKTableName)
        COLUMN_ENTRY(4, m_szPKColumnName)
        COLUMN_ENTRY(5, m_guidPKColumn)
        COLUMN_ENTRY(6, m_nPKColumnPropID)
        COLUMN_ENTRY(7, m_szFKTableCatalog)
        COLUMN_ENTRY(8, m_szFKTableSchema)
        COLUMN_ENTRY(9, m_szFKTableName)
        COLUMN_ENTRY(10, m_szFKColumnName)
        COLUMN_ENTRY(11, m_guidFKColumn)
        COLUMN_ENTRY(12, m_nFKColumnPropID)
        COLUMN_ENTRY(13, m_nOrdinal)
        COLUMN_ENTRY(14, m_szUpdateRule)
        COLUMN_ENTRY(15, m_szDeleteRule)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CIndexesInfo

class CIndexesInfo
{
public:
// Constructors
        CIndexesInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szTableCatalog[129];
        TCHAR           m_szTableSchema[129];
        TCHAR           m_szTableName[129];
        TCHAR           m_szIndexCatalog[129];
        TCHAR           m_szIndexSchema[129];
        TCHAR           m_szIndexName[129];
        VARIANT_BOOL    m_bPrimaryKey;
        VARIANT_BOOL    m_bUnique;
        VARIANT_BOOL    m_bClustered;
        USHORT          m_nType;
        LONG            m_nFillFactor;
        LONG            m_nInitialSize;
        LONG            m_nNulls;
        VARIANT_BOOL    m_bSortBookmarks;
        VARIANT_BOOL    m_bAutoUpdate;
        LONG            m_nNullCollation;
        ULONG           m_nOrdinalPosition;
        TCHAR           m_szColumnName[129];
        GUID            m_guidColumn;
        ULONG           m_nColumnPropID;
        SHORT           m_nCollation;
        LONG            m_nCardinality;
        LONG            m_nPages;
        TCHAR           m_szFilterCondition[129];

// Binding Maps
BEGIN_COLUMN_MAP(CIndexesInfo)
        COLUMN_ENTRY(1, m_szTableCatalog)
        COLUMN_ENTRY(2, m_szTableSchema)
        COLUMN_ENTRY(3, m_szTableName)
        COLUMN_ENTRY(4, m_szIndexCatalog)
        COLUMN_ENTRY(5, m_szIndexSchema)
        COLUMN_ENTRY(6, m_szIndexName)
        COLUMN_ENTRY(7, m_bPrimaryKey)
        COLUMN_ENTRY(8, m_bUnique)
        COLUMN_ENTRY(9, m_bClustered)
        COLUMN_ENTRY(10, m_nType)
        COLUMN_ENTRY(11, m_nFillFactor)
        COLUMN_ENTRY(12, m_nInitialSize)
        COLUMN_ENTRY(13, m_nNulls)
        COLUMN_ENTRY(14, m_bSortBookmarks)
        COLUMN_ENTRY(15, m_bAutoUpdate)
        COLUMN_ENTRY(16, m_nNullCollation)
        COLUMN_ENTRY(17, m_nOrdinalPosition)
        COLUMN_ENTRY(18, m_szColumnName)
        COLUMN_ENTRY(19, m_guidColumn)
        COLUMN_ENTRY(20, m_nColumnPropID)
        COLUMN_ENTRY(21, m_nCollation)
        COLUMN_ENTRY(22, m_nCardinality)
        COLUMN_ENTRY(23, m_nPages)
        COLUMN_ENTRY(25, m_szFilterCondition)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CKeyColumnUsageInfo

class CKeyColumnUsageInfo
{
public:
// Constructors
        CKeyColumnUsageInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szConstraintCatalog[129];
        TCHAR   m_szConstraintSchema[129];
        TCHAR   m_szConstraintName[129];
        TCHAR   m_szTableCatalog[129];
        TCHAR   m_szTableSchema[129];
        TCHAR   m_szTableName[129];
        TCHAR   m_szColumnName[129];
        GUID    m_guidColumn;
        ULONG   m_nColumnPropID;
        ULONG   m_nOrdinalPosition;

// Binding Maps
BEGIN_COLUMN_MAP(CKeyColumnUsageInfo)
        COLUMN_ENTRY(1,  m_szConstraintCatalog)
        COLUMN_ENTRY(2,  m_szConstraintSchema)
        COLUMN_ENTRY(3,  m_szConstraintName)
        COLUMN_ENTRY(4,  m_szTableCatalog)
        COLUMN_ENTRY(5,  m_szTableSchema)
        COLUMN_ENTRY(6,  m_szTableName)
        COLUMN_ENTRY(7,  m_szColumnName)
        COLUMN_ENTRY(8,  m_guidColumn)
        COLUMN_ENTRY(9,  m_nColumnPropID)
        COLUMN_ENTRY(10, m_nOrdinalPosition)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CPrimaryKeyInfo

class CPrimaryKeyInfo
{
public:
// Constructors
        CPrimaryKeyInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szTableCatalog[129];
        TCHAR   m_szTableSchema[129];
        TCHAR   m_szTableName[129];
        TCHAR   m_szColumnName[129];
        GUID    m_guidColumn;
        ULONG   m_nColumnPropID;
        ULONG   m_nOrdinal;

// Binding Maps
BEGIN_COLUMN_MAP(CPrimaryKeyInfo)
        COLUMN_ENTRY(1, m_szTableCatalog)
        COLUMN_ENTRY(2, m_szTableSchema)
        COLUMN_ENTRY(3, m_szTableName)
        COLUMN_ENTRY(4, m_szColumnName)
        COLUMN_ENTRY(5, m_guidColumn)
        COLUMN_ENTRY(6, m_nColumnPropID)
        COLUMN_ENTRY(7, m_nOrdinal)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureColumnInfo

class CProcedureColumnInfo
{
public:
// Constructors
        CProcedureColumnInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szCatalog[129];
        TCHAR           m_szSchema[129];
        TCHAR           m_szName[129];
        TCHAR           m_szColumnName[129];
        GUID            m_guidColumn;
        ULONG           m_nColumnPropID;
        ULONG           m_nRowsetNumber;
        ULONG           m_nOrdinalPosition;
        VARIANT_BOOL    m_bIsNullable;
        USHORT          m_nDataType;
        GUID            m_guidType;
        ULONG           m_nMaxLength;
        ULONG           m_nOctetLength;
        USHORT          m_nPrecision;
        SHORT           m_nScale;
        TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureColumnInfo)
        COLUMN_ENTRY(1,  m_szCatalog)
        COLUMN_ENTRY(2,  m_szSchema)
        COLUMN_ENTRY(3,  m_szName)
        COLUMN_ENTRY(4,  m_szColumnName)
        COLUMN_ENTRY(5,  m_guidColumn)
        COLUMN_ENTRY(6,  m_nColumnPropID)
        COLUMN_ENTRY(7,  m_nRowsetNumber)
        COLUMN_ENTRY(8,  m_nOrdinalPosition)
        COLUMN_ENTRY(9,  m_bIsNullable)
        COLUMN_ENTRY(10, m_nDataType)
        COLUMN_ENTRY(11, m_guidType)
        COLUMN_ENTRY(12, m_nMaxLength)
        COLUMN_ENTRY(13, m_nOctetLength)
        COLUMN_ENTRY(14, m_nPrecision)
        COLUMN_ENTRY(15, m_nScale)
        COLUMN_ENTRY(16, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureParameterInfo

class CProcedureParameterInfo
{
public:
// Constructors
        CProcedureParameterInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szCatalog[129];
        TCHAR           m_szSchema[129];
        TCHAR           m_szName[129];
        TCHAR           m_szParameterName[129];
        USHORT          m_nOrdinalPosition;
        USHORT          m_nType;
        VARIANT_BOOL    m_bHasDefault;
        TCHAR           m_szDefault[129];
        VARIANT_BOOL    m_bIsNullable;
        USHORT          m_nDataType;
        ULONG           m_nMaxLength;
        ULONG           m_nOctetLength;
        USHORT          m_nPrecision;
        SHORT           m_nScale;
        TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureParameterInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szParameterName)
        COLUMN_ENTRY(5, m_nOrdinalPosition)
        COLUMN_ENTRY(6, m_nType)
        COLUMN_ENTRY(7, m_bHasDefault)
        COLUMN_ENTRY(8, m_szDefault)
        COLUMN_ENTRY(9, m_bIsNullable)
        COLUMN_ENTRY(10, m_nDataType)
        COLUMN_ENTRY(11, m_nMaxLength)
        COLUMN_ENTRY(12, m_nOctetLength)
        COLUMN_ENTRY(13, m_nPrecision)
        COLUMN_ENTRY(14, m_nScale)
        COLUMN_ENTRY(15, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureInfo

class CProcedureInfo
{
public:
// Constructors
        CProcedureInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        SHORT   m_nType;
        TCHAR   m_szDefinition[129];
        TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_nType)
        COLUMN_ENTRY(5, m_szDefinition)
        COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProviderTypeInfo

class CProviderTypeInfo
{
public:
// Constructors
        CProviderTypeInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szTypeName[129];
        USHORT          m_nDataType;
        ULONG           m_nColumnSize;
        TCHAR           m_szLiteralPrefix[129];
        TCHAR           m_szLiteralSuffix[129];
        TCHAR           m_szCreateParams[129];
        VARIANT_BOOL    m_bIsNullable;
        VARIANT_BOOL    m_bCaseSensitive;
        ULONG           m_nSearchable;
        VARIANT_BOOL    m_bUnsignedAttribute;
        VARIANT_BOOL    m_bFixedPrecScale;
        VARIANT_BOOL    m_bAutoUniqueValue;
        TCHAR           m_szLocalTypeName[129];
        SHORT           m_nMinScale;
        SHORT           m_nMaxScale;
        GUID            m_guidType;
        TCHAR           m_szTypeLib[129];
        TCHAR           m_szVersion[129];
        VARIANT_BOOL    m_bIsLong;
        VARIANT_BOOL    m_bBestMatch;

// Binding Maps
BEGIN_COLUMN_MAP(CProviderTypeInfo)
        COLUMN_ENTRY(1, m_szTypeName)
        COLUMN_ENTRY(2, m_nDataType)
        COLUMN_ENTRY(3, m_nColumnSize)
        COLUMN_ENTRY(4, m_szLiteralPrefix)
        COLUMN_ENTRY(5, m_szLiteralSuffix)
        COLUMN_ENTRY(6, m_szCreateParams)
        COLUMN_ENTRY(7, m_bIsNullable)
        COLUMN_ENTRY(8, m_bCaseSensitive)
        COLUMN_ENTRY(9, m_nSearchable)
        COLUMN_ENTRY(10, m_bUnsignedAttribute)
        COLUMN_ENTRY(11, m_bFixedPrecScale)
        COLUMN_ENTRY(12, m_bAutoUniqueValue)
        COLUMN_ENTRY(13, m_szLocalTypeName)
        COLUMN_ENTRY(14, m_nMinScale)
        COLUMN_ENTRY(15, m_nMaxScale)
        COLUMN_ENTRY(16, m_guidType)
        COLUMN_ENTRY(17, m_szTypeLib)
        COLUMN_ENTRY(18, m_szVersion)
        COLUMN_ENTRY(19, m_bIsLong)
        COLUMN_ENTRY(20, m_bBestMatch)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CReferentialConstraintInfo

class CReferentialConstraintInfo
{
public:
// Constructors
        CReferentialConstraintInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        TCHAR   m_szUniqueCatalog[129];
        TCHAR   m_szUniqueSchema[129];
        TCHAR   m_szUniqueName[129];
        TCHAR   m_szMatchOption[8];
        TCHAR   m_szUpdateRule[12];
        TCHAR   m_szDeleteRule[12];
        TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CReferentialConstraintInfo)
        COLUMN_ENTRY(1,  m_szCatalog)
        COLUMN_ENTRY(2,  m_szSchema)
        COLUMN_ENTRY(3,  m_szName)
        COLUMN_ENTRY(4,  m_szUniqueCatalog)
        COLUMN_ENTRY(5,  m_szUniqueSchema)
        COLUMN_ENTRY(6,  m_szUniqueName)
        COLUMN_ENTRY(7,  m_szMatchOption)
        COLUMN_ENTRY(8,  m_szUpdateRule)
        COLUMN_ENTRY(9,  m_szDeleteRule)
        COLUMN_ENTRY(10, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CSchemataInfo

class CSchemataInfo
{
public:
// Constructors
        CSchemataInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szName[129];
        TCHAR   m_szOwner[129];
        TCHAR   m_szCharCatalog[129];
        TCHAR   m_szCharSchema[129];
        TCHAR   m_szCharName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CSchemataInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szName)
        COLUMN_ENTRY(3, m_szOwner)
        COLUMN_ENTRY(4, m_szCharCatalog)
        COLUMN_ENTRY(5, m_szCharSchema)
        COLUMN_ENTRY(6, m_szCharName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CSQLLangugageInfo

class CSQLLanguageInfo
{
public:
// Constructors
        CSQLLanguageInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szSource[10];
        TCHAR   m_szYear[5];
        TCHAR   m_szConformance[13];
        TCHAR   m_szIntegrity[4];
        TCHAR   m_szImplementation[24];
        TCHAR   m_szBindingStyle[10];
        TCHAR   m_szProgrammingLanguage[10];

// Binding Maps
BEGIN_COLUMN_MAP(CSQLLanguageInfo)
        COLUMN_ENTRY(1, m_szSource)
        COLUMN_ENTRY(2, m_szYear)
        COLUMN_ENTRY(3, m_szConformance)
        COLUMN_ENTRY(4, m_szIntegrity)
        COLUMN_ENTRY(5, m_szImplementation)
        COLUMN_ENTRY(6, m_szBindingStyle)
        COLUMN_ENTRY(7, m_szProgrammingLanguage)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CStatisticInfo

class CStatisticInfo
{
public:
// Constructors
        CStatisticInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szTableCatalog[129];
        TCHAR   m_szTableSchema[129];
        TCHAR   m_szTableName[129];
        LONG    m_nCardinality;

// Binding Maps
BEGIN_COLUMN_MAP(CStatisticInfo)
        COLUMN_ENTRY(1, m_szTableCatalog)
        COLUMN_ENTRY(2, m_szTableSchema)
        COLUMN_ENTRY(3, m_szTableName)
        COLUMN_ENTRY(4, m_nCardinality)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTableConstraintInfo

class CTableConstraintInfo
{
public:
// Constructors
        CTableConstraintInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szCatalog[129];
        TCHAR           m_szSchema[129];
        TCHAR           m_szName[129];
        TCHAR           m_szTableCatalog[129];
        TCHAR           m_szTableSchema[129];
        TCHAR           m_szTableName[129];
        TCHAR           m_szType[12];
        VARIANT_BOOL    m_bIsDeferrable;
        VARIANT_BOOL    m_bInitiallyDeferred;
        TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CTableConstraintInfo)
        COLUMN_ENTRY(1,  m_szCatalog)
        COLUMN_ENTRY(2,  m_szSchema)
        COLUMN_ENTRY(3,  m_szName)
        COLUMN_ENTRY(4,  m_szTableCatalog)
        COLUMN_ENTRY(5,  m_szTableSchema)
        COLUMN_ENTRY(6,  m_szTableName)
        COLUMN_ENTRY(7,  m_szType)
        COLUMN_ENTRY(8,  m_bIsDeferrable)
        COLUMN_ENTRY(9,  m_bInitiallyDeferred)
        COLUMN_ENTRY(10, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTablePrivilegeInfo

class CTablePrivilegeInfo
{
public:
// Constructors
        CTablePrivilegeInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szGrantor[129];
        TCHAR           m_szGrantee[129];
        TCHAR           m_szCatalog[129];
        TCHAR           m_szSchema[129];
        TCHAR           m_szName[129];
        TCHAR           m_szType[12];
        VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CTablePrivilegeInfo)
        COLUMN_ENTRY(1, m_szGrantor)
        COLUMN_ENTRY(2, m_szGrantee)
        COLUMN_ENTRY(3, m_szCatalog)
        COLUMN_ENTRY(4, m_szSchema)
        COLUMN_ENTRY(5, m_szName)
        COLUMN_ENTRY(6, m_szType)
        COLUMN_ENTRY(7, m_bIsGrantable)
END_COLUMN_MAP()
};



///////////////////////////////////////////////////////////////////////////
// class CTableInfo

class CTableInfo
{
public:
// Constructors
        CTableInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        TCHAR   m_szType[129];
        GUID    m_guidTable;
        TCHAR   m_szDescription[129];


// Binding Map
BEGIN_COLUMN_MAP(CTableInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szType)
        COLUMN_ENTRY(5, m_guidTable)
        COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTranslationInfo

class CTranslationInfo
{
public:
// Constructors
        CTranslationInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        TCHAR   m_szSourceCatalog[129];
        TCHAR   m_szSourceSchema[129];
        TCHAR   m_szSourceName[129];
        TCHAR   m_szTargetCatalog[129];
        TCHAR   m_szTargetSchema[129];
        TCHAR   m_szTargetName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CTranslationInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szSourceCatalog)
        COLUMN_ENTRY(5, m_szSourceSchema)
        COLUMN_ENTRY(6, m_szSourceName)
        COLUMN_ENTRY(7, m_szTargetCatalog)
        COLUMN_ENTRY(8, m_szTargetSchema)
        COLUMN_ENTRY(9, m_szTargetName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CUsagePrivilegeInfo

class CUsagePrivilegeInfo
{
public:
// Constructors
        CUsagePrivilegeInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szGrantor[129];
        TCHAR   m_szGrantee[129];
        TCHAR   m_szObjectCatalog[129];
        TCHAR   m_szObjectSchema[129];
        TCHAR   m_szObjectName[129];
        TCHAR   m_szObjectType[12];
        TCHAR   m_szPrivilegeType[6];
        VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CUsagePrivilegeInfo)
        COLUMN_ENTRY(1, m_szGrantor)
        COLUMN_ENTRY(2, m_szGrantee)
        COLUMN_ENTRY(3, m_szObjectCatalog)
        COLUMN_ENTRY(4, m_szObjectSchema)
        COLUMN_ENTRY(5, m_szObjectName)
        COLUMN_ENTRY(6, m_szObjectType)
        COLUMN_ENTRY(7, m_szPrivilegeType)
        COLUMN_ENTRY(8, m_bIsGrantable)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewColumnUsageInfo

class CViewColumnUsageInfo
{
public:
// Constructors
        CViewColumnUsageInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        TCHAR   m_szTableCatalog[129];
        TCHAR   m_szTableSchema[129];
        TCHAR   m_szTableName[129];
        TCHAR   m_szColumnName[129];
        GUID    m_guidColumn;
        ULONG   m_nColumnPropID;

// Binding Maps
BEGIN_COLUMN_MAP(CViewColumnUsageInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szTableCatalog)
        COLUMN_ENTRY(5, m_szTableSchema)
        COLUMN_ENTRY(6, m_szTableName)
        COLUMN_ENTRY(7, m_szColumnName)
        COLUMN_ENTRY(8, m_guidColumn)
        COLUMN_ENTRY(9, m_nColumnPropID)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewTableUsageInfo

class CViewTableUsageInfo
{
public:
// Constructors
        CViewTableUsageInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR   m_szCatalog[129];
        TCHAR   m_szSchema[129];
        TCHAR   m_szName[129];
        TCHAR   m_szTableCatalog[129];
        TCHAR   m_szTableSchema[129];
        TCHAR   m_szTableName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CViewTableUsageInfo)
        COLUMN_ENTRY(1, m_szCatalog)
        COLUMN_ENTRY(2, m_szSchema)
        COLUMN_ENTRY(3, m_szName)
        COLUMN_ENTRY(4, m_szTableCatalog)
        COLUMN_ENTRY(5, m_szTableSchema)
        COLUMN_ENTRY(6, m_szTableName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewInfo

class CViewInfo
{
public:
// Constructors
        CViewInfo()
        {
                memset(this, 0, sizeof(*this));
        }

// Attributes
        TCHAR           m_szTableCatalog[129];
        TCHAR           m_szTableSchema[129];
        TCHAR           m_szTableName[129];
        TCHAR           m_szDefinition[129];
        VARIANT_BOOL    m_bCheckOption;
        VARIANT_BOOL    m_bIsUpdatable;
        TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CViewInfo)
        COLUMN_ENTRY(1, m_szTableCatalog)
        COLUMN_ENTRY(2, m_szTableSchema)
        COLUMN_ENTRY(3, m_szTableName)
        COLUMN_ENTRY(4, m_szDefinition)
        COLUMN_ENTRY(5, m_bCheckOption)
        COLUMN_ENTRY(6, m_bIsUpdatable)
        COLUMN_ENTRY(7, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// typedefs

typedef CRestrictions<CAccessor<CAssertionInfo>,            3, &DBSCHEMA_ASSERTIONS>                CAssertions;
typedef CRestrictions<CAccessor<CCatalogInfo>,              1, &DBSCHEMA_CATALOGS >                 CCatalogs;
typedef CRestrictions<CAccessor<CCharacterSetInfo>,         3, &DBSCHEMA_CHARACTER_SETS>            CCharacterSets;
typedef CRestrictions<CAccessor<CCheckConstraintInfo>,      3, &DBSCHEMA_CHECK_CONSTRAINTS>         CCheckConstraints;
typedef CRestrictions<CAccessor<CCollationInfo>,            3, &DBSCHEMA_COLLATIONS>                CCollations;
typedef CRestrictions<CAccessor<CColumnDomainUsageInfo>,    4, &DBSCHEMA_COLUMN_DOMAIN_USAGE>       CColumnDomainUsage;
typedef CRestrictions<CAccessor<CColumnPrivilegeInfo>,      6, &DBSCHEMA_COLUMN_PRIVILEGES>         CColumnPrivileges;
typedef CRestrictions<CAccessor<CColumnsInfo>,              4, &DBSCHEMA_COLUMNS>                   CColumns;
typedef CRestrictions<CAccessor<CConstraintColumnUsageInfo>,4, &DBSCHEMA_CONSTRAINT_COLUMN_USAGE>   CConstraintColumnUsage;
typedef CRestrictions<CAccessor<CConstraintTableUsageInfo>, 3, &DBSCHEMA_CONSTRAINT_TABLE_USAGE>    CConstraintTableUsage;
typedef CRestrictions<CAccessor<CForeignKeysInfo>,          6, &DBSCHEMA_FOREIGN_KEYS>              CForeignKeys;
typedef CRestrictions<CAccessor<CIndexesInfo>,              5, &DBSCHEMA_INDEXES>                   CIndexes;
typedef CRestrictions<CAccessor<CKeyColumnUsageInfo>,       7, &DBSCHEMA_KEY_COLUMN_USAGE>          CKeyColumnUsage;
typedef CRestrictions<CAccessor<CPrimaryKeyInfo>,           3, &DBSCHEMA_PRIMARY_KEYS>              CPrimaryKeys;
typedef CRestrictions<CAccessor<CProcedureColumnInfo>,      4, &DBSCHEMA_PROCEDURE_COLUMNS>         CProcedureColumns;
typedef CRestrictions<CAccessor<CProcedureParameterInfo>,   4, &DBSCHEMA_PROCEDURE_PARAMETERS>      CProcedureParameters;
typedef CRestrictions<CAccessor<CProcedureInfo>,            4, &DBSCHEMA_PROCEDURES>                CProcedures;
typedef CRestrictions<CAccessor<CProviderTypeInfo>,         2, &DBSCHEMA_PROVIDER_TYPES>            CProviderTypes;
typedef CRestrictions<CAccessor<CReferentialConstraintInfo>,3, &DBSCHEMA_REFERENTIAL_CONSTRAINTS>   CReferentialConstraints;
typedef CRestrictions<CAccessor<CSchemataInfo>,             3, &DBSCHEMA_SCHEMATA>                  CSchemata;
typedef CRestrictions<CAccessor<CSQLLanguageInfo>,          0, &DBSCHEMA_SQL_LANGUAGES>             CSQLLanguages;
typedef CRestrictions<CAccessor<CStatisticInfo>,            3, &DBSCHEMA_STATISTICS>                CStatistics ;
typedef CRestrictions<CAccessor<CTableConstraintInfo>,      7, &DBSCHEMA_TABLE_CONSTRAINTS>         CTableConstraints;
typedef CRestrictions<CAccessor<CTablePrivilegeInfo>,       5, &DBSCHEMA_TABLE_PRIVILEGES>          CTablePrivileges;
typedef CRestrictions<CAccessor<CTableInfo>,                4, &DBSCHEMA_TABLES>                    CTables;
typedef CRestrictions<CAccessor<CTranslationInfo>,          3, &DBSCHEMA_TRANSLATIONS>              CTranslations;
typedef CRestrictions<CAccessor<CUsagePrivilegeInfo>,       6, &DBSCHEMA_USAGE_PRIVILEGES>          CUsagePrivileges;
typedef CRestrictions<CAccessor<CViewColumnUsageInfo>,      3, &DBSCHEMA_VIEW_COLUMN_USAGE>         CViewColumnUsage;
typedef CRestrictions<CAccessor<CViewTableUsageInfo>,       3, &DBSCHEMA_VIEW_TABLE_USAGE>          CViewTableUsage;
typedef CRestrictions<CAccessor<CViewInfo>,                 3, &DBSCHEMA_VIEWS>                     CViews;

///////////////////////////////////////////////////////////////////////////

}; //namespace ATL

#endif // __ATLDBSCH_H__

///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlctl.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTL_H__
#define __ATLCTL_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlwin.h>

#include <objsafe.h>
#include <urlmon.h>

#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "urlmon.lib")


#define DECLARE_VIEW_STATUS(statusFlags) \
        DWORD _GetViewStatus() \
        { \
                return statusFlags; \
        }

// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL
#include "msstkppg.h"
#include "atliface.h"
#define CLSID_MSStockFont CLSID_StockFontPage
#define CLSID_MSStockColor CLSID_StockColorPage
#define CLSID_MSStockPicture CLSID_StockPicturePage

struct ATL_DRAWINFO
{
        UINT cbSize;
        DWORD dwDrawAspect;
        LONG lindex;
        DVTARGETDEVICE* ptd;
        HDC hicTargetDev;
        HDC hdcDraw;
        LPCRECTL prcBounds; //Rectangle in which to draw
        LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
        BOOL bOptimize;
        BOOL bZoomed;
        BOOL bRectInHimetric;
        SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
        SIZEL ZoomDen;
};

namespace ATL
{

#pragma pack(push, _ATL_PACKING)

// Forward declarations
//
class ATL_NO_VTABLE CComControlBase;
template <class T, class WinBase> class CComControl;

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent


// Helper functions for safely communicating with objects who sink IPropertyNotifySink
class CFirePropNotifyEvent
{
public:
        // Ask any objects sinking the IPropertyNotifySink notification if it is ok to edit a specified property
        static HRESULT FireOnRequestEdit(IUnknown* pUnk, DISPID dispID)
        {
                CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
                if (!pCPC)
                        return S_OK;
                CComPtr<IConnectionPoint> pCP;
                pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
                if (!pCP)
                        return S_OK;
                CComPtr<IEnumConnections> pEnum;

                if (FAILED(pCP->EnumConnections(&pEnum)))
                        return S_OK;
                CONNECTDATA cd;
                while (pEnum->Next(1, &cd, NULL) == S_OK)
                {
                        if (cd.pUnk)
                        {
                                HRESULT hr = S_OK;
                                CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
                                if (pSink)
                                        hr = pSink->OnRequestEdit(dispID);
                                cd.pUnk->Release();
                                if (hr == S_FALSE)
                                        return S_FALSE;
                        }
                }
                return S_OK;
        }
        // Notify any objects sinking the IPropertyNotifySink notification that a property has changed
        static HRESULT FireOnChanged(IUnknown* pUnk, DISPID dispID)
        {
                CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
                if (!pCPC)
                        return S_OK;
                CComPtr<IConnectionPoint> pCP;
                pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
                if (!pCP)
                        return S_OK;
                CComPtr<IEnumConnections> pEnum;

                if (FAILED(pCP->EnumConnections(&pEnum)))
                        return S_OK;
                CONNECTDATA cd;
                while (pEnum->Next(1, &cd, NULL) == S_OK)
                {
                        if (cd.pUnk)
                        {
                                CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
                                if (pSink)
                                        pSink->OnChanged(dispID);
                                cd.pUnk->Release();
                        }
                }
                return S_OK;
        }
};


//////////////////////////////////////////////////////////////////////////////
// CComControlBase

// Holds the essential data members for an ActiveX control and useful helper functions
class ATL_NO_VTABLE CComControlBase
{
public:
        CComControlBase(HWND& h) : m_hWndCD(h)
        {
                memset(this, 0, sizeof(CComControlBase));
                m_phWndCD = &h;
                m_sizeExtent.cx = 2*2540;
                m_sizeExtent.cy = 2*2540;
                m_sizeNatural = m_sizeExtent;
        }
        ~CComControlBase()
        {
                if (m_hWndCD != NULL)
                        ::DestroyWindow(m_hWndCD);
                ATLTRACE2(atlTraceControls,2,_T("Control Destroyed\n"));
        }

// methods
public:
        // Control helper functions can go here non-virtuals only please

        // Mark the control 'dirty' so the container will save it
        void SetDirty(BOOL bDirty)
        {
                m_bRequiresSave = bDirty;
        }
        // Obtain the dirty state for the control
        BOOL GetDirty()
        {
                return m_bRequiresSave ? TRUE : FALSE;
        }
        // Get the zoom factor (numerator & denominator) which is factor of the natural extent
        void GetZoomInfo(ATL_DRAWINFO& di);
        // Sends a notification that the moniker for the control has changed
        HRESULT SendOnRename(IMoniker *pmk)
        {
                HRESULT hRes = S_OK;
                if (m_spOleAdviseHolder)
                        hRes = m_spOleAdviseHolder->SendOnRename(pmk);
                return hRes;
        }
        // Sends a notification that the control has just saved its data
        HRESULT SendOnSave()
        {
                HRESULT hRes = S_OK;
                if (m_spOleAdviseHolder)
                        hRes = m_spOleAdviseHolder->SendOnSave();
                return hRes;
        }
        // Sends a notification that the control has closed its advisory sinks
        HRESULT SendOnClose()
        {
                HRESULT hRes = S_OK;
                if (m_spOleAdviseHolder)
                        hRes = m_spOleAdviseHolder->SendOnClose();
                return hRes;
        }
        // Sends a notification that the control's data has changed
        HRESULT SendOnDataChange(DWORD advf = 0);
        // Sends a notification that the control's representation has changed
        HRESULT SendOnViewChange(DWORD dwAspect, LONG lindex = -1)
        {
                if (m_spAdviseSink)
                        m_spAdviseSink->OnViewChange(dwAspect, lindex);
                return S_OK;
        }
        // Sends a notification to the container that the control has received focus
        LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
        {
                if (m_bInPlaceActive)
                {
                        CComPtr<IOleObject> pOleObject;
                        ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
                        if (pOleObject != NULL)
                                pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
                        CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
                        if (m_bInPlaceActive && spSite != NULL)
                                spSite->OnFocus(TRUE);
                }
                bHandled = FALSE;
                return 1;
        }
        LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
        {
                CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
                if (m_bInPlaceActive && spSite != NULL && !::IsChild(m_hWndCD, ::GetFocus()))
                        spSite->OnFocus(FALSE);
                bHandled = FALSE;
                return 1;
        }
        LRESULT OnMouseActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
        {
                BOOL bUserMode = TRUE;
                HRESULT hRet = GetAmbientUserMode(bUserMode);
                // UI activate if in user mode only
                // allow activation if we can't determine mode
                if (FAILED(hRet) || bUserMode)
                {
                        CComPtr<IOleObject> pOleObject;
                        ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
                        if (pOleObject != NULL)
                                pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
                }
                bHandled = FALSE;
                return 1;
        }
        BOOL PreTranslateAccelerator(LPMSG /*pMsg*/, HRESULT& /*hRet*/)
        {
                return FALSE;
        }

        HRESULT GetAmbientProperty(DISPID dispid, VARIANT& var)
        {
                HRESULT hRes = E_FAIL;
                if (m_spAmbientDispatch.p != NULL)
                        hRes = m_spAmbientDispatch.GetProperty(dispid, &var);
                return hRes;
        }
        HRESULT GetAmbientAppearance(short& nAppearance)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var);
                ATLASSERT(var.vt == VT_I2 || var.vt == VT_UI2 || var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
                nAppearance = var.iVal;
                return hRes;
        }
        HRESULT GetAmbientBackColor(OLE_COLOR& BackColor)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var);
                ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
                BackColor = var.lVal;
                return hRes;
        }
        HRESULT GetAmbientDisplayName(BSTR& bstrDisplayName)
        {
                CComVariant var;
                if (bstrDisplayName)
                {
                        SysFreeString(bstrDisplayName);
                        bstrDisplayName = NULL;
                }
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var);
                if (SUCCEEDED(hRes))
                {
                        if (var.vt != VT_BSTR)
                                return E_FAIL;
                        bstrDisplayName = var.bstrVal;
                        var.vt = VT_EMPTY;
                        var.bstrVal = NULL;
                }
                return hRes;
        }
        HRESULT GetAmbientFont(IFont** ppFont)
        {
                // caller MUST Release the font!
                if (ppFont == NULL)
                        return E_POINTER;
                *ppFont = NULL;
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
                ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
                if (SUCCEEDED(hRes) && var.pdispVal)
                {
                        if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
                                hRes = var.pdispVal->QueryInterface(IID_IFont, (void**)ppFont);
                        else
                                hRes = DISP_E_BADVARTYPE;
                }
                return hRes;
        }
        HRESULT GetAmbientFontDisp(IFontDisp** ppFont)
        {
                // caller MUST Release the font!
                if (ppFont == NULL)
                        return E_POINTER;
                *ppFont = NULL;
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
                ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
                if (SUCCEEDED(hRes) && var.pdispVal)
                {
                        if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
                                hRes = var.pdispVal->QueryInterface(IID_IFontDisp, (void**)ppFont);
                        else
                                hRes = DISP_E_BADVARTYPE;
                }
                return hRes;
        }
        HRESULT GetAmbientForeColor(OLE_COLOR& ForeColor)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var);
                ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
                ForeColor = var.lVal;
                return hRes;
        }
        HRESULT GetAmbientLocaleID(LCID& lcid)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var);
                ATLASSERT((var.vt == VT_UI4 || var.vt == VT_I4) || FAILED(hRes));
                lcid = var.lVal;
                return hRes;
        }
        HRESULT GetAmbientScaleUnits(BSTR& bstrScaleUnits)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var);
                ATLASSERT(var.vt == VT_BSTR || FAILED(hRes));
                if (SUCCEEDED(hRes))
                {
                        if (var.vt != VT_BSTR)
                                return E_FAIL;
                        bstrScaleUnits = var.bstrVal;
                        var.vt = VT_EMPTY;
                        var.bstrVal = NULL;
                }
                return hRes;
        }
        HRESULT GetAmbientTextAlign(short& nTextAlign)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var);
                ATLASSERT(var.vt == VT_I2 || FAILED(hRes));
                nTextAlign = var.iVal;
                return hRes;
        }
        HRESULT GetAmbientUserMode(BOOL& bUserMode)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
                ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
                bUserMode = var.boolVal;
                return hRes;
        }
        HRESULT GetAmbientUIDead(BOOL& bUIDead)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var);
                ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
                bUIDead = var.boolVal;
                return hRes;
        }
        HRESULT GetAmbientShowGrabHandles(BOOL& bShowGrabHandles)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var);
                ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
                bShowGrabHandles = var.boolVal;
                return hRes;
        }
        HRESULT GetAmbientShowHatching(BOOL& bShowHatching)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var);
                ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
                bShowHatching = var.boolVal;
                return hRes;
        }
        HRESULT GetAmbientMessageReflect(BOOL& bMessageReflect)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var);
                ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
                bMessageReflect = var.boolVal;
                return hRes;
        }
        HRESULT GetAmbientAutoClip(BOOL& bAutoClip)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var);
                ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
                bAutoClip = var.boolVal;
                return hRes;
        }
        HRESULT GetAmbientDisplayAsDefault(BOOL& bDisplaysDefault)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var);
                ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
                bDisplaysDefault = var.boolVal;
                return hRes;
        }
        HRESULT GetAmbientSupportsMnemonics(BOOL& bSupportMnemonics)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var);
                ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
                bSupportMnemonics = var.boolVal;
                return hRes;
        }
        HRESULT GetAmbientPalette(HPALETTE& hPalette)
        {
                CComVariant var;
                HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var);
#ifdef _WIN64
                ATLASSERT(var.vt == VT_I8 || var.vt == VT_UI8 || FAILED(hRes));
                hPalette = *(HPALETTE*)&var.dblVal;
#else
                ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
                hPalette = reinterpret_cast<HPALETTE>(var.lVal);
#endif
                return hRes;
        }

        HRESULT InternalGetSite(REFIID riid, void** ppUnkSite)
        {
                ATLASSERT(ppUnkSite != NULL);
                if (ppUnkSite == NULL)
                        return E_POINTER;
                if (m_spClientSite == NULL)
                {
                        *ppUnkSite = NULL;
                        return S_OK;
                }
                return m_spClientSite->QueryInterface(riid, ppUnkSite);
        }

        BOOL DoesVerbUIActivate(LONG iVerb)
        {
                BOOL b = FALSE;
                switch (iVerb)
                {
                        case OLEIVERB_UIACTIVATE:
                        case OLEIVERB_PRIMARY:
                                b = TRUE;
                                break;
                }
                // if no ambient dispatch then in old style OLE container
                if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)
                        b = TRUE;
                return b;
        }

        BOOL DoesVerbActivate(LONG iVerb)
        {
                BOOL b = FALSE;
                switch (iVerb)
                {
                        case OLEIVERB_UIACTIVATE:
                        case OLEIVERB_PRIMARY:
                        case OLEIVERB_SHOW:
                        case OLEIVERB_INPLACEACTIVATE:
                                b = TRUE;
                                break;
                }
                return b;
        }

        BOOL SetControlFocus(BOOL bGrab);
        HRESULT IQuickActivate_QuickActivate(QACONTAINER *pQACont,
                QACONTROL *pQACtrl);
        HRESULT DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent);
        HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);

        HRESULT IOleObject_SetClientSite(IOleClientSite *pClientSite);
        HRESULT IOleObject_GetClientSite(IOleClientSite **ppClientSite);
        HRESULT IOleObject_Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
        HRESULT IOleObject_Close(DWORD dwSaveOption);
        HRESULT IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
        HRESULT IOleInPlaceObject_InPlaceDeactivate(void);
        HRESULT IOleInPlaceObject_UIDeactivate(void);
        HRESULT IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip);
        HRESULT IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
                DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
                LPCRECTL prcBounds, LPCRECTL prcWBounds);
        HRESULT IDataObject_GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);

        HRESULT FireViewChange();
        LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);

        virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos) = 0;
        virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv) = 0;
        virtual HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
        virtual HRESULT OnDraw(ATL_DRAWINFO& /*di*/)
        {
                return S_OK;
        }


// Attributes
public:
        CComPtr<IOleInPlaceSiteWindowless> m_spInPlaceSite;
        CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;
        CComPtr<IOleAdviseHolder> m_spOleAdviseHolder;
        CComPtr<IOleClientSite> m_spClientSite;
        CComPtr<IAdviseSink> m_spAdviseSink;
        CComDispatchDriver m_spAmbientDispatch;

        SIZE m_sizeNatural; //unscaled size in himetric
        SIZE m_sizeExtent;  //current extents in himetric
        RECT m_rcPos; // position in pixels
#pragma warning(disable: 4510 4610) // unnamed union
        union
        {
                HWND& m_hWndCD;
                HWND* m_phWndCD;
        };
#pragma warning(default: 4510 4610)
        union
        {
                // m_nFreezeEvents is the only one actually used
                int m_nFreezeEvents; // count of freezes versus thaws

                // These are here to make stock properties work
                IPictureDisp* m_pMouseIcon;
                IPictureDisp* m_pPicture;
                IFontDisp* m_pFont;
                OLE_COLOR m_clrBackColor;
                OLE_COLOR m_clrBorderColor;
                OLE_COLOR m_clrFillColor;
                OLE_COLOR m_clrForeColor;
                BSTR m_bstrText;
                BSTR m_bstrCaption;
                BOOL m_bValid;
                BOOL m_bTabStop;
                BOOL m_bBorderVisible;
                BOOL m_bEnabled;
                LONG m_nBackStyle;
                LONG m_nBorderStyle;
                LONG m_nBorderWidth;
                LONG m_nDrawMode;
                LONG m_nDrawStyle;
                LONG m_nDrawWidth;
                LONG m_nFillStyle;
                SHORT m_nAppearance;
                LONG m_nMousePointer;
                LONG m_nReadyState;
        };

        unsigned m_bNegotiatedWnd:1;
        unsigned m_bWndLess:1;
        unsigned m_bInPlaceActive:1;
        unsigned m_bUIActive:1;
        unsigned m_bUsingWindowRgn:1;
        unsigned m_bInPlaceSiteEx:1;
        unsigned m_bWindowOnly:1;
        unsigned m_bRequiresSave:1;
        unsigned m_bWasOnceWindowless:1;
        unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing
        unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE
        unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent
        unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent
        unsigned m_bDrawGetDataInHimetric:1; //instead of pixels

        DECLARE_VIEW_STATUS(VIEWSTATUS_OPAQUE)
};

inline HRESULT CComControlBase::IQuickActivate_QuickActivate(QACONTAINER *pQACont,
        QACONTROL *pQACtrl)
{
        ATLASSERT(pQACont != NULL);
        ATLASSERT(pQACtrl != NULL);
        if (!pQACont || !pQACtrl)
                return E_POINTER;

        HRESULT hRes;
        ULONG uCB = pQACtrl->cbSize;
        memset(pQACtrl, 0, uCB);
        pQACtrl->cbSize = uCB;

        // get all interfaces we are going to need
        CComPtr<IOleObject> pOO;
        ControlQueryInterface(IID_IOleObject, (void**)&pOO);
        CComPtr<IViewObjectEx> pVOEX;
        ControlQueryInterface(IID_IViewObjectEx, (void**)&pVOEX);
        CComPtr<IPointerInactive> pPI;
        ControlQueryInterface(IID_IPointerInactive, (void**)&pPI);
        CComPtr<IProvideClassInfo2> pPCI;
        ControlQueryInterface(IID_IProvideClassInfo2, (void**)&pPCI);

        if (pOO == NULL || pVOEX == NULL)
                return E_FAIL;

        pOO->SetClientSite(pQACont->pClientSite);

        if (pQACont->pAdviseSink != NULL)
        {
                ATLTRACE2(atlTraceControls,2,_T("Setting up IOleObject Advise\n"));
                pVOEX->SetAdvise(DVASPECT_CONTENT, 0, pQACont->pAdviseSink);
        }

        CComPtr<IConnectionPointContainer> pCPC;
        ControlQueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

        if (pQACont->pPropertyNotifySink)
        {
                ATLTRACE2(atlTraceControls,2,_T("Setting up PropNotify CP\n"));
                CComPtr<IConnectionPoint> pCP;
                if (pCPC != NULL)
                {
                        hRes = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
                        if (SUCCEEDED(hRes))
                                pCP->Advise(pQACont->pPropertyNotifySink, &pQACtrl->dwPropNotifyCookie);
                }
        }

        if (pPCI)
        {
                GUID iidDefaultSrc;
                if (SUCCEEDED(pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,
                        &iidDefaultSrc)))
                {
                        if (pQACont->pUnkEventSink)
                        {
                                ATLTRACE2(atlTraceControls,2,_T("Setting up Default Out Going Interface\n"));
                                CComPtr<IConnectionPoint> pCP;
                                if (pCPC != NULL)
                                {
                                        hRes = pCPC->FindConnectionPoint(iidDefaultSrc, &pCP);
                                        if (SUCCEEDED(hRes))
                                                pCP->Advise(pQACont->pUnkEventSink, &pQACtrl->dwEventCookie);
                                }
                        }
                }
        }
        // give information to container
        if (pOO != NULL)
                pOO->GetMiscStatus(DVASPECT_CONTENT, &pQACtrl->dwMiscStatus);

        if (pVOEX != NULL)
                pVOEX->GetViewStatus(&pQACtrl->dwViewStatus);

        if (pPI != NULL)
                pPI->GetActivationPolicy(&pQACtrl->dwPointerActivationPolicy);
        return S_OK;
}

inline BOOL CComControlBase::SetControlFocus(BOOL bGrab)
{
        if (m_bWndLess)
        {
                if (!m_bUIActive && bGrab)
                        if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE)))
                                return FALSE;

                return (m_spInPlaceSite->SetFocus(bGrab) == S_OK);
        }
        else
        {
                // we've got a window.
                //
                if (m_bInPlaceActive)
                {
                        HWND hwnd = (bGrab) ? m_hWndCD : ::GetParent(m_hWndCD);
                        if (!m_bUIActive && bGrab)
                                return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
                        else
                        {
                                if (!::IsChild(hwnd, ::GetFocus()))
                                        ::SetFocus(hwnd);
                                return TRUE;
                        }
                }
        }
        return FALSE;
}

inline HRESULT CComControlBase::DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent)
{
        HRESULT hr = S_OK;
        CComQIPtr <ISpecifyPropertyPages, &IID_ISpecifyPropertyPages> spPages;
        CComQIPtr <IOleObject, &IID_IOleObject> spObj;
        CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);

        if (spSite)
        {
                hr = spSite->ShowPropertyFrame();
                if (SUCCEEDED(hr))
                        return hr;
        }

        CComPtr<IUnknown> pUnk;
        ControlQueryInterface(IID_IUnknown, (void**)&pUnk);
        ATLASSERT(pUnk != NULL);
        CAUUID pages;
        spPages = pUnk;
        if (spPages)
        {
                hr = spPages->GetPages(&pages);
                if (SUCCEEDED(hr))
                {
                        spObj = pUnk;
                        if (spObj)
                        {
                                LPOLESTR szTitle = NULL;

                                spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

                                LCID lcid;
                                if (FAILED(GetAmbientLocaleID(lcid)))
                                        lcid = LOCALE_USER_DEFAULT;

                                hr = OleCreatePropertyFrame(hwndParent, m_rcPos.top, m_rcPos.left, szTitle,
                                        1, &pUnk.p, pages.cElems, pages.pElems, lcid, 0, 0);

                                CoTaskMemFree(szTitle);
                        }
                        else
                        {
                                hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
                        }
                        CoTaskMemFree(pages.pElems);
                }
        }
        else
        {
                hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
        }

        return hr;
}

inline HRESULT CComControlBase::InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/)
{
        HRESULT hr;

        if (m_spClientSite == NULL)
                return S_OK;

        CComPtr<IOleInPlaceObject> pIPO;
        ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
        ATLASSERT(pIPO != NULL);

        if (!m_bNegotiatedWnd)
        {
                if (!m_bWindowOnly)
                        // Try for windowless site
                        hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spInPlaceSite);

                if (m_spInPlaceSite)
                {
                        m_bInPlaceSiteEx = TRUE;
                        // CanWindowlessActivate returns S_OK or S_FALSE
                        if ( m_spInPlaceSite->CanWindowlessActivate() == S_OK )
                        {
                                m_bWndLess = TRUE;
                                m_bWasOnceWindowless = TRUE;
                        }
                        else
                        {
                                m_bWndLess = FALSE;
                        }
                }
                else
                {
                        m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spInPlaceSite);
                        if (m_spInPlaceSite)
                                m_bInPlaceSiteEx = TRUE;
                        else
                                hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spInPlaceSite);
                }
        }

        ATLASSERT(m_spInPlaceSite);
        if (!m_spInPlaceSite)
                return E_FAIL;

        m_bNegotiatedWnd = TRUE;

        if (!m_bInPlaceActive)
        {

                BOOL bNoRedraw = FALSE;
                if (m_bWndLess)
                        m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
                else
                {
                        if (m_bInPlaceSiteEx)
                                m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
                        else
                        {
                                hr = m_spInPlaceSite->CanInPlaceActivate();
                                // CanInPlaceActivate returns S_FALSE or S_OK
                                if (FAILED(hr))
                                        return hr;
                                if ( hr != S_OK )
                                {
                                   // CanInPlaceActivate returned S_FALSE.
                                   return( E_FAIL );
                                }
                                m_spInPlaceSite->OnInPlaceActivate();
                        }
                }
        }

        m_bInPlaceActive = TRUE;

        // get location in the parent window,
        // as well as some information about the parent
        //
        OLEINPLACEFRAMEINFO frameInfo = { 0 };
        RECT rcPos, rcClip;
        CComPtr<IOleInPlaceFrame> spInPlaceFrame;
        CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
        frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        HWND hwndParent;
        if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
        {
                m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
                        &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
                if (frameInfo.haccel)
                {
                        // this handle is not used, but it's allocated in GetWindowContext.
                        DestroyAcceleratorTable(frameInfo.haccel);
                }

                if (!m_bWndLess)
                {
                        if (m_hWndCD)
                        {
                                ShowWindow(m_hWndCD, SW_SHOW);
                                if (!::IsChild(m_hWndCD, ::GetFocus()))
                                        ::SetFocus(m_hWndCD);
                        }
                        else
                        {
                                HWND h = CreateControlWindow(hwndParent, rcPos);
                                ATLASSERT(h != NULL);        // will assert if creation failed
                                ATLASSERT(h == m_hWndCD);
                                h;        // avoid unused warning
                        }
                }

                pIPO->SetObjectRects(&rcPos, &rcClip);
        }

        CComPtr<IOleInPlaceActiveObject> spActiveObject;
        ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

        // Gone active by now, take care of UIACTIVATE
        if (DoesVerbUIActivate(iVerb))
        {
                if (!m_bUIActive)
                {
                        m_bUIActive = TRUE;
                        hr = m_spInPlaceSite->OnUIActivate();
                        if (FAILED(hr))
                                return hr;

                        SetControlFocus(TRUE);
                        // set ourselves up in the host.
                        //
                        if (spActiveObject)
                        {
                                if (spInPlaceFrame)
                                        spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
                                if (spInPlaceUIWindow)
                                        spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
                        }

                        if (spInPlaceFrame)
                                spInPlaceFrame->SetBorderSpace(NULL);
                        if (spInPlaceUIWindow)
                                spInPlaceUIWindow->SetBorderSpace(NULL);
                }
        }

        m_spClientSite->ShowObject();

        return S_OK;
}

inline HRESULT CComControlBase::SendOnDataChange(DWORD advf)
{
        HRESULT hRes = S_OK;
        if (m_spDataAdviseHolder)
        {
                CComPtr<IDataObject> pdo;
                if (SUCCEEDED(ControlQueryInterface(IID_IDataObject, (void**)&pdo)))
                        hRes = m_spDataAdviseHolder->SendOnDataChange(pdo, 0, advf);
        }
        return hRes;
}

inline HRESULT CComControlBase::IOleObject_SetClientSite(IOleClientSite *pClientSite)
{
        ATLASSERT(pClientSite == NULL || m_spClientSite == NULL);
        m_spClientSite = pClientSite;
        m_spAmbientDispatch.Release();
        if (m_spClientSite != NULL)
        {
                m_spClientSite->QueryInterface(IID_IDispatch,
                        (void**) &m_spAmbientDispatch.p);
        }
        return S_OK;
}

inline HRESULT CComControlBase::IOleObject_GetClientSite(IOleClientSite **ppClientSite)
{
        ATLASSERT(ppClientSite);
        if (ppClientSite == NULL)
                return E_POINTER;

        *ppClientSite = m_spClientSite;
        if (m_spClientSite != NULL)
                m_spClientSite.p->AddRef();
        return S_OK;
}

inline HRESULT CComControlBase::IOleObject_Advise(IAdviseSink *pAdvSink,
        DWORD *pdwConnection)
{
        HRESULT hr = S_OK;
        if (m_spOleAdviseHolder == NULL)
                hr = CreateOleAdviseHolder(&m_spOleAdviseHolder);
        if (SUCCEEDED(hr))
                hr = m_spOleAdviseHolder->Advise(pAdvSink, pdwConnection);
        return hr;
}

inline HRESULT CComControlBase::IOleObject_Close(DWORD dwSaveOption)
{
        CComPtr<IOleInPlaceObject> pIPO;
        ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
        ATLASSERT(pIPO != NULL);
        if (m_hWndCD)
        {
                if (m_spClientSite)
                        m_spClientSite->OnShowWindow(FALSE);
        }

        if (m_bInPlaceActive)
        {
                HRESULT hr = pIPO->InPlaceDeactivate();
                if (FAILED(hr))
                        return hr;
                ATLASSERT(!m_bInPlaceActive);
        }
        if (m_hWndCD)
        {
                ATLTRACE2(atlTraceControls,2,_T("Destroying Window\n"));
                if (::IsWindow(m_hWndCD))
                        DestroyWindow(m_hWndCD);
                m_hWndCD = NULL;
        }

        // handle the save flag.
        //
        if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY ||
                dwSaveOption == OLECLOSE_PROMPTSAVE) && m_bRequiresSave)
        {
                if (m_spClientSite)
                        m_spClientSite->SaveObject();
                SendOnSave();
        }

        m_spInPlaceSite.Release();
        m_bNegotiatedWnd = FALSE;
        m_bWndLess = FALSE;
        m_bInPlaceSiteEx = FALSE;
        m_spAdviseSink.Release();
        return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_InPlaceDeactivate(void)
{
        CComPtr<IOleInPlaceObject> pIPO;
        ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
        ATLASSERT(pIPO != NULL);

        if (!m_bInPlaceActive)
                return S_OK;
        pIPO->UIDeactivate();

        m_bInPlaceActive = FALSE;

        // if we have a window, tell it to go away.
        //
        if (m_hWndCD)
        {
                ATLTRACE2(atlTraceControls,2,_T("Destroying Window\n"));
                if (::IsWindow(m_hWndCD))
                        DestroyWindow(m_hWndCD);
                m_hWndCD = NULL;
        }

        if (m_spInPlaceSite)
                m_spInPlaceSite->OnInPlaceDeactivate();

        return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_UIDeactivate(void)
{
        // if we're not UIActive, not much to do.
        //
        if (!m_bUIActive)
                return S_OK;

        m_bUIActive = FALSE;

        // notify frame windows, if appropriate, that we're no longer ui-active.
        //
        CComPtr<IOleInPlaceFrame> spInPlaceFrame;
        CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
        OLEINPLACEFRAMEINFO frameInfo = { 0 };
        frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        RECT rcPos, rcClip;

        HWND hwndParent;
        // This call to GetWindow is a fix for Delphi
        if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
        {
                m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
                        &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
                if (frameInfo.haccel)
                {
                        // this handle is not used, but it's allocated in GetWindowContext.
                        DestroyAcceleratorTable(frameInfo.haccel);
                }

                if (spInPlaceUIWindow)
                        spInPlaceUIWindow->SetActiveObject(NULL, NULL);
                if (spInPlaceFrame)
                        spInPlaceFrame->SetActiveObject(NULL, NULL);
        }
        // we don't need to explicitly release the focus here since somebody
        // else grabbing the focus is what is likely to cause us to get lose it
        //
        m_spInPlaceSite->OnUIDeactivate(FALSE);

        return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip)
{
        if (prcPos == NULL || prcClip == NULL)
                return E_POINTER;

        m_rcPos = *prcPos;
        if (m_hWndCD)
        {
                // the container wants us to clip, so figure out if we really
                // need to
                //
                RECT rcIXect;
                BOOL b = IntersectRect(&rcIXect, prcPos, prcClip);
                HRGN tempRgn = NULL;
                if (b && !EqualRect(&rcIXect, prcPos))
                {
                        OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
                        tempRgn = CreateRectRgnIndirect(&rcIXect);
                }

                SetWindowRgn(m_hWndCD, tempRgn, TRUE);

                // set our control's location, but don't change it's size at all
                // [people for whom zooming is important should set that up here]
                //
                SIZEL size = {prcPos->right - prcPos->left, prcPos->bottom - prcPos->top};
                SetWindowPos(m_hWndCD, NULL, prcPos->left,
                                         prcPos->top, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
        }

        return S_OK;
}

inline HRESULT CComControlBase::IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
        if (dwDrawAspect != DVASPECT_CONTENT)
                return DV_E_DVASPECT;
        if (psizel == NULL)
                return E_POINTER;

        BOOL bSizeMatchesNatural =
                memcmp(psizel, &m_sizeNatural, sizeof(SIZE)) == 0;

        if (m_bAutoSize) //object can't do any other size
                return (bSizeMatchesNatural) ? S_OK : E_FAIL;

        BOOL bResized = FALSE;
        if (memcmp(psizel, &m_sizeExtent, sizeof(SIZE)) != 0)
        {
                m_sizeExtent = *psizel;
                bResized = TRUE;
        }
        if (m_bResizeNatural && !bSizeMatchesNatural)
        {
                m_sizeNatural = *psizel;
                bResized = TRUE;
        }

        if (m_bRecomposeOnResize && bResized)
        {
                SendOnDataChange();
                FireViewChange();
        }
        return S_OK;
}

inline HRESULT CComControlBase::IViewObject_Draw(DWORD dwDrawAspect, LONG lindex,
        void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
        LPCRECTL prcBounds, LPCRECTL prcWBounds)
{
        ATLTRACE2(atlTraceControls,2,_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"),
                dwDrawAspect, lindex, ptd, hicTargetDev, hdcDraw);
#ifdef _DEBUG
        if (prcBounds == NULL)
                ATLTRACE2(atlTraceControls,2,_T("\tprcBounds=NULL\n"));
        else
                ATLTRACE2(atlTraceControls,2,_T("\tprcBounds=%d,%d,%d,%d\n"), prcBounds->left,
                        prcBounds->top, prcBounds->right, prcBounds->bottom);
        if (prcWBounds == NULL)
                ATLTRACE2(atlTraceControls,2,_T("\tprcWBounds=NULL\n"));
        else
                ATLTRACE2(atlTraceControls,2,_T("\tprcWBounds=%d,%d,%d,%d\n"), prcWBounds->left,
                        prcWBounds->top, prcWBounds->right, prcWBounds->bottom);
#endif

        if (prcBounds == NULL)
        {
                if (!m_bWndLess)
                        return E_INVALIDARG;
                prcBounds = (RECTL*)&m_rcPos;
        }

        // support the aspects required for multi-pass drawing
        switch (dwDrawAspect)
        {
                case DVASPECT_CONTENT:
                case DVASPECT_OPAQUE:
                case DVASPECT_TRANSPARENT:
                        break;
                default:
                        ATLASSERT(FALSE);
                        return DV_E_DVASPECT;
                        break;
        }

        // make sure nobody forgets to do this
        if (ptd == NULL)
                hicTargetDev = NULL;

        BOOL bOptimize = FALSE;
        if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb >= sizeof(DVASPECTINFO))
                bOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE);

        ATL_DRAWINFO di;
        memset(&di, 0, sizeof(di));
        di.cbSize = sizeof(di);
        di.dwDrawAspect = dwDrawAspect;
        di.lindex = lindex;
        di.ptd = ptd;
        di.hicTargetDev = hicTargetDev;
        di.hdcDraw = hdcDraw;
        di.prcBounds = prcBounds;
        di.prcWBounds = prcWBounds;
        di.bOptimize = bOptimize;
        return OnDrawAdvanced(di);
}

inline HRESULT CComControlBase::IDataObject_GetData(FORMATETC *pformatetcIn,
        STGMEDIUM *pmedium)
{
        if (pmedium == NULL)
                return E_POINTER;
        memset(pmedium, 0, sizeof(STGMEDIUM));
        ATLTRACE2(atlTraceControls,2,_T("Format = %x\n"), pformatetcIn->cfFormat);
        ATLTRACE2(atlTraceControls,2,_T("TYMED = %x\n"), pformatetcIn->tymed);

        if ((pformatetcIn->tymed & TYMED_MFPICT) == 0)
                return DATA_E_FORMATETC;

        SIZEL sizeMetric, size;
        if (m_bDrawFromNatural)
                sizeMetric = m_sizeNatural;
        else
                sizeMetric = m_sizeExtent;
        if (!m_bDrawGetDataInHimetric)
                AtlHiMetricToPixel(&sizeMetric, &size);
        else
                size = sizeMetric;
        RECTL rectl = {0 ,0, size.cx, size.cy};

        ATL_DRAWINFO di;
        memset(&di, 0, sizeof(di));
        di.cbSize = sizeof(di);
        di.dwDrawAspect = DVASPECT_CONTENT;
        di.lindex = -1;
        di.ptd = NULL;
        di.hicTargetDev = NULL;
        di.prcBounds = &rectl;
        di.prcWBounds = &rectl;
        di.bOptimize = TRUE; //we do a SaveDC/RestoreDC
        di.bRectInHimetric = m_bDrawGetDataInHimetric;
        // create appropriate memory metafile DC
        di.hdcDraw = CreateMetaFile(NULL);

        // create attribute DC according to pformatetcIn->ptd

        SaveDC(di.hdcDraw);
        SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
        SetWindowExtEx(di.hdcDraw, rectl.right, rectl.bottom, NULL);
        OnDrawAdvanced(di);
        RestoreDC(di.hdcDraw, -1);

        HMETAFILE hMF = CloseMetaFile(di.hdcDraw);
        if (hMF == NULL)
                return E_UNEXPECTED;

        HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT));

        if (NULL==hMem)
        {
                DeleteMetaFile(hMF);
                return ResultFromScode(STG_E_MEDIUMFULL);
        }

        LPMETAFILEPICT pMF=(LPMETAFILEPICT)GlobalLock(hMem);
        pMF->hMF=hMF;
        pMF->mm=MM_ANISOTROPIC;
        pMF->xExt=sizeMetric.cx;
        pMF->yExt=sizeMetric.cy;
        GlobalUnlock(hMem);

        pmedium->tymed = TYMED_MFPICT;
        pmedium->hGlobal = hMem;
        pmedium->pUnkForRelease = NULL;

        return S_OK;
}

inline HRESULT CComControlBase::FireViewChange()
{
        if (m_bInPlaceActive)
        {
                // Active
                if (m_hWndCD != NULL)
                        ::InvalidateRect(m_hWndCD, NULL, TRUE); // Window based
                else if (m_spInPlaceSite != NULL)
                        m_spInPlaceSite->InvalidateRect(NULL, TRUE); // Windowless
        }
        else // Inactive
                SendOnViewChange(DVASPECT_CONTENT);
        return S_OK;
}

inline void CComControlBase::GetZoomInfo(ATL_DRAWINFO& di)
{
        const RECTL& rcPos = *di.prcBounds;
        SIZEL sizeDen;
        if (m_bDrawFromNatural)
                sizeDen = m_sizeNatural;
        else
                sizeDen = m_sizeExtent;
        if (!di.bRectInHimetric)
                AtlHiMetricToPixel(&sizeDen, &sizeDen);
        SIZEL sizeNum = {rcPos.right-rcPos.left, rcPos.bottom-rcPos.top};
        di.ZoomNum.cx = sizeNum.cx;
        di.ZoomNum.cy = sizeNum.cy;
        di.ZoomDen.cx = sizeDen.cx;
        di.ZoomDen.cy = sizeDen.cy;
        if (sizeDen.cx == 0 || sizeDen.cy == 0 ||
                sizeNum.cx == 0 || sizeNum.cy == 0)
        {
                di.ZoomNum.cx = di.ZoomNum.cy = di.ZoomDen.cx = di.ZoomDen.cy = 1;
                di.bZoomed = FALSE;
        }
        else if (sizeNum.cx != sizeDen.cx || sizeNum.cy != sizeDen.cy)
                di.bZoomed = TRUE;
        else
                di.bZoomed = FALSE;
}

inline HRESULT CComControlBase::OnDrawAdvanced(ATL_DRAWINFO& di)
{
        BOOL bDeleteDC = FALSE;
        if (di.hicTargetDev == NULL)
        {
                di.hicTargetDev = AtlCreateTargetDC(di.hdcDraw, di.ptd);
                bDeleteDC = (di.hicTargetDev != di.hdcDraw);
        }
        RECTL rectBoundsDP = *di.prcBounds;
        BOOL bMetafile = GetDeviceCaps(di.hdcDraw, TECHNOLOGY) == DT_METAFILE;
        if (!bMetafile)
        {
                ::LPtoDP(di.hicTargetDev, (LPPOINT)&rectBoundsDP, 2);
                SaveDC(di.hdcDraw);
                SetMapMode(di.hdcDraw, MM_TEXT);
                SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
                SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);
                di.bOptimize = TRUE; //since we save the DC we can do this
        }
        di.prcBounds = &rectBoundsDP;
        GetZoomInfo(di);

        HRESULT hRes = OnDraw(di);
        if (bDeleteDC)
                ::DeleteDC(di.hicTargetDev);
        if (!bMetafile)
                RestoreDC(di.hdcDraw, -1);
        return hRes;
}

inline LRESULT CComControlBase::OnPaint(UINT /* uMsg */, WPARAM wParam,
        LPARAM /* lParam */, BOOL& /* lResult */)
{
        RECT rc;
        PAINTSTRUCT ps;

        HDC hdc = (wParam != NULL) ? (HDC)wParam : ::BeginPaint(m_hWndCD, &ps);
        if (hdc == NULL)
                return 0;
        ::GetClientRect(m_hWndCD, &rc);

        ATL_DRAWINFO di;
        memset(&di, 0, sizeof(di));
        di.cbSize = sizeof(di);
        di.dwDrawAspect = DVASPECT_CONTENT;
        di.lindex = -1;
        di.hdcDraw = hdc;
        di.prcBounds = (LPCRECTL)&rc;

        OnDrawAdvanced(di);
        if (wParam == NULL)
                ::EndPaint(m_hWndCD, &ps);
        return 0;
}

template <class T, class WinBase =  CWindowImpl< T > >
class ATL_NO_VTABLE CComControl :  public CComControlBase, public WinBase
{
public:
        CComControl() : CComControlBase(m_hWnd) {}
        HRESULT FireOnRequestEdit(DISPID dispID)
        {
                T* pT = static_cast<T*>(this);
                return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT->GetUnknown(), dispID);
        }
        HRESULT FireOnChanged(DISPID dispID)
        {
                T* pT = static_cast<T*>(this);
                return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT->GetUnknown(), dispID);
        }
        virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv)
        {
                T* pT = static_cast<T*>(this);
                return pT->_InternalQueryInterface(iid, ppv);
        }
        virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
        {
                T* pT = static_cast<T*>(this);
                return pT->Create(hWndParent, rcPos);
        }

        typedef CComControl< T, WinBase >        thisClass;
        BEGIN_MSG_MAP(thisClass)
                MESSAGE_HANDLER(WM_PAINT, CComControlBase::OnPaint)
                MESSAGE_HANDLER(WM_SETFOCUS, CComControlBase::OnSetFocus)
                MESSAGE_HANDLER(WM_KILLFOCUS, CComControlBase::OnKillFocus)
                MESSAGE_HANDLER(WM_MOUSEACTIVATE, CComControlBase::OnMouseActivate)
        END_MSG_MAP()
};

//////////////////////////////////////////////////////////////////////////////
// CComCompositeControl

#ifndef _ATL_NO_HOSTING
template <class T>
class CComCompositeControl : public CComControl< T, CAxDialogImpl< T > >
{
public:
        CComCompositeControl()
        {
                m_hbrBackground = NULL;
        }
        ~CComCompositeControl()
        {
                DeleteObject(m_hbrBackground);
        }
        HRESULT AdviseSinkMap(bool bAdvise)
        {
                if(!bAdvise && m_hWnd == NULL)
                {
                        // window is gone, controls are already unadvised
                        ATLTRACE2(atlTraceControls, 1, _T("CComCompositeControl::AdviseSinkMap called after the window was destroyed\n"));
                        return S_OK;
                }
                T* pT = static_cast<T*>(this);
                return AtlAdviseSinkMap(pT, bAdvise);
        }
        HBRUSH m_hbrBackground;
        HRESULT SetBackgroundColorFromAmbient()
        {
                if (m_hbrBackground != NULL)
                {
                        DeleteObject(m_hbrBackground);
                        m_hbrBackground = NULL;
                }
                OLE_COLOR clr;
                HRESULT hr = GetAmbientBackColor(clr);
                if (SUCCEEDED(hr))
                {
                        COLORREF rgb;
                        ::OleTranslateColor(clr, NULL, &rgb);
                        m_hbrBackground = ::CreateSolidBrush(rgb);
                        EnumChildWindows(m_hWnd, (WNDENUMPROC)BackgroundColorEnumProc, (LPARAM) clr);
                }
                return hr;
        }
        static BOOL CALLBACK BackgroundColorEnumProc(HWND hwnd, LPARAM l)
        {
                CAxWindow wnd(hwnd);
                CComPtr<IAxWinAmbientDispatch> spDispatch;
                wnd.QueryHost(&spDispatch);
                if (spDispatch != NULL)
                        spDispatch->put_BackColor((OLE_COLOR)l);
                return TRUE;
        }
        LRESULT OnDialogColor(UINT, WPARAM w, LPARAM, BOOL&)
        {
                HDC dc = (HDC) w;
                LOGBRUSH lb;
                ::GetObject(m_hbrBackground, sizeof(lb), (void*)&lb);
                ::SetBkColor(dc, lb.lbColor);
                return (LRESULT)m_hbrBackground;
        }
        HWND Create(HWND hWndParent, RECT& /*rcPos*/, LPARAM dwInitParam = NULL)
        {
                CComControl< T, CAxDialogImpl< T > >::Create(hWndParent, dwInitParam);
                SetBackgroundColorFromAmbient();
                if (m_hWnd != NULL)
                        ShowWindow(SW_SHOWNOACTIVATE);
                return m_hWnd;
        }
        BOOL CalcExtent(SIZE& size)
        {
                HINSTANCE hInstance = _Module.GetResourceInstance();
                LPCTSTR lpTemplateName = MAKEINTRESOURCE(T::IDD);
                HRSRC hDlgTempl = FindResource(hInstance, lpTemplateName, RT_DIALOG);
                if (hDlgTempl == NULL)
                        return FALSE;
                HGLOBAL hResource = LoadResource(hInstance, hDlgTempl);
                DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hResource);
                if (pDlgTempl == NULL)
                        return FALSE;
                AtlGetDialogSize(pDlgTempl, &size);
                AtlPixelToHiMetric(&size, &size);
                return TRUE;
        }
//Implementation
        BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hRet)
        {
                hRet = S_OK;
                if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
                   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
                        return FALSE;
                // find a direct child of the dialog from the window that has focus
                HWND hWndCtl = ::GetFocus();
                if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
                {
                        do
                        {
                                hWndCtl = ::GetParent(hWndCtl);
                        }
                        while (::GetParent(hWndCtl) != m_hWnd);
                }
                // give controls a chance to translate this message
                if (::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg) == 1)
                        return TRUE;

                // special handling for keyboard messages
                DWORD_PTR dwDlgCode = ::SendMessage(pMsg->hwnd, WM_GETDLGCODE, 0, 0L);
                switch(pMsg->message)
                {
                case WM_CHAR:
                        if(dwDlgCode == 0)        // no dlgcode, possibly an ActiveX control
                                return FALSE;        // let the container process this
                        break;
                case WM_KEYDOWN:
                        switch(LOWORD(pMsg->wParam))
                        {
                        case VK_TAB:
                                // prevent tab from looping inside of our dialog
                                if((dwDlgCode & DLGC_WANTTAB) == 0)
                                {
                                        HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
                                        if (::GetKeyState(VK_SHIFT) >= 0)  // not pressed
                                                hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
                                        if (hWndFirstOrLast == hWndCtl)
                                                return FALSE;
                                }
                                break;
                        case VK_LEFT:
                        case VK_UP:
                        case VK_RIGHT:
                        case VK_DOWN:
                                // prevent arrows from looping inside of our dialog
                                if((dwDlgCode & DLGC_WANTARROWS) == 0)
                                {
                                        HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
                                        if (pMsg->wParam == VK_RIGHT || pMsg->wParam == VK_DOWN)        // going forward
                                                hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
                                        if (hWndFirstOrLast == hWndCtl)
                                                return FALSE;
                                }
                                break;
                        case VK_EXECUTE:
                        case VK_RETURN:
                        case VK_ESCAPE:
                        case VK_CANCEL:
                                // we don't want to handle these, let the container do it
                                return FALSE;
                        }
                        break;
                }

                return IsDialogMessage(pMsg);
        }
        HRESULT IOleInPlaceObject_InPlaceDeactivate(void)
        {
                AdviseSinkMap(false); //unadvise
                return CComControl<T, CAxDialogImpl<T> >::IOleInPlaceObject_InPlaceDeactivate();
        }
        virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
        {
                T* pT = static_cast<T*>(this);
                HWND h = pT->Create(hWndParent, rcPos);
                if (h != NULL)
                        AdviseSinkMap(true);
                return h;
        }
        virtual HRESULT OnDraw(ATL_DRAWINFO& di)
        {
                if(!m_bInPlaceActive)
                {
                        HPEN hPen = (HPEN)::GetStockObject(BLACK_PEN);
                        HBRUSH hBrush = (HBRUSH)::GetStockObject(GRAY_BRUSH);
                        ::SelectObject(di.hdcDraw, hPen);
                        ::SelectObject(di.hdcDraw, hBrush);
                        ::Rectangle(di.hdcDraw, di.prcBounds->left, di.prcBounds->top, di.prcBounds->right, di.prcBounds->bottom);
                        ::SetTextColor(di.hdcDraw, ::GetSysColor(COLOR_WINDOWTEXT));
                        ::SetBkMode(di.hdcDraw, TRANSPARENT);
                        ::DrawText(di.hdcDraw, _T("ATL Composite Control"), -1, (LPRECT)di.prcBounds, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
                }
                return S_OK;
        }
        typedef CComControl< T, CAxDialogImpl< T > >        baseClass;
        BEGIN_MSG_MAP(CComCompositeControl< T >)
                MESSAGE_HANDLER(WM_CTLCOLORDLG, OnDialogColor)
                MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnDialogColor)
                MESSAGE_HANDLER(WM_SETFOCUS, baseClass::OnSetFocus)
                MESSAGE_HANDLER(WM_KILLFOCUS, baseClass::OnKillFocus)
                MESSAGE_HANDLER(WM_MOUSEACTIVATE, baseClass::OnMouseActivate)
        END_MSG_MAP()

        BEGIN_SINK_MAP(T)
        END_SINK_MAP()
};
#endif //_ATL_NO_HOSTING

// Forward declarations
//
template <class T> class IPersistStorageImpl;
template <class T> class IPersistPropertyBagImpl;

template <class T> class IOleControlImpl;
template <class T> class IRunnableObjectImpl;
template <class T> class IQuickActivateImpl;
template <class T> class IOleObjectImpl;
template <class T> class IPropertyPageImpl;
template <class T> class IPropertyPage2Impl;
template <class T> class IPerPropertyBrowsingImpl;
template <class T> class IViewObjectExImpl;
template <class T> class IOleWindowImpl;
template <class T> class IPointerInactiveImpl;
template <class T, class CDV> class IPropertyNotifySinkCP;
template <class T> class IBindStatusCallbackImpl;
template <class T> class CBindStatusCallback;


//////////////////////////////////////////////////////////////////////////////
// IOleControlImpl
template <class T>
class ATL_NO_VTABLE IOleControlImpl : public IOleControl
{
public:
        STDMETHOD(GetControlInfo)(LPCONTROLINFO /* pCI */)
        {
                ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));
        }
        STDMETHOD(OnMnemonic)(LPMSG /* pMsg */)
        {
                ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));
        }
        STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
        {
                dispid;
                ATLTRACE2(atlTraceControls,2,_T("IOleControlImpl::OnAmbientPropertyChange\n"));
                ATLTRACE2(atlTraceControls,2,_T(" -- DISPID = %d (%d)\n"), dispid);
                return S_OK;
        }
        STDMETHOD(FreezeEvents)(BOOL bFreeze)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleControlImpl::FreezeEvents\n"));
                if (bFreeze)
                        pT->m_nFreezeEvents++;
                else
                        pT->m_nFreezeEvents--;
                return S_OK;
        }
};


//////////////////////////////////////////////////////////////////////////////
// IQuickActivateImpl
template <class T>
class ATL_NO_VTABLE IQuickActivateImpl : public IQuickActivate
{
public:
        STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::QuickActivate\n"));
                return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
        }
        STDMETHOD(SetContentExtent)(LPSIZEL pSize)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::SetContentExtent\n"));
                return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);
        }
        STDMETHOD(GetContentExtent)(LPSIZEL pSize)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::GetContentExtent\n"));
                return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);
        }
};


//////////////////////////////////////////////////////////////////////////////
// IOleObjectImpl
template <class T>
class ATL_NO_VTABLE IOleObjectImpl : public IOleObject
{
public:
        STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetClientSite\n"));
                return pT->IOleObject_SetClientSite(pClientSite);
        }
        STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetClientSite\n"));
                return pT->IOleObject_GetClientSite(ppClientSite);
        }
        STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetHostNames\n"));
                return S_OK;
        }
        STDMETHOD(Close)(DWORD dwSaveOption)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Close\n"));
                return pT->IOleObject_Close(dwSaveOption);
        }
        STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
        {
                ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));
        }
        STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
        {
                ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));
        }
        STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
        {
                ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));
        }
        STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
        {
                ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));
        }

        // Helpers for DoVerb - Over-rideable in user class
        HRESULT DoVerbPrimary(LPCRECT prcPosRect, HWND hwndParent)
        {
                T* pT = static_cast<T*>(this);
                BOOL bDesignMode = FALSE;
                CComVariant var;
                // if container doesn't support this property
                // don't allow design mode
                HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
                if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)
                        bDesignMode = TRUE;
                if (bDesignMode)
                        return pT->DoVerbProperties(prcPosRect, hwndParent);
                else
                        return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);
        }
        HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
        {
                T* pT = static_cast<T*>(this);
                HRESULT hr;
                hr = pT->OnPreVerbShow();
                if (SUCCEEDED(hr))
                {
                        hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
                        if (SUCCEEDED(hr))
                                hr = pT->OnPostVerbShow();
                }
                return hr;
        }
        HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
        {
                T* pT = static_cast<T*>(this);
                HRESULT hr;
                hr = pT->OnPreVerbInPlaceActivate();
                if (SUCCEEDED(hr))
                {
                        hr = pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
                        if (SUCCEEDED(hr))
                                hr = pT->OnPostVerbInPlaceActivate();
                        if (SUCCEEDED(hr))
                                pT->FireViewChange();
                }
                return hr;
        }
        HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
        {
                T* pT = static_cast<T*>(this);
                HRESULT hr = S_OK;
                if (!pT->m_bUIActive)
                {
                        hr = pT->OnPreVerbUIActivate();
                        if (SUCCEEDED(hr))
                        {
                                hr = pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);
                                if (SUCCEEDED(hr))
                                        hr = pT->OnPostVerbUIActivate();
                        }
                }
                return hr;
        }
        HRESULT DoVerbHide(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
        {
                T* pT = static_cast<T*>(this);
                HRESULT hr;
                hr = pT->OnPreVerbHide();
                if (SUCCEEDED(hr))
                {
                        pT->UIDeactivate();
                        if (pT->m_hWnd)
                                pT->ShowWindow(SW_HIDE);
                        hr = pT->OnPostVerbHide();
                }
                return hr;
        }
        HRESULT DoVerbOpen(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
        {
                T* pT = static_cast<T*>(this);
                HRESULT hr;
                hr = pT->OnPreVerbOpen();
                if (SUCCEEDED(hr))
                        hr = pT->OnPostVerbOpen();
                return hr;
        }
        HRESULT DoVerbDiscardUndo(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
        {
                T* pT = static_cast<T*>(this);
                HRESULT hr;
                hr = pT->OnPreVerbDiscardUndo();
                if (SUCCEEDED(hr))
                        hr = pT->OnPostVerbDiscardUndo();
                return hr;
        }
        STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* pMsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
                                                                         HWND hwndParent, LPCRECT lprcPosRect)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::DoVerb(%d)\n"), iVerb);
                ATLASSERT(pT->m_spClientSite);

                HRESULT hr = E_NOTIMPL;
                switch (iVerb)
                {
                case OLEIVERB_PRIMARY:
                        hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
                        break;
                case OLEIVERB_SHOW:
                        hr = pT->DoVerbShow(lprcPosRect, hwndParent);
                        break;
                case OLEIVERB_INPLACEACTIVATE:
                        hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);
                        break;
                case OLEIVERB_UIACTIVATE:
                        hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);
                        break;
                case OLEIVERB_HIDE:
                        hr = pT->DoVerbHide(lprcPosRect, hwndParent);
                        break;
                case OLEIVERB_OPEN:
                        hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
                        break;
                case OLEIVERB_DISCARDUNDOSTATE:
                        hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
                        break;
                case OLEIVERB_PROPERTIES:
                        hr = pT->DoVerbProperties(lprcPosRect, hwndParent);
                }
                return hr;
        }
        STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::EnumVerbs\n"));
                ATLASSERT(ppEnumOleVerb);
                if (!ppEnumOleVerb)
                        return E_POINTER;
                return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);
        }
        STDMETHOD(Update)(void)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Update\n"));
                return S_OK;
        }
        STDMETHOD(IsUpToDate)(void)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::IsUpToDate\n"));
                return S_OK;
        }
        STDMETHOD(GetUserClassID)(CLSID *pClsid)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetUserClassID\n"));
                ATLASSERT(pClsid);
                if (!pClsid)
                        return E_POINTER;
                *pClsid = T::GetObjectCLSID();
                return S_OK;
        }
        STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetUserType\n"));
                return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);
        }
        STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetExtent\n"));
                return pT->IOleObject_SetExtent(dwDrawAspect, psizel);
        }
        STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetExtent\n"));
                if (dwDrawAspect != DVASPECT_CONTENT)
                        return E_FAIL;
                if (psizel == NULL)
                        return E_POINTER;
                *psizel = pT->m_sizeExtent;
                return S_OK;
        }
        STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Advise\n"));
                return pT->IOleObject_Advise(pAdvSink, pdwConnection);
        }
        STDMETHOD(Unadvise)(DWORD dwConnection)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Unadvise\n"));
                HRESULT hRes = E_FAIL;
                if (pT->m_spOleAdviseHolder != NULL)
                        hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);
                return hRes;
        }
        STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::EnumAdvise\n"));
                HRESULT hRes = E_FAIL;
                if (pT->m_spOleAdviseHolder != NULL)
                        hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);
                return hRes;
        }
        STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetMiscStatus\n"));
                return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);
        }
        STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
        {
                ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));
        }
// Implementation
public:
        HRESULT OnPreVerbShow() { return S_OK; }
        HRESULT OnPostVerbShow() { return S_OK; }
        HRESULT OnPreVerbInPlaceActivate() { return S_OK; }
        HRESULT OnPostVerbInPlaceActivate() { return S_OK; }
        HRESULT OnPreVerbUIActivate() { return S_OK; }
        HRESULT OnPostVerbUIActivate() { return S_OK; }
        HRESULT OnPreVerbHide() { return S_OK; }
        HRESULT OnPostVerbHide() { return S_OK; }
        HRESULT OnPreVerbOpen() { return S_OK; }
        HRESULT OnPostVerbOpen() { return S_OK; }
        HRESULT OnPreVerbDiscardUndo() { return S_OK; }
        HRESULT OnPostVerbDiscardUndo() { return S_OK; }
};

//local struct used for implementation
#pragma pack(push, 1)
struct _ATL_DLGTEMPLATEEX
{
        WORD dlgVer;
        WORD signature;
        DWORD helpID;
        DWORD exStyle;
        DWORD style;
        WORD cDlgItems;
        short x;
        short y;
        short cx;
        short cy;
};
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// IPropertyPageImpl
template <class T>
class ATL_NO_VTABLE IPropertyPageImpl : public IPropertyPage
{

public:
        void SetDirty(BOOL bDirty)
        {
                T* pT = static_cast<T*>(this);
                if (pT->m_bDirty != bDirty)
                {
                        pT->m_bDirty = bDirty;
                        pT->m_pPageSite->OnStatusChange(bDirty ? PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE : 0);
                }
        }

        IPropertyPageImpl()
        {
                T* pT = static_cast<T*>(this);
                pT->m_pPageSite = NULL;
                pT->m_size.cx = 0;
                pT->m_size.cy = 0;
                pT->m_dwTitleID = 0;
                pT->m_dwHelpFileID = 0;
                pT->m_dwDocStringID = 0;
                pT->m_dwHelpContext = 0;
                pT->m_ppUnk = NULL;
                pT->m_nObjects = 0;
                pT->m_bDirty = FALSE;
                pT->m_hWnd = NULL;
        }

        ~IPropertyPageImpl()
        {
                T* pT = static_cast<T*>(this);
                if (pT->m_pPageSite != NULL)
                        pT->m_pPageSite->Release();

                for (UINT i = 0; i < m_nObjects; i++)
                        pT->m_ppUnk[i]->Release();

                delete[] pT->m_ppUnk;
        }

        // IPropertyPage
        //
        STDMETHOD(SetPageSite)(IPropertyPageSite *pPageSite)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::SetPageSite\n"));

                if (!pPageSite && pT->m_pPageSite)
                {
                        pT->m_pPageSite->Release();
                        pT->m_pPageSite = NULL;
                        return S_OK;
                }

                if (!pPageSite && !pT->m_pPageSite)
                        return S_OK;

                if (pPageSite && pT->m_pPageSite)
                {
                        ATLTRACE2(atlTraceControls,2,_T("Error : setting page site again with non NULL value\n"));
                        return E_UNEXPECTED;
                }

                pT->m_pPageSite = pPageSite;
                pT->m_pPageSite->AddRef();
                return S_OK;
        }
        STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Activate\n"));

                if (pRect == NULL)
                {
                        ATLTRACE2(atlTraceControls,2,_T("Error : Passed a NULL rect\n"));
                        return E_POINTER;
                }

                pT->m_hWnd = pT->Create(hWndParent);
                Move(pRect);

                m_size.cx = pRect->right - pRect->left;
                m_size.cy = pRect->bottom - pRect->top;

                return S_OK;

        }
        STDMETHOD(Deactivate)( void)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Deactivate\n"));

                if (pT->m_hWnd)
                {
                        ATLTRACE2(atlTraceControls,2,_T("Destroying Dialog\n"));
                        if (::IsWindow(pT->m_hWnd))
                                pT->DestroyWindow();
                        pT->m_hWnd = NULL;
                }

                return S_OK;

        }
        STDMETHOD(GetPageInfo)(PROPPAGEINFO *pPageInfo)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::GetPageInfo\n"));

                if (pPageInfo == NULL)
                {
                        ATLTRACE2(atlTraceControls,2,_T("Error : PROPPAGEINFO passed == NULL\n"));
                        return E_POINTER;
                }

                HRSRC hRsrc = FindResource(_Module.GetResourceInstance(),
                                                                   MAKEINTRESOURCE(T::IDD), RT_DIALOG);
                if (hRsrc == NULL)
                {
                        ATLTRACE2(atlTraceControls,2,_T("Could not find resource template\n"));
                        return E_UNEXPECTED;
                }

                HGLOBAL hGlob = LoadResource(_Module.GetResourceInstance(), hRsrc);
                DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hGlob);
                if (pDlgTempl == NULL)
                {
                        ATLTRACE2(atlTraceControls,2,_T("Could not load resource template\n"));
                        return E_UNEXPECTED;
                }
                AtlGetDialogSize(pDlgTempl, &m_size);

                pPageInfo->cb = sizeof(PROPPAGEINFO);
                pPageInfo->pszTitle = LoadStringHelper(pT->m_dwTitleID);
                pPageInfo->size = m_size;
                pPageInfo->pszHelpFile = LoadStringHelper(pT->m_dwHelpFileID);
                pPageInfo->pszDocString = LoadStringHelper(pT->m_dwDocStringID);
                pPageInfo->dwHelpContext = pT->m_dwHelpContext;

                return S_OK;
        }

        STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::SetObjects\n"));

                if (ppUnk == NULL)
                        return E_POINTER;

                if (pT->m_ppUnk != NULL && pT->m_nObjects > 0)
                {
                        for (UINT iObj = 0; iObj < pT->m_nObjects; iObj++)
                                pT->m_ppUnk[iObj]->Release();

                        delete [] pT->m_ppUnk;
                }

                pT->m_ppUnk = NULL;
                ATLTRY(pT->m_ppUnk = new IUnknown*[nObjects]);

                if (pT->m_ppUnk == NULL)
                        return E_OUTOFMEMORY;

                for (UINT i = 0; i < nObjects; i++)
                {
                        ppUnk[i]->AddRef();
                        pT->m_ppUnk[i] = ppUnk[i];
                }

                pT->m_nObjects = nObjects;

                return S_OK;
        }
        STDMETHOD(Show)(UINT nCmdShow)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Show\n"));

                if (pT->m_hWnd == NULL)
                        return E_UNEXPECTED;

                ShowWindow(pT->m_hWnd, nCmdShow);
                return S_OK;
        }
        STDMETHOD(Move)(LPCRECT pRect)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Move\n"));

                if (pT->m_hWnd == NULL)
                        return E_UNEXPECTED;

                if (pRect == NULL)
                        return E_POINTER;

                MoveWindow(pT->m_hWnd, pRect->left, pRect->top, pRect->right - pRect->left,
                                 pRect->bottom - pRect->top, TRUE);

                return S_OK;

        }
        STDMETHOD(IsPageDirty)(void)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::IsPageDirty\n"));
                return pT->m_bDirty ? S_OK : S_FALSE;
        }
        STDMETHOD(Apply)(void)
        {
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Apply\n"));
                return S_OK;
        }
        STDMETHOD(Help)(LPCOLESTR pszHelpDir)
        {
                T* pT = static_cast<T*>(this);
                USES_CONVERSION;

                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Help\n"));
                CComBSTR szFullFileName(pszHelpDir);
                LPOLESTR szFileName = LoadStringHelper(pT->m_dwHelpFileID);
                szFullFileName.Append(OLESTR("\\"));
                szFullFileName.Append(szFileName);
                CoTaskMemFree(szFileName);
                WinHelp(pT->m_hWnd, OLE2CT(szFullFileName), HELP_CONTEXTPOPUP, NULL);
                return S_OK;
        }
        STDMETHOD(TranslateAccelerator)(MSG *pMsg)
        {
                ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::TranslateAccelerator\n"));
                T* pT = static_cast<T*>(this);
                if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
                        (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
                        return S_FALSE;

                return (IsDialogMessage(pT->m_hWnd, pMsg)) ? S_OK : S_FALSE;
        }

        IPropertyPageSite* m_pPageSite;
        IUnknown** m_ppUnk;
        ULONG m_nObjects;
        SIZE m_size;
        UINT m_dwTitleID;
        UINT m_dwHelpFileID;
        UINT m_dwDocStringID;
        DWORD m_dwHelpContext;
        BOOL m_bDirty;

//methods
public:

        BEGIN_MSG_MAP(IPropertyPageImpl<T>)
                MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange)
        END_MSG_MAP()

        LRESULT OnStyleChange(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
        {
                if (wParam == GWL_EXSTYLE)
                {
                        LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
                        lpss->styleNew |= WS_EX_CONTROLPARENT;
                        return 0;
                }
                return 1;
        }

        LPOLESTR LoadStringHelper(UINT idRes)
        {
                USES_CONVERSION;

                TCHAR szTemp[_MAX_PATH];
                LPOLESTR sz;
                sz = (LPOLESTR)CoTaskMemAlloc(_MAX_PATH*sizeof(OLECHAR));
                if (sz == NULL)
                        return NULL;
                sz[0] = NULL;

                if (LoadString(_Module.GetResourceInstance(), idRes, szTemp, _MAX_PATH))
                        ocscpy(sz, T2OLE(szTemp));
                else
                {
                        ATLTRACE2(atlTraceControls,2,_T("Error : Failed to load string from res\n"));
                }

                return sz;
        }
};


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage2Impl
template <class T>
class ATL_NO_VTABLE IPropertyPage2Impl : public IPropertyPageImpl<T>
{
public:

        STDMETHOD(EditProperty)(DISPID dispID)
        {
                ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n"));
        }
};



//////////////////////////////////////////////////////////////////////////////
// IPerPropertyBrowsingImpl
template <class T>
class ATL_NO_VTABLE IPerPropertyBrowsingImpl : public IPerPropertyBrowsing
{
public:
        STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr)
        {
                ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetDisplayString\n"));
                T* pT = static_cast<T*>(this);
                *pBstr = NULL;
                CComVariant var;
                if (FAILED(CComDispatchDriver::GetProperty(pT, dispID, &var)))
                        return S_FALSE;

                BSTR bstrTemp = var.bstrVal;
                if (var.vt != VT_BSTR)
                {
                        CComVariant varDest;
                        if (FAILED(::VariantChangeType(&varDest, &var, VARIANT_NOVALUEPROP, VT_BSTR)))
                                return S_FALSE;
                        bstrTemp = varDest.bstrVal;
                }
                *pBstr = SysAllocString(bstrTemp);
                if (*pBstr == NULL)
                        return E_OUTOFMEMORY;
                return S_OK;
        }

        STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid)
        {
                ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n"));
                ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
                ATLASSERT(pMap != NULL);
                for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
                {
                        if (pMap[i].szDesc == NULL)
                                continue;

                        // reject data entry types
                        if (pMap[i].dwSizeData != 0)
                                continue;

                        if (pMap[i].dispid == dispID)
                        {
                                ATLASSERT(pMap[i].pclsidPropPage != NULL);
                                *pClsid = *(pMap[i].pclsidPropPage);
                                return S_OK;
                        }
                }
                *pClsid = CLSID_NULL;
                return E_INVALIDARG;
        }
        STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut,CADWORD *pCaCookiesOut)
        {
                dispID;
                ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n"));
                if (pCaStringsOut == NULL || pCaCookiesOut == NULL)
                        return E_POINTER;

                pCaStringsOut->cElems = 0;
                pCaStringsOut->pElems = NULL;
                pCaCookiesOut->cElems = 0;
                pCaCookiesOut->pElems = NULL;
                return S_OK;
        }
        STDMETHOD(GetPredefinedValue)(DISPID /*dispID*/, DWORD /*dwCookie*/, VARIANT* /*pVarOut*/)
        {
                ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue"));
        }
};

//////////////////////////////////////////////////////////////////////////////
// IViewObjectExImpl
template <class T>
class ATL_NO_VTABLE IViewObjectExImpl : public IViewObjectEx
{
public:
        STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
                                        DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
                                        LPCRECTL prcBounds, LPCRECTL prcWBounds,
                                        BOOL (__stdcall * /*pfnContinue*/)(DWORD_PTR dwContinue),
                                        DWORD_PTR /*dwContinue*/)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::Draw\n"));
                return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
                        prcBounds, prcWBounds);
        }

        STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, LOGPALETTE** /* ppColorSet */)
        {
                ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));
        }
        STDMETHOD(Freeze)(DWORD /* dwDrawAspect */, LONG /* lindex */, void* /* pvAspect */,DWORD* /* pdwFreeze */)
        {
                ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));
        }
        STDMETHOD(Unfreeze)(DWORD /* dwFreeze */)
        {
                ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));
        }
        STDMETHOD(SetAdvise)(DWORD /* aspects */, DWORD /* advf */, IAdviseSink* pAdvSink)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::SetAdvise\n"));
                pT->m_spAdviseSink = pAdvSink;
                return S_OK;
        }
        STDMETHOD(GetAdvise)(DWORD* /* pAspects */, DWORD* /* pAdvf */, IAdviseSink** ppAdvSink)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetAdvise\n"));
                if (ppAdvSink != NULL)
                {
                        *ppAdvSink = pT->m_spAdviseSink;
                        if (pT->m_spAdviseSink)
                                pT->m_spAdviseSink.p->AddRef();
                }
                return S_OK;
        }

        // IViewObject2
        //
        STDMETHOD(GetExtent)(DWORD /* dwDrawAspect */, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetExtent\n"));
                *lpsizel = pT->m_sizeExtent;
                return S_OK;
        }

        // IViewObjectEx
        //
        STDMETHOD(GetRect)(DWORD /* dwAspect */, LPRECTL /* pRect */)
        {
                ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));
        }

        STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetViewStatus\n"));
                *pdwStatus = pT->_GetViewStatus();
                return S_OK;
        }
        STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG /* lCloseHint */, DWORD *pHitResult)
        {
                ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitPoint\n"));
                if (dwAspect == DVASPECT_CONTENT)
                {
                        *pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
                        return S_OK;
                }
                ATLTRACE2(atlTraceControls,2,_T("Wrong DVASPECT\n"));
                return E_FAIL;
        }
        STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG /* lCloseHint */, DWORD* pHitResult)
        {
                ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitRect\n"));
                if (dwAspect == DVASPECT_CONTENT)
                {
                        RECT rc;
                        *pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
                        return S_OK;
                }
                ATLTRACE2(atlTraceControls,2,_T("Wrong DVASPECT\n"));
                return E_FAIL;
        }
        STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, DVEXTENTINFO* pExtentInfo , LPSIZEL psizel)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetNaturalExtent\n"));
                HRESULT hRes = E_FAIL;
                if (pExtentInfo == NULL || psizel == NULL)
                        hRes = E_POINTER;
                else if (dwAspect == DVASPECT_CONTENT)
                {
                        if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)
                        {
                                *psizel = pT->m_sizeNatural;
                                hRes = S_OK;
                        }
                }
                return hRes;
        }

public:
};

//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowlessImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl : public IOleInPlaceObjectWindowless
{
public:
        // IOleWindow
        //

        // Change IOleInPlaceActiveObject::GetWindow as well
        STDMETHOD(GetWindow)(HWND* phwnd)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
                T* pT = static_cast<T*>(this);
                HRESULT hRes = E_POINTER;

                if (pT->m_bWasOnceWindowless)
                        return E_FAIL;

                if (phwnd != NULL)
                {
                        *phwnd = pT->m_hWnd;
                        hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
                }
                return hRes;
        }
        STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
        {
                ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));
        }

        // IOleInPlaceObject
        //
        STDMETHOD(InPlaceDeactivate)(void)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
                return pT->IOleInPlaceObject_InPlaceDeactivate();
        }
        STDMETHOD(UIDeactivate)(void)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
                return pT->IOleInPlaceObject_UIDeactivate();
        }
        STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip)
        {
                T* pT = static_cast<T*>(this);
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
                return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);
        }
        STDMETHOD(ReactivateAndUndo)(void)
        {
                ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));
        }

        // IOleInPlaceObjectWindowless
        //
        STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
                T* pT = static_cast<T*>(this);
                BOOL b = pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult);
                return b ? S_OK : S_FALSE;
        }

        STDMETHOD(GetDropTarget)(IDropTarget** /* ppDropTarget */)
        {
                ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));
        }
};


//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceActiveObjectImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl : public IOleInPlaceActiveObject
{
public:
        // IOleWindow
        //

        // Change IOleInPlaceObjectWindowless::GetWindow as well
        STDMETHOD(GetWindow)(HWND *phwnd)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
                T* pT = static_cast<T*>(this);
                HRESULT hRes = E_POINTER;

                if (pT->m_bWasOnceWindowless)
                        return E_FAIL;

                if (phwnd != NULL)
                {
                        *phwnd = pT->m_hWnd;
                        hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
                }
                return hRes;
        }
        STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
        {
                ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));
        }

        // IOleInPlaceActiveObject
        //
        STDMETHOD(TranslateAccelerator)(LPMSG pMsg)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
                T* pT = static_cast<T*>(this);
                HRESULT hRet = S_OK;
                if (pT->PreTranslateAccelerator(pMsg, hRet))
                        return hRet;
                CComPtr<IOleControlSite> spCtlSite;
                hRet = pT->InternalGetSite(IID_IOleControlSite, (void**)&spCtlSite);
                if (SUCCEEDED(hRet))
                {
                        if (spCtlSite != NULL)
                        {
                                DWORD dwKeyMod = 0;
                                if (::GetKeyState(VK_SHIFT) < 0)
                                        dwKeyMod += 1;        // KEYMOD_SHIFT
                                if (::GetKeyState(VK_CONTROL) < 0)
                                        dwKeyMod += 2;        // KEYMOD_CONTROL
                                if (::GetKeyState(VK_MENU) < 0)
                                        dwKeyMod += 4;        // KEYMOD_ALT
                                hRet = spCtlSite->TranslateAccelerator(pMsg, dwKeyMod);
                        }
                        else
                                hRet = S_FALSE;
                }
                return (hRet == S_OK) ? S_OK : S_FALSE;
        }
        STDMETHOD(OnFrameWindowActivate)(BOOL /* fActivate */)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
                return S_OK;
        }
        STDMETHOD(OnDocWindowActivate)(BOOL fActivate)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
                T* pT = static_cast<T*>(this);
                if (fActivate == FALSE)
                        pT->IOleInPlaceObject_UIDeactivate();
                return S_OK;
        }
        STDMETHOD(ResizeBorder)(LPCRECT /* prcBorder */, IOleInPlaceUIWindow* /* pUIWindow */, BOOL /* fFrameWindow */)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
                return S_OK;
        }
        STDMETHOD(EnableModeless)(BOOL /* fEnable */)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
                return S_OK;
        }
};

//////////////////////////////////////////////////////////////////////////////
// IPointerInactiveImpl
template <class T>
class ATL_NO_VTABLE IPointerInactiveImpl : public IPointerInactive
{
public:
        // IPointerInactive
        //
        STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy)
        {
                ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy"));
        }
        STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg)
        {
                ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove"));
        }
        STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
        {
                ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor"));
        }
};

//////////////////////////////////////////////////////////////////////////////
// IRunnableObjectImpl
template <class T>
class ATL_NO_VTABLE IRunnableObjectImpl : public IRunnableObject
{
public:
        // IRunnableObject
        //
        STDMETHOD(GetRunningClass)(LPCLSID lpClsid)
        {
                ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::GetRunningClass\n"));
                *lpClsid = GUID_NULL;
                return E_UNEXPECTED;
        }
        STDMETHOD(Run)(LPBINDCTX)
        {
                ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::Run\n"));
                return S_OK;
        }
        virtual BOOL STDMETHODCALLTYPE IsRunning()
        {
                ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::IsRunning\n"));
                return TRUE;
        }
        STDMETHOD(LockRunning)(BOOL /*fLock*/, BOOL /*fLastUnlockCloses*/)
        {
                ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::LockRunning\n"));
                return S_OK;
        }
        STDMETHOD(SetContainedObject)(BOOL /*fContained*/)
        {
                ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::SetContainedObject\n"));
                return S_OK;
        }
};


//////////////////////////////////////////////////////////////////////////////
// IDataObjectImpl
template <class T>
class ATL_NO_VTABLE IDataObjectImpl : public IDataObject
{
public:
        STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
        {
                ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::GetData\n"));
                T* pT = (T*) this;
                return pT->IDataObject_GetData(pformatetcIn, pmedium);
        }
        STDMETHOD(GetDataHere)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */)
        {
                ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));
        }
        STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
        {
                ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));
        }
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
        {
                ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));
        }
        STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
        {
                ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));
        }
        STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
        {
                ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));
        }
        STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
                DWORD *pdwConnection)
        {
                ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::DAdvise\n"));
                T* pT = static_cast<T*>(this);
                HRESULT hr = S_OK;
                if (pT->m_spDataAdviseHolder == NULL)
                        hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

                if (hr == S_OK)
                        hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

                return hr;
        }
        STDMETHOD(DUnadvise)(DWORD dwConnection)
        {
                ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::DUnadvise\n"));
                T* pT = static_cast<T*>(this);
                HRESULT hr = S_OK;
                if (pT->m_spDataAdviseHolder == NULL)
                        hr = OLE_E_NOCONNECTION;
                else
                        hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);
                return hr;
        }
        STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
        {
                ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::EnumDAdvise\n"));
                T* pT = static_cast<T*>(this);
                HRESULT hr = E_FAIL;
                if (pT->m_spDataAdviseHolder != NULL)
                        hr = pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
                return hr;
        }
};

//////////////////////////////////////////////////////////////////////////////
// IPropertyNotifySinkCP
template <class T, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IPropertyNotifySinkCP :
        public IConnectionPointImpl<T, &IID_IPropertyNotifySink, CDV>
{
public:
        typedef CFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//
// 2nd template parameter is the supported safety e.g.
// INTERFACESAFE_FOR_UNTRUSTED_CALLER - safe for scripting
// INTERFACESAFE_FOR_UNTRUSTED_DATA   - safe for initialization from data

template <class T, DWORD dwSupportedSafety>
class ATL_NO_VTABLE IObjectSafetyImpl : public IObjectSafety
{
public:
        IObjectSafetyImpl()
        {
                m_dwCurrentSafety = 0;
        }

        STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
        {
                ATLTRACE2(atlTraceControls,2,_T("IObjectSafetyImpl2::GetInterfaceSafetyOptions\n"));
                T* pT = static_cast<T*>(this);
                if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
                        return E_POINTER;
                
                HRESULT hr;
                IUnknown* pUnk;
                // Check if we support this interface
                hr = pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk);
                if (SUCCEEDED(hr))
                {
                        // We support this interface so set the safety options accordingly
                        pUnk->Release();        // Release the interface we just acquired
                        *pdwSupportedOptions = dwSupportedSafety;
                        *pdwEnabledOptions   = m_dwCurrentSafety;
                }
                else
                {
                        // We don't support this interface
                        *pdwSupportedOptions = 0;
                        *pdwEnabledOptions   = 0;
                }
                return hr;
        }
        STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
        {
                ATLTRACE2(atlTraceControls,2,_T("IObjectSafetyImpl2::SetInterfaceSafetyOptions\n"));
                T* pT = static_cast<T*>(this);
                IUnknown* pUnk;
                
                // Check if we support the interface and return E_NOINTEFACE if we don't
                if (FAILED(pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk)))
                        return E_NOINTERFACE;
                pUnk->Release();        // Release the interface we just acquired
                
                // If we are asked to set options we don't support then fail
                if (dwOptionSetMask & ~dwSupportedSafety)
                        return E_FAIL;

                // Set the safety options we have been asked to
                m_dwCurrentSafety = m_dwCurrentSafety  & ~dwOptionSetMask | dwEnabledOptions;
                return S_OK;
        }
        DWORD m_dwCurrentSafety;
};

template <class T>
class ATL_NO_VTABLE IOleLinkImpl : public IOleLink
{
        STDMETHOD(SetUpdateOptions)(DWORD /* dwUpdateOpt */)
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions"));
        }

        STDMETHOD(GetUpdateOptions)(DWORD* /* pdwUpdateOpt */)
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions"));
        }

        STDMETHOD(SetSourceMoniker)(IMoniker* /* pmk */, REFCLSID /* rclsid */)
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker"));
        }

        STDMETHOD(GetSourceMoniker)(IMoniker** /* ppmk */)
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker"));
        };

        STDMETHOD(SetSourceDisplayName)(LPCOLESTR /* pszStatusText */)
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName"));
        }

        STDMETHOD(GetSourceDisplayName)(LPOLESTR *ppszDisplayName)
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleLink::GetSourceDisplayName\n"));
                *ppszDisplayName = NULL;
                return E_FAIL;
        }

        STDMETHOD(BindToSource)(DWORD /* bindflags */, IBindCtx* /* pbc */)
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n"));
        };

        STDMETHOD(BindIfRunning)()
        {
                ATLTRACE2(atlTraceControls,2,_T("IOleLinkImpl::BindIfRunning\n"));
                return S_OK;
        };

        STDMETHOD(GetBoundSource)(IUnknown** /* ppunk */)
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource"));
        };

        STDMETHOD(UnbindSource)()
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource"));
        };

        STDMETHOD(Update)(IBindCtx* /* pbc */)
        {
                ATLTRACENOTIMPL(_T("IOleLinkImpl::Update"));
        };
};

template <class T>
class ATL_NO_VTABLE CBindStatusCallback :
        public CComObjectRootEx<typename T::_ThreadModel::ThreadModelNoCS>,
        public IBindStatusCallback
{
        typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

public:

BEGIN_COM_MAP(CBindStatusCallback<T>)
        COM_INTERFACE_ENTRY(IBindStatusCallback)
END_COM_MAP()

        CBindStatusCallback()
        {
                m_pT = NULL;
                m_pFunc = NULL;
        }
        ~CBindStatusCallback()
        {
                ATLTRACE2(atlTraceControls,2,_T("~CBindStatusCallback\n"));
        }

        STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
        {
                ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnStartBinding\n"));
                m_spBinding = pBinding;
                return S_OK;
        }

        STDMETHOD(GetPriority)(LONG *pnPriority)
        {
                ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::GetPriority"));
                HRESULT hr = S_OK;
                if (pnPriority)
                        *pnPriority = THREAD_PRIORITY_NORMAL;
                else
                        hr = E_INVALIDARG;
                return S_OK;
        }

        STDMETHOD(OnLowResource)(DWORD reserved)
        {
                ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnLowResource"));
                return S_OK;
        }

        STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
        {
                ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnProgress"));
                return S_OK;
        }

        STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
        {
                ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnStopBinding\n"));
                (m_pT->*m_pFunc)(this, NULL, 0);
                m_spBinding.Release();
                m_spBindCtx.Release();
                m_spMoniker.Release();
                return S_OK;
        }

        STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
        {
                ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::GetBindInfo\n"));

                if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
                        return E_INVALIDARG;

                *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
                        BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;

                ULONG cbSize = pbindInfo->cbSize;                // remember incoming cbSize
                memset(pbindInfo, 0, cbSize);                        // zero out structure
                pbindInfo->cbSize = cbSize;                                // restore cbSize
                pbindInfo->dwBindVerb = BINDVERB_GET;        // set verb
                return S_OK;
        }

        STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
        {
                ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnDataAvailable\n"));
                HRESULT hr = S_OK;

                // Get the Stream passed
                if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
                {
                        if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
                                m_spStream = pstgmed->pstm;
                }

                DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
                DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

                // If there is some data to be read then go ahead and read them
                if (m_spStream)
                {
                        if (dwRead > 0)
                        {
                                BYTE* pBytes = NULL;
                                ATLTRY(pBytes = new BYTE[dwRead + 1]);
                                if (pBytes == NULL)
                                        return E_OUTOFMEMORY;
                                hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
                                if (SUCCEEDED(hr))
                                {
                                        pBytes[dwActuallyRead] = 0;
                                        if (dwActuallyRead>0)
                                        {
                                                (m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
                                                m_dwTotalRead += dwActuallyRead;
                                        }
                                }
                                delete[] pBytes;
                        }
                }

                if (BSCF_LASTDATANOTIFICATION & grfBSCF)
                        m_spStream.Release();
                return hr;
        }

        STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
        {
                ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnObjectAvailable"));
                return S_OK;
        }

        HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
        {
                m_dwTotalRead = 0;
                m_dwAvailableToRead = 0;
                HRESULT hr = S_OK;
                CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
                CComPtr<IBindHost>        spBindHost;
                CComPtr<IStream>        spStream;
                if (spServiceProvider)
                        spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

                if (spBindHost == NULL)
                {
                        if (bRelative)
                                return E_NOINTERFACE;  // relative asked for, but no IBindHost
                        hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
                        if (SUCCEEDED(hr))
                                hr = CreateBindCtx(0, &m_spBindCtx);

                        if (SUCCEEDED(hr))
                                hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);
                        else
                                m_spMoniker.Release();

                        if (SUCCEEDED(hr))
                                hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
                }
                else
                {
                        hr = CreateBindCtx(0, &m_spBindCtx);
                        if (SUCCEEDED(hr))
                                hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);

                        if (SUCCEEDED(hr))
                        {
                                if (bRelative)
                                        hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
                                else
                                        hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
                        }

                        if (SUCCEEDED(hr))
                        {
                                hr = spBindHost->MonikerBindToStorage(m_spMoniker, m_spBindCtx, static_cast<IBindStatusCallback*>(this), IID_IStream, (void**)&spStream);
                                ATLTRACE2(atlTraceControls,2,_T("Bound"));
                        }
                }
                return hr;
        }

        HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
        {
                m_pT = pT;
                m_pFunc = pFunc;
                return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
        }

        static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
        {
                CComObject<CBindStatusCallback<T> > *pbsc;
                HRESULT hRes = CComObject<CBindStatusCallback<T> >::CreateInstance(&pbsc);
                if (FAILED(hRes))
                        return hRes;
                return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative);
        }

        CComPtr<IMoniker> m_spMoniker;
        CComPtr<IBindCtx> m_spBindCtx;
        CComPtr<IBinding> m_spBinding;
        CComPtr<IStream> m_spStream;
        T* m_pT;
        ATL_PDATAAVAILABLE m_pFunc;
        DWORD m_dwTotalRead;
        DWORD m_dwAvailableToRead;
};

#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \
        HRESULT STDMETHODCALLTYPE put_##fname(type pname) \
        { \
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
                T* pT = (T*) this; \
                if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
                        return S_FALSE; \
                pT->m_##pname = pname; \
                pT->m_bRequiresSave = TRUE; \
                pT->FireOnChanged(dispid); \
                pT->FireViewChange(); \
                pT->SendOnDataChange(NULL); \
                return S_OK; \
        } \
        HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \
        { \
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
                T* pT = (T*) this; \
                *p##pname = pT->m_##pname; \
                return S_OK; \
        }

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
        HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \
        { \
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
                T* pT = (T*) this; \
                if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
                        return S_FALSE; \
                pT->m_##pname = pname; \
                pT->m_bRequiresSave = TRUE; \
                pT->FireOnChanged(dispid); \
                pT->FireViewChange(); \
                pT->SendOnDataChange(NULL); \
                return S_OK; \
        } \
        HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \
        { \
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
                T* pT = (T*) this; \
                *p##pname = pT->m_##pname ? VARIANT_TRUE : VARIANT_FALSE; \
                return S_OK; \
        }

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
        HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \
        { \
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
                T* pT = (T*) this; \
                if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
                        return S_FALSE; \
                if (*(&(pT->m_##pname)) != NULL) \
                        SysFreeString(*(&(pT->m_##pname))); \
                *(&(pT->m_##pname)) = SysAllocString(pname); \
                pT->m_bRequiresSave = TRUE; \
                pT->FireOnChanged(dispid); \
                pT->FireViewChange(); \
                pT->SendOnDataChange(NULL); \
                return S_OK; \
        } \
        HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \
        { \
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
                T* pT = (T*) this; \
                *p##pname = SysAllocString(pT->m_##pname); \
                return S_OK; \
        }


template < class T, class InterfaceName, const IID* piid, const GUID* plibid>
class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl< InterfaceName, piid, plibid >
{
public:
        // Font
        HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFont)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Font\n"));
                T* pT = (T*) this;
                if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
                        return S_FALSE;
                pT->m_pFont = 0;
                if (pFont)
                {
                        CComQIPtr<IFont, &IID_IFont> p(pFont);
                        if (p)
                        {
                                CComPtr<IFont> pFont;
                                p->Clone(&pFont);
                                if (pFont)
                                        pFont->QueryInterface(IID_IFontDisp, (void**) &pT->m_pFont);
                        }
                }
                pT->m_bRequiresSave = TRUE;
                pT->FireOnChanged(DISPID_FONT);
                pT->FireViewChange();
                pT->SendOnDataChange(NULL);
                return S_OK;
        }
        HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_Font\n"));
                T* pT = (T*) this;
                if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
                        return S_FALSE;
                pT->m_pFont = pFont;
                pT->m_bRequiresSave = TRUE;
                pT->FireOnChanged(DISPID_FONT);
                pT->FireViewChange();
                pT->SendOnDataChange(NULL);
                return S_OK;
        }
        HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Font\n"));
                T* pT = (T*) this;
                *ppFont = pT->m_pFont;
                if (*ppFont != NULL)
                        (*ppFont)->AddRef();
                return S_OK;
        }
        // Picture
        HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Picture\n"));
                T* pT = (T*) this;
                if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
                        return S_FALSE;
                pT->m_pPicture = 0;
                if (pPicture)
                {
                        CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
                        if (p)
                        {
                                ULARGE_INTEGER l;
                                p->GetSizeMax(&l);
                                HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
                                if (hGlob)
                                {
                                        CComPtr<IStream> spStream;
                                        CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
                                        if (spStream)
                                        {
                                                if (SUCCEEDED(p->Save(spStream, FALSE)))
                                                {
                                                        LARGE_INTEGER l;
                                                        l.QuadPart = 0;
                                                        spStream->Seek(l, STREAM_SEEK_SET, NULL);
                                                        OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pPicture);
                                                }
                                                spStream.Release();
                                        }
                                        GlobalFree(hGlob);
                                }
                        }
                }
                pT->m_bRequiresSave = TRUE;
                pT->FireOnChanged(DISPID_PICTURE);
                pT->FireViewChange();
                pT->SendOnDataChange(NULL);
                return S_OK;
        }
        HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_Picture\n"));
                T* pT = (T*) this;
                if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
                        return S_FALSE;
                pT->m_pPicture = pPicture;
                pT->m_bRequiresSave = TRUE;
                pT->FireOnChanged(DISPID_PICTURE);
                pT->FireViewChange();
                pT->SendOnDataChange(NULL);
                return S_OK;
        }
        HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Picture\n"));
                T* pT = (T*) this;
                *ppPicture = pT->m_pPicture;
                if (*ppPicture != NULL)
                        (*ppPicture)->AddRef();
                return S_OK;
        }
        // MouseIcon
        HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_MouseIcon\n"));
                T* pT = (T*) this;
                if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
                        return S_FALSE;
                pT->m_pMouseIcon = 0;
                if (pPicture)
                {
                        CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
                        if (p)
                        {
                                ULARGE_INTEGER l;
                                p->GetSizeMax(&l);
                                HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
                                if (hGlob)
                                {
                                        CComPtr<IStream> spStream;
                                        CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
                                        if (spStream)
                                        {
                                                if (SUCCEEDED(p->Save(spStream, FALSE)))
                                                {
                                                        LARGE_INTEGER l;
                                                        l.QuadPart = 0;
                                                        spStream->Seek(l, STREAM_SEEK_SET, NULL);
                                                        OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pMouseIcon);
                                                }
                                                spStream.Release();
                                        }
                                        GlobalFree(hGlob);
                                }
                        }
                }
                pT->m_bRequiresSave = TRUE;
                pT->FireOnChanged(DISPID_MOUSEICON);
                pT->FireViewChange();
                pT->SendOnDataChange(NULL);
                return S_OK;
        }
        HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_MouseIcon\n"));
                T* pT = (T*) this;
                if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
                        return S_FALSE;
                pT->m_pMouseIcon = pPicture;
                pT->m_bRequiresSave = TRUE;
                pT->FireOnChanged(DISPID_MOUSEICON);
                pT->FireViewChange();
                pT->SendOnDataChange(NULL);
                return S_OK;
        }
        HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_MouseIcon\n"));
                T* pT = (T*) this;
                *ppPicture = pT->m_pMouseIcon;
                if (*ppPicture != NULL)
                        (*ppPicture)->AddRef();
                return S_OK;
        }
        IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
        IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
        IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
        IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
        IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
        IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
        IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
        IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
        IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
        IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
        IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
        HRESULT STDMETHODCALLTYPE put_Window(LONG_PTR /*hWnd*/)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Window\n"));
                return E_FAIL;
        }
        HRESULT STDMETHODCALLTYPE get_Window(LONG_PTR* phWnd)
        {
                ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Window\n"));
                T* pT = (T*) this;
                *phWnd = (LONG_PTR)pT->m_hWnd;
                return S_OK;
        }
        IMPLEMENT_STOCKPROP(LONG, BackStyle, nBackStyle, DISPID_BACKSTYLE)
        IMPLEMENT_STOCKPROP(LONG, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
        IMPLEMENT_STOCKPROP(LONG, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
        IMPLEMENT_STOCKPROP(LONG, DrawMode, nDrawMode, DISPID_DRAWMODE)
        IMPLEMENT_STOCKPROP(LONG, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
        IMPLEMENT_STOCKPROP(LONG, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
        IMPLEMENT_STOCKPROP(LONG, FillStyle, nFillStyle, DISPID_FILLSTYLE)
        IMPLEMENT_STOCKPROP(SHORT, Appearance, nAppearance, DISPID_APPEARANCE)
        IMPLEMENT_STOCKPROP(LONG, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
        IMPLEMENT_STOCKPROP(LONG, ReadyState, nReadyState, DISPID_READYSTATE)
};

#pragma pack(pop)

}; //namespace ATL

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLCTL_IMPL
#endif
#endif

#endif // __ATLCTL_H__

#ifdef _ATLCTL_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif


//All exports go here


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time
#undef _ATLCTL_IMPL

#endif // _ATLCTL_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atldbcli.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// ATLDBCLI.H : ATL consumer code for OLEDB

#ifndef __ATLDBCLI_H_
#define __ATLDBCLI_H_

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef _ATLBASE_H
#include <atlbase.h>
#endif

#ifndef __oledb_h__
#include <oledb.h>
#endif // __oledb_h__

#include <msdaguid.h>
#include <msdasc.h>

namespace ATL
{

#define DEFINE_OLEDB_TYPE_FUNCTION(ctype, oledbtype) \
        inline DBTYPE _GetOleDBType(ctype&) \
        { \
                return oledbtype; \
        }
        inline DBTYPE _GetOleDBType(BYTE[])
        {
                return DBTYPE_BYTES;
        }
        inline DBTYPE _GetOleDBType(CHAR[])
        {
                return DBTYPE_STR;
        }
        inline DBTYPE _GetOleDBType(WCHAR[])
        {
                return DBTYPE_WSTR;
        }

        DEFINE_OLEDB_TYPE_FUNCTION(signed char      ,DBTYPE_I1)
        DEFINE_OLEDB_TYPE_FUNCTION(SHORT            ,DBTYPE_I2)     // DBTYPE_BOOL
        DEFINE_OLEDB_TYPE_FUNCTION(int              ,DBTYPE_I4)
        DEFINE_OLEDB_TYPE_FUNCTION(LONG             ,DBTYPE_I4)     // DBTYPE_ERROR (SCODE)
        DEFINE_OLEDB_TYPE_FUNCTION(LARGE_INTEGER    ,DBTYPE_I8)     // DBTYPE_CY
        DEFINE_OLEDB_TYPE_FUNCTION(BYTE             ,DBTYPE_UI1)
        DEFINE_OLEDB_TYPE_FUNCTION(unsigned short   ,DBTYPE_UI2)
        DEFINE_OLEDB_TYPE_FUNCTION(unsigned int     ,DBTYPE_UI4)
        DEFINE_OLEDB_TYPE_FUNCTION(unsigned long    ,DBTYPE_UI4)
        DEFINE_OLEDB_TYPE_FUNCTION(ULARGE_INTEGER   ,DBTYPE_UI8)
        DEFINE_OLEDB_TYPE_FUNCTION(float            ,DBTYPE_R4)
        DEFINE_OLEDB_TYPE_FUNCTION(double           ,DBTYPE_R8)     // DBTYPE_DATE
        DEFINE_OLEDB_TYPE_FUNCTION(DECIMAL          ,DBTYPE_DECIMAL)
        DEFINE_OLEDB_TYPE_FUNCTION(DB_NUMERIC       ,DBTYPE_NUMERIC)
        DEFINE_OLEDB_TYPE_FUNCTION(VARIANT          ,DBTYPE_VARIANT)
        DEFINE_OLEDB_TYPE_FUNCTION(IDispatch*       ,DBTYPE_IDISPATCH)
        DEFINE_OLEDB_TYPE_FUNCTION(IUnknown*        ,DBTYPE_IUNKNOWN)
        DEFINE_OLEDB_TYPE_FUNCTION(GUID             ,DBTYPE_GUID)
        DEFINE_OLEDB_TYPE_FUNCTION(SAFEARRAY*       ,DBTYPE_ARRAY)
        DEFINE_OLEDB_TYPE_FUNCTION(DBVECTOR         ,DBTYPE_VECTOR)
        DEFINE_OLEDB_TYPE_FUNCTION(DBDATE           ,DBTYPE_DBDATE)
        DEFINE_OLEDB_TYPE_FUNCTION(DBTIME           ,DBTYPE_DBTIME)
        DEFINE_OLEDB_TYPE_FUNCTION(DBTIMESTAMP      ,DBTYPE_DBTIMESTAMP)
         DEFINE_OLEDB_TYPE_FUNCTION(FILETIME                        ,DBTYPE_FILETIME)
        DEFINE_OLEDB_TYPE_FUNCTION(PROPVARIANT                ,DBTYPE_PROPVARIANT)
        DEFINE_OLEDB_TYPE_FUNCTION(DB_VARNUMERIC        ,DBTYPE_VARNUMERIC)
   
// Internal structure containing the accessor handle and a flag
// indicating whether the data for the accessor is automatically
// retrieved
struct _ATL_ACCESSOR_INFO
{
        HACCESSOR   hAccessor;
        bool        bAutoAccessor;
};

class _CNoOutputColumns
{
public:
        static bool HasOutputColumns()
        {
                return false;
        }
        static ULONG _GetNumAccessors()
        {
                return 0;
        }
        static HRESULT _GetBindEntries(ULONG*, DBBINDING*, ULONG, bool*, BYTE* pBuffer = NULL)
        {
                pBuffer;
                return E_FAIL;
        }
};

class _CNoParameters
{
public:
        static bool HasParameters()
        {
                return false;
        }
        static HRESULT _GetParamEntries(ULONG*, DBBINDING*, BYTE* pBuffer = NULL)
        {
                pBuffer;
                return E_FAIL;
        }
};

class _CNoCommand
{
public:
        static HRESULT GetDefaultCommand(LPCTSTR* /*ppszCommand*/)
        {
                return S_OK;
        }
};

typedef _CNoOutputColumns   _OutputColumnsClass;
typedef _CNoParameters      _ParamClass;
typedef _CNoCommand         _CommandClass;

#define BEGIN_ACCESSOR_MAP(x, num) \
        public: \
        typedef x _classtype; \
        typedef x _OutputColumnsClass; \
        static ULONG _GetNumAccessors() { return num; } \
        static bool HasOutputColumns() { return true; } \
        /* If pBindings == NULL means we only return the column number */ \
        /* If pBuffer != NULL then it points to the accessor buffer and */ \
        /* we release any appropriate memory e.g. BSTR's or interface pointers */ \
        inline static HRESULT _GetBindEntries(ULONG* pColumns, DBBINDING *pBinding, ULONG nAccessor, bool* pAuto, BYTE* pBuffer = NULL) \
        { \
                ATLASSERT(pColumns != NULL); \
                DBPARAMIO eParamIO = DBPARAMIO_NOTPARAM; \
                ULONG nColumns = 0; \
                pBuffer;

#define BEGIN_ACCESSOR(num, bAuto) \
        if (nAccessor == num) \
        { \
                if (pBinding != NULL) \
                        *pAuto = bAuto;

#define END_ACCESSOR() \
        } \
        else

#define END_ACCESSOR_MAP() \
                ; \
                *pColumns = nColumns; \
                return S_OK; \
        }

#define BEGIN_COLUMN_MAP(x) \
        BEGIN_ACCESSOR_MAP(x, 1) \
                BEGIN_ACCESSOR(0, true)

#define END_COLUMN_MAP() \
                END_ACCESSOR() \
        END_ACCESSOR_MAP()

#define offsetbuf(m) offsetof(_classtype, m)
#define _OLEDB_TYPE(data) _GetOleDBType(((_classtype*)0)->data)
#define _SIZE_TYPE(data) sizeof(((_classtype*)0)->data)

#define _COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, nPrecision, nScale, dataOffset, lengthOffset, statusOffset) \
        if (pBuffer != NULL) \
        { \
                CAccessorBase::FreeType(wType, pBuffer + dataOffset); \
        } \
        else if (pBinding != NULL) \
        { \
                CAccessorBase::Bind(pBinding, nOrdinal, wType, nLength, nPrecision, nScale, eParamIO, \
                        dataOffset, lengthOffset, statusOffset); \
                pBinding++; \
        } \
        nColumns++;

#define COLUMN_ENTRY_EX(nOrdinal, wType, nLength, nPrecision, nScale, data, length, status) \
        _COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

#define COLUMN_ENTRY_TYPE(nOrdinal, wType, data) \
        COLUMN_ENTRY_TYPE_SIZE(nOrdinal, wType, _SIZE_TYPE(data), data)

#define COLUMN_ENTRY_TYPE_SIZE(nOrdinal, wType, nLength, data) \
        _COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, 0, 0, offsetbuf(data), 0, 0)


// Standard macros where type and size is worked out
#define COLUMN_ENTRY(nOrdinal, data) \
        COLUMN_ENTRY_TYPE(nOrdinal, _OLEDB_TYPE(data), data)

#define COLUMN_ENTRY_LENGTH(nOrdinal, data, length) \
        _COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_ENTRY_STATUS(nOrdinal, data, status) \
        _COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_LENGTH_STATUS(nOrdinal, data, length, status) \
        _COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), offsetbuf(status))


// Follow macros are used if precision and scale need to be specified
#define COLUMN_ENTRY_PS(nOrdinal, nPrecision, nScale, data) \
        _COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

#define COLUMN_ENTRY_PS_LENGTH(nOrdinal, nPrecision, nScale, data, length) \
        _COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_ENTRY_PS_STATUS(nOrdinal, nPrecision, nScale, data, status) \
        _COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_PS_LENGTH_STATUS(nOrdinal, nPrecision, nScale, data, length, status) \
        _COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))


#define BOOKMARK_ENTRY(variable) \
        COLUMN_ENTRY_TYPE_SIZE(0, DBTYPE_BYTES, _SIZE_TYPE(variable##.m_rgBuffer), variable##.m_rgBuffer)

#define _BLOB_ENTRY_CODE(nOrdinal, IID, flags, dataOffset, statusOffset) \
        if (pBuffer != NULL) \
        { \
                CAccessorBase::FreeType(DBTYPE_IUNKNOWN, pBuffer + dataOffset); \
        } \
        else if (pBinding != NULL) \
        { \
                DBOBJECT* pObject = NULL; \
                ATLTRY(pObject = new DBOBJECT); \
                if (pObject == NULL) \
                        return E_OUTOFMEMORY; \
                pObject->dwFlags = flags; \
                pObject->iid     = IID; \
                CAccessorBase::Bind(pBinding, nOrdinal, DBTYPE_IUNKNOWN, sizeof(IUnknown*), 0, 0, eParamIO, \
                        dataOffset, 0, statusOffset, pObject); \
                pBinding++; \
        } \
        nColumns++;

#define BLOB_ENTRY(nOrdinal, IID, flags, data) \
        _BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), 0);

#define BLOB_ENTRY_STATUS(nOrdinal, IID, flags, data, status) \
        _BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), offsetbuf(status));

#define BEGIN_PARAM_MAP(x) \
        public: \
        typedef x _classtype; \
        typedef x _ParamClass; \
        static bool HasParameters() { return true; } \
        static HRESULT _GetParamEntries(ULONG* pColumns, DBBINDING *pBinding, BYTE* pBuffer = NULL) \
        { \
                ATLASSERT(pColumns != NULL); \
                DBPARAMIO eParamIO = DBPARAMIO_INPUT; \
                int nColumns = 0; \
                pBuffer;

#define END_PARAM_MAP() \
                *pColumns = nColumns; \
                return S_OK; \
        }

#define SET_PARAM_TYPE(type) \
        eParamIO = type;

#define DEFINE_COMMAND(x, szCommand) \
        typedef x _CommandClass; \
        static HRESULT GetDefaultCommand(LPCTSTR* ppszCommand) \
        { \
                *ppszCommand = szCommand; \
                return S_OK; \
        }


///////////////////////////////////////////////////////////////////////////
// class CDBErrorInfo

class CDBErrorInfo
{
public:
        // Use to get the number of error record when you want to explicitly check that
        // the passed interface set the error information
        HRESULT GetErrorRecords(IUnknown* pUnk, const IID& iid, ULONG* pcRecords)
        {
                CComPtr<ISupportErrorInfo> spSupportErrorInfo;
                HRESULT hr = pUnk->QueryInterface(&spSupportErrorInfo);
                if (FAILED(hr))
                        return hr;

                hr = spSupportErrorInfo->InterfaceSupportsErrorInfo(iid);
                if (FAILED(hr))
                        return hr;

                return GetErrorRecords(pcRecords);
        }
        // Use to get the number of error records
        HRESULT GetErrorRecords(ULONG* pcRecords)
        {
                ATLASSERT(pcRecords != NULL);
                HRESULT hr;
                m_spErrorInfo.Release();
                m_spErrorRecords.Release();
                hr = ::GetErrorInfo(0, &m_spErrorInfo);
                if (hr == S_FALSE)
                        return E_FAIL;

                hr = m_spErrorInfo->QueryInterface(IID_IErrorRecords, (void**)&m_spErrorRecords);
                if (FAILED(hr))
                {
                        // Well we got the IErrorInfo so we'll just treat that as
                        // the one record
                        *pcRecords = 1;
                        return S_OK;
                }

                return m_spErrorRecords->GetRecordCount(pcRecords);
        }
        // Get the error information for the passed record number. GetErrorRecords must
        // be called before this function is called.
        HRESULT GetAllErrorInfo(ULONG ulRecordNum, LCID lcid, BSTR* pbstrDescription,
                BSTR* pbstrSource = NULL, GUID* pguid = NULL, DWORD* pdwHelpContext = NULL,
                BSTR* pbstrHelpFile = NULL) const
        {
                CComPtr<IErrorInfo> spErrorInfo;

                // If we have the IErrorRecords interface pointer then use it, otherwise
                // we'll just default to the IErrorInfo we have already retrieved in the call
                // to GetErrorRecords
                if (m_spErrorRecords != NULL)
                {
                        HRESULT hr = m_spErrorRecords->GetErrorInfo(ulRecordNum, lcid, &spErrorInfo);
                        if (FAILED(hr))
                                return hr;
                }
                else
                {
                        ATLASSERT(m_spErrorInfo != NULL);
                        spErrorInfo = m_spErrorInfo;
                }

                if (pbstrDescription != NULL)
                        spErrorInfo->GetDescription(pbstrDescription);

                if (pguid != NULL)
                        spErrorInfo->GetGUID(pguid);

                if (pdwHelpContext != NULL)
                        spErrorInfo->GetHelpContext(pdwHelpContext);

                if (pbstrHelpFile != NULL)
                        spErrorInfo->GetHelpFile(pbstrHelpFile);

                if (pbstrSource != NULL)
                        spErrorInfo->GetSource(pbstrSource);

                return S_OK;
        }
        // Get the error information for the passed record number
        HRESULT GetBasicErrorInfo(ULONG ulRecordNum, ERRORINFO* pErrorInfo) const
        {
                return m_spErrorRecords->GetBasicErrorInfo(ulRecordNum, pErrorInfo);
        }
        // Get the custom error object for the passed record number
        HRESULT GetCustomErrorObject(ULONG ulRecordNum, REFIID riid, IUnknown** ppObject) const
        {
                return m_spErrorRecords->GetCustomErrorObject(ulRecordNum, riid, ppObject);
        }
        // Get the IErrorInfo interface for the passed record number
        HRESULT GetErrorInfo(ULONG ulRecordNum, LCID lcid, IErrorInfo** ppErrorInfo) const
        {
                return m_spErrorRecords->GetErrorInfo(ulRecordNum, lcid, ppErrorInfo);
        }
        // Get the error parameters for the passed record number
        HRESULT GetErrorParameters(ULONG ulRecordNum, DISPPARAMS* pdispparams) const
        {
                return m_spErrorRecords->GetErrorParameters(ulRecordNum, pdispparams);
        }

// Implementation
        CComPtr<IErrorInfo>     m_spErrorInfo;
        CComPtr<IErrorRecords>  m_spErrorRecords;
};

#ifdef _DEBUG
inline void AtlTraceErrorRecords(HRESULT hrErr = S_OK)
{
        CDBErrorInfo ErrorInfo;
        ULONG        cRecords;
        HRESULT      hr;
        ULONG        i;
        CComBSTR     bstrDesc, bstrHelpFile, bstrSource;
        GUID         guid;
        DWORD        dwHelpContext;
        WCHAR        wszGuid[40];
        USES_CONVERSION;

        // If the user passed in an HRESULT then trace it
        if (hrErr != S_OK)
                ATLTRACE2(atlTraceDBClient, 0, _T("OLE DB Error Record dump for hr = 0x%x\n"), hrErr);

        LCID lcLocale = GetSystemDefaultLCID();

        hr = ErrorInfo.GetErrorRecords(&cRecords);
        if (FAILED(hr) && ErrorInfo.m_spErrorInfo == NULL)
        {
                ATLTRACE2(atlTraceDBClient, 0, _T("No OLE DB Error Information found: hr = 0x%x\n"), hr);
        }
        else
        {
                for (i = 0; i < cRecords; i++)
                {
                        hr = ErrorInfo.GetAllErrorInfo(i, lcLocale, &bstrDesc, &bstrSource, &guid,
                                                                                &dwHelpContext, &bstrHelpFile);
                        if (FAILED(hr))
                        {
                                ATLTRACE2(atlTraceDBClient, 0,
                                        _T("OLE DB Error Record dump retrieval failed: hr = 0x%x\n"), hr);
                                return;
                        }
                        StringFromGUID2(guid, wszGuid, sizeof(wszGuid) / sizeof(WCHAR));
                        ATLTRACE2(atlTraceDBClient, 0,
                                _T("Row #: %4d Source: \"%s\" Description: \"%s\" Help File: \"%s\" Help Context: %4d GUID: %s\n"),
                                i, OLE2T(bstrSource), OLE2T(bstrDesc), OLE2T(bstrHelpFile), dwHelpContext, OLE2T(wszGuid));
                        bstrSource.Empty();
                        bstrDesc.Empty();
                        bstrHelpFile.Empty();
                }
                ATLTRACE2(atlTraceDBClient, 0, _T("OLE DB Error Record dump end\n"));
        }
}
#else
inline void AtlTraceErrorRecords(HRESULT hrErr = S_OK)  { hrErr; }
#endif


///////////////////////////////////////////////////////////////////////////
// class CDBPropSet

class CDBPropSet : public tagDBPROPSET
{
public:
        CDBPropSet()
        {
                rgProperties    = NULL;
                cProperties     = 0;
        }
        CDBPropSet(const GUID& guid)
        {
                rgProperties    = NULL;
                cProperties     = 0;
                guidPropertySet = guid;
        }
        CDBPropSet(const CDBPropSet& propset)
        {
                InternalCopy(propset);
        }
        ~CDBPropSet()
        {
                for (ULONG i = 0; i < cProperties; i++)
                        VariantClear(&rgProperties[i].vValue);

                CoTaskMemFree(rgProperties);
        }
        CDBPropSet& operator=(CDBPropSet& propset)
        {
                this->~CDBPropSet();
                InternalCopy(propset);
                return *this;
        }
        // Set the GUID of the property set this class represents.
        // Use if you didn't pass the GUID to the constructor.
        void SetGUID(const GUID& guid)
        {
                guidPropertySet = guid;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, const VARIANT& var)
        {
                HRESULT hr;
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID   = dwPropertyID;
                hr = ::VariantCopy(&(rgProperties[cProperties].vValue), const_cast<VARIANT*>(&var));
                if (FAILED(hr))
                        return false;
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, LPCSTR szValue)
        {
                USES_CONVERSION;
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID   = dwPropertyID;
                rgProperties[cProperties].vValue.vt      = VT_BSTR;
                rgProperties[cProperties].vValue.bstrVal = SysAllocString(A2COLE(szValue));
                if (rgProperties[cProperties].vValue.bstrVal == NULL)
                        return false;
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, LPCWSTR szValue)
        {
                USES_CONVERSION;
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID   = dwPropertyID;
                rgProperties[cProperties].vValue.vt      = VT_BSTR;
                rgProperties[cProperties].vValue.bstrVal = SysAllocString(W2COLE(szValue));
                if (rgProperties[cProperties].vValue.bstrVal == NULL)
                        return false;
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, bool bValue)
        {
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID   = dwPropertyID;
                rgProperties[cProperties].vValue.vt      = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
                rgProperties[cProperties].vValue.boolVal = (bValue) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310)
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, BYTE bValue)
        {
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID  = dwPropertyID;
                rgProperties[cProperties].vValue.vt     = VT_UI1;
                rgProperties[cProperties].vValue.bVal   = bValue;
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, short nValue)
        {
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID  = dwPropertyID;
                rgProperties[cProperties].vValue.vt     = VT_I2;
                rgProperties[cProperties].vValue.iVal   = nValue;
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, long nValue)
        {
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID  = dwPropertyID;
                rgProperties[cProperties].vValue.vt     = VT_I4;
                rgProperties[cProperties].vValue.lVal   = nValue;
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, float fltValue)
        {
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID  = dwPropertyID;
                rgProperties[cProperties].vValue.vt     = VT_R4;
                rgProperties[cProperties].vValue.fltVal = fltValue;
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, double dblValue)
        {
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID  = dwPropertyID;
                rgProperties[cProperties].vValue.vt     = VT_R8;
                rgProperties[cProperties].vValue.dblVal = dblValue;
                cProperties++;
                return true;
        }
        // Add the passed property to the property set
        bool AddProperty(DWORD dwPropertyID, CY cyValue)
        {
                if (!Add())
                        return false;
                rgProperties[cProperties].dwPropertyID  = dwPropertyID;
                rgProperties[cProperties].vValue.vt     = VT_CY;
                rgProperties[cProperties].vValue.cyVal  = cyValue;
                cProperties++;
                return true;
        }
// Implementation
        // Create memory to add a new property
        bool Add()
        {
                DBPROP* p = (DBPROP*)CoTaskMemRealloc(rgProperties, (cProperties + 1) * sizeof(DBPROP));
                if (p != NULL)
                {
                        rgProperties = p;
                        rgProperties[cProperties].dwOptions = DBPROPOPTIONS_REQUIRED;
                        rgProperties[cProperties].colid     = DB_NULLID;
                        rgProperties[cProperties].vValue.vt = VT_EMPTY;
                        return true;
                }
                else
                        return false;
        }
        // Copies in the passed value now it this value been cleared
        void InternalCopy(const CDBPropSet& propset)
        {
                cProperties     = propset.cProperties;
                guidPropertySet = propset.guidPropertySet;
                rgProperties    = (DBPROP*)CoTaskMemAlloc(cProperties * sizeof(DBPROP));
                if (rgProperties != NULL)
                {
                        for (ULONG i = 0; i < cProperties; i++)
                        {
                                rgProperties[i].dwPropertyID = propset.rgProperties[i].dwPropertyID;
                                rgProperties[i].dwOptions    = DBPROPOPTIONS_REQUIRED;
                                rgProperties[i].colid        = DB_NULLID;
                                rgProperties[i].vValue.vt    = VT_EMPTY;
                                HRESULT hr = VariantCopy(&rgProperties[i].vValue, &propset.rgProperties[i].vValue);
                                ATLASSERT( SUCCEEDED(hr) );
                                if( FAILED(hr) )
                                        VariantInit( &rgProperties[i].vValue );
                        }
                }
                else
                {
                        // The memory allocation failed so set the count
                        // of properties to zero
                        cProperties = 0;
                }
        }
};


///////////////////////////////////////////////////////////////////////////
// class CDBPropIDSet

class CDBPropIDSet : public tagDBPROPIDSET
{
// Constructors and Destructors
public:
        CDBPropIDSet()
        {
                rgPropertyIDs   = NULL;
                cPropertyIDs    = 0;
        }
        CDBPropIDSet(const GUID& guid)
        {
                rgPropertyIDs   = NULL;
                cPropertyIDs    = 0;
                guidPropertySet = guid;
        }
        CDBPropIDSet(const CDBPropIDSet& propidset)
        {
                InternalCopy(propidset);
        }
        ~CDBPropIDSet()
        {
                if (rgPropertyIDs != NULL)
                        free(rgPropertyIDs);
        }
        CDBPropIDSet& operator=(CDBPropIDSet& propset)
        {
                this->~CDBPropIDSet();
                InternalCopy(propset);
                return *this;
        }
        // Set the GUID of the property ID set
        void SetGUID(const GUID& guid)
        {
                guidPropertySet = guid;
        }
        // Add a property ID to the set
        bool AddPropertyID(DBPROPID propid)
        {
                if (!Add())
                        return false;
                rgPropertyIDs[cPropertyIDs] = propid;
                cPropertyIDs++;
                return true;
        }
// Implementation
        bool Add()
        {
                DBPROPID* p = (DBPROPID*)realloc(rgPropertyIDs, (cPropertyIDs + 1) * sizeof(DBPROPID));
                if (p != NULL)
                        rgPropertyIDs = p;
                return (p != NULL) ? true : false;
        }
        void InternalCopy(const CDBPropIDSet& propidset)
        {
                cPropertyIDs    = propidset.cPropertyIDs;
                guidPropertySet = propidset.guidPropertySet;
                rgPropertyIDs   = (DBPROPID*)malloc(cPropertyIDs * sizeof(DBPROPID));
                if (rgPropertyIDs != NULL)
                {
                        for (ULONG i = 0; i < cPropertyIDs; i++)
                                rgPropertyIDs[i] = propidset.rgPropertyIDs[i];
                }
                else
                {
                        // The memory allocation failed so set the count
                        // of properties to zero
                        cPropertyIDs = 0;
                }
        }
};


///////////////////////////////////////////////////////////////////////////
// class CBookmarkBase

class ATL_NO_VTABLE CBookmarkBase
{
public:
        virtual ULONG_PTR GetSize() const = 0;
        virtual BYTE* GetBuffer() const = 0;
};


///////////////////////////////////////////////////////////////////////////
// class CBookmark

template <ULONG_PTR nSize = 0>
class CBookmark : public CBookmarkBase
{
public:
        virtual ULONG_PTR   GetSize() const { return nSize; }
        virtual BYTE*   GetBuffer() const { return (BYTE*)m_rgBuffer; }

// Implementation
        BYTE m_rgBuffer[nSize];
};


// Size of 0 means that the memory for the bookmark will be allocated
// at run time.
template <>
class CBookmark<0> : public CBookmarkBase
{
public:
        CBookmark()
        {
                m_nSize = 0;
                m_pBuffer = NULL;
        }
        CBookmark(ULONG_PTR nSize)
        {
                m_pBuffer = NULL;
                ATLTRY(m_pBuffer = new BYTE[(size_t)nSize]);  //REVIEW
                m_nSize = (m_pBuffer == NULL) ? 0 : nSize;
        }
        ~CBookmark()
        {
                delete [] m_pBuffer;
        }
        CBookmark& operator=(const CBookmark& bookmark)
        {
                SetBookmark(bookmark.GetSize(), bookmark.GetBuffer());
                return *this;
        }
        virtual ULONG_PTR GetSize() const { return m_nSize; }
        virtual BYTE* GetBuffer() const { return m_pBuffer; }
        // Sets the bookmark to the passed value
        HRESULT SetBookmark(ULONG_PTR nSize, BYTE* pBuffer)
        {
                ATLASSERT(pBuffer != NULL);
                delete [] m_pBuffer;
                m_pBuffer = NULL;
                ATLTRY(m_pBuffer = new BYTE[(size_t)nSize]);  //REVIEW
                if (m_pBuffer != NULL)
                {
                        memcpy(m_pBuffer, pBuffer, (size_t)nSize);  //REVIEW
                        m_nSize = nSize;
                        return S_OK;
                }
                else
                {
                        m_nSize = 0;
                        return E_OUTOFMEMORY;
                }
        }
        ULONG_PTR   m_nSize;
        BYTE*   m_pBuffer;
};


///////////////////////////////////////////////////////////////////////////
// class CAccessorBase

class CAccessorBase
{
public:
        CAccessorBase()
        {
                m_pAccessorInfo  = NULL;
                m_nAccessors     = 0;
                m_pBuffer        = NULL;
        }
        void Close()
        {
                // If Close is called then ReleaseAccessors must have been
                // called first
                ATLASSERT(m_nAccessors == 0);
                ATLASSERT(m_pAccessorInfo == NULL);
        }
        // Get the number of accessors that have been created
        ULONG GetNumAccessors() const { return m_nAccessors; }
        // Get the handle of the passed accessor (offset from 0)
        HACCESSOR GetHAccessor(ULONG nAccessor) const
        {
                ATLASSERT(nAccessor<m_nAccessors);
                return m_pAccessorInfo[nAccessor].hAccessor;
        };
        // Called during Close to release the accessor information
        HRESULT ReleaseAccessors(IUnknown* pUnk)
        {
                ATLASSERT(pUnk != NULL);
                HRESULT hr = S_OK;
                if (m_nAccessors > 0)
                {
                        CComPtr<IAccessor> spAccessor;
                        hr = pUnk->QueryInterface(IID_IAccessor, (void**)&spAccessor);
                        if (SUCCEEDED(hr))
                        {
                                ATLASSERT(m_pAccessorInfo != NULL);
                                for (ULONG i = 0; i < m_nAccessors; i++)
                                        spAccessor->ReleaseAccessor(m_pAccessorInfo[i].hAccessor, NULL);
                        }
                        m_nAccessors = 0;
                        delete [] m_pAccessorInfo;
                        m_pAccessorInfo = NULL;
                }
                return hr;
        }
        // Returns true or false depending upon whether data should be
        // automatically retrieved for the passed accessor.
        bool IsAutoAccessor(ULONG nAccessor) const
        {
                ATLASSERT(nAccessor < m_nAccessors);
                ATLASSERT(m_pAccessorInfo != NULL);
                return m_pAccessorInfo[nAccessor].bAutoAccessor;
        }

// Implementation
        // Used by the rowset class to find out where to place the data
        BYTE* GetBuffer() const
        {
                return m_pBuffer;
        }
        // Set the buffer that is used to retrieve the data
        void SetBuffer(BYTE* pBuffer)
        {
                m_pBuffer = pBuffer;
        }

        // Allocate internal memory for the passed number of accessors
        HRESULT AllocateAccessorMemory(int nAccessors)
        {
                // Can't be called twice without calling ReleaseAccessors first
                ATLASSERT(m_pAccessorInfo == NULL);
                m_nAccessors    = nAccessors;
                m_pAccessorInfo = NULL;
                ATLTRY(m_pAccessorInfo = new _ATL_ACCESSOR_INFO[nAccessors]);
                if (m_pAccessorInfo == NULL)
                        return E_OUTOFMEMORY;
                else
                        return S_OK;
        }
        // BindParameters will be overriden if parameters are used
        HRESULT BindParameters(HACCESSOR*, ICommand*, void**) { return S_OK; }

        // Create an accessor for the passed binding information. The created accessor is
        // returned through the pHAccessor parameter.
        static HRESULT BindEntries(DBBINDING* pBindings, DBCOUNTITEM nColumns, HACCESSOR* pHAccessor,
                ULONG_PTR nSize, IAccessor* pAccessor)
        {
                ATLASSERT(pBindings  != NULL);
                ATLASSERT(pHAccessor != NULL);
                ATLASSERT(pAccessor  != NULL);
                HRESULT hr;
                DBCOUNTITEM i;
                DWORD dwAccessorFlags = (pBindings->eParamIO == DBPARAMIO_NOTPARAM) ?
                        DBACCESSOR_ROWDATA : DBACCESSOR_PARAMETERDATA;

#ifdef _DEBUG
                // In debug builds we will retrieve the status flags and trace out
                // any errors that may occur.
                DBBINDSTATUS* pStatus = NULL;
                ATLTRY(pStatus = new DBBINDSTATUS[(size_t)nColumns]);  //REVIEW
                hr = pAccessor->CreateAccessor(dwAccessorFlags, nColumns,
                        pBindings, nSize, pHAccessor, pStatus);
                if (FAILED(hr) && pStatus != NULL)
                {
                        for (i=0; i<nColumns; i++)
                        {
                                if (pStatus[i] != DBBINDSTATUS_OK)
                                        ATLTRACE2(atlTraceDBClient, 0, _T("Binding entry %d failed. Status: %d\n"), i, pStatus[i]);
                        }
                }
                delete [] pStatus;
#else
                hr = pAccessor->CreateAccessor(dwAccessorFlags, nColumns,
                        pBindings, nSize, pHAccessor, NULL);
#endif
                for (i=0; i<nColumns; i++)
                        delete pBindings[i].pObject;

                return hr;
        }
        // Set up the binding structure pointed to by pBindings based upon
        // the other passed parameters.
        static void Bind(DBBINDING* pBinding, ULONG_PTR nOrdinal, DBTYPE wType,
                ULONG_PTR nLength, BYTE nPrecision, BYTE nScale, DBPARAMIO eParamIO,
                ULONG_PTR nDataOffset, ULONG_PTR nLengthOffset = NULL, ULONG_PTR nStatusOffset = NULL,
                DBOBJECT* pdbobject = NULL)
        {
                ATLASSERT(pBinding != NULL);

                // If we are getting a pointer to the data then let the provider
                // own the memory
                if (wType & DBTYPE_BYREF)
                        pBinding->dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
                else
                        pBinding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;

                pBinding->pObject   = pdbobject;

                pBinding->eParamIO      = eParamIO;
                pBinding->iOrdinal      = nOrdinal;
                pBinding->wType         = wType;
                pBinding->bPrecision    = nPrecision;
                pBinding->bScale        = nScale;
                pBinding->dwFlags       = 0;

                pBinding->obValue       = nDataOffset;
                pBinding->obLength      = 0;
                pBinding->obStatus      = 0;
                pBinding->pTypeInfo     = NULL;
                pBinding->pBindExt      = NULL;
                pBinding->cbMaxLen      = nLength;

                pBinding->dwPart = DBPART_VALUE;
                if (nLengthOffset != NULL)
                {
                        pBinding->dwPart |= DBPART_LENGTH;
                        pBinding->obLength = nLengthOffset;
                }
                if (nStatusOffset != NULL)
                {
                        pBinding->dwPart |= DBPART_STATUS;
                        pBinding->obStatus = nStatusOffset;
                }
        }

        // Free memory if appropriate
        static inline void FreeType(DBTYPE wType, BYTE* pValue, IRowset* pRowset = NULL)
        {
                switch (wType)
                {
                        case DBTYPE_BSTR:
                                SysFreeString(*((BSTR*)pValue));
                        break;
                        case DBTYPE_VARIANT:
                                VariantClear((VARIANT*)pValue);
                        break;
                        case DBTYPE_IUNKNOWN:
                        case DBTYPE_IDISPATCH:
                                (*(IUnknown**)pValue)->Release();
                        break;
                        case DBTYPE_ARRAY:
                                SafeArrayDestroy((SAFEARRAY*)pValue);
                        break;

                        case DBTYPE_HCHAPTER:
                                CComQIPtr<IChapteredRowset> spChapteredRowset = pRowset;
                                if (spChapteredRowset != NULL)
                                        spChapteredRowset->ReleaseChapter(*(HCHAPTER*)pValue, NULL);
                        break;
                }
                if ((wType & DBTYPE_VECTOR) && ~(wType & DBTYPE_BYREF))
                        CoTaskMemFree(((DBVECTOR*)pValue)->ptr);
        }

        _ATL_ACCESSOR_INFO* m_pAccessorInfo;
        ULONG               m_nAccessors;
        BYTE*               m_pBuffer;
};

///////////////////////////////////////////////////////////////////////////
// class CRowset

class CRowset
{
// Constructors and Destructors
public:
        CRowset()
        {
                m_pAccessor = NULL;
                m_hRow      = NULL;
        }
        CRowset(IRowset* pRowset)
        {
                m_spRowset  = pRowset;
                CRowset();
        }
        ~CRowset()
        {
                Close();
        }
        // Release any retrieved row handles and then release the rowset
        void Close()
        {
                if (m_spRowset != NULL)
                {
                        ReleaseRows();
                        m_spRowset.Release();
                        m_spRowsetChange.Release();
                }
        }
        // Addref the current row
        HRESULT AddRefRows()
        {
                ATLASSERT(m_spRowset != NULL);
                return m_spRowset->AddRefRows(1, &m_hRow, NULL, NULL);
        }
        // Release the current row
        HRESULT ReleaseRows()
        {
                ATLASSERT(m_spRowset != NULL);
                HRESULT hr = S_OK;

                if (m_hRow != NULL)
                {
                        hr = m_spRowset->ReleaseRows(1, &m_hRow, NULL, NULL, NULL);
                        m_hRow = NULL;
                }
                return hr;
        }
        // Compare two bookmarks with each other
        HRESULT Compare(const CBookmarkBase& bookmark1, const CBookmarkBase& bookmark2,
                DBCOMPARE* pComparison) const
        {
                ATLASSERT(m_spRowset != NULL);
                CComPtr<IRowsetLocate> spLocate;
                HRESULT hr = m_spRowset.QueryInterface(&spLocate);
                if (FAILED(hr))
                        return hr;

                return spLocate->Compare(NULL, bookmark1.GetSize(), bookmark1.GetBuffer(),
                        bookmark2.GetSize(), bookmark2.GetBuffer(), pComparison);
        }
        // Compare the passed hRow with the current row
        HRESULT IsSameRow(HROW hRow) const
        {
                ATLASSERT(m_spRowset != NULL);
                CComPtr<IRowsetIdentity> spRowsetIdentity;
                HRESULT hr = m_spRowset.QueryInterface(&spRowsetIdentity);
                if (FAILED(hr))
                        return hr;

                return spRowsetIdentity->IsSameRow(m_hRow, hRow);
        }
        // Move to the previous record
        HRESULT MovePrev()
        {
                return MoveNext(-2, true);
        }
        // Move to the next record
        HRESULT MoveNext()
        {
                return MoveNext(0, true);
        }
        // Move lSkip records forward or backward
        HRESULT MoveNext(LONG lSkip, bool bForward)
        {
                HRESULT hr;
                DBCOUNTITEM ulRowsFetched = 0;

                // Check the data was opened successfully and the accessor
                // has been set.
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_pAccessor != NULL);

                // Release a row if one is already around
                ReleaseRows();

                // Get the row handle
                HROW* phRow = &m_hRow;
                hr = m_spRowset->GetNextRows(NULL, lSkip, (bForward) ? 1 : -1, &ulRowsFetched, &phRow);
                if (hr != S_OK)
                        return hr;

                // Get the data
                hr = GetData();
                if (FAILED(hr))
                {
                        ATLTRACE2(atlTraceDBClient, 0, _T("GetData failed - HRESULT = 0x%X\n"),hr);
                        ReleaseRows();
                }
                return hr;
        }
        // Move to the first record
        HRESULT MoveFirst()
        {
                HRESULT hr;

                // Check the data was opened successfully and the accessor
                // has been set.
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_pAccessor != NULL);

                // Release a row if one is already around
                ReleaseRows();

                hr = m_spRowset->RestartPosition(NULL);
                if (FAILED(hr))
                        return hr;

                // Get the data
                return MoveNext();
        }
        // Move to the last record
        HRESULT MoveLast()
        {
                // Check the data was opened successfully and the accessor
                // has been set.
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_pAccessor != NULL);

                // Release a row if one is already around
                ReleaseRows();

                HRESULT hr;
                DBCOUNTITEM ulRowsFetched = 0;
                HROW* phRow = &m_hRow;
                // Restart the rowset position and then move backwards
                m_spRowset->RestartPosition(NULL);
                hr = m_spRowset->GetNextRows(NULL, -1, 1, &ulRowsFetched, &phRow);
                if (hr != S_OK)
                        return hr;

                // Get the data
                hr = GetData();
                if (FAILED(hr))
                {
                        ATLTRACE2(atlTraceDBClient, 0, _T("GetData from MoveLast failed - HRESULT = 0x%X\n"),hr);
                        ReleaseRows();
                }

                return S_OK;
        }
        // Move to the passed bookmark
        HRESULT MoveToBookmark(const CBookmarkBase& bookmark, LONG lSkip = 0)
        {
                // Check the data was opened successfully and the accessor
                // has been set.
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_pAccessor != NULL);

                CComPtr<IRowsetLocate> spLocate;
                HRESULT hr = m_spRowset.QueryInterface(&spLocate);
                if (FAILED(hr))
                        return hr;

                // Release a row if one is already around
                ReleaseRows();

                DBCOUNTITEM ulRowsFetched = 0;
                HROW* phRow = &m_hRow;
                hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
                        lSkip, 1, &ulRowsFetched, &phRow);
                // Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
                if (hr != S_OK)
                        return hr;

                // Get the data
                hr = GetData();
                if (FAILED(hr))
                {
                        ATLTRACE2(atlTraceDBClient, 0, _T("GetData from Bookmark failed - HRESULT = 0x%X\n"),hr);
                        ReleaseRows();
                }

                return S_OK;
        }
        // Get the data for the current record
        HRESULT GetData()
        {
                HRESULT hr = S_OK;
                ATLASSERT(m_pAccessor != NULL);

                ULONG nAccessors = m_pAccessor->GetNumAccessors();
                for (ULONG i=0; i<nAccessors; i++)
                {
                        if (m_pAccessor->IsAutoAccessor(i))
                        {
                                hr = GetData(i);
                                if (FAILED(hr))
                                        return hr;
                        }
                }
                return hr;
        }
        // Get the data for the passed accessor. Use for a non-auto accessor
        HRESULT GetData(int nAccessor)
        {
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_pAccessor != NULL);
                ATLASSERT(m_hRow != NULL);

                // Note that we are using the specified buffer if it has been set,
                // otherwise we use the accessor for the data.
                return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), m_pAccessor->GetBuffer());
        }
        // Get the data for the passed accessor. Use for a non-auto accessor
        HRESULT GetDataHere(int nAccessor, void* pBuffer)
        {
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_pAccessor != NULL);
                ATLASSERT(m_hRow != NULL);

                // Note that we are using the specified buffer if it has been set,
                // otherwise we use the accessor for the data.
                return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), pBuffer);
        }
        HRESULT GetDataHere(void* pBuffer)
        {
                HRESULT hr = S_OK;

                ULONG nAccessors = m_pAccessor->GetNumAccessors();
                for (ULONG i=0; i<nAccessors; i++)
                {
                        hr = GetDataHere(i, pBuffer);
                        if (FAILED(hr))
                                return hr;
                }
                return hr;
        }

        // Insert the current record
        HRESULT Insert(int nAccessor = 0, bool bGetHRow = false)
        {
                ATLASSERT(m_pAccessor != NULL);
                HRESULT hr;
                if (m_spRowsetChange != NULL)
                {
                        HROW* pHRow;
                        if (bGetHRow)
                        {
                                ReleaseRows();
                                pHRow = &m_hRow;
                        }
                        else
                                pHRow = NULL;

                        hr = m_spRowsetChange->InsertRow(NULL, m_pAccessor->GetHAccessor(nAccessor),
                                        m_pAccessor->GetBuffer(), pHRow);

                }
                else
                        hr = E_NOINTERFACE;

                return hr;
        }
        // Delete the current record
        HRESULT Delete() const
        {
                ATLASSERT(m_pAccessor != NULL);
                HRESULT hr;
                if (m_spRowsetChange != NULL)
                        hr = m_spRowsetChange->DeleteRows(NULL, 1, &m_hRow, NULL);
                else
                        hr = E_NOINTERFACE;

                return hr;
        }
        // Update the current record
        HRESULT SetData() const
        {
                ATLASSERT(m_pAccessor != NULL);
                HRESULT hr = S_OK;

                ULONG nAccessors = m_pAccessor->GetNumAccessors();
                for (ULONG i=0; i<nAccessors; i++)
                {
                        hr = SetData(i);
                        if (FAILED(hr))
                                return hr;
                }
                return hr;
        }
        // Update the current record with the data in the passed accessor
        HRESULT SetData(int nAccessor) const
        {
                ATLASSERT(m_pAccessor != NULL);
                HRESULT hr;
                if (m_spRowsetChange != NULL)
                {
                        hr = m_spRowsetChange->SetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor),
                                m_pAccessor->GetBuffer());
                }
                else
                        hr = E_NOINTERFACE;

                return hr;
        }

        // Get the data most recently fetched from or transmitted to the data source.
        // Does not get values based on pending changes.
        HRESULT GetOriginalData()
        {
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_pAccessor != NULL);

                HRESULT hr = S_OK;
                CComPtr<IRowsetUpdate> spRowsetUpdate;
                hr = m_spRowset->QueryInterface(&spRowsetUpdate);
                if (FAILED(hr))
                        return hr;

                ULONG nAccessors = m_pAccessor->GetNumAccessors();
                for (ULONG i = 0; i < nAccessors; i++)
                {
                        hr = spRowsetUpdate->GetOriginalData(m_hRow, m_pAccessor->GetHAccessor(i), m_pAccessor->GetBuffer());
                        if (FAILED(hr))
                                return hr;
                }
                return hr;
        }
        // Get the status of the current row
        HRESULT GetRowStatus(DBPENDINGSTATUS* pStatus) const
        {
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(pStatus != NULL);

                CComPtr<IRowsetUpdate> spRowsetUpdate;
                HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
                if (FAILED(hr))
                        return hr;

                return spRowsetUpdate->GetRowStatus(NULL, 1, &m_hRow, pStatus);
        }
        // Undo any changes made to the current row since it was last fetched or Update
        // was called for it
        HRESULT Undo(DBCOUNTITEM* pcRows = NULL, HROW* phRow = NULL, DBROWSTATUS* pStatus = NULL)
        {
                ATLASSERT(m_spRowset != NULL);

                CComPtr<IRowsetUpdate> spRowsetUpdate;
                HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
                if (FAILED(hr))
                        return hr;

                HROW*           prgRows;
                DBROWSTATUS*    pRowStatus;
                if (phRow != NULL)
                        hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, &prgRows, &pRowStatus);
                else
                        hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, NULL, &pRowStatus);
                if (FAILED(hr))
                        return hr;

                if (phRow != NULL)
                {
                        *phRow = *prgRows;
                        CoTaskMemFree(prgRows);
                }
                if (pStatus != NULL)
                        *pStatus = *pRowStatus;

                CoTaskMemFree(pRowStatus);
                return hr;
        }
        // Transmits any pending changes made to a row since it was last fetched or Update was
        // called for it. Also see SetData.
        HRESULT Update(DBCOUNTITEM* pcRows = NULL, HROW* phRow = NULL, DBROWSTATUS* pStatus = NULL)
        {
                ATLASSERT(m_spRowset != NULL);

                CComPtr<IRowsetUpdate> spRowsetUpdate;
                HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
                if (FAILED(hr))
                        return hr;

                HROW*           prgRows;
                DBROWSTATUS*    pRowStatus;
                if (phRow != NULL)
                        hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, &prgRows, &pRowStatus);
                else
                        hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, NULL, &pRowStatus);
                if (FAILED(hr))
                        return hr;

                if (phRow != NULL)
                {
                        *phRow = *prgRows;
                        CoTaskMemFree(prgRows);
                }
                if (pStatus != NULL)
                        *pStatus = *pRowStatus;

                CoTaskMemFree(pRowStatus);
                return hr;
        }

        // Get the approximate position of the row corresponding to the passed bookmark
        HRESULT GetApproximatePosition(const CBookmarkBase* pBookmark, DBCOUNTITEM* pPosition, DBCOUNTITEM* pcRows)
        {
                ATLASSERT(m_spRowset != NULL);

                CComPtr<IRowsetScroll> spRowsetScroll;
                HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
                if (SUCCEEDED(hr))
                {
                        if (pBookmark != NULL)
                                hr = spRowsetScroll->GetApproximatePosition(NULL, pBookmark->GetSize(), pBookmark->GetBuffer(),
                                                pPosition, pcRows);
                        else
                                hr = spRowsetScroll->GetApproximatePosition(NULL, 0, NULL, pPosition, pcRows);

                }
                return hr;

        }
        // Move to a fractional position in the rowset
        HRESULT MoveToRatio(ULONG nNumerator, ULONG nDenominator, bool bForward = true)
        {
                ATLASSERT(m_spRowset != NULL);
                DBCOUNTITEM   nRowsFetched;

                CComPtr<IRowsetScroll> spRowsetScroll;
                HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
                if (FAILED(hr))
                        return hr;

                ReleaseRows();
                HROW* phRow = &m_hRow;
                hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, (bForward) ? 1 : -1,
                        &nRowsFetched, &phRow);
                // Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
                if (hr == S_OK)
                        hr = GetData();

                return hr;
        }

// Implementation
        static const IID& GetIID()
        {
                return IID_IRowset;
        }
        IRowset* GetInterface() const
        {
                return m_spRowset;
        }
        IRowset** GetInterfacePtr()
        {
                return &m_spRowset;
        }
        void SetupOptionalRowsetInterfaces()
        {
                // Cache IRowsetChange if available
                if (m_spRowset != NULL)
                        m_spRowset->QueryInterface(&m_spRowsetChange);
        }
        HRESULT BindFinished() const { return S_OK; }
        void    SetAccessor(CAccessorBase* pAccessor)
        {
                m_pAccessor = pAccessor;
        }

        CComPtr<IRowset>        m_spRowset;
        CComPtr<IRowsetChange>  m_spRowsetChange;
        CAccessorBase*          m_pAccessor;
        HROW                    m_hRow;
};


///////////////////////////////////////////////////////////////////////////
// class CBulkRowset

class CBulkRowset : public CRowset
{
public:
        CBulkRowset()
        {
                // Default the number of rows to bulk fetch to 10
                m_nRows = 10;
                m_hr    = S_OK;
                m_phRow = NULL;
        }
        CBulkRowset::~CBulkRowset()
        {
                Close();

                delete [] m_phRow;
        }
        void Close()
        {
                if (m_spRowset != NULL)
                {
                        ReleaseRows();
                        m_spRowset.Release();
                        m_spRowsetChange.Release();
                }
        }

        // Set the number of row handles that will be retrieved in each
        // bulk row fetch. The default is 10 and this function must be called
        // before Open if you wish to change it.
        void SetRows(ULONG nRows)
        {
                // This function must be called before the memory is allocated
                // during binding
                ATLASSERT(m_phRow == NULL);
                m_nRows = nRows;
        }
        // AddRef all the currently retrieved row handles
        HRESULT AddRefRows()
        {
                ATLASSERT(m_spRowset != NULL);
                return m_spRowset->AddRefRows(m_nCurrentRows, m_phRow, NULL, NULL);
        }
        // Release all the currently retrieved row handles
        HRESULT ReleaseRows()
        {
                ATLASSERT(m_spRowset != NULL);
                // We're going to Release the rows so reset the current row position
                m_nCurrentRow = 0;
                m_hRow        = NULL;
                return m_spRowset->ReleaseRows(m_nCurrentRows, m_phRow, NULL, NULL, NULL);
        }
        // Move to the first record
        HRESULT MoveFirst()
        {
                ATLASSERT(m_spRowset != NULL);
                ReleaseRows();

                // Cause MoveNext to perform a new bulk fetch
                m_nCurrentRow  = m_nRows;

                HRESULT hr = m_spRowset->RestartPosition(NULL);
                if (FAILED(hr))
                        return hr;

                // Get the data
                return MoveNext();
        }
        // Move to the next record
        HRESULT MoveNext()
        {
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_phRow    != NULL);

                // Move to the next record in the buffer
                m_nCurrentRow++;

                // Have we reached the end of the buffer?
                if (m_nCurrentRow >= m_nCurrentRows)
                {
                        // If we've reached the end of the buffer and we had a non S_OK HRESULT from
                        // the last call to GetNextRows then return that HRESULT now.
                        if (m_hr != S_OK)
                                return m_hr;

                        // We've finished with these rows so we need some more
                        // First release any HROWs that we have
                        ReleaseRows();

                        m_hr = m_spRowset->GetNextRows(NULL, 0, m_nRows, &m_nCurrentRows, &m_phRow);
                        // If we have an error HRESULT or we haven't retrieved any rows then return
                        // the HRESULT now.
                        if (FAILED(m_hr) || m_nCurrentRows == 0)
                                return m_hr;
                }

                // Get the data for the current row
                m_hRow = m_phRow[m_nCurrentRow];
                return GetData();
        }
        // Move to the previous record
        HRESULT MovePrev()
        {
                ATLASSERT(m_spRowset != NULL);
                ATLASSERT(m_phRow    != NULL);

                // Check if we're at the start of the block
                if (m_nCurrentRow == 0)
                {
                        ReleaseRows();

                        // Go back the amount of rows in the block - 1 and fetch forward
                        m_hr = m_spRowset->GetNextRows(NULL, -(LONG)m_nRows-1, m_nRows, &m_nCurrentRows, &m_phRow);

                        // Set the current record to the end of the new block
                        m_nCurrentRow = m_nCurrentRows - 1;

                        // If we have an error HRESULT or we haven't retrieved any rows then return
                        // the HRESULT now.
                        if (FAILED(m_hr) || m_nCurrentRows == 0)
                                return m_hr;
                }
                else
                {
                        // Move back a row in the block
                        m_nCurrentRow--;
                }

                // Get the data for the current row
                m_hRow = m_phRow[m_nCurrentRow];
                return GetData();
        }
        // Move to the last record
        HRESULT MoveLast()
        {
                ReleaseRows();
                return CRowset::MoveLast();
        }
        // Move to the passed bookmark
        HRESULT MoveToBookmark(const CBookmarkBase& bookmark, LONG lSkip = 0)
        {
                ATLASSERT(m_spRowset != NULL);
                CComPtr<IRowsetLocate> spLocate;
                HRESULT hr = m_spRowset->QueryInterface(&spLocate);
                if (FAILED(hr))
                        return hr;

                ReleaseRows();
                m_hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
                        lSkip, m_nRows, &m_nCurrentRows, &m_phRow);
                if (m_hr != S_OK || m_nCurrentRows == 0)
                        return m_hr;

                // Get the data
                m_hRow = m_phRow[m_nCurrentRow];
                return GetData();
        }
        // Move to a fractional position in the rowset
        HRESULT MoveToRatio(ULONG nNumerator, ULONG nDenominator)
        {
                ATLASSERT(m_spRowset != NULL);

                CComPtr<IRowsetScroll> spRowsetScroll;
                HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
                if (FAILED(hr))
                        return hr;

                ReleaseRows();
                m_hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, m_nRows, &m_nCurrentRows, &m_phRow);
                if (m_hr != S_OK || m_nCurrentRows == 0)
                        return m_hr;

                // Get the data
                m_hRow = m_phRow[m_nCurrentRow];
                return GetData();
        }
        // Insert the current record
        HRESULT Insert(int nAccessor = 0, bool bGetHRow = false)
        {
                ReleaseRows();
                return CRowset::Insert(nAccessor, bGetHRow);
        }

// Implementation
        HRESULT BindFinished()
        {
                // No rows in the buffer yet
                m_nCurrentRows = 0;
                // Cause MoveNext to automatically perform a new bulk fetch the first time
                m_nCurrentRow  = m_nRows;

                m_phRow = NULL;
                ATLTRY(m_phRow = new HROW[(size_t)m_nRows]);  //REVIEW
                if (m_phRow == NULL)
                        return E_OUTOFMEMORY;

                return S_OK;
        }

        HRESULT m_hr;           // HRESULT to return from MoveNext at end of buffer
        HROW*   m_phRow;        // Pointer to array of HROWs for each row in buffer
        ULONG_PTR   m_nRows;        // Number of rows that will fit in the buffer
        ULONG_PTR   m_nCurrentRows; // Number of rows currently in the buffer
        ULONG_PTR   m_nCurrentRow;
};

///////////////////////////////////////////////////////////////////////////
// class CArrayRowset
//
// Allows you to access a rowset with an array syntax

template <class T, class TRowset = CRowset>
class CArrayRowset :
        public CVirtualBuffer<T>,
        public TRowset
{
public:
        CArrayRowset(int nMax = 100000) : CVirtualBuffer<T>(nMax)
        {
                m_nRowsRead = 0;
        }
        T& operator[](int nRow)
        {
                ATLASSERT(nRow >= 0);
                if( nRow < 0 )
                        _AtlRaiseException( EXCEPTION_ARRAY_BOUNDS_EXCEEDED, EXCEPTION_NONCONTINUABLE );

                HRESULT hr = S_OK;
                T* m_pCurrent = m_pBase + m_nRowsRead;

                // Retrieve the row if we haven't retrieved it already
                while ((ULONG)nRow >= m_nRowsRead)
                {
                        m_pAccessor->SetBuffer((BYTE*)m_pCurrent);
                        __try
                        {
                                // Get the row
                                hr = MoveNext();
                                if (hr != S_OK)
                                        break;
                        }
                        __except(Except(GetExceptionInformation()))
                        {
                        }
                        m_nRowsRead++;
                        m_pCurrent++;
                }
                if (hr != S_OK)
                        _AtlRaiseException( EXCEPTION_ARRAY_BOUNDS_EXCEEDED, EXCEPTION_NONCONTINUABLE );

                return *(m_pBase + nRow);
        }

        HRESULT Snapshot()
        {
                ATLASSERT(m_nRowsRead == 0);
                ATLASSERT(m_spRowset != NULL);
                HRESULT hr = MoveFirst();
                if (FAILED(hr))
                        return hr;
                do
                {
                        Write(*(T*)m_pAccessor->GetBuffer());
                        m_nRowsRead++;
                        hr = MoveNext();
                } while (SUCCEEDED(hr) &&  hr != DB_S_ENDOFROWSET);

                return (hr == DB_S_ENDOFROWSET) ? S_OK : hr;
        }


// Implementation
        ULONG   m_nRowsRead;
};

// Used when you don't need any parameters or output columns
class CNoAccessor
{
public:
        // We don't need any typedef's here as the default
        // global typedef is not to have any parameters and
        // output columns.
        HRESULT BindColumns(IUnknown*) { return S_OK; }
        HRESULT BindParameters(HACCESSOR*, ICommand*, void**) { return S_OK; }
        void    Close() { }
        HRESULT ReleaseAccessors(IUnknown*) { return S_OK; }
};

// Used when a rowset will not be returned from the command
class CNoRowset
{
public:
        HRESULT             BindFinished() { return S_OK; }
        void                Close() { }
        static const IID&   GetIID() { return IID_NULL; }
        IRowset*            GetInterface() const { return NULL; }
        IRowset**           GetInterfacePtr() { return NULL; }
        void                SetAccessor(void*) { }
        void                SetupOptionalRowsetInterfaces() { }
};

///////////////////////////////////////////////////////////////////////////
// class CAccessor

// T is the class that contains the data that will be accessed.
template <class T>
class CAccessor :
        public T,
        public CAccessorBase
{
public:
// Implementation
        // Free's any columns in the current record that need to be freed.
        // E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
        void FreeRecordMemory(IRowset* /* pRowset */)
        {
                ULONG nColumns;
                ULONG i;

                for (i = 0; i < GetNumAccessors(); i++)
                {
                        // Passing in m_pBuffer tells the column entry maps to free the
                        // memory for the types if appropriate
                        _GetBindEntries(&nColumns, NULL, i, NULL, m_pBuffer);
                }
        }
        HRESULT BindColumns(IUnknown* pUnk)
        {
                HRESULT hr;
                ULONG   nAccessors;
                ULONG   nSize;
                nAccessors = _OutputColumnsClass::_GetNumAccessors();

                SetBuffer((BYTE*)this);

                nSize = sizeof(T);
                hr = BindAccessors(nAccessors, nSize, pUnk);
                return hr;
        }
        HRESULT BindAccessors(ULONG nAccessors, ULONG nSize, IUnknown* pUnk)
        {
                ATLASSERT(pUnk != NULL);
                HRESULT hr;

                CComPtr<IAccessor> spAccessor;
                hr = pUnk->QueryInterface(&spAccessor);
                if (SUCCEEDED(hr))
                {
                        // Allocate the accessor memory if we haven't done so yet
                        if (m_pAccessorInfo == NULL)
                        {
                                hr = AllocateAccessorMemory(nAccessors);
                                if (FAILED(hr))
                                        return hr;
                        }

                        for (ULONG i=0; i<nAccessors && SUCCEEDED(hr); i++)
                                hr = BindAccessor(spAccessor, i, nSize);
                }

                return hr;
        }

        HRESULT BindAccessor(IAccessor* pAccessor, ULONG nAccessor, ULONG nSize)
        {
                DBBINDING*  pBindings = NULL;
                ULONG       nColumns;
                bool        bAuto;
                HRESULT     hr;

                // First time just get the number of entries by passing in &nColumns
                _OutputColumnsClass::_GetBindEntries(&nColumns, NULL, nAccessor, NULL);

                // Now allocate the binding structures
                ATLTRY(pBindings = new DBBINDING[nColumns]);
                if (pBindings == NULL)
                        return E_OUTOFMEMORY;

                // Now get the bind entries
                hr = _OutputColumnsClass::_GetBindEntries(&nColumns, pBindings, nAccessor, &bAuto);
                if (FAILED(hr))
                        return hr;

                m_pAccessorInfo[nAccessor].bAutoAccessor = bAuto;
                hr = BindEntries(pBindings, nColumns, &m_pAccessorInfo[nAccessor].hAccessor, nSize, pAccessor);
                delete [] pBindings;
                return hr;
        }

        HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand, void** ppParameterBuffer)
        {
                HRESULT hr = S_OK;
                // In the static accessor case, the parameter buffer will be T
                *ppParameterBuffer = this;

                // Only bind the parameters if we haven't already done it
                if (*pHAccessor == NULL)
                {
                        ULONG   nColumns = 0;
                        _ParamClass::_GetParamEntries(&nColumns, NULL);

                        DBBINDING* pBinding = NULL;
                        ATLTRY(pBinding = new DBBINDING[nColumns]);
                        if (pBinding == NULL)
                                return E_OUTOFMEMORY;

                        hr = _ParamClass::_GetParamEntries(&nColumns, pBinding);
                        if (SUCCEEDED(hr))
                        {
                                // Get the IAccessor from the passed IUnknown
                                CComPtr<IAccessor> spAccessor;
                                hr = pCommand->QueryInterface(&spAccessor);
                                if (SUCCEEDED(hr))
                                {
                                        hr = BindEntries(pBinding, nColumns, pHAccessor, sizeof(T),
                                                spAccessor);
                                }
                        }
                        delete [] pBinding;
                }
                return hr;
        }
};


///////////////////////////////////////////////////////////////////////////
// CDynamicAccessor

class CDynamicAccessor :
        public CAccessorBase
{
public:
        CDynamicAccessor()
        {
                m_nColumns        = 0;
                m_pColumnInfo     = NULL;
                m_pStringsBuffer  = NULL;
        };
        ~CDynamicAccessor()
        {
                Close();
        }
        void Close()
        {
                if (m_pColumnInfo != NULL)
                {
                        CoTaskMemFree(m_pColumnInfo);
                        m_pColumnInfo = NULL;
                }

                // Free the memory for the string buffer returned by IColumnsInfo::GetColumnInfo,
                // if necessary
                if (m_pStringsBuffer != NULL)
                {
                        CoTaskMemFree(m_pStringsBuffer);
                        m_pStringsBuffer = NULL;
                }

                delete [] m_pBuffer;
                m_pBuffer = NULL;
                m_nColumns = 0;

                CAccessorBase::Close();
        }
        bool GetColumnType(ULONG_PTR nColumn, DBTYPE* pType) const
        {
                if (TranslateColumnNo(nColumn))
                {
                        *pType = m_pColumnInfo[nColumn].wType;
                        return true;
                }
                else
                        return false;
        }
        bool GetColumnFlags(ULONG_PTR nColumn, DBCOLUMNFLAGS* pFlags) const
        {
                if (TranslateColumnNo(nColumn))
                {
                        *pFlags = m_pColumnInfo[nColumn].dwFlags;
                        return true;
                }
                else
                        return false;
        }
        bool GetOrdinal(TCHAR* pColumnName, DBORDINAL* pOrdinal) const
        {
                ATLASSERT(pColumnName != NULL);
                ULONG_PTR nColumn;
                if (GetInternalColumnNo(pColumnName, &nColumn))
                {
                        *pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
                        return true;
                }
                else
                        return false;
        }

        void* GetValue(ULONG_PTR nColumn) const
        {
                if (TranslateColumnNo(nColumn))
                        return _GetDataPtr(nColumn);
                else
                        return NULL;
        }

        void* GetValue(TCHAR* pColumnName) const
        {
                ATLASSERT(pColumnName != NULL);
                ULONG_PTR nColumn;
                if (GetInternalColumnNo(pColumnName, &nColumn))
                        return _GetDataPtr(nColumn);
                else
                        return NULL;    // Not Found
        }

        template <class ctype>
        void _GetValue(ULONG_PTR nColumn, ctype* pData) const
        {
                ATLASSERT(pData != NULL);
                ATLASSERT(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
                ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
                *pData = *pBuffer;
        }
        template <class ctype>
        void _SetValue(ULONG_PTR nColumn, const ctype& data)
        {
                ATLASSERT(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
                ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
                *pBuffer = (ctype)data;
        }
        template <class ctype>
        bool GetValue(ULONG_PTR nColumn, ctype* pData) const
        {
                if (TranslateColumnNo(nColumn))
                {
                        _GetValue(nColumn, pData);
                        return true;
                }
                return false;
        }
        template <class ctype>
        bool SetValue(ULONG_PTR nColumn, const ctype& data)
        {
                if (TranslateColumnNo(nColumn))
                {
                        _SetValue(nColumn, data);
                        return true;
                }
                return false;
        }
        template <class ctype>
        bool GetValue(TCHAR *pColumnName, ctype* pData) const
        {
                ATLASSERT(pColumnName != NULL);
                ULONG_PTR nColumn;
                if (GetInternalColumnNo(pColumnName, &nColumn))
                {
                        _GetValue(nColumn, pData);
                        return true;
                }
                return false;
        }
        template <class ctype>
        bool SetValue(TCHAR *pColumnName, const ctype& data)
        {
                ATLASSERT(pColumnName != NULL);
                ULONG_PTR nColumn;
                if (GetInternalColumnNo(pColumnName, &nColumn))
                {
                        _SetValue(nColumn, data);
                        return true;
                }
                return false;
        }
        bool GetLength(ULONG_PTR nColumn, ULONG_PTR* pLength) const
        {
                ATLASSERT(pLength != NULL);
                if (TranslateColumnNo(nColumn))
                {
                        *pLength = *(ULONG_PTR*)(AddOffset((ULONG_PTR)_GetDataPtr(nColumn), m_pColumnInfo[nColumn].ulColumnSize));
                        return true;
                }
                else
                        return false;
        }
        bool SetLength(ULONG_PTR nColumn, ULONG_PTR nLength)
        {
                if (TranslateColumnNo(nColumn))
                {
                        *(ULONG_PTR*)(AddOffset((ULONG_PTR)_GetDataPtr(nColumn), m_pColumnInfo[nColumn].ulColumnSize)) = nLength;
                        return true;
                }
                else
                        return false;
        }
        bool GetLength(TCHAR* pColumnName, ULONG_PTR* pLength) const
        {
                ATLASSERT(pColumnName != NULL);
                ATLASSERT(pLength != NULL);
                ULONG_PTR nColumn;
                if (GetInternalColumnNo(pColumnName, &nColumn))
                {
                        *pLength = *(ULONG_PTR*)(AddOffset((ULONG_PTR)_GetDataPtr(nColumn), m_pColumnInfo[nColumn].ulColumnSize));
                        return true;
                }
                else
                        return false;
        }
        bool SetLength(TCHAR* pColumnName, ULONG_PTR nLength)
        {
                ATLASSERT(pColumnName != NULL);
                ULONG_PTR nColumn;
                if (GetInternalColumnNo(pColumnName, &nColumn))
                {
                        *(ULONG_PTR*)(AddOffset((ULONG_PTR)_GetDataPtr(nColumn), m_pColumnInfo[nColumn].ulColumnSize)) = nLength;
                        return true;
                }
                else
                        return false;
        }
        bool GetStatus(ULONG_PTR nColumn, DBSTATUS* pStatus) const
        {
                ATLASSERT(pStatus != NULL);
                if (TranslateColumnNo(nColumn))
                {
                        *pStatus = *(DBSTATUS*)(AddOffset(AddOffset((ULONG_PTR)_GetDataPtr(nColumn), m_pColumnInfo[nColumn].ulColumnSize), sizeof(ULONG)));
                        return true;
                }
                else
                        return false;
        }
        bool SetStatus(ULONG_PTR nColumn, DBSTATUS status)
        {
                if (TranslateColumnNo(nColumn))
                {
                        *(DBSTATUS*)(AddOffset(AddOffset((ULONG_PTR)_GetDataPtr(nColumn), m_pColumnInfo[nColumn].ulColumnSize), sizeof(ULONG))) = status;
                        return true;
                }
                else
                        return false;
        }
        bool GetStatus(TCHAR* pColumnName, DBSTATUS* pStatus) const
        {
                ATLASSERT(pColumnName != NULL);
                ATLASSERT(pStatus != NULL);
                ULONG_PTR nColumn;
                if (GetInternalColumnNo(pColumnName, &nColumn))
                {
                        *pStatus = *(DBSTATUS*)((BYTE*)_GetDataPtr(nColumn) + m_pColumnInfo[nColumn].ulColumnSize + sizeof(ULONG));
                        return true;
                }
                else
                        return false;
        }
        bool SetStatus(TCHAR* pColumnName, DBSTATUS status)
        {
                ATLASSERT(pColumnName != NULL);
                ULONG_PTR nColumn;
                if (GetInternalColumnNo(pColumnName, &nColumn))
                {
                        *(DBSTATUS*)((BYTE*)_GetDataPtr(nColumn) + m_pColumnInfo[nColumn].ulColumnSize + sizeof(ULONG)) = status;
                        return true;
                }
                else
                        return false;
        }

        // Returns true if a bookmark is available
        HRESULT GetBookmark(CBookmark<>* pBookmark) const
        {
                HRESULT hr;
                if (m_pColumnInfo->iOrdinal == 0)
                        hr = pBookmark->SetBookmark(m_pColumnInfo->ulColumnSize, (BYTE*)_GetDataPtr(0));
                else
                        hr = E_FAIL;
                return hr;
        }

        ULONG_PTR GetColumnCount() const
        {
                return m_nColumns;
        }

        LPOLESTR GetColumnName(ULONG_PTR nColumn) const
        {
                if (TranslateColumnNo(nColumn))
                        return m_pColumnInfo[nColumn].pwszName;
                else
                        return NULL;
        }

        // Note: the next method used to be defined as
        //                HRESULT GetColumnInfo(IRowset* pRowset, ULONG* pColumns, DBCOLUMNINFO** ppColumnInfo)
        // this was causing a memory leak because we were using m_pStringsBuffer as a parameter to the
        // spColumnsInfo->GetColumnInfo call.  The memory pointed by m_pStringsBuffer was released
        // only in CDynamicAccessor::Close.
        // Now the user has to provide his own pointer buffer, and is responsible for releasing the 
        // memory after it is no longer needed
        HRESULT GetColumnInfo(IRowset* pRowset, DBORDINAL* pColumns, DBCOLUMNINFO** ppColumnInfo, OLECHAR **ppStringsBuffer)
        {
                CComPtr<IColumnsInfo> spColumnsInfo;
                HRESULT hr = pRowset->QueryInterface(&spColumnsInfo);
                if (SUCCEEDED(hr))
                        hr = spColumnsInfo->GetColumnInfo(pColumns, ppColumnInfo, ppStringsBuffer);

                return hr;
        }

        HRESULT AddBindEntry(const DBCOLUMNINFO& info)
        {
                DBCOLUMNINFO* p = (DBCOLUMNINFO*)CoTaskMemRealloc(m_pColumnInfo, (m_nColumns + 1) * sizeof(DBCOLUMNINFO));
                if (p == NULL)
                        return E_OUTOFMEMORY;
                m_pColumnInfo = p;
                m_pColumnInfo[m_nColumns] = info;
                m_nColumns++;

                return S_OK;
        }

// Implementation
        // Free's any columns in the current record that need to be freed.
        // E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
        void FreeRecordMemory(IRowset* pRowset)
        {
                ULONG_PTR i;

                for (i = 0; i < m_nColumns; i++)
                        CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
        }
        void* _GetDataPtr(ULONG_PTR nColumn) const
        {
                return m_pBuffer + (ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
        }
        bool GetInternalColumnNo(TCHAR* pColumnName, ULONG_PTR* pColumn) const
        {
                ATLASSERT(pColumnName != NULL);
                ATLASSERT(pColumn != NULL);
                USES_CONVERSION;
                ULONG_PTR   i;
                ULONG       nSize = (lstrlen(pColumnName) + 1) * sizeof(OLECHAR);
                OLECHAR*    pOleColumnName = T2OLE(pColumnName);

                // Search through the columns trying to find a match
                for (i = 0; i < m_nColumns; i++)
                {
                        if (m_pColumnInfo[i].pwszName != NULL &&
                                memcmp(m_pColumnInfo[i].pwszName, pOleColumnName, nSize) == 0)
                                break;
                }
                if (i < m_nColumns)
                {
                        *pColumn = i;
                        return true;
                }
                else
                        return false;   // Not Found
        }
        HRESULT BindColumns(IUnknown* pUnk)
        {
                ATLASSERT(pUnk != NULL);
                CComPtr<IAccessor> spAccessor;
                HRESULT hr = pUnk->QueryInterface(&spAccessor);
                if (FAILED(hr))
                        return hr;

                ULONG_PTR   i;
                ULONG_PTR   nOffset = 0, nLengthOffset, nStatusOffset;

                // If the user hasn't specifed the column information to bind by calling AddBindEntry then
                // we get it ourselves
                if (m_pColumnInfo == NULL)
                {
                        CComPtr<IColumnsInfo> spColumnsInfo;
                        hr = pUnk->QueryInterface(&spColumnsInfo);
                        if (FAILED(hr))
                                return hr;

                        hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
                        if (FAILED(hr))
                                return hr;

                        m_bOverride = false;
                }
                else
                        m_bOverride = true;

                DBBINDING* pBinding = NULL;
                ATLTRY(pBinding= new DBBINDING[(size_t)m_nColumns]);  //REVIEW
                if (pBinding == NULL)
                        return E_OUTOFMEMORY;

                DBBINDING* pCurrent = pBinding;
                DBOBJECT*  pObject;
                for (i = 0; i < m_nColumns; i++)
                {
                        // If it's a BLOB or the column size is large enough for us to treat it as
                        // a BLOB then we also need to set up the DBOBJECT structure.
                        if (m_pColumnInfo[i].ulColumnSize > 1024 || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
                        {
                                pObject = NULL;
                                ATLTRY(pObject = new DBOBJECT);
                                if (pObject == NULL)
                                        return E_OUTOFMEMORY;
                                pObject->dwFlags = STGM_READ;
                                pObject->iid     = IID_ISequentialStream;
                                m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
                                m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
                        }
                        else
                                pObject = NULL;

                        // If column is of type STR or WSTR increase length by 1
                        // to accommodate the NULL terminator.
                        if (m_pColumnInfo[i].wType == DBTYPE_STR ||
                                m_pColumnInfo[i].wType == DBTYPE_WSTR)
                                        m_pColumnInfo[i].ulColumnSize += 1;
                        if( m_pColumnInfo[i].wType == DBTYPE_WSTR )
                                        m_pColumnInfo[i].ulColumnSize *= sizeof(WCHAR);

                        nLengthOffset = AddOffset(nOffset, m_pColumnInfo[i].ulColumnSize);
                        nStatusOffset = AddOffset(nLengthOffset, sizeof(ULONG));
                        Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
                                m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
                                DBPARAMIO_NOTPARAM, nOffset,
                                nLengthOffset, nStatusOffset, pObject);
                        pCurrent++;

                        // Note that, as we're not using this for anything else, we're using the
                        // pTypeInfo element to store the offset to our data.
                        m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(DWORD_PTR)nOffset;

                        nOffset = AddOffset(nStatusOffset, sizeof(DBSTATUS));
                }
                // Allocate the accessor memory if we haven't done so yet
                if (m_pAccessorInfo == NULL)
                {
                        hr = AllocateAccessorMemory(1); // We only have one accessor
                        if (FAILED(hr))
                        {
                                delete [] pBinding;
                                return hr;
                        }
                        m_pAccessorInfo->bAutoAccessor = TRUE;
                }

                // Allocate enough memory for the data buffer and tell the rowset
                // Note that the rowset will free the memory in its destructor.
                m_pBuffer = NULL;
                ATLTRY(m_pBuffer = new BYTE[(size_t)nOffset]);  //REVIEW
                if (m_pBuffer == NULL)
                {
                        delete [] pBinding;
                        return E_OUTOFMEMORY;
                }
                hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
                                nOffset, spAccessor);
                delete [] pBinding;

                return hr;
        }

        static ULONG_PTR AddOffset(ULONG_PTR nCurrent, ULONG_PTR nAdd)
        {
                struct foobar
                {
                        char    foo;
                        LONG_PTR    bar;
                };
                ULONG_PTR nAlign = offsetof(foobar, bar);

                ULONG_PTR nResult = nCurrent + nAdd;
                if( nResult % nAlign )
                        nResult += ( nAlign - (nAdd % nAlign) );
                return nResult;
        }

        // Translate the column number to the index into the column info array
        bool TranslateColumnNo(ULONG_PTR& nColumn) const
        {
                ATLASSERT(m_pColumnInfo != NULL);
                // If the user has overriden the binding then we need to search
                // through the column info for the ordinal number
                if (m_bOverride)
                {
                        for (ULONG_PTR i = 0; i < m_nColumns; i++)
                        {
                                if (m_pColumnInfo[i].iOrdinal == nColumn)
                                {
                                        nColumn = i;
                                        return true;
                                }
                        }
                        return false;
                }
                else
                {
                        // Note that m_pColumnInfo->iOrdinal will be zero if have bound
                        // a bookmark as the first entry, otherwise it will be 1.
                        // If the column is out of range then return false
                        if (nColumn > (m_nColumns - 1 + m_pColumnInfo->iOrdinal))
                                return false;

                        // otherwise translate the column to an index into our internal
                        // binding entries array
                        nColumn -= m_pColumnInfo->iOrdinal;
                        return true;
                }
        }
        typedef CDynamicAccessor _OutputColumnsClass;
        static bool HasOutputColumns() { return true; }

        ULONG_PTR           m_nColumns;
        DBCOLUMNINFO*       m_pColumnInfo;
        OLECHAR*            m_pStringsBuffer;
        bool                m_bOverride;
};


///////////////////////////////////////////////////////////////////////////
// class CDynamicParameterAccessor

class CDynamicParameterAccessor : public CDynamicAccessor
{
// Constructors and Destructors
public:
        typedef CDynamicParameterAccessor _ParamClass;
        CDynamicParameterAccessor()
        {
                m_pParameterEntry       = NULL;
                m_pParameterBuffer      = NULL;
                m_ppParamName           = NULL;
                m_nParameterBufferSize  = 0;
                m_nParams               = 0;
        };

        ~CDynamicParameterAccessor()
        {
                delete [] m_pParameterEntry;
                if (m_ppParamName != NULL)
                {
                        if (*m_ppParamName != NULL)
                                CoTaskMemFree(*m_ppParamName);
                        delete [] m_ppParamName;
                }
                delete m_pParameterBuffer;
        };
        // nParam is the parameter number (offset from 1)
        bool GetParamType(ULONG_PTR nParam, DBTYPE* pType) const
        {
                ATLASSERT(pType != NULL);
                if (nParam == 0 || nParam > m_nParams)
                        return false;

                *pType = m_pParameterEntry[nParam-1].wType;
                return true;
        }
        template <class ctype>
        bool GetParam(ULONG_PTR nParam, ctype* pData) const
        {
                ATLASSERT(pData != NULL);
                ctype* pBuffer = (ctype*)GetParam(nParam);
                if (pBuffer == NULL)
                        return false;
                *pData = *pBuffer;
                return true;

        }
        template <class ctype>
        bool SetParam(ULONG_PTR nParam, ctype* pData)
        {
                ATLASSERT(pData != NULL);
                ctype* pBuffer = (ctype*)GetParam(nParam);
                if (pBuffer == NULL)
                        return false;
                *pBuffer = *pData;
                return true;

        }
        template <class ctype>
        bool GetParam(TCHAR* pParamName, ctype* pData) const
        {
                ATLASSERT(pData != NULL);
                ctype* pBuffer = (ctype*)GetParam(pParamName);
                if (pBuffer == NULL)
                        return false;
                *pData = *pBuffer;
                return true;

        }
        template <class ctype>
        bool SetParam(TCHAR* pParamName, ctype* pData)
        {
                ATLASSERT(pData != NULL);
                ctype* pBuffer = (ctype*)GetParam(pParamName);
                if (pBuffer == NULL)
                        return false;
                *pBuffer = *pData;
                return true;

        }
        void* GetParam(ULONG_PTR nParam) const
        {
                if (nParam == 0 || nParam > m_nParams)
                        return NULL;
                else
                        return m_pParameterBuffer + m_pParameterEntry[nParam-1].obValue;
        }
        void* GetParam(TCHAR* pParamName) const
        {
                USES_CONVERSION;
                ULONG_PTR    i;
                ULONG       nSize = (lstrlen(pParamName) + 1) * sizeof(OLECHAR);
                OLECHAR*    pOleParamName = T2OLE(pParamName);

                for (i=0; i<m_nParams; i++)
                {
                        if (memcmp(m_ppParamName[i], pOleParamName, nSize) == 0)
                                break;
                }
                if (i < m_nParams)
                        return (m_pParameterBuffer + m_pParameterEntry[i].obValue);
                else
                        return NULL;    // Not Found
        }
        // Get the number of parameters
        ULONG_PTR GetParamCount() const
        {
                return m_nParams;
        }
        // Get the parameter name for the passed parameter number
        LPOLESTR GetParamName(ULONG_PTR ulParam) const
        {
                ATLASSERT(ulParam<m_nParams);
                return m_ppParamName[ulParam];
        }

// Implementation
        HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand,
                                void** ppParameterBuffer)
        {
                // If we have already bound the parameters then just return
                // the pointer to the parameter buffer
                if (*pHAccessor != NULL)
                {
                        *ppParameterBuffer = m_pParameterBuffer;
                        return S_OK;
                }

                CComPtr<IAccessor> spAccessor;
                HRESULT hr = pCommand->QueryInterface(&spAccessor);
                if (FAILED(hr))
                        return hr;

                // Try to bind parameters if available
                CComPtr<ICommandWithParameters> spCommandParameters;
                hr = pCommand->QueryInterface(&spCommandParameters);
                if (FAILED(hr))
                        return hr;

                DB_UPARAMS      ulParams     = 0;
                DBPARAMINFO*    pParamInfo   = NULL;
                LPOLESTR        pNamesBuffer = NULL;

                // Get Parameter Information
                hr = spCommandParameters->GetParameterInfo(&ulParams, &pParamInfo,
                                &pNamesBuffer);
                if (FAILED(hr))
                        return hr;

                // Create the parameter information for binding
                hr = AllocateParameterInfo(ulParams);
                if (FAILED(hr))
                {
                        CoTaskMemFree(pParamInfo);
                        CoTaskMemFree(pNamesBuffer);
                        return hr;
                }

                ULONG_PTR nOffset = 0;
                DBBINDING* pCurrent = m_pParameterEntry;
                for (ULONG l=0; l<ulParams; l++)
                {
                        m_pParameterEntry[l].eParamIO = 0;
                        if (pParamInfo[l].dwFlags & DBPARAMFLAGS_ISINPUT)
                                m_pParameterEntry[l].eParamIO |= DBPARAMIO_INPUT;

                        if (pParamInfo[l].dwFlags & DBPARAMFLAGS_ISOUTPUT)
                                m_pParameterEntry[l].eParamIO |= DBPARAMIO_OUTPUT;

                        if( pParamInfo[l].wType == DBTYPE_STR || pParamInfo[l].wType == DBTYPE_WSTR )
                                pParamInfo[l].ulParamSize += 1;
                        if( pParamInfo[l].wType == DBTYPE_WSTR )
                                pParamInfo[l].ulParamSize *= sizeof(WCHAR);
                        Bind(pCurrent, pParamInfo[l].iOrdinal, pParamInfo[l].wType,
                                pParamInfo[l].ulParamSize, pParamInfo[l].bPrecision, pParamInfo[l].bScale,
                                m_pParameterEntry[l].eParamIO, nOffset);
                        pCurrent++;

                        m_ppParamName[l] = pNamesBuffer;
                        if (pNamesBuffer && *pNamesBuffer)
                        {
                                // Search for the NULL termination character
                                while (*pNamesBuffer++)
                                        ;
                        }
                        nOffset = AddOffset(nOffset, pParamInfo[l].ulParamSize);
                }

                // Allocate memory for the new buffer
                m_pParameterBuffer = NULL;
                ATLTRY(m_pParameterBuffer = new BYTE[(size_t)nOffset]);  //REVIEW
                if (m_pParameterBuffer == NULL)
                {
                        // Note that pNamesBuffer will be freed in the destructor
                        // by freeing *m_ppParamName
                        CoTaskMemFree(pParamInfo);
                        return E_OUTOFMEMORY;
                }
                *ppParameterBuffer = m_pParameterBuffer;
                m_nParameterBufferSize = nOffset;
                m_nParams = ulParams;
                BindEntries(m_pParameterEntry, ulParams, pHAccessor, nOffset, spAccessor);

                CoTaskMemFree(pParamInfo);

                return S_OK;
        }
        bool HasParameters() const
        {
                return true;
        }
        HRESULT AllocateParameterInfo(ULONG_PTR nParamEntries)
        {
                // Allocate memory for the bind structures
                m_pParameterEntry = NULL;
                ATLTRY(m_pParameterEntry = new DBBINDING[(size_t)nParamEntries]);  //REVIEW
                if (m_pParameterEntry == NULL)
                        return E_OUTOFMEMORY;

                // Allocate memory to store the field names
                m_ppParamName = NULL;
                ATLTRY(m_ppParamName = new OLECHAR*[(size_t)nParamEntries]);  //REVIEW
                if (m_ppParamName == NULL)
                        return E_OUTOFMEMORY;
                return S_OK;
        }

// Data Members
        // Number of parameters
        ULONG_PTR           m_nParams;
        // A pointer to the entry structures for each parameter
        DBBINDING*          m_pParameterEntry;
        // String names for the parameters
        OLECHAR**           m_ppParamName;
        // The size of the buffer where the parameters are stored
        ULONG_PTR           m_nParameterBufferSize;
        // A pointer to the buffer where the parameters are stored
        BYTE*               m_pParameterBuffer;
};


///////////////////////////////////////////////////////////////////////////
// class CManualAccessor

class CManualAccessor :
        public CAccessorBase
{
public:
        CManualAccessor()
        {
                // By default we don't have any parameters unless CreateParameterAccessor is called
                m_pEntry          = NULL;
                m_nParameters     = 0;
                m_pParameterEntry = NULL;
                m_nColumns        = 0;
        }
        ~CManualAccessor()
        {
                delete [] m_pEntry;
                delete [] m_pParameterEntry;
        }
        HRESULT CreateAccessor(ULONG_PTR nBindEntries, void* pBuffer, ULONG_PTR nBufferSize)
        {
                m_pBuffer     = (BYTE*)pBuffer;
                m_nBufferSize = nBufferSize;
                m_nColumns    = nBindEntries;
                m_nEntry      = 0;

                // If they've previously created some entries then free them
                delete [] m_pEntry;
                m_pEntry = NULL;

                // Allocate memory for the bind structures
                ATLTRY(m_pEntry = new DBBINDING[(size_t)nBindEntries]);  //REVIEW
                if (m_pEntry == NULL)
                        return E_OUTOFMEMORY;
                else
                        return S_OK;
        }
        HRESULT CreateParameterAccessor(ULONG_PTR nBindEntries, void* pBuffer, ULONG_PTR nBufferSize)
        {
                m_pParameterBuffer     = (BYTE*)pBuffer;
                m_nParameterBufferSize = nBufferSize;
                m_nParameters          = nBindEntries;
                m_nCurrentParameter    = 0;

                // Allocate memory for the bind structures
                m_pParameterEntry = NULL;
                ATLTRY(m_pParameterEntry  = new DBBINDING[(size_t)nBindEntries]);  //REVIEW
                if (m_pParameterEntry == NULL)
                        return E_OUTOFMEMORY;
                else
                        return S_OK;
        }
        void AddBindEntry(ULONG_PTR nOrdinal, DBTYPE wType, ULONG_PTR nColumnSize,
                        void* pData, void* pLength = NULL, void* pStatus = NULL)
        {
                ATLASSERT(m_nEntry < m_nColumns);
                ULONG_PTR   nLengthOffset, nStatusOffset;

                if (pStatus != NULL)
                        nStatusOffset = (BYTE*)pStatus - m_pBuffer;
                else
                        nStatusOffset = 0;

                if (pLength != NULL)
                        nLengthOffset = (BYTE*)pLength - m_pBuffer;
                else
                        nLengthOffset = 0;

                Bind(m_pEntry+m_nEntry, nOrdinal, wType, nColumnSize, 0, 0, DBPARAMIO_NOTPARAM,
                        (BYTE*)pData - m_pBuffer, nLengthOffset, nStatusOffset);

                m_nEntry++;
        }
        void AddParameterEntry(ULONG_PTR nOrdinal, DBTYPE wType, ULONG_PTR nColumnSize,
                        void* pData, void* pLength = NULL, void* pStatus = NULL,
                        DBPARAMIO eParamIO = DBPARAMIO_INPUT)
        {
                ATLASSERT(m_nCurrentParameter < m_nParameters);
                ULONG_PTR   nLengthOffset, nStatusOffset;

                if (pStatus != NULL)
                        nStatusOffset = (BYTE*)pStatus - m_pParameterBuffer;
                else
                        nStatusOffset = 0;

                if (pLength != NULL)
                        nLengthOffset = (BYTE*)pLength - m_pBuffer;
                else
                        nLengthOffset = 0;

                Bind(m_pParameterEntry + m_nCurrentParameter, nOrdinal, wType, nColumnSize, 0, 0,
                        eParamIO, (BYTE*)pData - m_pParameterBuffer, nLengthOffset, nStatusOffset);

                m_nCurrentParameter++;
        }

// Implementation
        // Free's any columns in the current record that need to be freed.
        // E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
        void FreeRecordMemory(IRowset* pRowset)
        {
                ULONG_PTR i;

                for (i = 0; i < m_nColumns; i++)
                        CAccessorBase::FreeType(m_pEntry[i].wType, m_pBuffer + m_pEntry[i].obValue, pRowset);
        }
        HRESULT BindColumns(IUnknown* pUnk)
        {
                ATLASSERT(pUnk != NULL);
                CComPtr<IAccessor> spAccessor;
                HRESULT hr = pUnk->QueryInterface(&spAccessor);
                if (FAILED(hr))
                        return hr;

                // Allocate the accessor memory if we haven't done so yet
                if (m_pAccessorInfo == NULL)
                {
                        hr = AllocateAccessorMemory(1); // We only have one accessor
                        if (FAILED(hr))
                                return hr;
                        m_pAccessorInfo->bAutoAccessor = TRUE;
                }

                return BindEntries(m_pEntry, m_nColumns, &m_pAccessorInfo->hAccessor, m_nBufferSize, spAccessor);
        }

        HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand, void** ppParameterBuffer)
        {
                HRESULT hr;
                *ppParameterBuffer = m_pParameterBuffer;

                // Only bind the parameter if we haven't done so yet
                if (*pHAccessor == NULL)
                {
                        // Get the IAccessor from the passed IUnknown
                        CComPtr<IAccessor> spAccessor;
                        hr = pCommand->QueryInterface(&spAccessor);
                        if (SUCCEEDED(hr))
                        {
                                hr = BindEntries(m_pParameterEntry, m_nParameters, pHAccessor,
                                                m_nParameterBufferSize, spAccessor);
                        }
                }
                else
                        hr = S_OK;

                return hr;
        }
        typedef CManualAccessor _ParamClass;
        bool HasParameters() { return (m_nParameters > 0); }
        typedef CManualAccessor _OutputColumnsClass;
        static bool HasOutputColumns() { return true; }
        ULONG_PTR GetColumnCount() const
        {
                return m_nColumns;
        }

        // The binding structure for the output columns
        DBBINDING*          m_pEntry;
        // The number of output columns
        ULONG_PTR            m_nColumns;
        // The number of the current entry for the output columns
        ULONG_PTR            m_nEntry;
        // The size of the data buffer for the output columns
        ULONG_PTR            m_nBufferSize;
        // The number of parameters columns
        ULONG_PTR            m_nParameters;
        // The number of the parameter column to bind next
        ULONG_PTR            m_nCurrentParameter;
        // A pointer to the entry structures for each parameter
        DBBINDING*          m_pParameterEntry;
        // The size of the buffer where the parameters are stored
        ULONG_PTR           m_nParameterBufferSize;
        // A pointer to the buffer where the parameters are stored
        BYTE*               m_pParameterBuffer;
};


///////////////////////////////////////////////////////////////////////////
// CAccessorRowset

template <class TAccessor = CNoAccessor, class TRowset = CRowset>
class CAccessorRowset :
        public TAccessor,
        public TRowset
{
public:
        CAccessorRowset()
        {
                // Give the rowset a pointer to the accessor
                SetAccessor(this);
        }
        ~CAccessorRowset()
        {
                Close();
        }
        // Used to get the column information from the opened rowset. The user is responsible
        // for freeing the returned column information and string buffer.
        HRESULT GetColumnInfo(ULONG_PTR* pulColumns,
                DBCOLUMNINFO** ppColumnInfo, LPOLESTR* ppStrings) const
        {
                ATLASSERT(GetInterface() != NULL);
                if (ppColumnInfo == NULL || pulColumns == NULL || ppStrings == NULL)
                        return E_POINTER;

                CComPtr<IColumnsInfo> spColumns;
                HRESULT hr = GetInterface()->QueryInterface(&spColumns);
                if (SUCCEEDED(hr))
                        hr = spColumns->GetColumnInfo(pulColumns, ppColumnInfo, ppStrings);

                return hr;
        }
        // Used to get the column information when overriding the bindings using CDynamicAccessor
        // The user should CoTaskMemFree the column information pointer that is returned.
        // Since the corresponding method in CDynamicAccessor has also been declared as deprecated
        // users should use the other version of the method (one that takes the 
        // DBCOLUMNINFO** ppColumnInfo argument).  This is due to a bug fix 
        // (see CDynamicAccessor::GetColumnInfo for details).
        //HRESULT GetColumnInfo(ULONG* pColumns, DBCOLUMNINFO** ppColumnInfo)
        //{
                // If you get a compilation here, then you are most likely calling this function
                // from a class that is not using CDynamicAccessor.
                //ATLASSERT(GetInterface() != NULL);
                //return TAccessor::GetColumnInfo(GetInterface(), pColumns, ppColumnInfo);
        //}
        // Call to bind the output columns
        HRESULT Bind()
        {
                // Bind should only be called when we've successfully opened the rowset
                ATLASSERT(GetInterface() != NULL);
                HRESULT hr = TAccessor::BindColumns(GetInterface());
                if (SUCCEEDED(hr))
                        hr = BindFinished();
                return hr;
        }
        // Close the opened rowset and release the created accessors for the output columns
        void Close()
        {
                if (GetInterface() != NULL)
                {
                        ReleaseAccessors(GetInterface());
                        TAccessor::Close();
                        TRowset::Close();
                }
        }
        // Free's any columns in the current record that need to be freed.
        // E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
        void FreeRecordMemory()
        {
                TAccessor::FreeRecordMemory(m_spRowset);
        }
};


///////////////////////////////////////////////////////////////////////////
// class CEnumeratorAccessor

class CEnumeratorAccessor
{
public:
        WCHAR           m_szName[129];
        WCHAR           m_szParseName[129];
        WCHAR           m_szDescription[129];
        USHORT          m_nType;
        VARIANT_BOOL    m_bIsParent;

// Binding Maps
BEGIN_COLUMN_MAP(CEnumeratorAccessor)
        COLUMN_ENTRY(1, m_szName)
        COLUMN_ENTRY(2, m_szParseName)
        COLUMN_ENTRY(3, m_szDescription)
        COLUMN_ENTRY(4, m_nType)
        COLUMN_ENTRY(5, m_bIsParent)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CEnumerator

class CEnumerator : public CAccessorRowset<CAccessor<CEnumeratorAccessor> >
{
public:
        HRESULT Open(LPMONIKER pMoniker)
        {
                if (pMoniker == NULL)
                        return E_FAIL;

                // Bind the moniker for the sources rowset
                if (FAILED(BindMoniker(pMoniker, 0, IID_ISourcesRowset,
                                        (void**)&m_spSourcesRowset)))
                        return E_FAIL;

                // Enumerate the data sources
                if (FAILED(m_spSourcesRowset->GetSourcesRowset(NULL, IID_IRowset, 0,
                        NULL, (IUnknown**)&m_spRowset)))
                        return E_FAIL;

                return Bind();
        }
        HRESULT Open(const CEnumerator& enumerator)
        {
                HRESULT hr;
                CComPtr<IMoniker> spMoniker;

                hr = enumerator.GetMoniker(&spMoniker);
                if (FAILED(hr))
                        return hr;

                return Open(spMoniker);
        }
        HRESULT Open(const CLSID* pClsid = &CLSID_OLEDB_ENUMERATOR)
        {
                if (pClsid == NULL)
                        return E_FAIL;

                HRESULT hr;
                // Create the enumerator
                hr = CoCreateInstance(*pClsid, NULL, CLSCTX_INPROC_SERVER,
                                IID_ISourcesRowset, (LPVOID*)&m_spSourcesRowset);
                if (FAILED(hr))
                        return hr;

                // Get the rowset so we can enumerate the data sources
                hr = m_spSourcesRowset->GetSourcesRowset(NULL, IID_IRowset, 0,
                        NULL, (IUnknown**)&m_spRowset);
                if (FAILED(hr))
                        return hr;

                return Bind();
        }

        HRESULT GetMoniker(LPMONIKER* ppMoniker) const
        {
                CComPtr<IParseDisplayName> spParse;
                HRESULT hr;
                ULONG   chEaten;

                if (ppMoniker == NULL)
                        return E_POINTER;

                if (m_spSourcesRowset == NULL)
                        return E_FAIL;

                hr = m_spSourcesRowset->QueryInterface(IID_IParseDisplayName, (void**)&spParse);
                if (FAILED(hr))
                        return hr;

                hr = spParse->ParseDisplayName(NULL, (LPOLESTR)m_szParseName,
                                &chEaten, ppMoniker);
                return hr;
        }

        HRESULT GetMoniker(LPMONIKER* ppMoniker, LPCTSTR lpszDisplayName) const
        {
                USES_CONVERSION;
                CComPtr<IParseDisplayName> spParse;
                HRESULT hr;
                ULONG   chEaten;

                if (ppMoniker == NULL || lpszDisplayName == NULL)
                        return E_POINTER;

                if (m_spSourcesRowset == NULL)
                        return E_FAIL;

                hr = m_spSourcesRowset->QueryInterface(IID_IParseDisplayName, (void**)&spParse);
                if (FAILED(hr))
                        return hr;

                hr = spParse->ParseDisplayName(NULL, (LPOLESTR)T2COLE(lpszDisplayName),
                                &chEaten, ppMoniker);
                return hr;
        }

        bool Find(TCHAR* szSearchName)
        {
                USES_CONVERSION;

                WCHAR *pwszSearchName = T2W(szSearchName);
                if( pwszSearchName == NULL )
                        return false;

                // Loop through the providers looking for the passed name
                while (MoveNext()==S_OK && lstrcmpW(m_szName, pwszSearchName))
#ifdef UNICODE
                        ATLTRACE2(atlTraceDBClient, 0, _T("%s, %s, %d\n"), m_szName, m_szParseName, m_nType);
#else
                        ATLTRACE2(atlTraceDBClient, 0, _T("%S, %S, %d\n"), m_szName, m_szParseName, m_nType);
#endif
                if (lstrcmpW(m_szName, pwszSearchName))
                        return false;
                else
                        return true;
        }

        CComPtr<ISourcesRowset> m_spSourcesRowset;
};


///////////////////////////////////////////////////////////////////////////
// CDataSource

class CDataSource
{
public:
        HRESULT Open(const CLSID& clsid, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1)
        {
                HRESULT hr;

                m_spInit.Release();
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IDBInitialize,
                                (void**)&m_spInit);
                if (FAILED(hr))
                        return hr;

                // Initialize the provider
                return OpenWithProperties(pPropSet, nPropertySets);
        }
        HRESULT Open(const CLSID& clsid, LPCTSTR pName, LPCTSTR pUserName = NULL,
                LPCTSTR pPassword = NULL, long nInitMode = 0)
        {
                HRESULT   hr;

                m_spInit.Release();
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IDBInitialize,
                                (void**)&m_spInit);
                if (FAILED(hr))
                        return hr;

                return OpenWithNameUserPassword(pName, pUserName, pPassword, nInitMode);
        }
        HRESULT Open(LPCTSTR szProgID, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1)
        {
                USES_CONVERSION;
                HRESULT hr;
                CLSID   clsid;

                hr = CLSIDFromProgID(T2COLE(szProgID), &clsid);
                if (FAILED(hr))
                        return hr;

                return Open(clsid, pPropSet, nPropertySets);
        }
        HRESULT Open(LPCTSTR szProgID, LPCTSTR pName, LPCTSTR pUserName = NULL,
                LPCTSTR pPassword = NULL, long nInitMode = 0)
        {
                USES_CONVERSION;
                HRESULT hr;
                CLSID   clsid;

                hr = CLSIDFromProgID(T2COLE(szProgID), &clsid);
                if (FAILED(hr))
                        return hr;

                return Open(clsid, pName, pUserName, pPassword, nInitMode);
        }
        HRESULT Open(const CEnumerator& enumerator, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1)
        {
                CComPtr<IMoniker> spMoniker;
                HRESULT   hr;

                hr = enumerator.GetMoniker(&spMoniker);
                if (FAILED(hr))
                        return hr;

                m_spInit.Release();
                //  Now bind the moniker
                hr = BindMoniker(spMoniker, 0, IID_IDBInitialize, (void**)&m_spInit);
                if (FAILED(hr))
                        return hr;

                return OpenWithProperties(pPropSet, nPropertySets);
        }
        HRESULT Open(const CEnumerator& enumerator, LPCTSTR pName, LPCTSTR pUserName = NULL,
                LPCTSTR pPassword = NULL, long nInitMode = 0)
        {
                CComPtr<IMoniker> spMoniker;
                HRESULT   hr;

                hr = enumerator.GetMoniker(&spMoniker);
                if (FAILED(hr))
                        return hr;

                m_spInit.Release();
                //  Now bind the moniker
                hr = BindMoniker(spMoniker, 0, IID_IDBInitialize, (void**)&m_spInit);
                if (FAILED(hr))
                        return hr;

                return OpenWithNameUserPassword(pName, pUserName, pPassword, nInitMode);
        }
        // Invoke the data links dialog and open the selected database
        HRESULT Open(HWND hWnd = GetActiveWindow(), DBPROMPTOPTIONS dwPromptOptions = DBPROMPTOPTIONS_WIZARDSHEET)
        {
                CComPtr<IDBPromptInitialize> spDBInit;

                HRESULT hr = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDBPromptInitialize, (void**) &spDBInit);
                if (FAILED(hr))
                        return hr;

                CComPtr<IDBProperties> spIDBProperties;
                hr = spDBInit->PromptDataSource(NULL, hWnd, dwPromptOptions, 0, NULL, NULL,
                        IID_IDBProperties, (IUnknown**)&spIDBProperties);

                if (hr == S_OK)
                {
                        hr = spIDBProperties->QueryInterface(&m_spInit);
                        if (SUCCEEDED(hr))
                                hr = m_spInit->Initialize();
                }
                else if (hr == S_FALSE)
                        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_CANCELLED);  // The user clicked cancel

                return hr;
        }
        // Opens a data source using the service components
        HRESULT OpenWithServiceComponents(const CLSID& clsid, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1)
        {
                CComPtr<IDataInitialize> spDataInit;
                HRESULT hr;
        
                hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER, 
                        IID_IDataInitialize, (void**)&spDataInit);
                if (FAILED(hr))
                        return hr;

                m_spInit.Release();
                hr = spDataInit->CreateDBInstance(clsid, NULL, CLSCTX_INPROC_SERVER, NULL, 
                        IID_IDBInitialize, (IUnknown**)&m_spInit);
                if (FAILED(hr))
                        return hr;

                // Initialize the provider
                return OpenWithProperties(pPropSet, nPropertySets);
        }
        // Opens a data source using the service components
        HRESULT OpenWithServiceComponents(LPCTSTR szProgID, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1)
        {
                USES_CONVERSION;
                HRESULT hr;
                CLSID   clsid;

                hr = CLSIDFromProgID(T2COLE(szProgID), &clsid);
                if (FAILED(hr))
                        return hr;

                return OpenWithServiceComponents(clsid, pPropSet, nPropertySets);
        }
        // Bring up the "Organize Dialog" which allows the user to select a previously created data link
        // file (.UDL file). The selected file will be used to open the datbase.
        HRESULT OpenWithPromptFileName(HWND hWnd = GetActiveWindow(), DBPROMPTOPTIONS dwPromptOptions = DBPROMPTOPTIONS_NONE,
                LPCOLESTR szInitialDirectory = NULL)
        {
                USES_CONVERSION;
                CComPtr<IDBPromptInitialize> spDBInit;

                HRESULT hr = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDBPromptInitialize, (void**) &spDBInit);
                if (FAILED(hr))
                        return hr;

                CComPtr<IDBProperties> spIDBProperties;
                LPOLESTR szSelected;

                hr = spDBInit->PromptFileName(hWnd, dwPromptOptions, szInitialDirectory, L"*.udl", &szSelected);

                if (hr == S_OK)
                        hr = OpenFromFileName(szSelected);
                else if (hr == S_FALSE)
                        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_CANCELLED);  // The user clicked cancel

                return hr;
        }
        // Open the datasource specified by the passed filename, typically a .UDL file
        HRESULT OpenFromFileName(LPCOLESTR szFileName)
        {
                CComPtr<IDataInitialize> spDataInit;
                LPOLESTR                 szInitString;

                HRESULT hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDataInitialize, (void**)&spDataInit);
                if (FAILED(hr))
                        return hr;

                hr = spDataInit->LoadStringFromStorage(szFileName, &szInitString);
                if (FAILED(hr))
                        return hr;

                return OpenFromInitializationString(szInitString);
        }
        // Open the datasource specified by the passed initialization string
        HRESULT OpenFromInitializationString(LPCOLESTR szInitializationString)
        {
                CComPtr<IDataInitialize> spDataInit;

                HRESULT hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDataInitialize, (void**)&spDataInit);
                if (FAILED(hr))
                        return hr;

                CComPtr<IDBProperties> spIDBProperties;
                hr = spDataInit->GetDataSource(NULL, CLSCTX_INPROC_SERVER, szInitializationString,
                        IID_IDBInitialize, (IUnknown**)&m_spInit);
                if (FAILED(hr))
                        return hr;

                return m_spInit->Initialize();
        }
        // Get the initialization string from the currently open data source. The returned string
        // must be CoTaskMemFree'd when finished with.
        HRESULT GetInitializationString(BSTR* pInitializationString, bool bIncludePassword=false)
        {
                // If the datasource isn't open then we're not going to get an init string
                _ASSERTE(m_spInit != NULL);
                CComPtr<IDataInitialize> spDataInit;
                LPOLESTR    szInitString;

                HRESULT hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDataInitialize, (void**)&spDataInit);
                if (FAILED(hr))
                        return hr;

                hr = spDataInit->GetInitializationString(m_spInit, bIncludePassword, &szInitString);

                if (SUCCEEDED(hr))
                        *pInitializationString = ::SysAllocString(szInitString);

                return hr;
        }
        HRESULT GetProperties(ULONG ulPropIDSets, const DBPROPIDSET* pPropIDSet,
                                ULONG* pulPropertySets, DBPROPSET** ppPropsets) const
        {
                CComPtr<IDBProperties> spProperties;

                // Check that we are connected
                ATLASSERT(m_spInit != NULL);

                HRESULT hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spProperties);
                if (FAILED(hr))
                        return hr;

                hr = spProperties->GetProperties(ulPropIDSets, pPropIDSet, pulPropertySets,
                                ppPropsets);
                return hr;
        }

        HRESULT GetProperty(const GUID& guid, DBPROPID propid, VARIANT* pVariant) const
        {
                ATLASSERT(pVariant != NULL);
                CComPtr<IDBProperties> spProperties;

                // Check that we are connected
                ATLASSERT(m_spInit != NULL);

                HRESULT hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spProperties);
                if (FAILED(hr))
                        return hr;

                CDBPropIDSet set(guid);
                set.AddPropertyID(propid);
                DBPROPSET* pPropSet = NULL;
                ULONG ulPropSet = 0;
                hr = spProperties->GetProperties(1, &set, &ulPropSet, &pPropSet);
                if (FAILED(hr))
                        return hr;

                ATLASSERT(ulPropSet == 1);
                hr = VariantCopy(pVariant, &pPropSet->rgProperties[0].vValue);
                CoTaskMemFree(pPropSet->rgProperties);
                CoTaskMemFree(pPropSet);

                return hr;
        }
        void Close()
        {
                m_spInit.Release();
        }

// Implementation
        HRESULT OpenFromIDBProperties(IDBProperties* pIDBProperties)
        {
                CComPtr<IPersist> spPersist;
                CLSID   clsid;
                HRESULT hr;

                hr = pIDBProperties->QueryInterface(IID_IPersist, (void**)&spPersist);
                if (FAILED(hr))
                        return hr;

                spPersist->GetClassID(&clsid);

                ULONG       ulPropSets=0;
                CDBPropSet* pPropSets=NULL;
                pIDBProperties->GetProperties(0, NULL, &ulPropSets, (DBPROPSET**)&pPropSets);

                hr = Open(clsid, &pPropSets[0], ulPropSets);

                for (ULONG i=0; i < ulPropSets; i++)
                        (pPropSets+i)->~CDBPropSet();
                CoTaskMemFree(pPropSets);

                return hr;
        }
        HRESULT OpenWithNameUserPassword(LPCTSTR pName, LPCTSTR pUserName, LPCTSTR pPassword, long nInitMode = 0)
        {
                ATLASSERT(m_spInit != NULL);
                CComPtr<IDBProperties>  spProperties;
                HRESULT                 hr;

                hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spProperties);
                if (FAILED(hr))
                        return hr;

                // Set connection properties
                CDBPropSet propSet(DBPROPSET_DBINIT);

                // Add Datbase name, User name and Password
                if (pName != NULL)
                        propSet.AddProperty(DBPROP_INIT_DATASOURCE, pName);

                if (pUserName != NULL)
                        propSet.AddProperty(DBPROP_AUTH_USERID, pUserName);

                if (pPassword != NULL)
                        propSet.AddProperty(DBPROP_AUTH_PASSWORD, pPassword);

                if (nInitMode)
                        propSet.AddProperty(DBPROP_INIT_MODE, nInitMode);

                hr = spProperties->SetProperties(1, &propSet);
                if (FAILED(hr))
                        return hr;

                // Initialize the provider
                return m_spInit->Initialize();
        }
        HRESULT OpenWithProperties(DBPROPSET* pPropSet, ULONG nPropertySets=1)
        {
                ATLASSERT(m_spInit != NULL);

                // Set the properties if there are some to set
                if (pPropSet != NULL)
                {
                        CComPtr<IDBProperties>  spProperties;
                        HRESULT                 hr;

                        hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spProperties);
                        if (FAILED(hr))
                                return hr;

                        hr = spProperties->SetProperties(nPropertySets, pPropSet);
                        if (FAILED(hr))
                                return hr;
                }

                // Initialize the provider
                return m_spInit->Initialize();
        }

        CComPtr<IDBInitialize>  m_spInit;
};


///////////////////////////////////////////////////////////////////////////
// class CSession

class CSession
{
public:
        // Create a session on the passed datasource
        HRESULT Open(const CDataSource& ds, DBPROPSET *pPropSet = NULL, ULONG ulPropSets = 0)
        {
                CComPtr<IDBCreateSession> spSession;

                // Check we have connected to the database
                ATLASSERT(ds.m_spInit != NULL);

                HRESULT hr = ds.m_spInit->QueryInterface(IID_IDBCreateSession, (void**)&spSession);
                if (FAILED(hr))
                        return hr;

                hr = spSession->CreateSession(NULL, IID_IOpenRowset, (IUnknown**)&m_spOpenRowset);

                if( pPropSet != NULL && SUCCEEDED(hr) && m_spOpenRowset != NULL )
                {
                        // If the user didn't specify the default parameter, use one
                        if (pPropSet != NULL && ulPropSets == 0)
                                ulPropSets = 1;

                        CComPtr<ISessionProperties> spSessionProperties;
                        hr = m_spOpenRowset->QueryInterface(__uuidof(ISessionProperties), (void**)&spSessionProperties);
                        if(FAILED(hr))
                                return hr;

                        hr = spSessionProperties->SetProperties( ulPropSets, pPropSet );
                }
                return hr;
        }

        // Close the session
        void Close()
        {
                m_spOpenRowset.Release();
        }
        // Start a transaction
        HRESULT StartTransaction(ISOLEVEL isoLevel = ISOLATIONLEVEL_READCOMMITTED, ULONG isoFlags = 0,
                ITransactionOptions* pOtherOptions = NULL, ULONG* pulTransactionLevel = NULL) const
        {
                ATLASSERT(m_spOpenRowset != NULL);
                CComPtr<ITransactionLocal> spTransactionLocal;
                HRESULT hr = m_spOpenRowset->QueryInterface(&spTransactionLocal);

                if (SUCCEEDED(hr))
                        hr = spTransactionLocal->StartTransaction(isoLevel, isoFlags, pOtherOptions, pulTransactionLevel);

                return hr;
        }
        // Abort the current transaction
        HRESULT Abort(BOID* pboidReason = NULL, BOOL bRetaining = FALSE, BOOL bAsync = FALSE) const
        {
                ATLASSERT(m_spOpenRowset != NULL);
                CComPtr<ITransaction> spTransaction;
                HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

                if (SUCCEEDED(hr))
                        hr = spTransaction->Abort(pboidReason, bRetaining, bAsync);

                return hr;
        }
        // Commit the current transaction
        HRESULT Commit(BOOL bRetaining = FALSE, DWORD grfTC = XACTTC_SYNC, DWORD grfRM = 0) const
        {
                ATLASSERT(m_spOpenRowset != NULL);
                CComPtr<ITransaction> spTransaction;
                HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

                if (SUCCEEDED(hr))
                        hr = spTransaction->Commit(bRetaining, grfTC, grfRM);

                return hr;
        }
        // Get information for the current transaction
        HRESULT GetTransactionInfo(XACTTRANSINFO* pInfo) const
        {
                ATLASSERT(m_spOpenRowset != NULL);
                CComPtr<ITransaction> spTransaction;
                HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

                if (SUCCEEDED(hr))
                        hr = spTransaction->GetTransactionInfo(pInfo);

                return hr;
        }
// Implementation
        CComPtr<IOpenRowset> m_spOpenRowset;
};


///////////////////////////////////////////////////////////////////////////
// CTable

template <class TAccessor = CNoAccessor, class TRowset = CRowset>
class CTable :
        public CAccessorRowset<TAccessor, TRowset>
{
public:
        // Open a rowset on the passed name
        HRESULT Open(const CSession& session, LPCTSTR szTableName, DBPROPSET* pPropSet = NULL)
        {
                USES_CONVERSION;
                DBID    idTable;

                idTable.eKind           = DBKIND_NAME;
                idTable.uName.pwszName  = (LPOLESTR)T2COLE(szTableName);

                return Open(session, idTable, pPropSet);
        }
        // Open the a rowset on the passed DBID
        HRESULT Open(const CSession& session, DBID& dbid, DBPROPSET* pPropSet = NULL)
        {
                // Check the session is valid
                ATLASSERT(session.m_spOpenRowset != NULL);
                HRESULT hr;

                hr = session.m_spOpenRowset->OpenRowset(NULL, &dbid, NULL, GetIID(),
                        (pPropSet) ? 1 : 0, pPropSet, (IUnknown**)GetInterfacePtr());
                if (SUCCEEDED(hr))
                {
                        SetupOptionalRowsetInterfaces();

                        // If we have output columns then bind
                        if (_OutputColumnsClass::HasOutputColumns())
                                hr = Bind();
                }

                return hr;
        }
};

#if (OLEDBVER < 0x0150)
#define DBGUID_DEFAULT DBGUID_DBSQL
#endif


///////////////////////////////////////////////////////////////////////////
// CCommandBase

class CCommandBase
{
public:
        CCommandBase()
        {
                m_hParameterAccessor = NULL;
        }

        ~CCommandBase()
        {
                ReleaseCommand();
        }
        // Create the command
        HRESULT CreateCommand(const CSession& session)
        {
                // Before creating the command, release the old one if necessary.
                ReleaseCommand();

                // Check the session is valid
                ATLASSERT(session.m_spOpenRowset != NULL);

                CComPtr<IDBCreateCommand> spCreateCommand;

                HRESULT hr = session.m_spOpenRowset->QueryInterface(IID_IDBCreateCommand, (void**)&spCreateCommand);
                if (FAILED(hr))
                        return hr;

                return spCreateCommand->CreateCommand(NULL, IID_ICommand, (IUnknown**)&m_spCommand);
        }
        // Prepare the command
        HRESULT Prepare(ULONG cExpectedRuns = 0)
        {
                CComPtr<ICommandPrepare> spCommandPrepare;
                HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
                if (SUCCEEDED(hr))
                        hr = spCommandPrepare->Prepare(cExpectedRuns);

                return hr;
        }
        // Unprepare the command
        HRESULT Unprepare()
        {
                CComPtr<ICommandPrepare> spCommandPrepare;
                HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
                if (SUCCEEDED(hr))
                        hr = spCommandPrepare->Unprepare();

                return hr;
        }
        // Create the command and set the command text
        HRESULT Create(const CSession& session, LPCTSTR szCommand,
                REFGUID guidCommand = DBGUID_DEFAULT)
        {
                USES_CONVERSION;
                HRESULT hr;

                hr = CreateCommand(session);
                if (SUCCEEDED(hr))
                {
                        CComPtr<ICommandText> spCommandText;
                        hr = m_spCommand->QueryInterface(&spCommandText);
                        if (SUCCEEDED(hr))
                                hr = spCommandText->SetCommandText(guidCommand, T2COLE(szCommand));
                }
                return hr;
        }
        // Release the command
        void ReleaseCommand()
        {
                // Release the parameter accessor if necessary, before releasing the command
                if (m_hParameterAccessor != NULL)
                {
                        CComPtr<IAccessor> spAccessor;
                        HRESULT hr = m_spCommand->QueryInterface(&spAccessor);
                        if (SUCCEEDED(hr))
                        {
                                spAccessor->ReleaseAccessor(m_hParameterAccessor, NULL); \
                                m_hParameterAccessor = NULL;
                        }
                }
                m_spCommand.Release();
        }
        // Get the parameter information from the command
        HRESULT GetParameterInfo(ULONG_PTR* pParams, DBPARAMINFO** ppParamInfo,
                                OLECHAR** ppNamesBuffer)
        {
                CComPtr<ICommandWithParameters> spCommandParameters;
                HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
                if (SUCCEEDED(hr))
                {
                        // Get the parameter information
                        hr = spCommandParameters->GetParameterInfo(pParams, ppParamInfo,
                                        ppNamesBuffer);
                }
                return hr;
        }
        // Set the parameter information for the command
        HRESULT SetParameterInfo(ULONG_PTR ulParams, const ULONG_PTR* pOrdinals,
                                const DBPARAMBINDINFO* pParamInfo)
        {
                CComPtr<ICommandWithParameters> spCommandParameters;
                HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
                if (SUCCEEDED(hr))
                {
                        // Set the parameter information
                        hr = spCommandParameters->SetParameterInfo(ulParams, pOrdinals,
                                pParamInfo);
                }
                return hr;
        }

        CComPtr<ICommand>   m_spCommand;
        HACCESSOR           m_hParameterAccessor;
};

// Used to turn on multiple result set support in CCommand
class CMultipleResults
{
public:
        bool UseMultipleResults() { return true; }
        IMultipleResults** GetMultiplePtrAddress() { return &m_spMultipleResults.p; }
        IMultipleResults* GetMultiplePtr() { return m_spMultipleResults; }

        CComPtr<IMultipleResults> m_spMultipleResults;
};

// Used to turn off multiple result set support in CCommand
class CNoMultipleResults
{
public:
        bool UseMultipleResults() { return false; }
        IMultipleResults** GetMultiplePtrAddress() { return NULL; }
        IMultipleResults* GetMultiplePtr() { return NULL; }
};


///////////////////////////////////////////////////////////////////////////
// CCommand

template <class TAccessor = CNoAccessor, class TRowset = CRowset, class TMultiple = CNoMultipleResults>
class CCommand :
        public CAccessorRowset<TAccessor, TRowset>,
        public CCommandBase,
        public TMultiple
{
public:
        // Create a command on the session and execute it
        HRESULT Open(const CSession& session, LPCTSTR szCommand = NULL,
                DBPROPSET *pPropSet = NULL, LONG_PTR* pRowsAffected = NULL,
                REFGUID guidCommand = DBGUID_DEFAULT, bool bBind = true)
        {
                HRESULT hr;
                if (szCommand == NULL)
                {
                        hr = _CommandClass::GetDefaultCommand(&szCommand);
                        if (FAILED(hr))
                                return hr;
                }
                hr = Create(session, szCommand, guidCommand);
                if (FAILED(hr))
                        return hr;

                return Open(pPropSet, pRowsAffected, bBind);
        }
        // Used if you have previously created the command
        HRESULT Open(DBPROPSET *pPropSet = NULL, LONG_PTR* pRowsAffected = NULL, bool bBind = true)
        {
                HRESULT     hr;
                DBPARAMS    params;
                DBPARAMS    *pParams;

                // Bind the parameters if we have some
                if (_ParamClass::HasParameters())
                {
                        // Bind the parameters in the accessor if they haven't already been bound
                        hr = BindParameters(&m_hParameterAccessor, m_spCommand, &params.pData);
                        if (FAILED(hr))
                                return hr;

                        // Setup the DBPARAMS structure
                        params.cParamSets = 1;
                        params.hAccessor = m_hParameterAccessor;
                        pParams = &params;
                }
                else
                        pParams = NULL;

                hr = Execute(GetInterfacePtr(), pParams, pPropSet, pRowsAffected);
                if (FAILED(hr))
                        return hr;

                // Only bind if we have been asked to and we have output columns
                if (bBind && _OutputColumnsClass::HasOutputColumns())
                        return Bind();
                else
                        return hr;
        }
        // Get the next rowset when using multiple result sets
        HRESULT GetNextResult(LONG_PTR* pulRowsAffected, bool bBind = true)
        {
                // This function should only be called if CMultipleResults is being
                // used as the third template parameter
                ATLASSERT(GetMultiplePtrAddress() != NULL);

                // If user calls GetNextResult but the interface is not available
                // return E_FAIL.
                if (GetMultiplePtr() == NULL)
                        return E_FAIL;

                // Close the existing rowset in preparation for opening the next one
                Close();

                HRESULT hr = GetMultiplePtr()->GetResult(NULL, 0, IID_IRowset,
                        pulRowsAffected, (IUnknown**)GetInterfacePtr());
                if (FAILED(hr))
                        return hr;

                if (bBind && GetInterface() != NULL)
                        return Bind();
                else
                        return hr;
        }

// Implementation
        HRESULT Execute(IRowset** ppRowset, DBPARAMS* pParams, DBPROPSET *pPropSet, LONG_PTR* pRowsAffected)
        {
                HRESULT hr;

                // Specify the properties if we have some
                if (pPropSet)
                {
                        CComPtr<ICommandProperties> spCommandProperties;
                        hr = m_spCommand->QueryInterface(&spCommandProperties);
                        if (FAILED(hr))
                                return hr;

                        hr = spCommandProperties->SetProperties(1, pPropSet);
                        if (FAILED(hr))
                                return hr;
                }

                // If the user want the rows affected then return it back, otherwise
                // just point to our local variable here.
                LONG_PTR nAffected, *pAffected;
                if (pRowsAffected)
                        pAffected = pRowsAffected;
                else
                        pAffected = &nAffected;

                if (UseMultipleResults())
                {
                        hr = m_spCommand->Execute(NULL, IID_IMultipleResults, pParams,
                                pAffected, (IUnknown**)GetMultiplePtrAddress());

                        if (SUCCEEDED(hr))
                        {
                                hr = GetNextResult(pAffected, false);
                        }
                        else
                        {
                                // If we can't get IMultipleResults then just try to get IRowset
                                hr = m_spCommand->Execute(NULL, IID_IRowset, pParams, pAffected,
                                        (IUnknown**)GetInterfacePtr());
                        }
                }
                else
                {
                        hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
                                (IUnknown**)ppRowset);
                        if (SUCCEEDED(hr))
                                SetupOptionalRowsetInterfaces();
                }
                return hr;
        }
};


// This class can be used to implement the IRowsetNotify interface.
// It is supplied so that if you only want to implement one of the
// notifications you don't have to supply empty functions for the
// other methods.
class ATL_NO_VTABLE IRowsetNotifyImpl : public IRowsetNotify
{
public:
        STDMETHOD(OnFieldChange)(
                        /* [in] */ IRowset* /* pRowset */,
                        /* [in] */ HROW /* hRow */,
                        /* [in] */ DBORDINAL /* cColumns */,
                        /* [size_is][in] */ DBORDINAL /* rgColumns*/ [] ,
                        /* [in] */ DBREASON /* eReason */,
                        /* [in] */ DBEVENTPHASE /* ePhase */,
                        /* [in] */ BOOL /* fCantDeny */)
        {
                ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnFieldChange"));
        }
        STDMETHOD(OnRowChange)(
                        /* [in] */ IRowset* /* pRowset */,
                        /* [in] */ DBCOUNTITEM /* cRows */,
                        /* [size_is][in] */ const HROW /* rghRows*/ [] ,
                        /* [in] */ DBREASON /* eReason */,
                        /* [in] */ DBEVENTPHASE /* ePhase */,
                        /* [in] */ BOOL /* fCantDeny */)
        {
                ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnRowChange"));
        }
        STDMETHOD(OnRowsetChange)(
                /* [in] */ IRowset* /* pRowset */,
                /* [in] */ DBREASON /* eReason */,
                /* [in] */ DBEVENTPHASE /* ePhase */,
                /* [in] */ BOOL /* fCantDeny*/)
        {
                ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnRowsetChange"));
        }
};

}; //namespace ATL

#endif // __ATLDBCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atliface.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Nov 30 13:38:38 2001
 */
/* Compiler settings for atliface.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __atliface_h__
#define __atliface_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRegistrar_FWD_DEFINED__
#define __IRegistrar_FWD_DEFINED__
typedef interface IRegistrar IRegistrar;
#endif         /* __IRegistrar_FWD_DEFINED__ */


#ifndef __IDocHostUIHandlerDispatch_FWD_DEFINED__
#define __IDocHostUIHandlerDispatch_FWD_DEFINED__
typedef interface IDocHostUIHandlerDispatch IDocHostUIHandlerDispatch;
#endif         /* __IDocHostUIHandlerDispatch_FWD_DEFINED__ */


#ifndef __IAxWinHostWindow_FWD_DEFINED__
#define __IAxWinHostWindow_FWD_DEFINED__
typedef interface IAxWinHostWindow IAxWinHostWindow;
#endif         /* __IAxWinHostWindow_FWD_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_FWD_DEFINED__
#define __IAxWinAmbientDispatch_FWD_DEFINED__
typedef interface IAxWinAmbientDispatch IAxWinAmbientDispatch;
#endif         /* __IAxWinAmbientDispatch_FWD_DEFINED__ */


#ifndef __IInternalConnection_FWD_DEFINED__
#define __IInternalConnection_FWD_DEFINED__
typedef interface IInternalConnection IInternalConnection;
#endif         /* __IInternalConnection_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_atliface_0000 */
/* [local] */ 

EXTERN_C const CLSID CLSID_Registrar;


extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_s_ifspec;

#ifndef __IRegistrar_INTERFACE_DEFINED__
#define __IRegistrar_INTERFACE_DEFINED__

/* interface IRegistrar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44EC053B-400F-11D0-9DCD-00A0C90391D3")
    IRegistrar : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddReplacement( 
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceRegisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceUnregisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FileRegister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FileUnregister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StringRegister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StringUnregister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceRegister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceUnregister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
    };
    
#else         /* C style interface */

    typedef struct IRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRegistrar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRegistrar __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddReplacement )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearReplacements )( 
            IRegistrar __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceRegisterSz )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceUnregisterSz )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR fileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR fileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StringRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StringUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        END_INTERFACE
    } IRegistrarVtbl;

    interface IRegistrar
    {
        CONST_VTBL struct IRegistrarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistrar_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrar_AddRef(This)        \
    (This)->lpVtbl -> AddRef(This)

#define IRegistrar_Release(This)        \
    (This)->lpVtbl -> Release(This)


#define IRegistrar_AddReplacement(This,key,item)        \
    (This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrar_ClearReplacements(This)        \
    (This)->lpVtbl -> ClearReplacements(This)

#define IRegistrar_ResourceRegisterSz(This,resFileName,szID,szType)        \
    (This)->lpVtbl -> ResourceRegisterSz(This,resFileName,szID,szType)

#define IRegistrar_ResourceUnregisterSz(This,resFileName,szID,szType)        \
    (This)->lpVtbl -> ResourceUnregisterSz(This,resFileName,szID,szType)

#define IRegistrar_FileRegister(This,fileName)        \
    (This)->lpVtbl -> FileRegister(This,fileName)

#define IRegistrar_FileUnregister(This,fileName)        \
    (This)->lpVtbl -> FileUnregister(This,fileName)

#define IRegistrar_StringRegister(This,data)        \
    (This)->lpVtbl -> StringRegister(This,data)

#define IRegistrar_StringUnregister(This,data)        \
    (This)->lpVtbl -> StringUnregister(This,data)

#define IRegistrar_ResourceRegister(This,resFileName,nID,szType)        \
    (This)->lpVtbl -> ResourceRegister(This,resFileName,nID,szType)

#define IRegistrar_ResourceUnregister(This,resFileName,nID,szType)        \
    (This)->lpVtbl -> ResourceUnregister(This,resFileName,nID,szType)

#endif /* COBJMACROS */


#endif         /* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_AddReplacement_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR key,
    /* [in] */ LPCOLESTR item);


void __RPC_STUB IRegistrar_AddReplacement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ClearReplacements_Proxy( 
    IRegistrar __RPC_FAR * This);


void __RPC_STUB IRegistrar_ClearReplacements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegisterSz_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregisterSz_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_FileRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_FileUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_StringRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_StringUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif         /* __IRegistrar_INTERFACE_DEFINED__ */


#ifndef __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__
#define __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__

/* interface IDocHostUIHandlerDispatch */
/* [object][unique][helpstring][uuid] */ 

typedef 
enum tagDOCHOSTUIDBLCLKDispatch
    {        docHostUIDblClkDEFAULT        = 0,
        docHostUIDblClkSHOWPROPERTIES        = 1,
        docHostUIDblClkSHOWCODE        = 2
    }        DOCHOSTUIDBLCLKDispatch;

typedef 
enum tagDocHostUIFlagDispatch
    {        docHostUIFlagDIALOG        = 1,
        docHostUIFlagDISABLE_HELP_MENU        = 2,
        docHostUIFlagNO3DBORDER        = 4,
        docHostUIFlagSCROLL_NO        = 8,
        docHostUIFlagDISABLE_SCRIPT_INACTIVE        = 16,
        docHostUIFlagOPENNEWWIN        = 32,
        docHostUIFlagDISABLE_OFFSCREEN        = 64,
        docHostUIFlagFLAT_SCROLLBAR        = 128,
        docHostUIFlagDIV_BLOCKDEFAULT        = 256,
        docHostUIFlagACTIVATE_CLIENTHIT_ONLY        = 512
    }        DocHostUIFlagDispatch;


EXTERN_C const IID IID_IDocHostUIHandlerDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("425B5AF0-65F1-11d1-9611-0000F81E0D0D")
    IDocHostUIHandlerDispatch : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            /* [in] */ DWORD dwID,
            /* [in] */ DWORD x,
            /* [in] */ DWORD y,
            /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
            /* [in] */ IDispatch __RPC_FAR *pdispReserved,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostInfo( 
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
            /* [out][in] */ DWORD __RPC_FAR *pdwDoubleClick) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowUI( 
            /* [in] */ DWORD dwID,
            /* [in] */ IUnknown __RPC_FAR *pActiveObject,
            /* [in] */ IUnknown __RPC_FAR *pCommandTarget,
            /* [in] */ IUnknown __RPC_FAR *pFrame,
            /* [in] */ IUnknown __RPC_FAR *pDoc,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideUI( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateUI( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate( 
            /* [in] */ VARIANT_BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate( 
            /* [in] */ VARIANT_BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom,
            /* [in] */ IUnknown __RPC_FAR *pUIWindow,
            /* [in] */ VARIANT_BOOL fFrameWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ DWORD hWnd,
            /* [in] */ DWORD nMessage,
            /* [in] */ DWORD wParam,
            /* [in] */ DWORD lParam,
            /* [in] */ BSTR bstrGuidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath( 
            /* [out] */ BSTR __RPC_FAR *pbstrKey,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
            /* [in] */ IUnknown __RPC_FAR *pDropTarget,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDropTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExternal( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ BSTR bstrURLIn,
            /* [out] */ BSTR __RPC_FAR *pbstrURLOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterDataObject( 
            /* [in] */ IUnknown __RPC_FAR *pDO,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDORet) = 0;
        
    };
    
#else         /* C style interface */

    typedef struct IDocHostUIHandlerDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [in] */ DWORD x,
            /* [in] */ DWORD y,
            /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
            /* [in] */ IDispatch __RPC_FAR *pdispReserved,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHostInfo )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
            /* [out][in] */ DWORD __RPC_FAR *pdwDoubleClick);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowUI )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [in] */ IUnknown __RPC_FAR *pActiveObject,
            /* [in] */ IUnknown __RPC_FAR *pCommandTarget,
            /* [in] */ IUnknown __RPC_FAR *pFrame,
            /* [in] */ IUnknown __RPC_FAR *pDoc,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HideUI )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateUI )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableModeless )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDocWindowActivate )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnFrameWindowActivate )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResizeBorder )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom,
            /* [in] */ IUnknown __RPC_FAR *pUIWindow,
            /* [in] */ VARIANT_BOOL fFrameWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateAccelerator )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DWORD hWnd,
            /* [in] */ DWORD nMessage,
            /* [in] */ DWORD wParam,
            /* [in] */ DWORD lParam,
            /* [in] */ BSTR bstrGuidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptionKeyPath )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrKey,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDropTarget )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDropTarget,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDropTarget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExternal )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateUrl )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwTranslate,
            /* [in] */ BSTR bstrURLIn,
            /* [out] */ BSTR __RPC_FAR *pbstrURLOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterDataObject )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDO,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDORet);
        
        END_INTERFACE
    } IDocHostUIHandlerDispatchVtbl;

    interface IDocHostUIHandlerDispatch
    {
        CONST_VTBL struct IDocHostUIHandlerDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocHostUIHandlerDispatch_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocHostUIHandlerDispatch_AddRef(This)        \
    (This)->lpVtbl -> AddRef(This)

#define IDocHostUIHandlerDispatch_Release(This)        \
    (This)->lpVtbl -> Release(This)


#define IDocHostUIHandlerDispatch_GetTypeInfoCount(This,pctinfo)        \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDocHostUIHandlerDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)        \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDocHostUIHandlerDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)        \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDocHostUIHandlerDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)        \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDocHostUIHandlerDispatch_ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)        \
    (This)->lpVtbl -> ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)

#define IDocHostUIHandlerDispatch_GetHostInfo(This,pdwFlags,pdwDoubleClick)        \
    (This)->lpVtbl -> GetHostInfo(This,pdwFlags,pdwDoubleClick)

#define IDocHostUIHandlerDispatch_ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)        \
    (This)->lpVtbl -> ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)

#define IDocHostUIHandlerDispatch_HideUI(This)        \
    (This)->lpVtbl -> HideUI(This)

#define IDocHostUIHandlerDispatch_UpdateUI(This)        \
    (This)->lpVtbl -> UpdateUI(This)

#define IDocHostUIHandlerDispatch_EnableModeless(This,fEnable)        \
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#define IDocHostUIHandlerDispatch_OnDocWindowActivate(This,fActivate)        \
    (This)->lpVtbl -> OnDocWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_OnFrameWindowActivate(This,fActivate)        \
    (This)->lpVtbl -> OnFrameWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)        \
    (This)->lpVtbl -> ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)

#define IDocHostUIHandlerDispatch_TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)        \
    (This)->lpVtbl -> TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)

#define IDocHostUIHandlerDispatch_GetOptionKeyPath(This,pbstrKey,dw)        \
    (This)->lpVtbl -> GetOptionKeyPath(This,pbstrKey,dw)

#define IDocHostUIHandlerDispatch_GetDropTarget(This,pDropTarget,ppDropTarget)        \
    (This)->lpVtbl -> GetDropTarget(This,pDropTarget,ppDropTarget)

#define IDocHostUIHandlerDispatch_GetExternal(This,ppDispatch)        \
    (This)->lpVtbl -> GetExternal(This,ppDispatch)

#define IDocHostUIHandlerDispatch_TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)        \
    (This)->lpVtbl -> TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)

#define IDocHostUIHandlerDispatch_FilterDataObject(This,pDO,ppDORet)        \
    (This)->lpVtbl -> FilterDataObject(This,pDO,ppDORet)

#endif /* COBJMACROS */


#endif         /* C style interface */



HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowContextMenu_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [in] */ DWORD x,
    /* [in] */ DWORD y,
    /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
    /* [in] */ IDispatch __RPC_FAR *pdispReserved,
    /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetHostInfo_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwDoubleClick);


void __RPC_STUB IDocHostUIHandlerDispatch_GetHostInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowUI_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [in] */ IUnknown __RPC_FAR *pActiveObject,
    /* [in] */ IUnknown __RPC_FAR *pCommandTarget,
    /* [in] */ IUnknown __RPC_FAR *pFrame,
    /* [in] */ IUnknown __RPC_FAR *pDoc,
    /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_HideUI_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This);


void __RPC_STUB IDocHostUIHandlerDispatch_HideUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_UpdateUI_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This);


void __RPC_STUB IDocHostUIHandlerDispatch_UpdateUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_EnableModeless_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB IDocHostUIHandlerDispatch_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnDocWindowActivate_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnDocWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnFrameWindowActivate_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnFrameWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ResizeBorder_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ long left,
    /* [in] */ long top,
    /* [in] */ long right,
    /* [in] */ long bottom,
    /* [in] */ IUnknown __RPC_FAR *pUIWindow,
    /* [in] */ VARIANT_BOOL fFrameWindow);


void __RPC_STUB IDocHostUIHandlerDispatch_ResizeBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateAccelerator_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ DWORD hWnd,
    /* [in] */ DWORD nMessage,
    /* [in] */ DWORD wParam,
    /* [in] */ DWORD lParam,
    /* [in] */ BSTR bstrGuidCmdGroup,
    /* [in] */ DWORD nCmdID,
    /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetOptionKeyPath_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrKey,
    /* [in] */ DWORD dw);


void __RPC_STUB IDocHostUIHandlerDispatch_GetOptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetDropTarget_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDropTarget,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDropTarget);


void __RPC_STUB IDocHostUIHandlerDispatch_GetDropTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetExternal_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IDocHostUIHandlerDispatch_GetExternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateUrl_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwTranslate,
    /* [in] */ BSTR bstrURLIn,
    /* [out] */ BSTR __RPC_FAR *pbstrURLOut);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_FilterDataObject_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDO,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDORet);


void __RPC_STUB IDocHostUIHandlerDispatch_FilterDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif         /* __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__ */


#ifndef __IAxWinHostWindow_INTERFACE_DEFINED__
#define __IAxWinHostWindow_INTERFACE_DEFINED__

/* interface IAxWinHostWindow */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAxWinHostWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6EA2050-048A-11d1-82B9-00C04FB9942E")
    IAxWinHostWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateControl( 
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateControlEx( 
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown __RPC_FAR *punkAdvise) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AttachControl( 
            /* [in] */ IUnknown __RPC_FAR *pUnkControl,
            /* [in] */ HWND hWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryControl( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExternalDispatch( 
            /* [in] */ IDispatch __RPC_FAR *pDisp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExternalUIHandler( 
            /* [in] */ IDocHostUIHandlerDispatch __RPC_FAR *pDisp) = 0;
        
    };
    
#else         /* C style interface */

    typedef struct IAxWinHostWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAxWinHostWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAxWinHostWindow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateControl )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateControlEx )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown __RPC_FAR *punkAdvise);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachControl )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkControl,
            /* [in] */ HWND hWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryControl )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExternalDispatch )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pDisp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExternalUIHandler )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ IDocHostUIHandlerDispatch __RPC_FAR *pDisp);
        
        END_INTERFACE
    } IAxWinHostWindowVtbl;

    interface IAxWinHostWindow
    {
        CONST_VTBL struct IAxWinHostWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAxWinHostWindow_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinHostWindow_AddRef(This)        \
    (This)->lpVtbl -> AddRef(This)

#define IAxWinHostWindow_Release(This)        \
    (This)->lpVtbl -> Release(This)


#define IAxWinHostWindow_CreateControl(This,lpTricsData,hWnd,pStream)        \
    (This)->lpVtbl -> CreateControl(This,lpTricsData,hWnd,pStream)

#define IAxWinHostWindow_CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)        \
    (This)->lpVtbl -> CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)

#define IAxWinHostWindow_AttachControl(This,pUnkControl,hWnd)        \
    (This)->lpVtbl -> AttachControl(This,pUnkControl,hWnd)

#define IAxWinHostWindow_QueryControl(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryControl(This,riid,ppvObject)

#define IAxWinHostWindow_SetExternalDispatch(This,pDisp)        \
    (This)->lpVtbl -> SetExternalDispatch(This,pDisp)

#define IAxWinHostWindow_SetExternalUIHandler(This,pDisp)        \
    (This)->lpVtbl -> SetExternalUIHandler(This,pDisp)

#endif /* COBJMACROS */


#endif         /* C style interface */



HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControl_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ LPCOLESTR lpTricsData,
    /* [in] */ HWND hWnd,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IAxWinHostWindow_CreateControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControlEx_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ LPCOLESTR lpTricsData,
    /* [in] */ HWND hWnd,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
    /* [in] */ REFIID riidAdvise,
    /* [in] */ IUnknown __RPC_FAR *punkAdvise);


void __RPC_STUB IAxWinHostWindow_CreateControlEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_AttachControl_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkControl,
    /* [in] */ HWND hWnd);


void __RPC_STUB IAxWinHostWindow_AttachControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_QueryControl_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IAxWinHostWindow_QueryControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalDispatch_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalDispatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalUIHandler_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ IDocHostUIHandlerDispatch __RPC_FAR *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalUIHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif         /* __IAxWinHostWindow_INTERFACE_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_INTERFACE_DEFINED__
#define __IAxWinAmbientDispatch_INTERFACE_DEFINED__

/* interface IAxWinAmbientDispatch */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_IAxWinAmbientDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6EA2051-048A-11d1-82B9-00C04FB9942E")
    IAxWinAmbientDispatch : public IDispatch
    {
    public:
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowWindowlessActivation( 
            /* [in] */ VARIANT_BOOL bCanWindowlessActivate) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowWindowlessActivation( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanWindowlessActivate) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clrBackground) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrBackground) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ OLE_COLOR clrForeground) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrForeground) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocaleID( 
            /* [in] */ LCID lcidLocaleID) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocaleID( 
            /* [retval][out] */ LCID __RPC_FAR *plcidLocaleID) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UserMode( 
            /* [in] */ VARIANT_BOOL bUserMode) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbUserMode) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayAsDefault( 
            /* [in] */ VARIANT_BOOL bDisplayAsDefault) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayAsDefault( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbDisplayAsDefault) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
            /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *pFont) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MessageReflect( 
            /* [in] */ VARIANT_BOOL bMsgReflect) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MessageReflect( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbMsgReflect) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowGrabHandles( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowGrabHandles) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowHatching( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowHatching) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostFlags( 
            /* [in] */ DWORD dwDocHostFlags) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostFlags( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostFlags) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostDoubleClickFlags( 
            /* [in] */ DWORD dwDocHostDoubleClickFlags) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostDoubleClickFlags( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostDoubleClickFlags) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowContextMenu( 
            /* [in] */ VARIANT_BOOL bAllowContextMenu) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowContextMenu( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowContextMenu) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowShowUI( 
            /* [in] */ VARIANT_BOOL bAllowShowUI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowShowUI( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowShowUI) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_OptionKeyPath( 
            /* [in] */ BSTR bstrOptionKeyPath) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OptionKeyPath( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOptionKeyPath) = 0;
        
    };
    
#else         /* C style interface */

    typedef struct IAxWinAmbientDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAxWinAmbientDispatch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAxWinAmbientDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowWindowlessActivation )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bCanWindowlessActivate);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowWindowlessActivation )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanWindowlessActivate);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackColor )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ OLE_COLOR clrBackground);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackColor )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrBackground);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ForeColor )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ OLE_COLOR clrForeground);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ForeColor )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrForeground);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocaleID )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ LCID lcidLocaleID);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocaleID )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ LCID __RPC_FAR *plcidLocaleID);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserMode )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bUserMode);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserMode )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbUserMode);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayAsDefault )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bDisplayAsDefault);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayAsDefault )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbDisplayAsDefault);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Font )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ IFontDisp __RPC_FAR *pFont);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Font )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *pFont);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessageReflect )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bMsgReflect);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessageReflect )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbMsgReflect);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowGrabHandles )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowGrabHandles);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowHatching )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowHatching);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DocHostFlags )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwDocHostFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocHostFlags )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DocHostDoubleClickFlags )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwDocHostDoubleClickFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocHostDoubleClickFlags )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostDoubleClickFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowContextMenu )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bAllowContextMenu);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowContextMenu )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowContextMenu);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowShowUI )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bAllowShowUI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowShowUI )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowShowUI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OptionKeyPath )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ BSTR bstrOptionKeyPath);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OptionKeyPath )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOptionKeyPath);
        
        END_INTERFACE
    } IAxWinAmbientDispatchVtbl;

    interface IAxWinAmbientDispatch
    {
        CONST_VTBL struct IAxWinAmbientDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAxWinAmbientDispatch_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinAmbientDispatch_AddRef(This)        \
    (This)->lpVtbl -> AddRef(This)

#define IAxWinAmbientDispatch_Release(This)        \
    (This)->lpVtbl -> Release(This)


#define IAxWinAmbientDispatch_GetTypeInfoCount(This,pctinfo)        \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAxWinAmbientDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)        \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAxWinAmbientDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)        \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAxWinAmbientDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)        \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAxWinAmbientDispatch_put_AllowWindowlessActivation(This,bCanWindowlessActivate)        \
    (This)->lpVtbl -> put_AllowWindowlessActivation(This,bCanWindowlessActivate)

#define IAxWinAmbientDispatch_get_AllowWindowlessActivation(This,pbCanWindowlessActivate)        \
    (This)->lpVtbl -> get_AllowWindowlessActivation(This,pbCanWindowlessActivate)

#define IAxWinAmbientDispatch_put_BackColor(This,clrBackground)        \
    (This)->lpVtbl -> put_BackColor(This,clrBackground)

#define IAxWinAmbientDispatch_get_BackColor(This,pclrBackground)        \
    (This)->lpVtbl -> get_BackColor(This,pclrBackground)

#define IAxWinAmbientDispatch_put_ForeColor(This,clrForeground)        \
    (This)->lpVtbl -> put_ForeColor(This,clrForeground)

#define IAxWinAmbientDispatch_get_ForeColor(This,pclrForeground)        \
    (This)->lpVtbl -> get_ForeColor(This,pclrForeground)

#define IAxWinAmbientDispatch_put_LocaleID(This,lcidLocaleID)        \
    (This)->lpVtbl -> put_LocaleID(This,lcidLocaleID)

#define IAxWinAmbientDispatch_get_LocaleID(This,plcidLocaleID)        \
    (This)->lpVtbl -> get_LocaleID(This,plcidLocaleID)

#define IAxWinAmbientDispatch_put_UserMode(This,bUserMode)        \
    (This)->lpVtbl -> put_UserMode(This,bUserMode)

#define IAxWinAmbientDispatch_get_UserMode(This,pbUserMode)        \
    (This)->lpVtbl -> get_UserMode(This,pbUserMode)

#define IAxWinAmbientDispatch_put_DisplayAsDefault(This,bDisplayAsDefault)        \
    (This)->lpVtbl -> put_DisplayAsDefault(This,bDisplayAsDefault)

#define IAxWinAmbientDispatch_get_DisplayAsDefault(This,pbDisplayAsDefault)        \
    (This)->lpVtbl -> get_DisplayAsDefault(This,pbDisplayAsDefault)

#define IAxWinAmbientDispatch_put_Font(This,pFont)        \
    (This)->lpVtbl -> put_Font(This,pFont)

#define IAxWinAmbientDispatch_get_Font(This,pFont)        \
    (This)->lpVtbl -> get_Font(This,pFont)

#define IAxWinAmbientDispatch_put_MessageReflect(This,bMsgReflect)        \
    (This)->lpVtbl -> put_MessageReflect(This,bMsgReflect)

#define IAxWinAmbientDispatch_get_MessageReflect(This,pbMsgReflect)        \
    (This)->lpVtbl -> get_MessageReflect(This,pbMsgReflect)

#define IAxWinAmbientDispatch_get_ShowGrabHandles(This,pbShowGrabHandles)        \
    (This)->lpVtbl -> get_ShowGrabHandles(This,pbShowGrabHandles)

#define IAxWinAmbientDispatch_get_ShowHatching(This,pbShowHatching)        \
    (This)->lpVtbl -> get_ShowHatching(This,pbShowHatching)

#define IAxWinAmbientDispatch_put_DocHostFlags(This,dwDocHostFlags)        \
    (This)->lpVtbl -> put_DocHostFlags(This,dwDocHostFlags)

#define IAxWinAmbientDispatch_get_DocHostFlags(This,pdwDocHostFlags)        \
    (This)->lpVtbl -> get_DocHostFlags(This,pdwDocHostFlags)

#define IAxWinAmbientDispatch_put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)        \
    (This)->lpVtbl -> put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)        \
    (This)->lpVtbl -> get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_put_AllowContextMenu(This,bAllowContextMenu)        \
    (This)->lpVtbl -> put_AllowContextMenu(This,bAllowContextMenu)

#define IAxWinAmbientDispatch_get_AllowContextMenu(This,pbAllowContextMenu)        \
    (This)->lpVtbl -> get_AllowContextMenu(This,pbAllowContextMenu)

#define IAxWinAmbientDispatch_put_AllowShowUI(This,bAllowShowUI)        \
    (This)->lpVtbl -> put_AllowShowUI(This,bAllowShowUI)

#define IAxWinAmbientDispatch_get_AllowShowUI(This,pbAllowShowUI)        \
    (This)->lpVtbl -> get_AllowShowUI(This,pbAllowShowUI)

#define IAxWinAmbientDispatch_put_OptionKeyPath(This,bstrOptionKeyPath)        \
    (This)->lpVtbl -> put_OptionKeyPath(This,bstrOptionKeyPath)

#define IAxWinAmbientDispatch_get_OptionKeyPath(This,pbstrOptionKeyPath)        \
    (This)->lpVtbl -> get_OptionKeyPath(This,pbstrOptionKeyPath)

#endif /* COBJMACROS */


#endif         /* C style interface */



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowWindowlessActivation_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowWindowlessActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowWindowlessActivation_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowWindowlessActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_BackColor_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ OLE_COLOR clrBackground);


void __RPC_STUB IAxWinAmbientDispatch_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_BackColor_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrBackground);


void __RPC_STUB IAxWinAmbientDispatch_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_ForeColor_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ OLE_COLOR clrForeground);


void __RPC_STUB IAxWinAmbientDispatch_put_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ForeColor_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrForeground);


void __RPC_STUB IAxWinAmbientDispatch_get_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_LocaleID_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ LCID lcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_put_LocaleID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_LocaleID_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ LCID __RPC_FAR *plcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_get_LocaleID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_UserMode_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bUserMode);


void __RPC_STUB IAxWinAmbientDispatch_put_UserMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_UserMode_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbUserMode);


void __RPC_STUB IAxWinAmbientDispatch_get_UserMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DisplayAsDefault_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_put_DisplayAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DisplayAsDefault_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_get_DisplayAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_Font_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ IFontDisp __RPC_FAR *pFont);


void __RPC_STUB IAxWinAmbientDispatch_put_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_Font_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *pFont);


void __RPC_STUB IAxWinAmbientDispatch_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_MessageReflect_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_put_MessageReflect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_MessageReflect_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_get_MessageReflect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowGrabHandles_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowGrabHandles);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowGrabHandles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowHatching_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowHatching);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowHatching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostFlags_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostFlags_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowContextMenu_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowContextMenu_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowShowUI_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowShowUI_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_OptionKeyPath_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ BSTR bstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_put_OptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_OptionKeyPath_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_get_OptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif         /* __IAxWinAmbientDispatch_INTERFACE_DEFINED__ */


#ifndef __IInternalConnection_INTERFACE_DEFINED__
#define __IInternalConnection_INTERFACE_DEFINED__

/* interface IInternalConnection */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72AD0770-6A9F-11d1-BCEC-0060088F444E")
    IInternalConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddConnection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseConnection( void) = 0;
        
    };
    
#else         /* C style interface */

    typedef struct IInternalConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInternalConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInternalConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInternalConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddConnection )( 
            IInternalConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseConnection )( 
            IInternalConnection __RPC_FAR * This);
        
        END_INTERFACE
    } IInternalConnectionVtbl;

    interface IInternalConnection
    {
        CONST_VTBL struct IInternalConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternalConnection_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternalConnection_AddRef(This)        \
    (This)->lpVtbl -> AddRef(This)

#define IInternalConnection_Release(This)        \
    (This)->lpVtbl -> Release(This)


#define IInternalConnection_AddConnection(This)        \
    (This)->lpVtbl -> AddConnection(This)

#define IInternalConnection_ReleaseConnection(This)        \
    (This)->lpVtbl -> ReleaseConnection(This)

#endif /* COBJMACROS */


#endif         /* C style interface */



HRESULT STDMETHODCALLTYPE IInternalConnection_AddConnection_Proxy( 
    IInternalConnection __RPC_FAR * This);


void __RPC_STUB IInternalConnection_AddConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternalConnection_ReleaseConnection_Proxy( 
    IInternalConnection __RPC_FAR * This);


void __RPC_STUB IInternalConnection_ReleaseConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif         /* __IInternalConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_atliface_0213 */
/* [local] */ 

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

ATLAPI_(INT_PTR) AtlAxDialogBoxW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
ATLAPI_(INT_PTR) AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
#ifdef UNICODE
#define AtlAxDialogBox AtlAxDialogBoxW
#else
#define AtlAxDialogBox AtlAxDialogBoxA
#endif

ATLAPI_(HWND) AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
ATLAPI_(HWND) AtlAxCreateDialogA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
#ifdef UNICODE
#define AtlAxCreateDialog AtlAxCreateDialogW
#else
#define AtlAxCreateDialog AtlAxCreateDialogA
#endif

ATLAPI AtlAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer);
ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
                IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
                REFIID iidSink=IID_NULL, IUnknown* punkSink=NULL);
ATLAPI AtlAxAttachControl(IUnknown* pControl, HWND hWnd, IUnknown** ppUnkContainer);
ATLAPI_(BOOL) AtlAxWinInit();

ATLAPI AtlAxGetHost(HWND h, IUnknown** pp);
ATLAPI AtlAxGetControl(HWND h, IUnknown** pp);

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif //_ATL_DLL_IMPL


extern RPC_IF_HANDLE __MIDL_itf_atliface_0236_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0236_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlwin.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atldb.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDB_H
#define __ATLDB_H

// OLE DB Provider Support

// Interface Impl Classes
//
// Data Source Object
//
// -Mandatory Interfaces:
//  IDBCreateSession
//  IDBInitialize
//  IDBProperties
//  IPersist
//
// Session Object
//
// -Mandatory Interfaces:
//  IGetDataSource
//  IOpenRowset
//  ISessionProperties
//
// -Optional Interfaces:
//  IDBCreateCommand
//  IDBSchemaRowset
//
// Rowset Object
//
// -Mandatory Interfaces:
//  IAccessor
//  IColumnsInfo
//  IConvertType
//  IRowset
//  IRowsetInfo
//
// -Optional Interfaces:
//  IRowsetIdentity
//
// Command Object
//
// -Mandatory Interfaces:
// ICommand)
// IAccessor)
// ICommandProperties
// ICommandText - derives from ICommand
// IColumnsInfo
// IConvertType

#include <oledb.h>
#include <limits.h>
#include <oledberr.h>
#include <msdadc.h>
#include <atldbcli.h>

//Forwards
template <class T> class CUtlPropInfo;
class CColumnIds;

// Additional Property Flag needed internally
const int   DBPROPFLAGS_CHANGE  = 0x40000000;

// -------------  STRUCTURE DEFINITIONS --------------------------------

struct UPROPVAL
{
        DBPROPOPTIONS   dwOption;
        CColumnIds*     pCColumnIds;
        DWORD           dwFlags;
        VARIANT         vValue;
};

struct UPROPINFO
{
        DBPROPID    dwPropId;
        ULONG       ulIDS;
        VARTYPE     VarType;
        DBPROPFLAGS dwFlags;
        union
        {
                DWORD_PTR dwVal;
                LPOLESTR szVal;
        };
        DBPROPOPTIONS dwOption;
};

struct UPROP
{
        ULONG           cPropIds;
        UPROPINFO**     rgpUPropInfo;
        UPROPVAL*       pUPropVal;
};

struct PROPCOLID
{
        DBID            dbidProperty;   // The column id information
        DBPROPOPTIONS   dwOption;
        VARIANT         vValue;
};

typedef PROPCOLID* PPROPCOLID;

struct UPROPSET
{
        const GUID* pPropSet;
        ULONG cUPropInfo;
        UPROPINFO* pUPropInfo;
        DWORD dwFlags;
};

struct ATLBINDINGS
{
        DBBINDING* pBindings;
        DWORD dwRef;
        DBCOUNTITEM cBindings;
        DBACCESSORFLAGS dwAccessorFlags;
};

struct ATLCOLUMNINFO
{
        LPOLESTR pwszName;
        ITypeInfo *pTypeInfo;
        DBORDINAL iOrdinal;
        DBCOLUMNFLAGS dwFlags;
        DBLENGTH ulColumnSize;
        DBTYPE wType;
        BYTE bPrecision;
        BYTE bScale;
        DBID columnid;
        DBBYTEOFFSET cbOffset;
};

//
// The following very large sections of defines are to implement auto determination
// of Preoperty map constants based on a stringized prop name.  There is one set for
// Type (VT_), one for Init Value, and one for Property flags.
//

#define ABORTPRESERVE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ACTIVESESSIONS_Flags  ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define APPENDONLY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define ASYNCTXNABORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ASYNCTXNCOMMIT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define AUTH_CACHE_AUTHINFO_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_ENCRYPT_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_INTEGRATED_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_MASK_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_PERSIST_ENCRYPTED_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_USERID_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define BLOCKINGSTORAGEOBJECTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define BOOKMARKS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define BOOKMARKSKIPPED_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define BOOKMARKTYPE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define BYREFACCESSORS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CACHEDEFERRED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANFETCHBACKWARDS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANHOLDROWS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANSCROLLBACKWARDS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CATALOGLOCATION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CATALOGTERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CATALOGUSAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CHANGEINSERTEDROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_CHANGE )
#define COL_AUTOINCREMENT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_DEFAULT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_DESCRIPTION_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_FIXEDLENGTH_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_NULLABLE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_PRIMARYKEY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_UNIQUE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COLUMNDEFINITION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define COLUMNRESTRICT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define COMMANDTIMEOUT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COMMITPRESERVE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CONCATNULLBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CURRENTCATALOG_Flags ( DBPROPFLAGS_DATASOURCE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define DATASOURCENAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DATASOURCEREADONLY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DBMSNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DBMSVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DEFERRED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define DELAYSTORAGEOBJECTS_Flags  ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DSOTHREADMODEL_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define GROUPBY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define HETEROGENEOUSTABLES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define IAccessor_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IColumnsInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IColumnsRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IConnectionPointContainer_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IConvertType_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetChange_Flags  ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetIdentity_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetIndex_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetLocate_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetResynch_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetScroll_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetUpdate_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ISupportErrorInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ILockBytes_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ISequentialStream_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IStorage_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IStream_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IDENTIFIERCASE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define IMMOBILEROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_AUTOUPDATE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_CLUSTERED_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_FILLFACTOR_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_INITIALSIZE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_NULLCOLLATION_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_NULLS_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_PRIMARYKEY_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_SORTBOOKMARKS_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_TEMPINDEX_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_TYPE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_UNIQUE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_DATASOURCE_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_HWND_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_IMPERSONATION_LEVEL_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_LCID_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_LOCATION_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_MODE_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROMPT_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROTECTION_LEVEL_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROVIDERSTRING_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_TIMEOUT_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define LITERALBOOKMARKS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define LITERALIDENTITY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXINDEXSIZE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXOPENROWS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXPENDINGROWS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MAXROWSIZE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXROWSIZEINCLUDESBLOB_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXTABLESINSELECT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAYWRITECOLUMN_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MEMORYUSAGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MULTIPLEPARAMSETS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MULTIPLERESULTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MULTIPLESTORAGEOBJECTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MULTITABLEUPDATE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFICATIONPHASES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYCOLUMNSET_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWDELETE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWFIRSTCHANGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWINSERT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWRESYNCH_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWSETRELEASE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWUNDOCHANGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWUNDODELETE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWUNDOINSERT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFYROWUPDATE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NULLCOLLATION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define OLEOBJECTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ORDERBYCOLUMNSINSELECT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ORDEREDBOOKMARKS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OTHERINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OTHERUPDATEDELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OUTPUTPARAMETERAVAILABILITY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define OWNINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OWNUPDATEDELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define PERSISTENTIDTYPE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PREPAREABORTBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PREPARECOMMITBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PROCEDURETERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PROVIDERNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PROVIDEROLEDBVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PROVIDERVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define QUICKRESTART_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define QUOTEDIDENTIFIERCASE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define REENTRANTEVENTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define REMOVEDELETED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define REPORTMULTIPLECHANGES_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_CHANGE )
#define RETURNPENDINGINSERTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ROWRESTRICT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ROWSETCONVERSIONSONCOMMAND_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ROWTHREADMODEL_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define SCHEMATERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SCHEMAUSAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SERVERCURSOR_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define SESS_AUTOCOMMITISOLEVELS_Flags ( DBPROPFLAGS_SESSION | DBPROPFLAGS_READ )
#define SQLSUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define STRONGIDENTITY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define STRUCTUREDSTORAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SUBQUERIES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SUPPORTEDTXNDDL_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SUPPORTEDTXNISOLEVELS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SUPPORTEDTXNISORETAIN_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define TABLETERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define TBL_TEMPTABLE_Flags ( DBPROPFLAGS_TABLE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define TRANSACTEDOBJECT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define UPDATABILITY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define USERNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )



#define ABORTPRESERVE_Type VT_BOOL
#define ACTIVESESSIONS_Type VT_I4
#define APPENDONLY_Type VT_BOOL
#define ASYNCTXNABORT_Type VT_BOOL
#define ASYNCTXNCOMMIT_Type VT_BOOL
#define AUTH_CACHE_AUTHINFO_Type VT_BOOL
#define AUTH_ENCRYPT_PASSWORD_Type VT_BOOL
#define AUTH_INTEGRATED_Type VT_BSTR
#define AUTH_MASK_PASSWORD_Type VT_BOOL
#define AUTH_PASSWORD_Type VT_BSTR
#define AUTH_PERSIST_ENCRYPTED_Type VT_BOOL
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Type VT_BOOL
#define AUTH_USERID_Type VT_BSTR
#define BLOCKINGSTORAGEOBJECTS_Type VT_BOOL
#define BOOKMARKS_Type VT_BOOL
#define BOOKMARKSKIPPED_Type VT_BOOL
#define BOOKMARKTYPE_Type VT_I4
#define BYREFACCESSORS_Type VT_BOOL
#define CACHEDEFERRED_Type VT_BOOL
#define CANFETCHBACKWARDS_Type VT_BOOL
#define CANHOLDROWS_Type VT_BOOL
#define CANSCROLLBACKWARDS_Type VT_BOOL
#define CATALOGLOCATION_Type VT_I4
#define CATALOGTERM_Type VT_BSTR
#define CATALOGUSAGE_Type VT_I4
#define CHANGEINSERTEDROWS_Type VT_BOOL
#define COL_AUTOINCREMENT_Type VT_BOOL
#define COL_DEFAULT_Type VT_BSTR
#define COL_DESCRIPTION_Type VT_BSTR
#define COL_FIXEDLENGTH_Type VT_BOOL
#define COL_NULLABLE_Type VT_BOOL
#define COL_PRIMARYKEY_Type VT_BOOL
#define COL_UNIQUE_Type VT_BOOL
#define COLUMNDEFINITION_Type VT_I4
#define COLUMNRESTRICT_Type VT_BOOL
#define COMMANDTIMEOUT_Type VT_I4
#define COMMITPRESERVE_Type VT_BOOL
#define CONCATNULLBEHAVIOR_Type VT_I4
#define CURRENTCATALOG_Type VT_BSTR
#define DATASOURCENAME_Type VT_BSTR
#define DATASOURCEREADONLY_Type VT_BOOL
#define DBMSNAME_Type VT_BSTR
#define DBMSVER_Type VT_BSTR
#define DEFERRED_Type VT_BOOL
#define DELAYSTORAGEOBJECTS_Type VT_BOOL
#define DSOTHREADMODEL_Type VT_I4
#define GROUPBY_Type VT_I4
#define HETEROGENEOUSTABLES_Type VT_I4
#define IAccessor_Type VT_BOOL
#define IColumnsInfo_Type VT_BOOL
#define IColumnsRowset_Type VT_BOOL
#define IConnectionPointContainer_Type VT_BOOL
#define IConvertType_Type VT_BOOL
#define IRowset_Type VT_BOOL
#define IRowsetChange_Type VT_BOOL
#define IRowsetIdentity_Type VT_BOOL
#define IRowsetIndex_Type VT_BOOL
#define IRowsetInfo_Type VT_BOOL
#define IRowsetLocate_Type VT_BOOL
#define IRowsetResynch_Type VT_BOOL
#define IRowsetScroll_Type VT_BOOL
#define IRowsetUpdate_Type VT_BOOL
#define ISupportErrorInfo_Type VT_BOOL
#define ILockBytes_Type VT_BOOL
#define ISequentialStream_Type VT_BOOL
#define IStorage_Type VT_BOOL
#define IStream_Type VT_BOOL
#define IDENTIFIERCASE_Type VT_I4
#define IMMOBILEROWS_Type VT_BOOL
#define INDEX_AUTOUPDATE_Type VT_BOOL
#define INDEX_CLUSTERED_Type VT_BOOL
#define INDEX_FILLFACTOR_Type VT_I4
#define INDEX_INITIALSIZE_Type VT_I4
#define INDEX_NULLCOLLATION_Type VT_I4
#define INDEX_NULLS_Type VT_I4
#define INDEX_PRIMARYKEY_Type VT_BOOL
#define INDEX_SORTBOOKMARKS_Type VT_BOOL
#define INDEX_TEMPINDEX_Type VT_BOOL
#define INDEX_TYPE_Type VT_I4
#define INDEX_UNIQUE_Type VT_BOOL
#define INIT_DATASOURCE_Type VT_BSTR
#define INIT_HWND_Type VT_I4
#define INIT_IMPERSONATION_LEVEL_Type VT_I4
#define INIT_LCID_Type VT_I4
#define INIT_LOCATION_Type VT_BSTR
#define INIT_MODE_Type VT_I4
#define INIT_PROMPT_Type VT_I2
#define INIT_PROTECTION_LEVEL_Type VT_I4
#define INIT_PROVIDERSTRING_Type VT_BSTR
#define INIT_TIMEOUT_Type VT_I4
#define LITERALBOOKMARKS_Type VT_BOOL
#define LITERALIDENTITY_Type VT_BOOL
#define MAXINDEXSIZE_Type VT_I4
#define MAXOPENROWS_Type VT_I4
#define MAXPENDINGROWS_Type VT_I4
#define MAXROWS_Type VT_I4
#define MAXROWSIZE_Type VT_I4
#define MAXROWSIZEINCLUDESBLOB_Type VT_BOOL
#define MAXTABLESINSELECT_Type VT_I4
#define MAYWRITECOLUMN_Type VT_BOOL
#define MEMORYUSAGE_Type VT_I4
#define MULTIPLEPARAMSETS_Type VT_BOOL
#define MULTIPLERESULTS_Type VT_I4
#define MULTIPLESTORAGEOBJECTS_Type VT_BOOL
#define MULTITABLEUPDATE_Type VT_BOOL
#define NOTIFICATIONPHASES_Type VT_I4
#define NOTIFYCOLUMNSET_Type VT_I4
#define NOTIFYROWDELETE_Type VT_I4
#define NOTIFYROWFIRSTCHANGE_Type VT_I4
#define NOTIFYROWINSERT_Type VT_I4
#define NOTIFYROWRESYNCH_Type VT_I4
#define NOTIFYROWSETRELEASE_Type VT_I4
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Type VT_I4
#define NOTIFYROWUNDOCHANGE_Type VT_I4
#define NOTIFYROWUNDODELETE_Type VT_I4
#define NOTIFYROWUNDOINSERT_Type VT_I4
#define NOTIFYROWUPDATE_Type VT_I4
#define NULLCOLLATION_Type VT_I4
#define OLEOBJECTS_Type VT_I4
#define ORDERBYCOLUMNSINSELECT_Type VT_BOOL
#define ORDEREDBOOKMARKS_Type VT_BOOL
#define OTHERINSERT_Type VT_BOOL
#define OTHERUPDATEDELETE_Type VT_BOOL
#define OUTPUTPARAMETERAVAILABILITY_Type VT_I4
#define OWNINSERT_Type VT_BOOL
#define OWNUPDATEDELETE_Type VT_BOOL
#define PERSISTENTIDTYPE_Type VT_I4
#define PREPAREABORTBEHAVIOR_Type VT_I4
#define PREPARECOMMITBEHAVIOR_Type VT_I4
#define PROCEDURETERM_Type VT_BSTR
#define PROVIDERNAME_Type VT_BSTR
#define PROVIDEROLEDBVER_Type VT_BSTR
#define PROVIDERVER_Type VT_BSTR
#define QUICKRESTART_Type VT_BOOL
#define QUOTEDIDENTIFIERCASE_Type VT_I4
#define REENTRANTEVENTS_Type VT_BOOL
#define REMOVEDELETED_Type VT_BOOL
#define REPORTMULTIPLECHANGES_Type VT_BOOL
#define RETURNPENDINGINSERTS_Type VT_BOOL
#define ROWRESTRICT_Type VT_BOOL
#define ROWSETCONVERSIONSONCOMMAND_Type VT_BOOL
#define ROWTHREADMODEL_Type VT_I4
#define SCHEMATERM_Type VT_BSTR
#define SCHEMAUSAGE_Type VT_I4
#define SERVERCURSOR_Type VT_BOOL
#define SESS_AUTOCOMMITISOLEVELS_Type VT_I4
#define SQLSUPPORT_Type VT_I4
#define STRONGIDENTITY_Type VT_BOOL
#define STRUCTUREDSTORAGE_Type VT_I4
#define SUBQUERIES_Type VT_I4
#define SUPPORTEDTXNDDL_Type VT_I4
#define SUPPORTEDTXNISOLEVELS_Type VT_I4
#define SUPPORTEDTXNISORETAIN_Type VT_I4
#define TABLETERM_Type VT_BSTR
#define TBL_TEMPTABLE_Type VT_BOOL
#define TRANSACTEDOBJECT_Type VT_BOOL
#define UPDATABILITY_Type VT_I4
#define USERNAME_Type VT_BSTR



#define ABORTPRESERVE_Value VARIANT_FALSE
#define ACTIVESESSIONS_Value 0
#define APPENDONLY_Value VARIANT_FALSE
#define ASYNCTXNABORT_Value VARIANT_FALSE
#define ASYNCTXNCOMMIT_Value VARIANT_FALSE
#define AUTH_CACHE_AUTHINFO_Value VARIANT_FALSE
#define AUTH_ENCRYPT_PASSWORD_Value VARIANT_FALSE
#define AUTH_INTEGRATED_Value OLESTR("")
#define AUTH_MASK_PASSWORD_Value VARIANT_FALSE
#define AUTH_PASSWORD_Value OLESTR("")
#define AUTH_PERSIST_ENCRYPTED_Value VARIANT_FALSE
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Value VARIANT_FALSE
#define AUTH_USERID_Value OLESTR("")
#define BLOCKINGSTORAGEOBJECTS_Value VARIANT_FALSE
#define BOOKMARKS_Value VARIANT_FALSE
#define BOOKMARKSKIPPED_Value VARIANT_FALSE
#define BOOKMARKTYPE_Value 0
#define BYREFACCESSORS_Value VARIANT_FALSE
#define CACHEDEFERRED_Value VARIANT_FALSE
#define CANFETCHBACKWARDS_Value VARIANT_TRUE
#define CANHOLDROWS_Value VARIANT_TRUE
#define CANSCROLLBACKWARDS_Value VARIANT_TRUE
#define CATALOGLOCATION_Value 0
#define CATALOGTERM_Value OLESTR("")
#define CATALOGUSAGE_Value 0
#define CHANGEINSERTEDROWS_Value VARIANT_FALSE
#define COL_AUTOINCREMENT_Value VARIANT_FALSE
#define COL_DEFAULT_Value OLESTR("")
#define COL_DESCRIPTION_Value OLESTR("")
#define COL_FIXEDLENGTH_Value VARIANT_FALSE
#define COL_NULLABLE_Value VARIANT_FALSE
#define COL_PRIMARYKEY_Value VARIANT_FALSE
#define COL_UNIQUE_Value VARIANT_FALSE
#define COLUMNDEFINITION_Value 0
#define COLUMNRESTRICT_Value VARIANT_FALSE
#define COMMANDTIMEOUT_Value 0
#define COMMITPRESERVE_Value VARIANT_FALSE
#define CONCATNULLBEHAVIOR_Value 0
#define CURRENTCATALOG_Value OLESTR("")
#define DATASOURCENAME_Value OLESTR("")
#define DATASOURCEREADONLY_Value VARIANT_TRUE
#define DBMSNAME_Value OLESTR("")
#define DBMSVER_Value OLESTR("")
#define DEFERRED_Value VARIANT_FALSE
#define DELAYSTORAGEOBJECTS_Value VARIANT_FALSE
#define DSOTHREADMODEL_Value DBPROPVAL_RT_APTMTTHREAD
#define GROUPBY_Value 0
#define HETEROGENEOUSTABLES_Value 0
#define IAccessor_Value VARIANT_TRUE
#define IColumnsInfo_Value VARIANT_TRUE
#define IColumnsRowset_Value VARIANT_FALSE
#define IConnectionPointContainer_Value VARIANT_FALSE
#define IConvertType_Value VARIANT_TRUE
#define IRowset_Value VARIANT_TRUE
#define IRowsetChange_Value VARIANT_FALSE
#define IRowsetIdentity_Value VARIANT_TRUE
#define IRowsetIndex_Value VARIANT_FALSE
#define IRowsetInfo_Value VARIANT_TRUE
#define IRowsetLocate_Value VARIANT_FALSE
#define IRowsetResynch_Value VARIANT_FALSE
#define IRowsetScroll_Value VARIANT_FALSE
#define IRowsetUpdate_Value VARIANT_FALSE
#define ISupportErrorInfo_Value VARIANT_FALSE
#define ILockBytes_Value VARIANT_FALSE
#define ISequentialStream_Value VARIANT_FALSE
#define IStorage_Value VARIANT_FALSE
#define IStream_Value VARIANT_FALSE
#define IDENTIFIERCASE_Value 0
#define IMMOBILEROWS_Value VARIANT_FALSE
#define INDEX_AUTOUPDATE_Value VARIANT_FALSE
#define INDEX_CLUSTERED_Value VARIANT_FALSE
#define INDEX_FILLFACTOR_Value 0
#define INDEX_INITIALSIZE_Value 0
#define INDEX_NULLCOLLATION_Value 0
#define INDEX_NULLS_Value 0
#define INDEX_PRIMARYKEY_Value VARIANT_FALSE
#define INDEX_SORTBOOKMARKS_Value VARIANT_FALSE
#define INDEX_TEMPINDEX_Value VARIANT_FALSE
#define INDEX_TYPE_Value 0
#define INDEX_UNIQUE_Value VARIANT_FALSE
#define INIT_DATASOURCE_Value OLESTR("")
#define INIT_HWND_Value 0
#define INIT_IMPERSONATION_LEVEL_Value 0
#define INIT_LCID_Value 0
#define INIT_LOCATION_Value OLESTR("")
#define INIT_MODE_Value 0
#define INIT_PROMPT_Value VT_I2
#define INIT_PROTECTION_LEVEL_Value 0
#define INIT_PROVIDERSTRING_Value OLESTR("")
#define INIT_TIMEOUT_Value 0
#define LITERALBOOKMARKS_Value VARIANT_FALSE
#define LITERALIDENTITY_Value VARIANT_FALSE
#define MAXINDEXSIZE_Value 0
#define MAXOPENROWS_Value 0
#define MAXPENDINGROWS_Value 0
#define MAXROWS_Value 0
#define MAXROWSIZE_Value 0
#define MAXROWSIZEINCLUDESBLOB_Value VARIANT_FALSE
#define MAXTABLESINSELECT_Value 0
#define MAYWRITECOLUMN_Value VARIANT_FALSE
#define MEMORYUSAGE_Value 0
#define MULTIPLEPARAMSETS_Value VARIANT_FALSE
#define MULTIPLERESULTS_Value 0
#define MULTIPLESTORAGEOBJECTS_Value VARIANT_FALSE
#define MULTITABLEUPDATE_Value VARIANT_FALSE
#define NOTIFICATIONPHASES_Value 0
#define NOTIFYCOLUMNSET_Value 0
#define NOTIFYROWDELETE_Value 0
#define NOTIFYROWFIRSTCHANGE_Value 0
#define NOTIFYROWINSERT_Value 0
#define NOTIFYROWRESYNCH_Value 0
#define NOTIFYROWSETRELEASE_Value 0
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Value 0
#define NOTIFYROWUNDOCHANGE_Value 0
#define NOTIFYROWUNDODELETE_Value 0
#define NOTIFYROWUNDOINSERT_Value 0
#define NOTIFYROWUPDATE_Value 0
#define NULLCOLLATION_Value 0
#define OLEOBJECTS_Value 0
#define ORDERBYCOLUMNSINSELECT_Value VARIANT_FALSE
#define ORDEREDBOOKMARKS_Value VARIANT_FALSE
#define OTHERINSERT_Value VARIANT_FALSE
#define OTHERUPDATEDELETE_Value VARIANT_FALSE
#define OUTPUTPARAMETERAVAILABILITY_Value 0
#define OWNINSERT_Value VARIANT_FALSE
#define OWNUPDATEDELETE_Value VARIANT_FALSE
#define PERSISTENTIDTYPE_Value 0
#define PREPAREABORTBEHAVIOR_Value 0
#define PREPARECOMMITBEHAVIOR_Value 0
#define PROCEDURETERM_Value OLESTR("")
#define PROVIDERNAME_Value OLESTR("")
#define PROVIDEROLEDBVER_Value OLESTR("2.0")
#define PROVIDERVER_Value OLESTR("")
#define QUICKRESTART_Value VARIANT_FALSE
#define QUOTEDIDENTIFIERCASE_Value 0
#define REENTRANTEVENTS_Value VARIANT_FALSE
#define REMOVEDELETED_Value VARIANT_FALSE
#define REPORTMULTIPLECHANGES_Value VARIANT_FALSE
#define RETURNPENDINGINSERTS_Value VARIANT_FALSE
#define ROWRESTRICT_Value VARIANT_FALSE
#define ROWSETCONVERSIONSONCOMMAND_Value VARIANT_TRUE
#define ROWTHREADMODEL_Value 0
#define SCHEMATERM_Value OLESTR("")
#define SCHEMAUSAGE_Value 0
#define SERVERCURSOR_Value VARIANT_FALSE
#define SESS_AUTOCOMMITISOLEVELS_Value 0
#define SQLSUPPORT_Value 0
#define STRONGIDENTITY_Value VARIANT_FALSE
#define STRUCTUREDSTORAGE_Value 0
#define SUBQUERIES_Value 0
#define SUPPORTEDTXNDDL_Value 0
#define SUPPORTEDTXNISOLEVELS_Value 0
#define SUPPORTEDTXNISORETAIN_Value 0
#define TABLETERM_Value OLESTR("")
#define TBL_TEMPTABLE_Value VARIANT_FALSE
#define TRANSACTEDOBJECT_Value VARIANT_FALSE
#define UPDATABILITY_Value 0
#define USERNAME_Value OLESTR("")


#define OUT_OF_LINE virtual

#define BEGIN_PROPSET_MAP(Class) \
static UPROPSET* _GetPropSet(ULONG* pNumPropSets, ULONG* pcElemPerSupported, UPROPSET* pSet = NULL, GUID* pguidSet = (GUID*)&(GUID_NULL)) \
{ \
        typedef Class _PropSetClass; \
        ULONG& cElemsMax = *pcElemPerSupported; \
        cElemsMax = 0; \
        int nCurProp = 0; \
        int cRemainder = 0; \
        cRemainder;

#define BEGIN_PROPERTY_SET_EX(guid, flags) \
if (pNumPropSets != NULL) \
{ \
        pSet[nCurProp].pPropSet = &guid; \
        pSet[nCurProp].dwFlags = flags; \
} \
static const UPROPINFO aProperty##guid[] = \
{

#define BEGIN_PROPERTY_SET(guid) BEGIN_PROPERTY_SET_EX(guid, 0)

#define PROPERTY_INFO_ENTRY_EX(dwPropID, vt, dwFlags, value, options) DBPROP_##dwPropID, IDS_DBPROP_##dwPropID, vt, dwFlags, (DWORD_PTR)value, (DBPROPOPTIONS)options,

#define PROPERTY_INFO_ENTRY_VALUE(dwPropID, value) PROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, ##dwPropID##_Flags, value, 0)

#define PROPERTY_INFO_ENTRY(dwPropID) PROPERTY_INFO_ENTRY_VALUE(dwPropID, dwPropID##_Value)


#define END_PROPERTY_SET(guid) \
                }; \
                if (pNumPropSets != NULL) \
                { \
                        pSet[nCurProp].pUPropInfo = (UPROPINFO*)aProperty##guid; \
                        pSet[nCurProp].cUPropInfo = sizeof(aProperty##guid) / sizeof(UPROPINFO); \
                        cRemainder = (pSet[nCurProp].cUPropInfo % 32) ? 1 : 0; \
                        if (cElemsMax < (pSet[nCurProp].cUPropInfo / 32 + cRemainder)) \
                        { \
                                cElemsMax = (pSet[nCurProp].cUPropInfo / 32 + cRemainder); \
                        } \
                } \
                nCurProp++;

#define CHAIN_PROPERTY_SET(ChainClass) \
                ULONG cPropSets##ChainClass, cElsSupported##ChainClass; \
                int cSets##ChainClass = (int)(DWORD_PTR)ChainClass::_GetPropSet(NULL, &cElsSupported##ChainClass); \
                if (pNumPropSets != NULL) \
                { \
                        UPROPSET* pSetA = (UPROPSET*)_alloca(sizeof(UPROPSET)*cSets##ChainClass); \
                        UPROPSET* pSetTemp = ChainClass::_GetPropSet(&cPropSets##ChainClass, &cElsSupported##ChainClass, pSetA); \
                        cElemsMax = (cElemsMax < cElsSupported##ChainClass) ? cElsSupported##ChainClass : cElemsMax; \
                        ATLASSERT(pSetTemp); \
                        for (ULONG iSet = nCurProp; iSet < nCurProp+cPropSets##ChainClass; iSet++) \
                        { \
                                pSet[iSet].pPropSet = pSetTemp[iSet-nCurProp].pPropSet; \
                                pSet[iSet].dwFlags = pSetTemp[iSet-nCurProp].dwFlags; \
                                pSet[iSet].pUPropInfo = pSetTemp[iSet-nCurProp].pUPropInfo; \
                                pSet[iSet].cUPropInfo = pSetTemp[iSet-nCurProp].cUPropInfo; \
                        } \
                } \
                nCurProp += cSets##ChainClass;

#define END_PROPSET_MAP() \
        if (pNumPropSets != NULL) \
        { \
                if (IsEqualGUID(*pguidSet, GUID_NULL)) \
                { \
                        *pNumPropSets = nCurProp; \
                        return pSet; \
                } \
                else \
                { \
                        *pNumPropSets = 1; \
                        UINT i = 0; \
                        for (; i < sizeof(pSet)/sizeof(UPROPSET) && IsEqualGUID(*(pSet[i].pPropSet), *pguidSet); i++); \
                        return (i == sizeof(pSet)/sizeof(UPROPSET)) ? &pSet[0] : &pSet[i]; \
                } \
        } \
        return (UPROPSET*)(DWORD_PTR)nCurProp; \
        }


// For DataSource flags IDBInitialize::m_dwStatus
enum DATASOURCE_FLAGS {
        DSF_MASK_INIT           = 0xFFFFF00F,   // Mask for stuff lasting over init/uninit.
        DSF_PERSIST_DIRTY       = 0x00000001,   // Set if init string changes.
        DSF_INITIALIZED         = 0x00000010,   // Have we been initialized.
};


#define DBID_USE_GUID_OR_PGUID(e) \
        ((1<<(e)) & \
        ( 1<<DBKIND_GUID \
        | 1<<DBKIND_GUID_NAME \
        | 1<<DBKIND_GUID_PROPID \
        | 1<<DBKIND_PGUID_NAME \
        | 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_GUID(e) \
        ((1<<(e)) & \
        ( 1<<DBKIND_GUID \
        | 1<<DBKIND_GUID_NAME \
        | 1<<DBKIND_GUID_PROPID ))

#define DBID_USE_PGUID(e) \
        ((1<<(e)) & \
        ( 1<<DBKIND_PGUID_NAME \
        | 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_NAME(e) \
        ((1<<(e)) & \
        ( 1<<DBKIND_NAME \
        | 1<<DBKIND_GUID_NAME \
        | 1<<DBKIND_PGUID_NAME ))

#define DBID_USE_PROPID(e) \
        ((1<<(e)) & \
        ( 1<<DBKIND_PROPID \
        | 1<<DBKIND_GUID_PROPID \
        | 1<<DBKIND_PGUID_PROPID ))

// Bookmark can be either guid or pguid.
#define DBID_IS_BOOKMARK(dbid) \
        (  DBID_USE_GUID(dbid.eKind)  &&  dbid.uGuid.guid  == DBCOL_SPECIALCOL \
        || DBID_USE_PGUID(dbid.eKind) && *dbid.uGuid.pguid == DBCOL_SPECIALCOL )

#define DivDword(dw) (dw >> 5)      // dw / 32 = dw / (sizeof(DWORD)*8)
#define ModDword(dw) (dw & (32-1))  // dw % 32
#define DwordSizeofBits(nBits) (nBits/32+1) // Use in array declarations
#define CLEARBITARRAY( rgdwFlags ) memset( rgdwFlags, 0, sizeof(rgdwFlags) )

template <class T>
BOOL InRange(const T& val, const T& valMin, const T& valMax)
{
        return ( valMin <= val && val <= valMax );
}
// Implementation Class
class CBitFieldOps
{
public:
        void SETBIT( DWORD rgdwFlags[], const DWORD dwBit )
        {
                rgdwFlags[DivDword(dwBit)] |= 1 << ModDword(dwBit);
        }

        void CLEARBIT( DWORD rgdwFlags[], const DWORD dwBit )
        {
                rgdwFlags[DivDword(dwBit)] &= ~( 1 << ModDword(dwBit) );
        }

        DWORD TESTBIT( const DWORD rgdwFlags[], const DWORD dwBit )
        {
                //old//Note: Not {0,1}, but from {0...2^32-1}.
                // Note: Now returns {0,1}.
                return ( rgdwFlags[DivDword(dwBit)] & ( 1 << ModDword(dwBit) ) ) != 0;
        }
};

// Implementation Class
class CDBIDOps
{
public:
        HRESULT CompareDBIDs(const DBID* pdbid1, const DBID* pdbid2)
        {
                // Array of valid eKind matches, in addition to matching exactly.
                static BYTE s_rgbKind[] =
                {
                        DBKIND_PGUID_NAME,      // DBKIND_GUID_NAME
                        DBKIND_PGUID_PROPID,    // DBKIND_GUID_PROPID
                        DBKIND_NAME,            // DBKIND_NAME
                        DBKIND_GUID_NAME,       // DBKIND_PGUID_NAME
                        DBKIND_GUID_PROPID,     // DBKIND_PGUID_PROPID
                        DBKIND_PROPID,          // DBKIND_PROPID
                        DBKIND_GUID             // DBKIND_GUID
                };

                if( !pdbid1 || !pdbid2 )
                        return S_FALSE;

                // Assume a match, and discard early if we can.
                if (!InRange(pdbid2->eKind, (DWORD)0, (DWORD)(sizeof(s_rgbKind)/sizeof(*s_rgbKind)-1)))
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "Column ID out of Range\n");
                        return E_FAIL;
                }
                if (pdbid1->eKind != pdbid2->eKind
                &&  pdbid1->eKind != s_rgbKind[pdbid2->eKind])
                        return S_FALSE;

                if (DBID_USE_GUID_OR_PGUID(pdbid1->eKind))
                {
                        if (!DBID_USE_GUID_OR_PGUID(pdbid2->eKind))
                                return S_FALSE;
                        // Compare GUIDs.
                        // Note that _GUID_ is equivalent to _PGUID_.
                        if (!InlineIsEqualGUID(
                                        DBID_USE_PGUID(pdbid1->eKind) ? *(pdbid1->uGuid.pguid) : pdbid1->uGuid.guid,
                                        DBID_USE_PGUID(pdbid2->eKind) ? *(pdbid2->uGuid.pguid) : pdbid2->uGuid.guid ))
                                return S_FALSE;
                }
                if (DBID_USE_NAME(pdbid1->eKind))
                {
                        if (!DBID_USE_NAME(pdbid2->eKind))
                                return S_FALSE;
                        // Compare names.
                        // Need to check if 1 is null and the other is not.
                        if ( ((pdbid1->uName.pwszName == NULL) &&
                                  (pdbid2->uName.pwszName != NULL)) ||
                                 ((pdbid1->uName.pwszName != NULL) &&
                                  (pdbid2->uName.pwszName == NULL)) )
                                 return S_FALSE;
                        // Since the above check does not rule out both being null, which is
                        // a valid comparison, and wcscmp will GPF if they were, we need
                        // to check for valid pointers
                        if( pdbid1->uName.pwszName && pdbid2->uName.pwszName )
                        {
                                // Assume null-terminated.
                                // Assume LCID match is OK (note diff with lstrcmp(), CompareString().)
                                if (wcscmp(pdbid1->uName.pwszName, pdbid2->uName.pwszName) != 0)
                                        return S_FALSE;
                        }
                }
                if (DBID_USE_PROPID(pdbid1->eKind))
                {
                        if (!DBID_USE_PROPID(pdbid2->eKind))
                                return S_FALSE;
                        // Compare PROPID.
                        if (pdbid1->uName.ulPropid != pdbid2->uName.ulPropid)
                                return S_FALSE;
                }

                // No reason to discard, so must have matched each field successfully.
                return S_OK;
        }

        static HRESULT IsValidDBID(const DBID*  pdbid1)
        {
                ATLASSERT( pdbid1 );

                if( pdbid1 &&
                        ((pdbid1->eKind == DBKIND_GUID_NAME) ||
                        (pdbid1->eKind == DBKIND_GUID_PROPID) ||
                        (pdbid1->eKind == DBKIND_NAME) ||
                        (pdbid1->eKind == DBKIND_PGUID_NAME) ||
                        (pdbid1->eKind == DBKIND_PGUID_PROPID) ||
                        (pdbid1->eKind == DBKIND_PROPID) ||
                        (pdbid1->eKind == DBKIND_GUID)) )
                        return S_OK;
                else
                        return S_FALSE;
        }
        HRESULT CopyDBIDs(DBID* pdbidDest,  const DBID* pdbidSrc)
        {
                size_t  cwchBuffer;

                ATLASSERT( pdbidDest || pdbidSrc );

                if( !pdbidDest || !pdbidSrc )
                        return S_FALSE;

                // Save eKind
                pdbidDest->eKind = pdbidSrc->eKind;

                switch( pdbidSrc->eKind )
                {

                        case DBKIND_GUID_NAME:
                                pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
                                cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
                                cwchBuffer++;
                                pdbidDest->uName.pwszName = (PWSTR)CoTaskMemAlloc(cwchBuffer * sizeof(WCHAR));
                                if( pdbidDest->uName.pwszName )
                                        memcpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
                                else
                                        return E_OUTOFMEMORY;
                                break;

                        case DBKIND_GUID_PROPID:
                                pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
                                pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
                                break;
                        case DBKIND_NAME:
                                cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
                                cwchBuffer++;
                                pdbidDest->uName.pwszName = (PWSTR)CoTaskMemAlloc(cwchBuffer * sizeof(WCHAR));
                                if( pdbidDest->uName.pwszName )
                                        memcpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
                                else
                                        return E_OUTOFMEMORY;
                                break;
                        case DBKIND_PGUID_NAME:
                                pdbidDest->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
                                if( pdbidDest->uGuid.pguid )
                                {
                                        *(pdbidDest->uGuid.pguid) = *(pdbidSrc->uGuid.pguid);
                                        cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
                                        cwchBuffer++;
                                        pdbidDest->uName.pwszName = (PWSTR)CoTaskMemAlloc(cwchBuffer * sizeof(WCHAR));
                                        if( pdbidDest->uName.pwszName )
                                        {
                                                memcpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
                                                break;
                                        }
                                        else
                                        {
                                                CoTaskMemFree(pdbidDest->uGuid.pguid);
                                                pdbidDest->uGuid.pguid = NULL;
                                        }
                                }
                                return E_OUTOFMEMORY;
                        case DBKIND_PGUID_PROPID:
                                pdbidDest->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
                                if( pdbidDest->uGuid.pguid )
                                        *(pdbidDest->uGuid.pguid) = *(pdbidSrc->uGuid.pguid);
                                else
                                        return E_OUTOFMEMORY;
                                pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
                                break;
                        case DBKIND_PROPID:
                                pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
                                break;
                        case DBKIND_GUID:
                                pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
                                break;
                        default:
                                ATLASSERT(L"Unhandled dbid1.ekind");
                                return S_FALSE;
                }

                return S_OK;
        }
        static GUID* GetDBIDpGuid(DBID& dbid)
        {
                GUID* pGuid;
                switch (dbid.eKind)
                {
                case DBKIND_PGUID_NAME:
                case DBKIND_PGUID_PROPID:
                        pGuid = dbid.uGuid.pguid;
                        break;
                case DBKIND_GUID_NAME:
                case DBKIND_GUID_PROPID:
                case DBKIND_GUID:
                        pGuid = &(dbid.uGuid.guid);
                        break;
                default:
                        pGuid = NULL;
                }

                return pGuid;
        }
        static ULONG GetPropIDFromDBID(DBID& dbid)
        {
                switch (dbid.eKind)
                {
                case DBKIND_GUID_PROPID:
                case DBKIND_PGUID_PROPID:
                case DBKIND_PROPID:
                        return dbid.uName.ulPropid;
                default:
                        return 0;
                }
        }
        void FreeDBIDs(DBID* pdbidSrc)
        {
                switch( pdbidSrc->eKind )
                {

                        case DBKIND_GUID_NAME:
                                CoTaskMemFree(pdbidSrc->uName.pwszName);
                                break;
                        case DBKIND_NAME:
                                CoTaskMemFree(pdbidSrc->uName.pwszName);
                                break;
                        case DBKIND_PGUID_NAME:
                                CoTaskMemFree(pdbidSrc->uGuid.pguid);
                                CoTaskMemFree(pdbidSrc->uName.pwszName);
                                break;
                        case DBKIND_PGUID_PROPID:
                                CoTaskMemFree(pdbidSrc->uGuid.pguid);
                                break;
                        case DBKIND_GUID_PROPID:
                        case DBKIND_PROPID:
                        case DBKIND_GUID:
                                break;
                        default:
                                ATLASSERT(L"Unhandled dbid1.ekind");
                                break;
                }
        }
};

extern "C" const CLSID CLSID_DataConvert;

class CConvertHelper
{
public:
        CConvertHelper() {}
        HRESULT FinalConstruct()
        {
                HRESULT hr = ::CoCreateInstance(CLSID_DataConvert, NULL, CLSCTX_INPROC_SERVER, IID_IDataConvert, (void**)&m_spConvert);

                if (FAILED(hr))
                        return hr;

                // Check to see if the data conversion routine is 2.0 capable, if so.  Initialize
                // the conversion routine to be 2.0.
                DCINFO rgInfo[] = {{DCINFOTYPE_VERSION, {VT_UI4, 0, 0, 0, 0x0}}};
                CComPtr<IDCInfo> spIDCInfo;

                hr = m_spConvert->QueryInterface(&spIDCInfo);
                if (hr == S_OK)
                {
                        V_UI4(&rgInfo->vData) = 0x200;  // OLEDB Version 02.00
                        spIDCInfo->SetInfo(1, rgInfo);
                }

                return hr;
        }
        CComPtr<IDataConvert> m_spConvert;
};

// IDBCreateSessionImpl
template <class T, class SessionClass>
class ATL_NO_VTABLE IDBCreateSessionImpl : public IDBCreateSession
{
public:
        STDMETHOD(CreateSession)(IUnknown *pUnkOuter,
                                                         REFIID riid,
                                                         IUnknown **ppDBSession)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IDBCreateSessionImpl::CreateSession\n");
                if (ppDBSession == NULL)
                        return E_INVALIDARG;
                T* pT = (T*)this;
                if (!(pT->m_dwStatus & DSF_INITIALIZED))
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "IDBCreateSessionImpl::CreateSession : Error not initialized\n");
                        *ppDBSession = NULL;
                        return E_UNEXPECTED;
                }
                CComPolyObject<SessionClass> *pSession;

                // You can't QI for an interface other than IUnknown when aggregating
                // and creating the object.  You might ask for your own interface,
                // which would be bad.  Note, we return DB_E_NOAGGREGATION instead of
                // CLASS_E_NOAGGREGATION due to OLE DB constraints.
                if (pUnkOuter != NULL && !InlineIsEqualUnknown(riid))
                        return DB_E_NOAGGREGATION;

                HRESULT hr = CComPolyObject<SessionClass>::CreateInstance(pUnkOuter, &pSession);
                if (SUCCEEDED(hr))
                {
                        CComPtr<IObjectWithSite> spCreator;
                        hr = pSession->QueryInterface(IID_IObjectWithSite, (void**)&spCreator);
                        if (SUCCEEDED(hr))
                        {
                                spCreator->SetSite(this);
                                hr = pSession->QueryInterface(riid, (void**)ppDBSession);
                        }
                        else
                                delete pSession;
                }
                return hr;
        }
};

// IDBInitializeImpl
template <class T>
class ATL_NO_VTABLE IDBInitializeImpl : public IDBInitialize
{
public:
        IDBInitializeImpl()
        {
                m_dwStatus = 0;
                m_pCUtlPropInfo = NULL;
                m_cSessionsOpen = 0;
        }
        ~IDBInitializeImpl()
        {
                delete m_pCUtlPropInfo;
        }

        STDMETHOD(Uninitialize)(void)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IDBInitializeImpl::Uninitialize\n");
                T* pT = (T*)this;
                pT->Lock();
                if (pT->m_cSessionsOpen != 0)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "Uninitialized called with Open Sessions\n");
                        pT->Unlock();
                        return DB_E_OBJECTOPEN;
                }
                delete m_pCUtlPropInfo;
                m_pCUtlPropInfo = NULL;
                pT->m_dwStatus |= DSF_PERSIST_DIRTY;
                pT->m_dwStatus &= DSF_MASK_INIT;    // Clear all non-init flags.
                pT->Unlock();
                return S_OK;

        }

        LONG m_cSessionsOpen;
        DWORD m_dwStatus;
        CUtlPropInfo<T>* m_pCUtlPropInfo;

        STDMETHOD(Initialize)(void)
        {

                ATLTRACE2(atlTraceDBProvider, 0, "IDBInitializeImpl::Initialize\n");
                T *pT = (T*)(this);
                T::ObjectLock lock(pT);
                HRESULT hr;
                if (pT->m_dwStatus & DSF_INITIALIZED)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "IDBInitializeImpl::Initialize Error : Already Initialized\n");
                        return DB_E_ALREADYINITIALIZED;
                }
                delete m_pCUtlPropInfo;
                m_pCUtlPropInfo = NULL;
                ATLTRY(m_pCUtlPropInfo = new CUtlPropInfo<T>())
                if (m_pCUtlPropInfo == NULL)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "IDBInitializeImpl::Initialize Error : OOM\n");
                        return E_OUTOFMEMORY;
                }
                hr = m_pCUtlPropInfo->FInit();
                if (hr == S_OK)
                {
                        pT->m_dwStatus |= DSF_INITIALIZED;
                }
                else
                {
                        delete m_pCUtlPropInfo;
                        m_pCUtlPropInfo = NULL;
                }
                return hr;
        }

};


// Implementation Class

class CPropColID :
        public PROPCOLID,
        public CDBIDOps
{
public:
        CPropColID()
        {
                VariantInit(&vValue);
        }
        ~CPropColID()
        {
                FreeDBIDs(&dbidProperty);
                VariantClear(&vValue);
        }
        bool operator==(const CPropColID& colId)
        {
                return (CompareDBIDs(&dbidProperty, &(colId.dbidProperty)) == S_OK) ? true : false;
        }

};

class CColumnIds :
        public CDBIDOps,
        public CSimpleArray<CPropColID>

{
public:
        PPROPCOLID AddNode()
        {
                CPropColID colID;
                if (Add(colID))
                        return &(m_aT[GetSize()]);
                return NULL;
        }
        HRESULT RemoveColumnId(const DBID* pdbidProp)
        {
                for (int i = 0; i < GetSize(); i++)
                {
                        if (CompareDBIDs(pdbidProp, &(m_aT[i].dbidProperty)) == S_OK)
                                return (RemoveAt(i)) ? S_OK : E_FAIL;
                }

                return E_FAIL;
        }
        HRESULT AddColumnId(DBPROP* pProp)
        {
                CPropColID colID;
                HRESULT hr = CopyDBIDs(&(colID.dbidProperty),&(pProp->colid));
                if(FAILED(hr))
                        return hr;
                colID.dwOption = pProp->dwOptions;
                hr = VariantCopy(&(colID.vValue),&(pProp->vValue));
                if(FAILED(hr))
                        return hr;
                return (Add(colID)) ? S_OK : E_OUTOFMEMORY;

        }
        HRESULT AddColumnId(PPROPCOLID pPropNode)
        {
                CPropColID colID;
                HRESULT hr = CopyDBIDs(&(colID.dbidProperty),&(pPropNode->dbidProperty));
                if(FAILED(hr))
                        return hr;
                colID.dwOption = pPropNode->dwOption;
                hr = VariantCopy(&(colID.vValue),&(pPropNode->vValue));
                if(FAILED(hr))
                        return hr;
                return (Add(colID)) ? S_OK : E_OUTOFMEMORY;

        }
        ULONG GetCountOfPropColids(){ return (ULONG)GetSize();}
        PPROPCOLID FindColumnId(const DBID* pdbidProp)
        {
                for (int i = 0; i < GetSize(); i++)
                {
                        if (CompareDBIDs(pdbidProp, &(m_aT[i].dbidProperty)) == S_OK)
                                return &(m_aT[i]);
                }

                return NULL;
        }
        HRESULT GetValue(int iColId, DWORD* pdwOptions, DBID* pColid, VARIANT* pvValue)
        {
                HRESULT     hr;

                ATLASSERT(pdwOptions && pColid && pvValue);
                ATLASSERT(iColId >= 0 && iColId < m_nSize);

                CPropColID& colId = m_aT[iColId];
                *pdwOptions = colId.dwOption;
                CopyDBIDs( pColid, &(colId.dbidProperty) );
                if(FAILED(hr = VariantCopy(pvValue, &(colId.vValue))))
                        return hr;
                return S_OK;
        }
};

const ULONG     cchDescBuffSize = 256;
const DWORD     DBINTERNFLAGS_CHANGED       = 0x00000001;
// Rules for GetPropertiesArgChk
const DWORD     ARGCHK_PROPERTIESINERROR    = 0x00000001;

// Implementation Class
template <class T>
class CUtlPropInfo : public CBitFieldOps, public CDBIDOps
{
public:
        enum EnumGetPropInfo
        {
                GETPROPINFO_ALLPROPIDS      = 0x0001,
                GETPROPINFO_NOTSUPPORTED    = 0x0002,
                GETPROPINFO_ERRORSOCCURRED  = 0x0004,
                GETPROPINFO_VALIDPROP       = 0x0008
        };

        CUtlPropInfo()
        {
                m_cUPropSet      = 0;
                m_pUPropSet      = NULL;

                m_cPropSetDex   = 0;
                m_rgiPropSetDex = NULL;

                m_cElemPerSupported = 0;
                m_rgdwSupported = NULL;
        }
        ~CUtlPropInfo()
        {
                delete[] m_rgiPropSetDex;
                delete[] m_rgdwSupported;
                if (m_pUPropSet != NULL)
                        CoTaskMemFree(m_pUPropSet);
        }

        //Determine the number of description buffers needed
        ULONG CalcDescripBuffers(ULONG cPropInfoSet, DBPROPINFOSET* pPropInfoSet)
        {
                ULONG   cBuffers = 0;

                ATLASSERT(m_pUPropSet);
                ATLASSERT(cPropInfoSet && pPropInfoSet);

                for(ULONG ulSet=0; ulSet<cPropInfoSet; ulSet++)
                {
                        if( GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_OK)
                        {
                                for(ULONG ul=0; ul<m_cPropSetDex; ul++)
                                {
                                        cBuffers += m_pUPropSet[m_rgiPropSetDex[ul]].cUPropInfo;
                                }
                        }
                }

                return cBuffers;
        }
        //Retrieve the property set indexes that match this property set.
        HRESULT GetPropertySetIndex(const GUID* pPropertySet)
        {
                DWORD   dwFlag = 0;
                ULONG   ulSet;

                ATLASSERT(m_cUPropSet && m_pUPropSet);
                ATLASSERT(m_rgiPropSetDex);
                ATLASSERT(pPropertySet);

                m_cPropSetDex = 0;

                if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_DATASOURCEALL))
                {
                        dwFlag = DBPROPFLAGS_DATASOURCE;
                }
                else if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_DATASOURCEINFOALL))
                {
                        dwFlag = DBPROPFLAGS_DATASOURCEINFO;
                }
                else if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_ROWSETALL))
                {
                        dwFlag = DBPROPFLAGS_ROWSET;
                }
                else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_DBINITALL))
                {
                        dwFlag = DBPROPFLAGS_DBINIT;
                }
                else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_SESSIONALL))
                {
                        dwFlag = DBPROPFLAGS_SESSION;
                }
                else // No scan required, just look for match.
                {
                        for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
                        {
                                if( *(m_pUPropSet[ulSet].pPropSet) == *pPropertySet )
                                {
                                        m_rgiPropSetDex[m_cPropSetDex] = ulSet;
                                        m_cPropSetDex++;
                                        break;
                                }
                        }
                        goto EXIT;
                }

                // Scan through the property sets looking for matching attributes
                for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
                {
                        if( m_pUPropSet[ulSet].pUPropInfo[0].dwFlags & dwFlag )
                        {
                                m_rgiPropSetDex[m_cPropSetDex] = ulSet;
                                m_cPropSetDex++;
                        }
                }

        EXIT:
                return (m_cPropSetDex) ? S_OK : S_FALSE;

        }
        //Retrieve the property id pointer
        HRESULT GetUPropInfoPtr(ULONG iPropSetDex, DBPROPID dwPropertyId, UPROPINFO** ppUPropInfo)
        {
                // Scan through the property sets looking for matching attributes
                for(ULONG ulProps=0; ulProps<m_pUPropSet[iPropSetDex].cUPropInfo; ulProps++)
                {
                        if( m_pUPropSet[iPropSetDex].pUPropInfo[ulProps].dwPropId == dwPropertyId )
                        {
                                *ppUPropInfo = &(m_pUPropSet[iPropSetDex].pUPropInfo[ulProps]);
                                // Test to see if the property is supported for this
                                // instantiation
                                return (TESTBIT(&(m_rgdwSupported[iPropSetDex * m_cElemPerSupported]), ulProps)) ? S_OK : S_FALSE;
                        }
                }
                return S_FALSE;
        }
        HRESULT FInit(GUID* pguidSet = (GUID*)&GUID_NULL)
        {
                HRESULT hr;

                hr = InitAvailUPropSets(&m_cUPropSet, &m_pUPropSet, &m_cElemPerSupported, pguidSet);
                if (FAILED(hr))
                        return hr;
                ATLASSERT((m_cUPropSet != 0) && (m_cElemPerSupported != 0));
                if(!m_cUPropSet || !m_cElemPerSupported)
                        return E_FAIL;

                ATLTRY(m_rgdwSupported = new DWORD[m_cUPropSet * m_cElemPerSupported])
                if(m_rgdwSupported == NULL)
                        return E_OUTOFMEMORY;

                if(FAILED(hr = InitUPropSetsSupported()))
                {
                        delete[] m_rgdwSupported;
                        m_rgdwSupported = NULL;
                        return hr;
                }
                if(m_cUPropSet)
                {
                        ATLTRY(m_rgiPropSetDex = new ULONG[m_cUPropSet])
                        if(m_rgiPropSetDex == NULL)
                        {
                                delete [] m_rgdwSupported;
                                return E_OUTOFMEMORY;
                        }
                }
                return S_OK;
        }
        HRESULT GetPropertyInfo(ULONG cPropertySets,
                                                const DBPROPIDSET rgPropertySets[], ULONG* pcPropertyInfoSets,
                                                DBPROPINFOSET** prgPropertyInfoSets,
                                                WCHAR** ppDescBuffer, bool bInitialized = true,
                                                const GUID* pGuid = NULL)
        {
                HRESULT hr = S_OK;
                ULONG ul, ulSet, ulNext, ulEnd;
                ULONG ulOutIndex;
                ULONG cSets;
                ULONG cPropInfos;
                ULONG ulIndex = 0;
                DWORD dwStatus = 0;
                DBPROPINFO* pPropInfo = NULL;
                DBPROPINFO* pCurPropInfo = NULL;
                WCHAR* pDescBuffer = NULL;
                DBPROPINFOSET* pPropInfoSet = NULL;
                UPROPINFO* pUPropInfo = NULL;
                WCHAR wszBuff[256];
                int cch;

                // If the consumer does not restrict the property sets
                // by specify an array of property sets and a cPropertySets
                // greater than 0, then we need to make sure we
                // have some to return
                if(cPropertySets == 0)
                {
                        // Determine the number of property sets supported
                        // In this case, it usually the enumerator or data source asking for
                        // DBPROPSET_DBINIT information.

                        if (pGuid != NULL)
                                cSets = 1;
                        else
                                cSets = m_cUPropSet;
                }
                else
                {
                        cSets = 0;

                        // Determine number of property sets required
                        // This is only required when any of the "special" property set GUIDs were specified
                        for(ulSet=0; ulSet<cPropertySets; ulSet++)
                        {
                                if (GetPropertySetIndex(&(rgPropertySets[ulSet].guidPropertySet)) == S_OK)
                                        cSets += m_cPropSetDex;
                                else
                                        cSets++;
                        }
                }
                ATLASSERT(cSets);

                // Allocate the DBPROPINFOSET structures
                pPropInfoSet = (DBPROPINFOSET*)CoTaskMemAlloc(cSets * sizeof(DBPROPINFOSET));
                if(pPropInfoSet == NULL)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "Could not allocate DBPROPSET array for GetProperties\n");
                        hr =  E_OUTOFMEMORY;
                        goto EXIT;
                }

                memset(pPropInfoSet, 0, cSets * sizeof(DBPROPINFOSET));

                ulOutIndex = 0;
                // VC 6.0 ulEnd = cPropertySets == 0 ? cSets : cPropertySets;
                ulEnd = cSets; // VC 6.0 SP3

                // Fill in the output array
                for(ulSet=0; ulSet<ulEnd; ulSet++)
                {
                        // Depending of if Property sets are specified store the
                        // return property set.
                        if (cPropertySets == 0)
                        {
                                if (pGuid != NULL)
                                {
                                        GUID const& guidSet = *pGuid;
                                        if( (InlineIsEqualGUID(guidSet, DBPROPSET_DATASOURCEALL) ||
                                                InlineIsEqualGUID(guidSet, DBPROPSET_DATASOURCEINFOALL) ||
                                                InlineIsEqualGUID(guidSet, DBPROPSET_DBINITALL) ||
                                                InlineIsEqualGUID(guidSet, DBPROPSET_SESSIONALL) ||
                                                InlineIsEqualGUID(guidSet, DBPROPSET_ROWSETALL)) &&
                                                GetPropertySetIndex(&guidSet) == S_OK )
                                        {
                                                for(ul=0; ul<m_cPropSetDex; ul++,ulOutIndex++)
                                                {
                                                        pPropInfoSet[ulOutIndex].guidPropertySet    = *(m_pUPropSet[m_rgiPropSetDex[ul]].pPropSet);
                                                        pPropInfoSet[ulOutIndex].cPropertyInfos     = 0;
                                                        ulIndex = m_rgiPropSetDex[ul];
                                                }
                                        }
                                        else
                                        {
                                                for (ULONG l=0; l<m_cUPropSet; l++)
                                                {
                                                        if (InlineIsEqualGUID(*m_pUPropSet[l].pPropSet, *pGuid))
                                                                ulIndex = l;
                                                }

                                                if (l == m_cUPropSet)
                                                {
                                                        ATLTRACE2(atlTraceDBProvider, 0, "Property Info Set not supported");
                                                        ulIndex = 0;
                                                }
                                                pPropInfoSet[ulSet].guidPropertySet = *pGuid;
                                        }
                                }
                                else
                                {
                                        pPropInfoSet[ulSet].guidPropertySet = *(m_pUPropSet[ulSet].pPropSet);
                                }
                        }
                        else
                        {
                                GUID const& guidSet = rgPropertySets[ulSet].guidPropertySet;
                                if( (InlineIsEqualGUID(guidSet, DBPROPSET_DATASOURCEALL) ||
                                        InlineIsEqualGUID(guidSet, DBPROPSET_DATASOURCEINFOALL) ||
                                        InlineIsEqualGUID(guidSet, DBPROPSET_DBINITALL) ||
                                        InlineIsEqualGUID(guidSet, DBPROPSET_SESSIONALL) ||
                                        InlineIsEqualGUID(guidSet, DBPROPSET_ROWSETALL)) &&
                                        GetPropertySetIndex(&guidSet) == S_OK )
                                {
                                        for(ul=0; ul<m_cPropSetDex; ul++,ulOutIndex++)
                                        {
                                                pPropInfoSet[ulOutIndex].guidPropertySet    = *(m_pUPropSet[m_rgiPropSetDex[ul]].pPropSet);
                                                pPropInfoSet[ulOutIndex].cPropertyInfos     = 0;
                                        }
                                }
                                else
                                {
                                        // Handle non-category property sets
                                        // Handle unknown property sets
                                        pPropInfoSet[ulOutIndex].guidPropertySet = guidSet;
                                        pPropInfoSet[ulOutIndex].cPropertyInfos  = rgPropertySets[ulSet].cPropertyIDs;
                                        ulOutIndex++;
                                }
                        }
                }

                // Allocate a Description Buffer if needed
                if( ppDescBuffer )
                {
                        ULONG cBuffers = CalcDescripBuffers(cSets, pPropInfoSet);
                        if( cBuffers != 0 )
                        {
                                pDescBuffer = (WCHAR*)CoTaskMemAlloc(cBuffers * cchDescBuffSize * sizeof(WCHAR));
                                if(pDescBuffer == NULL)
                                {
                                        hr = E_OUTOFMEMORY;
                                        goto EXIT;
                                }
                                *ppDescBuffer = pDescBuffer;
                                memset(pDescBuffer, 0, (cBuffers * cchDescBuffSize * sizeof(WCHAR)));
                        }
                }

                // Process requested or derived Property sets
                dwStatus = 0;
                for(ulSet=0; ulSet<cSets; ulSet++)
                {
                        ulNext=0;
                        cPropInfos = 0;
                        pPropInfo = NULL;
                        dwStatus &= (GETPROPINFO_ERRORSOCCURRED | GETPROPINFO_VALIDPROP);

                        // Calculate the number of property nodes needed for this
                        // property set.
                        if( cPropertySets == 0 )
                        {
                                ULONG ulTempSet;
                                if (pGuid != NULL)
                                        ulTempSet = ulIndex;
                                else
                                        ulTempSet = ulSet;

                                cPropInfos = m_pUPropSet[ulTempSet].cUPropInfo;
                                dwStatus |= GETPROPINFO_ALLPROPIDS;
                                m_rgiPropSetDex[0] = ulTempSet;
                                m_cPropSetDex = 1;
                        }
                        else
                        {
                                // If the count of PROPIDs is 0 (NOTE: the above routine already determined
                                // if it belonged to a category and if so set the count of properties to 0 for
                                // each propset in that category.
                                if( pPropInfoSet[ulSet].cPropertyInfos == 0 )
                                {
                                        dwStatus |= GETPROPINFO_ALLPROPIDS;
                                        // We have to determine if the property set is supported and if so
                                        // the count of properties in the set.
                                        if( GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_OK)
                                        {
                                                ATLASSERT( m_cPropSetDex == 1 );

                                                cPropInfos += m_pUPropSet[m_rgiPropSetDex[0]].cUPropInfo;
                                        }
                                        else
                                        {
                                                // Not Supported
                                                dwStatus |= GETPROPINFO_ERRORSOCCURRED;
                                                goto NEXT_SET;
                                        }
                                }
                                else
                                {
                                        // We also handle the case here where the user has requested
                                        // a non-initialization group property info set while the
                                        // provider is not initialized.  In this case, properties should
                                        // not be set.
                                        cPropInfos = pPropInfoSet[ulSet].cPropertyInfos;
                                        if( (GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_FALSE)
                                                || (!bInitialized &&
                                                !(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINIT)) &&
                                                !(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINITALL))))
                                        {
                                                dwStatus |= GETPROPINFO_NOTSUPPORTED;
                                                dwStatus |= GETPROPINFO_ERRORSOCCURRED;
                                        }
                                }
                        }


                        // Allocate DBPROP array
                        ATLASSERT( cPropInfos != 0 );
                        pPropInfo = (DBPROPINFO*)CoTaskMemAlloc(cPropInfos * sizeof(DBPROPINFO));
                        if( pPropInfo )
                        {
                                // Initialize Buffer
                                memset(pPropInfo, 0, cPropInfos * sizeof(DBPROPINFO));
                                for(ULONG ulProp=0; ulProp<cPropInfos; ulProp++)
                                {
                                        VariantInit(&(pPropInfo[ulProp].vValues));
                                        if( dwStatus & GETPROPINFO_NOTSUPPORTED )
                                        {
                                                // Not supported, thus we need to mark all as NOT_SUPPORTED
                                                pPropInfo[ulProp].dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
                                                pPropInfo[ulProp].dwFlags = DBPROPFLAGS_NOTSUPPORTED;
                                                dwStatus |= GETPROPINFO_ERRORSOCCURRED;
                                        }
                                }
                                // Make sure we support the property set
                                if( dwStatus & GETPROPINFO_NOTSUPPORTED )
                                {
                                        ulNext = cPropInfos;
                                        goto NEXT_SET;
                                }

                                // Retrieve the property information for this property set
                                for(ul=0; ul<m_cPropSetDex; ul++)
                                {
                                        pUPropInfo = (m_pUPropSet[m_rgiPropSetDex[ul]].pUPropInfo);
                                        ATLASSERT( pUPropInfo );

                                        // Retrieve current value of properties
                                        if( dwStatus & GETPROPINFO_ALLPROPIDS )
                                        {
                                                for(ulProp=0; ulProp<m_pUPropSet[m_rgiPropSetDex[ul]].cUPropInfo; ulProp++)
                                                {
                                                        // Verify property is supported, if not do not return
                                                        if( !TESTBIT(&(m_rgdwSupported[m_rgiPropSetDex[ul] * m_cElemPerSupported]), ulProp) )
                                                                continue;

                                                        pCurPropInfo = &(pPropInfo[ulNext]);

                                                        // If the ppDescBuffer pointer was not NULL, then
                                                        // we need supply description of the properties
                                                        if( ppDescBuffer )
                                                        {
                                                                // Set Buffer pointer
                                                                pCurPropInfo->pwszDescription = pDescBuffer;

                                                                // Load the string into temp buffer
                                                                cch = LoadDescription(pUPropInfo[ulProp].ulIDS, wszBuff, (sizeof(wszBuff)/sizeof(*wszBuff)));
                                                                if( cch )
                                                                {
                                                                        // Adjust for '\0'
                                                                        cch++;

                                                                        // Transfer to official buffer if room
                                                                        memcpy(pDescBuffer, wszBuff, cch * sizeof(WCHAR));
                                                                        pDescBuffer += cch;
                                                                }
                                                                else
                                                                {
                                                                        wcscpy(pDescBuffer, L"UNKNOWN");
                                                                        pDescBuffer += (wcslen(L"UNKNOWN") + 1);
                                                                }
                                                        }

                                                        pCurPropInfo->dwPropertyID = pUPropInfo[ulProp].dwPropId;
                                                        pCurPropInfo->dwFlags = pUPropInfo[ulProp].dwFlags;
                                                        pCurPropInfo->vtType = pUPropInfo[ulProp].VarType;
                                                        pCurPropInfo->vValues.vt = VT_EMPTY;

                                                        dwStatus |= GETPROPINFO_VALIDPROP;
                                                        // Increment to next available buffer
                                                        ulNext++;
                                                }
                                        }
                                        else
                                        {
                                                ATLASSERT( m_cPropSetDex == 1 );

                                                for( ulProp = 0; ulProp < cPropInfos; ulProp++, ulNext++ )
                                                {
                                                        pCurPropInfo = &(pPropInfo[ulNext]);

                                                        // Process Properties based on Restriction array.
                                                        pCurPropInfo->dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];

                                                        if( GetUPropInfoPtr(m_rgiPropSetDex[ul], pCurPropInfo->dwPropertyID, &pUPropInfo)
                                                                == S_OK )
                                                        {
                                                                // If the ppDescBuffer pointer was not NULL, then
                                                                // we need supply description of the properties
                                                                if( ppDescBuffer )
                                                                {
                                                                        // Set Buffer pointer
                                                                        pCurPropInfo->pwszDescription = pDescBuffer;

                                                                        // Load the string into temp buffer
                                                                        cch = LoadDescription(pUPropInfo->ulIDS, wszBuff, (sizeof(wszBuff)/sizeof(*wszBuff)));
                                                                        if( cch )
                                                                        {
                                                                                // Adjust for '\0'
                                                                                cch++;

                                                                                // Transfer to official buffer if room
                                                                                memcpy(pDescBuffer, wszBuff, cch * sizeof(WCHAR));
                                                                                pDescBuffer += cch;
                                                                        }
                                                                        else
                                                                        {
                                                                                wcscpy(pDescBuffer, L"UNKNOWN");
                                                                                pDescBuffer += (wcslen(L"UNKNOWN") + 1);
                                                                        }
                                                                }

                                                                pCurPropInfo->dwPropertyID = pUPropInfo->dwPropId;
                                                                pCurPropInfo->dwFlags = pUPropInfo->dwFlags;
                                                                pCurPropInfo->vtType = pUPropInfo->VarType;

                                                                dwStatus |= GETPROPINFO_VALIDPROP;
                                                        }
                                                        else
                                                        {
                                                                // Not Supported
                                                                pCurPropInfo->dwFlags = DBPROPFLAGS_NOTSUPPORTED;
                                                                dwStatus |= GETPROPINFO_ERRORSOCCURRED;
                                                        }
                                                }
                                        }
                                }
                        }
                        else
                        {
                                hr = E_OUTOFMEMORY;
                                goto EXIT;
                        }

NEXT_SET:
                        pPropInfoSet[ulSet].cPropertyInfos = ulNext;
                        pPropInfoSet[ulSet].rgPropertyInfos = pPropInfo;
                }

                // Success, set return values
                *pcPropertyInfoSets = cSets;
                *prgPropertyInfoSets = pPropInfoSet;

                // At least one propid was marked as not S_OK
                if( dwStatus & GETPROPINFO_ERRORSOCCURRED )
                {
                        // If at least 1 property was set
                        if( dwStatus & GETPROPINFO_VALIDPROP )
                                return DB_S_ERRORSOCCURRED;
                        else
                        {
                                // Do not free any of the rgPropertyInfoSets, but
                                // do free the ppDescBuffer
                                if( pDescBuffer )
                                {
                                        ATLASSERT( ppDescBuffer );
                                        CoTaskMemFree(pDescBuffer);
                                        *ppDescBuffer = NULL;
                                }
                                return DB_E_ERRORSOCCURRED;
                        }
                }

                return S_OK;
EXIT:
                // Check if failure and clean up any allocated memory
                if( FAILED(hr) &&
                        (hr != DB_E_ERRORSOCCURRED) )
                {
                        // Free Description Buffer
                        if( pDescBuffer )
                        {
                                ATLASSERT( ppDescBuffer );

                                CoTaskMemFree(pDescBuffer);
                                *ppDescBuffer = NULL;
                        }

                        if( pPropInfoSet )
                        {
                                // Loop through Property Sets
                                for(ulSet=0; ulSet<cSets; ulSet++)
                                {
                                        if( pPropInfoSet[ulSet].rgPropertyInfos )
                                                CoTaskMemFree(pPropInfoSet[ulSet].rgPropertyInfos);
                                }

                                CoTaskMemFree(pPropInfoSet);
                        }
                }

                return hr;
        }

        ULONG m_cUPropSet; //count of UPropSet items
        UPROPSET* m_pUPropSet; //Pointer to UPropset items
        ULONG m_cPropSetDex;    //count of UPropSet Indexes
        ULONG* m_rgiPropSetDex;//array of UPropSet Index values
        ULONG m_cElemPerSupported; //number of DWORDS per UPropSet to indicate supported UPropIds
        DWORD* m_rgdwSupported;//array of DWORDs indicating supported UPropIds

        HRESULT InitAvailUPropSets(ULONG* pcUPropSet, UPROPSET** ppUPropSet, ULONG* pcElemPerSupported, GUID* pguid)
        {
                ATLASSERT(pcUPropSet && ppUPropSet);
                if (*ppUPropSet != NULL)
                {
                        CoTaskMemFree(*ppUPropSet);
                        *ppUPropSet = NULL;
                }
                int cSets = (int)(INT_PTR)T::_GetPropSet(NULL, pcElemPerSupported);
                UPROPSET* pSet = (UPROPSET*)CoTaskMemAlloc(sizeof(UPROPSET) * cSets);
                if (pSet == NULL)
                        return E_OUTOFMEMORY;
                *ppUPropSet = T::_GetPropSet(pcUPropSet, pcElemPerSupported, pSet, pguid);
                return S_OK;
        }
        virtual HRESULT InitUPropSetsSupported()
        {
                ULONG cPropSet = 0, cElemsPerSupported = 0;
                int cSets = (int)(INT_PTR)T::_GetPropSet(NULL, &cElemsPerSupported);
                UPROPSET* pSet = (UPROPSET*)CoTaskMemAlloc(sizeof(UPROPSET) * cSets);
                if (pSet == NULL)
                        return E_OUTOFMEMORY;
                pSet = T::_GetPropSet(&cPropSet, &cElemsPerSupported, pSet);
                memset(m_rgdwSupported, 0xFFFF, cPropSet * cElemsPerSupported * sizeof(DWORD));
                CoTaskMemFree(pSet);
                return S_OK;
        }
        //Load a localized description
        int LoadDescription(ULONG ids, PWSTR pwszBuff, ULONG cchBuff)
        {
                USES_CONVERSION;
                TCHAR* pszBuf = (TCHAR*)_alloca(cchBuff * sizeof(TCHAR));
                if (pszBuf == NULL)
                        return 0;
                int nTemp = LoadString(_pModule->GetResourceInstance(), ids, pszBuf, cchBuff);
                wcscpy(pwszBuff, T2W(pszBuf));
                return nTemp;
        }
};

class ATL_NO_VTABLE CUtlPropsBase : public CBitFieldOps, public CDBIDOps
{
public:

        ULONG m_cUPropSet; //count of UPropSet items
        UPROPSET* m_pUPropSet; //Pointer to UPropset items
        UPROP* m_pUProp;
        ULONG m_cUPropSetHidden; //Count of Hidden items
        DWORD m_dwFlags; //Configuration flags
        ULONG m_cPropSetDex; //count of UPropSet Indexes
        ULONG* m_rgiPropSetDex; //pointer to Array of UPropSet Index values
        ULONG m_cElemPerSupported;//number of DWORDS per UPropSet to indicate supported UPropIds
        DWORD* m_rgdwSupported; //pointer to array of DWORDs indicating supported UPropIds
        DWORD* m_rgdwPropsInError;//pointer to array of DWORDs indicating if property is in error

        enum EnumUPropSetFlags
        {
                UPROPSET_HIDDEN             = 0x00000001,
                UPROPSET_PASSTHROUGH        = 0x00000002
        };
        enum EnumGetProp
        {
                GETPROP_ALLPROPIDS          = 0x0001,
                GETPROP_NOTSUPPORTED        = 0x0002,
                GETPROP_ERRORSOCCURRED      = 0x0004,
                GETPROP_VALIDPROP           = 0x0008,
                GETPROP_PROPSINERROR        = 0x0010
        };

        enum EnumSetProp
        {
                SETPROP_BADOPTION           = 0x0001,
                SETPROP_NOTSUPPORTED        = 0x0002,
                SETPROP_VALIDPROP           = 0x0004,
                SETPROP_ERRORS              = 0x0008,
                SETPROP_COLUMN_LEVEL        = 0x0010,
                SETPROP_WAS_REQUIRED        = 0x0020
        };

        HRESULT SetPassThrough(const DBPROPSET* pPropSet)
        {
                ATLASSERT(pPropSet);

                DBPROP* pProp = pPropSet->rgProperties;

                //Default implementation just sets all properties as NOTSUPPORTED
                for( ULONG ul=0; ul<pPropSet->cProperties; ul++, pProp++ )
                        pProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;

                return DB_E_ERRORSOCCURRED;
        }

        HRESULT GetIndexofPropIdinPropSet(ULONG iCurSet, DBPROPID dwPropertyId, ULONG* piCurPropId)
        {
                ATLASSERT(piCurPropId);
                UPROPINFO* pUPropInfo = m_pUPropSet[iCurSet].pUPropInfo;
                for(ULONG ul=0; ul<m_pUPropSet[iCurSet].cUPropInfo; ul++)
                {
                        if( dwPropertyId == pUPropInfo[ul].dwPropId )
                        {
                                *piCurPropId = ul;
                                // Test to see if the property is supported for this
                                // instantiation
                                return (TESTBIT(&(m_rgdwSupported[iCurSet * m_cElemPerSupported]), ul)) ? S_OK : S_FALSE;
                        }
                }

                return S_FALSE;
        }

        virtual HRESULT IsValidValue(ULONG /*iCurSet*/, DBPROP* pDBProp)
        {
                ATLASSERT(pDBProp != NULL);
                CComVariant var = pDBProp->vValue;
                if (var.vt == VT_BOOL)
                {
                        if (var.boolVal != VARIANT_TRUE && var.boolVal != VARIANT_FALSE)
                                return S_FALSE;
                }

                return S_OK;
        }

        virtual HRESULT OnPropertyChanged(ULONG /*iCurSet*/, DBPROP* /*pDBProp*/) = 0;

        HRESULT SetProperty(ULONG iCurSet, ULONG iCurProp, DBPROP* pDBProp)
        {
                HRESULT hr = S_OK;
                UPROP* pUProp;
                UPROPVAL* pUPropVal;
                UPROPINFO* pUPropInfo;
                ULONG iUProp;

                ATLASSERT( pDBProp );

                // Set pointer to correct set
                pUProp = &(m_pUProp[iCurSet]);
                ATLASSERT( pUProp );

                pUPropInfo = &(m_pUPropSet[iCurSet].pUPropInfo[iCurProp]);
                ATLASSERT( pUPropInfo );

                // Determine the index within m_pUProp
                for(iUProp=0; iUProp<pUProp->cPropIds; iUProp++)
                {
                        if( (pUProp->rgpUPropInfo[iUProp])->dwPropId == pDBProp->dwPropertyID )
                                break;
                }

                if( iUProp >= pUProp->cPropIds )
                {
                        ATLASSERT( !"Should have found index of property to set" );
                        hr = E_FAIL;
                        pDBProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                        goto EXIT;
                }

                //Get the UPROPVAL node pointer within that propset.
                pUPropVal = &(pUProp->pUPropVal[iUProp]);
                ATLASSERT( pUPropVal );

                // Handle VT_EMPTY, which indicates to the provider to
                // reset this property to the providers default
                if( pDBProp->vValue.vt == VT_EMPTY )
                {
                        if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
                        {
                                // Remove any nodes, because the default applies to
                                // all columns
                                delete pUPropVal->pCColumnIds;
                                pUPropVal->pCColumnIds = NULL;
                        }

                        // Should clear here, since previous values may already
                        // have been cached and need to be replaced.
                        VariantClear(&(pUPropVal->vValue));

                        pUPropVal->dwFlags &= ~DBINTERNFLAGS_CHANGED;
                        hr = GetDefaultValue(iCurSet, pDBProp->dwPropertyID,
                                &(pUPropVal->dwOption), &(pUPropVal->vValue));

                        goto EXIT;
                }


                // Column Level
                if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
                {
                        // Check to see if it applies to all
                        if( (CompareDBIDs(&(pDBProp->colid), &DB_NULLID) == S_OK) )
                        {
                                // Remove the Columns Storage object
                                delete pUPropVal->pCColumnIds;
                                pUPropVal->pCColumnIds = NULL;
                                pUPropVal->dwOption = pDBProp->dwOptions;
                                if( FAILED(hr = VariantCopy(&(pUPropVal->vValue),
                                        &(pDBProp->vValue))) )
                                        goto EXIT;
                                pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
                        }
                        else // Does not apply to all columns
                        {
                                if( pUPropVal->pCColumnIds == NULL )
                                        ATLTRY(pUPropVal->pCColumnIds = new CColumnIds)

                                if( pUPropVal->pCColumnIds )
                                {
                                        if( FAILED(hr = (pUPropVal->pCColumnIds)->AddColumnId(pDBProp)) )
                                                goto EXIT;
                                        pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
                                }
                                else
                                {
                                        hr = E_OUTOFMEMORY;
                                        goto EXIT;
                                }

                        }
                }
                else
                {
                        // Set for non-column level properties
                        pUPropVal->dwOption = pDBProp->dwOptions;
                        if( FAILED(hr = VariantCopy(&(pUPropVal->vValue),
                                &(pDBProp->vValue))) )
                                goto EXIT;
                        OnPropertyChanged(iCurSet, pDBProp);
                        pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
                }

EXIT:
                if( SUCCEEDED(hr) )
                        pDBProp->dwStatus = DBPROPSTATUS_OK;

                return hr;
        }

        HRESULT SetProperties(const DWORD /*dwStatus*/, const ULONG cPropertySets,
                        const DBPROPSET rgPropertySets[], const ULONG cSelectProps = 1,
                        const GUID** ppGuid = NULL, bool bIsCreating = false)
        {
                DWORD dwState = 0;
                ULONG ulCurSet, ulProp, ulCurProp = 0;
                DBPROP* rgDBProp;
                UPROPINFO* pUPropInfo;
                VARIANT vDefaultValue;
                DWORD dwOption;

                // ppGuid specifies the property sets that the consumer can set based
                // on the interface that called this function.
                ATLASSERT(ppGuid != NULL);

                if ((cPropertySets != 0) && (rgPropertySets == NULL))
                        return E_INVALIDARG;

                // Initialize Variant
                VariantInit(&vDefaultValue);

                // Process property sets
                for(ULONG ulSet=0; ulSet<cPropertySets; ulSet++)
                {
                        if ((rgPropertySets[ulSet].cProperties != 0) && (rgPropertySets[ulSet].rgProperties == NULL))
                                return E_INVALIDARG;

                        bool bAvailable = false;
                        for (ULONG l=0; l<cSelectProps; l++)
                        {
                                if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
                                        bAvailable |= true;
                        }

                        // Make sure we support the property set
                        if( !bAvailable ||
                                (GetIndexofPropSet(&(rgPropertySets[ulSet].guidPropertySet), &ulCurSet) == S_FALSE ))
                        {
                                // Not supported, thus we need to mark all as NOT_SUPPORTED
                                rgDBProp = rgPropertySets[ulSet].rgProperties;
                                for(ulProp=0; ulProp<rgPropertySets[ulSet].cProperties; ulProp++)
                                {
                                        dwState |= SETPROP_ERRORS;
                                        dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
                                        rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                                }
                                continue;
                        }

                        // Handle property sets marked as pass through
                        if( m_pUPropSet[ulCurSet].dwFlags & UPROPSET_PASSTHROUGH )
                        {
                                HRESULT hr = SetPassThrough(&rgPropertySets[ulSet]);
                                if( hr == DB_E_ERRORSOCCURRED )
                                {
                                        dwState |= SETPROP_ERRORS;
                                        dwState |= SETPROP_WAS_REQUIRED;
                                }
                                else if( hr == DB_S_ERRORSOCCURRED )
                                {
                                        dwState |= SETPROP_ERRORS;
                                        dwState |= SETPROP_VALIDPROP;
                                }
                                else
                                {
                                        ATLASSERT( hr == S_OK );
                                        dwState |= SETPROP_VALIDPROP;
                                }

                                continue;
                        }

                        // Handle properties of a supported property set
                        rgDBProp = rgPropertySets[ulSet].rgProperties;
                        for(ulProp=0; ulProp<rgPropertySets[ulSet].cProperties; ulProp++)
                        {
                                // Is this a supported PROPID for this property set
                                if( GetIndexofPropIdinPropSet(ulCurSet, rgDBProp[ulProp].dwPropertyID,
                                        &ulCurProp) == S_FALSE)
                                {
                                        dwState |= SETPROP_ERRORS;
                                        dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
                                        rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                                        continue;
                                }

                                // Set the pUPropInfo pointer
                                pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulCurProp]);
                                ATLASSERT( pUPropInfo );

                                // check dwOption for a valid option
                                if( (rgDBProp[ulProp].dwOptions != DBPROPOPTIONS_REQUIRED)  &&
                                        (rgDBProp[ulProp].dwOptions != DBPROPOPTIONS_SETIFCHEAP) )
                                {
                                        ATLTRACE2(atlTraceDBProvider, 0, "SetProperties dwOptions Invalid: %u\n", rgDBProp[ulProp].dwOptions);
                                        dwState |= SETPROP_ERRORS;
                                        dwState |= SETPROP_WAS_REQUIRED;
                                        rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADOPTION;
                                        continue;
                                }

                                // Check that the property is settable
                                // We do not check against DBPROPFLAGS_CHANGE here
                                if( (pUPropInfo->dwFlags & DBPROPFLAGS_WRITE) == 0 )
                                {
                                        rgDBProp[ulProp].dwStatus = DBPROPSTATUS_OK;

                                        VariantClear(&vDefaultValue);

                                        // VT_EMPTY against a read only property should be a no-op since
                                        // the VT_EMPTY means the default.
                                        if( V_VT(&rgDBProp[ulProp].vValue) == VT_EMPTY )
                                        {
                                                dwState |= SETPROP_VALIDPROP;
                                                continue;
                                        }

                                        if( SUCCEEDED(GetDefaultValue(ulCurSet, rgDBProp[ulProp].dwPropertyID,
                                                        &dwOption, &(vDefaultValue))) )
                                        {
                                                if( V_VT(&rgDBProp[ulProp].vValue) ==  V_VT(&vDefaultValue) )
                                                {
                                                        switch( V_VT(&vDefaultValue) )
                                                        {
                                                                case VT_BOOL:
                                                                        if( V_BOOL(&rgDBProp[ulProp].vValue) == V_BOOL(&vDefaultValue) )
                                                                        {
                                                                                dwState |= SETPROP_VALIDPROP;
                                                                                continue;
                                                                        }
                                                                        break;
                                                                case VT_I2:
                                                                        if( V_I2(&rgDBProp[ulProp].vValue) == V_I2(&vDefaultValue) )
                                                                        {
                                                                                dwState |= SETPROP_VALIDPROP;
                                                                                continue;
                                                                        }
                                                                        break;
                                                                case VT_I4:
                                                                        if( V_I4(&rgDBProp[ulProp].vValue) == V_I4(&vDefaultValue) )
                                                                        {
                                                                                dwState |= SETPROP_VALIDPROP;
                                                                                continue;
                                                                        }
                                                                        break;
                                                                case VT_BSTR:
                                                                        if( wcscmp(V_BSTR(&rgDBProp[ulProp].vValue), V_BSTR(&vDefaultValue)) == 0 )
                                                                        {
                                                                                dwState |= SETPROP_VALIDPROP;
                                                                                continue;
                                                                        }
                                                                        break;
                                                        }
                                                }
                                        }

                                        dwState |= SETPROP_ERRORS;
                                        dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
                                        rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSETTABLE;
                                        continue;
                                }

                                // Check that the property is being set with the correct VARTYPE
                                if( (rgDBProp[ulProp].vValue.vt != pUPropInfo->VarType) &&
                                        (rgDBProp[ulProp].vValue.vt != VT_EMPTY) )
                                {
                                        dwState |= SETPROP_ERRORS;
                                        dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
                                        rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADVALUE;
                                        continue;
                                }

                                // Check that the value is legal
                                if( (rgDBProp[ulProp].vValue.vt != VT_EMPTY) &&
                                        IsValidValue(ulCurSet, &(rgDBProp[ulProp])) == S_FALSE )
                                {
                                        dwState |= SETPROP_ERRORS;
                                        dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
                                        rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADVALUE;
                                        continue;
                                }


                                // Check for a bad COLID, we only catch bad DBIDs
                                if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
                                {
                                        if( CDBIDOps::IsValidDBID(&(rgDBProp[ulProp].colid)) == S_FALSE )
                                        {
                                                dwState |= SETPROP_ERRORS;
                                                dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
                                                rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADCOLUMN;
                                                continue;
                                        }
                                        dwState |= SETPROP_COLUMN_LEVEL;

                                }

                                if( SUCCEEDED(SetProperty(ulCurSet, ulCurProp, /*pUPropInfo,*/ &(rgDBProp[ulProp]))) )
                                {
                                        dwState |= SETPROP_VALIDPROP;
                                }
                        }
                }

                VariantClear(&vDefaultValue);

                // At least one propid was marked as not S_OK
                if( dwState & SETPROP_ERRORS )
                {
                        if (!bIsCreating)
                        {
                                return (dwState & SETPROP_VALIDPROP) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
                        }
                        else
                        {
                                return (dwState & SETPROP_WAS_REQUIRED) ? DB_E_ERRORSOCCURRED : DB_S_ERRORSOCCURRED;
                        }
                }

                return S_OK;
        }

        OUT_OF_LINE HRESULT CopyUPropVal(ULONG iPropSet, UPROPVAL* rgUPropVal)
        {
                HRESULT hr = S_OK;
                UPROP* pUProp;
                UPROPVAL* pUPropVal;
                DBPROP dbProp;

                ATLASSERT(rgUPropVal);
                ATLASSERT(iPropSet < m_cUPropSet);

                VariantInit(&dbProp.vValue);

                pUProp = &(m_pUProp[iPropSet]);
                for(ULONG ul=0; ul<pUProp->cPropIds; ul++)
                {
                        pUPropVal = &(pUProp->pUPropVal[ul]);

                        // Transfer dwOptions
                        rgUPropVal[ul].dwOption = pUPropVal->dwOption;

                        // Transfer Flags
                        rgUPropVal[ul].dwFlags = pUPropVal->dwFlags;

                        // Transfer Column Properties
                        if( pUPropVal->pCColumnIds )
                        {
                                ATLTRY(rgUPropVal[ul].pCColumnIds = new CColumnIds)
                                if( rgUPropVal[ul].pCColumnIds )
                                {
                                        CColumnIds* pColIds = pUPropVal->pCColumnIds;
                                        for (int i = 0; i < pColIds->GetSize(); i++)
                                        {
                                                hr = (pUPropVal->pCColumnIds)->GetValue(i, &(dbProp.dwOptions),&(dbProp.colid), &(dbProp.vValue));
                                                if( FAILED(hr) )
                                                        goto EXIT;
                                                if( FAILED(hr = (rgUPropVal[ul].pCColumnIds)->AddColumnId(&dbProp)) )
                                                        goto EXIT;
                                        }
                                }
                                else
                                {
                                        hr = E_OUTOFMEMORY;
                                        goto EXIT;
                                }
                        }
                        else
                        {
                                rgUPropVal[ul].pCColumnIds = NULL;
                        }

                        // Transfer value
                        VariantInit(&(rgUPropVal[ul].vValue));
                        if( FAILED(hr = VariantCopy(&(rgUPropVal[ul].vValue),
                                &(pUPropVal->vValue))) )
                                goto EXIT;
                }

EXIT:
                VariantClear(&(dbProp.vValue));
                return hr;
        }
        void ClearPropertyInError()
        {
                ATLASSERT( m_rgdwPropsInError );
                memset(m_rgdwPropsInError, 0, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD));
        }

        void CopyUPropSetsSupported(DWORD* rgdwSupported)
        {
                memcpy(rgdwSupported, m_rgdwSupported, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD));
        }

        virtual HRESULT InitUPropSetsSupported() = 0;

        virtual HRESULT GetIndexofPropSet(const GUID* pPropSet, ULONG* pulCurSet) = 0;

        ULONG GetCountofWritablePropsInPropSet(ULONG iPropSet)
        {
                ULONG cWritable = 0;
                UPROPINFO* pUPropInfo;

                ATLASSERT( m_pUPropSet );
                ATLASSERT( iPropSet < m_cUPropSet );

                pUPropInfo = m_pUPropSet[iPropSet].pUPropInfo;

                for(ULONG ul=0; ul<m_pUPropSet[iPropSet].cUPropInfo; ul++)
                {
                        if( pUPropInfo[ul].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
                                cWritable++;
                }

                return cWritable;
        }

        void CopyUPropInfo(ULONG iPropSet, UPROPINFO** rgpUPropInfo)
        {
                ATLASSERT( rgpUPropInfo );
                ATLASSERT( iPropSet < m_cUPropSet );
                memcpy(rgpUPropInfo, m_pUProp[iPropSet].rgpUPropInfo, m_pUProp[iPropSet].cPropIds * sizeof(UPROPINFO*));
        }

        virtual HRESULT GetDefaultValue(ULONG iPropSet, DBPROPID dwPropId, DWORD* pdwOption, VARIANT* pVar) = 0;

        typedef UPROPSET* (*PGetPropSet)(ULONG* pNumPropSets, ULONG* pcElemPerSupported, UPROPSET* pSet, GUID* pguidSet);

        HRESULT InternalInitUPropSetsSupported(PGetPropSet pfnGetSet)
        {
                ULONG cPropSet = 0, cElemsPerSupported = 0;
                INT_PTR cSets = (INT_PTR)(*pfnGetSet)(NULL, &cElemsPerSupported, NULL, (GUID*)&GUID_NULL);
                UPROPSET* pPropSet = (UPROPSET*)CoTaskMemAlloc(sizeof(UPROPSET) * cSets);
                if (pPropSet == NULL)
                        return E_OUTOFMEMORY;
                pPropSet = (*pfnGetSet)(&cPropSet, &cElemsPerSupported, pPropSet, (GUID*)&GUID_NULL);
                memset(m_rgdwSupported, 0xFFFF, cPropSet * cElemsPerSupported * sizeof(DWORD));
                CoTaskMemFree(pPropSet);
                return S_OK;
        }

        HRESULT InternalGetDefaultValue(PGetPropSet pfnGetSet, ULONG iPropSet, DBPROPID dwPropId, DWORD* pdwOption, VARIANT* pVar)
        {
                if (pdwOption == NULL || pVar == NULL)
                        return E_INVALIDARG;

                ULONG cUPropSet = 0, cElemPerSupported =0;

                INT_PTR cSets = (INT_PTR)(*pfnGetSet)(NULL, &cElemPerSupported, NULL, (GUID*)&GUID_NULL);
                UPROPSET* pPropSet = (UPROPSET*)CoTaskMemAlloc(sizeof(UPROPSET) * cSets);
                if (pPropSet == NULL)
                        return E_OUTOFMEMORY;
                pPropSet = (*pfnGetSet)(&cUPropSet, &cElemPerSupported, pPropSet, (GUID*)&GUID_NULL);

                ATLASSERT(iPropSet < cUPropSet);
                for (ULONG iProp = 0; iProp < pPropSet[iPropSet].cUPropInfo; iProp++)
                {
                        UPROPINFO& rInfo = pPropSet[iPropSet].pUPropInfo[iProp];
                        if (rInfo.dwPropId == dwPropId)
                        {
                                pVar->vt = rInfo.VarType;
                                *pdwOption = rInfo.dwOption;
                                switch(rInfo.VarType)
                                {
                                case VT_BSTR:
                                        pVar->bstrVal = SysAllocString(rInfo.szVal);
                                        break;
                                default:
                                        pVar->lVal = (DWORD)rInfo.dwVal;
                                        break;
                                }
                                CoTaskMemFree(pPropSet);
                                return S_OK;
                        }
                }
                CoTaskMemFree(pPropSet);
                return E_FAIL;
        }

        HRESULT InternalFInit(PGetPropSet pfnGetSet, CUtlPropsBase* pCopyMe = NULL)
        {
                HRESULT     hr;
                ULONG       ulPropId;
                ULONG       cPropIds;
                ULONG       iPropSet;
                ULONG       iNewDex;
                UPROPINFO** rgpUPropInfo;
                UPROPVAL*   rgUPropVal;
                UPROPINFO*  pUPropInfo;

                // If a pointer is passed in, we should copy that property object
                if( pCopyMe )
                {
                        // Establish some base values
                        m_cUPropSet = pCopyMe->m_cUPropSet;
                        if (m_pUPropSet != NULL)
                                CoTaskMemFree(m_pUPropSet);
                        m_pUPropSet = (UPROPSET*)CoTaskMemAlloc(sizeof(UPROPSET) * m_cUPropSet);
                        if (m_pUPropSet == NULL)
                                return E_OUTOFMEMORY;
                        memcpy(m_pUPropSet, pCopyMe->m_pUPropSet, sizeof(UPROPSET) * m_cUPropSet);
                        m_cElemPerSupported = pCopyMe->m_cElemPerSupported;
                        ATLASSERT( (m_cUPropSet != 0)  && (m_cElemPerSupported != 0) );
                        // Retrieve Supported Bitmask
                        ATLTRY(m_rgdwSupported = new DWORD[m_cUPropSet * m_cElemPerSupported])
                        ATLTRY(m_rgdwPropsInError = new DWORD[m_cUPropSet * m_cElemPerSupported])
                        if( m_rgdwSupported == NULL|| m_rgdwPropsInError == NULL)
                        {
                                delete[] m_rgdwSupported;
                                delete[] m_rgdwPropsInError;
                                return E_OUTOFMEMORY;
                        }
                        ClearPropertyInError();
                        pCopyMe->CopyUPropSetsSupported(m_rgdwSupported);

                }
                else
                {
                        INT_PTR cSets = (INT_PTR)(*pfnGetSet)(NULL, &m_cElemPerSupported, NULL, (GUID*)&GUID_NULL);
                        UPROPSET* pSet = (UPROPSET*)CoTaskMemAlloc(sizeof(UPROPSET) * cSets);
                        if (pSet == NULL)
                                return E_OUTOFMEMORY;
                        pSet = (*pfnGetSet)(&m_cUPropSet, &m_cElemPerSupported, pSet, (GUID*)&GUID_NULL);
                        if (m_pUPropSet != NULL)
                                CoTaskMemFree(m_pUPropSet);
                        m_pUPropSet = pSet;
                        ATLASSERT( (m_cUPropSet != 0)  && (m_cElemPerSupported != 0) );
                        if( !m_cUPropSet || !m_cElemPerSupported )
                                return E_FAIL;

                        ATLTRY(m_rgdwSupported = new DWORD[m_cUPropSet * m_cElemPerSupported])
                        ATLTRY(m_rgdwPropsInError = new DWORD[m_cUPropSet * m_cElemPerSupported])
                        if( m_rgdwSupported == NULL || m_rgdwPropsInError == NULL)
                        {
                                delete[] m_rgdwSupported;
                                delete[] m_rgdwPropsInError;
                                return E_OUTOFMEMORY;
                        }
                        else
                                ClearPropertyInError();

                        if( FAILED(hr = InitUPropSetsSupported()) )
                        {
                                delete[] m_rgdwSupported;
                                m_rgdwSupported = NULL;
                                return hr;
                        }
                }

                // Allocate UPROPS structures for the count of Property sets
                ATLTRY(m_pUProp = (UPROP*) new UPROP[m_cUPropSet])
                if( m_pUProp)
                {
                        memset(m_pUProp, 0, m_cUPropSet * sizeof(UPROP));
                }
                else
                {
                        m_cUPropSet = 0;
                        return E_OUTOFMEMORY;
                }

                // With in the UPROPS Structure allocate and intialize the
                // Property IDs that belong to this property set.
                for(iPropSet=0; iPropSet<m_cUPropSet; iPropSet++)
                {
                        cPropIds = GetCountofWritablePropsInPropSet(iPropSet);

                        if( cPropIds > 0 )
                        {
                                ATLTRY(rgpUPropInfo = (UPROPINFO**) new UPROPINFO*[cPropIds])
                                ATLTRY(rgUPropVal = (UPROPVAL*) new UPROPVAL[cPropIds])
                                if( rgpUPropInfo != NULL && rgUPropVal != NULL)
                                {
                                        if( pCopyMe )
                                        {
                                                pCopyMe->CopyUPropInfo(iPropSet, rgpUPropInfo);
                                                if( FAILED(hr = pCopyMe->CopyUPropVal(iPropSet, rgUPropVal)) )
                                                        return hr;
                                        }
                                        else
                                        {
                                                // Clear Pointer Array
                                                memset(rgpUPropInfo, 0, cPropIds * sizeof(UPROPINFO*));

                                                // Set Pointer to correct property ids with a property set
                                                pUPropInfo = m_pUPropSet[iPropSet].pUPropInfo;

                                                // Set up the writable property buffers
                                                iNewDex = 0;
                                                for(ulPropId=0; ulPropId<m_pUPropSet[iPropSet].cUPropInfo; ulPropId++)
                                                {
                                                        if( pUPropInfo[ulPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
                                                        {
                                                                // Following ATLASSERT indicates that the are more
                                                                // writable properties then space allocated
                                                                ATLASSERT(iNewDex < cPropIds);

                                                                rgpUPropInfo[iNewDex] = &(pUPropInfo[ulPropId]);
                                                                rgUPropVal[iNewDex].dwOption = DBPROPOPTIONS_SETIFCHEAP;
                                                                rgUPropVal[iNewDex].pCColumnIds = NULL;
                                                                rgUPropVal[iNewDex].dwFlags = 0;
                                                                VariantInit(&(rgUPropVal[iNewDex].vValue));
                                                                GetDefaultValue(iPropSet, pUPropInfo[ulPropId].dwPropId,
                                                                        &(rgUPropVal[iNewDex].dwOption), &(rgUPropVal[iNewDex].vValue));
                                                                iNewDex++;
                                                        }
                                                }

                                                ATLASSERT(cPropIds == iNewDex);
                                        }

                                        m_pUProp[iPropSet].rgpUPropInfo = rgpUPropInfo;
                                        m_pUProp[iPropSet].pUPropVal = rgUPropVal;
                                        m_pUProp[iPropSet].cPropIds = cPropIds;
                                }
                                else
                                {
                                        delete[] rgpUPropInfo;
                                        delete[] rgUPropVal;
                                        return E_OUTOFMEMORY;
                                }
                        }
                }

                // Finally determine if there are any hidden property sets..  Those
                // that do not show up in GetPropertyInfo and should not be returns on
                // a 0, NULL call to GetProperties
                for(iPropSet=0; iPropSet<m_cUPropSet; iPropSet++)
                {
                        if( m_pUPropSet[iPropSet].dwFlags & UPROPSET_HIDDEN )
                                m_cUPropSetHidden++;
                }

                return S_OK;
        }
        //Check the arguments for Set Properties
        static HRESULT SetPropertiesArgChk(const ULONG cPropertySets, const DBPROPSET rgPropertySets[])
        {
                if( cPropertySets > 0 && !rgPropertySets )
                        return E_INVALIDARG;

                // New argument check for > 1 cPropertyIDs and NULL pointer for
                // array of property ids.
                for(ULONG ul=0; ul<cPropertySets; ul++)
                {
                        if( rgPropertySets[ul].cProperties && !(rgPropertySets[ul].rgProperties) )
                                return E_INVALIDARG;
                }

                return S_OK;
        }
        HRESULT GetProperties(const ULONG cPropertySets, const DBPROPIDSET rgPropertySets[],
                                                  ULONG* pcProperties, DBPROPSET** prgProperties,
                                                  const ULONG cSelectProps = 1, const GUID** ppGuid = NULL)
        {
                UPROPVAL*       pUPropVal;
                ULONG           ulCurProp = 0;
                ULONG           cTmpPropertySets = cPropertySets;
                HRESULT         hr = S_OK;
                ULONG           ulSet = 0;
                ULONG           ulNext = 0;
                ULONG           cSets = 0;
                ULONG           cProps = 0;
                ULONG           ulProp = 0;
                DWORD           dwStatus = 0;
                DBPROP*         pProp = NULL;
                DBPROP*         pCurProp = NULL;
                DBPROPSET*      pPropSet = NULL;
                UPROPINFO*      pUPropInfo = NULL;
                ULONG*          piSetIndex = NULL;
                ULONG*          piIndex = NULL;
                ULONG           ulCurSet = 0;
                ULONG           iPropSet;

                // ppGuid contains an array of GUIDs that the consumer can retrieve.
                // This is based upon the interface calling this function
                ATLASSERT(ppGuid != NULL);

                // We need to have special handling for DBPROPSET_PROPERTIESINERROR..
                // Turn on a flags to indicate this mode and make cTmpPropertySets
                // appear to be 0
                if( (m_dwFlags & ARGCHK_PROPERTIESINERROR) &&
                        rgPropertySets &&
                        (rgPropertySets[0].guidPropertySet == DBPROPSET_PROPERTIESINERROR) )
                {
                        cTmpPropertySets = 0;
                        dwStatus |= GETPROP_PROPSINERROR;
                }

                // If the consumer does not restrict the property sets
                // by specify an array of property sets and a cTmpPropertySets
                // greater than 0, then we need to make sure we
                // have some to return
                if( cTmpPropertySets == 0 )
                {
                        // There are times when we are called from IRowsetInfo, ISessionProperties, etc.
                        // where we should return only the appropriate rowset when cTmpPropertySets is
                        // zero.  This solves the problem if the user has more than one set specified in
                        // their PROPSET_MAP.

                        // Determine the number of property sets supported
                        if (ppGuid == NULL)
                        {
                                cSets = m_cUPropSet;
                        }
                        else
                        {
                                ULONG ulActualProps = 0;
                                piSetIndex = new ULONG[cSelectProps];

                                // Also, find the index for the set we are looking for
                                for (ULONG l=0; l<cSelectProps; l++)
                                {
                                        for (piSetIndex[l]=0; piSetIndex[l]<m_cUPropSet; piSetIndex[l]++)
                                        {
                                                if (InlineIsEqualGUID(*m_pUPropSet[piSetIndex[l]].pPropSet, *ppGuid[l]))
                                                {
                                                        ulActualProps++;
                                                        break;
                                                }
                                        }
                                }

                                // YIKES!
                                cSets = ulActualProps;
                                ulActualProps = 0;
                                piIndex = new ULONG[cSets];
                                for (l=0; l<cSelectProps; l++)
                                {
                                        if (piSetIndex[l] != m_cUPropSet) // this is an invalid index
                                                piIndex[ulActualProps++] = piSetIndex[l];
                                }

                                delete [] piSetIndex;
                                piSetIndex = NULL;

                        }
                }
                else
                {
                        // Since special property set guids are not supported by
                        // GetProperties, we can just use the count of property
                        // sets given to us.
                        cSets = cTmpPropertySets;
                }

                // If no properties set, then return
                if( cSets == 0 )
                                return S_OK;

                // Allocate the DBPROPSET structures
                pPropSet = (DBPROPSET*)CoTaskMemAlloc(cSets * sizeof(DBPROPSET));
                if(pPropSet)
                {
                        memset(pPropSet, 0, cSets * sizeof(DBPROPSET));

                        // Fill in the output array
                        iPropSet = 0;
                        for(ulSet=0; ulSet<cSets; ulSet++)
                        {
                                // Depending of if Property sets are specified store the
                                // return property set.
                                if( cTmpPropertySets == 0 )
                                {
                                        ULONG lSet;

                                        if (ppGuid[ulSet] == NULL)
                                                lSet = ulSet;
                                        else
                                                lSet = piIndex[ulSet];
                                        if( m_pUPropSet[lSet].dwFlags & UPROPSET_HIDDEN )
                                                continue;

                                        pPropSet[iPropSet].guidPropertySet = *(m_pUPropSet[lSet].pPropSet);
                                }
                                else
                                        pPropSet[iPropSet].guidPropertySet = rgPropertySets[ulSet].guidPropertySet;

                                iPropSet++;
                        }
                }
                else
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "Could not allocate DBPROPSET array for GetProperties\n");
                        delete [] piIndex;
                        piIndex = NULL;
                        return E_OUTOFMEMORY;
                }

                // Process requested or derived Property sets
                iPropSet=0;
                for(ulSet=0; ulSet<cSets; ulSet++)
                {
                        cProps  = 0;
                        pProp   = NULL;
                        ulNext  = 0;
                        dwStatus &= (GETPROP_ERRORSOCCURRED | GETPROP_VALIDPROP | GETPROP_PROPSINERROR);

                        // Calculate the number of property nodes needed for this
                        // property set.
                        if( cTmpPropertySets == 0 )
                        {
                                ULONG lSet;

                                if (ppGuid[ulSet] == NULL)
                                        lSet = ulSet;
                                else
                                        lSet = piIndex[ulSet];

                                // If processing requesting all property sets, do not
                                // return the hidden sets.
                                if( m_pUPropSet[lSet].dwFlags & UPROPSET_HIDDEN )
                                        continue;

                                cProps = m_pUPropSet[lSet].cUPropInfo;

                                // Add Enough space for node that are colid specific
                                cProps += GetCountofColids(&(m_pUProp[lSet]));
                                dwStatus |= GETPROP_ALLPROPIDS;
                                ulCurSet = lSet;
                        }
                        else
                        {
                                ATLASSERT(ulSet == iPropSet);

                                // If the count of PROPIDs is 0 or It is a special property set, then
                                // the consumer is requesting all propids for this property set.
                                if(rgPropertySets[ulSet].cPropertyIDs == 0)
                                {
                                        dwStatus |= GETPROP_ALLPROPIDS;
                                        // We have to determine if the property set is supported and if so
                                        // the count of properties in the set.
                                        BOOL bAvailable = false;
                                        for (ULONG l=0; l<cSelectProps; l++)
                                        {
                                                if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
                                                        bAvailable |= true;
                                        }

                                        if (bAvailable &&
                                                        GetIndexofPropSet(&(pPropSet[iPropSet].guidPropertySet), &ulCurSet) == S_OK)
                                        {
                                                cProps += m_pUPropSet[ulCurSet].cUPropInfo;
                                                // Add Enough space for node that are colid specific
                                                cProps += GetCountofColids(&m_pUProp[ulCurSet]);
                                        }
                                        else
                                        {
                                                // Not Supported
                                                dwStatus |= GETPROP_ERRORSOCCURRED;
                                                goto NEXT_SET;

                                        }
                                }
                                else
                                {
                                        cProps = rgPropertySets[ulSet].cPropertyIDs;
                                        // Check to see if this is a supported interface based on ppGuid.
                                        BOOL bAvailable = false;
                                        for (ULONG l=0; l<cSelectProps; l++)
                                        {
                                                if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
                                                        bAvailable |= true;
                                        }

                                        if (!bAvailable ||
                                                (GetIndexofPropSet(&(pPropSet[iPropSet].guidPropertySet), &ulCurSet) != S_OK))
                                        {
                                                dwStatus |= GETPROP_NOTSUPPORTED;
                                                dwStatus |= GETPROP_ERRORSOCCURRED;
                                        }
                                }
                        }


                        // Allocate DBPROP array
                        if( cProps == 0 )           //Possible with Hidden Passthrough sets
                                goto NEXT_SET;

                        pProp = (DBPROP*)CoTaskMemAlloc(cProps * sizeof(DBPROP));
                        if( pProp )
                        {
                                // Initialize Buffer
                                memset(pProp, 0, cProps * sizeof(DBPROP));
                                for(ulProp=0; ulProp<cProps; ulProp++)
                                {
                                        VariantInit(&(pProp[ulProp].vValue));
                                        if( dwStatus & GETPROP_NOTSUPPORTED )
                                        {
                                                // Not supported, thus we need to mark all as NOT_SUPPORTED
                                                pProp[ulProp].dwPropertyID  = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
                                                pProp[ulProp].dwStatus      = DBPROPSTATUS_NOTSUPPORTED;
                                        }
                                }
                                // Make sure we support the property set
                                if( dwStatus & GETPROP_NOTSUPPORTED )
                                {
                                        ulNext = cProps;
                                        goto NEXT_SET;
                                }

                                // Now that we have determined we can support the property set, we
                                // need to gather current property values
                                for(ulProp=0; ulProp<cProps; ulProp++)
                                {
                                        pCurProp = &(pProp[ulNext]);

                                        //Initialize Variant Value
                                        pCurProp->dwStatus = DBPROPSTATUS_OK;

                                        // Retrieve current value of properties
                                        if( dwStatus & GETPROP_ALLPROPIDS )
                                        {
                                                // Verify property is supported, if not do not return
                                                if( !TESTBIT(&(m_rgdwSupported[ulCurSet * m_cElemPerSupported]), ulProp) )
                                                        continue;

                                                // If we are looking for properties in error, then we should ignore all
                                                // that are not in error.
                                                if( (dwStatus & GETPROP_PROPSINERROR) &&
                                                        !TESTBIT(&(m_rgdwPropsInError[ulCurSet * m_cElemPerSupported]), ulProp) )
                                                        continue;

                                                pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulProp]);

                                                ATLASSERT( pUPropInfo );

                                                pCurProp->dwPropertyID = pUPropInfo->dwPropId;
                                                pCurProp->colid = DB_NULLID;

                                                // If the property is WRITEABLE or CHANGABLE, then the value will
                                                // be gotten from the UPROPVAL array, else it will be
                                                // derive from the GetDefaultValue
                                                if( pUPropInfo->dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
                                                {
                                                        pUPropVal = &(m_pUProp[ulCurSet].
                                                                pUPropVal[GetUPropValIndex(ulCurSet, pCurProp->dwPropertyID)]);
                                                        ATLASSERT( pUPropVal );

                                                        // Check to see if this property supports column level,
                                                        // if so, dump those nodes
                                                        if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
                                                        {
                                                                if( pUPropVal->pCColumnIds )
                                                                {
                                                                        RetrieveColumnIdProps(pProp, pUPropVal, &ulNext);
                                                                        continue;
                                                                }
                                                        }

                                                        pCurProp->dwOptions = pUPropVal->dwOption;
                                                        hr = VariantCopy(&(pCurProp->vValue), &(pUPropVal->vValue));
                                                }
                                                else
                                                {
                                                        GetDefaultValue(ulCurSet, pUPropInfo->dwPropId,
                                                                &(pCurProp->dwOptions), &(pCurProp->vValue));
                                                }

                                                // Return all Properties in Error with CONFLICT status
                                                if( dwStatus & GETPROP_PROPSINERROR )
                                                        pCurProp->dwStatus = DBPROPSTATUS_CONFLICTING;

                                                dwStatus |= GETPROP_VALIDPROP;
                                        }
                                        else
                                        {
                                                // Process Properties based on Restriction array.

                                                pCurProp->dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
                                                pCurProp->colid = DB_NULLID;

                                                if( GetIndexofPropIdinPropSet(ulCurSet, pCurProp->dwPropertyID,
                                                        &ulCurProp) == S_OK)
                                                {
                                                        // Supported
                                                        pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulCurProp]);
                                                        ATLASSERT( pUPropInfo );

                                                        // If the property is WRITEABLE, then the value will
                                                        // be gotten from the UPROPVAL array, else it will be
                                                        // derive from the GetDefaultValue
                                                        if( pUPropInfo->dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
                                                        {
                                                                pUPropVal = &(m_pUProp[ulCurSet].
                                                                        pUPropVal[GetUPropValIndex(ulCurSet, pCurProp->dwPropertyID)]);
                                                                ATLASSERT( pUPropVal );

                                                                // Check to see if this property supports column level,
                                                                // if so, dump those nodes
                                                                if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
                                                                {
                                                                        if( pUPropVal->pCColumnIds )
                                                                        {
                                                                                RetrieveColumnIdProps(pProp, pUPropVal, &ulNext);
                                                                                continue;
                                                                        }
                                                                }
                                                                pCurProp->dwOptions = pUPropVal->dwOption;
                                                                hr = VariantCopy(&(pCurProp->vValue), &(pUPropVal->vValue));
                                                        }
                                                        else
                                                        {
                                                                GetDefaultValue(ulCurSet, pUPropInfo->dwPropId,
                                                                        &(pCurProp->dwOptions), &(pCurProp->vValue));

                                                        }

                                                        dwStatus |= GETPROP_VALIDPROP;
                                                }
                                                else
                                                {
                                                        // Not Supported
                                                        pCurProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                                                        dwStatus |= GETPROP_ERRORSOCCURRED;
                                                }
                                        }

                                        // Increment return nodes count
                                        ulNext++;
                                }
                        }
                        else
                        {
                                ATLTRACE2(atlTraceDBProvider, 0, "Could not allocate DBPROP array for GetProperties\n");
                                if( pPropSet )
                                {
                                        // Free any DBPROP arrays
                                        for(ulSet=0; ulSet<cSets; ulSet++)
                                        {
                                                // Need to loop through all the VARIANTS and clear them
                                                for(ulProp=0; ulProp<pPropSet[ulSet].cProperties; ulProp++)
                                                        VariantClear(&(pPropSet[ulSet].rgProperties[ulProp].vValue));
                                                if( pPropSet[ulSet].rgProperties )
                                                        CoTaskMemFree(pPropSet[ulSet].rgProperties);
                                        }

                                        // Free DBPROPSET
                                        CoTaskMemFree(pPropSet);
                                }
                                //Since we have no properties to return, then we
                                //need to free allocated memory and return 0,NULL
                                if(pPropSet)
                                {
                                        // Free any DBPROP arrays
                                        for(ulSet=0; ulSet<cSets; ulSet++)
                                        {
                                                // Need to loop through all the VARIANTS and clear them
                                                for(ulProp=0; ulProp<pPropSet[ulSet].cProperties; ulProp++)
                                                        VariantClear(&(pPropSet[ulSet].rgProperties[ulProp].vValue));
                                                if( pPropSet[ulSet].rgProperties )
                                                        CoTaskMemFree(pPropSet[ulSet].rgProperties);
                                        }

                                        // Free DBPROPSET
                                        CoTaskMemFree(pPropSet);
                                }
                                *pcProperties = 0;
                                *prgProperties = NULL;
                                delete [] piIndex;
                                piIndex = NULL;
                                return E_OUTOFMEMORY;
                        }

NEXT_SET:
                        // It is possible that all properties are not supported,
                        // thus we should delete that memory and set rgProperties
                        // to NULL
                        if( ulNext == 0 && pProp )
                        {
                                CoTaskMemFree(pProp);
                                pProp = NULL;
                        }

                        pPropSet[iPropSet].cProperties = ulNext;
                        pPropSet[iPropSet].rgProperties = pProp;
                        iPropSet++;
                }

                *pcProperties = iPropSet;
                *prgProperties = pPropSet;

                delete piIndex;
                piIndex = NULL;

                // At least one propid was marked as not S_OK
                if( dwStatus & GETPROP_ERRORSOCCURRED )
                {
                        // If at least 1 property was set
                        if( dwStatus & GETPROP_VALIDPROP )
                                return DB_S_ERRORSOCCURRED;
                        else
                        {
                                // Do not free any of the memory on a DB_E_
                                return DB_E_ERRORSOCCURRED;
                        }
                }

                return S_OK;
        }

        ULONG GetCountofColids(UPROP* pUProp)
        {
                ULONG   cExtra=0;
                ATLASSERT(pUProp);
                for(ULONG ul=0; ul<pUProp->cPropIds; ul++)
                {
                        if( pUProp->pUPropVal[ul].pCColumnIds )
                                cExtra += (pUProp->pUPropVal[ul].pCColumnIds)->GetCountOfPropColids();
                }
                return cExtra;
        }

        ULONG GetUPropValIndex(ULONG iCurSet, DBPROPID dwPropId)
        {
                for(ULONG ul=0; ul<m_pUProp[iCurSet].cPropIds; ul++)
                {
                        if( (m_pUProp[iCurSet].rgpUPropInfo[ul])->dwPropId == dwPropId )
                                return ul;
                }
                return 0;
        }

        void RetrieveColumnIdProps(DBPROP* pCurProp, UPROPVAL* pUPropVal, ULONG* pulNext)
        {
                // Reset to first Node
                CColumnIds* pColIds = pUPropVal->pCColumnIds;
                HRESULT hr = E_FAIL;
                for (int i = 0; i < pColIds->GetSize(); i++)
                {
                        CPropColID colId;
                        hr = pColIds->GetValue(i, &(pCurProp->dwOptions), &(pCurProp->colid),&(pCurProp->vValue));
                        if (SUCCEEDED(hr))
                                pCurProp = &(pCurProp[++(*pulNext)]);
                }
                (*pulNext)++;
        }

        //Check the arguments for Retrieve Properties
        HRESULT GetPropertiesArgChk(const ULONG cPropertySets, const DBPROPIDSET rgPropertySets[],
                                                                ULONG* pcProperties, DBPROPSET** prgProperties)
        {
                // Initialize values
                if(pcProperties)
                        *pcProperties = 0;
                if(prgProperties)
                        *prgProperties = NULL;

                // Check Arguments
                if( ((cPropertySets > 0) && !rgPropertySets) || !pcProperties || !prgProperties )
                        return E_INVALIDARG;

                // New argument check for > 1 cPropertyIDs and NULL pointer for
                // array of property ids.
                for(ULONG ul=0; ul<cPropertySets; ul++)
                {
                        if( rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs) )
                                return E_INVALIDARG;

                        // Check for propper formation of DBPROPSET_PROPERTIESINERROR
                        if( (m_dwFlags & ARGCHK_PROPERTIESINERROR) &&
                                rgPropertySets[ul].guidPropertySet == DBPROPSET_PROPERTIESINERROR )
                        {
                                if( (cPropertySets > 1) ||
                                        (rgPropertySets[ul].cPropertyIDs != 0) ||
                                        (rgPropertySets[ul].rgPropertyIDs != NULL) )
                                        return E_INVALIDARG;
                        }
                }

                return S_OK;
        }

        OUT_OF_LINE HRESULT FInit(CUtlPropsBase* pCopyMe = NULL) = 0;
};

// Implementation Class
template <class T>
class ATL_NO_VTABLE CUtlProps : public CUtlPropsBase
{
public:

        CUtlProps(DWORD dwFlags = 0)
        {
                ClearMemberVars();
                m_dwFlags = dwFlags;
        }
        ~CUtlProps()
        {
                FreeMemory();
        }
        void FreeMemory()
        {
                // Remove Property Information
                if( m_pUProp )
                {
                        for(ULONG ulPropSet=0; ulPropSet<m_cUPropSet; ulPropSet++)
                        {
                                UPROPVAL* pUPropVal = m_pUProp[ulPropSet].pUPropVal;
                                for(ULONG ulPropId=0; ulPropId<m_pUProp[ulPropSet].cPropIds; ulPropId++)
                                {
                                        delete pUPropVal[ulPropId].pCColumnIds;
                                        VariantClear(&(pUPropVal[ulPropId].vValue));
                                }
                                delete[] m_pUProp[ulPropSet].rgpUPropInfo;
                                delete[] m_pUProp[ulPropSet].pUPropVal;
                        }

                }

                delete[] m_pUProp;
                delete[] m_rgdwSupported;
                delete[] m_rgdwPropsInError;
                delete[] m_rgiPropSetDex;

                if (m_pUPropSet != NULL)
                        CoTaskMemFree(m_pUPropSet);

                ClearMemberVars();
        }
        void ClearMemberVars()
        {
                m_cPropSetDex       = 0;
                m_cUPropSet         = 0;
                m_cUPropSetHidden   = 0;
                m_pUPropSet         = NULL;

                m_dwFlags           = 0;

                m_pUProp            = NULL;
                m_cElemPerSupported = 0;
                m_rgdwSupported     = NULL;
                m_rgdwPropsInError  = NULL;
                m_rgiPropSetDex     = NULL;
        }

        //Retrieve the property set indexes that match this property set.
        HRESULT GetPropertySetIndex(GUID* pPropertySet)
        {
                DWORD   dwFlag = 0;
                ULONG   ulSet;

                ATLASSERT( m_cUPropSet && m_pUPropSet );
                ATLASSERT( m_rgiPropSetDex );
                ATLASSERT( pPropertySet );

                m_cPropSetDex = 0;

                if( *pPropertySet == DBPROPSET_DATASOURCEALL )
                {
                        dwFlag = DBPROPFLAGS_DATASOURCE;
                }
                else if( *pPropertySet == DBPROPSET_DATASOURCEINFOALL )
                {
                        dwFlag = DBPROPFLAGS_DATASOURCEINFO;
                }
                else if( *pPropertySet == DBPROPSET_ROWSETALL )
                {
                        dwFlag = DBPROPFLAGS_ROWSET;
                }
                else if( *pPropertySet == DBPROPSET_DBINITALL )
                {
                        dwFlag = DBPROPFLAGS_DBINIT;
                }
                else if( *pPropertySet == DBPROPSET_SESSIONALL )
                {
                        dwFlag = DBPROPFLAGS_SESSION;
                }
                else // No scan required, just look for match.
                {
                        for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
                        {
                                if( *(m_pUPropSet[ulSet].pPropSet) == *pPropertySet )
                                {
                                        m_rgiPropSetDex[m_cPropSetDex] = ulSet;
                                        m_cPropSetDex++;
                                        break;
                                }
                        }
                        goto EXIT;
                }

                // Scan through the property sets looking for matching attributes
                for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
                {
                        if( m_pUPropSet[ulSet].pUPropInfo[0].dwFlags & dwFlag )
                        {
                                m_rgiPropSetDex[m_cPropSetDex] = ulSet;
                                m_cPropSetDex++;
                        }
                }

EXIT:
                return (m_cPropSetDex) ? S_OK : S_FALSE;
        }

        OUT_OF_LINE HRESULT GetDefaultValue(ULONG iPropSet, DBPROPID dwPropId, DWORD* pdwOption, VARIANT* pVar)
        {
                return InternalGetDefaultValue(T::_GetPropSet, iPropSet, dwPropId, pdwOption, pVar);
        }

        OUT_OF_LINE HRESULT FInit(CUtlPropsBase* pCopyMe = NULL)
        {
                return InternalFInit(T::_GetPropSet, pCopyMe);
        }
        HRESULT FillDefaultValues(ULONG ulPropSetTarget = ULONG_MAX)
        {
                HRESULT     hr;
                ULONG       ulPropId;
                ULONG       iPropSet;
                ULONG       iNewDex;

                // Fill in all the actual values.
                // Typically because we now have an hdbc with which to get them.
                // (Or we no longer have an hdbc, so must clear them.)
                // Note that the UPROP (with values) array may be a subset of the UPROPINFO array.
                // Only writable properties are in UPROP array.

                // Maybe restrict to a single PropSet if within valid range [0...m_cUPropSet-1].
                // Otherwise do all propsets.
                iPropSet = (ulPropSetTarget < m_cUPropSet) ? ulPropSetTarget : 0;

                for( ; iPropSet<m_cUPropSet; iPropSet++)
                {
                        iNewDex = 0;
                        for(ulPropId=0; ulPropId<m_pUPropSet[iPropSet].cUPropInfo; ulPropId++)
                        {
                                if( m_pUPropSet[iPropSet].pUPropInfo[ulPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
                                {
                                        //Initialize dwFlags element of UPropVal
                                        m_pUProp[iPropSet].pUPropVal[iNewDex].dwFlags = 0;

                                        // Don't need this since SetProperties() resets these.
                                        //ATLASSERT( m_pUProp[iPropSet].pUPropVal[iNewDex].dwOption == DBPROPOPTIONS_SETIFCHEAP);
                                        ATLASSERT( m_pUProp[iPropSet].pUPropVal[iNewDex].pCColumnIds == NULL);

                                        VariantClear(&m_pUProp[iPropSet].pUPropVal[iNewDex].vValue);
                                        hr = GetDefaultValue(
                                                        iPropSet,
                                                        m_pUPropSet[iPropSet].pUPropInfo[ulPropId].dwPropId,
                                                        &m_pUProp[iPropSet].pUPropVal[iNewDex].dwOption,
                                                        &m_pUProp[iPropSet].pUPropVal[iNewDex].vValue );
                                        if (FAILED(hr))
                                                return hr;
                                        iNewDex++;
                                }
                        }

                        // We're through if restricting to single PropSet.
                        if (ulPropSetTarget < m_cUPropSet)
                                break;
                }
                return NOERROR;
        }

        // Translate Rowset IIDs to PROPSET structures ready to pass to SetProperties
        HRESULT ConvertRowsetIIDtoDBPROPSET(const IID* piid, DBPROPSET* pPropSet)
        {
                HRESULT     hr = S_OK;
                DBPROP*     pProp;

                ATLASSERT( piid || pPropSet );
                ATLASSERT( (pPropSet->cProperties == 1) || (pPropSet->rgProperties) );

                pProp = &(pPropSet->rgProperties[0]);

                if(InlineIsEqualGUID(*piid, IID_IAccessor))
                        pProp->dwPropertyID = DBPROP_IAccessor;
                else if(InlineIsEqualGUID(*piid,IID_IColumnsInfo))
                        pProp->dwPropertyID = DBPROP_IColumnsInfo;
                else if(InlineIsEqualGUID(*piid , IID_IRowset))
                        pProp->dwPropertyID = DBPROP_IRowset;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetInfo))
                        pProp->dwPropertyID = DBPROP_IRowsetInfo;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetLocate))
                        pProp->dwPropertyID = DBPROP_IRowsetLocate;
                else if(InlineIsEqualGUID(*piid , IID_IColumnsRowset))
                        pProp->dwPropertyID = DBPROP_IColumnsRowset;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetResynch))
                        pProp->dwPropertyID = DBPROP_IRowsetResynch;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetScroll))
                        pProp->dwPropertyID = DBPROP_IRowsetScroll;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetChange))
                        pProp->dwPropertyID = DBPROP_IRowsetChange;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetUpdate))
                        pProp->dwPropertyID = DBPROP_IRowsetUpdate;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetIdentity))
                        pProp->dwPropertyID = DBPROP_IRowsetIdentity;
                else if(InlineIsEqualGUID(*piid , IID_IConnectionPointContainer))
                        pProp->dwPropertyID = DBPROP_IConnectionPointContainer;
                else if(InlineIsEqualGUID(*piid , IID_ISupportErrorInfo))
                        pProp->dwPropertyID = DBPROP_ISupportErrorInfo;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetIndex))
                        pProp->dwPropertyID = DBPROP_IRowsetIndex;
        #if( OLEDBVER >= 0x0200 )
                else if(InlineIsEqualGUID(*piid , IID_IRowsetLockRows))
                        pProp->dwPropertyID = DBPROP_IRowsetLockRows;
                else if(InlineIsEqualGUID(*piid , IID_IProvideMoniker))
                        pProp->dwPropertyID = DBPROP_IProvideMoniker;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetNotify))
                        pProp->dwPropertyID = DBPROP_IRowsetNotify;
                else if(InlineIsEqualGUID(*piid , IID_IReadData))
                        pProp->dwPropertyID = DBPROP_IReadData;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetExactScroll))
                        pProp->dwPropertyID = DBPROP_IRowsetExactScroll;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetNextRowset))
                        pProp->dwPropertyID = DBPROP_IRowsetNextRowset;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetDelete))
                        pProp->dwPropertyID = DBPROP_IRowsetDelete;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetDeleteBookmarks))
                        pProp->dwPropertyID = DBPROP_IRowsetDeleteBookmarks;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetNewRow))
                        pProp->dwPropertyID = DBPROP_IRowsetNewRow;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetNewRowAfter))
                        pProp->dwPropertyID = DBPROP_IRowsetNewRowAfter;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetWithParameters))
                        pProp->dwPropertyID = DBPROP_IRowsetWithParameters;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetFind))
                        pProp->dwPropertyID = DBPROP_IRowsetFind;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetAsynch))
                        pProp->dwPropertyID = DBPROP_IRowsetAsynch;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetKeys))
                        pProp->dwPropertyID = DBPROP_IRowsetKeys;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetWatchAll))
                        pProp->dwPropertyID = DBPROP_IRowsetWatchAll;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetWatchNotify))
                        pProp->dwPropertyID = DBPROP_IRowsetWatchNotify;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetWatchRegion))
                        pProp->dwPropertyID = DBPROP_IRowsetWatchRegion;
                else if(InlineIsEqualGUID(*piid , IID_IRowsetCopyRows))
                        pProp->dwPropertyID = DBPROP_IRowsetCopyRows;
        #endif //#if( OLEDBVER >= 0x0200 )
                else
                        hr = S_FALSE;

                // If the IID can be mapped to a DBPROPID, the
                // we need to initialize the vValue to TRUE
                if(hr == S_OK)
                {
                        // Set PropertySet
                        pPropSet->guidPropertySet = DBPROPSET_ROWSET;

                        // Set Property
                        pProp->dwOptions = DBPROPOPTIONS_REQUIRED;
                        pProp->dwStatus = 0;
                        pProp->colid = DB_NULLID;

                        VariantInit(&(pProp->vValue));
                        pProp->vValue.vt = VT_BOOL;
                        V_BOOL(&(pProp->vValue)) = VARIANT_TRUE;
                }

                return hr;
        }


        void SetPropertyInError(const ULONG iPropSet, const ULONG iPropId)
        {
                SETBIT(&(m_rgdwPropsInError[iPropSet * m_cElemPerSupported]), iPropId);
        }

        BOOL IsPropSet(const GUID* pguidPropSet, DBPROPID dwPropId)
        {
                HRESULT     hr;
                ULONG       iPropSet;
                ULONG       iPropId;
                VARIANT     vValue;
                DWORD       dwOptions;

                VariantInit(&vValue);

                if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
                {
                        if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
                        {
                                if( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags &
                                        (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
                                {
                                        ULONG iPropVal = GetUPropValIndex(iPropSet, dwPropId);

                                        dwOptions = m_pUProp[iPropSet].pUPropVal[iPropVal].dwOption;
                                        hr = VariantCopy(&vValue, &(m_pUProp[iPropSet].
                                                pUPropVal[iPropVal].vValue));
                                }
                                else
                                {
                                        hr = GetDefaultValue(iPropSet, dwPropId,
                                                &dwOptions, &vValue);
                                }

                                if( dwOptions == DBPROPOPTIONS_REQUIRED )
                                {
                                        ATLASSERT( vValue.vt == VT_BOOL );
                                        if( SUCCEEDED(hr) &&
                                                (V_BOOL(&vValue) == VARIANT_TRUE) )
                                        {
                                                VariantClear(&vValue);
                                                return TRUE;
                                        }
                                }
                        }
                }

                VariantClear(&vValue);
                return FALSE;
        }
        OUT_OF_LINE HRESULT GetPropValue(const GUID* pguidPropSet, DBPROPID dwPropId, VARIANT* pvValue)
        {
                HRESULT     hr = E_FAIL;
                ULONG       iPropSet;
                ULONG       iPropId = 0;
                DWORD       dwOptions;

                if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
                {
                        if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
                        {
                                if( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
                                {
                                        hr = VariantCopy(pvValue, &(m_pUProp[iPropSet].pUPropVal[
                                                GetUPropValIndex(iPropSet, dwPropId)].vValue));
                                }
                                else
                                {
                                        VariantClear(pvValue);

                                        hr = GetDefaultValue(iPropSet, dwPropId,
                                                &dwOptions, pvValue);
                                }
                        }
                }

                return hr;
        }
        HRESULT SetPropValue(const GUID* pguidPropSet,DBPROPID dwPropId, VARIANT* pvValue)
        {
                HRESULT     hr = E_FAIL;
                ULONG       iPropSet;
                ULONG       iPropId;

                if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
                {
                        if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
                        {
                                ATLASSERT( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) );

                                hr = VariantCopy(&(m_pUProp[iPropSet].pUPropVal[
                                                GetUPropValIndex(iPropSet, dwPropId)].vValue), pvValue);
                        }
                }

                return hr;
        }


        //Pointer to properties in error mask
        DWORD* GetPropsInErrorPtr(){return m_rgdwPropsInError;}
        ULONG GetUPropSetCount() {return m_cUPropSet;}
        void SetUPropSetCount(ULONG c) {m_cUPropSet = c;}

        // NOTE: The following functions depend on all prior
        // properties in the array being writable.
        // This is because the UPROP array contains only writable elements,
        // and the UPROPINFO array contains writable and read-only elements.
        // (If this is a problem, we would need to define which one it came from
        // and add the appropriate ATLASSERTs...)

        //Get DBPROPOPTIONS_xx
        DWORD GetPropOption(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                return m_pUProp[iPropSet].pUPropVal[iProp].dwOption;
        }
        //Set DBPROPOPTIONS_xx
        void SetPropOption(ULONG iPropSet, ULONG iProp, DWORD dwOption)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                m_pUProp[iPropSet].pUPropVal[iProp].dwOption = dwOption;
        }
        //Determine if property is required and variant_true
        BOOL IsRequiredTrue(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                ATLASSERT(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BOOL);
                ATLASSERT(V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue) == VARIANT_TRUE
                ||     V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue) == VARIANT_FALSE);

                return( (m_pUProp[iPropSet].pUPropVal[iProp].dwOption == DBPROPOPTIONS_REQUIRED) &&
                                (V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue) == VARIANT_TRUE) );
        }
        DWORD GetInternalFlags(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                return m_pUProp[iPropSet].pUPropVal[iProp].dwFlags;
        }
        void AddInternalFlags(ULONG iPropSet, ULONG iProp, DWORD dwFlags)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                m_pUProp[iPropSet].pUPropVal[iProp].dwFlags |= dwFlags;
        }
        void RemoveInternalFlags(ULONG iPropSet, ULONG iProp, DWORD dwFlags)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                m_pUProp[iPropSet].pUPropVal[iProp].dwFlags &= ~dwFlags;
        }
        VARIANT * GetVariant(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                return & m_pUProp[iPropSet].pUPropVal[iProp].vValue;
        }
        HRESULT SetVariant(ULONG iPropSet, ULONG iProp, VARIANT *pv )
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                // Does VariantClear first.
                return VariantCopy( &m_pUProp[iPropSet].pUPropVal[iProp].vValue, pv );
        }
        void SetValEmpty(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                VariantClear( &m_pUProp[iPropSet].pUPropVal[iProp].vValue );
        }
        BOOL IsEmpty(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                return ( m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_EMPTY);
        }
        void SetValBool(ULONG iPropSet, ULONG iProp, VARIANT_BOOL bVal)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                // Note that we accept any "true" value.
                VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
                m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_BOOL;
                V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue) = (bVal ? VARIANT_TRUE : VARIANT_FALSE);
        }
        VARIANT_BOOL GetValBool(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                ATLASSERT(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BOOL);
                return V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
        }
        void SetValShort(ULONG iPropSet, ULONG iProp, SHORT iVal )
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
                m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_I2;
                m_pUProp[iPropSet].pUPropVal[iProp].vValue.iVal = iVal;
        }
        SHORT GetValShort(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                ATLASSERT(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_I2);
                return m_pUProp[iPropSet].pUPropVal[iProp].vValue.iVal;
        }
        void SetValLong(ULONG iPropSet, ULONG iProp, LONG lVal)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
                m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_I4;
                m_pUProp[iPropSet].pUPropVal[iProp].vValue.lVal = lVal;
        }
        LONG GetValLong(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                ATLASSERT(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_I4);
                return m_pUProp[iPropSet].pUPropVal[iProp].vValue.lVal;
        }
        HRESULT SetValString(ULONG iPropSet, ULONG iProp, const WCHAR *pwsz)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                VARIANT *pv = &m_pUProp[iPropSet].pUPropVal[iProp].vValue;
                VariantClear(pv);
                pv->bstrVal = SysAllocString(pwsz);
                if (pv->bstrVal)
                        pv->vt = VT_BSTR;
                else
                        return E_FAIL;

                // See if this was used for non-string type.
                // Typically this is an easy way to pass integer as a string.
                if (GetExpectedVarType(iPropSet,iProp) == VT_BSTR)
                        return NOERROR;
                if (pwsz[0] != L'\0')
                        return VariantChangeType( pv, pv, 0, GetExpectedVarType(iPropSet,iProp) );

                // Set to "", which for non-string means empty.
                SysFreeString(pv->bstrVal);
                pv->vt = VT_EMPTY;
                return NOERROR;
        }
        const WCHAR * GetValString(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                ATLASSERT(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BSTR);
                return m_pUProp[iPropSet].pUPropVal[iProp].vValue.bstrVal;
        }
        const GUID * GetGuid(ULONG iPropSet)
        {
                ATLASSERT(iPropSet < m_cUPropSet);
                return m_pUPropSet[iPropSet].pPropSet;
        }
        DWORD GetPropID(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                return m_pUPropSet[iPropSet].pUPropInfo[iProp].dwPropId;
        }
        VARTYPE GetExpectedVarType(ULONG iPropSet, ULONG iProp)
        {
                ATLASSERT((  (iPropSet < m_cUPropSet)   && (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
                return m_pUPropSet[iPropSet].pUPropInfo[iProp].VarType;
        }
        virtual HRESULT GetIndexofPropSet(const GUID* pPropSet, ULONG* pulCurSet)
        {
                ATLASSERT(pPropSet && pulCurSet);

                for(ULONG ul=0; ul<m_cUPropSet; ul++)
                {
                        if( *pPropSet == *(m_pUPropSet[ul].pPropSet) )
                        {
                                *pulCurSet = ul;
                                return S_OK;
                        }
                }
                return S_FALSE;
        }


        virtual HRESULT OnPropertyChanged(ULONG /*iCurSet*/, DBPROP* /*pDBProp*/)
        {
                return S_OK;
        }

        virtual HRESULT InitUPropSetsSupported()
        {
                return InternalInitUPropSetsSupported(T::_GetPropSet);
        }

        HRESULT GetIndexOfPropertyInSet(const GUID* pPropSet, DBPROPID dwPropertyId, ULONG* piCurPropId, ULONG* piCurSet)
        {
                HRESULT hr = GetIndexofPropSet(pPropSet, piCurSet);
                if (hr == S_FALSE)
                        return hr;
                UPROPINFO* pUPropInfo = m_pUPropSet[*piCurSet].pUPropInfo;
                for(ULONG ul=0; ul<m_pUPropSet[*piCurSet].cUPropInfo; ul++)
                {
                        if( dwPropertyId == pUPropInfo[ul].dwPropId )
                                *piCurPropId = ul;
                        return S_OK;
                }

                return S_FALSE;
        }
        HRESULT SetSupportedBit(const GUID* pPropSet, DBPROPID dwPropertyId)
        {
                ULONG iCurPropId, iCurSet;

                if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
                {
                        m_rgdwSupported[iCurSet * m_cElemPerSupported] |= 1 << iCurPropId;
                        return S_OK;
                }
                return S_FALSE;
        }

        HRESULT ClearSupportedBit(const GUID* pPropSet, DBPROPID dwPropertyId)
        {
                ULONG iCurPropId, iCurSet;

                if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
                {
                        m_rgdwSupported[iCurSet * m_cElemPerSupported] &= ~( 1 << iCurPropId);
                        return S_OK;
                }
                return S_FALSE;
        }

        HRESULT TestSupportedBit(const GUID* pPropSet, DBPROPID dwPropertyId, bool& bSet)
        {
                ULONG iCurPropId, iCurSet;

                if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
                {
                        bSet = (m_rgdwSupported[iCurSet * m_cElemPerSupported] & ( 1 << iCurPropId)) != 0;
                        return S_OK;
                }
                return S_FALSE;
        }
        void CopyPropsInError(DWORD* rgdwSupported)
        {
                memcpy(rgdwSupported, m_rgdwPropsInError, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD));
        }
};

// IDBPropertiesImpl
// IDBProperties <- IUnknown
template <class T>
class ATL_NO_VTABLE IDBPropertiesImpl : public IDBProperties, public CUtlProps<T>
{
public:
        STDMETHOD(GetProperties)(ULONG cPropertySets,
                                                         const DBPROPIDSET rgPropertySets[],
                                                         ULONG *pcProperties,
                                                         DBPROPSET **prgProperties)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IDBPropertiesImpl::GetProperties\n");
                T* pT = (T*)this;
                HRESULT hr = GetPropertiesArgChk(cPropertySets, rgPropertySets, pcProperties, prgProperties);
                if (FAILED(hr))
                        return hr;

                if(SUCCEEDED(hr))
                {
                        // Check for other invalid arguments
                        for (ULONG i=0; i<cPropertySets; i++)
                        {
                                if (InlineIsEqualGUID(rgPropertySets[i].guidPropertySet, DBPROPSET_PROPERTIESINERROR))
                                        if (pcProperties != NULL || prgProperties != NULL || cPropertySets > 1)
                                                return E_INVALIDARG;
                        }
                }

                if (SUCCEEDED(hr))
                {
                        const GUID* ppGuid[3];
                        if (pT->m_dwStatus & DSF_INITIALIZED)
                        {
                                ppGuid[0] = &DBPROPSET_DBINIT;
                                ppGuid[1] = &DBPROPSET_DATASOURCE;
                                ppGuid[2] = &DBPROPSET_DATASOURCEINFO;
                                hr = CUtlProps<T>::GetProperties(cPropertySets, rgPropertySets,
                                                        pcProperties, prgProperties, 3, ppGuid);
                        }
                        else
                        {
                                ppGuid[0] = &DBPROPSET_DBINIT;
                                hr = CUtlProps<T>::GetProperties(cPropertySets, rgPropertySets,
                                                        pcProperties, prgProperties, 1, ppGuid);
                        }
                }

                return hr;
        }

        STDMETHOD(GetPropertyInfo)(ULONG cPropertySets,
                                                           const DBPROPIDSET rgPropertySets[],
                                                           ULONG *pcPropertyInfoSets,
                                                           DBPROPINFOSET **prgPropertyInfoSets,
                                                           OLECHAR **ppDescBuffer)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IDBPropertiesImpl::GetPropertyInfo\n");
                T* pT = (T*)this;

                if (pT->m_pCUtlPropInfo == NULL)
                {
                        // Go ahead and create the m_pCUtlPropInfo but do not change the
                        // Initialized status of the provider (see IDBInitialize::Initialize).
                        ATLTRACE2(atlTraceDBProvider, 0, "m_pCUtlPropInfo == NULL\n");
                        pT->Lock();
                        delete pT->m_pCUtlPropInfo;
                        ATLTRY(pT->m_pCUtlPropInfo = new CUtlPropInfo<T>())
                        pT->Unlock();
                        if (pT->m_pCUtlPropInfo == NULL)
                        {
                                ATLTRACE2(atlTraceDBProvider, 0, "IDBProperties::GetPropertyInfo Error : OOM\n");
                                return E_OUTOFMEMORY;
                        }
                        HRESULT hr = pT->m_pCUtlPropInfo->FInit();
                        if (hr != S_OK)
                        {
                                pT->Lock();
                                delete pT->m_pCUtlPropInfo;
                                pT->m_pCUtlPropInfo = NULL;
                                pT->Unlock();
                        }
                }

                // Initialize
                if( pcPropertyInfoSets )
                        *pcPropertyInfoSets = 0;
                if( prgPropertyInfoSets )
                        *prgPropertyInfoSets = NULL;
                if( ppDescBuffer )
                        *ppDescBuffer = NULL;

                // Check Arguments
                if( ((cPropertySets > 0) && !rgPropertySets) ||
                        !pcPropertyInfoSets || !prgPropertyInfoSets )
                        return E_INVALIDARG;



                // New argument check for > 1 cPropertyIDs and NULL pointer for
                // array of property ids.
                const DWORD SPECIAL_GROUP       = 1;
                const DWORD SPECIAL_SINGLE      = 2;
                const DWORD SPECIALS            = SPECIAL_GROUP | SPECIAL_SINGLE;
                DWORD dwSpecial = 0;
                for(ULONG ul=0; ul<cPropertySets; ul++)
                {
                        if( (rgPropertySets[ul].guidPropertySet == DBPROPSET_DATASOURCEALL) ||
                                (rgPropertySets[ul].guidPropertySet == DBPROPSET_DATASOURCEINFOALL) ||
                                (rgPropertySets[ul].guidPropertySet == DBPROPSET_DBINITALL) ||
                                (rgPropertySets[ul].guidPropertySet == DBPROPSET_SESSIONALL) ||
                                (rgPropertySets[ul].guidPropertySet == DBPROPSET_ROWSETALL) )
                                dwSpecial |= SPECIAL_GROUP;
                        else
                                dwSpecial |= SPECIAL_SINGLE;

                        if( (dwSpecial == SPECIALS) ||
                                (rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs)) )
                                return E_INVALIDARG;
                }

                if (pT->m_dwStatus & DSF_INITIALIZED)
                        return pT->m_pCUtlPropInfo->GetPropertyInfo(cPropertySets, rgPropertySets,
                                                                                          pcPropertyInfoSets, prgPropertyInfoSets,
                                                                                          ppDescBuffer, true);
                else
                        return pT->m_pCUtlPropInfo->GetPropertyInfo(cPropertySets, rgPropertySets,
                                                                                          pcPropertyInfoSets, prgPropertyInfoSets,
                                                                                          ppDescBuffer, false, &DBPROPSET_DBINITALL);

        }

        STDMETHOD(SetProperties)(ULONG cPropertySets,
                                                         DBPROPSET rgPropertySets[])
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IDBPropertiesImpl::SetProperties\n");
                HRESULT hr;
                DBPROPSET* pdbPropSet = NULL;
                ULONG iProp;
                const GUID* ppGuid[3];
                T* pT = (T*)this;

                // Quick return if the Count of Properties is 0
                if( cPropertySets == 0 )
                        return S_OK;

                hr = CUtlProps<T>::SetPropertiesArgChk(cPropertySets, rgPropertySets);
                if(SUCCEEDED(hr))
                {
                        // We need to handle the DBINIT properties specially after being initialized.
                        // - they should be treated as NOTSETTABLE at this point.
                        if( pT->m_dwStatus & DSF_INITIALIZED )
                        {
                                ATLASSERT(cPropertySets);

                                BOOL fFoundDBINIT = FALSE;

                                // Allocate a DBPROPSET structure of equal size
                                ATLTRY(pdbPropSet = new DBPROPSET[cPropertySets])
                                if( pdbPropSet == NULL )
                                        return E_OUTOFMEMORY;

                                for(ULONG iNewSet=0,iSet=0; iSet<cPropertySets; iSet++)
                                {
                                        // Remove any DBPROPSET_DBINIT values and mark them all
                                        // as not settable
                                        if( (rgPropertySets[iSet].guidPropertySet == DBPROPSET_DBINIT))
                                        {
                                                fFoundDBINIT = TRUE;
                                                for(iProp=0; iProp<rgPropertySets[iSet].cProperties; iProp++)
                                                        rgPropertySets[iSet].rgProperties[iProp].dwStatus = DBPROPSTATUS_NOTSETTABLE;
                                        }
                                        else
                                        {
                                                // If not DBPROPSET_DBINIT then copy the DBPROPSET values
                                                memcpy(&pdbPropSet[iNewSet++], &rgPropertySets[iSet], sizeof(DBPROPSET));
                                        }
                                }

                                // If we have no propertyset to pass on to the property handler, we
                                // can exit
                                if( iNewSet == 0 )
                                {
                                        hr = DB_E_ERRORSOCCURRED;
                                        goto exit;
                                }

                                ppGuid[0] = &DBPROPSET_DBINIT;
                                ppGuid[1] = &DBPROPSET_DATASOURCE;
                                ppGuid[2] = &DBPROPSET_DATASOURCEINFO;
                                hr = CUtlProps<T>::SetProperties(0, iNewSet, pdbPropSet, 3, ppGuid);

                                // If we have determined that one of the property sets was DBINIT, we may
                                // need to fixup the returned hr value.
                                if( fFoundDBINIT && SUCCEEDED(hr))
                                        hr = DB_S_ERRORSOCCURRED;
                        }
                        else
                        {
                                // Note that m_pCUtlProps knows about initialization,
                                // so we don't have to here.
                                ppGuid[0] = &DBPROPSET_DBINIT;
                                hr = CUtlProps<T>::SetProperties(0, cPropertySets, rgPropertySets,
                                                1, ppGuid);
                        }
                }

exit:
                delete[] pdbPropSet;
                return hr;
        }
};


#define BEGIN_SCHEMA_MAP(SchemaClass) \
        typedef SchemaClass _SchemaClass; \
        HRESULT _SchemaSupport(GUID** ppGuid, \
                                                   IUnknown *pUnkOuter, \
                                                   REFIID rguidSchema, \
                                                   ULONG cRestrictions, \
                                                   const VARIANT rgRestrictions[], \
                                                   REFIID riid, \
                                                   ULONG cPropertySets, \
                                                   DBPROPSET rgPropertySets[], \
                                                   IUnknown **ppRowset) \
        { \
        int cGuids = 0; \
        HRESULT hr = S_OK; \
        if (ppGuid != NULL) \
                *ppGuid = NULL;

#define SCHEMA_ENTRY(guid, rowsetClass) \
        if (ppGuid != NULL && SUCCEEDED(hr)) \
        { \
                cGuids++; \
                *ppGuid = (GUID*)CoTaskMemRealloc(*ppGuid, cGuids * sizeof(GUID)); \
                hr = (*ppGuid == NULL) ? E_OUTOFMEMORY : S_OK; \
                if (SUCCEEDED(hr)) \
                        (*ppGuid)[cGuids - 1] = guid; \
        } \
        else \
        { \
                if (InlineIsEqualGUID(guid, rguidSchema)) \
                { \
                        rowsetClass* pRowset; \
                        hr =  CreateSchemaRowset(pUnkOuter, cRestrictions, \
                                                           rgRestrictions, riid, cPropertySets, \
                                                           rgPropertySets, ppRowset, pRowset); \
                        return hr; \
                } \
        }

#define END_SCHEMA_MAP() \
                if (ppGuid != NULL) \
                        return hr; \
                return E_INVALIDARG; \
        }


template <class SessionClass>
class  ATL_NO_VTABLE IDBSchemaRowsetImpl: public IDBSchemaRowset
{
public:

        OUT_OF_LINE HRESULT InternalCreateSchemaRowset(IUnknown *pUnkOuter, ULONG /*cRestrictions*/,
                                                           const VARIANT /*rgRestrictions*/[], REFIID riid,
                                                           ULONG cPropertySets, DBPROPSET rgPropertySets[],
                                                           IUnknown** ppRowset, IUnknown* pUnkThis, CUtlPropsBase* pProps,
                                                           IUnknown* pUnkSession)
        {
                HRESULT hr, hrProps = S_OK;
                if (ppRowset != NULL)
                        *ppRowset = NULL;
                if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
                        return DB_E_NOAGGREGATION;
                CComPtr<IUnknown> spUnk;
                hr = pUnkThis->QueryInterface(IID_IUnknown, (void**)&spUnk);
                if (FAILED(hr))
                        return hr;
                hr = pProps->FInit();
                if (FAILED(hr))
                        return hr;
                hr = pProps->SetPropertiesArgChk(cPropertySets, rgPropertySets);
                if (FAILED(hr))
                        return hr;
                const GUID* ppGuid[1];
                ppGuid[0] = &DBPROPSET_ROWSET;

                // Call SetProperties.  The true in the last parameter indicates
                // the special behavior that takes place on rowset creation (i.e.
                // it succeeds as long as any of the properties were not marked
                // as DBPROPS_REQUIRED.

                hrProps = pProps->SetProperties(0, cPropertySets, rgPropertySets,
                                                                                        1, ppGuid, true);
                if (FAILED(hrProps))
                        return hrProps;

                if (ppRowset == NULL)
                        return (hrProps == DB_S_ERRORSOCCURRED) ? DB_E_ERRORSOCCURRED : hr;

                CComQIPtr<IObjectWithSite> spSite = spUnk;
                ATLASSERT(spSite != NULL);
                hr = spSite->SetSite(pUnkSession);
                if (FAILED(hr))
                        return hr;
                if (InlineIsEqualGUID(riid, IID_NULL))
                        return E_NOINTERFACE;
                hr = spUnk->QueryInterface(riid, (void**)ppRowset);
                if (FAILED(hr))
                {
                        *ppRowset = NULL;
                        return hr;
                }
                return (hrProps == DB_S_ERRORSOCCURRED) ? hrProps : hr;
        }

        template <class SchemaRowsetClass>
        HRESULT CreateSchemaRowset(IUnknown *pUnkOuter, ULONG cRestrictions,
                                                           const VARIANT rgRestrictions[], REFIID riid,
                                                           ULONG cPropertySets, DBPROPSET rgPropertySets[],
                                                           IUnknown** ppRowset, SchemaRowsetClass*& pSchemaRowset)
        {
                HRESULT hrProps, hr = S_OK;
                SessionClass* pT = (SessionClass*) this;
                CComPolyObject<SchemaRowsetClass>* pPolyObj;
                if (FAILED(hr = CComPolyObject<SchemaRowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
                        return hr;
                pSchemaRowset = &(pPolyObj->m_contained);
                hr = InternalCreateSchemaRowset(pUnkOuter, cRestrictions, rgRestrictions,
                                                                                riid, cPropertySets, rgPropertySets, ppRowset,
                                                                                pPolyObj, pT, pT->GetUnknown());
                // Ref the created COM object and Auto release it on failure
                if (FAILED(hr))
                        return hr;

                hrProps = hr;
                // Get a pointer to the Rowset instance
                LONG cRowsAffected;
                hr = pSchemaRowset->Execute(&cRowsAffected, cRestrictions, rgRestrictions);
                if (FAILED(hr))
                        return hr;
                return (hrProps == DB_S_ERRORSOCCURRED) ? hrProps : hr;
        }


        void SetRestrictions(ULONG cRestrictions, GUID* /*rguidSchema*/, ULONG* rgRestrictions)
        {
                memset(rgRestrictions, 0, sizeof(ULONG) * cRestrictions);
        }

        STDMETHOD(GetSchemas)(ULONG * pcSchemas, GUID ** prgSchemas, ULONG** prgRest)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IDBSchemaRowsetImpl::GetSchemas\n");
                if (pcSchemas != NULL)
                        *pcSchemas = 0;
                if (prgSchemas != NULL)
                        *prgSchemas = NULL;
                if (pcSchemas == NULL || prgSchemas == NULL)
                        return E_INVALIDARG;

                SessionClass* pT = (SessionClass*)this;

                HRESULT hr = pT->_SchemaSupport(prgSchemas, NULL, GUID_NULL, 0,
                                                                                NULL, GUID_NULL, 0, NULL, NULL);
                if (FAILED(hr))
                        return hr;

                CComPtr<IMalloc> spMalloc;
                hr = CoGetMalloc(1, &spMalloc);
                if (FAILED(hr))
                {
                        CoTaskMemFree(*prgSchemas);
                        *prgSchemas = NULL;
                        return hr;
                }
                *pcSchemas = (ULONG)(ULONG_PTR)spMalloc->GetSize(*prgSchemas) / sizeof(GUID);

                if (prgRest != NULL)
                {
                        // The OLE DB spec states that if prgRest == NULL not to return array
                        // but it also says that is E_INVALIDARG, so doing first
                        *prgRest = (ULONG*) spMalloc->Alloc(sizeof(ULONG) * (*pcSchemas));
                        if (*prgRest == NULL)
                        {
                                spMalloc->Free(*prgSchemas);
                                *prgSchemas = NULL;
                                return E_OUTOFMEMORY;
                        }
                        pT->SetRestrictions(*pcSchemas, *prgSchemas, *prgRest);
                }
                return hr;
        }
        STDMETHOD(GetRowset)(IUnknown *pUnkOuter, REFGUID rguidSchema, ULONG cRestrictions,
                                                 const VARIANT rgRestrictions[], REFIID riid, ULONG cPropertySets,
                                                 DBPROPSET rgPropertySets[], IUnknown **ppRowset)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IDBSchemaRowsetImpl::GetRowset\n");
                SessionClass* pT = (SessionClass*)this;
                return  pT->_SchemaSupport(NULL, pUnkOuter, rguidSchema, cRestrictions,
                                                                   rgRestrictions, riid, cPropertySets,
                                                                   rgPropertySets, ppRowset);

        }

};

// IDBCreateCommandImpl
template <class T, class CommandClass>
class ATL_NO_VTABLE IDBCreateCommandImpl : public IDBCreateCommand
{
public:
        STDMETHOD(CreateCommand)(IUnknown *pUnkOuter,
                                                         REFIID riid,
                                                         IUnknown **ppvCommand)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IDBCreateCommandImpl::CreateCommand\n");
                if (ppvCommand == NULL)
                        return E_INVALIDARG;
                HRESULT hr;
                CComPolyObject<CommandClass>* pCommand;

                // You can't QI for an interface other than IUnknown when aggregating
                // and creating the object.  You might ask for your own interface,
                // which would be bad.  Note, we return DB_E_NOAGGREGATION instead of
                // CLASS_E_NOAGGREGATION due to OLE DB constraints.
                if (pUnkOuter != NULL && !InlineIsEqualUnknown(riid))
                        return DB_E_NOAGGREGATION;

                hr = CComPolyObject<CommandClass>::CreateInstance(pUnkOuter, &pCommand);
                if (FAILED(hr))
                        return hr;
                // Ref the created COM object and Auto release it on failure
                CComPtr<IUnknown> spUnk;
                hr = pCommand->QueryInterface(&spUnk);
                if (FAILED(hr))
                {
                        delete pCommand; // must hand delete as it is not ref'd
                        return hr;
                }
                ATLASSERT(pCommand->m_contained.m_spUnkSite == NULL);
                pCommand->m_contained.SetSite(this);
                hr = pCommand->QueryInterface(riid, (void**)ppvCommand);
                return hr;
        }

};


// IGetDataSourceImpl
template <class T>
class ATL_NO_VTABLE IGetDataSourceImpl : public IGetDataSource
{
public:
        STDMETHOD(GetDataSource)(REFIID riid,
                                                         IUnknown **ppDataSource)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IGetDataSourceImpl::GetDataSource\n");
                if (ppDataSource == NULL)
                        return E_INVALIDARG;
                T* pT = (T*) this;
                ATLASSERT(pT->m_spUnkSite != NULL);
                return pT->m_spUnkSite->QueryInterface(riid, (void**)ppDataSource);
        }
};


// IOpenRowsetImpl
template <class SessionClass>
class IOpenRowsetImpl : public IOpenRowset
{
public:
        template <class RowsetClass>
        HRESULT CreateRowset(IUnknown* pUnkOuter,
                                                 DBID *pTableID, DBID *pIndexID,
                                                 REFIID riid,
                                                 ULONG cPropertySets, DBPROPSET rgPropertySets[],
                                                 IUnknown** ppRowset,
                                                 RowsetClass*& pRowsetObj)
        {
                HRESULT hr, hrProps = S_OK;
                if (ppRowset != NULL)
                        *ppRowset = NULL;
                if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
                        return DB_E_NOAGGREGATION;
                CComPolyObject<RowsetClass>* pPolyObj;
                if (FAILED(hr = CComPolyObject<RowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
                        return hr;
                // Ref the created COM object and Auto release it on failure
                CComPtr<IUnknown> spUnk;
                hr = pPolyObj->QueryInterface(&spUnk);
                if (FAILED(hr))
                {
                        delete pPolyObj; // must hand delete as it is not ref'd
                        return hr;
                }
                // Get a pointer to the Rowset instance
                pRowsetObj = &(pPolyObj->m_contained);
                hr = pRowsetObj->FInit();
                if (FAILED(hr))
                        return hr;
                hr = pRowsetObj->SetPropertiesArgChk(cPropertySets, rgPropertySets);
                if (FAILED(hr))
                        return hr;

                const GUID* ppGuid[1];
                ppGuid[0] = &DBPROPSET_ROWSET;

                // Call SetProperties.  The true in the last parameter indicates
                // the special behavior that takes place on rowset creation (i.e.
                // it succeeds as long as any of the properties were not marked
                // as DBPROPS_REQUIRED.

                hrProps = pRowsetObj->SetProperties(0, cPropertySets, rgPropertySets,
                                                                                        1, ppGuid, true);
                if (FAILED(hrProps))
                        return hrProps;

                pRowsetObj->SetSite(((SessionClass*)this)->GetUnknown());

                hr = pRowsetObj->SetCommandText(pTableID, pIndexID);
                if (FAILED(hr))
                        return hr;
                DBROWCOUNT cRowsAffected;
                if (FAILED(hr = pRowsetObj->Execute(NULL, &cRowsAffected)))
                        return hr;
                if (InlineIsEqualGUID(riid, IID_NULL))
                {
                        return E_NOINTERFACE;
                }
                else
                {
                        if (ppRowset == NULL)
                                return (hrProps == DB_S_ERRORSOCCURRED) ? DB_E_ERRORSOCCURRED : hr;

                        hr = pPolyObj->QueryInterface(riid, (void**)ppRowset);
                }

                if (FAILED(hr))
                {
                        *ppRowset = NULL;
                        return hr;
                }
                return (hrProps == DB_S_ERRORSOCCURRED) ? hrProps : hr;
        }

};

// IColumnsInfoImpl
template <class T>
class ATL_NO_VTABLE IColumnsInfoImpl :
        public IColumnsInfo,
        public CDBIDOps
{
public:

        HRESULT CheckCommandText(IUnknown* pUnkThis)
        {
                HRESULT hr = E_FAIL;
                CComPtr<ICommandText> spText;
                if (SUCCEEDED(hr = pUnkThis->QueryInterface(IID_ICommandText, (void**)&spText)))
                {
                        LPOLESTR szCommand;
                        hr = spText->GetCommandText(NULL, &szCommand);
                        if (SUCCEEDED(hr))
                                CoTaskMemFree(szCommand);
                }
                return hr;
        }
        OUT_OF_LINE HRESULT InternalGetColumnInfo(DBORDINAL *pcColumns, ATLCOLUMNINFO** ppInfo)
        {
                ATLASSERT(ppInfo != NULL);
                T* pT = (T*) this;
                if (pT->CheckCommandText(pT->GetUnknown()) == DB_E_NOCOMMAND)
                        return DB_E_NOCOMMAND;
                *ppInfo = T::GetColumnInfo(pT, pcColumns);
                return S_OK;

        }
        STDMETHOD(GetColumnInfo)(DBORDINAL *pcColumns,
                                                         DBCOLUMNINFO **prgInfo,
                                                         OLECHAR **ppStringsBuffer)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IColumnsInfoImpl::GetColumnInfo\n");
                if (pcColumns == NULL || prgInfo == NULL || ppStringsBuffer == NULL)
                {
                        if (prgInfo != NULL)
                                *prgInfo = NULL;
                        if (ppStringsBuffer != NULL)
                                *ppStringsBuffer = NULL;
                        if (pcColumns != NULL)
                                *pcColumns = NULL;
                        return E_INVALIDARG;
                }

                // NULL out pointers in case of an error
                *prgInfo = NULL;
                *ppStringsBuffer = NULL;
                *pcColumns = 0;

                ATLCOLUMNINFO* pInfo;
                HRESULT hr = InternalGetColumnInfo(pcColumns, &pInfo);
                if (FAILED(hr))
                        return hr;
                ATLASSERT(pInfo != NULL);
                *prgInfo = (DBCOLUMNINFO*)CoTaskMemAlloc(*pcColumns * sizeof(DBCOLUMNINFO));
                if (*prgInfo != NULL)
                {
                        for (DBORDINAL iCol = 0, cwRequired = 0; iCol < *pcColumns; iCol++)
                        {
                                memcpy(&((*prgInfo)[iCol]), &pInfo[iCol], sizeof(DBCOLUMNINFO));
                                if (pInfo[iCol].pwszName)
                                {
                                        cwRequired += wcslen(pInfo[iCol].pwszName) + 1;
                                }
                        }
                        *ppStringsBuffer = (OLECHAR*)CoTaskMemAlloc(cwRequired*sizeof(OLECHAR));
                        if (*ppStringsBuffer)
                        {
                                for (DBORDINAL iCol = 0, iOffset = 0; iCol < *pcColumns; iCol++)
                                {
                                        if (pInfo[iCol].pwszName)
                                        {
                                                lstrcpyW(*ppStringsBuffer + iOffset,  pInfo[iCol].pwszName);
                                                iOffset += wcslen(*ppStringsBuffer + iOffset) + 1;
                                        }
                                }
                                return S_OK;
                        }
                        else
                        {
                                ATLTRACE2(atlTraceDBProvider, 0, _T("Failed to allocate string buffer\n"));
                                CoTaskMemFree(*prgInfo);
                                *prgInfo = NULL;
                                *pcColumns = 0;
                                return E_OUTOFMEMORY;
                        }
                }
                else
                {
                        ATLTRACE2(atlTraceDBProvider, 0, _T("Failed to allocate ColumnInfo array\n"));
                        *prgInfo = NULL;
                        *pcColumns = 0;
                        return E_OUTOFMEMORY;
                }

        }

        STDMETHOD(MapColumnIDs)(DBORDINAL cColumnIDs,
                                                        const DBID rgColumnIDs[],
                                                        DBORDINAL rgColumns[])
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IColumnsInfoImpl::MapColumnIDs\n");
                USES_CONVERSION;
                if ((cColumnIDs != 0 && rgColumnIDs == NULL) || rgColumns == NULL)
                        return E_INVALIDARG;
                DBORDINAL cCols = 0;
                DBORDINAL cColsInError = 0;
                HRESULT hr = S_OK;
                ATLCOLUMNINFO* pInfo;
                for (DBORDINAL iColId = 0; iColId < cColumnIDs; iColId++)
                {
                        hr = InternalGetColumnInfo(&cCols, &pInfo);
                        if (hr == DB_E_NOCOMMAND)
                                return hr;
                        ULONG iColMapCur = 0;
                        BOOL bDone = FALSE;
                        while(iColMapCur < cCols && !bDone)
                        {
                                hr = CompareDBIDs(&(pInfo[iColMapCur].columnid), &(rgColumnIDs[iColId]));
                                bDone = (hr == S_OK || FAILED(hr));
                                if (hr == S_OK)
                                        rgColumns[iColId] = pInfo[iColMapCur].iOrdinal;
                                iColMapCur++;
                        }
                        if (!bDone || FAILED(hr))
                        {
                                rgColumns[iColId] = DB_INVALIDCOLUMN;
                                cColsInError++;
                        }

                }
                if (cColsInError > 0 && cColumnIDs == cColsInError)
                        return DB_E_ERRORSOCCURRED;
                if (cColsInError > 0 && cColsInError < cColumnIDs)
                        return DB_S_ERRORSOCCURRED;
                return S_OK;
        }
};

//IConvertTypeImpl
template <class T>
class ATL_NO_VTABLE IConvertTypeImpl : public IConvertType, public CConvertHelper
{
public:
        HRESULT InternalCanConvert(DBTYPE wFromType, DBTYPE wToType, DBCONVERTFLAGS dwConvertFlags,
                                                                   bool bIsCommand, bool bHasParamaters, IObjectWithSite* pSite)
        {

                // Check to see if conversion types are invalid.  Note, this is just a
                // quick test as it would be difficult to check each available type
                // (as new DBTYPE values can be added).
                if ((wFromType & 0x8000) || (wToType & 0x8000))
                        return E_INVALIDARG;

                // Determine if new 2.x flags are valid
                if((dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH)) != DBCONVERTFLAGS_COLUMN
                        && (dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH)) != DBCONVERTFLAGS_PARAMETER )
                        return DB_E_BADCONVERTFLAG;

#ifdef _LATER
                // If the convert flags are for DBCONVERTFLAGS_FROMVARIANT, check to see
                // that the type is a variant type
                if (dwConvertFlags == DBCONVERTFLAGS_FROMVARIANT)
                {
                        if (wFromType != DBTYPE_VARIANT)
                                return DB_E_BADTYPE;
                }
#endif // _LATER

                // Note, if the convert flag is either ISLONG or ISFIXEDLENGTH, then we should
                // make sure we are not dealing with an OLE DB 1.x provider.  However, since
                // we default to 2.x providers, we don't check this.  If you, change the
                // DBPROP_PROVIDEROLEDBVER property in the DATASOURCEINFO group, you need to
                // check the property value and return a DB_E_BADCONVERTFLAG if it is a 1.x
                // provider.

                // Do we have ISLONG on a fixed length data type?
                DBTYPE dbtype = wFromType & ~(DBTYPE_BYREF|DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_RESERVED);
                if ((dwConvertFlags & DBCONVERTFLAGS_ISLONG) &&
                        (dbtype != DBTYPE_WSTR && dbtype != DBTYPE_STR && dbtype != DBTYPE_BYTES && dbtype != DBTYPE_VARNUMERIC))
                        return DB_E_BADCONVERTFLAG;

                if (dwConvertFlags == DBCONVERTFLAGS_PARAMETER)
                {
                        // In the case where we are a rowset and ask for a parameter
                        // conversion, return DB_E_BADCONVERTFLAG
                        if (!bIsCommand)
                                return DB_E_BADCONVERTFLAG;

                        // In the case where we are a command and ask for a parameter
                        // conversion and ICommandWithParameters is not supported, return
                        // S_FALSE.  We just can't convert them.
                        if (!bHasParamaters)
                                return S_FALSE;
                }

                // If we deal with a command and the user asks for a conversion on a rowset
                // the DBPROP_ROWSETCONVERSIONSONCOMMAND must be suppored and set to TRUE.
                if (bIsCommand && dwConvertFlags == DBCONVERTFLAGS_COLUMN)
                {
                        CDBPropIDSet set(DBPROPSET_DATASOURCEINFO);
                        set.AddPropertyID(DBPROP_ROWSETCONVERSIONSONCOMMAND);
                        DBPROPSET* pPropSet = NULL;
                        ULONG ulPropSet = 0;
                        //HRESULT hr1 = S_OK;

                        // Get a pointer into the session
                        CComPtr<IGetDataSource> spDataSource = NULL;
                        CComPtr<IDBProperties> spProps = NULL;

                        // if any of these calls fail, we're either unable to retrieve the
                        // property or it is unsupported.  Since the property is only on
                        // the data source object, we use the IObjectWithSite interface to
                        // get the session object and then the GetDataSource method to get
                        // the data source object itself.
                        if (FAILED(pSite->GetSite(IID_IGetDataSource, (void**)&spDataSource)))
                                return DB_E_BADCONVERTFLAG;
                        if (FAILED(spDataSource->GetDataSource(IID_IDBProperties,
                                (IUnknown**)&spProps)))
                                return DB_E_BADCONVERTFLAG;
                        if (FAILED(spProps->GetProperties(1, &set, &ulPropSet, &pPropSet)))
                                return DB_E_BADCONVERTFLAG;

                        if (pPropSet != NULL)
                        {
                                CComVariant var = pPropSet->rgProperties[0].vValue;
                                CoTaskMemFree(pPropSet->rgProperties);
                                CoTaskMemFree(pPropSet);

                                if (var.boolVal == VARIANT_FALSE)
                                        return DB_E_BADCONVERTFLAG;
                        }
                }
                HRESULT hr = E_FAIL;
                if (m_spConvert != NULL)
                {
                        hr = m_spConvert->CanConvert(wFromType, wToType);
                }
                return hr;
        }
        STDMETHOD(CanConvert)(DBTYPE wFromType, DBTYPE wToType, DBCONVERTFLAGS dwConvertFlags)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IConvertTypeImpl::CanConvert\n");
                T* pT = (T*)this;
                return pT->InternalCanConvert(wFromType, wToType, dwConvertFlags, pT->m_bIsCommand, pT->m_bHasParamaters, pT);
        }
};

template <class T, class PropClass = T>
class ATL_NO_VTABLE ICommandPropertiesImpl :
        public ICommandProperties,
        public CUtlProps<PropClass>
{
public:
        typedef PropClass _PropClass;

        STDMETHOD(GetProperties)(const ULONG cPropertyIDSets,
                                                         const DBPROPIDSET rgPropertyIDSets[],
                                                         ULONG *pcPropertySets,
                                                         DBPROPSET **prgPropertySets)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "ICommandPropertiesImpl::GetProperties\n");
                HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
                const GUID* ppGuid[1];
                ppGuid[0] = &DBPROPSET_ROWSET;
                if(SUCCEEDED(hr))
                        hr = CUtlProps<PropClass>::GetProperties(cPropertyIDSets,
                                        rgPropertyIDSets, pcPropertySets, prgPropertySets,
                                        1, ppGuid);
                return hr;

        }

        STDMETHOD(SetProperties)(ULONG cPropertySets,
                                                         DBPROPSET rgPropertySets[])
        {
                ATLTRACE2(atlTraceDBProvider, 0, "ICommandPropertiesImpl::SetProperties\n");
                HRESULT hr = SetPropertiesArgChk(cPropertySets, rgPropertySets);
                const GUID* ppGuid[1];
                ppGuid[0] = &DBPROPSET_ROWSET;
                if(SUCCEEDED(hr))
                        hr = CUtlProps<PropClass>::SetProperties(0, cPropertySets,
                                        rgPropertySets, 1, ppGuid);
                return hr;
        }
};

template <class T>
class CRunTimeFree
{
public:

        static void Free(T* pData)
        {
                delete [] pData;
        }
};

template <class T>
class CComFree
{
public:

        static void Free(T* pData)
        {
                CoTaskMemFree(pData);
        }
};


template <class T, class DeAllocator = CRunTimeFree < T > >
class CAutoMemRelease
{
public:
        CAutoMemRelease()
        {
                m_pData = NULL;
        }

        CAutoMemRelease(T* pData)
        {
                m_pData = pData;
        }

        ~CAutoMemRelease()
        {
                Attach(NULL);
        }

        void Attach(T* pData)
        {
                DeAllocator::Free(m_pData);
                m_pData = pData;
        }

        T* Detach()
        {
                T* pTemp = m_pData;
                m_pData = NULL;
                return pTemp;
        }

        T* m_pData;
};

template <class T>
class ATL_NO_VTABLE ICommandImpl : public ICommand
{
public:
        ICommandImpl()
        {
                m_bIsExecuting = FALSE;
                m_bCancelWhenExecuting = TRUE;
                m_bCancel = FALSE;
        }
        HRESULT CancelExecution()
        {
                T* pT = (T*)this;
                pT->Lock();
                m_bCancel = TRUE;
                pT->Unlock();
                return S_OK;
        }
        STDMETHOD(Cancel)()
        {
                ATLTRACE2(atlTraceDBProvider, 0, "ICommandImpl::Cancel\n");
                HRESULT hr = S_OK;
                T* pT = (T*)this;

                if (m_bIsExecuting && m_bCancelWhenExecuting)
                {
                        hr = pT->CancelExecution();
                        return hr;
                }
                if (m_bIsExecuting && !m_bCancelWhenExecuting)
                        hr = DB_E_CANTCANCEL;
                return hr;
        }
        STDMETHOD(GetDBSession)(REFIID riid, IUnknown ** ppSession)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "ICommandImpl::GetDBSession\n");
                T* pT = (T*)this;
                ATLASSERT(pT->m_spUnkSite != NULL);
                return pT->m_spUnkSite->QueryInterface(riid, (void**) ppSession);
        }

        template <class RowsetClass>
        HRESULT CreateRowset(IUnknown* pUnkOuter, REFIID riid,
                                                 DBPARAMS * pParams, DBROWCOUNT * pcRowsAffected,
                                                 IUnknown** ppRowset,
                                                 RowsetClass*& pRowsetObj)
        {
                HRESULT hr;
                USES_CONVERSION;
                int iBind;
                T* pT = (T*)this;
                if (ppRowset != NULL)
                        *ppRowset = NULL;
                if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
                        return DB_E_NOAGGREGATION;
                CComPolyObject<RowsetClass>* pPolyObj;
                if (FAILED(hr = CComPolyObject<RowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
                        return hr;
                // Ref the created COM object and Auto release it on failure
                CComPtr<IUnknown> spUnk;
                hr = pPolyObj->QueryInterface(&spUnk);
                if (FAILED(hr))
                {
                        delete pPolyObj; // must hand delete as it is not ref'd
                        return hr;
                }
                // Get a pointer to the Rowset instance
                pRowsetObj = &(pPolyObj->m_contained);

                if (FAILED(hr = pRowsetObj->FInit(pT)))
                        return hr;
                pRowsetObj->SetSite(pT->GetUnknown());

                if (pT->m_strCommandText.Length() == 0)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "ICommandImpl::No command text specified.\n");
                        return DB_E_NOCOMMAND;
                }

                pRowsetObj->m_strCommandText = pT->m_strCommandText;
                if (pRowsetObj->m_strCommandText == (BSTR)NULL)
                        return E_OUTOFMEMORY;
                if (FAILED(hr = pRowsetObj->Execute(pParams, pcRowsAffected)))
                        return hr;
                if (InlineIsEqualGUID(riid, IID_NULL) || ppRowset == NULL)
                {
                        if (ppRowset != NULL)
                                *ppRowset = NULL;
                        return hr;
                }
                hr = pPolyObj->QueryInterface(riid, (void**)ppRowset);
                if (FAILED(hr))
                        return hr;
                for (iBind = 0; iBind < pT->m_rgBindings.GetSize(); iBind++)
                {
                        T::_BindType* pBind = NULL;
                        T::_BindType* pBindSrc = NULL;
                        ATLTRY(pBind = new T::_BindType);
                        if (pBind == NULL)
                        {
                                ATLTRACE2(atlTraceDBProvider, 0, "Failed to allocate memory for new Binding\n");
                                return E_OUTOFMEMORY;
                        }
                        // auto cleanup on failure
                        CAutoMemRelease<T::_BindType> amr(pBind);
                        pBindSrc = pT->m_rgBindings.GetValueAt(iBind);
                        if (pBindSrc == NULL)
                        {
                                ATLTRACE2(atlTraceDBProvider, 0, "The map appears to be corrupted, failing!!\n");
                                return E_FAIL;
                        }
                        if (!pRowsetObj->m_rgBindings.Add(pT->m_rgBindings.GetKeyAt(iBind), pBind))
                        {
                                ATLTRACE2(atlTraceDBProvider, 0, "Failed to add hAccessor to Map\n");
                                return E_OUTOFMEMORY;
                        }
                        if (pBindSrc->cBindings)
                        {
                                ATLTRY(pBind->pBindings = new DBBINDING[pBindSrc->cBindings])
                                if (pBind->pBindings == NULL)
                                {
                                        ATLTRACE2(atlTraceDBProvider, 0, "Failed to Allocate dbbinding Array\n");
                                        // We added it, must now remove on failure
                                        pRowsetObj->m_rgBindings.Remove(pT->m_rgBindings.GetKeyAt(iBind));
                                        return E_OUTOFMEMORY;
                                }
                        }
                        else
                        {
                                pBind->pBindings = NULL; // NULL Accessor
                        }

                        pBind->dwAccessorFlags = pBindSrc->dwAccessorFlags;
                        pBind->cBindings = pBindSrc->cBindings;
                        pBind->dwRef = 1;
                        memcpy (pBind->pBindings, pBindSrc->pBindings, (pBindSrc->cBindings)*sizeof(DBBINDING));
                        pBind = amr.Detach();
                }

                return S_OK;
        }

        unsigned m_bIsExecuting:1;
        unsigned m_bCancelWhenExecuting:1;
        unsigned m_bCancel:1;
};


template <class T>
class ATL_NO_VTABLE ICommandTextImpl : public ICommandImpl<T>
{
public:
        STDMETHOD(GetCommandText)(GUID * /*pguidDialect*/,LPOLESTR * ppwszCommand)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "ICommandTextImpl::GetCommandText\n");
                UINT cchCommandText;
                HRESULT hr = E_FAIL;
                if (ppwszCommand == NULL)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "ICommandTextImpl::GetCommandText Bad Command buffer\n");
                        return E_INVALIDARG;
                }
                if (m_strCommandText.m_str == NULL)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "ICommandTextImpl::GetCommandText Bad Command buffer\n");
                        return DB_E_NOCOMMAND;
                }
                cchCommandText = sizeof(OLECHAR) * (m_strCommandText.Length() + 1);
                *ppwszCommand = (OLECHAR*)CoTaskMemAlloc(cchCommandText);
                if (*ppwszCommand != NULL)
                {
                        memcpy(*ppwszCommand, m_strCommandText.m_str, cchCommandText);
                        *(*ppwszCommand + m_strCommandText.Length()) = (OLECHAR)NULL;
                        return S_OK;
                }
                *ppwszCommand = NULL;
                return hr;
        }

        STDMETHOD(SetCommandText)(REFGUID /*rguidDialect*/,LPCOLESTR pwszCommand)
        {
                T* pT = (T*)this;
                ATLTRACE2(atlTraceDBProvider, 0, "ICommandTextImpl::SetCommandText\n");
                pT->Lock();
                m_strCommandText = pwszCommand;
                pT->Unlock();
                return S_OK;
        }

        CComBSTR m_strCommandText;
};

// ISessionPropertiesImpl
template <class T, class PropClass = T>
class ATL_NO_VTABLE ISessionPropertiesImpl :
        public ISessionProperties,
        public CUtlProps<PropClass>
{
public:
        typedef PropClass _PropClass;

        STDMETHOD(GetProperties)(ULONG cPropertyIDSets,
                                                         const DBPROPIDSET rgPropertyIDSets[],
                                                         ULONG *pcPropertySets,
                                                         DBPROPSET **prgPropertySets)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "ISessionPropertiesImpl::GetProperties\n");
                HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
                const GUID* ppGuid[1];
                ppGuid[0] = &DBPROPSET_SESSION;

                if(SUCCEEDED(hr))
                        hr = CUtlProps<PropClass>::GetProperties(cPropertyIDSets,
                                        rgPropertyIDSets, pcPropertySets, prgPropertySets,
                                        1, ppGuid);
                return hr;

        }

        STDMETHOD(SetProperties)(ULONG cPropertySets,
                                                         DBPROPSET rgPropertySets[])
        {
                ATLTRACE2(atlTraceDBProvider, 0, "ISessionPropertiesImpl::SetProperties");
                HRESULT hr = SetPropertiesArgChk(cPropertySets, rgPropertySets);
                const GUID* ppGuid[1];

                ppGuid[0] = &DBPROPSET_SESSION;
                if(SUCCEEDED(hr))
                        hr = CUtlProps<PropClass>::SetProperties(0, cPropertySets, rgPropertySets,
                                        1, ppGuid);
                return hr;
        }
};

// Implementation Class
template <class BindType>
class ATL_NO_VTABLE IAccessorImplBase : public IAccessor
{
public:

        STDMETHOD(CreateAccessor)(DBACCESSORFLAGS dwAccessorFlags,
                                                          DBCOUNTITEM cBindings,
                                                          const DBBINDING rgBindings[],
                                                          DBLENGTH /*cbRowSize*/,
                                                          HACCESSOR *phAccessor,
                                                          DBBINDSTATUS rgStatus[])
        {
                if (!(dwAccessorFlags & DBACCESSOR_PARAMETERDATA) && !(dwAccessorFlags & DBACCESSOR_ROWDATA))
                        return DB_E_BADACCESSORFLAGS;
                if (dwAccessorFlags == DBACCESSOR_INVALID)
                        return DB_E_BADACCESSORFLAGS;
                if (dwAccessorFlags > 0x000F)
                        return DB_E_BADACCESSORFLAGS;
                BindType *pBind = NULL;
                ATLTRY(pBind = new BindType)
                if (pBind == NULL)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, _T("Failed to allocate ATL Binding struct\n"));
                        return E_OUTOFMEMORY;
                }
                if (cBindings)
                {
                        ATLTRY(pBind->pBindings = new DBBINDING[cBindings])
                        if (pBind->pBindings == NULL)
                        {
                                delete pBind;
                                return E_OUTOFMEMORY;
                        }
                }
                else
                        pBind->pBindings = NULL; // NULL Accessor

                pBind->dwAccessorFlags = dwAccessorFlags;
                pBind->cBindings = cBindings;
                pBind->dwRef = 1;
                memcpy (pBind->pBindings, rgBindings, cBindings*sizeof(DBBINDING));
                DBBINDSTATUS status = DBBINDSTATUS_OK;
                memset (rgStatus, status, sizeof(DBBINDSTATUS)*cBindings);
                *phAccessor = (ULONG_PTR)pBind;
                return S_OK;
        }
        BOOL HasFlag(DBTYPE dbToCheck, DBTYPE dbCombo)
        {
                return ( (dbToCheck & dbCombo) == dbCombo );
        }
        HRESULT ValidateBindings(DBCOUNTITEM cBindings, const DBBINDING rgBindings[],
                                DBBINDSTATUS rgStatus[], bool bHasBookmarks)
        {
                HRESULT hr = S_OK;;

                for (ULONG iBinding = 0; iBinding < cBindings; iBinding++)
                {
                        const DBBINDING& rBindCur = rgBindings[iBinding];
                        if (rBindCur.iOrdinal == 0)
                        {
                                if (!m_bIsCommand && !bHasBookmarks)
                                {
                                        hr = DB_E_ERRORSOCCURRED;
                                        rgStatus[iBinding] = DBBINDSTATUS_BADORDINAL;
                                        continue;
                                }
                        }
                        if (rBindCur.dwPart == 0) // nothing to bind to
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                continue;
                        }
                        if (HasFlag(rBindCur.wType, (DBTYPE_BYREF | DBTYPE_ARRAY)))
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                continue;
                        }
                        if (HasFlag(rBindCur.wType, (DBTYPE_BYREF | DBTYPE_VECTOR)))
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                continue;
                        }
                        if (HasFlag(rBindCur.wType, (DBTYPE_VECTOR | DBTYPE_ARRAY)))
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                continue;
                        }
                        if (rBindCur.wType == DBTYPE_NULL || rBindCur.wType == DBTYPE_EMPTY)
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                continue;
                        }
                        if (HasFlag(rBindCur.wType, DBTYPE_RESERVED))
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                continue;
                        }
                        // Search for DBTYPE_BYREF | DBTYPE_EMPTY
                        if ((rBindCur.wType & 0xBFFF) == 0)
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                continue;
                        }
                        if ((rBindCur.wType & 0xBFFE) == 0)
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                continue;
                        }
                        if (rBindCur.dwMemOwner == DBMEMOWNER_PROVIDEROWNED)
                        {
                                BOOL bIsPointerType = HasFlag(rBindCur.wType, DBTYPE_BYREF) ||
                                                                          HasFlag(rBindCur.wType, DBTYPE_VECTOR) ||
                                                                          HasFlag(rBindCur.wType, DBTYPE_ARRAY) ||
                                                                          HasFlag(~(DBTYPE_BYREF) & rBindCur.wType, DBTYPE_BSTR);
                                if (!bIsPointerType)
                                {
                                        hr = DB_E_ERRORSOCCURRED;
                                        rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                        continue;
                                }
                        }

                }
                return hr;
        }

        unsigned  m_bIsCommand:1;
        unsigned  m_bHasParamaters:1;
        unsigned  m_bIsChangeable:1;
};

// IAccessorImpl
template <class T, class BindType = ATLBINDINGS, class BindingVector = CSimpleMap < INT_PTR, BindType* > >
class ATL_NO_VTABLE IAccessorImpl : public IAccessorImplBase<BindType>
{
public:
        typedef BindType _BindType;
        typedef BindingVector _BindingVector;
        IAccessorImpl()
        {
                m_bIsCommand = FALSE;
                m_bHasParamaters = FALSE;
                m_bIsChangeable = FALSE;
        }
        OUT_OF_LINE HRESULT InternalFinalConstruct(IUnknown* pUnkThis)
        {
                CComQIPtr<ICommand> spCommand = pUnkThis;
                if (spCommand != NULL)
                {
                        m_bIsCommand = TRUE;
                        CComQIPtr<ICommandWithParameters> spCommandParams = pUnkThis;
                        m_bHasParamaters =  spCommandParams != NULL;
                }
                else // its a Rowset
                {
                        CComQIPtr<IRowsetChange> spRSChange = pUnkThis;
                        m_bIsChangeable = spRSChange != NULL;
                }
                return S_OK;
        }
        HRESULT FinalConstruct()
        {
                T* pT = (T*)this;
                return InternalFinalConstruct(pT->GetUnknown());
        }
        void FinalRelease()
        {
#ifdef _DEBUG
                if (m_rgBindings.GetSize())
                        ATLTRACE2(atlTraceDBProvider, 0, "IAccessorImpl::~IAccessorImpl Bindings still in vector, removing\n");
#endif //_DEBUG
                while (m_rgBindings.GetSize())
                        ReleaseAccessor((HACCESSOR)m_rgBindings.GetKeyAt(0), NULL);
        }
        STDMETHOD(AddRefAccessor)(HACCESSOR hAccessor,
                                                          DBREFCOUNT *pcRefCount)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IAccessorImpl::AddRefAccessor\n");
                if (hAccessor == NULL)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, _T("AddRefAccessor : Bad hAccessor\n"));
                        return E_INVALIDARG;
                }
                if (pcRefCount == NULL)
                        pcRefCount = (ULONG*)_alloca(sizeof(ULONG));

                BindType* pBind = m_rgBindings.Lookup((int)hAccessor);
                *pcRefCount = T::_ThreadModel::Increment((LONG*)&pBind->dwRef);
                return S_OK;
        }
        OUT_OF_LINE ATLCOLUMNINFO* ValidateHelper(DBORDINAL* pcCols, CComPtr<IDataConvert> & rspConvert)
        {
                T* pT = (T*)this;
                rspConvert = pT->m_spConvert;
                return pT->GetColumnInfo(pT, pcCols);
        }
        OUT_OF_LINE HRESULT ValidateBindingsFromMetaData(DBCOUNTITEM cBindings, const DBBINDING rgBindings[],
                                DBBINDSTATUS rgStatus[], bool bHasBookmarks)
        {
                HRESULT hr = S_OK;
                DBORDINAL cCols;
                CComPtr<IDataConvert> spConvert;
                ATLCOLUMNINFO* pColInfo = ValidateHelper(&cCols, spConvert);
                ATLASSERT(pColInfo != NULL);
                for (ULONG iBinding = 0; iBinding < cBindings; iBinding++)
                {
                        const DBBINDING& rBindCur = rgBindings[iBinding];
                        DBORDINAL iOrdAdjusted;
                        if (bHasBookmarks)
                                iOrdAdjusted = rBindCur.iOrdinal;   // Bookmarks start with ordinal 0
                        else
                                iOrdAdjusted = rBindCur.iOrdinal - 1; // Non-bookmarks start w/ ordinal 1
                        if (rBindCur.iOrdinal > cCols)
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_BADORDINAL;
                                continue;
                        }

                        // If a binding specifies provider owned memory, and specifies type
                        // X | BYREF, and the provider's copy is not X or X | BYREF, return
                        // DBBINDSTATUS_BADBINDINFO
                        if (rBindCur.dwMemOwner == DBMEMOWNER_PROVIDEROWNED)
                        {
                                if ((rBindCur.wType & DBTYPE_BYREF) != 0)
                                {
                                        DBTYPE dbConsumerType = rBindCur.wType & 0xBFFF;
                                        DBTYPE dbProviderType = pColInfo[iOrdAdjusted].wType & 0xBFFF;

                                        if (dbConsumerType != dbProviderType)
                                        {
                                                hr = DB_E_ERRORSOCCURRED;
                                                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
                                                continue;
                                        }
                                }
                        }

                        ATLASSERT(spConvert != NULL);
                        HRESULT hrConvert = spConvert->CanConvert(pColInfo[iOrdAdjusted].wType, rBindCur.wType);
                        if (FAILED(hrConvert) || hrConvert == S_FALSE)
                        {
                                hr = DB_E_ERRORSOCCURRED;
                                rgStatus[iBinding] = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
                                continue;
                        }
                }
                return hr;
        }
        STDMETHOD(CreateAccessor)(DBACCESSORFLAGS dwAccessorFlags,
                                                          DBCOUNTITEM cBindings,
                                                          const DBBINDING rgBindings[],
                                                          DBLENGTH cbRowSize,
                                                          HACCESSOR *phAccessor,
                                                          DBBINDSTATUS rgStatus[])
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IAccessorImpl::CreateAccessor\n");
                T* pT = (T*)this;
                T::ObjectLock cab(pT);

                if (!phAccessor)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "IAccessorImpl::CreateAccessor : Inavlid NULL Parameter for HACCESSOR*\n");
                        return E_INVALIDARG;
                }
                *phAccessor = NULL;
                if (cBindings != 0 && rgBindings == NULL)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "IAccessorImpl::CreateAccessor  : Bad Binding array\n");
                        return E_INVALIDARG;
                }
                if (dwAccessorFlags & DBACCESSOR_PASSBYREF)
                {
                        CComVariant varByRef;
                        HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_BYREFACCESSORS, &varByRef);
                        if (FAILED(hr) || varByRef.boolVal == VARIANT_FALSE)
                                return DB_E_BYREFACCESSORNOTSUPPORTED;
                }
                if (!m_bHasParamaters)
                {
                        if (dwAccessorFlags & DBACCESSOR_PARAMETERDATA)
                                return DB_E_BADACCESSORFLAGS;
                }
                if (m_bIsCommand || !m_bIsChangeable)
                {
                        if (cBindings == 0) // No NULL Accessors on the command
                                return DB_E_NULLACCESSORNOTSUPPORTED;
                }

                if (rgStatus == NULL && cBindings) // Create a fake status array
                        rgStatus = (DBBINDSTATUS*)_alloca(cBindings*sizeof(DBBINDSTATUS));

                // Validate the Binding passed
                HRESULT hr;
                bool bHasBookmarks = false;
                CComVariant varBookmarks;
                HRESULT hrLocal = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_BOOKMARKS, &varBookmarks);
                bHasBookmarks = (hrLocal == S_OK &&  varBookmarks.boolVal == VARIANT_TRUE);

                hr = ValidateBindings(cBindings, rgBindings, rgStatus, bHasBookmarks);
                if (FAILED(hr))
                        return hr;
                if (!m_bIsCommand)
                {
                        hr = ValidateBindingsFromMetaData(cBindings, rgBindings, rgStatus,
                                        bHasBookmarks);
                        if (FAILED(hr))
                                return hr;
                }
                hr = IAccessorImplBase<BindType>::CreateAccessor(dwAccessorFlags, cBindings,
                        rgBindings, cbRowSize, phAccessor,rgStatus);
                if (SUCCEEDED(hr))
                {
                        ATLASSERT(*phAccessor != NULL);
                        BindType* pBind = (BindType*)*phAccessor;
                        hr = m_rgBindings.Add((HACCESSOR)pBind, pBind) ? S_OK : E_OUTOFMEMORY;
                }
                return hr;

        }

        STDMETHOD(GetBindings)(HACCESSOR hAccessor,
                                                   DBACCESSORFLAGS *pdwAccessorFlags,
                                                   DBCOUNTITEM *pcBindings,
                                                   DBBINDING **prgBindings)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IAccessorImpl::GetBindings");

                // Zero output parameters in case of failure
                if (pdwAccessorFlags != NULL)
                        *pdwAccessorFlags = NULL;

                if (pcBindings != NULL)
                        *pcBindings = NULL;

                if (prgBindings != NULL)
                        *prgBindings = NULL;

                // Check if any of the out params are NULL pointers
                if ((pdwAccessorFlags && pcBindings && prgBindings) == NULL)
                        return E_INVALIDARG;

                BindType* pBind = m_rgBindings.Lookup((int)hAccessor);
                HRESULT hr = DB_E_BADACCESSORHANDLE;
                if (pBind != NULL)
                {
                        *pdwAccessorFlags = pBind->dwAccessorFlags;
                        *pcBindings = pBind->cBindings;
                        *prgBindings = (DBBINDING*)CoTaskMemAlloc(*pcBindings * sizeof(DBBINDING));
                        if (*prgBindings == NULL)
                                return E_OUTOFMEMORY;
                        memcpy(*prgBindings, pBind->pBindings, sizeof(DBBINDING) * (*pcBindings));
                        hr = S_OK;
                }
                return hr;
        }

        STDMETHOD(ReleaseAccessor)(HACCESSOR hAccessor,
                                                           DBREFCOUNT *pcRefCount)
        {
                ATLTRACE2(atlTraceDBProvider, 0, _T("IAccessorImpl::ReleaseAccessor\n"));
                BindType* pBind = m_rgBindings.Lookup((int)hAccessor);
                if (pBind == NULL)
                        return DB_E_BADACCESSORHANDLE;

                if (pcRefCount == NULL)
                        pcRefCount = (DBREFCOUNT*)_alloca(sizeof(DBREFCOUNT));
                *pcRefCount = T::_ThreadModel::Decrement((LONG*)&pBind->dwRef);
                if (!(*pcRefCount))
                {
                        delete [] pBind->pBindings;
                        delete pBind;
                        return m_rgBindings.Remove((int)hAccessor) ? S_OK : DB_E_BADACCESSORHANDLE;
                }
                return S_OK;
        }

        BindingVector m_rgBindings;
};

#define BEGIN_PROVIDER_COLUMN_MAP(theClass) \
        typedef theClass _Class; \
        template <class T> \
        static ATLCOLUMNINFO* GetColumnInfo(T* pv, DBORDINAL* pcCols) \
        { \
        pv; \
        static ATLCOLUMNINFO _rgColumns [] = \
        {

#define SIZEOF_MEMBER(memberOf, member) \
        sizeof(((memberOf*)0)->member)
#define EXPANDGUID(guid) \
        { guid.Data1, guid.Data2, guid.Data3, \
        { guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] } }

#define PROVIDER_COLUMN_ENTRY_GN(name, ordinal, flags, colSize, dbtype, precision, scale, guid) \
{ (LPOLESTR)name, (ITypeInfo*)NULL, (ULONG)ordinal, (DBCOLUMNFLAGS)flags, (ULONG)colSize, (DBTYPE)dbtype, (BYTE)precision, (BYTE)scale, { EXPANDGUID(guid), (DWORD)0, (LPOLESTR) name}, 0},

#define PROVIDER_COLUMN_ENTRY(name, ordinal, member) \
        { \
                (LPOLESTR)OLESTR(name), \
                (ITypeInfo*)NULL, \
                (ULONG)ordinal, \
                DBCOLUMNFLAGS_ISFIXEDLENGTH, \
                (ULONG)sizeof(((_Class*)0)->member), \
                _GetOleDBType(((_Class*)0)->member), \
                (BYTE)0, \
                (BYTE)0, \
                { \
                        EXPANDGUID(GUID_NULL), \
                        (DWORD)2, \
                        (LPOLESTR) name \
                }, \
                offsetof(_Class, member) \
        },

#define PROVIDER_COLUMN_ENTRY_LENGTH(name, ordinal, size, member) \
        { \
                (LPOLESTR)OLESTR(name), \
                (ITypeInfo*)NULL, \
                (ULONG)ordinal, \
                DBCOLUMNFLAGS_ISFIXEDLENGTH, \
                (ULONG)size, \
                _GetOleDBType(((_Class*)0)->member), \
                (BYTE)0, \
                (BYTE)0, \
                { \
                        EXPANDGUID(GUID_NULL), \
                        (DWORD)2, \
                        (LPOLESTR) name \
                }, \
                offsetof(_Class, member) \
        },

#define PROVIDER_COLUMN_ENTRY_TYPE_LENGTH(name, ordinal, type, size, member) \
        { \
                (LPOLESTR)OLESTR(name), \
                (ITypeInfo*)NULL, \
                (ULONG)ordinal, \
                DBCOLUMNFLAGS_ISFIXEDLENGTH, \
                (ULONG)size, \
                (DBTYPE)type, \
                (BYTE)0, \
                (BYTE)0, \
                { \
                        EXPANDGUID(GUID_NULL), \
                        (DWORD)2, \
                        (LPOLESTR) name \
                }, \
                offsetof(_Class, member) \
        },

#define PROVIDER_COLUMN_ENTRY_FIXED(name, ordinal, dbtype, member) \
        { \
                (LPOLESTR)OLESTR(name), \
                (ITypeInfo*)NULL, \
                (ULONG)ordinal, \
                DBCOLUMNFLAGS_ISFIXEDLENGTH, \
                (ULONG)sizeof(((_Class*)0)->member), \
                (DBTYPE)dbtype, \
                (BYTE)0, \
                (BYTE)0, \
                { \
                        EXPANDGUID(GUID_NULL), \
                        (DWORD)2, \
                        (LPOLESTR) name \
                }, \
                offsetof(_Class, member) \
        },

#define PROVIDER_COLUMN_ENTRY_STR(name, ordinal, member) \
        { \
                (LPOLESTR)OLESTR(name), \
                (ITypeInfo*)NULL, \
                (ULONG)ordinal, \
                0, \
                (ULONG)sizeof(((_Class*)0)->member), \
                DBTYPE_STR, \
                (BYTE)0xFF, \
                (BYTE)0xFF, \
                { \
                        EXPANDGUID(GUID_NULL), \
                        (DWORD)2, \
                        (LPOLESTR) name \
                }, \
                offsetof(_Class, member) \
        },

#define PROVIDER_COLUMN_ENTRY_WSTR(name, ordinal, member) \
        { \
                (LPOLESTR)OLESTR(name), \
                (ITypeInfo*)NULL, \
                (ULONG)ordinal, \
                0, \
                (ULONG)sizeof(((_Class*)0)->member), \
                DBTYPE_WSTR, \
                (BYTE)0xFF, \
                (BYTE)0xFF, \
                { \
                        EXPANDGUID(GUID_NULL), \
                        (DWORD)2, \
                        (LPOLESTR) name \
                }, \
                offsetof(_Class, member) \
        },

#define END_PROVIDER_COLUMN_MAP() \
}; *pcCols = sizeof(_rgColumns)/sizeof(ATLCOLUMNINFO); return _rgColumns;}

// Implementation Class
class CSimpleRow
{
public:
        typedef DBROWCOUNT KeyType;

        CSimpleRow(DBROWCOUNT iRowsetCur)
        {
                m_dwRef = 0;
                m_iRowset = iRowsetCur;
        }
        ~CSimpleRow()
        {
        }
        DWORD AddRefRow() { return CComObjectThreadModel::Increment((LPLONG)&m_dwRef); }
        DWORD ReleaseRow() { return CComObjectThreadModel::Decrement((LPLONG)&m_dwRef); }

        HRESULT Compare(CSimpleRow* pRow)
        {
                ATLASSERT(pRow != NULL);
                return (m_iRowset == pRow->m_iRowset) ? S_OK : S_FALSE;
        }

        KeyType m_iRowset;
        DWORD   m_dwRef;
};

// IRowsetImpl
template <class T, class RowsetInterface,
                  class RowClass = CSimpleRow,
                  class MapClass = CSimpleMap < RowClass::KeyType, RowClass* > >
class ATL_NO_VTABLE IRowsetImpl : public RowsetInterface
{
public:
        typedef RowClass _HRowClass;
        IRowsetImpl()
        {
                m_iRowset = 0;
                m_bCanScrollBack = false;
                m_bCanFetchBack = false;
                m_bReset = true;
        }
        ~IRowsetImpl()
        {
                for (int i = 0; i < m_rgRowHandles.GetSize(); i++)
                        delete (m_rgRowHandles.GetValueAt(i));
        }
        HRESULT RefRows(DBCOUNTITEM cRows, const HROW rghRows[], ULONG rgRefCounts[],
                                        DBROWSTATUS rgRowStatus[], BOOL bAdd)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetImpl::AddRefRows\n");
                if (cRows == 0)
                        return S_OK;
                if (rghRows == NULL)
                        return E_INVALIDARG;
                T::ObjectLock cab((T*)this);
                BOOL bSuccess1 = FALSE;
                BOOL bFailed1 = FALSE;
                DBROWSTATUS rs;
                DWORD dwRef;
                for (ULONG iRow = 0; iRow < cRows; iRow++)
                {
                        HROW hRowCur = rghRows[iRow];
                        RowClass* pRow = m_rgRowHandles.Lookup((RowClass::KeyType)hRowCur);
                        if (pRow == NULL)
                        {
                                ATLTRACE2(atlTraceDBProvider, 0, "Could not find HANDLE %x in list\n");
                                rs = DBROWSTATUS_E_INVALID;
                                dwRef = 0;
                                bFailed1 = TRUE;
                        }
                        else
                        {
                                if (bAdd)
                                        dwRef = pRow->AddRefRow();
                                else
                                {
                                        dwRef = pRow->ReleaseRow();
                                        if (dwRef == 0)
                                        {
                                                delete pRow;
                                                m_rgRowHandles.Remove((RowClass::KeyType)hRowCur);
                                        }
                                }
                                bSuccess1 = TRUE;
                                rs = DBROWSTATUS_S_OK;
                        }
                        if (rgRefCounts)
                                rgRefCounts[iRow] = dwRef;
                        if (rgRowStatus != NULL)
                                rgRowStatus[iRow] = rs;
                }
                if (!bSuccess1 && !bFailed1)
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "IRowsetImpl::RefRows Unexpected state\n");
                        return E_FAIL;
                }
                HRESULT hr = S_OK;
                if (bSuccess1 && bFailed1)
                        hr = DB_S_ERRORSOCCURRED;
                if (!bSuccess1 && bFailed1)
                        hr = DB_E_ERRORSOCCURRED;
                return hr;
        }

        STDMETHOD(AddRefRows)(DBCOUNTITEM cRows,
                                                  const HROW rghRows[],
                                                  DBREFCOUNT rgRefCounts[],
                                                  DBROWSTATUS rgRowStatus[])
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetImpl::AddRefRows\n");
                if (cRows == 0)
                        return S_OK;
                return RefRows(cRows, rghRows, rgRefCounts, rgRowStatus, TRUE);
        }
        virtual DBSTATUS GetDBStatus(RowClass* , ATLCOLUMNINFO*)
        {
                return DBSTATUS_S_OK;
        }
        OUT_OF_LINE HRESULT GetDataHelper(HACCESSOR hAccessor,
                                                                          ATLCOLUMNINFO*& rpInfo,
                                                                          void** ppBinding,
                                                                          void*& rpSrcData,
                                                                          DBORDINAL& rcCols,
                                                                          CComPtr<IDataConvert>& rspConvert,
                                                                          RowClass* pRow)
        {
                ATLASSERT(ppBinding != NULL);
                T* pT = (T*) this;
                *ppBinding = (void*)pT->m_rgBindings.Lookup((int)hAccessor);
                if (*ppBinding == NULL)
                        return DB_E_BADACCESSORHANDLE;
                rpSrcData = (void*)&(pT->m_rgRowData[(int)(INT_PTR)(pRow->m_iRowset)]);
                rpInfo = T::GetColumnInfo((T*)this, &rcCols);
                rspConvert = pT->m_spConvert;
                return S_OK;

        }
        STDMETHOD(GetData)(HROW hRow,
                                           HACCESSOR hAccessor,
                                           void *pDstData)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetImpl::GetData\n");
                if (pDstData == NULL)
                        return E_INVALIDARG;
                HRESULT hr = S_OK;
                RowClass* pRow = (RowClass*)hRow;
                if (hRow == NULL || (pRow = m_rgRowHandles.Lookup((RowClass::KeyType)hRow)) == NULL)
                        return DB_E_BADROWHANDLE;
                T::_BindType* pBinding;
                void* pSrcData;
                DBORDINAL cCols;
                ATLCOLUMNINFO* pColInfo;
                CComPtr<IDataConvert> spConvert;
                hr = GetDataHelper(hAccessor, pColInfo, (void**)&pBinding, pSrcData, cCols, spConvert, pRow);
                if (FAILED(hr))
                        return hr;
                for (ULONG iBind =0; iBind < pBinding->cBindings; iBind++)
                {
                        DBBINDING* pBindCur = &(pBinding->pBindings[iBind]);
                        for (ULONG iColInfo = 0;
                                 iColInfo < cCols && pBindCur->iOrdinal != pColInfo[iColInfo].iOrdinal;
                                 iColInfo++);
                        if (iColInfo == cCols)
                                return DB_E_BADORDINAL;
                        ATLCOLUMNINFO* pColCur = &(pColInfo[iColInfo]);
                        // Ordinal found at iColInfo
                        BOOL bProvOwn = pBindCur->dwMemOwner == DBMEMOWNER_PROVIDEROWNED;
                        bProvOwn;
                        DBSTATUS dbStat = GetDBStatus(pRow, pColCur);

                        // If the provider's field is NULL, we can optimize this situation,
                        // set the fields to 0 and continue.
                        if (dbStat == DBSTATUS_S_ISNULL)
                        {
                                if (pBindCur->dwPart & DBPART_STATUS)
                                        *((DBSTATUS*)((BYTE*)(pDstData) + pBindCur->obStatus)) = dbStat;

                                if (pBindCur->dwPart & DBPART_LENGTH)
                                        *((ULONG*)((BYTE*)(pDstData) + pBindCur->obLength)) = 0;

                                if (pBindCur->dwPart & DBPART_VALUE)
                                        *((BYTE*)(pDstData) + pBindCur->obValue) = NULL;
                                continue;
                        }
                        ULONG cbDst = pBindCur->cbMaxLen;
                        ULONG cbCol;
                        BYTE* pSrcTemp;

                        if (bProvOwn && pColCur->wType == pBindCur->wType)
                        {
                                pSrcTemp = ((BYTE*)(pSrcData) + pColCur->cbOffset);
                        }
                        else
                        {
                                BYTE* pDstTemp = (BYTE*)pDstData + pBindCur->obValue;
                                switch (pColCur->wType)
                                {
                                case DBTYPE_STR:
                                        cbCol = lstrlenA((LPSTR)(((BYTE*)pSrcData) + pColCur->cbOffset));
                                        break;
                                case DBTYPE_WSTR:
                                case DBTYPE_BSTR:
                                        cbCol = lstrlenW((LPWSTR)(((BYTE*)pSrcData) + pColCur->cbOffset)) * sizeof(WCHAR);
                                        break;
                                default:
                                        cbCol = pColCur->ulColumnSize;
                                        break;
                                }
                                if (pBindCur->dwPart & DBPART_VALUE)
                                {
                                        hr = spConvert->DataConvert(pColCur->wType, pBindCur->wType,
                                                                                        cbCol, &cbDst, (BYTE*)(pSrcData) + pColCur->cbOffset,
                                                                                        pDstTemp, pBindCur->cbMaxLen, dbStat, &dbStat,
                                                                                        pBindCur->bPrecision, pBindCur->bScale,0);
                                }
                        }
                        if (pBindCur->dwPart & DBPART_LENGTH)
                                *((DBLENGTH*)((BYTE*)(pDstData) + pBindCur->obLength)) = cbDst;
                        if (pBindCur->dwPart & DBPART_STATUS)
                                *((DBSTATUS*)((BYTE*)(pDstData) + pBindCur->obStatus)) = dbStat;
                        if (FAILED(hr))
                                return hr;
                }
                return hr;
        }

        HRESULT CreateRow(DBROWOFFSET lRowsOffset, DBCOUNTITEM& cRowsObtained, HROW* rgRows)
        {
                RowClass* pRow = NULL;
                ATLASSERT(lRowsOffset >= 0);
                RowClass::KeyType key = lRowsOffset+1;
                ATLASSERT(key > 0);
                pRow = m_rgRowHandles.Lookup(key);
                if (pRow == NULL)
                {
                        ATLTRY(pRow = new RowClass(lRowsOffset))
                        if (pRow == NULL)
                                return E_OUTOFMEMORY;
                        if (!m_rgRowHandles.Add(key, pRow))
                                return E_OUTOFMEMORY;
                }
                pRow->AddRefRow();
                m_bReset = false;
                rgRows[cRowsObtained++] = (HROW)key;
                return S_OK;
        }

        STDMETHOD(GetNextRows)(HCHAPTER /*hReserved*/,
                                                   DBROWOFFSET lRowsOffset,
                                                   DBROWCOUNT cRows,
                                                   DBCOUNTITEM *pcRowsObtained,
                                                   HROW **prghRows)
        {
                DBROWOFFSET lTmpRows = lRowsOffset;
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetImpl::GetNextRows\n");
                if (pcRowsObtained != NULL)
                        *pcRowsObtained = 0;
                if (prghRows == NULL || pcRowsObtained == NULL)
                        return E_INVALIDARG;
                if (cRows == 0)
                        return S_OK;
                HRESULT hr = S_OK;
                T* pT = (T*) this;
                T::ObjectLock cab(pT);
                if (lRowsOffset < 0 && !m_bCanScrollBack)
                        return DB_E_CANTSCROLLBACKWARDS;
                if (cRows < 0  && !m_bCanFetchBack)
                        return DB_E_CANTFETCHBACKWARDS;

                // Calculate # of rows in set and the base fetch position.  If the rowset
                // is at its head position, then lRowOffset < 0 means moving from the BACK
                // of the rowset and not the front.
                DBROWCOUNT cRowsInSet = pT->m_rgRowData.GetSize();
                if (((lRowsOffset == LONG_MIN) && (cRowsInSet != LONG_MIN))
                        || (abs((int)(INT_PTR)lRowsOffset)) > cRowsInSet ||
                        (abs((int)(INT_PTR)lRowsOffset) == cRowsInSet && lRowsOffset < 0 && cRows < 0) ||
                        (abs((int)(INT_PTR)lRowsOffset) == cRowsInSet && lRowsOffset > 0 && cRows > 0))
                        return DB_S_ENDOFROWSET;

                // In the case where the user is moving backwards after moving forwards,
                // we do not wrap around to the end of the rowset.
                if ((m_iRowset == 0 && !m_bReset && cRows < 0) ||
                        (((LONG)m_iRowset + lRowsOffset) > cRowsInSet) ||
                        (m_iRowset == (DWORD)cRowsInSet && lRowsOffset >= 0 && cRows > 0))
                        return DB_S_ENDOFROWSET;

                // Note, if m_bReset, m_iRowset must be 0
                if (lRowsOffset < 0 && m_bReset)
                {
                        ATLASSERT(m_iRowset == 0);
                        m_iRowset = cRowsInSet;
                }

                int iStepSize = cRows >= 0 ? 1 : -1;

                // If cRows == LONG_MIN, we can't use ABS on it.  Therefore, we reset it
                // to a value just greater than cRowsInSet
                if (cRows == LONG_MIN && cRowsInSet != LONG_MIN)
                        cRows = cRowsInSet + 2; // set the value to something we can deal with
                else
                        cRows = abs((int)(INT_PTR)cRows);

                if (iStepSize < 0 && m_iRowset == 0 && m_bReset && lRowsOffset <= 0)
                        m_iRowset = cRowsInSet;

                lRowsOffset += m_iRowset;

                *pcRowsObtained = 0;
                CAutoMemRelease<HROW, CComFree< HROW > > amr;
                if (*prghRows == NULL)
                {
                        DBROWCOUNT cHandlesToAlloc = (cRows > cRowsInSet) ? cRowsInSet : cRows;
                        if (iStepSize == 1 && (cRowsInSet - lRowsOffset) < cHandlesToAlloc)
                                cHandlesToAlloc = cRowsInSet - lRowsOffset;
                        if (iStepSize == -1 && lRowsOffset < cHandlesToAlloc)
                                cHandlesToAlloc = lRowsOffset;
                        *prghRows = (HROW*)CoTaskMemAlloc((cHandlesToAlloc) * sizeof(HROW*));
                        amr.Attach(*prghRows);
                }
                if (*prghRows == NULL)
                        return E_OUTOFMEMORY;
                while ((lRowsOffset >= 0 && cRows != 0) &&
                        ((lRowsOffset < cRowsInSet) || (lRowsOffset <= cRowsInSet && iStepSize < 0)))
                {
                        // cRows > cRowsInSet && iStepSize < 0
                        if (lRowsOffset == 0 && cRows > 0 && iStepSize < 0)
                                break;

                        // in the case where we have iStepSize < 0, move the row back
                        // further because we want the previous row
                        DBROWOFFSET lRow = lRowsOffset;
                        if ((lRowsOffset == 0) && (lTmpRows == 0) && (iStepSize < 0))
                                lRow = cRowsInSet;

                        if (iStepSize < 0)
                                lRow += iStepSize;

                        hr = pT->CreateRow(lRow, *pcRowsObtained, *prghRows);
                        if (FAILED(hr))
                        {
                                RefRows(*pcRowsObtained, *prghRows, NULL, NULL, FALSE);
                                for (ULONG iRowDel = 0; iRowDel < *pcRowsObtained; iRowDel++)
                                        *prghRows[iRowDel] = NULL;
                                *pcRowsObtained = 0;
                                return hr;
                        }
                        cRows--;
                        lRowsOffset += iStepSize;
                }

                if ((lRowsOffset >= cRowsInSet && cRows) || (lRowsOffset < 0 && cRows)  ||
                        (lRowsOffset == 0 && cRows > 0 && iStepSize < 0))
                        hr = DB_S_ENDOFROWSET;
                m_iRowset = lRowsOffset;
                if (SUCCEEDED(hr))
                        amr.Detach();
                return hr;
        }

        STDMETHOD(ReleaseRows)(DBCOUNTITEM cRows,
                                                   const HROW rghRows[],
                                                   DBROWOPTIONS rgRowOptions[],
                                                   DBREFCOUNT rgRefCounts[],
                                                   DBROWSTATUS rgRowStatus[])
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetImpl::ReleaseRows\n");
                if (cRows == 0)
                        return S_OK;
                rgRowOptions;
                return RefRows(cRows, rghRows, rgRefCounts, rgRowStatus, FALSE);
        }

        STDMETHOD(RestartPosition)(HCHAPTER /*hReserved*/)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetImpl::RestartPosition\n");
                m_iRowset = 0;
                m_bReset = true;
                return S_OK;
        }

        MapClass  m_rgRowHandles;
        DBCOUNTITEM     m_iRowset; // cursor
        unsigned  m_bCanScrollBack:1;
        unsigned  m_bCanFetchBack:1;
        unsigned  m_bReset:1;
};

///////////////////////////////////////////////////////////////////////////
// IRowsetIdentityImpl
template <class T, class RowClass = CSimpleRow>
class ATL_NO_VTABLE IRowsetIdentityImpl : public IRowsetIdentity
{
public:
        STDMETHOD(IsSameRow)(HROW hThisRow, HROW hThatRow)
        {
                ATLTRACE2(atlTraceDBProvider, 0, _T("IRowsetIdentityImpl::IsSameRow"));
                T* pT = (T*)this;

                // Validate row handles
                RowClass* pRow1 = pT->m_rgRowHandles.Lookup((RowClass::KeyType)hThisRow);
                RowClass* pRow2 = pT->m_rgRowHandles.Lookup((RowClass::KeyType)hThatRow);

                if (pRow1 == NULL || pRow2 == NULL)
                        return DB_E_BADROWHANDLE;

                return pRow1->Compare(pRow2);
        };
};

template <class T>
class ATL_NO_VTABLE IInternalConnectionImpl : public IInternalConnection
{
public:
        STDMETHOD(AddConnection)()
        {
                T* pT = (T*)this;
                T::_ThreadModel::Increment(&pT->m_cSessionsOpen);
                return S_OK;
        }
        STDMETHOD(ReleaseConnection)()
        {
                T* pT = (T*)this;
                T::_ThreadModel::Decrement(&pT->m_cSessionsOpen);
                return S_OK;
        }
};

template <class T>
class ATL_NO_VTABLE IObjectWithSiteSessionImpl : public IObjectWithSiteImpl< T >
{
public:

        ~IObjectWithSiteSessionImpl()
        {
                CComPtr<IInternalConnection> pConn;
                if (m_spUnkSite != NULL)
                {
                        if (SUCCEEDED(m_spUnkSite->QueryInterface(IID_IInternalConnection, (void**)&pConn)))
                                pConn->ReleaseConnection();
                }
        }
        STDMETHOD(SetSite)(IUnknown* pCreator)
        {
                HRESULT hr = S_OK;
                T* pT = (T*)this;
                pT->Lock();
                m_spUnkSite = pCreator;
                pT->Unlock();
                CComPtr<IInternalConnection> pConn;
                if (pCreator != NULL)
                {
                        hr = pCreator->QueryInterface(IID_IInternalConnection, (void**)&pConn);
                        if (SUCCEEDED(hr))
                                hr = pConn->AddConnection();
                }
                return hr;
        }
};

template <class T>
class ATL_NO_VTABLE IRowsetCreatorImpl : public IObjectWithSiteImpl< T >
{
public:

        STDMETHOD(SetSite)(IUnknown* pCreator)
        {
                T* pT = (T*)this;
                HRESULT hr = S_OK;
                pT->Lock();
                m_spUnkSite = pCreator;
                pT->Unlock();
                CComVariant varPropScroll, varPropFetch;
                HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANSCROLLBACKWARDS, &varPropScroll);
                if (SUCCEEDED(hrProps))
                        pT->m_bCanScrollBack = varPropScroll.boolVal == VARIANT_TRUE;
                hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANFETCHBACKWARDS, &varPropFetch);
                if (SUCCEEDED(hrProps))
                        pT->m_bCanFetchBack = (varPropFetch.boolVal == VARIANT_TRUE);
                return hr;
        }

};

// IRowsetInfoImpl
template <class T, class PropClass = T>
class ATL_NO_VTABLE IRowsetInfoImpl :
        public IRowsetInfo,
        public CUtlProps<PropClass>
{
public:
        static UPROPSET* _GetPropSet(ULONG* pNumPropSets, ULONG* pcElemPerSupported, UPROPSET* pSet = NULL, GUID* pguidSet = (GUID*)&(GUID_NULL))
        {
                return PropClass::_GetPropSet(pNumPropSets, pcElemPerSupported, pSet, pguidSet);
        }
        STDMETHOD(GetProperties)(const ULONG cPropertyIDSets,
                                                         const DBPROPIDSET rgPropertyIDSets[],
                                                         ULONG *pcPropertySets,
                                                         DBPROPSET **prgPropertySets)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetInfoImpl::GetProperties\n");
                HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
                const GUID* ppGuid[1];
                ppGuid[0] = &DBPROPSET_ROWSET;
                if(SUCCEEDED(hr))
                        return CUtlProps<PropClass>::GetProperties(cPropertyIDSets,
                                        rgPropertyIDSets, pcPropertySets, prgPropertySets,
                                        1, ppGuid);
                else
                        return hr;
        }

        OUT_OF_LINE ATLCOLUMNINFO* InternalGetColumnInfo(DBORDINAL* pcCols)
        {
                return T::GetColumnInfo((T*)this, pcCols);
        }

        STDMETHOD(GetReferencedRowset)(DBORDINAL iOrdinal,
                                                                   REFIID riid,
                                                                   IUnknown **ppReferencedRowset)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetInfoImpl::GetReferencedRowset\n");
                DBORDINAL cCols=0;

                // Check Arguments
                if( ppReferencedRowset == NULL )
                {
                        ATLTRACE2(atlTraceDBProvider, 0, "IRowsetInfoImpl::GetReferencedRowset : Error NULL IUnk output Param\n");
                        return E_INVALIDARG;
                }
                *ppReferencedRowset = NULL;

                // Check to see if column in question is a bookmark
                ATLCOLUMNINFO* pColInfo = InternalGetColumnInfo(&cCols);

                for (ULONG iColInfo = 0;
                         iColInfo < cCols && iOrdinal != pColInfo[iColInfo].iOrdinal;
                         iColInfo++);
                if (iColInfo == cCols)
                        return DB_E_BADORDINAL;
                ATLCOLUMNINFO* pColCur = &(pColInfo[iColInfo]);

                if ((pColCur->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) == 0)
                        return DB_E_NOTAREFERENCECOLUMN;

                // Query for requested interface
                return QueryInterface(riid, (void**)ppReferencedRowset);
        }

        STDMETHOD(GetSpecification)(REFIID riid,
                                                                IUnknown **ppSpecification)
        {
                ATLTRACE2(atlTraceDBProvider, 0, "IRowsetInfoImpl::GetSpecification\n");
                if (ppSpecification == NULL)
                        return E_INVALIDARG;
                T* pT = (T*) this;
                T::ObjectLock cab(pT);
                ATLASSERT(pT->m_spUnkSite != NULL);
                return pT->m_spUnkSite->QueryInterface(riid, (void**)ppSpecification);
        }
};


template <class T, class Storage, class CreatorClass,
                  class ArrayType = CSimpleArray<Storage>,
                  class RowClass = CSimpleRow,
                  class RowsetInterface = IRowsetImpl < T, IRowset, RowClass> >
class CRowsetImpl :
	public CComObjectRootEx<typename CreatorClass::_ThreadModel>,
	public IAccessorImpl<T>,
	public IRowsetIdentityImpl<T, RowClass>,
	public IRowsetCreatorImpl<T>,
	public IRowsetInfoImpl<T, typename CreatorClass::_PropClass>,
	public IColumnsInfoImpl<T>,
	public IConvertTypeImpl<T>,
	public RowsetInterface
{
public:

        typedef CreatorClass _RowsetCreatorClass;
        typedef ArrayType _RowsetArrayType;
        typedef CRowsetImpl< T, Storage, CreatorClass, ArrayType, RowClass, RowsetInterface> _RowsetBaseClass;

BEGIN_COM_MAP(CRowsetImpl)
        COM_INTERFACE_ENTRY(IAccessor)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IRowsetInfo)
        COM_INTERFACE_ENTRY(IColumnsInfo)
        COM_INTERFACE_ENTRY(IConvertType)
        COM_INTERFACE_ENTRY(IRowsetIdentity)
        COM_INTERFACE_ENTRY(IRowset)
END_COM_MAP()

        HRESULT FinalConstruct()
        {
                HRESULT hr = IAccessorImpl<T>::FinalConstruct();
                if (FAILED(hr))
                        return hr;
                return CConvertHelper::FinalConstruct();
        }

        HRESULT NameFromDBID(DBID* pDBID, CComBSTR& bstr, bool bIndex)
        {

                if (pDBID->uName.pwszName != NULL)
                {
                        bstr = pDBID->uName.pwszName;
                        if (m_strCommandText == (BSTR)NULL)
                                return E_OUTOFMEMORY;
                        return S_OK;
                }

                return (bIndex) ? DB_E_NOINDEX : DB_E_NOTABLE;
        }

        HRESULT GetCommandFromID(DBID* pTableID, DBID* pIndexID)
        {
                USES_CONVERSION;
                HRESULT hr;

                if (pTableID == NULL && pIndexID == NULL)
                        return E_INVALIDARG;

                if (pTableID != NULL && pTableID->eKind == DBKIND_NAME)
                {
                        hr = NameFromDBID(pTableID, m_strCommandText, true);
                        if (FAILED(hr))
                                return hr;
                        if (pIndexID != NULL)
                        {
                                if (pIndexID->eKind == DBKIND_NAME)
                                {
                                        hr = NameFromDBID(pIndexID, m_strIndexText, false);
                                        if (FAILED(hr))
                                        {
                                                m_strCommandText.Empty();
                                                return hr;
                                        }
                                }
                                else
                                {
                                        m_strCommandText.Empty();
                                        return DB_E_NOINDEX;
                                }
                        }
                        return S_OK;
                }
                if (pIndexID != NULL && pIndexID->eKind == DBKIND_NAME)
                        return NameFromDBID(pIndexID, m_strIndexText, false);

                return S_OK;
        }

        HRESULT ValidateCommandID(DBID* pTableID, DBID* pIndexID)
        {
                HRESULT hr = S_OK;

                if (pTableID != NULL)
                {
                        hr = CUtlProps<T>::IsValidDBID(pTableID);

                        if (hr != S_OK)
                                return hr;

                        // Check for a NULL TABLE ID (where its a valid pointer but NULL)
                        if ((pTableID->eKind == DBKIND_GUID_NAME ||
                                pTableID->eKind == DBKIND_NAME ||
                                pTableID->eKind == DBKIND_PGUID_NAME)
                                && pTableID->uName.pwszName == NULL)
                                return DB_E_NOTABLE;
                }

                if (pIndexID != NULL)
                        hr = CUtlProps<T>::IsValidDBID(pIndexID);

                return hr;
        }

        HRESULT SetCommandText(DBID* pTableID, DBID* pIndexID)
        {
                T* pT = (T*)this;
                HRESULT hr = pT->ValidateCommandID(pTableID, pIndexID);
                if (FAILED(hr))
                        return hr;
                hr = pT->GetCommandFromID(pTableID, pIndexID);
                return hr;
        }
        void FinalRelease()
        {
                m_rgRowData.RemoveAll();
        }

        static ATLCOLUMNINFO* GetColumnInfo(T* pv, DBORDINAL* pcCols)
        {
                return Storage::GetColumnInfo(pv,pcCols);
        }


        CComBSTR m_strCommandText;
        CComBSTR m_strIndexText;
        ArrayType m_rgRowData;
};

class CTABLESRow
{
public:

        WCHAR m_szCatalog[129];
        WCHAR m_szSchema[129];
        WCHAR m_szTable[129];
        WCHAR m_szType[129];
        WCHAR m_szDesc[129];
        GUID  m_guid;
        ULONG m_ulPropID;

        CTABLESRow()
        {
                m_szCatalog[0] = NULL;
                m_szSchema[0] = NULL;
                m_szTable[0] = NULL;
                m_szType[0] = NULL;
                m_szDesc[0] = NULL;
                m_guid = GUID_NULL;
                m_ulPropID = 0;
        }

BEGIN_PROVIDER_COLUMN_MAP(CTABLESRow)
        PROVIDER_COLUMN_ENTRY("TABLE_CATALOG", 1, m_szCatalog)
        PROVIDER_COLUMN_ENTRY("TABLE_SCHEMA", 2, m_szSchema)
        PROVIDER_COLUMN_ENTRY("TABLE_NAME", 3, m_szTable)
        PROVIDER_COLUMN_ENTRY("TABLE_TYPE", 4, m_szType)
        PROVIDER_COLUMN_ENTRY("TABLE_GUID", 5, m_guid)
        PROVIDER_COLUMN_ENTRY("DESCRIPTION", 6, m_szDesc)
        PROVIDER_COLUMN_ENTRY("TABLE_PROPID", 7, m_ulPropID)
END_PROVIDER_COLUMN_MAP()

};


class CCOLUMNSRow
{
public:

        WCHAR   m_szTableCatalog[129];
        WCHAR   m_szTableSchema[129];
        WCHAR   m_szTableName[129];
        WCHAR   m_szColumnName[129];
        GUID    m_guidColumn;
        ULONG   m_ulColumnPropID;
        DBORDINAL   m_ulOrdinalPosition;
        VARIANT_BOOL    m_bColumnHasDefault;
        WCHAR   m_szColumnDefault[129];
        ULONG   m_ulColumnFlags;
        VARIANT_BOOL    m_bIsNullable;
        USHORT  m_nDataType;
        GUID    m_guidType;
        DBLENGTH m_ulCharMaxLength;
        ULONG   m_ulCharOctetLength;
        USHORT  m_nNumericPrecision;
        short   m_nNumericScale;
        ULONG   m_ulDateTimePrecision;
        WCHAR   m_szCharSetCatalog[129];
        WCHAR   m_szCharSetSchema[129];
        WCHAR   m_szCharSetName[129];
        WCHAR   m_szCollationCatalog[129];
        WCHAR   m_szCollationSchema[129];
        WCHAR   m_szCollationName[129];
        WCHAR   m_szDomainCatalog[129];
        WCHAR   m_szDomainSchema[129];
        WCHAR   m_szDomainName[129];
        WCHAR   m_szDescription[129];

        CCOLUMNSRow()
        {
                ClearMembers();
        }

        void ClearMembers()
        {
                m_szTableCatalog[0] = NULL;
                m_szTableSchema[0] = NULL;
                m_szTableName[0] = NULL;
                m_szColumnName[0] = NULL;
                m_guidColumn = GUID_NULL;
                m_ulColumnPropID = 0;
                m_ulOrdinalPosition = 0;
                m_bColumnHasDefault = VARIANT_FALSE;
                m_szColumnDefault[0] = NULL;
                m_ulColumnFlags = 0;
                m_bIsNullable = VARIANT_FALSE;
                m_nDataType = 0;
                m_guidType = GUID_NULL;
                m_ulCharMaxLength = 0;
                m_ulCharOctetLength = 0;
                m_nNumericPrecision = 0;
                m_nNumericScale = 0;
                m_ulDateTimePrecision = 0;
                m_szCharSetCatalog[0] = NULL;
                m_szCharSetSchema[0] = NULL;
                m_szCharSetName[0] = NULL;
                m_szCollationCatalog[0] = NULL;
                m_szCollationSchema[0] = NULL;
                m_szCollationName[0] = NULL;
                m_szDomainCatalog[0] = NULL;
                m_szDomainSchema[0] = NULL;
                m_szDomainName[0] = NULL;
                m_szDescription[0] = NULL;
        }


BEGIN_PROVIDER_COLUMN_MAP(CCOLUMNSRow)
        PROVIDER_COLUMN_ENTRY("TABLE_CATALOG", 1, m_szTableCatalog)
        PROVIDER_COLUMN_ENTRY("TABLE_SCHEMA", 2, m_szTableSchema)
        PROVIDER_COLUMN_ENTRY("TABLE_NAME", 3, m_szTableName)
        PROVIDER_COLUMN_ENTRY("COLUMN_NAME", 4, m_szColumnName)
        PROVIDER_COLUMN_ENTRY("COLUMN_GUID",5, m_guidColumn)
        PROVIDER_COLUMN_ENTRY("COLUMN_PROPID",6, m_ulColumnPropID)
        PROVIDER_COLUMN_ENTRY("ORDINAL_POSITION",7, m_ulOrdinalPosition)
        PROVIDER_COLUMN_ENTRY("COLUMN_HASDEFAULT",8, m_bColumnHasDefault)
        PROVIDER_COLUMN_ENTRY("COLUMN_DEFAULT",9, m_szColumnDefault)
        PROVIDER_COLUMN_ENTRY("COLUMN_FLAGS",10, m_ulColumnFlags)
        PROVIDER_COLUMN_ENTRY("IS_NULLABLE",11, m_bIsNullable)
        PROVIDER_COLUMN_ENTRY("DATA_TYPE",12, m_nDataType)
        PROVIDER_COLUMN_ENTRY("TYPE_GUID",13, m_guidType)
        PROVIDER_COLUMN_ENTRY("CHARACTER_MAXIMUM_LENGTH",14, m_ulCharMaxLength)
        PROVIDER_COLUMN_ENTRY("CHARACTER_OCTET_LENGTH",15, m_ulCharOctetLength)
        PROVIDER_COLUMN_ENTRY("NUMERIC_PRECISION",16, m_nNumericPrecision)
        PROVIDER_COLUMN_ENTRY("NUMERIC_SCALE",17, m_nNumericScale)
        PROVIDER_COLUMN_ENTRY("DATETIME_PRECISION",18, m_ulDateTimePrecision)
        PROVIDER_COLUMN_ENTRY("CHARACTER_SET_CATALOG", 19, m_szCharSetCatalog)
        PROVIDER_COLUMN_ENTRY("CHARACTER_SET_SCHEMA", 20, m_szCharSetSchema)
        PROVIDER_COLUMN_ENTRY("CHARACTER_SET_NAME", 21, m_szCharSetName)
        PROVIDER_COLUMN_ENTRY("COLLATION_CATALOG", 22, m_szCollationCatalog)
        PROVIDER_COLUMN_ENTRY("COLLATION_SCHEMA", 23, m_szCollationSchema)
        PROVIDER_COLUMN_ENTRY("COLLATION_NAME", 24, m_szCollationName)
        PROVIDER_COLUMN_ENTRY("DOMAIN_CATALOG", 25, m_szDomainCatalog)
        PROVIDER_COLUMN_ENTRY("DOMAIN_SCHEMA", 26, m_szDomainSchema)
        PROVIDER_COLUMN_ENTRY("DOMAIN_NAME", 27, m_szDomainName)
        PROVIDER_COLUMN_ENTRY("DESCRIPTION", 28, m_szDescription)
END_PROVIDER_COLUMN_MAP()
};

template <class ArrayClass>
HRESULT InitFromRowset(ArrayClass& rgData, DBID* pTableID, DBID* pIndexID, IUnknown* pSession, LONG* pcRowsAffected)
{
        CComQIPtr<IOpenRowset> spOpenRowset = pSession;
        if (spOpenRowset == NULL)
                return E_FAIL;
        CComPtr<IColumnsInfo> spColInfo;
        HRESULT hr = spOpenRowset->OpenRowset(NULL, pTableID, pIndexID, IID_IColumnsInfo, 0, NULL, (IUnknown**)&spColInfo);
        if (FAILED(hr))
                return hr;
        LPOLESTR szColumns = NULL;
        DBORDINAL cColumns = 0;
        DBCOLUMNINFO* pColInfo = NULL;
        hr = spColInfo->GetColumnInfo(&cColumns, &pColInfo, &szColumns);
        if (FAILED(hr))
                return hr;
        *pcRowsAffected = 0;
        for (ULONG iCol = 0; iCol < cColumns;  iCol++)
        {
                CCOLUMNSRow crData;
                DBCOLUMNINFO& rColCur = pColInfo[iCol];
                lstrcpynW(crData.m_szTableName, pTableID->uName.pwszName, SIZEOF_MEMBER(CCOLUMNSRow, m_szTableName));
                lstrcpynW(crData.m_szColumnName, rColCur.pwszName, SIZEOF_MEMBER(CCOLUMNSRow, m_szColumnName));
                lstrcpynW(crData.m_szDescription, rColCur.pwszName, SIZEOF_MEMBER(CCOLUMNSRow, m_szColumnName));
                GUID* pGuidCol = CDBIDOps::GetDBIDpGuid(rColCur.columnid);
                if (pGuidCol)
                        crData.m_guidColumn = *pGuidCol;
                else
                        crData.m_guidColumn = GUID_NULL;
                crData.m_ulColumnPropID = CDBIDOps::GetPropIDFromDBID(rColCur.columnid);
                crData.m_ulOrdinalPosition = rColCur.iOrdinal;
                crData.m_ulColumnFlags = rColCur.dwFlags;
                crData.m_bIsNullable = (rColCur.dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ? VARIANT_TRUE : VARIANT_FALSE;
                crData.m_nDataType = rColCur.wType;
                crData.m_ulCharMaxLength = rColCur.ulColumnSize;
                crData.m_nNumericPrecision = rColCur.bPrecision;
                crData.m_nNumericScale = rColCur.bScale;
                if (!rgData.Add(crData))
                {
                        CoTaskMemFree(pColInfo);
                        CoTaskMemFree(szColumns);
                        return E_OUTOFMEMORY;
                }
                (*pcRowsAffected)++;
        }

        CoTaskMemFree(pColInfo);
        CoTaskMemFree(szColumns);
        return S_OK;
}

class CPROVIDER_TYPERow
{
public:
// Attributes
        WCHAR           m_szName[129];
        USHORT          m_nType;
        ULONG           m_ulSize;
        WCHAR           m_szPrefix[129];
        WCHAR           m_szSuffix[129];
        WCHAR           m_szCreateParams[129];
        VARIANT_BOOL    m_bIsNullable;
        VARIANT_BOOL    m_bCaseSensitive;
        ULONG           m_bSearchable;
        VARIANT_BOOL    m_bUnsignedAttribute;
        VARIANT_BOOL    m_bFixedPrecScale;
        VARIANT_BOOL    m_bAutoUniqueValue;
        WCHAR           m_szLocalTypeName[129];
        short           m_nMinScale;
        short           m_nMaxScale;
        GUID            m_guidType;
        WCHAR           m_szTypeLib[129];
        WCHAR           m_szVersion[129];
        VARIANT_BOOL    m_bIsLong;
        VARIANT_BOOL    m_bBestMatch;
        VARIANT_BOOL        m_bIsFixedLength;

        CPROVIDER_TYPERow()
        {
                m_szName[0] = NULL;
                m_nType = 0;
                m_ulSize = 0;
                m_szPrefix[0] = NULL;
                m_szSuffix[0] = NULL;
                m_szCreateParams[0] = NULL;
                m_bIsNullable = VARIANT_FALSE;
                m_bCaseSensitive = VARIANT_FALSE;
                m_bSearchable = DB_UNSEARCHABLE;
                m_bUnsignedAttribute = VARIANT_FALSE;
                m_bFixedPrecScale = VARIANT_FALSE;
                m_bAutoUniqueValue = VARIANT_FALSE;
                m_szLocalTypeName[0] = NULL;
                m_nMinScale = 0;
                m_nMaxScale = 0;
                m_guidType = GUID_NULL;
                m_szTypeLib[0] = NULL;
                m_szVersion[0] = NULL;
                m_bIsLong = VARIANT_FALSE;
                m_bBestMatch = VARIANT_FALSE;
                m_bIsFixedLength = VARIANT_FALSE;
        }
// Binding Maps
BEGIN_PROVIDER_COLUMN_MAP(CPROVIDER_TYPERow)
        PROVIDER_COLUMN_ENTRY("TYPE_NAME", 1, m_szName)
        PROVIDER_COLUMN_ENTRY("DATA_TYPE", 2, m_nType)
        PROVIDER_COLUMN_ENTRY("COLUMN_SIZE", 3, m_ulSize)
        PROVIDER_COLUMN_ENTRY("LITERAL_PREFIX", 4, m_szPrefix)
        PROVIDER_COLUMN_ENTRY("LITERAL_SUFFIX", 5, m_szSuffix)
        PROVIDER_COLUMN_ENTRY("CREATE_PARAMS", 6, m_szCreateParams)
        PROVIDER_COLUMN_ENTRY("IS_NULLABLE", 7, m_bIsNullable)
        PROVIDER_COLUMN_ENTRY("CASE_SENSITIVE", 8, m_bCaseSensitive)
        PROVIDER_COLUMN_ENTRY("SEARCHABLE", 9, m_bSearchable)
        PROVIDER_COLUMN_ENTRY("UNSIGNED_ATTRIBUTE", 10, m_bUnsignedAttribute)
        PROVIDER_COLUMN_ENTRY("FIXED_PREC_SCALE", 11, m_bFixedPrecScale)
        PROVIDER_COLUMN_ENTRY("AUTO_UNIQUE_VALUE", 12, m_bAutoUniqueValue)
        PROVIDER_COLUMN_ENTRY("LOCAL_TYPE_NAME", 13, m_szLocalTypeName)
        PROVIDER_COLUMN_ENTRY("MINIMUM_SCALE", 14, m_nMinScale)
        PROVIDER_COLUMN_ENTRY("MAXIMUM_SCALE", 15, m_nMaxScale)
        PROVIDER_COLUMN_ENTRY("GUID", 16, m_guidType)
        PROVIDER_COLUMN_ENTRY("TYPELIB", 17, m_szTypeLib)
        PROVIDER_COLUMN_ENTRY("VERSION", 18, m_szVersion)
        PROVIDER_COLUMN_ENTRY("IS_LONG", 19, m_bIsLong)
        PROVIDER_COLUMN_ENTRY("BEST_MATCH", 20, m_bBestMatch)
        PROVIDER_COLUMN_ENTRY("IS_FIXEDLENGTH", 21, m_bIsFixedLength)
END_PROVIDER_COLUMN_MAP()
};


class CEnumRowsetImpl
{
public:

        WCHAR m_szSourcesName[256];
        WCHAR m_szSourcesParseName[256];
        WCHAR m_szSourcesDescription[256];
        unsigned short m_iType;
        VARIANT_BOOL m_bIsParent;

BEGIN_PROVIDER_COLUMN_MAP(CEnumRowsetImpl)
        PROVIDER_COLUMN_ENTRY("SOURCES_NAME", 1, m_szSourcesName)
        PROVIDER_COLUMN_ENTRY("SOURCES_PARSENAME", 2, m_szSourcesParseName)
        PROVIDER_COLUMN_ENTRY("SOURCES_DESCRIPTION", 3, m_szSourcesDescription)
        PROVIDER_COLUMN_ENTRY("SOURCES_TYPE", 4, m_iType)
        PROVIDER_COLUMN_ENTRY("SOURCES_ISPARENT", 5, m_bIsParent)
END_PROVIDER_COLUMN_MAP()

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlimpl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
        #error atlimpl.cpp requires atlbase.h to be included first
#endif

/////////////////////////////////////////////////////////////////////////////
// Minimize CRT
// Specify DllMain as EntryPoint
// Turn off exception handling
// Define _ATL_MIN_CRT
#ifdef _ATL_MIN_CRT
/////////////////////////////////////////////////////////////////////////////
// Startup Code

#if defined(_WINDLL) || defined(_USRDLL)

// Declare DllMain
extern "C" BOOL WINAPI DllMain(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved);

extern "C" BOOL WINAPI _DllMainCRTStartup(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved)
{
        return DllMain(hDllHandle, dwReason, lpReserved);
}

#else

// wWinMain is not defined in winbase.h.
extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')


#ifdef _UNICODE
extern "C" void wWinMainCRTStartup()
#else // _UNICODE
extern "C" void WinMainCRTStartup()
#endif // _UNICODE
{
        LPTSTR lpszCommandLine = ::GetCommandLine();
        if(lpszCommandLine == NULL)
                ::ExitProcess((UINT)-1);

        // Skip past program name (first token in command line).
        // Check for and handle quoted program name.
        if(*lpszCommandLine == DQUOTECHAR)
        {
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                do
                {
                        lpszCommandLine = ::CharNext(lpszCommandLine);
                }
                while((*lpszCommandLine != DQUOTECHAR) && (*lpszCommandLine != _T('\0')));

                // If we stopped on a double-quote (usual case), skip over it.
                if(*lpszCommandLine == DQUOTECHAR)
                        lpszCommandLine = ::CharNext(lpszCommandLine);
        }
        else
        {
                while(*lpszCommandLine > SPACECHAR)
                        lpszCommandLine = ::CharNext(lpszCommandLine);
        }

        // Skip past any white space preceeding the second token.
        while(*lpszCommandLine && (*lpszCommandLine <= SPACECHAR))
                lpszCommandLine = ::CharNext(lpszCommandLine);

        STARTUPINFO StartupInfo;
        StartupInfo.dwFlags = 0;
        ::GetStartupInfo(&StartupInfo);

        int nRet = _tWinMain(::GetModuleHandle(NULL), NULL, lpszCommandLine,
                (StartupInfo.dwFlags & STARTF_USESHOWWINDOW) ?
                StartupInfo.wShowWindow : SW_SHOWDEFAULT);

        ::ExitProcess((UINT)nRet);
}

#endif // defined(_WINDLL) | defined(_USRDLL)

/////////////////////////////////////////////////////////////////////////////
// Heap Allocation

#ifndef _DEBUG

#ifndef _MERGE_PROXYSTUB
//rpcproxy.h does the same thing as this
int __cdecl _purecall()
{
        ::MessageBox(NULL, 
                _T("Runtime Error!\n\nR6025\n- pure virtual function call\n"), 
                _T("Microsoft Visual C+ ATL"), 
                MB_OK | MB_ICONERROR);
        ::ExitProcess(255);
        return 0;
}
#endif

#if !defined(_M_ALPHA) && !defined(_M_PPC)
//RISC always initializes floating point and always defines _fltused
extern "C" const int _fltused = 0;
#endif

static const int nExtraAlloc = 8;
static const int nOffsetBlock = nExtraAlloc/sizeof(HANDLE);

void* __cdecl malloc(size_t n)
{
        void* pv = NULL;
#ifndef _ATL_NO_MP_HEAP
        if (_Module.m_phHeaps == NULL)
#endif
        {
                pv = (HANDLE*) HeapAlloc(_Module.m_hHeap, 0, n);
        }
#ifndef _ATL_NO_MP_HEAP
        else
        {
                // overallocate to remember the heap handle
                int nHeap = _Module.m_nHeap++;
                HANDLE hHeap = _Module.m_phHeaps[nHeap & _Module.m_dwHeaps];
                HANDLE* pBlock = (HANDLE*) HeapAlloc(hHeap, 0, n + nExtraAlloc);
                if (pBlock != NULL)
                {
                        *pBlock = hHeap;
                        pv = (void*)(pBlock + nOffsetBlock);
                }
                else
                        pv = NULL;
        }
#endif
        return pv;
}

void* __cdecl calloc(size_t n, size_t s)
{
        return malloc(n*s);
}

#pragma prefast(push)
#pragma prefast(suppress:308, "prefast bug 538")
void* __cdecl realloc(void* p, size_t n)
{
        if (p == NULL)
                return malloc(n);
#ifndef _ATL_NO_MP_HEAP
        if (_Module.m_phHeaps == NULL)
#endif
                return HeapReAlloc(_Module.m_hHeap, 0, p, n);
#ifndef _ATL_NO_MP_HEAP
        else
        {
                HANDLE* pHeap = ((HANDLE*)p)-nOffsetBlock;
                pHeap = (HANDLE*) HeapReAlloc(*pHeap, 0, pHeap, n + nExtraAlloc);
                return (pHeap != NULL) ? pHeap + nOffsetBlock : NULL;
        }
#endif
}
#pragma prefast(pop)

void __cdecl free(void* p)
{
        if (p == NULL)
                return;
#ifndef _ATL_NO_MP_HEAP
        if (_Module.m_phHeaps == NULL)
#endif
                HeapFree(_Module.m_hHeap, 0, p);
#ifndef _ATL_NO_MP_HEAP
        else
        {
                HANDLE* pHeap = ((HANDLE*)p)-nOffsetBlock;
                HeapFree(*pHeap, 0, pHeap);
        }
#endif
}

void* __cdecl operator new(size_t n)
{
        return malloc(n);
}

void __cdecl operator delete(void* p)
{
        free(p);
}

#endif  //_DEBUG

#endif //_ATL_MIN_CRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlhost.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.


#ifndef __ATLHOST_H__
#define __ATLHOST_H__

#include <urlmon.h>
#include <mshtml.h>
#include <mshtmhst.h>
#include <exdisp.h>

#ifndef _ATL_AXHOST
#define _ATL_AXHOST
#endif //_ATL_AXHOST

#include <atlwin.h>

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLCOM_H__
        #error atlhost.h requires atlcom.h to be included first
#endif

#ifdef _ATL_NO_HOSTING
        #error atlhost.h requires Hosting support (_ATL_NO_HOSTING is defined)
#endif //_ATL_NO_HOSTING

namespace ATL
{
//AtlAxWinTerm is not exported
inline BOOL AtlAxWinTerm()
{
#ifndef _ATL_DLL //don't unregister DLL's version
        UnregisterClass(CAxWindow::GetWndClassName(), _Module.GetModuleInstance());
#endif
        return TRUE;
}


// Define this to host SHDOCVW rather than MSHTML
#define SHDOCVW

UINT __declspec(selectany) WM_ATLGETHOST = 0;
UINT __declspec(selectany) WM_ATLGETCONTROL = 0;

//EXTERN_C const IID IID_IHTMLDocument2 = {0x332C4425,0x26CB,0x11D0,{0xB4,0x83,0x00,0xC0,0x4F,0xD9,0x01,0x19}};

typedef HRESULT (__stdcall *typeMkParseDisplayName)(IBindCtx*, LPCWSTR , ULONG*, LPMONIKER*);

static HRESULT CreateNormalizedObject(LPCOLESTR lpszTricsData, REFIID riid, void** ppvObj, bool& bWasHTML)
{
        ATLASSERT(ppvObj);

        CLSID clsid;
        HRESULT hr = E_FAIL;
        BOOL bInited = FALSE;

        bWasHTML = false;

        *ppvObj = NULL;

        if (lpszTricsData == NULL || lpszTricsData[0] == 0)
                return S_OK;

        // Is it HTML ?
        USES_CONVERSION;
        if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
                (lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
                (lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
                (lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
                (lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
                (lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
                (lpszTricsData[6] == OLECHAR(':')))
        {
                // It's HTML, so let's create mshtml
                hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_SERVER, riid, ppvObj);
                bWasHTML = true;
        }
        if (FAILED(hr))
        {
                // Can't be clsid, or progid if length is grater than 255
                if (ocslen(lpszTricsData) < 255)
                {
                        if (lpszTricsData[0] == '{') // Is it a CLSID?
                                hr = CLSIDFromString((LPOLESTR)lpszTricsData, &clsid);
                        else
                                hr = CLSIDFromProgID((LPOLESTR)lpszTricsData, &clsid); // How about a ProgID?
                        if (SUCCEEDED(hr))        // Aha, it was one of those two
                                hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER, riid, ppvObj);
                }
                if (FAILED(hr))
                {
                        // Last guess - it must be either a URL so let's create shdocvw
                        hr = CoCreateInstance(CLSID_WebBrowser, NULL, CLSCTX_SERVER, riid, ppvObj);
                        bWasHTML = true;
                }
        }

        if (SUCCEEDED(hr) && bInited)
                hr = S_FALSE;

        return hr;
}


class ATL_NO_VTABLE CAxFrameWindow : 
        public CComObjectRootEx<CComObjectThreadModel>,
        public CWindowImpl<CAxFrameWindow>,
        public IOleInPlaceFrame
{
public:
        CAxFrameWindow()
        {
        }
        void FinalRelease()
        {
                m_spActiveObject.Release();
                if (m_hWnd)
                        DestroyWindow();
        }

        DECLARE_POLY_AGGREGATABLE(CAxFrameWindow)

        BEGIN_COM_MAP(CAxFrameWindow)
                COM_INTERFACE_ENTRY(IOleInPlaceFrame)
                COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
                COM_INTERFACE_ENTRY(IOleWindow)
        END_COM_MAP()

        DECLARE_EMPTY_MSG_MAP()

// IOleWindow
        STDMETHOD(GetWindow)(HWND* phwnd)
        {
                if (m_hWnd == NULL)
                {
                        RECT rcPos = { CW_USEDEFAULT, 0, 0, 0 };
                        Create(NULL, rcPos, _T("AXWIN Frame Window"), WS_OVERLAPPEDWINDOW, 0, (UINT)NULL);
                }
                *phwnd = m_hWnd;
                return S_OK;
        }
        STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
        {
                return S_OK;
        }

// IOleInPlaceUIWindow
        STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
        {
                return S_OK;
        }

        STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
        {
                return INPLACE_E_NOTOOLSPACE;
        }

        STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
        {
                return S_OK;
        }

        STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/)
        {
                m_spActiveObject = pActiveObject;
                return S_OK;
        }

// IOleInPlaceFrameWindow
        STDMETHOD(InsertMenus)(HMENU /*hmenuShared*/, LPOLEMENUGROUPWIDTHS /*lpMenuWidths*/)
        {
                return S_OK;
        }

        STDMETHOD(SetMenu)(HMENU /*hmenuShared*/, HOLEMENU /*holemenu*/, HWND /*hwndActiveObject*/)
        {
                return S_OK;
        }

        STDMETHOD(RemoveMenus)(HMENU /*hmenuShared*/)
        {
                return S_OK;
        }

        STDMETHOD(SetStatusText)(LPCOLESTR /*pszStatusText*/)
        {
                return S_OK;
        }

        STDMETHOD(EnableModeless)(BOOL /*fEnable*/)
        {
                return S_OK;
        }

        STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, WORD /*wID*/)
        {
                return S_FALSE;
        }

        CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
};


class ATL_NO_VTABLE CAxUIWindow : 
        public CComObjectRootEx<CComObjectThreadModel>,
        public CWindowImpl<CAxUIWindow>,
        public IOleInPlaceUIWindow
{
public:
        CAxUIWindow()
        {
        }

        void FinalRelease()
        {
                m_spActiveObject.Release();
                if (m_hWnd)
                        DestroyWindow();
        }

        DECLARE_POLY_AGGREGATABLE(CAxUIWindow)

        BEGIN_COM_MAP(CAxUIWindow)
                COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
                COM_INTERFACE_ENTRY(IOleWindow)
        END_COM_MAP()

        DECLARE_EMPTY_MSG_MAP()

// IOleWindow
        STDMETHOD(GetWindow)(HWND* phwnd)
        {
                if (m_hWnd == NULL)
                {
                        RECT rcPos = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
                        Create(NULL, rcPos, _T("AXWIN UI Window"), WS_OVERLAPPEDWINDOW, 0, (UINT)NULL);
                }
                *phwnd = m_hWnd;
                return S_OK;
        }

        STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
        {
                return S_OK;
        }

// IOleInPlaceUIWindow
        STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
        {
                return S_OK;
        }

        STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
        {
                return INPLACE_E_NOTOOLSPACE;
        }

        STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
        {
                return S_OK;
        }

        STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/)
        {
                m_spActiveObject = pActiveObject;
                return S_OK;
        }

        CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
};


/////////////////////////////////////////////////////////////////////////////
// CAxHostWindow
// This class is not cocreateable

class ATL_NO_VTABLE CAxHostWindow : 
                public CComCoClass<CAxHostWindow , &CLSID_NULL>,
                public CComObjectRootEx<CComSingleThreadModel>,
                public CWindowImpl<CAxHostWindow>,
                public IAxWinHostWindow,
                public IOleClientSite,
                public IOleInPlaceSiteWindowless,
                public IOleControlSite,
                public IOleContainer,
                public IObjectWithSiteImpl<CAxHostWindow>,
                public IServiceProvider,
                public IAdviseSink,
#ifndef _ATL_NO_DOCHOSTUIHANDLER
                public IDocHostUIHandler,
#endif
                public IDispatchImpl<IAxWinAmbientDispatch, &IID_IAxWinAmbientDispatch, &LIBID_ATLLib>
{
public:
// ctor/dtor
        CAxHostWindow()
        {
                m_bInPlaceActive = FALSE;
                m_bUIActive = FALSE;
                m_bMDIApp = FALSE;
                m_bWindowless = FALSE;
                m_bCapture = FALSE;
                m_bHaveFocus = FALSE;

                // Initialize ambient properties
                m_bCanWindowlessActivate = TRUE;
                m_bUserMode = TRUE;
                m_bDisplayAsDefault = FALSE;
                m_clrBackground = NULL;
                m_clrForeground = GetSysColor(COLOR_WINDOWTEXT);
                m_lcidLocaleID = LOCALE_USER_DEFAULT;
                m_bMessageReflect = true;

                m_bReleaseAll = FALSE;

                m_bSubclassed = FALSE;

                m_dwAdviseSink = 0xCDCDCDCD;
                m_dwDocHostFlags = DOCHOSTUIFLAG_NO3DBORDER;
                m_dwDocHostDoubleClickFlags = DOCHOSTUIDBLCLK_DEFAULT;
                m_bAllowContextMenu = true;
                m_bAllowShowUI = false;
        }

        ~CAxHostWindow()
        {
        }
        void FinalRelease()
        {
                ReleaseAll();
        }

        virtual void OnFinalMessage(HWND /*hWnd*/)
        {
                GetControllingUnknown()->Release();
        }

        DECLARE_NO_REGISTRY()
        DECLARE_POLY_AGGREGATABLE(CAxHostWindow)
        DECLARE_GET_CONTROLLING_UNKNOWN()

        BEGIN_COM_MAP(CAxHostWindow)
                COM_INTERFACE_ENTRY2(IDispatch, IAxWinAmbientDispatch)
                COM_INTERFACE_ENTRY(IAxWinHostWindow)
                COM_INTERFACE_ENTRY(IOleClientSite)
                COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
                COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
                COM_INTERFACE_ENTRY(IOleInPlaceSite)
                COM_INTERFACE_ENTRY(IOleWindow)
                COM_INTERFACE_ENTRY(IOleControlSite)
                COM_INTERFACE_ENTRY(IOleContainer)
                COM_INTERFACE_ENTRY(IObjectWithSite)
                COM_INTERFACE_ENTRY(IServiceProvider)
                COM_INTERFACE_ENTRY(IAxWinAmbientDispatch)
#ifndef _ATL_NO_DOCHOSTUIHANDLER
                COM_INTERFACE_ENTRY(IDocHostUIHandler)
#endif
                COM_INTERFACE_ENTRY(IAdviseSink)
        END_COM_MAP()

        static CWndClassInfo& GetWndClassInfo()
        {
                static CWndClassInfo wc =
                {
                        { sizeof(WNDCLASSEX), 0, StartWindowProc,
                          0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW + 1), 0, _T("AtlAxWin"), 0 },
                        NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
                };
                return wc;
        }

        BEGIN_MSG_MAP(CAxHostWindow)
                MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
                MESSAGE_HANDLER(WM_PAINT, OnPaint)
                MESSAGE_HANDLER(WM_SIZE, OnSize)
                MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
                MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
                if (m_bWindowless)
                {
                        // Mouse messages handled when a windowless control has captured the cursor
                        // or if the cursor is over the control
                        DWORD dwHitResult = m_bCapture ? HITRESULT_HIT : HITRESULT_OUTSIDE;
                        if (dwHitResult == HITRESULT_OUTSIDE && m_spViewObject != NULL)
                        {
                                POINT ptMouse = { LOWORD(lParam), HIWORD(lParam) };
                                m_spViewObject->QueryHitPoint(DVASPECT_CONTENT, &m_rcPos, ptMouse, 0, &dwHitResult);
                        }
                        if (dwHitResult == HITRESULT_HIT)
                        {
                                MESSAGE_HANDLER(WM_MOUSEMOVE, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_SETCURSOR, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_LBUTTONUP, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_RBUTTONUP, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_MBUTTONUP, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_LBUTTONDOWN, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_RBUTTONDOWN, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_MBUTTONDOWN, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnWindowlessMouseMessage)
                                MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnWindowlessMouseMessage)
                        }
                }
                if (m_bWindowless & m_bHaveFocus)
                {
                        // Keyboard messages handled only when a windowless control has the focus
                        MESSAGE_HANDLER(WM_KEYDOWN, OnWindowMessage)
                        MESSAGE_HANDLER(WM_KEYUP, OnWindowMessage)
                        MESSAGE_HANDLER(WM_CHAR, OnWindowMessage)
                        MESSAGE_HANDLER(WM_DEADCHAR, OnWindowMessage)
                        MESSAGE_HANDLER(WM_SYSKEYDOWN, OnWindowMessage)
                        MESSAGE_HANDLER(WM_SYSKEYUP, OnWindowMessage)
                        MESSAGE_HANDLER(WM_SYSDEADCHAR, OnWindowMessage)
                        MESSAGE_HANDLER(WM_HELP, OnWindowMessage)
                        MESSAGE_HANDLER(WM_CANCELMODE, OnWindowMessage)
                        MESSAGE_HANDLER(WM_IME_CHAR, OnWindowMessage)
                        MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnWindowMessage)
                        MESSAGE_RANGE_HANDLER(WM_IME_SETCONTEXT, WM_IME_KEYUP, OnWindowMessage)
                }
                MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
                if(!m_bWindowless && m_bMessageReflect)
                {
                        bHandled = TRUE;
                        lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled);
                        if(bHandled)
                                return TRUE;
                }
                MESSAGE_HANDLER(WM_ATLGETHOST, OnGetUnknown)
                MESSAGE_HANDLER(WM_ATLGETCONTROL, OnGetControl)
                MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
        END_MSG_MAP()

        LRESULT OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
        {
                ATLASSERT(lParam != 0);
                LPMSG lpMsg = (LPMSG)lParam;
                CComQIPtr<IOleInPlaceActiveObject, &IID_IOleInPlaceActiveObject> spInPlaceActiveObject(m_spUnknown);
                if(spInPlaceActiveObject)
                {
                        if(spInPlaceActiveObject->TranslateAccelerator(lpMsg) == S_OK)
                                return 1;
                }
                return 0;
        }

        LRESULT OnGetUnknown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
        {
                IUnknown* pUnk = GetControllingUnknown();
                pUnk->AddRef();
                return (LRESULT)pUnk;
        }
        LRESULT OnGetControl(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
        {
                IUnknown* pUnk = m_spUnknown;
                if (pUnk)
                        pUnk->AddRef();
                return (LRESULT)pUnk;
        }

        void ReleaseAll()
        {
                if (m_bReleaseAll)
                        return;
                m_bReleaseAll = TRUE;

                if (m_spViewObject != NULL)
                        m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, NULL);

                if(m_dwAdviseSink != 0xCDCDCDCD)
                {
                        AtlUnadvise(m_spUnknown, m_iidSink, m_dwAdviseSink);
                        m_dwAdviseSink = 0xCDCDCDCD;
                }

                if (m_spOleObject)
                {
                        m_spOleObject->Unadvise(m_dwOleObject);
                        m_spOleObject->Close(OLECLOSE_NOSAVE);
                        m_spOleObject->SetClientSite(NULL);
                }

                if (m_spUnknown != NULL)
                {
                        CComPtr<IObjectWithSite> spSite;
                        m_spUnknown->QueryInterface(IID_IObjectWithSite, (void**)&spSite);
                        if (spSite != NULL)
                                spSite->SetSite(NULL);
                }

                m_spViewObject.Release();
                m_dwViewObjectType = 0;

                m_spInPlaceObjectWindowless.Release();
                m_spOleObject.Release();
                m_spUnknown.Release();

                m_spInPlaceUIWindow.Release();
                m_spInPlaceFrame.Release();

                m_bInPlaceActive = FALSE;
                m_bWindowless = FALSE;
                m_bInPlaceActive = FALSE;
                m_bUIActive = FALSE;
                m_bCapture = FALSE;
                m_bReleaseAll = FALSE;
        }


// window message handlers
        LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
        {
                if (m_spViewObject == NULL)
                        bHandled = false;

                return 1;
        }
        LRESULT OnNCHitTest(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
        {
                return HTCLIENT;
        }
        LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
        {
                m_bHaveFocus = TRUE;
                if (!m_bReleaseAll)
                {
                        if (m_spOleObject != NULL && !m_bInPlaceActive)
                        {
                                CComPtr<IOleClientSite> spClientSite;
                                GetControllingUnknown()->QueryInterface(IID_IOleClientSite, (void**)&spClientSite);
                                if (spClientSite != NULL)
                                        m_spOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
                        }
                        if(!m_bWindowless && !IsChild(::GetFocus()))
                                ::SetFocus(::GetWindow(m_hWnd, GW_CHILD));
                }
                bHandled = FALSE;
                return 0;
        }
        LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
        {
                m_bHaveFocus = FALSE;
                bHandled = FALSE;
                return 0;
        }
        LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
        {
                int nWidth = LOWORD(lParam);  // width of client area
                int nHeight = HIWORD(lParam); // height of client area

                m_rcPos.right = m_rcPos.left + nWidth;
                m_rcPos.bottom = m_rcPos.top + nHeight;
                m_pxSize.cx = m_rcPos.right - m_rcPos.left;
                m_pxSize.cy = m_rcPos.bottom - m_rcPos.top;
                AtlPixelToHiMetric(&m_pxSize, &m_hmSize);

                if (m_spOleObject)
                        m_spOleObject->SetExtent(DVASPECT_CONTENT, &m_hmSize);
                if (m_spInPlaceObjectWindowless)
                        m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
                if (m_bWindowless)
                        InvalidateRect(NULL, TRUE);
                bHandled = FALSE;
                return 0;
        }
        LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
        {
                GetControllingUnknown()->AddRef();
                ReleaseAll();
                DefWindowProc(uMsg, wParam, lParam);
                bHandled = FALSE;
                return 0;
        }
        LRESULT OnWindowMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
        {
                LRESULT lRes = 0;
                HRESULT hr = S_FALSE;
                if (m_bInPlaceActive && m_bWindowless && m_spInPlaceObjectWindowless)
                        hr = m_spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
                if (hr == S_FALSE)
                        bHandled = FALSE;
                return lRes;
        }
        LRESULT OnWindowlessMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
        {
                LRESULT lRes = 0;
                if (m_bInPlaceActive && m_bWindowless && m_spInPlaceObjectWindowless)
                        m_spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
                bHandled = FALSE;
                return lRes;
        }
        LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
        {
                if (m_spViewObject == NULL)
                {
                        PAINTSTRUCT ps;
                        HDC hdc = ::BeginPaint(m_hWnd, &ps);
                        if (hdc == NULL)
                                return 0;
                        RECT rcClient;
                        GetClientRect(&rcClient);
                        HBRUSH hbrBack = CreateSolidBrush(m_clrBackground);
                        FillRect(hdc, &rcClient, hbrBack);
                        DeleteObject(hbrBack);
                        ::EndPaint(m_hWnd, &ps);
                        return 1;
                }
                if (m_spViewObject && m_bWindowless)
                {
                        PAINTSTRUCT ps;
                        HDC hdc = ::BeginPaint(m_hWnd, &ps);

                        if (hdc == NULL)
                                return 0;

                        RECT rcClient;
                        GetClientRect(&rcClient);

                        HBITMAP hBitmap = CreateCompatibleBitmap(hdc, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);

                        HDC hdcCompatible = ::CreateCompatibleDC(hdc);
                        
                        HBITMAP hBitmapOld = (HBITMAP)SelectObject(hdcCompatible, hBitmap); 

                        HBRUSH hbrBack = CreateSolidBrush(m_clrBackground);
                        FillRect(hdcCompatible, &rcClient, hbrBack);
                        DeleteObject(hbrBack);

                        m_spViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdcCompatible, (RECTL*)&m_rcPos, (RECTL*)&m_rcPos, NULL, NULL); 

                        ::BitBlt(hdc, 0, 0, rcClient.right, rcClient.bottom,  hdcCompatible, 0, 0, SRCCOPY);

                        ::SelectObject(hdcCompatible, hBitmapOld); 
                        ::DeleteObject(hBitmap);
                        ::DeleteDC(hdcCompatible);
                        ::EndPaint(m_hWnd, &ps);
                }
                else
                {
                        bHandled = FALSE;
                        return 0;
                }
                return 1;
        }

// IAxWinHostWindow
        STDMETHOD(CreateControl)(LPCOLESTR lpTricsData, HWND hWnd, IStream* pStream)
        {
                CComPtr<IUnknown> p;
                return CreateControlEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL);
        }
        STDMETHOD(CreateControlEx)(LPCOLESTR lpszTricsData, HWND hWnd, IStream* pStream, IUnknown** ppUnk, REFIID iidAdvise, IUnknown* punkSink)
        {
                HRESULT hr = S_FALSE;

                ReleaseAll();

                if (m_hWnd != NULL)
                {
                        RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                        ReleaseWindow();
                }

                if (::IsWindow(hWnd))
                {
                        USES_CONVERSION;
                        SubclassWindow(hWnd);
                        if (m_clrBackground == NULL)
                        {
                                if (IsParentDialog())
                                        m_clrBackground = GetSysColor(COLOR_BTNFACE);
                                else
                                        m_clrBackground = GetSysColor(COLOR_WINDOW);
                        }

                        bool bWasHTML;
                        hr = CreateNormalizedObject(lpszTricsData, IID_IUnknown, (void**)ppUnk, bWasHTML);
                        bool bInited = hr == S_FALSE;

                        if (SUCCEEDED(hr))
                                hr = ActivateAx(*ppUnk, bInited, pStream);

                        //Try to hook up any sink the user might have given us.
                        m_iidSink = iidAdvise;
                        if(SUCCEEDED(hr) && *ppUnk && punkSink)
                                AtlAdvise(*ppUnk, punkSink, m_iidSink, &m_dwAdviseSink);

                        if (SUCCEEDED(hr) && bWasHTML && *ppUnk != NULL)
                        {
                                if ((GetStyle() & (WS_VSCROLL | WS_HSCROLL)) == 0)
                                        m_dwDocHostFlags |= DOCHOSTUIFLAG_SCROLL_NO;
                                else
                                {
                                        DWORD dwStyle = GetStyle();
                                        SetWindowLong(GWL_STYLE, dwStyle & ~(WS_VSCROLL | WS_HSCROLL));
                                        SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSIZE | SWP_FRAMECHANGED | SWP_DRAWFRAME);
                                }

                                CComPtr<IUnknown> spUnk(*ppUnk);
                                // Is it just plain HTML?
                                USES_CONVERSION;
                                if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
                                        (lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
                                        (lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
                                        (lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
                                        (lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
                                        (lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
                                        (lpszTricsData[6] == OLECHAR(':')))
                                {
                                        // Just HTML, eh?
                                        CComPtr<IPersistStreamInit> spPSI;
                                        hr = spUnk->QueryInterface(IID_IPersistStreamInit, (void**)&spPSI);
                                        spPSI->InitNew();
                                        bInited = TRUE;
                                        CComPtr<IHTMLDocument2> spHTMLDoc2;
                                        hr = spUnk->QueryInterface(IID_IHTMLDocument2, (void**)&spHTMLDoc2);
                                        if (SUCCEEDED(hr))
                                        {
                                                CComPtr<IHTMLElement> spHTMLBody;
                                                hr = spHTMLDoc2->get_body(&spHTMLBody);
                                                if (SUCCEEDED(hr))
                                                        hr = spHTMLBody->put_innerHTML(CComBSTR(lpszTricsData + 7));
                                        }
                                }
                                else
                                {
                                        CComPtr<IWebBrowser2> spBrowser;
                                        spUnk->QueryInterface(IID_IWebBrowser2, (void**)&spBrowser);
                                        if (spBrowser)
                                        {
                                                CComVariant ve;
                                                CComVariant vurl(lpszTricsData);
#pragma warning(disable: 4310) // cast truncates constant value
                                                spBrowser->put_Visible(VARIANT_TRUE);
#pragma warning(default: 4310) // cast truncates constant value
                                                spBrowser->Navigate2(&vurl, &ve, &ve, &ve, &ve);
                                        }
                                }

                        }
                        if (FAILED(hr) || m_spUnknown == NULL)
                        {
                                // We don't have a control or something failed so release
                                ReleaseAll();

                                if (m_hWnd != NULL)
                                {
                                        RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                                        if (FAILED(hr))
                                                ReleaseWindow();
                                }
                        }
                }
                return hr;
        }
        STDMETHOD(AttachControl)(IUnknown* pUnkControl, HWND hWnd)
        {
                HRESULT hr = S_FALSE;

                ReleaseAll();

        if (!::IsWindow(hWnd))
            hWnd = NULL;

                if (m_hWnd != NULL && m_hWnd != hWnd)
                {
                        RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                        ReleaseWindow();
                }

                if (hWnd)
                {
                    if (m_hWnd != hWnd)
                            SubclassWindow(hWnd);

                        hr = ActivateAx(pUnkControl, TRUE, NULL);

                        if (FAILED(hr))
                        {
                                ReleaseAll();

                                if (m_hWnd != NULL)
                                {
                                        RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                                        ReleaseWindow();
                                }
                        }
                }
                return hr;
        }
        STDMETHOD(QueryControl)(REFIID riid, void** ppvObject)
        {
                HRESULT hr = E_POINTER;
                if (ppvObject)
                {
                        if (m_spUnknown)
                        {
                                hr = m_spUnknown->QueryInterface(riid, ppvObject);
                        }
                        else
                        {
                                *ppvObject = NULL;
                                hr = OLE_E_NOCONNECTION;
                        }
                }
                return hr;
        }
        STDMETHOD(SetExternalDispatch)(IDispatch* pDisp)
        {
                m_spExternalDispatch = pDisp;
                return S_OK;
        }
        STDMETHOD(SetExternalUIHandler)(IDocHostUIHandlerDispatch* pUIHandler)
        {
#ifndef _ATL_NO_DOCHOSTUIHANDLER
                m_spIDocHostUIHandlerDispatch = pUIHandler;
#endif
                return S_OK;
        }

#ifndef _ATL_NO_DOCHOSTUIHANDLER
// IDocHostUIHandler
        // MSHTML requests to display its context menu
        STDMETHOD(ShowContextMenu)(DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget, IDispatch* pDispatchObjectHit)
        {
                HRESULT hr = m_bAllowContextMenu ? S_FALSE : S_OK;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                        m_spIDocHostUIHandlerDispatch->ShowContextMenu(
                                dwID,
                                pptPosition->x,
                                pptPosition->y,
                                pCommandTarget,
                                pDispatchObjectHit,
                                &hr);
                return hr;
        }
        // Called at initialisation to find UI styles from container
        STDMETHOD(GetHostInfo)(DOCHOSTUIINFO* pInfo)
        {
                if (pInfo == NULL)
                        return E_POINTER;

                if (m_spIDocHostUIHandlerDispatch != NULL)
                        return m_spIDocHostUIHandlerDispatch->GetHostInfo(&pInfo->dwFlags, &pInfo->dwDoubleClick);

                pInfo->dwFlags = m_dwDocHostFlags;
                pInfo->dwDoubleClick = m_dwDocHostDoubleClickFlags;

                return S_OK;
        }
        // Allows the host to replace the IE4/MSHTML menus and toolbars. 
        STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject* pActiveObject, IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame, IOleInPlaceUIWindow* pDoc)
        {
                HRESULT hr = m_bAllowShowUI ? S_FALSE : S_OK;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                        m_spIDocHostUIHandlerDispatch->ShowUI(
                                dwID,
                                pActiveObject, 
                                pCommandTarget, 
                                pFrame, 
                                pDoc,
                                &hr);
                return hr;
        }
        // Called when IE4/MSHTML removes its menus and toolbars. 
        STDMETHOD(HideUI)()
        {
                HRESULT hr = S_OK;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                        hr = m_spIDocHostUIHandlerDispatch->HideUI();
                return hr;
        }
        // Notifies the host that the command state has changed. 
        STDMETHOD(UpdateUI)()
        {
                HRESULT hr = S_OK;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                        hr = m_spIDocHostUIHandlerDispatch->UpdateUI();
                return hr;
        }
        // Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::EnableModeless
        STDMETHOD(EnableModeless)(BOOL fEnable)
        {
                HRESULT hr = S_OK;
                if (m_spIDocHostUIHandlerDispatch != NULL)
#pragma warning(disable: 4310) // cast truncates constant value
                        hr = m_spIDocHostUIHandlerDispatch->EnableModeless(fEnable ? VARIANT_TRUE : VARIANT_FALSE);
#pragma warning(default: 4310) // cast truncates constant value
                return hr;
        }
        // Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::OnDocWindowActivate
        STDMETHOD(OnDocWindowActivate)(BOOL fActivate)
        {
                HRESULT hr = S_OK;
                if (m_spIDocHostUIHandlerDispatch != NULL)
#pragma warning(disable: 4310) // cast truncates constant value
                        hr = m_spIDocHostUIHandlerDispatch->OnDocWindowActivate(fActivate ? VARIANT_TRUE : VARIANT_FALSE);
#pragma warning(default: 4310) // cast truncates constant value
                return hr;
        }
        // Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::OnFrameWindowActivate. 
        STDMETHOD(OnFrameWindowActivate)(BOOL fActivate)
        {
                HRESULT hr = S_OK;
                if (m_spIDocHostUIHandlerDispatch != NULL)
#pragma warning(disable: 4310) // cast truncates constant value
                        hr = m_spIDocHostUIHandlerDispatch->OnFrameWindowActivate(fActivate ? VARIANT_TRUE : VARIANT_FALSE);
#pragma warning(default: 4310) // cast truncates constant value
                return hr;
        }
        // Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::ResizeBorder.
        STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow)
        {
                HRESULT hr = S_OK;
                if (m_spIDocHostUIHandlerDispatch != NULL)
#pragma warning(disable: 4310) // cast truncates constant value
                        hr = m_spIDocHostUIHandlerDispatch->ResizeBorder(
                                prcBorder->left,
                                prcBorder->top,
                                prcBorder->right,
                                prcBorder->bottom,
                                pUIWindow,
                                fFrameWindow ? VARIANT_TRUE : VARIANT_FALSE);
#pragma warning(default: 4310) // cast truncates constant value
                return hr;
        }
        // Called by IE4/MSHTML when IOleInPlaceActiveObject::TranslateAccelerator or IOleControlSite::TranslateAccelerator is called. 
        STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID* pguidCmdGroup, DWORD nCmdID)
        {
                HRESULT hr = S_FALSE;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                        m_spIDocHostUIHandlerDispatch->TranslateAccelerator(
                                (DWORD)(DWORD_PTR)lpMsg->hwnd,  //REVIEW
                                lpMsg->message,
                                (DWORD)lpMsg->wParam,  //REVIEW
                                (DWORD)lpMsg->lParam,  //REVIEW
                                CComBSTR(*pguidCmdGroup), 
                                nCmdID,
                                &hr);
                return hr;
        }
        // Returns the registry key under which IE4/MSHTML stores user preferences. 
        // Returns S_OK if successful, or S_FALSE otherwise. If S_FALSE, IE4/MSHTML will default to its own user options.
        STDMETHOD(GetOptionKeyPath)(BSTR* pbstrKey, DWORD dwReserved)
        {
                HRESULT hr = S_FALSE;
                if (pbstrKey == NULL)
                        return E_POINTER;
                *pbstrKey = NULL;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                {
                        hr = m_spIDocHostUIHandlerDispatch->GetOptionKeyPath(pbstrKey, dwReserved);
                        if (FAILED(hr) || *pbstrKey == NULL)
                                hr = S_FALSE;
                }
                else
                {
                        if (m_bstrOptionKeyPath.m_str != NULL)
                        {
                                *pbstrKey = m_bstrOptionKeyPath.Copy();
                                hr = S_OK;
                        }
                }
                return hr;
        }
        // Called by IE4/MSHTML when it is being used as a drop target to allow the host to supply an alternative IDropTarget
        STDMETHOD(GetDropTarget)(IDropTarget* pDropTarget, IDropTarget** ppDropTarget)
        {
                HRESULT hr = E_NOTIMPL;
                if (ppDropTarget == NULL)
                        return E_POINTER;
                *ppDropTarget = NULL;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                {
                        CComPtr<IUnknown> spUnk;
                        hr = m_spIDocHostUIHandlerDispatch->GetDropTarget(pDropTarget, &spUnk);
                        if (spUnk)
                                hr = spUnk->QueryInterface(IID_IDropTarget, (void**)ppDropTarget);
                        if (FAILED(hr) || *ppDropTarget == NULL)
                                hr = S_FALSE;
                }
                return hr;
        }
        // Called by IE4/MSHTML to obtain the host's IDispatch interface
        STDMETHOD(GetExternal)(IDispatch** ppDispatch)
        {
                HRESULT hr = E_NOINTERFACE;
                if (ppDispatch == NULL)
                        return E_POINTER;
                *ppDispatch = NULL;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                {
                        hr = m_spIDocHostUIHandlerDispatch->GetExternal(ppDispatch);
                        if (FAILED(hr) || *ppDispatch == NULL)
                                hr = E_NOINTERFACE;
                }
                else
                {
                        // return the IDispatch we have for extending the object Model
                        if (ppDispatch != NULL)
                        {
                                m_spExternalDispatch.CopyTo(ppDispatch);
                                hr = S_OK;
                        }
                        else
                                hr = E_POINTER;
                }
                return hr;
        }
        // Called by IE4/MSHTML to allow the host an opportunity to modify the URL to be loaded
        STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR* pchURLIn, OLECHAR** ppchURLOut)
        {
                HRESULT hr = S_FALSE;
                if (ppchURLOut == NULL)
                        return E_POINTER;
                *ppchURLOut = NULL;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                {
                        CComBSTR bstrURLOut;
                        hr = m_spIDocHostUIHandlerDispatch->TranslateUrl(dwTranslate, CComBSTR(pchURLIn), &bstrURLOut);
                        if (SUCCEEDED(hr) && bstrURLOut.m_str != NULL)
                        {
                                UINT nLen = (bstrURLOut.Length() + 1) * 2;
                                *ppchURLOut = (OLECHAR*) CoTaskMemAlloc(nLen);
                                if (*ppchURLOut == NULL)
                                        return E_OUTOFMEMORY;
                                memcpy(*ppchURLOut, bstrURLOut.m_str, nLen);
                        }
                        else
                                hr = S_FALSE;
                }
                return hr;
        }
        // Called on the host by IE4/MSHTML to allow the host to replace IE4/MSHTML's data object.
        // This allows the host to block certain clipboard formats or support additional clipboard formats. 
        STDMETHOD(FilterDataObject)(IDataObject* pDO, IDataObject** ppDORet)
        {
                HRESULT hr = S_FALSE;
                if (ppDORet == NULL)
                        return E_POINTER;
                *ppDORet = NULL;
                if (m_spIDocHostUIHandlerDispatch != NULL)
                {
                        CComPtr<IUnknown> spUnk;
                        hr = m_spIDocHostUIHandlerDispatch->FilterDataObject(pDO, &spUnk);
                        if (spUnk)
                                hr = QueryInterface(IID_IDataObject, (void**)ppDORet);
                        if (FAILED(hr) || *ppDORet == NULL)
                                hr = S_FALSE;
                }
                return hr;
        }
#endif

        HRESULT FireAmbientPropertyChange(DISPID dispChanged)
        {
                HRESULT hr = S_OK;
                CComQIPtr<IOleControl, &IID_IOleControl> spOleControl(m_spUnknown);
                if (spOleControl != NULL)
                        hr = spOleControl->OnAmbientPropertyChange(dispChanged);
                return hr;
        }

// IAxWinAmbientDispatch
        STDMETHOD(put_AllowWindowlessActivation)(VARIANT_BOOL bAllowWindowless)
        {
                m_bCanWindowlessActivate = bAllowWindowless;
                return S_OK;
        }
        STDMETHOD(get_AllowWindowlessActivation)(VARIANT_BOOL* pbAllowWindowless)
        {
#pragma warning(disable: 4310) // cast truncates constant value
                *pbAllowWindowless = m_bCanWindowlessActivate ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
                return S_OK;
        }
        STDMETHOD(put_BackColor)(OLE_COLOR clrBackground)
        {
                m_clrBackground = clrBackground;
                FireAmbientPropertyChange(DISPID_AMBIENT_BACKCOLOR);
                InvalidateRect(0, FALSE);
                return S_OK;
        }
        STDMETHOD(get_BackColor)(OLE_COLOR* pclrBackground)
        {
                *pclrBackground = m_clrBackground;
                return S_OK;
        }
        STDMETHOD(put_ForeColor)(OLE_COLOR clrForeground)
        {
                m_clrForeground = clrForeground;
                FireAmbientPropertyChange(DISPID_AMBIENT_FORECOLOR);
                return S_OK;
        }
        STDMETHOD(get_ForeColor)(OLE_COLOR* pclrForeground)
        {
                *pclrForeground = m_clrForeground;
                return S_OK;
        }
        STDMETHOD(put_LocaleID)(LCID lcidLocaleID)
        {
                m_lcidLocaleID = lcidLocaleID;
                FireAmbientPropertyChange(DISPID_AMBIENT_LOCALEID);
                return S_OK;
        }
        STDMETHOD(get_LocaleID)(LCID* plcidLocaleID)
        {
                *plcidLocaleID = m_lcidLocaleID;
                return S_OK;
        }
        STDMETHOD(put_UserMode)(VARIANT_BOOL bUserMode)
        {
                m_bUserMode = bUserMode;
                FireAmbientPropertyChange(DISPID_AMBIENT_USERMODE);
                return S_OK;
        }
        STDMETHOD(get_UserMode)(VARIANT_BOOL* pbUserMode)
        {
#pragma warning(disable: 4310) // cast truncates constant value
                *pbUserMode = m_bUserMode ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
                return S_OK;
        }
        STDMETHOD(put_DisplayAsDefault)(VARIANT_BOOL bDisplayAsDefault)
        {
                m_bDisplayAsDefault = bDisplayAsDefault;
                FireAmbientPropertyChange(DISPID_AMBIENT_DISPLAYASDEFAULT);
                return S_OK;
        }
        STDMETHOD(get_DisplayAsDefault)(VARIANT_BOOL* pbDisplayAsDefault)
        {
#pragma warning(disable: 4310) // cast truncates constant value
                *pbDisplayAsDefault = m_bDisplayAsDefault ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
                return S_OK;
        }
        STDMETHOD(put_Font)(IFontDisp* pFont)
        {
                m_spFont = pFont;
                FireAmbientPropertyChange(DISPID_AMBIENT_FONT);
                return S_OK;
        }
        STDMETHOD(get_Font)(IFontDisp** pFont)
        {
                if (m_spFont == NULL)
                {
                        USES_CONVERSION;
                        HFONT hSystemFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
                        if (hSystemFont == NULL)
                                hSystemFont = (HFONT) GetStockObject(SYSTEM_FONT);
                        LOGFONT logfont;
                        GetObject(hSystemFont, sizeof(logfont), &logfont);
                        FONTDESC fd;
                        fd.cbSizeofstruct = sizeof(FONTDESC);
                        fd.lpstrName = T2OLE(logfont.lfFaceName);
                        fd.sWeight = (short)logfont.lfWeight;
                        fd.sCharset = logfont.lfCharSet;
                        fd.fItalic = logfont.lfItalic;
                        fd.fUnderline = logfont.lfUnderline;
                        fd.fStrikethrough = logfont.lfStrikeOut;

                        long lfHeight = logfont.lfHeight;
                        if (lfHeight < 0)
                                lfHeight = -lfHeight;

                        int ppi;
                        HDC hdc;
                        if (m_hWnd)
                        {
                                hdc = ::GetDC(m_hWnd);
                                ppi = GetDeviceCaps(hdc, LOGPIXELSY);
                                ::ReleaseDC(m_hWnd, hdc);
                        }
                        else
                        {
                                hdc = ::GetDC(GetDesktopWindow());
                                ppi = GetDeviceCaps(hdc, LOGPIXELSY);
                                ::ReleaseDC(GetDesktopWindow(), hdc);
                        }
                        fd.cySize.Lo = lfHeight * 720000 / ppi;
                        fd.cySize.Hi = 0;

#pragma message( "Still need OleCreateFontIndirect()" )
//                        OleCreateFontIndirect(&fd, IID_IFontDisp, (void**) &m_spFont);
                }

                return m_spFont.CopyTo(pFont);
        }
        STDMETHOD(put_MessageReflect)(VARIANT_BOOL bMessageReflect)
        {
                m_bMessageReflect = bMessageReflect;
                FireAmbientPropertyChange(DISPID_AMBIENT_MESSAGEREFLECT);
                return S_OK;
        }
        STDMETHOD(get_MessageReflect)(VARIANT_BOOL* pbMessageReflect)
        {
#pragma warning(disable: 4310) // cast truncates constant value
                *pbMessageReflect = m_bMessageReflect ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
                return S_OK;
        }
        STDMETHOD(get_ShowGrabHandles)(VARIANT_BOOL* pbShowGrabHandles)
        {
                *pbShowGrabHandles = VARIANT_FALSE;
                return S_OK;
        }
        STDMETHOD(get_ShowHatching)(VARIANT_BOOL* pbShowHatching)
        {
                *pbShowHatching = VARIANT_FALSE;
                return S_OK;
        }
        STDMETHOD(put_DocHostFlags)(DWORD dwDocHostFlags)
        {
                m_dwDocHostFlags = dwDocHostFlags;
                FireAmbientPropertyChange(DISPID_UNKNOWN);
                return S_OK;
        }
        STDMETHOD(get_DocHostFlags)(DWORD* pdwDocHostFlags)
        {
                *pdwDocHostFlags = m_dwDocHostFlags;
                return S_OK;
        }
        STDMETHOD(put_DocHostDoubleClickFlags)(DWORD dwDocHostDoubleClickFlags)
        {
                m_dwDocHostDoubleClickFlags = dwDocHostDoubleClickFlags;
                return S_OK;
        }
        STDMETHOD(get_DocHostDoubleClickFlags)(DWORD* pdwDocHostDoubleClickFlags)
        {
                *pdwDocHostDoubleClickFlags = m_dwDocHostDoubleClickFlags;
                return S_OK;
        }
        STDMETHOD(put_AllowContextMenu)(VARIANT_BOOL bAllowContextMenu)
        {
                m_bAllowContextMenu = bAllowContextMenu;
                return S_OK;
        }
        STDMETHOD(get_AllowContextMenu)(VARIANT_BOOL* pbAllowContextMenu)
        {
#pragma warning(disable: 4310) // cast truncates constant value
                *pbAllowContextMenu = m_bAllowContextMenu ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
                return S_OK;
        }
        STDMETHOD(put_AllowShowUI)(VARIANT_BOOL bAllowShowUI)
        {
                m_bAllowShowUI = bAllowShowUI;
                return S_OK;
        }
        STDMETHOD(get_AllowShowUI)(VARIANT_BOOL* pbAllowShowUI)
        {
#pragma warning(disable: 4310) // cast truncates constant value
                *pbAllowShowUI = m_bAllowShowUI ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
                return S_OK;
        }
        STDMETHOD(put_OptionKeyPath)(BSTR bstrOptionKeyPath)
        {
                m_bstrOptionKeyPath = bstrOptionKeyPath;;
                return S_OK;
        }
        STDMETHOD(get_OptionKeyPath)(BSTR* pbstrOptionKeyPath)
        {
                *pbstrOptionKeyPath = m_bstrOptionKeyPath;
                return S_OK;
        }

// IObjectWithSite
        STDMETHOD(SetSite)(IUnknown* pUnkSite)
        {
                HRESULT hr = IObjectWithSiteImpl<CAxHostWindow>::SetSite(pUnkSite);

                if (SUCCEEDED(hr) && m_spUnkSite)
                {
                        // Look for "outer" IServiceProvider
                        hr = m_spUnkSite->QueryInterface(IID_IServiceProvider, (void**)&m_spServices);
                        ATLASSERT( !hr && "No ServiceProvider!" );
                }

                if (pUnkSite == NULL)
                        m_spServices.Release();

                return hr;
        }

// IOleClientSite
        STDMETHOD(SaveObject)()
        {
                ATLTRACENOTIMPL(_T("IOleClientSite::SaveObject"));
        }
        STDMETHOD(GetMoniker)(DWORD /*dwAssign*/, DWORD /*dwWhichMoniker*/, IMoniker** /*ppmk*/)
        {
                ATLTRACENOTIMPL(_T("IOleClientSite::GetMoniker"));
        }
        STDMETHOD(GetContainer)(IOleContainer** ppContainer)
        {
                ATLTRACE2(atlTraceHosting, 0, _T("IOleClientSite::GetContainer\n"));
                HRESULT hr = E_POINTER;
                if (ppContainer)
                {
                        hr = E_NOTIMPL;
                        (*ppContainer) = NULL;
                        if (m_spUnkSite)
                                hr = m_spUnkSite->QueryInterface(IID_IOleContainer, (void**)ppContainer);
                        if (FAILED(hr))
                                hr = QueryInterface(IID_IOleContainer, (void**)ppContainer);
                }
                return hr;
        }
        STDMETHOD(ShowObject)()
        {
                ATLTRACE2(atlTraceHosting, 0, _T("IOleClientSite::ShowObject\r\n"));

                HDC hdc = CWindowImpl<CAxHostWindow>::GetDC();
                if (hdc == NULL)
                        return E_FAIL;
                if (m_spViewObject)
                        m_spViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdc, (RECTL*)&m_rcPos, (RECTL*)&m_rcPos, NULL, NULL); 
                CWindowImpl<CAxHostWindow>::ReleaseDC(hdc);
                return S_OK;
        }
        STDMETHOD(OnShowWindow)(BOOL /*fShow*/)
        {
                ATLTRACENOTIMPL(_T("IOleClientSite::OnShowWindow"));
        }
        STDMETHOD(RequestNewObjectLayout)()
        {
                ATLTRACENOTIMPL(_T("IOleClientSite::RequestNewObjectLayout"));
        }

// IOleInPlaceSite
        STDMETHOD(GetWindow)(HWND* phwnd)
        {
                *phwnd = m_hWnd;
                return S_OK;
        }
        STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
        {
                ATLTRACENOTIMPL(_T("IOleWindow::CanInPlaceActivate"));
        }
        STDMETHOD(CanInPlaceActivate)()
        {
                return S_OK;
        }
        STDMETHOD(OnInPlaceActivate)()
        {
                m_bInPlaceActive = TRUE;
                OleLockRunning(m_spOleObject, TRUE, FALSE);
                m_bWindowless = FALSE;
                m_spOleObject->QueryInterface(IID_IOleInPlaceObject, (void**) &m_spInPlaceObjectWindowless);
                return S_OK;
        }
        STDMETHOD(OnUIActivate)()
        {
                ATLTRACE2(atlTraceHosting, 0, _T("IOleInPlaceSite::OnUIActivate\n"));
                m_bUIActive = TRUE;
                return S_OK;
        }
        STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo)
        {
                HRESULT hr = S_OK;
                if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL || lprcClipRect == NULL)
                        hr = E_POINTER;
                ATLASSERT(SUCCEEDED(hr));
                if (SUCCEEDED(hr))
                {
                        if (!m_spInPlaceFrame)
                        {
                                CComObject<CAxFrameWindow>* pFrameWindow;
                                CComObject<CAxFrameWindow>::CreateInstance(&pFrameWindow);
                                pFrameWindow->QueryInterface(IID_IOleInPlaceFrame, (void**) &m_spInPlaceFrame);
                                ATLASSERT(m_spInPlaceFrame);
                        }
                        if (!m_spInPlaceUIWindow)
                        {
                                CComObject<CAxUIWindow>* pUIWindow;
                                CComObject<CAxUIWindow>::CreateInstance(&pUIWindow);
                                pUIWindow->QueryInterface(IID_IOleInPlaceUIWindow, (void**) &m_spInPlaceUIWindow);
                                ATLASSERT(m_spInPlaceUIWindow);
                        }
                        m_spInPlaceFrame.CopyTo(ppFrame);
                        m_spInPlaceUIWindow.CopyTo(ppDoc);
                        GetClientRect(lprcPosRect);
                        GetClientRect(lprcClipRect);

                        ACCEL ac = { 0,0,0 };
                        HACCEL hac = CreateAcceleratorTable(&ac, 1);
                        pFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
                        pFrameInfo->fMDIApp = m_bMDIApp;
                        pFrameInfo->hwndFrame = GetParent();
                        pFrameInfo->haccel = hac;
                        pFrameInfo->cAccelEntries = 1;
                }
                return hr;
        }
        STDMETHOD(Scroll)(SIZE /*scrollExtant*/)
        {
                ATLTRACENOTIMPL(_T("IOleInPlaceSite::Scroll"));
        }
        STDMETHOD(OnUIDeactivate)(BOOL /*fUndoable*/)
        {
                ATLTRACE2(atlTraceHosting, 0, _T("IOleInPlaceSite::OnUIDeactivate\n"));
                m_bUIActive = FALSE;
                return S_OK;
        }
        STDMETHOD(OnInPlaceDeactivate)()
        {
                m_bInPlaceActive = FALSE;
                m_spInPlaceObjectWindowless.Release();
                return S_OK;
        }
        STDMETHOD(DiscardUndoState)()
        {
                ATLTRACENOTIMPL(_T("IOleInPlaceSite::DiscardUndoState"));
        }
        STDMETHOD(DeactivateAndUndo)()
        {
                ATLTRACENOTIMPL(_T("IOleInPlaceSite::DeactivateAndUndo"));
        }
        STDMETHOD(OnPosRectChange)(LPCRECT /*lprcPosRect*/)
        {
                ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnPosRectChange"));
        }

// IOleInPlaceSiteEx
        STDMETHOD(OnInPlaceActivateEx)(BOOL* /*pfNoRedraw*/, DWORD dwFlags)
        {
                m_bInPlaceActive = TRUE;
                OleLockRunning(m_spOleObject, TRUE, FALSE);
                HRESULT hr = E_FAIL;
                if (dwFlags & ACTIVATE_WINDOWLESS)
                {
                        m_bWindowless = TRUE;
                        hr = m_spOleObject->QueryInterface(IID_IOleInPlaceObjectWindowless, (void**) &m_spInPlaceObjectWindowless);
                }
                if (FAILED(hr))
                {
                        m_bWindowless = FALSE;
                        hr = m_spOleObject->QueryInterface(IID_IOleInPlaceObject, (void**) &m_spInPlaceObjectWindowless);
                }
                if (m_spInPlaceObjectWindowless)
                        m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
                return S_OK;
        }
        STDMETHOD(OnInPlaceDeactivateEx)(BOOL /*fNoRedraw*/)
        {
                return S_OK;
        }
        STDMETHOD(RequestUIActivate)()
        {
                return S_OK;
        }

// IOleInPlaceSiteWindowless
        STDMETHOD(CanWindowlessActivate)()
        {
                return m_bCanWindowlessActivate ? S_OK : S_FALSE;
        }
        STDMETHOD(GetCapture)()
        {
                return m_bCapture ? S_OK : S_FALSE;
        }
        STDMETHOD(SetCapture)(BOOL fCapture)
        {
                if (fCapture)
                {
                        CWindow::SetCapture();
                        m_bCapture = TRUE;
                }
                else
                {
                        ReleaseCapture();
                        m_bCapture = FALSE;
                }
                return S_OK;
        }
        STDMETHOD(GetFocus)()
        {
                return S_OK;
        }
        STDMETHOD(SetFocus)(BOOL /*fFocus*/)
        {
                return S_OK;
        }
        STDMETHOD(GetDC)(LPCRECT /*pRect*/, DWORD /*grfFlags*/, HDC* phDC)
        {
                if (phDC == NULL)
                        return E_POINTER;
                *phDC = CWindowImpl<CAxHostWindow>::GetDC();
                return S_OK;
        }
        STDMETHOD(ReleaseDC)(HDC hDC)
        {
                CWindowImpl<CAxHostWindow>::ReleaseDC(hDC);
                return S_OK;
        }
        STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase)
        {
                CWindowImpl<CAxHostWindow>::InvalidateRect(pRect, fErase);
                return S_OK;
        }
        STDMETHOD(InvalidateRgn)(HRGN hRGN, BOOL fErase)
        {
                CWindowImpl<CAxHostWindow>::InvalidateRgn(hRGN, fErase);
                return S_OK;
        }
        STDMETHOD(ScrollRect)(INT /*dx*/, INT /*dy*/, LPCRECT /*pRectScroll*/, LPCRECT /*pRectClip*/)
        {
                return S_OK;
        }
        STDMETHOD(AdjustRect)(LPRECT /*prc*/)
        {
                return S_OK;
        }
        STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
        {
                *plResult = DefWindowProc(msg, wParam, lParam);
                return S_OK;
        }

// IOleControlSite
        STDMETHOD(OnControlInfoChanged)()
        {
                return S_OK;
        }
        STDMETHOD(LockInPlaceActive)(BOOL /*fLock*/)
        {
                return S_OK;
        }
        STDMETHOD(GetExtendedControl)(IDispatch** ppDisp)
        {
                if (ppDisp == NULL)
                        return E_POINTER;
                return m_spOleObject.QueryInterface(ppDisp);
        }
        STDMETHOD(TransformCoords)(POINTL* /*pPtlHimetric*/, POINTF* /*pPtfContainer*/, DWORD /*dwFlags*/)
        {
                return S_OK;
        }
        STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, DWORD /*grfModifiers*/)
        {
                return S_FALSE;
        }
        STDMETHOD(OnFocus)(BOOL /*fGotFocus*/)
        {
                return S_OK;
        }
        STDMETHOD(ShowPropertyFrame)()
        {
                return E_NOTIMPL;
        }

// IAdviseSink
        STDMETHOD_(void, OnDataChange)(FORMATETC* /*pFormatetc*/, STGMEDIUM* /*pStgmed*/)
        {
        }
        STDMETHOD_(void, OnViewChange)(DWORD /*dwAspect*/, LONG /*lindex*/)
        {
        }
        STDMETHOD_(void, OnRename)(IMoniker* /*pmk*/)
        {
        }
        STDMETHOD_(void, OnSave)()
        {
        }
        STDMETHOD_(void, OnClose)()
        {
        }

// IOleContainer
        STDMETHOD(ParseDisplayName)(IBindCtx* /*pbc*/, LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/)
        {
                return E_NOTIMPL;
        }
        STDMETHOD(EnumObjects)(DWORD /*grfFlags*/, IEnumUnknown** ppenum)
        {
                if (ppenum == NULL)
                        return E_POINTER;
                *ppenum = NULL;
                typedef CComObject<CComEnum<IEnumUnknown, &IID_IEnumUnknown, IUnknown*, _CopyInterface<IUnknown> > > enumunk;
                enumunk* p = NULL;
                ATLTRY(p = new enumunk);
                if(p == NULL)
                        return E_OUTOFMEMORY;
                HRESULT hRes = p->Init(reinterpret_cast<IUnknown**>(&m_spUnknown), reinterpret_cast<IUnknown**>(&m_spOleObject), GetControllingUnknown(), AtlFlagCopy);
                if (SUCCEEDED(hRes))
                        hRes = p->QueryInterface(IID_IEnumUnknown, (void**)ppenum);
                if (FAILED(hRes))
                        delete p;
                return hRes;
        }
        STDMETHOD(LockContainer)(BOOL fLock)
        {
                m_bLocked = fLock;
                return S_OK;
        }

        HRESULT ActivateAx(IUnknown* pUnkControl, bool bInited, IStream* pStream)
        {
                if (pUnkControl == NULL)
                        return S_OK;

                m_spUnknown = pUnkControl;

                HRESULT hr = S_OK;
                pUnkControl->QueryInterface(IID_IOleObject, (void**)&m_spOleObject);
                if (m_spOleObject)
                {
                        m_spOleObject->GetMiscStatus(DVASPECT_CONTENT, &m_dwMiscStatus);
                        if(m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
                        {
                                CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
                                m_spOleObject->SetClientSite(spClientSite);
                        }

                        CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI(m_spOleObject);
                        if (!bInited && spPSI)
                        {
                                if (pStream)
                                        spPSI->Load(pStream);
                                else
                                        spPSI->InitNew();
                        }

                        if(0 == (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
                        {
                                CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
                                m_spOleObject->SetClientSite(spClientSite);
                        }

                        m_dwViewObjectType = 0;
                        HRESULT hr;
                        hr = m_spOleObject->QueryInterface(IID_IViewObjectEx, (void**) &m_spViewObject);
                        if (FAILED(hr))
                        {
                                hr = m_spOleObject->QueryInterface(IID_IViewObject2, (void**) &m_spViewObject);
                                m_dwViewObjectType = 3;
                        } else
                                m_dwViewObjectType = 7;

                        if (FAILED(hr))
                        {
                                hr = m_spOleObject->QueryInterface(IID_IViewObject, (void**) &m_spViewObject);
                                m_dwViewObjectType = 1;
                        }
                        CComQIPtr<IAdviseSink> spAdviseSink(GetControllingUnknown());
                        m_spOleObject->Advise(spAdviseSink, &m_dwOleObject);
                        if (m_dwViewObjectType)
                                m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, spAdviseSink);
                        m_spOleObject->SetHostNames(OLESTR("AXWIN"), NULL);
                        GetClientRect(&m_rcPos);
                        m_pxSize.cx = m_rcPos.right - m_rcPos.left;
                        m_pxSize.cy = m_rcPos.bottom - m_rcPos.top;
                        AtlPixelToHiMetric(&m_pxSize, &m_hmSize);
                        m_spOleObject->SetExtent(DVASPECT_CONTENT, &m_hmSize);
                        m_spOleObject->GetExtent(DVASPECT_CONTENT, &m_hmSize);
                        AtlHiMetricToPixel(&m_hmSize, &m_pxSize);
                        m_rcPos.right = m_rcPos.left + m_pxSize.cx;
                        m_rcPos.bottom = m_rcPos.top + m_pxSize.cy;

                        CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
                        hr = m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
                        RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                }
                CComPtr<IObjectWithSite> spSite;
                pUnkControl->QueryInterface(IID_IObjectWithSite, (void**)&spSite);
                if (spSite != NULL)
                        spSite->SetSite(GetControllingUnknown());

                return hr;
        }

// pointers
        CComPtr<IUnknown> m_spUnknown;
        CComPtr<IOleObject> m_spOleObject;
        CComPtr<IOleInPlaceFrame> m_spInPlaceFrame;
        CComPtr<IOleInPlaceUIWindow> m_spInPlaceUIWindow;
        CComPtr<IViewObjectEx> m_spViewObject;
        CComPtr<IOleInPlaceObjectWindowless> m_spInPlaceObjectWindowless;
        CComPtr<IDispatch> m_spExternalDispatch;
#ifndef _ATL_NO_DOCHOSTUIHANDLER
        CComPtr<IDocHostUIHandlerDispatch> m_spIDocHostUIHandlerDispatch;
#endif
        IID m_iidSink;
        DWORD m_dwViewObjectType;
        DWORD m_dwAdviseSink;

// state
        unsigned long m_bInPlaceActive:1;
        unsigned long m_bUIActive:1;
        unsigned long m_bMDIApp:1;
        unsigned long m_bWindowless:1;
        unsigned long m_bCapture:1;
        unsigned long m_bHaveFocus:1;
        unsigned long m_bReleaseAll:1;
        unsigned long m_bLocked:1;

        DWORD m_dwOleObject;
        DWORD m_dwMiscStatus;
        SIZEL m_hmSize;
        SIZEL m_pxSize;
        RECT m_rcPos;

        // Ambient property storage
        unsigned long m_bCanWindowlessActivate:1;
        unsigned long m_bUserMode:1;
        unsigned long m_bDisplayAsDefault:1;
        unsigned long m_bMessageReflect:1;
        unsigned long m_bSubclassed:1;
        unsigned long m_bAllowContextMenu:1;
        unsigned long m_bAllowShowUI:1;
        OLE_COLOR m_clrBackground;
        OLE_COLOR m_clrForeground;
        LCID m_lcidLocaleID;
        CComPtr<IFontDisp> m_spFont;
        CComPtr<IServiceProvider>  m_spServices;
        DWORD m_dwDocHostFlags;
        DWORD m_dwDocHostDoubleClickFlags;
        CComBSTR m_bstrOptionKeyPath;

        void SubclassWindow(HWND hWnd)
        {
                m_bSubclassed = CWindowImpl<CAxHostWindow>::SubclassWindow(hWnd);
        }

        void ReleaseWindow()
        {
                if (m_bSubclassed)
                {
                        if(UnsubclassWindow(TRUE) != NULL)
                                m_bSubclassed = FALSE;
                }
                else
                        DestroyWindow();
        }

        // Reflection
        LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
        {
                HWND hWndChild = NULL;

                switch(uMsg)
                {
                case WM_COMMAND:
                        if(lParam != NULL)        // not from a menu
                                hWndChild = (HWND)lParam;
                        break;
                case WM_NOTIFY:
                        hWndChild = ((LPNMHDR)lParam)->hwndFrom;
                        break;
                case WM_PARENTNOTIFY:
                        switch(LOWORD(wParam))
                        {
                        case WM_CREATE:
                        case WM_DESTROY:
                                hWndChild = (HWND)lParam;
                                break;
                        default:
                                hWndChild = GetDlgItem(HIWORD(wParam));
                                break;
                        }
                        break;
                case WM_DRAWITEM:
                        if(wParam)        // not from a menu
                                hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
                        break;
                case WM_MEASUREITEM:
                        if(wParam)        // not from a menu
                                hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
                        break;
                case WM_COMPAREITEM:
                        if(wParam)        // not from a menu
                                hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
                        break;
                case WM_DELETEITEM:
                        if(wParam)        // not from a menu
                                hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
                        break;
                case WM_VKEYTOITEM:
                case WM_CHARTOITEM:
                case WM_HSCROLL:
                case WM_VSCROLL:
                        hWndChild = (HWND)lParam;
                        break;
                case WM_CTLCOLORBTN:
                case WM_CTLCOLORDLG:
                case WM_CTLCOLOREDIT:
                case WM_CTLCOLORLISTBOX:
                case WM_CTLCOLORMSGBOX:
                case WM_CTLCOLORSCROLLBAR:
                case WM_CTLCOLORSTATIC:
                        hWndChild = (HWND)lParam;
                        break;
                default:
                        break;
                }

                if(hWndChild == NULL)
                {
                        bHandled = FALSE;
                        return 1;
                }

                ATLASSERT(::IsWindow(hWndChild));
                return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
        }

        STDMETHOD(QueryService)( REFGUID rsid, REFIID riid, void** ppvObj) 
        {
                HRESULT hr = E_NOINTERFACE;
                // Try for service on this object

                // No services currently

                // If that failed try to find the service on the outer object
                if (FAILED(hr) && m_spServices)
                        hr = m_spServices->QueryService(rsid, riid, ppvObj);

                return hr;
        }
};


/////////////////////////////////////////////////////////////////////////////
// Helper functions for cracking dialog templates



#define _ATL_RT_DLGINIT  MAKEINTRESOURCE(240)

class _DialogSplitHelper
{
public:
        // Constants used in DLGINIT resources for OLE control containers
        // NOTE: These are NOT real Windows messages they are simply tags
        // used in the control resource and are never used as 'messages'
        enum
        {
                WM_OCC_LOADFROMSTREAM = 0x0376,
                WM_OCC_LOADFROMSTORAGE = 0x0377,
                WM_OCC_INITNEW = 0x0378,
                WM_OCC_LOADFROMSTREAM_EX = 0x037A,
                WM_OCC_LOADFROMSTORAGE_EX = 0x037B,
                DISPID_DATASOURCE = 0x80010001,
                DISPID_DATAFIELD = 0x80010002,
        };

//local struct used for implementation
#pragma pack(push, 1)
        struct DLGINITSTRUCT
        {
                WORD nIDC;
                WORD message;
                DWORD dwSize;
        };
        struct DLGTEMPLATEEX
        {
                WORD dlgVer;
                WORD signature;
                DWORD helpID;
                DWORD exStyle;
                DWORD style;
                WORD cDlgItems;
                short x;
                short y;
                short cx;
                short cy;

                // Everything else in this structure is variable length,
                // and therefore must be determined dynamically

                // sz_Or_Ord menu;                        // name or ordinal of a menu resource
                // sz_Or_Ord windowClass;        // name or ordinal of a window class
                // WCHAR title[titleLen];        // title string of the dialog box
                // short pointsize;                        // only if DS_SETFONT is set
                // short weight;                        // only if DS_SETFONT is set
                // short bItalic;                        // only if DS_SETFONT is set
                // WCHAR font[fontLen];                // typeface name, if DS_SETFONT is set
        };
        struct DLGITEMTEMPLATEEX
        {
                DWORD helpID;
                DWORD exStyle;
                DWORD style;
                short x;
                short y;
                short cx;
                short cy;
                DWORD id;

                // Everything else in this structure is variable length,
                // and therefore must be determined dynamically

                // sz_Or_Ord windowClass;        // name or ordinal of a window class
                // sz_Or_Ord title;                        // title string or ordinal of a resource
                // WORD extraCount;                        // bytes following creation data
        };
#pragma pack(pop)

        static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
        {
                return ((DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
        }

        inline static WORD& DlgTemplateItemCount(DLGTEMPLATE* pTemplate)
        {
                if (IsDialogEx(pTemplate))
                        return reinterpret_cast<DLGTEMPLATEEX*>(pTemplate)->cDlgItems;
                else
                        return pTemplate->cdit;
        }

        inline static const WORD& DlgTemplateItemCount(const DLGTEMPLATE* pTemplate)
        {
                if (IsDialogEx(pTemplate))
                        return reinterpret_cast<const DLGTEMPLATEEX*>(pTemplate)->cDlgItems;
                else
                        return pTemplate->cdit;
        }

        static DLGITEMTEMPLATE* FindFirstDlgItem(const DLGTEMPLATE* pTemplate)
        {
                BOOL bDialogEx = IsDialogEx(pTemplate);

                WORD* pw;
                DWORD dwStyle;
                if (bDialogEx)
                {
                        pw = (WORD*)((DLGTEMPLATEEX*)pTemplate + 1);
                        dwStyle = ((DLGTEMPLATEEX*)pTemplate)->style;
                }
                else
                {
                        pw = (WORD*)(pTemplate + 1);
                        dwStyle = pTemplate->style;
                }

                // Check for presence of menu and skip it if there is one
                // 0x0000 means there is no menu
                // 0xFFFF means there is a menu ID following
                // Everything else means that this is a NULL terminated Unicode string
                // which identifies the menu resource
                if (*pw == 0xFFFF)
                        pw += 2;                                // Has menu ID, so skip 2 words
                else
                        while (*pw++);                        // Either No menu, or string, skip past terminating NULL

                // Check for presence of class name string
                // 0x0000 means "Use system dialog class name"
                // 0xFFFF means there is a window class (atom) specified
                // Everything else means that this is a NULL terminated Unicode string
                // which identifies the menu resource
                if (*pw == 0xFFFF)
                        pw += 2;                                // Has class atom, so skip 2 words
                else
                        while (*pw++);                        // Either No class, or string, skip past terminating NULL

                // Skip caption string
                while (*pw++);

                // If we have DS_SETFONT, there is extra font information which we must now skip
                if (dwStyle & DS_SETFONT)
                {
                        // If it is a regular DLGTEMPLATE there is only a short for the point size
                        // and a string specifying the font (typefacename).  If this is a DLGTEMPLATEEX
                        // then there is also the font weight, and bItalic which must be skipped
                        if (bDialogEx)
                                pw += 3;                        // Skip font size, weight, (italic, charset)
                        else
                                pw += 1;                        // Skip font size
                        while (*pw++);                        // Skip typeface name
                }

                // Dword-align and return
                return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + 3) & ~DWORD_PTR(3));
        }

        // Given the current dialog item and whether this is an extended dialog
        // return a pointer to the next DLGITEMTEMPLATE*
        static DLGITEMTEMPLATE* FindNextDlgItem(DLGITEMTEMPLATE* pItem, BOOL bDialogEx)
        {
                WORD* pw;

                // First skip fixed size header information, size of which depends
                // if this is a DLGITEMTEMPLATE or DLGITEMTEMPLATEEX
                if (bDialogEx)
                        pw = (WORD*)((DLGITEMTEMPLATEEX*)pItem + 1);
                else
                        pw = (WORD*)(pItem + 1);

                if (*pw == 0xFFFF)                        // Skip class name ordinal or string
                        pw += 2; // (WORDs)
                else
                        while (*pw++);

                if (*pw == 0xFFFF)                        // Skip title ordinal or string
                        pw += 2; // (WORDs)
                else
                        while (*pw++);

                WORD cbExtra = *pw++;                // Skip extra data

                // Dword-align and return
                return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + cbExtra + 3) & ~DWORD_PTR(3));
        }

        // Find the initialization data (Stream) for the control specified by the ID
        // If found, return the pointer into the data and the length of the data
        static DWORD FindCreateData(DWORD dwID, BYTE* pInitData, BYTE** pData)
        {
                while (pInitData)
                {
                        // Read the DLGINIT header
                        WORD nIDC = *((UNALIGNED WORD*)pInitData);
                        pInitData += sizeof(WORD);
                        WORD nMsg = *((UNALIGNED WORD*)pInitData);
                        pInitData += sizeof(WORD);
                        DWORD dwLen = *((UNALIGNED DWORD*)pInitData);
                        pInitData += sizeof(DWORD);

                        // If the header is for the control specified get the other info
                        if (nIDC == dwID)
                        {
                                DWORD cchLicKey = *((UNALIGNED DWORD*)pInitData);
                                pInitData += sizeof(DWORD);
                                dwLen -= sizeof(DWORD);
                                if (cchLicKey > 0)
                                {
                                        CComBSTR bstrLicKey;
                                        bstrLicKey.m_str = SysAllocStringLen((LPCOLESTR)pInitData, cchLicKey);
                                        pInitData += cchLicKey * sizeof(OLECHAR);
                                        dwLen -= cchLicKey * sizeof(OLECHAR);
                                }

                                // Extended (DATABINDING) stream format is not supported,
                                // we reject databinding info but preserve other information
                                if (nMsg == WM_OCC_LOADFROMSTREAM_EX ||
                                        nMsg == WM_OCC_LOADFROMSTORAGE_EX)
                                {
                                        // Read the size of the section
                                        ULONG cbOffset = *(UNALIGNED ULONG*)pInitData;

                                        // and simply skip past it
                                        *pData = pInitData + cbOffset;
                                        dwLen = dwLen - cbOffset;
                                        return dwLen;
                                }
                                if (nMsg == WM_OCC_LOADFROMSTREAM)
                                        *pData = pInitData;
                                return dwLen;
                        }

                        // It's not the right control, skip past data
                        pInitData += dwLen;
                }
                return 0;
        }

        // Convert MSDEV (MFC) style DLGTEMPLATE with controls to regular DLGTEMPLATE
        // Changing all ActiveX Controls to use ATL AxWin hosting code
        static DLGTEMPLATE* SplitDialogTemplate(DLGTEMPLATE* pTemplate, BYTE* pInitData)
        {
                USES_CONVERSION;
                LPCWSTR lpstrAxWndClassNameW = T2CW(CAxWindow::GetWndClassName());

                // Calculate the size of the DLGTEMPLATE for allocating the new one
                DLGITEMTEMPLATE* pFirstItem = FindFirstDlgItem(pTemplate);
                ULONG cbHeader = ULONG((BYTE*)pFirstItem - (BYTE*)pTemplate);
                ULONG cbNewTemplate = cbHeader;

                BOOL bDialogEx = IsDialogEx(pTemplate);

                int iItem;
                int nItems = (int)DlgTemplateItemCount(pTemplate);
#ifndef OLE2ANSI
                LPWSTR pszClassName;
#else
                LPSTR pszClassName;
#endif
                BOOL bHasOleControls = FALSE;

                // Make first pass through the dialog template.  On this pass, we're
                // interested in determining:
                //    1. Does this template contain any ActiveX Controls?
                //    2. If so, how large a buffer is needed for a template containing
                //       only the non-OLE controls?

                DLGITEMTEMPLATE* pItem = pFirstItem;
                DLGITEMTEMPLATE* pNextItem = pItem;
                for (iItem = 0; iItem < nItems; iItem++)
                {
                        pNextItem = FindNextDlgItem(pItem, bDialogEx);

                        pszClassName = bDialogEx ?
#ifndef OLE2ANSI
                                (LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
                                (LPWSTR)(pItem + 1);
#else
                                (LPSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
                                (LPSTR)(pItem + 1);
#endif

                        // Check if the class name begins with a '{'
                        // If it does, that means it is an ActiveX Control in MSDEV (MFC) format
#ifndef OLE2ANSI
                        if (pszClassName[0] == L'{')
#else
                        if (pszClassName[0] == '{')
#endif
                        {
                                // Item is an ActiveX control.
                                bHasOleControls = TRUE;

                                cbNewTemplate += (ULONG)((bDialogEx ? sizeof(DLGITEMTEMPLATEEX) : sizeof(DLGITEMTEMPLATE)));

                                // Length of className including NULL terminator
                                cbNewTemplate += (lstrlenW(lpstrAxWndClassNameW) + 1) * sizeof(WCHAR);
                                
                                // Add length for the title CLSID in the form "{00000010-0000-0010-8000-00AA006D2EA4}"
                                // plus room for terminating NULL and an extra WORD for cbExtra
                                cbNewTemplate += 80;

                                // Get the Control ID
                                DWORD wID = bDialogEx ? ((DLGITEMTEMPLATEEX*)pItem)->id : pItem->id;
                                BYTE* pData;
                                cbNewTemplate += FindCreateData(wID, pInitData, &pData);
                                
                                // Align to next DWORD
                                cbNewTemplate = ((cbNewTemplate + 3) & ~3);
                        }
                        else
                        {
                                // Item is not an ActiveX Control: make room for it in new template.
                                cbNewTemplate += ULONG((BYTE*)pNextItem - (BYTE*)pItem);
                        }

                        pItem = pNextItem;
                }

                // No OLE controls were found, so there's no reason to go any further.
                if (!bHasOleControls)
                        return pTemplate;

                // Copy entire header into new template.
                BYTE* pNew = (BYTE*)GlobalAlloc(GMEM_FIXED, cbNewTemplate);
                DLGTEMPLATE* pNewTemplate = (DLGTEMPLATE*)pNew;
                memcpy(pNew, pTemplate, cbHeader);
                pNew += cbHeader;

                // Initialize item count in new header to zero.
                DlgTemplateItemCount(pNewTemplate) = 0;

                pItem = pFirstItem;
                pNextItem = pItem;

                // Second pass through the dialog template.  On this pass, we want to:
                //    1. Copy all the non-OLE controls into the new template.
                //    2. Build an array of item templates for the OLE controls.

                for (iItem = 0; iItem < nItems; iItem++)
                {
                        pNextItem = FindNextDlgItem(pItem, bDialogEx);

                        pszClassName = bDialogEx ?
#ifndef OLE2ANSI
                                (LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
                                (LPWSTR)(pItem + 1);

                        if (pszClassName[0] == L'{')
#else
                                (LPSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
                                (LPSTR)(pItem + 1);

                        if (pszClassName[0] == '{')
#endif
                        {
                                // Item is OLE control: add it to template as custom control

                                // Copy the dialog item template
                                DWORD nSizeElement = (DWORD)(bDialogEx ? sizeof(DLGITEMTEMPLATEEX) : sizeof(DLGITEMTEMPLATE));
                                memcpy(pNew, pItem, nSizeElement);
                                pNew += nSizeElement;

                                // Copy ClassName
                                DWORD nClassName = (lstrlenW(lpstrAxWndClassNameW) + 1) * sizeof(WCHAR);
                                memcpy(pNew, lpstrAxWndClassNameW, nClassName);
                                pNew += nClassName;

                                // Title (CLSID)
                                memcpy(pNew, pszClassName, 78);
                                pNew += 78; // sizeof(L"{00000010-0000-0010-8000-00AA006D2EA4}") - A CLSID

                                DWORD wID = bDialogEx ? ((DLGITEMTEMPLATEEX*)pItem)->id : pItem->id;
                                BYTE* pData;
                                nSizeElement = FindCreateData(wID, pInitData, &pData);

                                // cbExtra
                                *((WORD*)pNew) = (WORD) nSizeElement;
                                pNew += sizeof(WORD);

                                memcpy(pNew, pData, nSizeElement);
                                pNew += nSizeElement;
                                //Align to DWORD
                                pNew += (((~((DWORD_PTR)pNew)) + 1) & 3);

                                // Incrememt item count in new header.
                                ++DlgTemplateItemCount(pNewTemplate);
                        }
                        else
                        {
                                // Item is not an OLE control: copy it to the new template.
                                ULONG cbItem = ULONG((BYTE*)pNextItem - (BYTE*)pItem);
                                ATLASSERT(cbItem >= (size_t)(bDialogEx ?
                                        sizeof(DLGITEMTEMPLATEEX) :
                                        sizeof(DLGITEMTEMPLATE)));
                                memcpy(pNew, pItem, cbItem);
                                pNew += cbItem;

                                // Incrememt item count in new header.
                                ++DlgTemplateItemCount(pNewTemplate);
                        }

                        pItem = pNextItem;
                }
                //ppOleDlgItems[nItems] = (DLGITEMTEMPLATE*)(-1);

                return pNewTemplate;
        }
};

static LRESULT CALLBACK AtlAxWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        switch(uMsg)
        {
        case WM_CREATE:
                {
                // create control from a PROGID in the title
                        // This is to make sure drag drop works
                        ::OleInitialize(NULL);

                        CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
                        int nLen = ::GetWindowTextLength(hWnd);
                        LPTSTR lpstrName = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
                        ::GetWindowText(hWnd, lpstrName, nLen + 1);
                        ::SetWindowText(hWnd, _T(""));
                        IAxWinHostWindow* pAxWindow = NULL;
                        int nCreateSize = 0;
                        if (lpCreate && lpCreate->lpCreateParams)
                                nCreateSize = *((WORD*)lpCreate->lpCreateParams);
                        HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
                        CComPtr<IStream> spStream;
                        if (h && nCreateSize)
                        {
                                BYTE* pBytes = (BYTE*) GlobalLock(h);
                                BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD); 
                                //Align to DWORD
                                //pSource += (((~((DWORD)pSource)) + 1) & 3);
                                memcpy(pBytes, pSource, nCreateSize);
                                GlobalUnlock(h);
                                CreateStreamOnHGlobal(h, TRUE, &spStream);
                        }
                        USES_CONVERSION;
                        CComPtr<IUnknown> spUnk;
                        HRESULT hRet = AtlAxCreateControl(T2COLE(lpstrName), hWnd, spStream, &spUnk);
                        if(FAILED(hRet))
                                return -1;        // abort window creation
                        hRet = spUnk->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
                        if(FAILED(hRet))
                                return -1;        // abort window creation
                        ::SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM)pAxWindow);
                        // check for control parent style if control has a window
                        HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
                        if(hWndChild != NULL)
                        {
                                if(::GetWindowLong(hWndChild, GWL_EXSTYLE) & WS_EX_CONTROLPARENT)
                                {
                                        DWORD dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
                                        dwExStyle |= WS_EX_CONTROLPARENT;
                                        ::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
                                }
                        }
                // continue with DefWindowProc
                }
                break;
        case WM_NCDESTROY:
                {
                        IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
                        if(pAxWindow != NULL)
                                pAxWindow->Release();
                        OleUninitialize();
                }
                break;
        default:
                break;
        }

        return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}




}; //namespace ATL

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLHOST_IMPL
#endif
#endif

#ifdef _ATLHOST_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif


//All exports go here
ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
        AtlAxWinInit();
        HRSRC hDlg = ::FindResourceW(hInstance, lpTemplateName, (LPWSTR)RT_DIALOG);
        HRSRC hDlgInit = ::FindResourceW(hInstance, lpTemplateName, (LPWSTR)_ATL_RT_DLGINIT);
        HGLOBAL hData = NULL;
        BYTE* pInitData = NULL;
        INT_PTR nRet = -1;

        if (hDlgInit)
        {
                hData = ::LoadResource(hInstance, hDlgInit);
                pInitData = (BYTE*) ::LockResource(hData);
        }
        if (hDlg)
        {
                HGLOBAL hResource = LoadResource(hInstance, hDlg);
                DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
                LPCDLGTEMPLATE lpDialogTemplate;
                lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);
                nRet = ::DialogBoxIndirectParamW(hInstance, lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
                if (lpDialogTemplate != pDlg)
                        GlobalFree(GlobalHandle(lpDialogTemplate));
                UnlockResource(hResource);
                FreeResource(hResource);
        }
        if (pInitData && hDlgInit)
        {
                UnlockResource(hData);
                FreeResource(hData);
        }
        return nRet;
}

ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
        AtlAxWinInit();
        HRSRC hDlg = ::FindResourceA(hInstance, lpTemplateName, (LPSTR)RT_DIALOG);
        HRSRC hDlgInit = ::FindResourceA(hInstance, lpTemplateName, (LPSTR)_ATL_RT_DLGINIT);
        HGLOBAL hData = NULL;
        BYTE* pInitData = NULL;
        INT_PTR nRet = -1;

        if (hDlgInit)
        {
                hData = ::LoadResource(hInstance, hDlgInit);
                pInitData = (BYTE*) ::LockResource(hData);
        }
        if (hDlg)
        {
                HGLOBAL hResource = LoadResource(hInstance, hDlg);
                DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
                LPCDLGTEMPLATE lpDialogTemplate;
                lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);
                nRet = ::DialogBoxIndirectParamA(hInstance, lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
                if (lpDialogTemplate != pDlg)
                        GlobalFree(GlobalHandle(lpDialogTemplate));
                UnlockResource(hResource);
                FreeResource(hResource);
        }
        if (pInitData && hDlgInit)
        {
                UnlockResource(hData);
                FreeResource(hData);
        }
        return nRet;
}

ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
        AtlAxWinInit();
        HRSRC hDlg = ::FindResourceW(hInstance, lpTemplateName, (LPWSTR)RT_DIALOG);
        HRSRC hDlgInit = ::FindResourceW(hInstance, lpTemplateName, (LPWSTR)_ATL_RT_DLGINIT);
        HGLOBAL hData = NULL;
        BYTE* pInitData = NULL;
        HWND hWnd = NULL;

        if (hDlgInit)
        {
                hData = ::LoadResource(hInstance, hDlgInit);
                pInitData = (BYTE*) ::LockResource(hData);
        }
        if (hDlg)
        {
                HGLOBAL hResource = LoadResource(hInstance, hDlg);
                DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
                LPCDLGTEMPLATE lpDialogTemplate;
                lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);
                hWnd = ::CreateDialogIndirectParamW(hInstance, lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
                if (lpDialogTemplate != pDlg)
                        GlobalFree(GlobalHandle(lpDialogTemplate));
                UnlockResource(hResource);
                FreeResource(hResource);
        }
        if (pInitData && hDlgInit)
        {
                UnlockResource(hData);
                FreeResource(hData);
        }
        return hWnd;
}

ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
        AtlAxWinInit();
        HRSRC hDlg = ::FindResourceA(hInstance, lpTemplateName, (LPSTR)RT_DIALOG);
        HRSRC hDlgInit = ::FindResourceA(hInstance, lpTemplateName, (LPSTR)_ATL_RT_DLGINIT);
        HGLOBAL hData = NULL;
        BYTE* pInitData = NULL;
        HWND hWnd = NULL;

        if (hDlgInit)
        {
                hData = ::LoadResource(hInstance, hDlgInit);
                pInitData = (BYTE*) ::LockResource(hData);
        }
        if (hDlg)
        {
                HGLOBAL hResource = LoadResource(hInstance, hDlg);
                DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
                LPCDLGTEMPLATE lpDialogTemplate;
                lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);
                hWnd = ::CreateDialogIndirectParamA(hInstance, lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
                if (lpDialogTemplate != pDlg)
                        GlobalFree(GlobalHandle(lpDialogTemplate));
                UnlockResource(hResource);
                FreeResource(hResource);
        }
        if (pInitData && hDlgInit)
        {
                UnlockResource(hData);
                FreeResource(hData);
        }
        return hWnd;
}

ATLINLINE ATLAPI AtlAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer)
{
        return AtlAxCreateControlEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL);
}

ATLINLINE ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
                IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
        AtlAxWinInit();
        HRESULT hr;
        CComPtr<IUnknown> spUnkContainer;
        CComPtr<IUnknown> spUnkControl;

        hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
        if (SUCCEEDED(hr))
        {
                CComPtr<IAxWinHostWindow> pAxWindow;
                spUnkContainer->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
                CComBSTR bstrName(lpszName);
                hr = pAxWindow->CreateControlEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink);
        }
        if (ppUnkContainer != NULL)
        {
                if (SUCCEEDED(hr))
                {
                        *ppUnkContainer = spUnkContainer.p;
                        spUnkContainer.p = NULL;
                }
                else
                        *ppUnkContainer = NULL;
        }
        if (ppUnkControl != NULL)
        {
                if (SUCCEEDED(hr))
                {
                        *ppUnkControl = SUCCEEDED(hr) ? spUnkControl.p : NULL;
                        spUnkControl.p = NULL;
                }
                else
                        *ppUnkControl = NULL;
        }
        return hr;
}

ATLINLINE ATLAPI AtlAxAttachControl(IUnknown* pControl, HWND hWnd, IUnknown** ppUnkContainer)
{
        AtlAxWinInit();
        HRESULT hr;
        if (pControl == NULL)
                return E_INVALIDARG;
        CComPtr<IUnknown> spUnkContainer;
        hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
        if (SUCCEEDED(hr))
        {
                CComPtr<IAxWinHostWindow> pAxWindow;
                spUnkContainer->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
                hr = pAxWindow->AttachControl(pControl, hWnd);
        }
        if (ppUnkContainer != NULL)
        {
                *ppUnkContainer = SUCCEEDED(hr) ? spUnkContainer.p : NULL;
                spUnkContainer.p = NULL;
        }
        return hr;
}

//This either registers a global class (if AtlAxWinInit is in ATL.DLL)
// or it registers a local class
#ifdef _ATL_DLL_IMPL
extern BOOL g_bAtlAxWinInitialized;
#endif

ATLINLINE ATLAPI_(BOOL) AtlAxWinInit()
{
        EnterCriticalSection(&_Module.m_csWindowCreate);
        WM_ATLGETHOST = RegisterWindowMessage(_T("WM_ATLGETHOST"));
        WM_ATLGETCONTROL = RegisterWindowMessage(_T("WM_ATLGETCONTROL"));
        WNDCLASSEX wc;
// first check if the class is already registered
        wc.cbSize = sizeof(WNDCLASSEX);
        BOOL bRet = ::GetClassInfoEx(_Module.GetModuleInstance(), CAxWindow::GetWndClassName(), &wc);

// register class if not

        if(!bRet)
        {
                wc.cbSize = sizeof(WNDCLASSEX);
#ifdef _ATL_DLL_IMPL
                wc.style = CS_GLOBALCLASS;
#else
                wc.style = 0;
#endif
                wc.lpfnWndProc = AtlAxWindowProc;
                wc.cbClsExtra = 0;
                wc.cbWndExtra = 0;
                wc.hInstance = _Module.GetModuleInstance();
                wc.hIcon = NULL;
                wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
                wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
                wc.lpszMenuName = NULL;
                wc.lpszClassName = CAxWindow::GetWndClassName();
                wc.hIconSm = NULL;

                bRet = (BOOL)::RegisterClassEx(&wc);
#ifdef _ATL_DLL_IMPL                
                g_bAtlAxWinInitialized = bRet;
#endif
        }
        LeaveCriticalSection(&_Module.m_csWindowCreate);
        return bRet;
}


ATLINLINE ATLAPI AtlAxGetControl(HWND h, IUnknown** pp)
{
        ATLASSERT(WM_ATLGETCONTROL != 0);
        if (pp == NULL)
                return E_POINTER;
        *pp = (IUnknown*)SendMessage(h, WM_ATLGETCONTROL, 0, 0);
        return (*pp) ? S_OK : E_FAIL;
}

ATLINLINE ATLAPI AtlAxGetHost(HWND h, IUnknown** pp)
{
        ATLASSERT(WM_ATLGETHOST != 0);
        if (pp == NULL)
                return E_POINTER;
        *pp = (IUnknown*)SendMessage(h, WM_ATLGETHOST, 0, 0);
        return (*pp) ? S_OK : E_FAIL;
}

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time 
#undef _ATLHOST_IMPL

#endif // _ATLHOST_IMPL

#endif  // __ATLHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\statreg.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#include <mmc.h>
#include <commctrl.h>

#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")

template <class T, bool bAutoDelete = true>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
        PROPSHEETPAGE m_psp;

        operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

                if(lpszTitle != NULL)
                {
                        m_psp.pszTitle = lpszTitle;
                        m_psp.dwFlags |= PSP_USETITLE;
                }
        }

        static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
        {
                ATLASSERT(hWnd == NULL);
                if(uMsg == PSPCB_CREATE)
                {
                        CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
                        _Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
                }
                if (bAutoDelete && uMsg == PSPCB_RELEASE)
                {
                        T* pPage = (T*)ppsp->lParam;
                        delete pPage;
                }

                return 1;
        }

        HPROPSHEETPAGE Create()
        {
                return ::CreatePropertySheetPage(&m_psp);
        }

        BOOL EndDialog(int)
        {
                // do nothing here, calling ::EndDialog will close the whole sheet
                ATLASSERT(FALSE);
                return FALSE;
        }

// Operations
        void CancelToClose()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ATLASSERT(GetParent() != NULL);

                ::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
        }
        void SetModified(BOOL bChanged = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ATLASSERT(GetParent() != NULL);

                if(bChanged)
                        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
                else
                        ::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
        }
        LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ATLASSERT(GetParent() != NULL);

                return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
        }

        typedef CSnapInPropertyPageImpl< T, bAutoDelete > thisClass;
        BEGIN_MSG_MAP(thisClass)
                MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
        END_MSG_MAP()

// Message handler
        LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                NMHDR* pNMHDR = (NMHDR*)lParam;

                // don't handle messages not from the page/sheet itself
                if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
                {
                        bHandled = FALSE;
                        return 1;
                }

                T* pT = (T*)this;
                LRESULT lResult = 0;
                // handle default
                switch(pNMHDR->code)
                {
                case PSN_SETACTIVE:
                        lResult = pT->OnSetActive() ? 0 : -1;
                        break;
                case PSN_KILLACTIVE:
                        lResult = !pT->OnKillActive();
                        break;
                case PSN_APPLY:
                        lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
                        break;
                case PSN_RESET:
                        pT->OnReset();
                        break;
                case PSN_QUERYCANCEL:
                        lResult = !pT->OnQueryCancel();
                        break;
                case PSN_WIZNEXT:
                        lResult = !pT->OnWizardNext();
                        break;
                case PSN_WIZBACK:
                        lResult = !pT->OnWizardBack();
                        break;
                case PSN_WIZFINISH:
                        lResult = !pT->OnWizardFinish();
                        break;
                case PSN_HELP:
                        lResult = pT->OnHelp();
                        break;
                default:
                        bHandled = FALSE;        // not handled
                }

                return lResult;
        }

// Overridables
        BOOL OnSetActive()
        {
                return TRUE;
        }
        BOOL OnKillActive()
        {
                return TRUE;
        }
        BOOL OnApply()
        {
                return TRUE;
        }
        void OnReset()
        {
        }
        BOOL OnQueryCancel()
        {
                return TRUE;    // ok to cancel
        }
        BOOL OnWizardBack()
        {
                return TRUE;
        }
        BOOL OnWizardNext()
        {
                return TRUE;
        }
        BOOL OnWizardFinish()
        {
                return TRUE;
        }
        BOOL OnHelp()
        {
                return TRUE;
        }
};

class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
        CSnapInItem* m_pItem;
        DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem 
{
public:
        virtual ~CSnapInItem()
        {
        }
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
                IComponentData* pComponentData,
                IComponent* pComponent,
                DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
                DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(Command)(long lCommandID,        
                CSnapInObjectRootBase* pObj,                
                DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
                IUnknown* pUnk,
                DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
                CSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
                CSimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
                CSnapInObjectRootBase* pObj,
                DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

        STDMETHOD(FillData)(CLIPFORMAT cf, 
                LPSTREAM pStream) = 0;

        virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
        {
                _ASSERTE(0 && "Override this function in derived class");
        }

        static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
        {
                if (ppItem == NULL)
                        return E_POINTER;
                if (pType == NULL)
                        return E_POINTER;

                if (IS_SPECIAL_DATAOBJECT(pDataObj))
                        return E_NOTIMPL;

                *ppItem = NULL;
                *pType = CCT_UNINITIALIZED;

                STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
                FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA, 
                        NULL, 
                        DVASPECT_CONTENT, 
                        -1, 
                        TYMED_HGLOBAL 
                };

                stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
                if (stgmedium.hGlobal == NULL)
                        return E_OUTOFMEMORY;

                HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
                if (SUCCEEDED(hr))
                {
                        CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
                         *ppItem = pData->m_pItem;
                         *pType = pData->m_type;
                }
                
                GlobalFree(stgmedium.hGlobal);
                
                return hr;
        }


        virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

        static void Init()
        {
                m_CCF_NODETYPE                        = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
                m_CCF_SZNODETYPE                = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));  
                m_CCF_DISPLAY_NAME                = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME")); 
                m_CCF_SNAPIN_CLASSID        = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
                m_CCF_SNAPIN_GETOBJECTDATA        = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
                m_CCF_MMC_MULTISELECT_DATAOBJECT        = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
        }
public:
        static CLIPFORMAT m_CCF_NODETYPE;
        static CLIPFORMAT m_CCF_SZNODETYPE;
        static CLIPFORMAT m_CCF_DISPLAY_NAME;
        static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
        static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
        static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;
};

class CSnapInObjectRootBase
{
public:
        CComPtr <IControlbar> m_spControlbar;
        CSimpleMap <UINT, IUnknown*> m_toolbarMap;
        const int m_nType;

        CSnapInObjectRootBase(int n = 0) : m_nType(n)
        {
        }
        HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
        {
                return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
        }
};

template <int n, class ComponentData>
class CSnapInObjectRoot : public CSnapInObjectRootBase
{
public :
        CSnapInObjectRoot() : CSnapInObjectRootBase(n)
        {
                m_pComponentData = NULL;
        }
        ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
        HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
        { \
                if (ppItem == NULL) \
                        return E_POINTER; \
                if (pType == NULL) \
                        return E_POINTER; \
\
                *ppItem = NULL; \
\
                *pType = CCT_UNINITIALIZED; \
\
                STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
                FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
                        NULL, \
                        DVASPECT_CONTENT, \
                        -1, \
                        TYMED_HGLOBAL \
                }; \
\
                stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
                if (stgmedium.hGlobal == NULL) \
                        return E_OUTOFMEMORY; \
\
                HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
                if (FAILED(hr)) \
                { \
                        GlobalFree(stgmedium.hGlobal); \
                        return hr; \
                } \
\
                GUID guid; \
                memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
                GlobalFree(stgmedium.hGlobal); \
                hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
                if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
                { \
                        *ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
                        _ASSERTE(*ppItem != NULL); \
                        (*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
                        return hr; \
                }

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
                        return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
        };

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
        public CComObjectRoot
{
public:
        BEGIN_COM_MAP(CSnapInDataObjectImpl)
                COM_INTERFACE_ENTRY(IDataObject)
        END_COM_MAP()
        STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
        }

        STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("SnapInDataObjectImpl::GetDataHere\n"));
                if (pmedium == NULL)
                        return E_POINTER;

                HRESULT hr = DV_E_TYMED;
                // Make sure the type medium is HGLOBAL
                if (pmedium->tymed == TYMED_HGLOBAL)
                {
                        // Create the stream on the hGlobal passed in
                        CComPtr<IStream> spStream;
                        hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
                        if (SUCCEEDED(hr))
                                if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
                                {
                                        hr = DV_E_CLIPFORMAT;
                                        ULONG uWritten;
                                        hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
                                }
                                else
                                        hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
                }
                return hr;
        }

        STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
        }
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
        }
        STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
        }
        STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
        }
        STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
                DWORD *pdwConnection)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
        }
        STDMETHOD(DUnadvise)(DWORD dwConnection)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
        }
        STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
        }

        CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
        IComponentDataImpl()
        {
                m_pNode = NULL;
        }

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Initialize\n"));

                HRESULT hr = E_POINTER;

                ATLASSERT(pUnknown != NULL);
                if (pUnknown == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::Initialize called with pUnknown == NULL\n"));
                else
                {
                        hr = pUnknown->QueryInterface(&m_spConsole);
                        if (FAILED(hr))
                                ATLTRACE2(atlTraceSnapin, 0, _T("QI for IConsole failed\n"));
                }

                return hr;
        }

        STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::CreateComponent\n"));

                HRESULT hr = E_POINTER;

                ATLASSERT(ppComponent != NULL);
                if (ppComponent == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
                else
                {
                        *ppComponent = NULL;
                        
                        CComObject< Component >* pComponent;
                        hr = CComObject< Component >::CreateInstance(&pComponent);
                        ATLASSERT(SUCCEEDED(hr));
                        if (FAILED(hr))
                                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::CreateComponent : Could not create IComponent object\n"));
                        else
                        {
                                pComponent->m_pComponentData = static_cast<T*>(this);
                                hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
                        }
                }
                return hr;
        }

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Notify\n"));
                ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));
                HRESULT hr = E_POINTER;

                ATLASSERT(lpDataObject != NULL);
                if (lpDataObject == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::Notify called with lpDataObject == NULL\n"));
                else
                {
                        T* pT = static_cast<T*>(this);
                        CSnapInItem* pItem;
                        DATA_OBJECT_TYPES type;
                        hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
                        ATLASSERT(SUCCEEDED(hr));
                        if (SUCCEEDED(hr))
                                hr = pItem->Notify(event, arg, param, pT, NULL, type);
                }
                return hr;
        }

    STDMETHOD(Destroy)(void)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Destroy\n"));

                T* pT = static_cast<T*>(this);
                if (pT->m_spControlbar != NULL)
                {
                        int n = pT->m_toolbarMap.GetSize();
                        for (int i = 0; i < n; i++)
                        {
                                IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
                                 if (pToolbar != NULL)
                                 {
                                        pT->m_spControlbar->Detach(pToolbar);
                                        pToolbar->Release();
                                 }
                        }
                }
                pT->m_toolbarMap.RemoveAll();

                m_spConsole.Release();
                return S_OK;
        }

    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::QueryDataObject\n"));
                HRESULT hr = E_POINTER;
                
                ATLASSERT(ppDataObject != NULL);
                if (ppDataObject == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
                else
                {
                        *ppDataObject = NULL;
                        
                        CSnapInItem* pItem = (CSnapInItem*) cookie;
                        if (cookie == NULL)
                                pItem = m_pNode;

                        hr = pItem->GetDataObject(ppDataObject, type);
                }
                return hr;
        }
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::GetDisplayInfo\n"));


                HRESULT hr = E_POINTER;
                
                ATLASSERT(pScopeDataItem != NULL);
                if (pScopeDataItem == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
                else
                {
                        CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
                        if (pItem == NULL)
                                pItem = m_pNode;

                        hr = E_UNEXPECTED;
                        if (pItem != NULL)
                                hr = pItem->GetScopePaneInfo(pScopeDataItem);
                }
                return hr;
        }
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
        {
                ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

        CComPtr<IConsole> m_spConsole;
        CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Initialize\n"));

                HRESULT hr = E_POINTER;

                ATLASSERT(lpConsole != NULL);
                if (lpConsole == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("lpConsole is NULL\n"));
                else
                {
                        m_spConsole = lpConsole;
        
                        CComPtr<IHeaderCtrl> spHeaderCtrl;
                        hr = m_spConsole.QueryInterface(&spHeaderCtrl);
                        if (FAILED(hr))
                                ATLTRACE2(atlTraceSnapin, 0, _T("QI for IHeaderCtrl failed\n"));
                        else
                        {
                                hr = m_spConsole->SetHeader(spHeaderCtrl);
                                if (FAILED(hr))
                                        ATLTRACE2(atlTraceSnapin, 0, _T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
                        }
                }
                return hr;
        }
    
        STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Notify\n"));
                ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));                
                HRESULT hr = E_POINTER;

                if (lpDataObject == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::Notify called with lpDataObject==NULL \n"));
                else
                {
                        T* pT = static_cast<T*>(this);
                        CSnapInItem* pItem;
                        DATA_OBJECT_TYPES type;
                        // Make sure that the object is derived from CSnapInObjectRoot
                        hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
                        if (SUCCEEDED(hr))
                                hr = pItem->Notify(event, arg, param, NULL, pT, type);
                }
                return hr;
        }
    
    STDMETHOD(Destroy)(MMC_COOKIE cookie)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Destroy\n"));

                T* pT = static_cast<T*>(this);

                if (pT->m_spControlbar != NULL)
                {
                        int n = pT->m_toolbarMap.GetSize();
                        for (int i = 0; i < n; i++)
                        {
                                IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
                                 if (pToolbar != NULL)
                                 {
                                        pT->m_spControlbar->Detach(pToolbar);
                                        pToolbar->Release();
                                 }
                        }
                }
                pT->m_toolbarMap.RemoveAll();

                m_spConsole->SetHeader(NULL);
                m_spConsole.Release();
                return S_OK;
        }
    
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::QueryDataObject\n"));

                ATLASSERT(ppDataObject != NULL);
                if (ppDataObject == NULL)
                {
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
                        return E_POINTER;
                }
                
                if (cookie == NULL)
                {
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with cookie==NULL \n"));
                        return E_UNEXPECTED;
                }

                *ppDataObject = NULL;
                if (cookie == MMC_MULTI_SELECT_COOKIE)
                {
                        ATLTRACE2(atlTraceSnapin, 0, _T("Override QueryDataObject to handle multiselect\n"));
                        return E_UNEXPECTED;
                }

                CSnapInItem* pItem = (CSnapInItem*) cookie;
                return pItem->GetDataObject(ppDataObject, type);
        }
    
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::GetResultViewType\n"));

                HRESULT hr = E_FAIL;
                if (cookie == NULL)
                {
                        T* pT = static_cast<T*> (this);
                        ATLASSERT( pT->m_pComponentData != NULL );
                        ATLASSERT( pT->m_pComponentData->m_pNode != NULL );
                        hr = pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
                }
                else
                {
                        CSnapInItem* pItem = (CSnapInItem*)cookie;
                        hr = pItem->GetResultViewType(ppViewType, pViewOptions);
                }
                return hr;
        }
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::GetDisplayInfo\n"));

                ATLASSERT(pResultDataItem != NULL);
                if (pResultDataItem == NULL)
                {
                        ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
                        return E_POINTER;
                }

                CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

                if (pItem == NULL)
                {
                        ATLTRACE2(atlTraceSnapin, 0, _T("Invalid Item\n"));
                        return E_UNEXPECTED;
                }
                return pItem->GetResultPaneInfo(pResultDataItem);
        }
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
        {
                ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
        }

        CComPtr<IConsole> m_spConsole;
};

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(LPARAM lUserParam,
        MMC_COOKIE cookieA,
        MMC_COOKIE cookieB,
        int *pnResult)
        {
                ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
        }
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::AddMenuItems\n"));

                HRESULT hr = E_POINTER;

                ATLASSERT(pDataObject != NULL);
                if (pDataObject == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
                else
                {
                        T* pT = static_cast<T*>(this);
                        CSnapInItem* pItem;
                        DATA_OBJECT_TYPES type;
                        hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

                        if (SUCCEEDED(hr))
                                hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
                }
                return hr;
        }
    
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::Command\n"));

                HRESULT hr = E_POINTER;

                ATLASSERT(pDataObject != NULL);
                if (pDataObject == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
                else
                {
                        T* pT = static_cast<T*>(this);
                        CSnapInItem* pItem;
                        DATA_OBJECT_TYPES type;
                        hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
                        
                        if (SUCCEEDED(hr))
                                hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
                }
                return hr;
        }
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
        STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

                HRESULT hr = E_POINTER;

                ATLASSERT(pDataObject != NULL);
                if (pDataObject == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
                else
                {
                        T* pT = static_cast<T*>(this);
                        CSnapInItem* pItem;
                        DATA_OBJECT_TYPES type;
                        hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

                        if (SUCCEEDED(hr))
                                hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
                }

                return hr;
        }
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::QueryPagesFor\n"));
                

                HRESULT hr = E_POINTER;
                
                ATLASSERT(pDataObject != NULL);
                if (pDataObject == NULL)
                        ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
                else
                {
                        T* pT = static_cast<T*>(this);
                        CSnapInItem* pItem;
                        DATA_OBJECT_TYPES type;
                        hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

                        if (SUCCEEDED(hr))
                                hr = pItem->QueryPagesFor(type);
                }
                return hr;
        }
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
        STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IExtendControlbarImpl::SetControlbar\n"));
                T* pT = static_cast<T*>(this);

                if (pT->m_spControlbar != NULL)
                {
                        int n = pT->m_toolbarMap.GetSize();
                        for (int i = 0; i < n; i++)
                        {
                                IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
                                 if (pToolbar != NULL)
                                 {
                                        pT->m_spControlbar->Detach(pToolbar);
                                        pToolbar->Release();
                                 }
                        }
                }
                pT->m_toolbarMap.RemoveAll();

                pT->m_spControlbar = pControlbar;
                return S_OK;
        }
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("IExtendControlbarImpl::ControlbarNotify\n"));

                CSnapInItem* pItem = NULL;
                DATA_OBJECT_TYPES type;
                HRESULT hr = S_OK;
                T* pT = static_cast<T*>(this);

                if (event == MMCN_BTN_CLICK)
                        hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
                else if (event == MMCN_SELECT)
                {
                        hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
                        BOOL bSelect = (BOOL) HIWORD (arg);
                        BOOL bScope = (BOOL) LOWORD(arg); 
                        if (bSelect)
                        {
                                int n = pT->m_toolbarMap.GetSize();
                                for (int i = 0; i < n; i++)
                                {
                                        IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
                                         if (pToolbar != NULL)
                                                pT->m_spControlbar->Detach(pToolbar);
                                }
                        }
                }

                if (SUCCEEDED(hr))
                        hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

                return hr;
        }
};

#define SNAPINMENUID(id) \
public: \
        static const UINT GetMenuID() \
        { \
                static const UINT IDMENU = id; \
                return id; \
        }

#define EXT_SNAPINMENUID(id) \
public: \
        static const UINT GetMenuID() \
        { \
                static const UINT IDMENU = id; \
                return id; \
        }

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
        HRESULT ProcessCommand(UINT nID, \
                bool& bHandled, \
                CSnapInObjectRootBase* pObj, \
                DATA_OBJECT_TYPES type) \
        { \
                        bHandled = true; \
                        HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
                if (id == nID) \
                { \
                        hr = func(bHandled, pObj); \
                        if (bHandled) \
                                return hr; \
                }

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
                if (id1 >= nID && nID <= id2) \
                { \
                        hr = func(nID, bHandled, pObj); \
                        if (bHandled) \
                                return hr; \
                }

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
        { \
                hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
                if (bHandled) \
                        return hr; \
        }

#define END_SNAPINCOMMAND_MAP() \
                        return hr; \
        }

struct CSnapInToolBarData
{
        WORD wVersion;
        WORD wWidth;
        WORD wHeight;
        WORD wItemCount;
        //WORD aItems[wItemCount]

        WORD* items()
                { return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
        
class CSnapInToolbarInfo
{
public:
        void __stdcall CleanUp(DWORD_PTR dw)
        {
                if (m_pStrToolTip)
                {
                        for (UINT i = 0; i < m_nButtonCount; i++)
                        {
                                delete m_pStrToolTip[i];
                                m_pStrToolTip[i] = NULL;
                        }
                        delete [] m_pStrToolTip;
                        m_pStrToolTip = NULL;
                }

                if (m_pStrButtonText)
                {
                        for (UINT i = 0; i < m_nButtonCount; i++)
                        {
                                delete m_pStrButtonText[i];
                                m_pStrButtonText[i] = NULL;
                        }

                        delete [] m_pStrButtonText;
                        m_pStrButtonText = NULL;
                }
                if (m_pnButtonID)
                {
                        delete m_pnButtonID;
                        m_pnButtonID = NULL;
                }

                m_nButtonCount = 0;
        }

        OLECHAR** m_pStrToolTip;
        OLECHAR** m_pStrButtonText;
        UINT* m_pnButtonID;
        UINT m_idToolbar;
        UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
        static CSnapInToolbarInfo* GetToolbarInfo() \
        { \
                static CSnapInToolbarInfo m_toolbarInfo[] = \
                {

#define SNAPINTOOLBARID_ENTRY(id) \
                        { NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
                        { NULL, NULL, NULL, 0, 0} \
                }; \
                return m_toolbarInfo; \
        }

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
        CSnapInItemImpl()
        {
        }

        virtual ~CSnapInItemImpl()
        {
        }    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
                IComponentData* pComponentData,
                IComponent* pComponent,
                DATA_OBJECT_TYPES type)
        {
                ATLASSERT("Override Function in Derived Class");
                ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
        }
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
        {
                ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
        }
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::GetResultViewType\n"));
                *ppViewType = NULL;
                *pViewOptions = MMC_VIEW_OPTIONS_NONE;
                return S_FALSE;
        }
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
        {
                ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
        }
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
                DATA_OBJECT_TYPES type)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::AddMenuItems\n"));
                T* pT = static_cast<T*>(this);

                if (!bIsExtension)
                        pT->SetMenuInsertionFlags(true, pInsertionAllowed);

                UINT menuID = pT->GetMenuID();
                if (menuID == 0)
                        return S_OK;

                HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
                long insertionID;
                if (hMenu)
                {
                        for (int i = 0; 1; i++)
                        {
                                HMENU hSubMenu = GetSubMenu(hMenu, i);
                                if (hSubMenu == NULL)
                                        break;
                                
                                MENUITEMINFO menuItemInfo;
                                memset(&menuItemInfo, 0, sizeof(menuItemInfo));
                                menuItemInfo.cbSize = sizeof(menuItemInfo);

                                switch (i)
                                {
                                case 0:
                                        if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
                                                continue;
                                        insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                                        break;

                                case 1:
                                        if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
                                                continue;
                                        if (bIsExtension)
                                                insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
                                        else
                                                insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
                                        break;

                                case 2:;
                                        if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
                                                continue;
                                        if (bIsExtension)
                                                insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
                                        else
                                                insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                                        break;
                                case 3:;
                                        if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
                                                continue;
                                        insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
                                        break;
                                default:
                                        {
                                                insertionID = 0;
                                                continue;
                                        }
                                        break;
                                }

                                menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
                                menuItemInfo.fType = MFT_STRING;
                                TCHAR szMenuText[128];

                                for (int j = 0; 1; j++)
                                {
                                        menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
                                        menuItemInfo.fType = MFT_STRING;
                                        menuItemInfo.cch = 128;
                                        menuItemInfo.dwTypeData = szMenuText;
                                        TCHAR szStatusBar[256];

                                        if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
                                                break;
                                        if (menuItemInfo.fType != MFT_STRING)
                                                continue;

                                        pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
                                        LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

                                        OLECHAR wszStatusBar[256];
                                        OLECHAR wszMenuText[128];
                                        USES_CONVERSION;
                                        ocscpy(wszMenuText, T2OLE(szMenuText));
                                        ocscpy(wszStatusBar, T2OLE(szStatusBar));

                                        CONTEXTMENUITEM contextMenuItem;
                                        contextMenuItem.strName = wszMenuText;
                                        contextMenuItem.strStatusBarText = wszStatusBar;
                                        contextMenuItem.lCommandID = menuItemInfo.wID;
                                        contextMenuItem.lInsertionPointID = insertionID;
                                        contextMenuItem.fFlags = menuItemInfo.fState;
                                        contextMenuItem.fSpecialFlags = 0;
                                        
                                        HRESULT hr = piCallback->AddItem(&contextMenuItem);
                                        ATLASSERT(SUCCEEDED(hr));
                                }
                        }
                        DestroyMenu(hMenu);
                }

                if (!bIsExtension)
                        pT->SetMenuInsertionFlags(true, pInsertionAllowed);

                return S_OK;
        }
    
    STDMETHOD(Command)(long lCommandID,
                CSnapInObjectRootBase* pObj,
                DATA_OBJECT_TYPES type)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::Command\n"));
                bool bHandled;
                T* pT = static_cast<T*>(this);
                return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
        }
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
                IUnknown* pUnk,
                DATA_OBJECT_TYPES type)
        {
                ATLASSERT("Override Function in Derived Class");
                ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
        }
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
        {
                ATLASSERT("Override Function in Derived Class");
                ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
        }

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, 
                IExtendControlbar* pExtendControlBar,
                CSimpleMap<UINT, IUnknown*>* pToolbarMap)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::SetControlbar\n"));
                static bool m_bAddTermFunc = false;
                if (!m_bAddTermFunc)
                {
                        m_bAddTermFunc = true;
                        AtlModuleAddTermFunc(&_Module, CleanUpToolbarInfo, 0);
                }

                T* pT = static_cast<T*>(this);

                CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
                if (pInfo == NULL)
                        return S_OK;

                for( ; pInfo->m_idToolbar; pInfo++)
                {
                        IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
                        if (p != NULL)
                                continue;

                        HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
                        if (hBitmap == NULL)
                                return S_OK;

                        HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
                        if (hRsrc == NULL)
                                return S_OK;

                        HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
                        if (hGlobal == NULL)
                                return S_OK;

                        CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
                        if (pData == NULL)
                                return S_OK;
                        ATLASSERT(pData->wVersion == 1);
                        ATLASSERT(pData->wWidth == 16);
                        ATLASSERT(pData->wHeight == 16);

                        pInfo->m_nButtonCount = pData->wItemCount;
                        if (pInfo->m_pnButtonID == NULL)
                                pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

                        if (pInfo->m_pnButtonID == NULL)
                                continue;

                        MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
                        if (pButtons == NULL)
                        {
                                delete []pInfo->m_pnButtonID;
                                continue;
                        }
                        
                        if (pInfo->m_pStrToolTip == NULL)
                        {
                                pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount];
                                if (pInfo->m_pStrToolTip)
                                        memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
                        }

                        if (pInfo->m_pStrToolTip == NULL)
                        {
                                delete []pInfo->m_pnButtonID;
                                delete []pButtons;
                                continue;
                        }
                
                        for (int i = 0, j = 0; i < pData->wItemCount; i++)
                        {
                                pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
                                if (pButtons[i].idCommand)
                                {
                                        pButtons[i].nBitmap = j++;
                                        // get the statusbar string and allow modification of the button state
                                        TCHAR szStatusBar[512];
                                        LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, szStatusBar, 512);

                                        if (pInfo->m_pStrToolTip[i] == NULL)
                                                pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1];
                                        if (pInfo->m_pStrToolTip[i] == NULL)
                                                continue;
                                        USES_CONVERSION;
                                        ocscpy(pInfo->m_pStrToolTip[i], T2OLE(szStatusBar));
                                        pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
                                        pButtons[i].lpButtonText = OLESTR("");
                                        pButtons[i].fsState = TBSTATE_ENABLED;
                                        pButtons[i].fsType = TBSTYLE_BUTTON;
                                        pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
                                }
                                else
                                {
                                        pButtons[i].lpTooltipText = OLESTR("");
                                        pButtons[i].lpButtonText = OLESTR("");
                                        pButtons[i].fsType = TBSTYLE_SEP;
                                        pButtons[i].fsState = 0;
                                }
                        }

                        IToolbar* pToolbar;
                HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
                        if (SUCCEEDED(hr))
                        {

                                hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
                                if (SUCCEEDED(hr))
                                {
                                        hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
                                        if (SUCCEEDED(hr))
                                        {
                                                pToolbar->AddRef();
                                                pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
                                        }
                                }
                        }
                        pToolbar->Release();
                        delete [] pButtons;
                }
                return S_OK;
        }
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
                CSimpleMap<UINT, IUnknown*>* pToolbarMap,
                MMC_NOTIFY_TYPE event,
        LPARAM arg, 
                LPARAM param,
                CSnapInObjectRootBase* pObj,
                DATA_OBJECT_TYPES type)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::ControlbarNotify\n"));
                T* pT = static_cast<T*>(this);

                SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

                if(event == MMCN_SELECT)
                {
                        if (pControlbar == NULL)
                                return S_OK;

                        BOOL bSelect = (BOOL) HIWORD (arg);
                        if (!bSelect)
                                return S_OK;
                        BOOL bScope = (BOOL) LOWORD(arg); 

                        CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
                        if (pInfo == NULL)
                                return S_OK;

                        for(; pInfo->m_idToolbar; pInfo++)
                        {
                                IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
                                if (pToolbar == NULL)
                                        continue;
                                pControlbar->Attach(TOOLBAR, pToolbar);
                                for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
                                {
                                        if (pInfo->m_pnButtonID[i])
                                        {
                                                pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                                                        ENABLED,
                                                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                                                                ENABLED));
                                                pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                                                        CHECKED,
                                                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                                                                CHECKED));
                                                pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                                                        HIDDEN,
                                                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                                                                HIDDEN));
                                                pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                                                        INDETERMINATE,
                                                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                                                                INDETERMINATE));
                                                pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                                                        BUTTONPRESSED,
                                                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                                                                BUTTONPRESSED));
                                        }
                                }
                        }
                        return S_OK;
                }
                else if (event == MMCN_BTN_CLICK)
                {
                        bool bHandled;
                        return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
                }

                return E_UNEXPECTED;
        }

        STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
        {
                if (pScopeDataItem == NULL)
                        return E_FAIL;

                *pScopeDataItem = &m_scopeDataItem;
                return S_OK;
        }
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
        {
                if (pResultDataItem == NULL)
                        return E_FAIL;

                *pResultDataItem = &m_resultDataItem;
                return S_OK;
        }

        STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
        {
                CComObject<CSnapInDataObjectImpl>* pData;
                HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
                if (FAILED(hr))
                        return hr;

                T* pT = static_cast<T*> (this);
                pData->m_objectData.m_pItem = pT;
                pData->m_objectData.m_type = type;

                hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
                return hr;
        }

        void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
        {
                return;
        }

        void SetToolbarButtonInfo(UINT id, BYTE *pfsState, BYTE *pfsType)
        {
                *pfsState = TBSTATE_ENABLED;
                *pfsType = TBSTYLE_BUTTON;
        }

        BOOL UpdateToolbarButton(UINT id, BYTE fsState)
        {
                if (fsState == ENABLED)
                        return TRUE;
                return FALSE;
        }

        HRESULT ProcessCommand(UINT nID, 
                bool& bHandled,
                CSnapInObjectRootBase* pObj,
                DATA_OBJECT_TYPES type)
        {
                ATLTRACE2(atlTraceSnapin, 0, _T("No handler for item with ID %d\n"), nID);
                return S_OK;
        }

        STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
        {
                HRESULT hr = DV_E_CLIPFORMAT;
                ULONG uWritten;

                T* pT = static_cast<T*> (this);

                if (cf == m_CCF_NODETYPE)
                {
                        hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
                        return hr;
                }

                if (cf == m_CCF_SZNODETYPE)
                {
                        hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
                        return hr;
                }

                if (cf == m_CCF_DISPLAY_NAME)
                {
                        hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
                        return hr;
                }

                if (cf == m_CCF_SNAPIN_CLASSID)
                {
                        hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
                        return hr;
                }

                return hr;
        }

        static CSnapInToolbarInfo* GetToolbarInfo()
        {
                return NULL;
        }
        static void _stdcall CleanUpToolbarInfo(DWORD_PTR dw)
        {
                for (CSnapInToolbarInfo* pInfo = T::GetToolbarInfo(); pInfo->m_idToolbar != 0; pInfo++)
                {
                        pInfo->CleanUp(dw);
                }
        }


        static const UINT GetMenuID() 
        {
                return 0;
        }

        void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed)
        {
        }

        void* GetNodeType()
        {
                return (void*)T::m_NODETYPE;
        }
        void* GetSZNodeType()
        {
                return (void*)T::m_SZNODETYPE;
        }

        void* GetDisplayName()
        {
                return (void*)T::m_SZDISPLAY_NAME;
        }

        void* GetSnapInCLSID()
        {
                return (void*)T::m_SNAPIN_CLASSID;
        }

        CComBSTR m_bstrDisplayName;
        SCOPEDATAITEM m_scopeDataItem;
        RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\atlwin.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN_H__
#define __ATLWIN_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
        #error atlwin.h requires atlbase.h to be included first
#endif

struct _ATL_WNDCLASSINFOA;
struct _ATL_WNDCLASSINFOW;


#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

ATLAPI_(ATOM) AtlModuleRegisterWndClassInfoA(_ATL_MODULE* pM, _ATL_WNDCLASSINFOA* p, WNDPROC* pProc);
ATLAPI_(ATOM) AtlModuleRegisterWndClassInfoW(_ATL_MODULE* pM, _ATL_WNDCLASSINFOW* p, WNDPROC* pProc);

#ifdef UNICODE
#define AtlModuleRegisterWndClassInfo AtlModuleRegisterWndClassInfoW
#else
#define AtlModuleRegisterWndClassInfo AtlModuleRegisterWndClassInfoA
#endif


#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd);
ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix);
ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric);


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

struct _ATL_WNDCLASSINFOA
{
        WNDCLASSEXA m_wc;
        LPCSTR m_lpszOrigName;
        WNDPROC pWndProc;
        LPCSTR m_lpszCursorID;
        BOOL m_bSystemCursor;
        ATOM m_atom;
    CHAR m_szAutoName[sizeof("ATL:") + (sizeof(PVOID)*2)+1];
        ATOM Register(WNDPROC* p)
        {
                return AtlModuleRegisterWndClassInfoA(&_Module, this, p);
        }
};
struct _ATL_WNDCLASSINFOW
{
        WNDCLASSEXW m_wc;
        LPCWSTR m_lpszOrigName;
        WNDPROC pWndProc;
        LPCWSTR m_lpszCursorID;
        BOOL m_bSystemCursor;
        ATOM m_atom;
    WCHAR m_szAutoName[sizeof("ATL:") + (sizeof(PVOID)*2)+1];
        ATOM Register(WNDPROC* p)
        {
                return AtlModuleRegisterWndClassInfoW(&_Module, this, p);
        }
};

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CWindow;
#ifndef _ATL_NO_HOSTING
template <class TBase = CWindow> class CAxWindowT;
#endif //!_ATL_NO_HOSTING
class CMessageMap;
class CDynamicChain;
typedef _ATL_WNDCLASSINFOA CWndClassInfoA;
typedef _ATL_WNDCLASSINFOW CWndClassInfoW;
#ifdef UNICODE
#define CWndClassInfo CWndClassInfoW
#else
#define CWndClassInfo CWndClassInfoA
#endif
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CWindowImpl;
template <class T, class TBase = CWindow> class CDialogImpl;
#ifndef _ATL_NO_HOSTING
template <class T, class TBase = CWindow> class CAxDialogImpl;
#endif //!_ATL_NO_HOSTING
template <WORD t_wDlgTemplateID, BOOL t_bCenter = TRUE> class CSimpleDialog;
template <class TBase = CWindow, class TWinTraits = CControlWinTraits> class CContainedWindowT;

/////////////////////////////////////////////////////////////////////////////
// CWindow - client side for a Windows window

class CWindow
{
public:
        static RECT rcDefault;
        HWND m_hWnd;

        CWindow(HWND hWnd = NULL)
        {
                m_hWnd = hWnd;
        }

        CWindow& operator=(HWND hWnd)
        {
                m_hWnd = hWnd;
                return *this;
        }

        static LPCTSTR GetWndClassName()
        {
                return NULL;
        }

        void Attach(HWND hWndNew)
        {
                ATLASSERT(::IsWindow(hWndNew));
                m_hWnd = hWndNew;
        }

        HWND Detach()
        {
                HWND hWnd = m_hWnd;
                m_hWnd = NULL;
                return hWnd;
        }

        HWND Create(LPCTSTR lpstrWndClass, HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
                        DWORD dwStyle = 0, DWORD dwExStyle = 0,
                        UINT nID = 0, LPVOID lpCreateParam = NULL)
        {
                m_hWnd = ::CreateWindowEx(dwExStyle, lpstrWndClass, szWindowName,
                        dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
                        rcPos.bottom - rcPos.top, hWndParent, (HMENU)(DWORD_PTR)nID,
                        _Module.GetModuleInstance(), lpCreateParam);
                return m_hWnd;
        }

        HWND Create(LPCTSTR lpstrWndClass, HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
                        DWORD dwStyle = 0, DWORD dwExStyle = 0,
                        HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
        {
                if(lpRect == NULL)
                        lpRect = &rcDefault;
                m_hWnd = ::CreateWindowEx(dwExStyle, lpstrWndClass, szWindowName,
                        dwStyle, lpRect->left, lpRect->top, lpRect->right - lpRect->left,
                        lpRect->bottom - lpRect->top, hWndParent, hMenu,
                        _Module.GetModuleInstance(), lpCreateParam);
                return m_hWnd;
        }

        BOOL DestroyWindow()
        {
                ATLASSERT(::IsWindow(m_hWnd));

                if(!::DestroyWindow(m_hWnd))
                        return FALSE;

                m_hWnd = NULL;
                return TRUE;
        }

// Attributes

        operator HWND() const { return m_hWnd; }

        DWORD GetStyle() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return (DWORD)::GetWindowLong(m_hWnd, GWL_STYLE);
        }

        DWORD GetExStyle() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return (DWORD)::GetWindowLong(m_hWnd, GWL_EXSTYLE);
        }

        LONG GetWindowLong(int nIndex) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowLong(m_hWnd, nIndex);
        }

        LONG SetWindowLong(int nIndex, LONG dwNewLong)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetWindowLong(m_hWnd, nIndex, dwNewLong);
        }

        WORD GetWindowWord(int nIndex) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowWord(m_hWnd, nIndex);
        }

        WORD SetWindowWord(int nIndex, WORD wNewWord)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetWindowWord(m_hWnd, nIndex, wNewWord);
        }

// Message Functions

        LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SendMessage(m_hWnd,message,wParam,lParam);
        }

        BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::PostMessage(m_hWnd,message,wParam,lParam);
        }

        BOOL SendNotifyMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SendNotifyMessage(m_hWnd, message, wParam, lParam);
        }

        // support for C style macros
        static LRESULT SendMessage(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
        {
                ATLASSERT(::IsWindow(hWnd));
                return ::SendMessage(hWnd, message, wParam, lParam);
        }

// Window Text Functions

        BOOL SetWindowText(LPCTSTR lpszString)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetWindowText(m_hWnd, lpszString);
        }

        int GetWindowText(LPTSTR lpszStringBuf, int nMaxCount) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowText(m_hWnd, lpszStringBuf, nMaxCount);
        }

        int GetWindowTextLength() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowTextLength(m_hWnd);
        }

// Font Functions

        void SetFont(HFONT hFont, BOOL bRedraw = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
        }

        HFONT GetFont() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return (HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0);
        }

// Menu Functions (non-child windows only)

        HMENU GetMenu() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetMenu(m_hWnd);
        }

        BOOL SetMenu(HMENU hMenu)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetMenu(m_hWnd, hMenu);
        }

        BOOL DrawMenuBar()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::DrawMenuBar(m_hWnd);
        }

        HMENU GetSystemMenu(BOOL bRevert) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetSystemMenu(m_hWnd, bRevert);
        }

        BOOL HiliteMenuItem(HMENU hMenu, UINT uItemHilite, UINT uHilite)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::HiliteMenuItem(m_hWnd, hMenu, uItemHilite, uHilite);
        }

// Window Size and Position Functions

        BOOL IsIconic() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::IsIconic(m_hWnd);
        }

        BOOL IsZoomed() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::IsZoomed(m_hWnd);
        }

        BOOL MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint);
        }

        BOOL MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::MoveWindow(m_hWnd, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, bRepaint);
        }

        BOOL SetWindowPos(HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetWindowPos(m_hWnd, hWndInsertAfter, x, y, cx, cy, nFlags);
        }

        BOOL SetWindowPos(HWND hWndInsertAfter, LPCRECT lpRect, UINT nFlags)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetWindowPos(m_hWnd, hWndInsertAfter, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, nFlags);
        }

        UINT ArrangeIconicWindows()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ArrangeIconicWindows(m_hWnd);
        }

        BOOL BringWindowToTop()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::BringWindowToTop(m_hWnd);
        }

        BOOL GetWindowRect(LPRECT lpRect) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowRect(m_hWnd, lpRect);
        }

        BOOL GetClientRect(LPRECT lpRect) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetClientRect(m_hWnd, lpRect);
        }

        BOOL GetWindowPlacement(WINDOWPLACEMENT FAR* lpwndpl) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowPlacement(m_hWnd, lpwndpl);
        }

        BOOL SetWindowPlacement(const WINDOWPLACEMENT FAR* lpwndpl)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetWindowPlacement(m_hWnd, lpwndpl);
        }

// Coordinate Mapping Functions

        BOOL ClientToScreen(LPPOINT lpPoint) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ClientToScreen(m_hWnd, lpPoint);
        }

        BOOL ClientToScreen(LPRECT lpRect) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                if(!::ClientToScreen(m_hWnd, (LPPOINT)lpRect))
                        return FALSE;
                return ::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1);
        }

        BOOL ScreenToClient(LPPOINT lpPoint) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ScreenToClient(m_hWnd, lpPoint);
        }

        BOOL ScreenToClient(LPRECT lpRect) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                if(!::ScreenToClient(m_hWnd, (LPPOINT)lpRect))
                        return FALSE;
                return ::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1);
        }

        int MapWindowPoints(HWND hWndTo, LPPOINT lpPoint, UINT nCount) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::MapWindowPoints(m_hWnd, hWndTo, lpPoint, nCount);
        }

        int MapWindowPoints(HWND hWndTo, LPRECT lpRect) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::MapWindowPoints(m_hWnd, hWndTo, (LPPOINT)lpRect, 2);
        }

// Update and Painting Functions

        HDC BeginPaint(LPPAINTSTRUCT lpPaint)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::BeginPaint(m_hWnd, lpPaint);
        }

        void EndPaint(LPPAINTSTRUCT lpPaint)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::EndPaint(m_hWnd, lpPaint);
        }

        HDC GetDC()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetDC(m_hWnd);
        }

        HDC GetWindowDC()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowDC(m_hWnd);
        }

        int ReleaseDC(HDC hDC)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ReleaseDC(m_hWnd, hDC);
        }

        void Print(HDC hDC, DWORD dwFlags) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_PRINT, (WPARAM)hDC, dwFlags);
        }

        void PrintClient(HDC hDC, DWORD dwFlags) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)hDC, dwFlags);
        }

        BOOL UpdateWindow()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::UpdateWindow(m_hWnd);
        }

        void SetRedraw(BOOL bRedraw = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_SETREDRAW, (WPARAM)bRedraw, 0);
        }

        BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetUpdateRect(m_hWnd, lpRect, bErase);
        }

        int GetUpdateRgn(HRGN hRgn, BOOL bErase = FALSE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetUpdateRgn(m_hWnd, hRgn, bErase);
        }

        BOOL Invalidate(BOOL bErase = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::InvalidateRect(m_hWnd, NULL, bErase);
        }

        BOOL InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::InvalidateRect(m_hWnd, lpRect, bErase);
        }

        BOOL ValidateRect(LPCRECT lpRect)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ValidateRect(m_hWnd, lpRect);
        }

        void InvalidateRgn(HRGN hRgn, BOOL bErase = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::InvalidateRgn(m_hWnd, hRgn, bErase);
        }

        BOOL ValidateRgn(HRGN hRgn)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ValidateRgn(m_hWnd, hRgn);
        }

        BOOL ShowWindow(int nCmdShow)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ShowWindow(m_hWnd, nCmdShow);
        }

        BOOL IsWindowVisible() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::IsWindowVisible(m_hWnd);
        }

        BOOL ShowOwnedPopups(BOOL bShow = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ShowOwnedPopups(m_hWnd, bShow);
        }

        HDC GetDCEx(HRGN hRgnClip, DWORD flags)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetDCEx(m_hWnd, hRgnClip, flags);
        }

        BOOL LockWindowUpdate(BOOL bLock = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::LockWindowUpdate(bLock ? m_hWnd : NULL);
        }

        BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL, HRGN hRgnUpdate = NULL, UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::RedrawWindow(m_hWnd, lpRectUpdate, hRgnUpdate, flags);
        }

// Timer Functions

        UINT_PTR SetTimer(UINT_PTR nIDEvent, UINT nElapse)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetTimer(m_hWnd, nIDEvent, nElapse, NULL);
        }

        BOOL KillTimer(UINT_PTR nIDEvent)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::KillTimer(m_hWnd, nIDEvent);
        }

// Window State Functions

        BOOL IsWindowEnabled() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::IsWindowEnabled(m_hWnd);
        }

        BOOL EnableWindow(BOOL bEnable = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::EnableWindow(m_hWnd, bEnable);
        }

        HWND SetActiveWindow()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetActiveWindow(m_hWnd);
        }

        HWND SetCapture()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetCapture(m_hWnd);
        }

        HWND SetFocus()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetFocus(m_hWnd);
        }

// Dialog-Box Item Functions

        BOOL CheckDlgButton(int nIDButton, UINT nCheck)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::CheckDlgButton(m_hWnd, nIDButton, nCheck);
        }

        BOOL CheckRadioButton(int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton);
        }

        int DlgDirList(LPTSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT nFileType)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox, nIDStaticPath, nFileType);
        }

        int DlgDirListComboBox(LPTSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT nFileType)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::DlgDirListComboBox(m_hWnd, lpPathSpec, nIDComboBox, nIDStaticPath, nFileType);
        }

        BOOL DlgDirSelect(LPTSTR lpString, int nCount, int nIDListBox)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::DlgDirSelectEx(m_hWnd, lpString, nCount, nIDListBox);
        }

        BOOL DlgDirSelectComboBox(LPTSTR lpString, int nCount, int nIDComboBox)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, nCount, nIDComboBox);
        }

        UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL, BOOL bSigned = TRUE) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);
        }

        UINT GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);
        }
        BOOL GetDlgItemText(int nID, BSTR& bstrText) const
        {
                ATLASSERT(::IsWindow(m_hWnd));

                HWND hWndCtl = GetDlgItem(nID);
                if(hWndCtl == NULL)
                        return FALSE;

                return CWindow(hWndCtl).GetWindowText(bstrText);
        }
        HWND GetNextDlgGroupItem(HWND hWndCtl, BOOL bPrevious = FALSE) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetNextDlgGroupItem(m_hWnd, hWndCtl, bPrevious);
        }

        HWND GetNextDlgTabItem(HWND hWndCtl, BOOL bPrevious = FALSE) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetNextDlgTabItem(m_hWnd, hWndCtl, bPrevious);
        }

        UINT IsDlgButtonChecked(int nIDButton) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::IsDlgButtonChecked(m_hWnd, nIDButton);
        }

        LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam);
        }

        BOOL SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned);
        }

        BOOL SetDlgItemText(int nID, LPCTSTR lpszString)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetDlgItemText(m_hWnd, nID, lpszString);
        }

#ifndef _ATL_NO_HOSTING
        HRESULT GetDlgControl(int nID, REFIID iid, void** ppUnk)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ATLASSERT(ppUnk != NULL);
                HRESULT hr = E_FAIL;
                HWND hWndCtrl = GetDlgItem(nID);
                if (hWndCtrl != NULL)
                {
                        if (ppUnk == NULL)
                        {
                                return E_POINTER;
                        }
                        *ppUnk = NULL;
                        CComPtr<IUnknown> spUnk;
                        hr = AtlAxGetControl(hWndCtrl, &spUnk);
                        if (SUCCEEDED(hr))
                                hr = spUnk->QueryInterface(iid, ppUnk);
                }
                return hr;
        }
#endif //!_ATL_NO_HOSTING

// Scrolling Functions

        int GetScrollPos(int nBar) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetScrollPos(m_hWnd, nBar);
        }

        BOOL GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetScrollRange(m_hWnd, nBar, lpMinPos, lpMaxPos);
        }

        BOOL ScrollWindow(int xAmount, int yAmount, LPCRECT lpRect = NULL, LPCRECT lpClipRect = NULL)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ScrollWindow(m_hWnd, xAmount, yAmount, lpRect, lpClipRect);
        }

        int ScrollWindowEx(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate, UINT uFlags)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, uFlags);
        }

        int ScrollWindowEx(int dx, int dy, UINT uFlags, LPCRECT lpRectScroll = NULL, LPCRECT lpRectClip = NULL, HRGN hRgnUpdate = NULL, LPRECT lpRectUpdate = NULL)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, uFlags);
        }

        int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetScrollPos(m_hWnd, nBar, nPos, bRedraw);
        }

        BOOL SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetScrollRange(m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
        }

        BOOL ShowScrollBar(UINT nBar, BOOL bShow = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ShowScrollBar(m_hWnd, nBar, bShow);
        }

        BOOL EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::EnableScrollBar(m_hWnd, uSBFlags, uArrowFlags);
        }

// Window Access Functions

        HWND ChildWindowFromPoint(POINT point) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ChildWindowFromPoint(m_hWnd, point);
        }

        HWND ChildWindowFromPointEx(POINT point, UINT uFlags) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ChildWindowFromPointEx(m_hWnd, point, uFlags);
        }

        HWND GetTopWindow() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetTopWindow(m_hWnd);
        }

        HWND GetWindow(UINT nCmd) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindow(m_hWnd, nCmd);
        }

        HWND GetLastActivePopup() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetLastActivePopup(m_hWnd);
        }

        BOOL IsChild(HWND hWnd) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::IsChild(m_hWnd, hWnd);
        }

        HWND GetParent() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetParent(m_hWnd);
        }

        HWND SetParent(HWND hWndNewParent)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetParent(m_hWnd, hWndNewParent);
        }

// Window Tree Access

        int GetDlgCtrlID() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetDlgCtrlID(m_hWnd);
        }

        int SetDlgCtrlID(int nID)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return (int)::SetWindowLong(m_hWnd, GWL_ID, nID);
        }

        HWND GetDlgItem(int nID) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetDlgItem(m_hWnd, nID);
        }

// Alert Functions

        BOOL FlashWindow(BOOL bInvert)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::FlashWindow(m_hWnd, bInvert);
        }

        int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = _T(""), UINT nType = MB_OK)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::MessageBox(m_hWnd, lpszText, lpszCaption, nType);
        }

// Clipboard Functions

        BOOL ChangeClipboardChain(HWND hWndNewNext)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ChangeClipboardChain(m_hWnd, hWndNewNext);
        }

        HWND SetClipboardViewer()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetClipboardViewer(m_hWnd);
        }

        BOOL OpenClipboard()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::OpenClipboard(m_hWnd);
        }

// Caret Functions

        BOOL CreateCaret(HBITMAP hBitmap)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::CreateCaret(m_hWnd, hBitmap, 0, 0);
        }

        BOOL CreateSolidCaret(int nWidth, int nHeight)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight);
        }

        BOOL CreateGrayCaret(int nWidth, int nHeight)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight);
        }

        BOOL HideCaret()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::HideCaret(m_hWnd);
        }

        BOOL ShowCaret()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ShowCaret(m_hWnd);
        }

#ifdef _INC_SHELLAPI
// Drag-Drop Functions
        void DragAcceptFiles(BOOL bAccept = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd)); ::DragAcceptFiles(m_hWnd, bAccept);
        }
#endif

// Icon Functions

        HICON SetIcon(HICON hIcon, BOOL bBigIcon = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon);
        }

        HICON GetIcon(BOOL bBigIcon = TRUE) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0);
        }

// Help Functions

        BOOL WinHelp(LPCTSTR lpszHelp, UINT nCmd = HELP_CONTEXT, DWORD dwData = 0)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::WinHelp(m_hWnd, lpszHelp, nCmd, dwData);
        }

        BOOL SetWindowContextHelpId(DWORD dwContextHelpId)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId);
        }

        DWORD GetWindowContextHelpId() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowContextHelpId(m_hWnd);
        }

// Hot Key Functions

        int SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return (int)::SendMessage(m_hWnd, WM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0);
        }

        DWORD GetHotKey() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return (DWORD)::SendMessage(m_hWnd, WM_GETHOTKEY, 0, 0);
        }

// Misc. Operations

//N new
        BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetScrollInfo(m_hWnd, nBar, lpScrollInfo);
        }
        BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetScrollInfo(m_hWnd, nBar, lpScrollInfo, bRedraw);
        }
        BOOL IsDialogMessage(LPMSG lpMsg)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::IsDialogMessage(m_hWnd, lpMsg);
        }

        void NextDlgCtrl() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0L);
        }
        void PrevDlgCtrl() const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0L);
        }
        void GotoDlgCtrl(HWND hWndCtrl) const
        {
                ATLASSERT(::IsWindow(m_hWnd));
                ::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)hWndCtrl, 1L);
        }

        BOOL ResizeClient(int nWidth, int nHeight, BOOL bRedraw = TRUE)
        {
                ATLASSERT(::IsWindow(m_hWnd));

                RECT rcWnd;
                if(!GetClientRect(&rcWnd))
                        return FALSE;

                if(nWidth != -1)
                        rcWnd.right = nWidth;
                if(nHeight != -1)
                        rcWnd.bottom = nHeight;

                if(!::AdjustWindowRectEx(&rcWnd, GetStyle(), (!(GetStyle() & WS_CHILD) && (GetMenu() != NULL)), GetExStyle()))
                        return FALSE;

                UINT uFlags = SWP_NOZORDER | SWP_NOMOVE;
                if(!bRedraw)
                        uFlags |= SWP_NOREDRAW;

                return SetWindowPos(NULL, 0, 0, rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top, uFlags);
        }

        int GetWindowRgn(HRGN hRgn)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowRgn(m_hWnd, hRgn);
        }
        int SetWindowRgn(HRGN hRgn, BOOL bRedraw = FALSE)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::SetWindowRgn(m_hWnd, hRgn, bRedraw);
        }
        HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::DeferWindowPos(hWinPosInfo, m_hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
        }
        DWORD GetWindowThreadID()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::GetWindowThreadProcessId(m_hWnd, NULL);
        }
        DWORD GetWindowProcessID()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                DWORD dwProcessID;
                ::GetWindowThreadProcessId(m_hWnd, &dwProcessID);
                return dwProcessID;
        }
        BOOL IsWindow()
        {
                return ::IsWindow(m_hWnd);
        }
        BOOL IsWindowUnicode()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::IsWindowUnicode(m_hWnd);
        }
        BOOL IsParentDialog()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                TCHAR szBuf[8]; // "#32770" + NUL character
                GetClassName(GetParent(), szBuf, sizeof(szBuf)/sizeof(TCHAR));
                return lstrcmp(szBuf, _T("#32770")) == 0;
        }
        BOOL ShowWindowAsync(int nCmdShow)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::ShowWindowAsync(m_hWnd, nCmdShow);
        }

        HWND GetDescendantWindow(int nID) const
        {
                ATLASSERT(::IsWindow(m_hWnd));

                // GetDlgItem recursive (return first found)
                // breadth-first for 1 level, then depth-first for next level

                // use GetDlgItem since it is a fast USER function
                HWND hWndChild, hWndTmp;
                CWindow wnd;
                if((hWndChild = ::GetDlgItem(m_hWnd, nID)) != NULL)
                {
                        if(::GetTopWindow(hWndChild) != NULL)
                        {
                                // children with the same ID as their parent have priority
                                wnd.Attach(hWndChild);
                                hWndTmp = wnd.GetDescendantWindow(nID);
                                if(hWndTmp != NULL)
                                        return hWndTmp;
                        }
                        return hWndChild;
                }

                // walk each child
                for(hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
                        hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
                {
                        wnd.Attach(hWndChild);
                        hWndTmp = wnd.GetDescendantWindow(nID);
                        if(hWndTmp != NULL)
                                return hWndTmp;
                }

                return NULL;    // not found
        }

        void SendMessageToDescendants(UINT message, WPARAM wParam = 0, LPARAM lParam = 0, BOOL bDeep = TRUE)
        {
                CWindow wnd;
                for(HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
                        hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
                {
                        ::SendMessage(hWndChild, message, wParam, lParam);

                        if(bDeep && ::GetTopWindow(hWndChild) != NULL)
                        {
                                // send to child windows after parent
                                wnd.Attach(hWndChild);
                                wnd.SendMessageToDescendants(message, wParam, lParam, bDeep);
                        }
                }
        }

        BOOL CenterWindow(HWND hWndCenter = NULL)
        {
                ATLASSERT(::IsWindow(m_hWnd));

                // determine owner window to center against
                DWORD dwStyle = GetStyle();
                if(hWndCenter == NULL)
                {
                        if(dwStyle & WS_CHILD)
                                hWndCenter = ::GetParent(m_hWnd);
                        else
                                hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
                }

                // get coordinates of the window relative to its parent
                RECT rcDlg;
                ::GetWindowRect(m_hWnd, &rcDlg);
                RECT rcArea;
                RECT rcCenter;
                HWND hWndParent;
                if(!(dwStyle & WS_CHILD))
                {
                        // don't center against invisible or minimized windows
                        if(hWndCenter != NULL)
                        {
                                DWORD L_dwStyle = ::GetWindowLong(hWndCenter, GWL_STYLE);
                                if(!(L_dwStyle & WS_VISIBLE) || (L_dwStyle & WS_MINIMIZE))
                                        hWndCenter = NULL;
                        }

                        // center within screen coordinates
                        ::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);
                        if(hWndCenter == NULL)
                                rcCenter = rcArea;
                        else
                                ::GetWindowRect(hWndCenter, &rcCenter);
                }
                else
                {
                        // center within parent client coordinates
                        hWndParent = ::GetParent(m_hWnd);
                        ATLASSERT(::IsWindow(hWndParent));

                        ::GetClientRect(hWndParent, &rcArea);
                        ATLASSERT(::IsWindow(hWndCenter));
                        ::GetClientRect(hWndCenter, &rcCenter);
                        ::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
                }

                int DlgWidth = rcDlg.right - rcDlg.left;
                int DlgHeight = rcDlg.bottom - rcDlg.top;

                // find dialog's upper left based on rcCenter
                int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
                int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

                // if the dialog is outside the screen, move it inside
                if(xLeft < rcArea.left)
                        xLeft = rcArea.left;
                else if(xLeft + DlgWidth > rcArea.right)
                        xLeft = rcArea.right - DlgWidth;

                if(yTop < rcArea.top)
                        yTop = rcArea.top;
                else if(yTop + DlgHeight > rcArea.bottom)
                        yTop = rcArea.bottom - DlgHeight;

                // map screen coordinates to child coordinates
                return ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, -1, -1,
                        SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

        BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0)
        {
                ATLASSERT(::IsWindow(m_hWnd));

                DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE);
                DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
                if(dwStyle == dwNewStyle)
                        return FALSE;

                ::SetWindowLong(m_hWnd, GWL_STYLE, dwNewStyle);
                if(nFlags != 0)
                {
                        ::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
                                SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
                }

                return TRUE;
        }

        BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0)
        {
                ATLASSERT(::IsWindow(m_hWnd));

                DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
                DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
                if(dwStyle == dwNewStyle)
                        return FALSE;

                ::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwNewStyle);
                if(nFlags != 0)
                {
                        ::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
                                SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
                }

                return TRUE;
        }

        BOOL GetWindowText(BSTR* pbstrText)
        {
                return GetWindowText(*pbstrText);
        }
        BOOL GetWindowText(BSTR& bstrText)
        {
                USES_CONVERSION;
                ATLASSERT(::IsWindow(m_hWnd));
                if (bstrText != NULL)
                {
                        SysFreeString(bstrText);
                        bstrText = NULL;
                }

                int nLen = ::GetWindowTextLength(m_hWnd);
                if(nLen == 0)
                {
                        bstrText = ::SysAllocString(OLESTR(""));
                        return (bstrText != NULL) ? TRUE : FALSE;
                }

                LPTSTR lpszText = (LPTSTR)_alloca((nLen+1)*sizeof(TCHAR));

                if(!::GetWindowText(m_hWnd, lpszText, nLen+1))
                        return FALSE;
                
                bstrText = ::SysAllocString(T2OLE(lpszText));
                return (bstrText != NULL) ? TRUE : FALSE;
        }
        HWND GetTopLevelParent() const
        {
                ATLASSERT(::IsWindow(m_hWnd));

                HWND hWndParent = m_hWnd;
                HWND hWndTmp;
                while((hWndTmp = ::GetParent(hWndParent)) != NULL)
                        hWndParent = hWndTmp;

                return hWndParent;
        }

        HWND GetTopLevelWindow() const
        {
                ATLASSERT(::IsWindow(m_hWnd));

                HWND hWndParent;
                HWND hWndTmp = m_hWnd;

                do
                {
                        hWndParent = hWndTmp;
                        hWndTmp = (::GetWindowLong(hWndParent, GWL_STYLE) & WS_CHILD) ? ::GetParent(hWndParent) : ::GetWindow(hWndParent, GW_OWNER);
                }
                while(hWndTmp != NULL);

                return hWndParent;
        }
};

_declspec(selectany) RECT CWindow::rcDefault = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };

/////////////////////////////////////////////////////////////////////////////
// CAxWindow - client side for an ActiveX host window

#ifndef _ATL_NO_HOSTING

template <class TBase /* = CWindow */>
class CAxWindowT : public TBase
{
public:
// Constructors
        CAxWindowT(HWND hWnd = NULL) : TBase(hWnd)
        { }

        CAxWindowT< TBase >& operator=(HWND hWnd)
        {
                m_hWnd = hWnd;
                return *this;
        }

// Attributes
        static LPCTSTR GetWndClassName()
        {
                return _T("AtlAxWin");
        }

// Operations
        HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
                        DWORD dwStyle = 0, DWORD dwExStyle = 0,
                        UINT nID = 0, LPVOID lpCreateParam = NULL)
        {
                return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
        }
        HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
                        DWORD dwStyle = 0, DWORD dwExStyle = 0,
                        HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
        {
                return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
        }

        HRESULT CreateControl(LPCOLESTR lpszName, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return AtlAxCreateControl(lpszName, m_hWnd, pStream, ppUnkContainer);
        }

        HRESULT CreateControl(DWORD dwResID, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
        {
                TCHAR szModule[_MAX_PATH];
                DWORD len = GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

                if (0 == len || (sizeof szModule / sizeof szModule[0]) == len) 
                {        // GetModuleFileName failed
                        return HRESULT_FROM_WIN32(::GetLastError());        
                }

                CComBSTR bstrURL(OLESTR("res://"));
                bstrURL.Append(szModule);
                bstrURL.Append(OLESTR("/"));
                TCHAR szResID[11];
                wsprintf(szResID, _T("%0d"), dwResID);
                bstrURL.Append(szResID);

                ATLASSERT(::IsWindow(m_hWnd));
                return AtlAxCreateControl(bstrURL, m_hWnd, pStream, ppUnkContainer);
        }

        HRESULT CreateControlEx(LPCOLESTR lpszName, IStream* pStream = NULL,
                        IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
                        REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return AtlAxCreateControlEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
        }

        HRESULT CreateControlEx(DWORD dwResID,  IStream* pStream = NULL,
                        IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
                        REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
        {
                TCHAR szModule[_MAX_PATH];
                DWORD len = GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

                if (0 == len || (sizeof szModule / sizeof szModule[0]) == len) 
                {        // GetModuleFileName failed
                        return HRESULT_FROM_WIN32(::GetLastError());        
                }

                CComBSTR bstrURL(OLESTR("res://"));
                bstrURL.Append(szModule);
                bstrURL.Append(OLESTR("/"));
                TCHAR szResID[11];
                wsprintf(szResID, _T("%0d"), dwResID);
                bstrURL.Append(szResID);

                ATLASSERT(::IsWindow(m_hWnd));
                return AtlAxCreateControlEx(bstrURL, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
        }

        HRESULT AttachControl(IUnknown* pControl, IUnknown** ppUnkContainer)
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return AtlAxAttachControl(pControl, m_hWnd, ppUnkContainer);
        }
        HRESULT QueryHost(REFIID iid, void** ppUnk)
        {
                ATLASSERT(ppUnk != NULL);
                HRESULT hr;

                if (NULL == ppUnk)
                {
                        return E_POINTER;
                }
                *ppUnk = NULL;                                                
                CComPtr<IUnknown> spUnk;
                hr = AtlAxGetHost(m_hWnd, &spUnk);
                if (SUCCEEDED(hr))
                        hr = spUnk->QueryInterface(iid, ppUnk);
                return hr;
        }
        template <class Q>
        HRESULT QueryHost(Q** ppUnk)
        {
                return QueryHost(__uuidof(Q), (void**)ppUnk);
        }
        HRESULT QueryControl(REFIID iid, void** ppUnk)
        {
                ATLASSERT(ppUnk != NULL);
                HRESULT hr;
                if (NULL == ppUnk)
                {
                        return E_POINTER;
                }
                *ppUnk = NULL;                                        
                CComPtr<IUnknown> spUnk;
                hr = AtlAxGetControl(m_hWnd, &spUnk);
                if (SUCCEEDED(hr))
                        hr = spUnk->QueryInterface(iid, ppUnk);
                return hr;
        }
        template <class Q>
        HRESULT QueryControl(Q** ppUnk)
        {
                return QueryControl(__uuidof(Q), (void**)ppUnk);
        }
        HRESULT SetExternalDispatch(IDispatch* pDisp)
        {
                HRESULT hr;
                CComPtr<IAxWinHostWindow> spHost;
                hr = QueryHost(IID_IAxWinHostWindow, (void**)&spHost);
                if (SUCCEEDED(hr))
                        hr = spHost->SetExternalDispatch(pDisp);
                return hr;
        }
        HRESULT SetExternalUIHandler(IDocHostUIHandlerDispatch* pUIHandler)
        {
                HRESULT hr;
                CComPtr<IAxWinHostWindow> spHost;
                hr = QueryHost(IID_IAxWinHostWindow, (void**)&spHost);
                if (SUCCEEDED(hr))
                        hr = spHost->SetExternalUIHandler(pUIHandler);
                return hr;
        }
};

typedef CAxWindowT<CWindow> CAxWindow;

#endif //_ATL_NO_HOSTING

/////////////////////////////////////////////////////////////////////////////
// WindowProc thunks

class CWndProcThunk
{
public:
	_AtlCreateWndData cd;
        CStdCallThunk thunk;

        void Init(WNDPROC proc, void* pThis)
        {
		thunk.Init((DWORD_PTR)proc, pThis);
        }
};

/////////////////////////////////////////////////////////////////////////////
// CMessageMap - abstract class that provides an interface for message maps

class ATL_NO_VTABLE CMessageMap
{
public:
        virtual BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                LRESULT& lResult, DWORD dwMsgMapID) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Message map

#define BEGIN_MSG_MAP(theClass) \
public: \
        BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0) \
        { \
                BOOL bHandled = TRUE; \
                hWnd; \
                uMsg; \
                wParam; \
                lParam; \
                lResult; \
                bHandled; \
                switch(dwMsgMapID) \
                { \
                case 0:

#define ALT_MSG_MAP(msgMapID) \
                break; \
                case msgMapID:

#define MESSAGE_HANDLER(msg, func) \
        if(uMsg == msg) \
        { \
                bHandled = TRUE; \
                lResult = func(uMsg, wParam, lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define MESSAGE_RANGE_HANDLER(msgFirst, msgLast, func) \
        if(uMsg >= msgFirst && uMsg <= msgLast) \
        { \
                bHandled = TRUE; \
                lResult = func(uMsg, wParam, lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define COMMAND_HANDLER(id, code, func) \
        if(uMsg == WM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
        { \
                bHandled = TRUE; \
                lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define COMMAND_ID_HANDLER(id, func) \
        if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
        { \
                bHandled = TRUE; \
                lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define COMMAND_CODE_HANDLER(code, func) \
        if(uMsg == WM_COMMAND && code == HIWORD(wParam)) \
        { \
                bHandled = TRUE; \
                lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
        if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
        { \
                bHandled = TRUE; \
                lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define NOTIFY_HANDLER(id, cd, func) \
        if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
        { \
                bHandled = TRUE; \
                lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define NOTIFY_ID_HANDLER(id, func) \
        if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
        { \
                bHandled = TRUE; \
                lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define NOTIFY_CODE_HANDLER(cd, func) \
        if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
        { \
                bHandled = TRUE; \
                lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
        if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
        { \
                bHandled = TRUE; \
                lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP(theChainClass) \
        { \
                if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_MEMBER(theChainMember) \
        { \
                if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_ALT(theChainClass, msgMapID) \
        { \
                if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_ALT_MEMBER(theChainMember, msgMapID) \
        { \
                if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
                        return TRUE; \
        }

#define CHAIN_MSG_MAP_DYNAMIC(dynaChainID) \
        { \
                if(CDynamicChain::CallChain(dynaChainID, hWnd, uMsg, wParam, lParam, lResult)) \
                        return TRUE; \
        }

#define END_MSG_MAP() \
                        break; \
                default: \
                        ATLTRACE2(atlTraceWindowing, 0, _T("Invalid message map ID (%i)\n"), dwMsgMapID); \
                        ATLASSERT(FALSE); \
                        break; \
                } \
                return FALSE; \
        }


// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// Empty message map macro

#define DECLARE_EMPTY_MSG_MAP() \
public: \
        BOOL ProcessWindowMessage(HWND, UINT, WPARAM, LPARAM, LRESULT&, DWORD) \
        { \
                return FALSE; \
        }

// Message reflection macros

#define REFLECT_NOTIFICATIONS() \
        { \
                bHandled = TRUE; \
                lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
                if(bHandled) \
                        return TRUE; \
        }

#define DEFAULT_REFLECTION_HANDLER() \
        if(DefaultReflectionHandler(hWnd, uMsg, wParam, lParam, lResult)) \
                return TRUE;

/////////////////////////////////////////////////////////////////////////////
// CDynamicChain - provides support for dynamic chaining

class CDynamicChain
{
public:
        struct ATL_CHAIN_ENTRY
        {
                DWORD m_dwChainID;
                CMessageMap* m_pObject;
                DWORD m_dwMsgMapID;
        };

        CSimpleArray<ATL_CHAIN_ENTRY*> m_aChainEntry;

        CDynamicChain()
        { }

        ~CDynamicChain()
        {
                for(int i = 0; i < m_aChainEntry.GetSize(); i++)
                {
                        if(m_aChainEntry[i] != NULL)
                                delete m_aChainEntry[i];
                }
        }

        BOOL SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID = 0)
        {
        // first search for an existing entry

                for(int i = 0; i < m_aChainEntry.GetSize(); i++)
                {
                        if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
                        {
                                m_aChainEntry[i]->m_pObject = pObject;
                                m_aChainEntry[i]->m_dwMsgMapID = dwMsgMapID;
                                return TRUE;
                        }
                }

        // create a new one

                ATL_CHAIN_ENTRY* pEntry = NULL;
                ATLTRY(pEntry = new ATL_CHAIN_ENTRY);

                if(pEntry == NULL)
                        return FALSE;

                pEntry->m_dwChainID = dwChainID;
                pEntry->m_pObject = pObject;
                pEntry->m_dwMsgMapID = dwMsgMapID;

        // search for an empty one

                for(i = 0; i < m_aChainEntry.GetSize(); i++)
                {
                        if(m_aChainEntry[i] == NULL)
                        {
                                m_aChainEntry[i] = pEntry;
                                return TRUE;
                        }
                }

        // add a new one

                BOOL bRet = m_aChainEntry.Add(pEntry);

                if(!bRet)
                {
                        delete pEntry;
                        return FALSE;
                }

                return TRUE;
        }

        BOOL RemoveChainEntry(DWORD dwChainID)
        {
                for(int i = 0; i < m_aChainEntry.GetSize(); i++)
                {
                        if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
                        {
                                delete m_aChainEntry[i];
                                m_aChainEntry[i] = NULL;
                                return TRUE;
                        }
                }

                return FALSE;
        }

        BOOL CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
        {
                for(int i = 0; i < m_aChainEntry.GetSize(); i++)
                {
                        if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
                                return (m_aChainEntry[i]->m_pObject)->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, m_aChainEntry[i]->m_dwMsgMapID);
                }

                return FALSE;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CWndClassInfo - Manages Windows class information

#define DECLARE_WND_CLASS(WndClassName) \
static CWndClassInfo& GetWndClassInfo() \
{ \
        static CWndClassInfo wc = \
        { \
                { sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS, StartWindowProc, \
                  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
                NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
        }; \
        return wc; \
}

#define DECLARE_WND_CLASS_EX(WndClassName, style, bkgnd) \
static CWndClassInfo& GetWndClassInfo() \
{ \
        static CWndClassInfo wc = \
        { \
                { sizeof(WNDCLASSEX), style, StartWindowProc, \
                  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
                NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
        }; \
        return wc; \
}

#define DECLARE_WND_SUPERCLASS(WndClassName, OrigWndClassName) \
static CWndClassInfo& GetWndClassInfo() \
{ \
        static CWndClassInfo wc = \
        { \
                { sizeof(WNDCLASSEX), 0, StartWindowProc, \
                  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
                OrigWndClassName, NULL, NULL, TRUE, 0, _T("") \
        }; \
        return wc; \
}

/////////////////////////////////////////////////////////////////////////////
// CWinTraits - Defines various default values for a window

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0>
class CWinTraits
{
public:
        static DWORD GetWndStyle(DWORD dwStyle)
        {
                return dwStyle == 0 ? t_dwStyle : dwStyle;
        }
        static DWORD GetWndExStyle(DWORD dwExStyle)
        {
                return dwExStyle == 0 ? t_dwExStyle : dwExStyle;
        }
};

typedef CWinTraits<WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0>                                        CControlWinTraits;
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE>                CFrameWinTraits;
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_MDICHILD>        CMDIChildWinTraits;

typedef CWinTraits<0, 0> CNullTraits;

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0, class TWinTraits = CControlWinTraits>
class CWinTraitsOR
{
public:
        static DWORD GetWndStyle(DWORD dwStyle)
        {
                return dwStyle | t_dwStyle | TWinTraits::GetWndStyle(dwStyle);
        }
        static DWORD GetWndExStyle(DWORD dwExStyle)
        {
                return dwExStyle | t_dwExStyle | TWinTraits::GetWndExStyle(dwExStyle);
        }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImpl - Implements a window

template <class TBase = CWindow>
class ATL_NO_VTABLE CWindowImplRoot : public TBase, public CMessageMap
{
public:
        CWndProcThunk m_thunk;
        const MSG* m_pCurrentMsg;

// Constructor/destructor
        CWindowImplRoot() : m_pCurrentMsg(NULL)
        { }

        ~CWindowImplRoot()
        {
#ifdef _DEBUG
                if(m_hWnd != NULL)        // should be cleared in WindowProc
                {
                        ATLTRACE2(atlTraceWindowing, 0, _T("ERROR - Object deleted before window was destroyed\n"));
                        ATLASSERT(FALSE);
                }
#endif //_DEBUG
        }

// Current message
        const MSG* GetCurrentMessage() const
        {
                return m_pCurrentMsg;
        }

// Message reflection support
        LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
        static BOOL DefaultReflectionHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult);
};

template <class TBase>
LRESULT CWindowImplRoot< TBase >::ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
        HWND hWndChild = NULL;

        switch(uMsg)
        {
        case WM_COMMAND:
                if(lParam != NULL)        // not from a menu
                        hWndChild = (HWND)lParam;
                break;
        case WM_NOTIFY:
                hWndChild = ((LPNMHDR)lParam)->hwndFrom;
                break;
        case WM_PARENTNOTIFY:
                switch(LOWORD(wParam))
                {
                case WM_CREATE:
                case WM_DESTROY:
                        hWndChild = (HWND)lParam;
                        break;
                default:
                        hWndChild = GetDlgItem(HIWORD(wParam));
                        break;
                }
                break;
        case WM_DRAWITEM:
                if(wParam)        // not from a menu
                        hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
                break;
        case WM_MEASUREITEM:
                if(wParam)        // not from a menu
                        hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
                break;
        case WM_COMPAREITEM:
                if(wParam)        // not from a menu
                        hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
                break;
        case WM_DELETEITEM:
                if(wParam)        // not from a menu
                        hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
                break;
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_HSCROLL:
        case WM_VSCROLL:
                hWndChild = (HWND)lParam;
                break;
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
                hWndChild = (HWND)lParam;
                break;
        default:
                break;
        }

        if(hWndChild == NULL)
        {
                bHandled = FALSE;
                return 1;
        }

        ATLASSERT(::IsWindow(hWndChild));
        return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
}

template <class TBase>
BOOL CWindowImplRoot< TBase >::DefaultReflectionHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
{
        switch(uMsg)
        {
        case OCM_COMMAND:
        case OCM_NOTIFY:
        case OCM_PARENTNOTIFY:
        case OCM_DRAWITEM:
        case OCM_MEASUREITEM:
        case OCM_COMPAREITEM:
        case OCM_DELETEITEM:
        case OCM_VKEYTOITEM:
        case OCM_CHARTOITEM:
        case OCM_HSCROLL:
        case OCM_VSCROLL:
        case OCM_CTLCOLORBTN:
        case OCM_CTLCOLORDLG:
        case OCM_CTLCOLOREDIT:
        case OCM_CTLCOLORLISTBOX:
        case OCM_CTLCOLORMSGBOX:
        case OCM_CTLCOLORSCROLLBAR:
        case OCM_CTLCOLORSTATIC:
                lResult = ::DefWindowProc(hWnd, uMsg - OCM__BASE, wParam, lParam);
                return TRUE;
        default:
                break;
        }
        return FALSE;
}

template <class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowImplBaseT : public CWindowImplRoot< TBase >
{
public:
        WNDPROC m_pfnSuperWindowProc;

        CWindowImplBaseT() : m_pfnSuperWindowProc(::DefWindowProc)
        {}

        static DWORD GetWndStyle(DWORD dwStyle)
        {
                return TWinTraits::GetWndStyle(dwStyle);
        }
        static DWORD GetWndExStyle(DWORD dwExStyle)
        {
                return TWinTraits::GetWndExStyle(dwExStyle);
        }

        virtual WNDPROC GetWindowProc()
        {
                return WindowProc;
        }
        static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
                        DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom, LPVOID lpCreateParam = NULL);
        BOOL DestroyWindow()
        {
                ATLASSERT(::IsWindow(m_hWnd));
                return ::DestroyWindow(m_hWnd);
        }
        BOOL SubclassWindow(HWND hWnd);
        HWND UnsubclassWindow(BOOL bForce = FALSE);

        LRESULT DefWindowProc()
        {
                const MSG* pMsg = m_pCurrentMsg;
                LRESULT lRes = 0;
                if (pMsg != NULL)
                        lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
                return lRes;
        }

        LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
        {
#ifdef STRICT
                return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
                return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
        }

        virtual void OnFinalMessage(HWND /*hWnd*/)
        {
                // override to do something, if needed
        }
};

typedef CWindowImplBaseT<CWindow>        CWindowImplBase;

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)_Module.ExtractCreateWndData();
        ATLASSERT(pThis != NULL);
        pThis->m_hWnd = hWnd;
        pThis->m_thunk.Init(pThis->GetWindowProc(), pThis);
        WNDPROC pProc = (WNDPROC)(pThis->m_thunk.thunk.pThunk);
        WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)pProc);
#ifdef _DEBUG
        // check if somebody has subclassed us already since we discard it
        if(pOldProc != StartWindowProc)
                ATLTRACE2(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
        pOldProc;        // avoid unused warning
#endif
        return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)hWnd;
        // set a ptr to this message and save the old value
        MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
        const MSG* pOldMsg = pThis->m_pCurrentMsg;
        pThis->m_pCurrentMsg = &msg;
        // pass to the message map to process
        LRESULT lRes;
        BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
        // restore saved value for the current message
        ATLASSERT(pThis->m_pCurrentMsg == &msg);
        pThis->m_pCurrentMsg = pOldMsg;
        // do the default processing if message was not handled
        if(!bRet)
        {
                if(uMsg != WM_NCDESTROY)
                        lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
                else
                {
                        // unsubclass, if needed
                        LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
                        lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
                        if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
                                ::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
                        // clear out window handle
                        HWND L_hWnd = pThis->m_hWnd;
                        pThis->m_hWnd = NULL;
                        // clean up after window is destroyed
                        pThis->OnFinalMessage(L_hWnd);
                }
        }
        return lRes;
}

template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
                DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom, LPVOID lpCreateParam)
{
        ATLASSERT(m_hWnd == NULL);

        if(atom == 0)
                return NULL;

        _Module.AddCreateWndData(&m_thunk.cd, this);

        if(nID == 0 && (dwStyle & WS_CHILD))
#if _ATL_VER > 0x0300
                nID = _Module.GetNextWindowID();
#else
        nID = (UINT)this;
#endif

        HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
                dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
                rcPos.bottom - rcPos.top, hWndParent, (HMENU)(DWORD_PTR)nID,
                _Module.GetModuleInstance(), lpCreateParam);

        ATLASSERT(m_hWnd == hWnd);

        return hWnd;
}

template <class TBase, class TWinTraits>
BOOL CWindowImplBaseT< TBase, TWinTraits >::SubclassWindow(HWND hWnd)
{
        ATLASSERT(m_hWnd == NULL);
        ATLASSERT(::IsWindow(hWnd));
        m_thunk.Init(GetWindowProc(), this);
        WNDPROC pProc = (WNDPROC)(m_thunk.thunk.pThunk);
        WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)pProc);
        if(pfnWndProc == NULL)
                return FALSE;
        m_pfnSuperWindowProc = pfnWndProc;
        m_hWnd = hWnd;
        return TRUE;
}

// Use only if you want to subclass before window is destroyed,
// WindowProc will automatically subclass when  window goes away
template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::UnsubclassWindow(BOOL bForce /*= FALSE*/)
{
        ATLASSERT(m_hWnd != NULL);

        WNDPROC pOurProc = (WNDPROC)(m_thunk.thunk.pThunk);
        WNDPROC pActiveProc = (WNDPROC)::GetWindowLongPtr(m_hWnd, GWLP_WNDPROC);

        HWND hWnd = NULL;
        if (bForce || pOurProc == pActiveProc)
        {
                if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
                        return NULL;

                m_pfnSuperWindowProc = ::DefWindowProc;
                hWnd = m_hWnd;
                m_hWnd = NULL;
        }
        return hWnd;
}

template <class T, class TBase /* = CWindow */, class TWinTraits /* = CControlWinTraits */>
class ATL_NO_VTABLE CWindowImpl : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
        DECLARE_WND_CLASS(NULL)

        HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
                        DWORD dwStyle = 0, DWORD dwExStyle = 0,
                        UINT nID = 0, LPVOID lpCreateParam = NULL)
        {
                if (T::GetWndClassInfo().m_lpszOrigName == NULL)
                        T::GetWndClassInfo().m_lpszOrigName = GetWndClassName();
                ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

                dwStyle = T::GetWndStyle(dwStyle);
                dwExStyle = T::GetWndExStyle(dwExStyle);

                return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rcPos, szWindowName,
                        dwStyle, dwExStyle, nID, atom, lpCreateParam);
        }
};

/////////////////////////////////////////////////////////////////////////////
// CDialogImpl - Implements a dialog box

template <class TBase = CWindow>
class ATL_NO_VTABLE CDialogImplBaseT : public CWindowImplRoot< TBase >
{
public:
	virtual DLGPROC GetDialogProc()
	{
		return DialogProc;
	}
	static INT_PTR CALLBACK StartDialogProc(HWND hWnd, UINT uMsg,
		WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL MapDialogRect(LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapDialogRect(m_hWnd, lpRect);
	}
	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		// override to do something, if needed
	}
	// has no meaning for a dialog, but needed for handlers that use it
	LRESULT DefWindowProc()
	{
		return 0;
	}
};

template <class TBase>
INT_PTR CALLBACK CDialogImplBaseT< TBase >::StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)_Module.ExtractCreateWndData();
        ATLASSERT(pThis != NULL);
        pThis->m_hWnd = hWnd;
        pThis->m_thunk.Init((WNDPROC)pThis->GetDialogProc(), pThis);
        DLGPROC pProc = (DLGPROC)(pThis->m_thunk.thunk.pThunk);
        DLGPROC pOldProc = (DLGPROC)::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LPARAM)pProc);
#ifdef _DEBUG
        // check if somebody has subclassed us already since we discard it
        if(pOldProc != StartDialogProc)
                ATLTRACE2(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
        pOldProc;        // avoid unused warning
#endif
        return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase>
INT_PTR CALLBACK CDialogImplBaseT< TBase >::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)hWnd;
        // set a ptr to this message and save the old value
        MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
        const MSG* pOldMsg = pThis->m_pCurrentMsg;
        pThis->m_pCurrentMsg = &msg;
        // pass to the message map to process
        LRESULT lRes;
        BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
        // restore saved value for the current message
        ATLASSERT(pThis->m_pCurrentMsg == &msg);
        pThis->m_pCurrentMsg = pOldMsg;
        // set result if message was handled
        if(bRet)
        {
                switch (uMsg)
                {
                case WM_COMPAREITEM:
                case WM_VKEYTOITEM:
                case WM_CHARTOITEM:
                case WM_INITDIALOG:
                case WM_QUERYDRAGICON:
                case WM_CTLCOLORMSGBOX:
                case WM_CTLCOLOREDIT:
                case WM_CTLCOLORLISTBOX:
                case WM_CTLCOLORBTN:
                case WM_CTLCOLORDLG:
                case WM_CTLCOLORSCROLLBAR:
                case WM_CTLCOLORSTATIC:
                        return lRes;
                        break;
                }
                ::SetWindowLongPtr(pThis->m_hWnd, DWLP_MSGRESULT, lRes);
                return TRUE;
        }
        if(uMsg == WM_NCDESTROY)
        {
                // clear out window handle
                HWND hWnd = pThis->m_hWnd;
                pThis->m_hWnd = NULL;
                // clean up after dialog is destroyed
                pThis->OnFinalMessage(hWnd);
        }
        return FALSE;
}

typedef CDialogImplBaseT<CWindow>        CDialogImplBase;

template <class T, class TBase /* = CWindow */>
class ATL_NO_VTABLE CDialogImpl : public CDialogImplBaseT< TBase >
{
public:
#ifdef _DEBUG
        bool m_bModal;
        CDialogImpl() : m_bModal(false) { }
#endif //_DEBUG
        // modal dialogs
        INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
        {
                ATLASSERT(m_hWnd == NULL);
                _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
                m_bModal = true;
#endif //_DEBUG
		return ::DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
	}
	BOOL EndDialog(INT_PTR nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_bModal);	// must be a modal dialog
		return ::EndDialog(m_hWnd, nRetCode);
	}
	// modeless dialogs
	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
                m_bModal = false;
#endif //_DEBUG
		HWND hWnd = ::CreateDialogParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}
	// for CComControl
	HWND Create(HWND hWndParent, RECT&, LPARAM dwInitParam = NULL)
	{
		return Create(hWndParent, dwInitParam);
	}
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(!m_bModal);	// must not be a modal dialog
		return ::DestroyWindow(m_hWnd);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CAxDialogImpl - Implements a dialog box that hosts ActiveX controls

#ifndef _ATL_NO_HOSTING

template <class T, class TBase /* = CWindow */>
class ATL_NO_VTABLE CAxDialogImpl : public CDialogImplBaseT< TBase >
{
public:
#ifdef _DEBUG
        bool m_bModal;
        CAxDialogImpl() : m_bModal(false) { }
#endif //_DEBUG
        // modal dialogs
        INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
        {
                ATLASSERT(m_hWnd == NULL);
                _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
                m_bModal = true;
#endif //_DEBUG
		return AtlAxDialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
	}
	BOOL EndDialog(int nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_bModal);	// must be a modal dialog
		return ::EndDialog(m_hWnd, nRetCode);
	}
	// modeless dialogs
	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
                m_bModal = false;
#endif //_DEBUG
		HWND hWnd = AtlAxCreateDialog(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}
	// for CComControl
	HWND Create(HWND hWndParent, RECT&, LPARAM dwInitParam = NULL)
	{
		return Create(hWndParent, dwInitParam);
	}
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(!m_bModal);	// must not be a modal dialog
		return ::DestroyWindow(m_hWnd);
	}
};

#endif //_ATL_NO_HOSTING

/////////////////////////////////////////////////////////////////////////////
// CSimpleDialog - Prebuilt modal dialog that uses standard buttons

template <WORD t_wDlgTemplateID, BOOL t_bCenter /* = TRUE */>
class CSimpleDialog : public CDialogImplBase
{
public:
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
		INT_PTR nRet = ::DialogBox(_Module.GetResourceInstance(),
			MAKEINTRESOURCE(t_wDlgTemplateID), hWndParent, StartDialogProc);
		m_hWnd = NULL;
		return nRet;
	}

        typedef CSimpleDialog<t_wDlgTemplateID, t_bCenter>        thisClass;
        BEGIN_MSG_MAP(thisClass)
                MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
                COMMAND_RANGE_HANDLER(IDOK, IDNO, OnCloseCmd)
        END_MSG_MAP()

        LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
        {
                if(t_bCenter)
                        CenterWindow(GetParent());
                return TRUE;
        }

        LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
        {
                ::EndDialog(m_hWnd, wID);
                return 0;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CContainedWindow - Implements a contained window

template <class TBase /* = CWindow */, class TWinTraits /* = CControlWinTraits */>
class CContainedWindowT : public TBase
{
public:
        CWndProcThunk m_thunk;
        LPCTSTR m_lpszClassName;
        WNDPROC m_pfnSuperWindowProc;
        CMessageMap* m_pObject;
        DWORD m_dwMsgMapID;
        const MSG* m_pCurrentMsg;

        // If you use this constructor you must supply
        // the Window Class Name, Object* and Message Map ID
        // Later to the Create call
        CContainedWindowT() : m_pCurrentMsg(NULL)
        { }

        CContainedWindowT(LPTSTR lpszClassName, CMessageMap* pObject, DWORD dwMsgMapID = 0)
                : m_lpszClassName(lpszClassName),
                m_pfnSuperWindowProc(::DefWindowProc),
                m_pObject(pObject), m_dwMsgMapID(dwMsgMapID),
                m_pCurrentMsg(NULL)
        { }

        CContainedWindowT(CMessageMap* pObject, DWORD dwMsgMapID = 0)
                : m_lpszClassName(TBase::GetWndClassName()),
                m_pfnSuperWindowProc(::DefWindowProc),
                m_pObject(pObject), m_dwMsgMapID(dwMsgMapID),
                m_pCurrentMsg(NULL)
        { }

        void SwitchMessageMap(DWORD dwMsgMapID)
        {
                m_dwMsgMapID = dwMsgMapID;
        }

        const MSG* GetCurrentMessage() const
        {
                return m_pCurrentMsg;
        }

        LRESULT DefWindowProc()
        {
                const MSG* pMsg = m_pCurrentMsg;
                LRESULT lRes = 0;
                if (pMsg != NULL)
                        lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
                return lRes;
        }

        LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
        {
#ifdef STRICT
                return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
                return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
        }
        static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg,
                WPARAM wParam, LPARAM lParam)
        {
                CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)_Module.ExtractCreateWndData();
                ATLASSERT(pThis != NULL);
                pThis->m_hWnd = hWnd;
                pThis->m_thunk.Init(WindowProc, pThis);
                WNDPROC pProc = (WNDPROC)(pThis->m_thunk.thunk.pThunk);
                WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
                // check if somebody has subclassed us already since we discard it
                if(pOldProc != StartWindowProc)
                        ATLTRACE2(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
                pOldProc;        // avoid unused warning
#endif
                return pProc(hWnd, uMsg, wParam, lParam);
        }

        static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        {
                CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)hWnd;
                ATLASSERT(pThis->m_hWnd != NULL);
                ATLASSERT(pThis->m_pObject != NULL);
                // set a ptr to this message and save the old value
                MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
                const MSG* pOldMsg = pThis->m_pCurrentMsg;
                pThis->m_pCurrentMsg = &msg;
                // pass to the message map to process
                LRESULT lRes;
                BOOL bRet = pThis->m_pObject->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, pThis->m_dwMsgMapID);
                // restore saved value for the current message
                ATLASSERT(pThis->m_pCurrentMsg == &msg);
                pThis->m_pCurrentMsg = pOldMsg;
                // do the default processing if message was not handled
                if(!bRet)
                {
                        if(uMsg != WM_NCDESTROY)
                                lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
                        else
                        {
                                // unsubclass, if needed
                                LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
                                lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
                                if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
                                        ::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
                                // clear out window handle
                                pThis->m_hWnd = NULL;
                        }
                }
                return lRes;
        }

        ATOM RegisterWndSuperclass()
        {
                ATOM atom = 0;
                LPTSTR szBuff = (LPTSTR)_alloca((lstrlen(m_lpszClassName) + 14) * sizeof(TCHAR));

                WNDCLASSEX wc;
                wc.cbSize = sizeof(WNDCLASSEX);

                // Try global class
                if(!::GetClassInfoEx(NULL, m_lpszClassName, &wc))
                {
                        // try local class
                        if(!::GetClassInfoEx(_Module.GetModuleInstance(), m_lpszClassName, &wc))
                                return atom;
                }

                m_pfnSuperWindowProc = wc.lpfnWndProc;
                lstrcpy(szBuff, _T("ATL:"));
                lstrcat(szBuff, m_lpszClassName);                

                WNDCLASSEX wc1;
                wc1.cbSize = sizeof(WNDCLASSEX);
                atom = (ATOM)::GetClassInfoEx(_Module.GetModuleInstance(), szBuff, &wc1);

                if(atom == 0)   // register class
                {
                        wc.lpszClassName = szBuff;
                        wc.lpfnWndProc = StartWindowProc;
                        wc.hInstance = _Module.GetModuleInstance();
                        wc.style &= ~CS_GLOBALCLASS;        // we don't register global classes

                        atom = ::RegisterClassEx(&wc);
                }

                return atom;
        }
        HWND Create(CMessageMap* pObject, DWORD dwMsgMapID, HWND hWndParent, RECT* prcPos,
                LPCTSTR szWindowName = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0,
                UINT nID = 0, LPVOID lpCreateParam = NULL)
        {
                m_lpszClassName = TBase::GetWndClassName();
                m_pfnSuperWindowProc = ::DefWindowProc;
                m_pObject = pObject;
                m_dwMsgMapID = dwMsgMapID;
                return Create(hWndParent, prcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
        }

        HWND Create(LPCTSTR lpszClassName, CMessageMap* pObject, DWORD dwMsgMapID, HWND hWndParent, RECT* prcPos, LPCTSTR szWindowName = NULL,
                DWORD dwStyle = 0, DWORD dwExStyle = 0, UINT nID = 0, LPVOID lpCreateParam = NULL)
        {
                m_lpszClassName = lpszClassName;
                m_pfnSuperWindowProc = ::DefWindowProc;
                m_pObject = pObject;
                m_dwMsgMapID = dwMsgMapID;
                return Create(hWndParent, prcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
        }


        // This function is Deprecated, use the version
        // which takes a RECT* instead
        HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
                DWORD dwStyle = 0, DWORD dwExStyle = 0,
                UINT nID = 0, LPVOID lpCreateParam = NULL)
        {
                return Create(hWndParent, &rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
        }

        HWND Create(HWND hWndParent, RECT* prcPos, LPCTSTR szWindowName = NULL,
                DWORD dwStyle = 0, DWORD dwExStyle = 0,
                UINT nID = 0, LPVOID lpCreateParam = NULL)
        {
                ATLASSERT(m_hWnd == NULL);

                ATOM atom = RegisterWndSuperclass();
                if(atom == 0)
                        return NULL;

                _Module.AddCreateWndData(&m_thunk.cd, this);

                dwStyle = TWinTraits::GetWndStyle(dwStyle);
                dwExStyle = TWinTraits::GetWndExStyle(dwExStyle);

                HWND hWnd = ::CreateWindowEx(dwExStyle, MAKEINTATOM(atom), szWindowName,
                                                                dwStyle,
                                                                prcPos->left, prcPos->top,
                                                                prcPos->right - prcPos->left,
                                                                prcPos->bottom - prcPos->top,
                                                                hWndParent, 
                                                                (nID == 0 && (dwStyle & WS_CHILD)) ? (HMENU)this : (HMENU)(DWORD_PTR)nID,
                                                                _Module.GetModuleInstance(), lpCreateParam);
                ATLASSERT(m_hWnd == hWnd);
                return hWnd;
        }

        BOOL SubclassWindow(HWND hWnd)
        {
                ATLASSERT(m_hWnd == NULL);
                ATLASSERT(::IsWindow(hWnd));

                m_thunk.Init(WindowProc, this);
                WNDPROC pProc = (WNDPROC)m_thunk.thunk.pThunk;
                WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
                if(pfnWndProc == NULL)
                        return FALSE;
                m_pfnSuperWindowProc = pfnWndProc;
                m_hWnd = hWnd;
                return TRUE;
        }

        // Use only if you want to subclass before window is destroyed,
        // WindowProc will automatically subclass when  window goes away
        HWND UnsubclassWindow(BOOL bForce = FALSE)
        {
                ATLASSERT(m_hWnd != NULL);

                WNDPROC pOurProc = (WNDPROC)(m_thunk.thunk.pThunk);
                WNDPROC pActiveProc = (WNDPROC)::GetWindowLongPtr(m_hWnd, GWLP_WNDPROC);

                HWND hWnd = NULL;
                if (bForce || pOurProc == pActiveProc)
                {
                        if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
                                return NULL;

                        m_pfnSuperWindowProc = ::DefWindowProc;
                        hWnd = m_hWnd;
                        m_hWnd = NULL;
                }
                return hWnd;
        }
};

typedef CContainedWindowT<CWindow>        CContainedWindow;

/////////////////////////////////////////////////////////////////////////////
// _DialogSizeHelper - helpers for calculating the size of a dialog template

class _DialogSizeHelper
{
public:
//local struct used for implementation
#pragma pack(push, 1)
        struct _ATL_DLGTEMPLATEEX
        {
                WORD dlgVer;
                WORD signature;
                DWORD helpID;
                DWORD exStyle;
                DWORD style;
                WORD cDlgItems;
                short x;
                short y;
                short cx;
                short cy;
        };
#pragma pack(pop)

        static void GetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize)
        {
                // If the dialog has a font we use it otherwise we default
                // to the system font.
                if (HasFont(pTemplate))
                {
                        TCHAR szFace[LF_FACESIZE];                                        
                        WORD  wFontSize = 0;
                        GetFont(pTemplate, szFace, &wFontSize);                
                        GetSizeInDialogUnits(pTemplate, pSize);
                        ConvertDialogUnitsToPixels(szFace, wFontSize, pSize);
                }
                else
                {
                        GetSizeInDialogUnits(pTemplate, pSize);
                        LONG nDlgBaseUnits = GetDialogBaseUnits();
                        pSize->cx = MulDiv(pSize->cx, LOWORD(nDlgBaseUnits), 4);
                        pSize->cy = MulDiv(pSize->cy, HIWORD(nDlgBaseUnits), 8);
                }
        }

        static void ConvertDialogUnitsToPixels(LPCTSTR pszFontFace, WORD wFontSize, SIZE* pSizePixel)
        {
                // Attempt to create the font to be used in the dialog box
                UINT cxSysChar, cySysChar;
                LOGFONT lf;
                HDC hDC = ::GetDC(NULL);
                int cxDlg = pSizePixel->cx;
                int cyDlg = pSizePixel->cy;

                ZeroMemory(&lf, sizeof(LOGFONT));
                lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
                lf.lfWeight = FW_NORMAL;
                lf.lfCharSet = DEFAULT_CHARSET;
                lstrcpyn(lf.lfFaceName, pszFontFace, sizeof lf.lfFaceName / sizeof lf.lfFaceName[0]);

                HFONT hNewFont = CreateFontIndirect(&lf);
                if (hNewFont != NULL)
                {
                        TEXTMETRIC  tm;
                        SIZE        size;
                        HFONT       hFontOld = (HFONT)SelectObject(hDC, hNewFont);
                        GetTextMetrics(hDC, &tm);
                        cySysChar = tm.tmHeight + tm.tmExternalLeading;
                        ::GetTextExtentPoint(hDC,
                                _T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52,
                                &size);
                        cxSysChar = (size.cx + 26) / 52;
                        SelectObject(hDC, hFontOld);
                        DeleteObject(hNewFont);
                }
                else
                {
                        // Could not create the font so just use the system's values
                        cxSysChar = LOWORD(GetDialogBaseUnits());
                        cySysChar = HIWORD(GetDialogBaseUnits());
                }
                ::ReleaseDC(NULL, hDC);

                // Translate dialog units to pixels
                pSizePixel->cx = MulDiv(cxDlg, cxSysChar, 4);
                pSizePixel->cy = MulDiv(cyDlg, cySysChar, 8);
        }

        static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
        {
                return ((_ATL_DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
        }

        static BOOL HasFont(const DLGTEMPLATE* pTemplate)
        {
                return (DS_SETFONT &
                        (IsDialogEx(pTemplate) ?
                                ((_ATL_DLGTEMPLATEEX*)pTemplate)->style : pTemplate->style));
        }

        static BYTE* GetFontSizeField(const DLGTEMPLATE* pTemplate)
        {
                BOOL bDialogEx = IsDialogEx(pTemplate);
                WORD* pw;

                if (bDialogEx)
                        pw = (WORD*)((_ATL_DLGTEMPLATEEX*)pTemplate + 1);
                else
                        pw = (WORD*)(pTemplate + 1);

                if (*pw == (WORD)-1)        // Skip menu name string or ordinal
                        pw += 2; // WORDs
                else
                        while(*pw++);

                if (*pw == (WORD)-1)        // Skip class name string or ordinal
                        pw += 2; // WORDs
                else
                        while(*pw++);

                while (*pw++);          // Skip caption string

                return (BYTE*)pw;
        }

        static BOOL GetFont(const DLGTEMPLATE* pTemplate, TCHAR* pszFace, WORD* pFontSize)
        {
                USES_CONVERSION;
                if (!HasFont(pTemplate))
                        return FALSE;

                BYTE* pb = GetFontSizeField(pTemplate);
                *pFontSize = *(WORD*)pb;
                // Skip over font attributes to get to the font name
                pb += sizeof(WORD) * (IsDialogEx(pTemplate) ? 3 : 1);
                
                _tcsncpy(pszFace, W2T((WCHAR*)pb), LF_FACESIZE);
                if (_tcslen(pszFace) >= LF_FACESIZE) 
                {        // NUL not appended
                        pszFace[LF_FACESIZE-1] = _T('\0');
                }
                return TRUE;
        }

        static void GetSizeInDialogUnits(const DLGTEMPLATE* pTemplate, SIZE* pSize)
        {
                if (IsDialogEx(pTemplate))
                {
                        pSize->cx = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cx;
                        pSize->cy = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cy;
                }
                else
                {
                        pSize->cx = pTemplate->cx;
                        pSize->cy = pTemplate->cy;
                }
        }
};

inline void AtlGetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize)
{
        _DialogSizeHelper::GetDialogSize(pTemplate, pSize);
}

}; //namespace ATL

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLWIN_IMPL
#endif
#endif

#endif // __ATLWIN_H__

//All exports go here
#ifdef _ATLWIN_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

ATLINLINE ATLAPI_(ATOM) AtlModuleRegisterWndClassInfoA(_ATL_MODULE* pM, _ATL_WNDCLASSINFOA* p, WNDPROC* pProc)
{                
        BOOL fFail = FALSE;
        if (p->m_atom == 0)
        {

                ::EnterCriticalSection(&pM->m_csWindowCreate);
                __try 
                {
                        if(p->m_atom == 0)
                        {
                                HINSTANCE hInst = pM->m_hInst;
                                if (p->m_lpszOrigName != NULL)
                                {
                                        ATLASSERT(pProc != NULL);
                                        LPCSTR lpsz = p->m_wc.lpszClassName;
                                        WNDPROC proc = p->m_wc.lpfnWndProc;

                                        WNDCLASSEXA wc;
                                        wc.cbSize = sizeof(WNDCLASSEX);
                                        // Try global class
                                        if(!::GetClassInfoExA(NULL, p->m_lpszOrigName, &wc))
                                        {
                                                // try process local
                                                if(!::GetClassInfoExA(_Module.GetModuleInstance(), p->m_lpszOrigName, &wc))
                                                {
                                                        fFail = TRUE;
                                                        __leave;
                                                }
                                        }
                                        memcpy(&p->m_wc, &wc, sizeof(WNDCLASSEX));
                                        p->pWndProc = p->m_wc.lpfnWndProc;
                                        p->m_wc.lpszClassName = lpsz;
                                        p->m_wc.lpfnWndProc = proc;
                                }
                                else
                                {
                                        p->m_wc.hCursor = ::LoadCursorA(p->m_bSystemCursor ? NULL : hInst,
                                                p->m_lpszCursorID);
                                }

                                p->m_wc.hInstance = hInst;
                                p->m_wc.style &= ~CS_GLOBALCLASS;        // we don't register global classes
                                if (p->m_wc.lpszClassName == NULL)
                                {
#ifdef _WIN64       // %p isn't available on Win2k/Win9x
                                        wsprintfA(p->m_szAutoName, "ATL:%p", &p->m_wc);
#else
                                        wsprintfA(p->m_szAutoName, "ATL:%8.8X", PtrToUlong(&p->m_wc));
#endif
                                        p->m_wc.lpszClassName = p->m_szAutoName;
                                }
                                WNDCLASSEXA wcTemp;
                                memcpy(&wcTemp, &p->m_wc, sizeof(WNDCLASSEXW));
                                p->m_atom = (ATOM)::GetClassInfoExA(p->m_wc.hInstance, p->m_wc.lpszClassName, &wcTemp);
                                if (p->m_atom == 0)
                                        p->m_atom = ::RegisterClassExA(&p->m_wc);
                        }
                }
                __finally 
                {
                        ::LeaveCriticalSection(&pM->m_csWindowCreate);
                }
        }

        if (fFail)
        {
                return 0;
        }

        if (p->m_lpszOrigName != NULL)
        {
                ATLASSERT(pProc != NULL);
                ATLASSERT(p->pWndProc != NULL);
                *pProc = p->pWndProc;
        }
        return p->m_atom;
}

ATLINLINE ATLAPI_(ATOM) AtlModuleRegisterWndClassInfoW(_ATL_MODULE* pM, _ATL_WNDCLASSINFOW* p, WNDPROC* pProc)
{
        BOOL fFail = FALSE;

        if (p->m_atom == 0)
        {
                ::EnterCriticalSection(&pM->m_csWindowCreate);        
                __try
                {
                        if(p->m_atom == 0)
                        {
                                HINSTANCE hInst = pM->m_hInst;
                                if (p->m_lpszOrigName != NULL)
                                {
                                        ATLASSERT(pProc != NULL);
                                        LPCWSTR lpsz = p->m_wc.lpszClassName;
                                        WNDPROC proc = p->m_wc.lpfnWndProc;

                                        WNDCLASSEXW wc;
                                        wc.cbSize = sizeof(WNDCLASSEX);
                                        // Try global class
                                        if(!::GetClassInfoExW(NULL, p->m_lpszOrigName, &wc))
                                        {
                                                // try process local
                                                if(!::GetClassInfoExW(_Module.GetModuleInstance(), p->m_lpszOrigName, &wc))
                                                {
                                                        fFail = TRUE;
                                                        __leave;
                                                }
                                        }
                                        memcpy(&p->m_wc, &wc, sizeof(WNDCLASSEX));
                                        p->pWndProc = p->m_wc.lpfnWndProc;
                                        p->m_wc.lpszClassName = lpsz;
                                        p->m_wc.lpfnWndProc = proc;
                                }
                                else
                                {
                                        p->m_wc.hCursor = ::LoadCursorW(p->m_bSystemCursor ? NULL : hInst,
                                                p->m_lpszCursorID);
                                }

                                p->m_wc.hInstance = hInst;
                                p->m_wc.style &= ~CS_GLOBALCLASS;        // we don't register global classes
                                if (p->m_wc.lpszClassName == NULL)
                                {
#ifdef _WIN64       // %p isn't available on Win2k/Win9x
                                        wsprintfW(p->m_szAutoName, L"ATL:%p", &p->m_wc);
#else
                                        wsprintfW(p->m_szAutoName, L"ATL:%8.8X", PtrToUlong(&p->m_wc));
#endif
                                        p->m_wc.lpszClassName = p->m_szAutoName;
                                }
                                WNDCLASSEXW wcTemp;
                                memcpy(&wcTemp, &p->m_wc, sizeof(WNDCLASSEXW));
                                p->m_atom = (ATOM)::GetClassInfoExW(p->m_wc.hInstance, p->m_wc.lpszClassName, &wcTemp);
                                if (p->m_atom == 0)
                                        p->m_atom = ::RegisterClassExW(&p->m_wc);
                        }
                }
                __finally
                {
                        ::LeaveCriticalSection(&pM->m_csWindowCreate);
                }
        }

        if (fFail)
        {
                return 0;
        }

        if (p->m_lpszOrigName != NULL)
        {
                ATLASSERT(pProc != NULL);
                ATLASSERT(p->pWndProc != NULL);
                *pProc = p->pWndProc;
        }
        return p->m_atom;
}

ATLINLINE ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd)
{
        USES_CONVERSION;

        // cases  hdc, ptd, hdc is metafile, hic
//  NULL,    NULL,  n/a,    Display
//  NULL,   !NULL,  n/a,    ptd
//  !NULL,   NULL,  FALSE,  hdc
//  !NULL,   NULL,  TRUE,   display
//  !NULL,  !NULL,  FALSE,  ptd
//  !NULL,  !NULL,  TRUE,   ptd

        if (ptd != NULL)
        {
                LPDEVMODEOLE lpDevMode;
                LPOLESTR lpszDriverName;
                LPOLESTR lpszDeviceName;
                LPOLESTR lpszPortName;

                if (ptd->tdExtDevmodeOffset == 0)
                        lpDevMode = NULL;
                else
                        lpDevMode  = (LPDEVMODEOLE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

                lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
                lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
                lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);
                
                return ::CreateDC(OLE2CT(lpszDriverName), OLE2CT(lpszDeviceName),
                        OLE2CT(lpszPortName), DEVMODEOLE2T(lpDevMode));
        }
        else if (hdc == NULL || GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
                return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
        else
                return hdc;
}

ATLINLINE ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
        int nPixelsPerInchX;    // Pixels per logical inch along width
        int nPixelsPerInchY;    // Pixels per logical inch along height

        HDC hDCScreen = GetDC(NULL);
        ATLASSERT(hDCScreen != NULL);
        if (hDCScreen != NULL)
        {
                nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
                nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
                ReleaseDC(NULL, hDCScreen);
        }
        else
        {
                nPixelsPerInchX = 1;
                nPixelsPerInchY = 1;
        }

        lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, nPixelsPerInchX);
        lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, nPixelsPerInchY);
}

ATLINLINE ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
        int nPixelsPerInchX;    // Pixels per logical inch along width
        int nPixelsPerInchY;    // Pixels per logical inch along height

        HDC hDCScreen = GetDC(NULL);
    if (hDCScreen) {
            nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
            nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
            ReleaseDC(NULL, hDCScreen);
    } else {
        nPixelsPerInchX = nPixelsPerInchY = 1;
    }

        lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
        lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
}


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time
#undef _ATLWIN_IMPL

#endif // _ATLWIN_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl30\statreg.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H
#define __STATREG_H

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

namespace ATL
{
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");

class CExpansionVector
{
public:
        //Declare EXPANDER struct.  Only used locally.
        struct EXPANDER
        {
                LPOLESTR    szKey;
                LPOLESTR    szValue;
        };

        CExpansionVector()
        {
                m_cEls = 0;
                m_nSize=10;
                m_p = (EXPANDER**)malloc(m_nSize*sizeof(EXPANDER*));
        }
        ~CExpansionVector()
        {
                 free(m_p);
        }
        HRESULT Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue)
        {
                HRESULT hr = S_OK;

                EXPANDER* pExpand = NULL;
                ATLTRY(pExpand = new EXPANDER);
                if (pExpand == NULL)
                        return E_OUTOFMEMORY;

                DWORD cbKey = (ocslen(lpszKey)+1)*sizeof(OLECHAR);
                DWORD cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);
                pExpand->szKey = (LPOLESTR)CoTaskMemAlloc(cbKey);
                pExpand->szValue = (LPOLESTR)CoTaskMemAlloc(cbValue);
                if (pExpand->szKey == NULL || pExpand->szValue == NULL)
                {
                        CoTaskMemFree(pExpand->szKey);
                        CoTaskMemFree(pExpand->szValue);
                        delete pExpand;
                        return E_OUTOFMEMORY;
                }
                memcpy(pExpand->szKey, lpszKey, cbKey);
                memcpy(pExpand->szValue, lpszValue, cbValue);

                if (m_cEls == m_nSize)
                {
                        m_nSize*=2;
                        EXPANDER** p;
                        p = (EXPANDER**)realloc(m_p, m_nSize*sizeof(EXPANDER*));
                        if (p == NULL)
                        {
                                CoTaskMemFree(pExpand->szKey);
                                CoTaskMemFree(pExpand->szValue);
                                delete pExpand;
                                m_nSize /=2;
                                hr = E_OUTOFMEMORY;
                        }
                        else
                                m_p = p;
                }

                if (SUCCEEDED(hr))
                {
                        ATLASSERT(m_p != NULL);
                        m_p[m_cEls] = pExpand;
                        m_cEls++;
                }

                return hr;
        }
        LPCOLESTR Find(LPTSTR lpszKey)
        {
                USES_CONVERSION_EX;
                for (int iExpand = 0; iExpand < m_cEls; iExpand++)
                {
                        LPTSTR lpOleStr = OLE2T_EX(m_p[iExpand]->szKey, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                        if (lpOleStr == NULL)
                        {
                                return NULL;
                        }
#endif // _UNICODE
                        if (!lstrcmpi(lpOleStr, lpszKey)) //are equal
                                return m_p[iExpand]->szValue;
                }
                return NULL;
        }
        HRESULT ClearReplacements()
        {
                for (int iExpand = 0; iExpand < m_cEls; iExpand++)
                {
                        EXPANDER* pExp = m_p[iExpand];
                        CoTaskMemFree(pExp->szValue);
                        CoTaskMemFree(pExp->szKey);
                        delete pExp;
                }
                m_cEls = 0;
                return S_OK;
        }

private:
        EXPANDER** m_p;
        int m_cEls;
        int m_nSize;
};

class CRegObject;

class CRegParser
{
public:
        CRegParser(CRegObject* pRegObj);

        HRESULT  PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg);
        HRESULT  RegisterBuffer(LPTSTR szReg, BOOL bRegister);

protected:

        void    SkipWhiteSpace();
        HRESULT NextToken(LPTSTR szToken);
        HRESULT AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken, bool bQuoteModule = false);
        BOOL    CanForceRemoveKey(LPCTSTR szKey);
        BOOL    HasSubKeys(HKEY hkey);
        BOOL    HasValues(HKEY hkey);
        HRESULT RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bInRecovery = FALSE);
        BOOL    IsSpace(TCHAR ch);
        LPTSTR  m_pchCur;

        CRegObject*     m_pRegObj;

        HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}
        HRESULT HandleReplacements(LPTSTR& szToken);
        HRESULT SkipAssignment(LPTSTR szToken);

        BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }
        static LPTSTR StrChr(LPTSTR lpsz, TCHAR ch);
        static LPCTSTR StrStr(LPCTSTR str1, LPCTSTR str2);
        static HKEY HKeyFromString(LPTSTR szToken);
        static BYTE ChToByte(const TCHAR ch);
        static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE& vt);
        static LPCTSTR rgszNeverDelete[];
        static const int cbNeverDelete;
        static const int MAX_VALUE;
        static const int MAX_TYPE;
        class CParseBuffer
        {
        public:
                int nPos;
                int nSize;
                LPTSTR p;
                CParseBuffer(int nInitial)
                {
                        nPos = 0;
                        nSize = nInitial;
                        p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));
                        if (!p) {
                            nSize = 0;
                        }
                }
                ~CParseBuffer()
                {
                        CoTaskMemFree(p);
                }
                BOOL AddChar(const TCHAR* pch)
                {
                        if (nPos == nSize) // realloc
                        {
                                LPTSTR pNew;
                                pNew = (LPTSTR) CoTaskMemRealloc(p, nSize*2*sizeof(TCHAR));
                                if (pNew == NULL)
                                        return FALSE;
                                nSize *= 2;
                                p = pNew;
                        }
                        p[nPos++] = *pch;
#ifndef _UNICODE
                        if (IsDBCSLeadByte(*pch))
                                p[nPos++] = *(pch + 1);
#endif
                        return TRUE;
                }
                BOOL AddString(LPCOLESTR lpsz)
                {
                        USES_CONVERSION_EX;
                        LPCTSTR lpszT = OLE2CT_EX(lpsz, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                        if (lpszT == NULL)
                        {
                                return FALSE;
                        }
                        while (*lpszT)
                        {
                                if (!AddChar(lpszT)) {
                                        return FALSE;
                                }
                                lpszT++;
                        }
                        return TRUE;
                }
                LPTSTR Detach()
                {
                        LPTSTR lp = p;
                        p = NULL;
                        return lp;
                }

        };
};

#if defined(_ATL_DLL) | defined(_ATL_DLL_IMPL)
class ATL_NO_VTABLE CRegObject
 : public IRegistrar
#else
class CRegObject
#endif
{
public:

        ~CRegObject(){ClearReplacements();}
        HRESULT FinalConstruct() {return S_OK;}
        void FinalRelease() {}


        // Map based methods
        HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem);
        HRESULT STDMETHODCALLTYPE ClearReplacements();
        LPCOLESTR StrFromMap(LPTSTR lpszKey);

        // Register via a given mechanism
        HRESULT STDMETHODCALLTYPE ResourceRegister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
        HRESULT STDMETHODCALLTYPE ResourceRegisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
        HRESULT STDMETHODCALLTYPE ResourceUnregister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
        HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
        HRESULT STDMETHODCALLTYPE FileRegister(LPCOLESTR bstrFileName)
        {
                return CommonFileRegister(bstrFileName, TRUE);
        }

        HRESULT STDMETHODCALLTYPE FileUnregister(LPCOLESTR bstrFileName)
        {
                return CommonFileRegister(bstrFileName, FALSE);
        }

        HRESULT STDMETHODCALLTYPE StringRegister(LPCOLESTR bstrData)
        {
                return RegisterWithString(bstrData, TRUE);
        }

        HRESULT STDMETHODCALLTYPE StringUnregister(LPCOLESTR bstrData)
        {
                return RegisterWithString(bstrData, FALSE);
        }

protected:

        HRESULT CommonFileRegister(LPCOLESTR pszFileName, BOOL bRegister);
        HRESULT RegisterFromResource(LPCOLESTR pszFileName, LPCTSTR pszID, LPCTSTR pszType, BOOL bRegister);
        HRESULT RegisterWithString(LPCOLESTR pszData, BOOL bRegister);

        static HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}

        CExpansionVector                                m_RepMap;
        CComObjectThreadModel::AutoCriticalSection      m_csMap;
};

inline HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem)
{
        m_csMap.Lock();
        HRESULT hr = m_RepMap.Add(lpszKey, lpszItem);
        m_csMap.Unlock();
        return hr;
}

inline HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID,
                                                                                 LPCTSTR szType, BOOL bRegister)
{
        USES_CONVERSION_EX;

        HRESULT     hr;
        CRegParser  parser(this);
        HINSTANCE   hInstResDll;
        HRSRC       hrscReg;
        HGLOBAL     hReg;
        DWORD       dwSize;
        LPSTR       szRegA;
        LPTSTR      szReg;

        LPCTSTR lpszBSTRFileName = OLE2CT_EX(bstrFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if (lpszBSTRFileName == NULL)
        {
                return E_OUTOFMEMORY;
        }
#endif // _UNICODE

        hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (NULL == hInstResDll)
        {
                ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %s\n"), lpszBSTRFileName);
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ReturnHR;
        }

        hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

        if (NULL == hrscReg)
        {
                if (DWORD_PTR(szID) <= 0xffff)
                        ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to FindResource on ID:%d TYPE:%s\n"),
                        (DWORD)(DWORD_PTR)szID, szType);
                else
                        ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to FindResource on ID:%s TYPE:%s\n"),
                        szID, szType);
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ReturnHR;
        }

        hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

        if (NULL == hReg)
        {
                ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to LoadResource \n"));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ReturnHR;
        }

        dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
        szRegA = (LPSTR)hReg;
        if (szRegA[dwSize] != NULL)
        {
                szRegA = (LPSTR)_ATL_SAFE_ALLOCA(dwSize+1, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                if (szRegA == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto ReturnHR;
                }
                memcpy(szRegA, (void*)hReg, dwSize+1);
                szRegA[dwSize] = NULL;
        }

        szReg = A2T_EX(szRegA, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

#ifndef _UNICODE
        if(szReg == NULL)
        {
                hr = E_OUTOFMEMORY;
                goto ReturnHR;
        }
#endif // _UNICODE

        hr = parser.RegisterBuffer(szReg, bRegister);

ReturnHR:

        if (NULL != hInstResDll)
                FreeLibrary((HMODULE)hInstResDll);
        return hr;
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
        USES_CONVERSION_EX;

        LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if (lpszT == NULL)
        {
                return E_OUTOFMEMORY;
        }
#endif // _UNICODE

        return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
        USES_CONVERSION_EX;
        if (szID == NULL || szType == NULL)
                return E_INVALIDARG;

        LPCTSTR lpszID = OLE2CT_EX(szID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
        LPCTSTR lpszType = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if (lpszID == NULL || lpszType == NULL)
        {
                return E_OUTOFMEMORY;
        }
#endif // _UNICODE
        return RegisterFromResource(szFileName, lpszID, lpszType, TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
        USES_CONVERSION_EX;
        LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if (lpszT == NULL)
        {
                return E_OUTOFMEMORY;
        }
#endif // _UNICODE
        return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, FALSE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
        USES_CONVERSION_EX;
        if (szID == NULL || szType == NULL)
                return E_INVALIDARG;

        LPCTSTR lpszID = OLE2CT_EX(szID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
        LPCTSTR lpszType = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if (lpszID == NULL || lpszType == NULL)
        {
                return E_OUTOFMEMORY;
        }
#endif // _UNICODE

        return RegisterFromResource(szFileName, lpszID, lpszType, FALSE);
}

inline HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister)
{
        USES_CONVERSION_EX;
        CRegParser  parser(this);


        LPCTSTR szReg = OLE2CT_EX(bstrData, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if (szReg == NULL)
        {
                return E_OUTOFMEMORY;
        }
#endif // _UNICODE
        HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);

        return hr;
}

inline HRESULT CRegObject::ClearReplacements()
{
        m_csMap.Lock();
        HRESULT hr = m_RepMap.ClearReplacements();
        m_csMap.Unlock();
        return hr;
}


inline LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey)
{
        m_csMap.Lock();
        LPCOLESTR lpsz = m_RepMap.Find(lpszKey);
        if (lpsz == NULL) // not found!!
                ATLTRACE2(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
        m_csMap.Unlock();
        return lpsz;
}

inline HRESULT CRegObject::CommonFileRegister(LPCOLESTR bstrFileName, BOOL bRegister)
{
        USES_CONVERSION_EX;

        CRegParser  parser(this);

        LPCTSTR lpszBSTRFileName = OLE2CT_EX(bstrFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
        if (lpszBSTRFileName == NULL)
        {
                return E_OUTOFMEMORY;
        }
#endif // _UNICODE

        HANDLE hFile = CreateFile(lpszBSTRFileName, GENERIC_READ, 0, NULL,
                                                          OPEN_EXISTING,
                                                          FILE_ATTRIBUTE_READONLY,
                                                          NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
                ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to CreateFile on %s\n"), lpszBSTRFileName);
                return HRESULT_FROM_WIN32(GetLastError());
        }

        HRESULT hRes = S_OK;
        DWORD cbRead;
        DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required
        char* szReg = (char*)_ATL_SAFE_ALLOCA(cbFile + 1, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
        if (szReg == NULL)
        {
                hRes = E_OUTOFMEMORY;
                goto ReturnHR;
        }
        if (ReadFile(hFile, szReg, cbFile, &cbRead, NULL) == 0)
        {
                ATLTRACE2(atlTraceRegistrar, 0, "Read Failed on file%s\n", lpszBSTRFileName);
                hRes =  HRESULT_FROM_WIN32(GetLastError());
        }
        if (SUCCEEDED(hRes))
        {
                szReg[cbRead] = NULL;
                LPTSTR szConverted = A2T_EX(szReg, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                if (szConverted == NULL)
                {
                        hRes =  E_OUTOFMEMORY;
                        goto ReturnHR;
                }
#endif // _UNICODE
                hRes = parser.RegisterBuffer(szConverted, bRegister);
        }
ReturnHR:
        CloseHandle(hFile);
        return hRes;
}

__declspec(selectany) LPCTSTR CRegParser::rgszNeverDelete[] = //Component Catagories
{
        _T("CLSID"), _T("TYPELIB")
};

__declspec(selectany) const int CRegParser::cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);
__declspec(selectany) const int CRegParser::MAX_VALUE=4096;
__declspec(selectany) const int CRegParser::MAX_TYPE=MAX_VALUE;


inline BOOL CRegParser::VTFromRegType(LPCTSTR szValueType, VARTYPE& vt)
{
        struct typemap
        {
                LPCTSTR lpsz;
                VARTYPE vt;
        };
        static const typemap map[] = {
                {szStringVal, VT_BSTR},
                {szDwordVal,  VT_UI4},
                {szBinaryVal, VT_UI1}
        };

        for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
        {
                if (!lstrcmpi(szValueType, map[i].lpsz))
                {
                        vt = map[i].vt;
                        return TRUE;
                }
        }

        return FALSE;

}

inline BYTE CRegParser::ChToByte(const TCHAR ch)
{
        switch (ch)
        {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                                return (BYTE) (ch - '0');
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                                return (BYTE) (10 + (ch - 'A'));
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                                return (BYTE) (10 + (ch - 'a'));
                default:
                                ATLASSERT(FALSE);
                                ATLTRACE2(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
                                return 0;
        }
}

inline HKEY CRegParser::HKeyFromString(LPTSTR szToken)
{
        struct keymap
        {
                LPCTSTR lpsz;
                HKEY hkey;
        };
        static const keymap map[] = {
                {_T("HKCR"), HKEY_CLASSES_ROOT},
                {_T("HKCU"), HKEY_CURRENT_USER},
                {_T("HKLM"), HKEY_LOCAL_MACHINE},
                {_T("HKU"),  HKEY_USERS},
                {_T("HKPD"), HKEY_PERFORMANCE_DATA},
                {_T("HKDD"), HKEY_DYN_DATA},
                {_T("HKCC"), HKEY_CURRENT_CONFIG},
                {_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
                {_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
                {_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
                {_T("HKEY_USERS"), HKEY_USERS},
                {_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
                {_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
                {_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
        };

        for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
        {
                if (!lstrcmpi(szToken, map[i].lpsz))
                        return map[i].hkey;
        }
        return NULL;
}

inline LPTSTR CRegParser::StrChr(LPTSTR lpsz, TCHAR ch)
{
        LPTSTR p = NULL;
        if (lpsz == NULL)
                return NULL;
        while (*lpsz)
        {
                if (*lpsz == ch)
                {
                        p = lpsz;
                        break;
                }
                lpsz = CharNext(lpsz);
        }
        return p;
}


inline LPCTSTR CRegParser::StrStr(LPCTSTR str1, LPCTSTR str2)
{
        TCHAR *cp = (TCHAR *) str1;
        TCHAR *s1, *s2;

        if ( !*str2 )
                return((TCHAR *)str1);

        while (*cp)
        {
                s1 = cp;
                s2 = (TCHAR *) str2;

        while ( *s1 && *s2 && !(*s1-*s2) )
        {
                        TCHAR* s1Temp = CharNext(s1);
                        TCHAR* s2Temp = CharNext(s2);
                        if (s1Temp - s1 != s2Temp - s2)
                                break;
                        while (s1 < s1Temp)
                        {
                                if (!(*(++s1) - *(++s2)))
                                        break;
                        }
                }

                if (!*s2)
                        return(cp);

                cp = CharNext(cp);
        }

        return(NULL);
}



inline CRegParser::CRegParser(CRegObject* pRegObj)
{
        m_pRegObj           = pRegObj;
        m_pchCur            = NULL;
}

inline BOOL CRegParser::IsSpace(TCHAR ch)
{
        switch (ch)
        {
                case _T(' '):
                case _T('\t'):
                case _T('\r'):
                case _T('\n'):
                                return TRUE;
        }

        return FALSE;
}

inline void CRegParser::SkipWhiteSpace()
{
        while(IsSpace(*m_pchCur))
                m_pchCur = CharNext(m_pchCur);
}

inline HRESULT CRegParser::NextToken(LPTSTR szToken)
{
        SkipWhiteSpace();

        // NextToken cannot be called at EOS
        if (NULL == *m_pchCur)
                return GenerateError(E_ATL_UNEXPECTED_EOS);

        LPCTSTR szOrig = szToken;
        // handle quoted value / key
        if (chQuote == *m_pchCur)
        {
                m_pchCur = CharNext(m_pchCur);

                while (NULL != *m_pchCur && !EndOfVar())
                {
                        if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
                                m_pchCur = CharNext(m_pchCur);

                        LPTSTR pchPrev = m_pchCur;
                        m_pchCur = CharNext(m_pchCur);

                        if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
                                return GenerateError(E_ATL_VALUE_TOO_LARGE);
                        for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
                                *szToken = *(pchPrev+i);
                }

                if (NULL == *m_pchCur)
                {
                        ATLTRACE2(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
                        return GenerateError(E_ATL_UNEXPECTED_EOS);
                }

                *szToken = NULL;
                m_pchCur = CharNext(m_pchCur);
        }

        else
        {   
                // Handle non-quoted ie parse up till first "White Space"
                while (NULL != *m_pchCur && !IsSpace(*m_pchCur))
                {
                        LPTSTR pchPrev = m_pchCur;
                        m_pchCur = CharNext(m_pchCur);
                        if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
                                return GenerateError(E_ATL_VALUE_TOO_LARGE);
                        for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
                                *szToken = *(pchPrev+i);
                }

                *szToken = NULL;
        }
        return S_OK;
}

inline HRESULT CRegParser::AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken, bool bQuoteModule)
{
        USES_CONVERSION_EX;
        HRESULT hr;

        TCHAR       *szTypeToken;
        VARTYPE     vt;
        LONG        lRes = ERROR_SUCCESS;
        UINT        nIDRes = 0;

        szTypeToken = (TCHAR *)malloc(sizeof(TCHAR)*MAX_TYPE);
        if (!szTypeToken) {
                return E_OUTOFMEMORY;
        }

        if (FAILED(hr = NextToken(szTypeToken))) {
                free(szTypeToken);
                return hr;
        }

        if (!VTFromRegType(szTypeToken, vt))
        {
                ATLTRACE2(atlTraceRegistrar, 0, _T("%s Type not supported\n"), szTypeToken);
                free(szTypeToken);
                return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
        }

        TCHAR *szValue;
        szValue = (TCHAR *)malloc(sizeof(TCHAR) * MAX_VALUE);
        if (!szValue) {
                free(szTypeToken);
                return E_OUTOFMEMORY;
        }
        SkipWhiteSpace();
        if (FAILED(hr = NextToken(szValue))) {
                free(szValue);
                free(szTypeToken);
                return hr;
        }

        ULONG ulVal;

        switch (vt)
        {
        case VT_BSTR:
                {
                LPTSTR pszValue = szValue;
                if (bQuoteModule)
                {
                        if (lstrlen(szValue) > MAX_VALUE - 2)
                                return E_FAIL;

                        TCHAR szModuleTemp[MAX_VALUE];
                        USES_CONVERSION_EX;
                        LPCOLESTR lpszVar = m_pRegObj->StrFromMap(_T("Module"));
                        if (lpszVar != NULL)
                        {
                                LPCTSTR szModule = OLE2CT_EX(lpszVar, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                                if (szModule != NULL)
                                {
                                        LPCTSTR p = StrStr(szValue, szModule);
                                        if (p != NULL)
                                        {
                                                if (p == szToken || *CharPrev(szValue, p) != '"')
                                                {
                                                        szModuleTemp[0] = 0;
                                                        lstrcpyn(szModuleTemp, szValue, (int)(p - szValue));
                                                        lstrcat(szModuleTemp, _T("\""));
                                                        lstrcat(szModuleTemp, szModule);
                                                        lstrcat(szModuleTemp, _T("\""));
                                                        lstrcat(szModuleTemp, p + lstrlen(szModule));
                                                        pszValue = szModuleTemp;
                                                }
                                        }
                                }
                                else
                                {
                                        return E_OUTOFMEMORY;
                                }
                        }
                }
                lRes = rkParent.SetValue(pszValue, szValueName);
                ATLTRACE2(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), pszValue, !szValueName ? _T("default") : szValueName);
                break;
                }
        case VT_UI4:
                {
                        LPOLESTR lpszV = T2OLE_EX(szValue, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
                        if(lpszV == NULL) 
                        {
                                free(szValue);
                                free(szTypeToken);
                                return E_OUTOFMEMORY;
                        }
#endif        
                        VarUI4FromStr(lpszV, 0, 0, &ulVal);
                        lRes = rkParent.SetValue(ulVal, szValueName);
                        ATLTRACE2(atlTraceRegistrar, 2, _T("Setting Value %d at %s\n"), ulVal, !szValueName ? _T("default") : szValueName);
                        break;
                }
        case VT_UI1:
                {
                        int cbValue = lstrlen(szValue);
                        if (cbValue & 0x00000001)
                        {
                                ATLTRACE2(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
                                free(szValue);
                                free(szTypeToken);
                                return E_FAIL;
                        }
                        int cbValDiv2 = cbValue/2;
                        BYTE* rgBinary = (BYTE*)_ATL_SAFE_ALLOCA(cbValDiv2*sizeof(BYTE), _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                        if (rgBinary == NULL) 
                        {
                                free(szValue);
                                free(szTypeToken);
                                return E_FAIL;
                        }
                        memset(rgBinary, 0, cbValDiv2);

                        for (int irg = 0; irg < cbValue; irg++)
                                rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));
                        lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);
                        break;
                }
        }

        if (ERROR_SUCCESS != lRes)
        {
                nIDRes = E_ATL_VALUE_SET_FAILED;
                hr = HRESULT_FROM_WIN32(lRes);
        }

        if (FAILED(hr = NextToken(szToken))) 
        {
                free(szValue);
                free(szTypeToken);
                return hr;
        }

        free(szValue);
        free(szTypeToken);
        return S_OK;
}

inline BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey)
{
        for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
                if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
                         return FALSE;                       // We cannot delete it

        return TRUE;
}

inline BOOL CRegParser::HasSubKeys(HKEY hkey)
{
        DWORD       cbSubKeys = 0;

        if (FAILED(RegQueryInfoKey(hkey, NULL, NULL, NULL,
                                                           &cbSubKeys, NULL, NULL,
                                                           NULL, NULL, NULL, NULL, NULL)))
        {
                ATLTRACE2(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
                ATLASSERT(FALSE);
                return FALSE;
        }

        return cbSubKeys > 0;
}

inline BOOL CRegParser::HasValues(HKEY hkey)
{
        DWORD       cbValues = 0;

        LONG lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL,
                                                                  NULL, NULL, NULL,
                                                                  &cbValues, NULL, NULL, NULL, NULL);
        if (ERROR_SUCCESS != lResult)
        {
                ATLTRACE2(atlTraceRegistrar, 0, _T("RegQueryInfoKey Failed "));
                ATLASSERT(FALSE);
                return FALSE;
        }

        if (1 == cbValues)
        {
                DWORD cbMaxName= MAX_VALUE;
                TCHAR szValueName[MAX_VALUE];
                // Check to see if the Value is default or named
                lResult = RegEnumValue(hkey, 0, szValueName, &cbMaxName, NULL, NULL, NULL, NULL);
                if (ERROR_SUCCESS == lResult && (szValueName[0] != NULL))
                        return TRUE; // Named Value means we have a value
                return FALSE;
        }

        return cbValues > 0; // More than 1 means we have a non-default value
}

inline HRESULT CRegParser::SkipAssignment(LPTSTR szToken)
{
        HRESULT hr;
        TCHAR szValue[MAX_VALUE];

        if (*szToken == chEquals)
        {
                if (FAILED(hr = NextToken(szToken)))
                        return hr;
                // Skip assignment
                SkipWhiteSpace();
                if (FAILED(hr = NextToken(szValue)))
                        return hr;
                if (FAILED(hr = NextToken(szToken)))
                        return hr;
        }

        return S_OK;
}

inline HRESULT CRegParser::PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg)
{
        USES_CONVERSION_EX;
        ATLASSERT(lpszReg != NULL);
        ATLASSERT(ppszReg != NULL);
        if (lpszReg == NULL || ppszReg == NULL)
                return E_POINTER;
        *ppszReg = NULL;
        int nSize = lstrlen(lpszReg)*2;
        CParseBuffer pb(nSize);
        if (pb.p == NULL)
                return E_OUTOFMEMORY;
        m_pchCur = lpszReg;
        HRESULT hr = S_OK;

        while (*m_pchCur != NULL) // look for end
        {
                if (*m_pchCur == _T('%'))
                {
                        m_pchCur = CharNext(m_pchCur);
                        if (*m_pchCur == _T('%'))
                                pb.AddChar(m_pchCur);
                        else
                        {
                                LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));
                                if (lpszNext == NULL)
                                {
                                        ATLTRACE2(atlTraceRegistrar, 0, _T("Error no closing %% found\n"));
                                        hr = GenerateError(E_ATL_UNEXPECTED_EOS);
                                        break;
                                }
                                int nLength = int(lpszNext - m_pchCur);
                                if (nLength > 31)
                                {
                                        hr = E_FAIL;
                                        break;
                                }
                                TCHAR buf[32];
                                lstrcpyn(buf, m_pchCur, nLength+1);
                                LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);
                                if (lpszVar == NULL)
                                {
                                        hr = GenerateError(E_ATL_NOT_IN_MAP);
                                        break;
                                }
                                pb.AddString(lpszVar);
                                while (m_pchCur != lpszNext)
                                        m_pchCur = CharNext(m_pchCur);
                        }
                }
                else
                        pb.AddChar(m_pchCur);
                m_pchCur = CharNext(m_pchCur);
        }
        pb.AddChar(m_pchCur);
        if (SUCCEEDED(hr))
                *ppszReg = pb.Detach();
        return hr;
}

inline HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister)
{
        TCHAR   szToken[MAX_VALUE];
        HRESULT hr = S_OK;

        LPTSTR szReg = NULL;
        hr = PreProcessBuffer(szBuffer, &szReg);
        if (FAILED(hr))
                return hr;

#if defined(_DEBUG) && defined(DEBUG_REGISTRATION)
        OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
        OutputDebugString(_T("\n"));
#endif //_DEBUG

        m_pchCur = szReg;

        // Preprocess szReg

        while (NULL != *m_pchCur)
        {
                if (FAILED(hr = NextToken(szToken)))
                        break;
                HKEY hkBase;
                if ((hkBase = HKeyFromString(szToken)) == NULL)
                {
                        ATLTRACE2(atlTraceRegistrar, 0, _T("HKeyFromString failed on %s\n"), szToken);
                        hr = GenerateError(E_ATL_BAD_HKEY);
                        break;
                }

                if (FAILED(hr = NextToken(szToken)))
                        break;

                if (chLeftBracket != *szToken)
                {
                        ATLTRACE2(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
                        hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
                        break;
                }
                if (bRegister)
                {
                        LPTSTR szRegAtRegister = m_pchCur;
                        hr = RegisterSubkeys(szToken, hkBase, bRegister);
                        if (FAILED(hr))
                        {
                                ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
                                m_pchCur = szRegAtRegister;
                                RegisterSubkeys(szToken, hkBase, FALSE);
                                break;
                        }
                }
                else
                {
                        if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))
                                break;
                }

                SkipWhiteSpace();
        }
        CoTaskMemFree(szReg);
        return hr;
}

inline HRESULT CRegParser::RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bRecover)
{
        USES_ATL_SAFE_ALLOCA;
        CRegKey keyCur;
        LONG    lRes;
        LPTSTR  szKey = NULL;
        BOOL    bDelete = TRUE;
        BOOL    bInRecovery = bRecover;
        HRESULT hr = S_OK;

        ATLTRACE2(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);
        if (FAILED(hr = NextToken(szToken)))
                return hr;


        while (*szToken != chRightBracket) // Continue till we see a }
        {
                BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

                if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)
                {
                        if (FAILED(hr = NextToken(szToken)))
                                break;

                        if (bRegister)
                        {
                                CRegKey rkForceRemove;

                                if (StrChr(szToken, chDirSep) != NULL)
                                        return GenerateError(E_ATL_COMPOUND_KEY);

                                if (CanForceRemoveKey(szToken))
                                {
                                        rkForceRemove.Attach(hkParent);
                                        rkForceRemove.RecurseDeleteKey(szToken);
                                        rkForceRemove.Detach();
                                }
                                if (bTokenDelete)
                                {
                                        if (FAILED(hr = NextToken(szToken)))
                                                break;
                                        if (FAILED(hr = SkipAssignment(szToken)))
                                                break;
                                        goto EndCheck;
                                }
                        }

                }

                if (!lstrcmpi(szToken, szNoRemove))
                {
                        bDelete = FALSE;    // set even for register
                        if (FAILED(hr = NextToken(szToken)))
                                break;
                }

                if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
                {
                        TCHAR  szValueName[_MAX_PATH];

                        if (FAILED(hr = NextToken(szValueName)))
                                break;
                        if (FAILED(hr = NextToken(szToken)))
                                break;


                        if (*szToken != chEquals)
                                return GenerateError(E_ATL_EXPECTING_EQUAL);

                        if (bRegister)
                        {
                                CRegKey rk;

                                rk.Attach(hkParent);
                                hr = AddValue(rk, szValueName, szToken);
                                rk.Detach();

                                if (FAILED(hr))
                                        return hr;

                                goto EndCheck;
                        }
                        else
                        {
                                if (!bRecover)
                                {
                                        ATLTRACE2(atlTraceRegistrar, 1, _T("Deleting %s\n"), szValueName);
                    CRegKey rkParent;
                    lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);
                    if (lRes == ERROR_SUCCESS)
                    {
                        lRes = rkParent.DeleteValue(szValueName);
                        if ((lRes != ERROR_SUCCESS) && (lRes != ERROR_FILE_NOT_FOUND))
                        {
                            // Key not present is not an error
                            hr = HRESULT_FROM_WIN32(lRes);
                            break;
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(lRes);
                        break;
                    }
                                }

                                if (FAILED(hr = SkipAssignment(szToken)))
                                        break;
                                continue;  // can never have a subkey
                        }
                }

                if (StrChr(szToken, chDirSep) != NULL)
                        return GenerateError(E_ATL_COMPOUND_KEY);

                if (bRegister)
                {
                        lRes = keyCur.Open(hkParent, szToken, KEY_ALL_ACCESS);
                        if (ERROR_SUCCESS != lRes)
                        {
                                // Failed all access try read only
                                lRes = keyCur.Open(hkParent, szToken, KEY_READ);
                                if (ERROR_SUCCESS != lRes)
                                {
                                        // Finally try creating it
                                        ATLTRACE2(atlTraceRegistrar, 2, _T("Creating key %s\n"), szToken);
                                        lRes = keyCur.Create(hkParent, szToken, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
                                        if (ERROR_SUCCESS != lRes)
                                                return GenerateError(E_ATL_CREATE_KEY_FAILED);
                                }
                        }
                        
                        bool bQuoteModule = false;
                        if ((*szToken == 'L' || *szToken == 'l') && lstrcmpi(szToken, _T("LocalServer32")) == 0)
                                bQuoteModule = true;

                        if (FAILED(hr = NextToken(szToken)))
                                break;


                        if (*szToken == chEquals)
                        {
                                if (FAILED(hr = AddValue(keyCur, NULL, szToken, bQuoteModule))) // NULL == default
                                        break;
                        }
                }
                else
                {
                        if (!bRecover && keyCur.Open(hkParent, szToken, KEY_READ) != ERROR_SUCCESS)
                                bRecover = TRUE;

                        // TRACE out Key open status and if in recovery mode
#ifdef _DEBUG
                        if (!bRecover)
                                ATLTRACE2(atlTraceRegistrar, 1, _T("Opened Key %s\n"), szToken);
                        else
                                ATLTRACE2(atlTraceRegistrar, 0, _T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
#endif //_DEBUG

                        // Remember Subkey
                        if (szKey == NULL) 
                        {
                                szKey = (LPTSTR)_ATL_SAFE_ALLOCA(sizeof(TCHAR)*_MAX_PATH, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
                                if (szKey == NULL)
                                        return E_OUTOFMEMORY;
                        }
                        lstrcpyn(szKey, szToken, _MAX_PATH);

                        // If in recovery mode

                        if (bRecover || HasSubKeys(keyCur) || HasValues(keyCur))
                        {
                                if (FAILED(hr = NextToken(szToken)))
                                        break;
                                if (FAILED(hr = SkipAssignment(szToken)))
                                        break;


                                if (*szToken == chLeftBracket)
                                {
                                        if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover)))
                                                break;
                                        if (bRecover) // Turn off recovery if we are done
                                        {
                                                bRecover = bInRecovery;
                                                ATLTRACE2(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
                                                if (FAILED(hr = NextToken(szToken)))
                                                        break;
                                                if (FAILED(hr = SkipAssignment(szToken)))
                                                        break;
                                                continue;
                                        }
                                }

                                if (!bRecover && HasSubKeys(keyCur))
                                {
                                        // See if the KEY is in the NeverDelete list and if so, don't
                                        if (CanForceRemoveKey(szKey))
                                        {
                                                ATLTRACE2(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %s by force\n"), szKey);
                                                keyCur.RecurseDeleteKey(szKey);
                                        }
                                        if (FAILED(hr = NextToken(szToken)))
                                                break;
                                        continue;
                                }

                                if (bRecover)
                                        continue;
                        }

                        if (!bRecover && keyCur.Close() != ERROR_SUCCESS)
                           return GenerateError(E_ATL_CLOSE_KEY_FAILED);

                        if (!bRecover && bDelete)
                        {
                                ATLTRACE2(atlTraceRegistrar, 0, _T("Deleting Key %s\n"), szKey);
                                CRegKey rkParent;
                                rkParent.Attach(hkParent);
                                rkParent.DeleteSubKey(szKey);
                                rkParent.Detach();
                        }

                        if (FAILED(hr = NextToken(szToken)))
                                break;
                        if (FAILED(hr = SkipAssignment(szToken)))
                                break;
                }

EndCheck:

                if (bRegister)
                {
                        if (*szToken == chLeftBracket && lstrlen(szToken) == 1)
                        {
                                if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))
                                        break;
                                if (FAILED(hr = NextToken(szToken)))
                                        break;
                        }
                }
        }

        return hr;
}

}; //namespace ATL

#endif //__STATREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
#ifdef USE_ARRAY_NEW_DELETE
void * __cdecl operator new[](size_t);

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#endif

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

#if     _MSC_VER >= 1200


#ifdef USE_ARRAY_NEW_DELETE
void __cdecl operator delete[](void *);
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
#ifdef USE_ARRAY_NEW_DELETE
void * __cdecl operator new[](size_t);

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );
#endif

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200
#ifdef USE_ARRAY_NEW_DELETE
void __cdecl operator delete[](void *);
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#ifdef USE_ARRAY_NEW_DELETE
inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }
#endif
#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#ifndef __PCTYPE_FUNC
#ifdef _MT
#define __PCTYPE_FUNC   __pctype_func()
#else
#define __PCTYPE_FUNC  _pctype
#endif  /* _MT */
#endif  /* __PCTYPE_FUNC */
#endif  /* _CTYPE_DISABLE_MACROS */




/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#ifdef _MT
#define MB_CUR_MAX ___mb_cur_max_func()
#else
#define MB_CUR_MAX __mb_cur_max
#endif
_CRTIMP extern int __mb_cur_max;
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (__PCTYPE_FUNC[(a)] & (b))
#endif



#ifndef _MT
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */


#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( __PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (__PCTYPE_FUNC[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */



/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif  /* _WCONIO_DEFINED */

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41
#define EILSEQ          42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DOS
#define _INC_DOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifdef  _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

struct _EXCEPTION_RECORD;
struct _CONTEXT;
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _DISPATCHER_CONTEXT;

#ifdef  _M_IX86

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_IA64)

_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    unsigned __int64 MemoryStackFp,
    unsigned __int64 BackingStoreFp,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext,
    unsigned __int64 GlobalPointer
    );

#elif   defined(_M_AMD64)

_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1



#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if     !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* __STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EH
#define _INC_EH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif


/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP __declspec(noreturn) void __cdecl unexpected(void);
#else
_CRTIMP void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);
#endif

_CRTIMP terminate_function __cdecl set_terminate(terminate_function);
_CRTIMP unexpected_function __cdecl set_unexpected(unexpected_function);
_CRTIMP _se_translator_function __cdecl _set_se_translator(_se_translator_function);
_CRTIMP bool __uncaught_exception();

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_EH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#define _clear87        _clearfp
#define _status87       _statusfp

/*
 * Abstract User Control Word Mask and bit definitions
 */
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _SW_DENORMAL    0x00080000              /* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */


/* initial Control Word value */

#if     defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_IA64) || defined(_M_AMD64)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#endif

/* Global variable holding floating point error code */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())
#else   /* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif  /* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define clear87         _clear87
#define status87        _status87
#define control87       _control87

_CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)

/* Disable C4324: structure was padded due to __declspec(align()) */
#pragma warning(push)
#pragma warning(disable: 4324)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString,
#if defined(_M_IA64)
    _FpFormatFp82
#endif
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate, 
    _FpCodeFmin,         /* XMMI */
    _FpCodeFmax,         /* XMMI */
    _FpCodeConvertTrunc, /* XMMI */
    _XMMIAddps,          /* XMMI */
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMI2Addpd,         /* XMMI2 */
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   /* 66 2D    */
    _XMMI2Cvtsd2si,   /* F2       */
    _XMMI2Cvttpd2pi,  /* 66 2C    */
    _XMMI2Cvttsd2si,  /* F2       */
    _XMMI2Cvtps2pd,   /* 0F 5A    */
    _XMMI2Cvtss2sd,   /* F3       */
    _XMMI2Cvtpd2ps,   /* 66       */
    _XMMI2Cvtsd2ss,   /* F2       */
    _XMMI2Cvtdq2ps,   /* 0F 5B    */
    _XMMI2Cvttps2dq,  /* F3       */
    _XMMI2Cvtps2dq,   /* 66       */
    _XMMI2Cvttpd2dq,  /* 66 0F E6 */
    _XMMI2Cvtpd2dq,   /* F2       */
#if defined(_M_IA64)
    _FpCodeFma,
    _FpCodeFmaSingle,
    _FpCodeFmaDouble,
    _FpCodeFms,
    _FpCodeFmsSingle,
    _FpCodeFmsDouble,
    _FpCodeFnma,
    _FpCodeFnmaSingle,
    _FpCodeFnmaDouble,
    _FpCodeFamin,
    _FpCodeFamax
#endif
} _FP_OPERATION_CODE;

#endif  /* #ifndef __assembler */

/*
 * Define rounding modes.
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24,
#if defined(_M_IA64)
    _FpPrecision64,
    _FpPrecision113
#endif
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;


typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _FP80;

typedef struct __declspec(align(16))
{
    unsigned long W[4];
} _FP128;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _I64;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _U64;

typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _BCD80;

typedef struct __declspec(align(16))
{
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
#if defined(_M_IA64)
    _FPIEEE_VALUE Operand3;
#endif
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        unsigned long,
        struct _EXCEPTION_POINTERS *,
        int (__cdecl *)(_FPIEEE_RECORD *)
        );

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma warning(pop)
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* #ifndef __assembler */

#endif  /* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP unsigned long __cdecl _getdrives(void);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#define diskfree_t  _diskfree_t

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MATH
#define _INC_MATH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* Protect from assembler */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if     !__STDC__ && !defined (__cplusplus)
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifndef __assembler /* Protect from assembler */
_CRTIMP extern double _HUGE;
#endif  /* __assembler */

#define HUGE_VAL _HUGE

#ifdef  _USE_MATH_DEFINES

/* Define _USE_MATH_DEFINES before including math.h to expose these macro
 * definitions for common math constants.  These are placed under an #ifdef
 * since these commonly-defined names are not part of the C/C++ standards.
 */

/* Definitions of useful mathematical constants
 * M_E        - e
 * M_LOG2E    - log2(e)
 * M_LOG10E   - log10(e)
 * M_LN2      - ln(2)
 * M_LN10     - ln(10)
 * M_PI       - pi
 * M_PI_2     - pi/2
 * M_PI_4     - pi/4
 * M_1_PI     - 1/pi
 * M_2_PI     - 2/pi
 * M_2_SQRTPI - 2/sqrt(pi)
 * M_SQRT2    - sqrt(2)
 * M_SQRT1_2  - 1/sqrt(2)
 */

#define M_E        2.71828182845904523536
#define M_LOG2E    1.44269504088896340736
#define M_LOG10E   0.434294481903251827651
#define M_LN2      0.693147180559945309417
#define M_LN10     2.30258509299404568402
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401

#endif  /* _USE_MATH_DEFINES */

/* Function prototypes */

#if     !defined(__assembler)   /* Protect from assembler */
        int     __cdecl abs(int);
        double  __cdecl acos(double);
        double  __cdecl asin(double);
        double  __cdecl atan(double);
        double  __cdecl atan2(double, double);
        double  __cdecl cos(double);
        double  __cdecl cosh(double);
        double  __cdecl exp(double);
        double  __cdecl fabs(double);
        double  __cdecl fmod(double, double);
        long    __cdecl labs(long);
        double  __cdecl log(double);
        double  __cdecl log10(double);
        double  __cdecl pow(double, double);
        double  __cdecl sin(double);
        double  __cdecl sinh(double);
        double  __cdecl tan(double);
        double  __cdecl tanh(double);
        double  __cdecl sqrt(double);
_CRTIMP double  __cdecl atof(const char *);
_CRTIMP double  __cdecl _cabs(struct _complex);
_CRTIMP double  __cdecl ceil(double);
_CRTIMP double  __cdecl floor(double);
_CRTIMP double  __cdecl frexp(double, int *);
_CRTIMP double  __cdecl _hypot(double, double);
_CRTIMP double  __cdecl _j0(double);
_CRTIMP double  __cdecl _j1(double);
_CRTIMP double  __cdecl _jn(int, double);
_CRTIMP double  __cdecl ldexp(double, int);
        int     __cdecl _matherr(struct _exception *);
_CRTIMP double  __cdecl modf(double, double *);

_CRTIMP double  __cdecl _y0(double);
_CRTIMP double  __cdecl _y1(double);
_CRTIMP double  __cdecl _yn(int, double);


#if     defined(_M_IX86)

_CRTIMP int     __cdecl _set_SSE2_enable(int);

#endif

#if defined(_M_IA64)

/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
        float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

        float  __cdecl hypotf(float, float);

#endif /* _M_IA64 */

/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */

#ifndef __cplusplus
#define acosl(x)    ((long double)acos((double)(x)))
#define asinl(x)    ((long double)asin((double)(x)))
#define atanl(x)    ((long double)atan((double)(x)))
#define atan2l(x,y) ((long double)atan2((double)(x), (double)(y)))
#define _cabsl      _cabs
#define ceill(x)    ((long double)ceil((double)(x)))
#define cosl(x)     ((long double)cos((double)(x)))
#define coshl(x)    ((long double)cosh((double)(x)))
#define expl(x)     ((long double)exp((double)(x)))
#define fabsl(x)    ((long double)fabs((double)(x)))
#define floorl(x)   ((long double)floor((double)(x)))
#define fmodl(x,y)  ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y) ((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)    ((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y) ((long double)ldexp((double)(x), (y)))
#define logl(x)     ((long double)log((double)(x)))
#define log10l(x)   ((long double)log10((double)(x)))
#define _matherrl   _matherr
#define modfl(x,y)  ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)   ((long double)pow((double)(x), (double)(y)))
#define sinl(x)     ((long double)sin((double)(x)))
#define sinhl(x)    ((long double)sinh((double)(x)))
#define sqrtl(x)    ((long double)sqrt((double)(x)))
#define tanl(x)     ((long double)tan((double)(x)))
#define tanhl(x)    ((long double)tanh((double)(x)))
#else   /* __cplusplus */
inline long double acosl(long double _X)
        {return (acos((double)_X)); }
inline long double asinl(long double _X)
        {return (asin((double)_X)); }
inline long double atanl(long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(long double _X, long double _Y)
        {return (atan2((double)_X, (double)_Y)); }
inline long double ceill(long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(long double _X)
        {return (cos((double)_X)); }
inline long double coshl(long double _X)
        {return (cosh((double)_X)); }
inline long double expl(long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(long double _X, long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(long double _X, int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(long double _X, int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(long double _X)
        {return (log((double)_X)); }
inline long double log10l(long double _X)
        {return (log10((double)_X)); }
inline long double modfl(long double _X, long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(long double _X, long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(long double _X)
        {return (tan((double)_X)); }
inline long double tanhl(long double _X)
        {return (tanh((double)_X)); }

inline float frexpf(float _X, int *_Y)
        {return ((float)frexp((double)_X, _Y)); }
inline float ldexpf(float _X, int _Y)
        {return ((float)ldexp((double)_X, _Y)); }
#if     !defined(_M_IA64)
inline float acosf(float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(float _X, float _Y)
        {return ((float)atan2((double)_X, (double)_Y)); }
inline float ceilf(float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(float _X)
        {return ((float)exp((double)_X)); }
inline float fabsf(float _X)
        {return ((float)fabs((double)_X)); }
inline float floorf(float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(float _X, float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(float _X)
        {return ((float)log((double)_X)); }
inline float log10f(float _X)
        {return ((float)log10((double)_X)); }
inline float modff(float _X, float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(float _X, float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(float _X)
        {return ((float)tanh((double)_X)); }
#endif  /* !defined(_M_IA64) */
#endif  /* __cplusplus */
#endif  /* __assembler */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr     _matherr

#ifndef __assembler /* Protect from assembler */

_CRTIMP extern double HUGE;

_CRTIMP double  __cdecl cabs(struct _complex);
_CRTIMP double  __cdecl hypot(double, double);
_CRTIMP double  __cdecl j0(double);
_CRTIMP double  __cdecl j1(double);
_CRTIMP double  __cdecl jn(int, double);
        int     __cdecl matherr(struct _exception *);
_CRTIMP double  __cdecl y0(double);
_CRTIMP double  __cdecl y1(double);
_CRTIMP double  __cdecl yn(int, double);

#endif  /* __assembler */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = _Y;
        else
                _N = -_Y;
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

#ifndef _MSC_EXTENSIONS

inline long __cdecl abs(long _X)
        {return (labs(_X)); }
inline double __cdecl abs(double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline double __cdecl pow(int _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(float _Y, float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(float _X, float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(float _X, int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(float _X, int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(float _X)
        {return (logf(_X)); }
inline float __cdecl log10(float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(float _X, float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(float _X, float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(float _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(long double _Y, long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(long double _X, long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(long double _X, int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(long double _X, int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(long double _X, long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(long double _X, long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(long double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(long double _X)
        {return (tanhl(_X)); }

#endif  /* _MSC_EXTENSIONS */ 

}
#endif  /* __cplusplus */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

#if     _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if     _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef  _POSIX_

#define _POSIX_ARG_MAX      4096
#define _POSIX_CHILD_MAX    6
#define _POSIX_LINK_MAX     8
#define _POSIX_MAX_CANON    255
#define _POSIX_MAX_INPUT    255
#define _POSIX_NAME_MAX     14
#define _POSIX_NGROUPS_MAX  0
#define _POSIX_OPEN_MAX     16
#define _POSIX_PATH_MAX     255
#define _POSIX_PIPE_BUF     512
#define _POSIX_SSIZE_MAX    32767
#define _POSIX_STREAM_MAX   8
#define _POSIX_TZNAME_MAX   3

#define ARG_MAX             14500       /* 16k heap, minus overhead */
#define LINK_MAX            1024
#define MAX_CANON           _POSIX_MAX_CANON
#define MAX_INPUT           _POSIX_MAX_INPUT
#define NAME_MAX            255
#define NGROUPS_MAX         16
#define OPEN_MAX            32
#define PATH_MAX            512
#define PIPE_BUF            _POSIX_PIPE_BUF
#define SSIZE_MAX           _POSIX_SSIZE_MAX
#define STREAM_MAX          20
#define TZNAME_MAX          10

#endif  /* POSIX */

#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\mbctype.h ===
/***
*mbctype.h - MBCS character conversion macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines macros for MBCS character classification/conversion.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBCTYPE
#define _INC_MBCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* include the standard ctype.h header file */

#include <ctype.h>

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     (!defined(_MSC_VER) && !defined(__cdecl))
#define __cdecl
#endif


/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * This declaration allows the user access the _mbctype[] look-up array.
 */
_CRTIMP extern unsigned char _mbctype[];
_CRTIMP extern unsigned char _mbcasemap[];


/* bit masks for MBCS character types */

#define _MS     0x01    /* MBCS single-byte symbol */
#define _MP     0x02    /* MBCS punct */
#define _M1     0x04    /* MBCS 1st (lead) byte */
#define _M2     0x08    /* MBCS 2nd byte*/

#define _SBUP   0x10    /* SBCS upper char */
#define _SBLOW  0x20    /* SBCS lower char */

/* byte types  */

#define _MBC_SINGLE     0       /* valid single byte char */
#define _MBC_LEAD       1       /* lead byte */
#define _MBC_TRAIL      2       /* trailing byte */
#define _MBC_ILLEGAL    (-1)    /* illegal byte */

#define _KANJI_CP   932

/* _setmbcp parameter defines */
#define _MB_CP_SBCS     0
#define _MB_CP_OEM      -2
#define _MB_CP_ANSI     -3
#define _MB_CP_LOCALE   -4


#ifndef _MBCTYPE_DEFINED

/* MB control routines */

_CRTIMP int __cdecl _setmbcp(int);
_CRTIMP int __cdecl _getmbcp(void);


/* MBCS character classification function prototypes */


/* byte routines */
_CRTIMP int __cdecl _ismbbkalnum( unsigned int );
_CRTIMP int __cdecl _ismbbkana( unsigned int );
_CRTIMP int __cdecl _ismbbkpunct( unsigned int );
_CRTIMP int __cdecl _ismbbkprint( unsigned int );
_CRTIMP int __cdecl _ismbbalpha( unsigned int );
_CRTIMP int __cdecl _ismbbpunct( unsigned int );
_CRTIMP int __cdecl _ismbbalnum( unsigned int );
_CRTIMP int __cdecl _ismbbprint( unsigned int );
_CRTIMP int __cdecl _ismbbgraph( unsigned int );

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

#define _MBCTYPE_DEFINED
#endif

/*
 * char byte classification macros
 */

#define _ismbbkalnum(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MS)
#define _ismbbkprint(_c)    ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#define _ismbbkpunct(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MP)

#define _ismbbalnum(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA|_DIGIT))||_ismbbkalnum(_c))
#define _ismbbalpha(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA))||_ismbbkalnum(_c))
#define _ismbbgraph(_c) (((_ctype+1)[(unsigned char)(_c)] & (_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbprint(_c) (((_ctype+1)[(unsigned char)(_c)] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbpunct(_c) (((_ctype+1)[(unsigned char)(_c)] & _PUNCT)||_ismbbkpunct(_c))

#define _ismbblead(_c)  ((_mbctype+1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail(_c) ((_mbctype+1)[(unsigned char)(_c)] & _M2)

#define _ismbbkana(_c)  ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MBCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCALE
#define _INC_LOCALE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef  _CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

#ifndef _CONFIG_LOCALE_SWT
#define _ENABLE_PER_THREAD_LOCALE           0x1
#define _DISABLE_PER_THREAD_LOCALE          0x2
#define _ENABLE_PER_THREAD_LOCALE_GLOBAL    0x10
#define _DISABLE_PER_THREAD_LOCALE_GLOBAL   0x20
#define _ENABLE_PER_THREAD_LOCALE_NEW       0x100
#define _DISABLE_PER_THREAD_LOCALE_NEW      0x200
#define _CONFIG_LOCALE_SWT
#endif

_CRTIMP int __cdecl _configthreadlocale(int i);
_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MALLOC
#define _INC_MALLOC

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTNOALIAS, _CRTRESTRICT */

#if     _MSC_FULL_VER >= 14002050

#ifndef _CRTNOALIAS
#define _CRTNOALIAS __declspec(noalias)
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT __declspec(restrict)
#endif  /* _CRTRESTRICT */

#else

#ifndef _CRTNOALIAS
#define _CRTNOALIAS
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT
#endif  /* _CRTRESTRICT */

#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif


/* Maximum heap request the heap manager will attempt */

#ifdef  _WIN64
#define _HEAP_MAXREQ    0xFFFFFFFFFFFFFFE0
#else
#define _HEAP_MAXREQ    0xFFFFFFE0
#endif

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

/* External variable declarations */

extern unsigned int _amblksiz;

#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b)    _aligned_malloc(a, b)

/* Function prototypes */

_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl calloc(size_t, size_t);
_CRTIMP _CRTNOALIAS              void    __cdecl free(void *);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl malloc(size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl realloc(void *, size_t);
_CRTIMP _CRTNOALIAS              void    __cdecl _aligned_free(void *);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_malloc(size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_offset_malloc(size_t, size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_realloc(void *, size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t);

#ifndef _POSIX_

void *          __cdecl _alloca(size_t);
_CRTIMP void *  __cdecl _expand(void *, size_t);
_CRTIMP size_t  __cdecl _get_sbh_threshold(void);
_CRTIMP int     __cdecl _set_sbh_threshold(size_t);
_CRTIMP int     __cdecl _heapadd(void *, size_t);
_CRTIMP int     __cdecl _heapchk(void);
_CRTIMP int     __cdecl _heapmin(void);
_CRTIMP int     __cdecl _heapset(unsigned int);
_CRTIMP int     __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t  __cdecl _heapused(size_t *, size_t *);
_CRTIMP size_t  __cdecl _msize(void *);
_CRTIMP int     __cdecl _resetstkoflw (void);
int __cdecl _resetstkoflw_downlevel(void);

_CRTIMP intptr_t __cdecl _get_heap_handle(void);

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/

#endif  /* _POSIX_ */

#ifdef  HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void **);
#define _HEAPHOOK_DEFINED
#endif  /* _HEAPHOOK_DEFINED */

/* set hook function */
_CRTIMP _HEAPHOOK __cdecl _setheaphook(_HEAPHOOK);

/* hook function must handle these types */
#define _HEAP_MALLOC    1
#define _HEAP_CALLOC    2
#define _HEAP_FREE      3
#define _HEAP_REALLOC   4
#define _HEAP_MSIZE     5
#define _HEAP_EXPAND    6
#endif  /* HEAPHOOK */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the
*       buffer (memory) manipulation routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MEMORY
#define _INC_MEMORY

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Function prototypes */

_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memcpy(void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\mbstring.h ===
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file contains macros and function declarations for the MBCS
*       string manipulation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647      /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbscat(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbscpy(unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsnbcat(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbcpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
_CRTIMP void __cdecl _mbccpy(unsigned char *, const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);


#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead(unsigned int);
_CRTIMP int __cdecl _ismbbtrail(unsigned int);
_CRTIMP int __cdecl _ismbslead(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail(const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.  */

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MBSTRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_IO
#define _INC_IO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _POSIX_

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        char        name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _finddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        wchar_t     name[260];
};

struct __wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP intptr_t __cdecl _findfirst(const char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(intptr_t, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(intptr_t);
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP intptr_t __cdecl _findfirsti64(const char *, struct _finddatai64_t *);
_CRTIMP intptr_t __cdecl _findfirst64(const char *, struct __finddata64_t *);
_CRTIMP int __cdecl _findnexti64(intptr_t, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnext64(intptr_t, struct __finddata64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(const wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(const wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(const wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif


_CRTIMP intptr_t __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(intptr_t, int);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\rtcapi.h ===
/***
*rtcapi.h - declarations and definitions for RTC use
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations and definitions for all RunTime Check
*       support.
*
****/

#ifndef _INC_RTCAPI
#define _INC_RTCAPI


#ifdef  __cplusplus

extern "C" {

#endif

    /* General User API */

typedef enum _RTC_ErrorNumber {
    _RTC_CHKSTK = 0,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_ILLEGAL 
} _RTC_ErrorNumber;
 
#   define _RTC_ERRTYPE_IGNORE -1
#   define _RTC_ERRTYPE_ASK    -2

    typedef int (__cdecl *_RTC_error_fn)(int, const char *, int, const char *, const char *, ...);

    /* User API */
    int           __cdecl _RTC_NumErrors(void);
    const char *  __cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum);
    int           __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int ErrType);
    _RTC_error_fn __cdecl _RTC_SetErrorFunc(_RTC_error_fn);

    /* Power User/library API */


    /* Init functions */

    /* These functions all call _CRT_RTC_INIT */
    void __cdecl _RTC_Initialize(void);
    void __cdecl _RTC_Terminate(void);

    /*
     * If you're not using the CRT, you have to implement _CRT_RTC_INIT
     * Just return either null, or your error reporting function
     * *** Don't mess with res0/res1/res2/res3/res4 - YOU'VE BEEN WARNED! ***
     */
    _RTC_error_fn _CRT_RTC_INIT(void *res0, void **res1, int res2, int res3, int res4);
    
    /* Compiler generated calls (unlikely to be used, even by power users) */
    /* Types */
    typedef struct _RTC_vardesc {
        int addr;
        int size;
        char *name;
    } _RTC_vardesc;

    typedef struct _RTC_framedesc {
        int varCount;
        _RTC_vardesc *variables;
    } _RTC_framedesc;

    /* Shortening convert checks - name indicates src bytes to target bytes */
    /* Signedness is NOT checked */
    char   __fastcall _RTC_Check_2_to_1(short src);
    char   __fastcall _RTC_Check_4_to_1(int src);
    char   __fastcall _RTC_Check_8_to_1(__int64 src);
    short  __fastcall _RTC_Check_4_to_2(int src);
    short  __fastcall _RTC_Check_8_to_2(__int64 src);
    int    __fastcall _RTC_Check_8_to_4(__int64 src);
 
    
    /* Stack Checking Calls */
    void   __cdecl     _RTC_CheckEsp();
    void   __fastcall  _RTC_CheckStackVars(void *esp, _RTC_framedesc *fd);

    /* Unintialized Local call */
    void   __cdecl     _RTC_UninitUse(const char *varname);


    /* Subsystem initialization stuff */
    void    __cdecl    _RTC_Shutdown(void);
    void    __cdecl    _RTC_InitBase(void);
    

#ifdef  __cplusplus

    void* _ReturnAddress();
}

#endif


#endif /* _INC_RTCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Protect against #define of new */
#pragma push_macro("new")
#undef  new


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
typedef void (__cdecl * new_handler) ();
_CRTIMP new_handler __cdecl set_new_handler(new_handler);
#endif

#ifndef __NOTHROW_T_DEFINED
#define __NOTHROW_T_DEFINED
namespace std {
        /* placement new tag type to suppress exceptions */
        struct nothrow_t {};

        /* constant for placement new tag */
        extern const nothrow_t nothrow;
};

void *__cdecl operator new(size_t, const std::nothrow_t&) throw();
void __cdecl operator delete(void *, const std::nothrow_t&) throw();
#if _MSC_FULL_VER >= 13009179
void *__cdecl operator new[](size_t, const std::nothrow_t&) throw();
void __cdecl operator delete[](void *, const std::nothrow_t&) throw();
#endif
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
        {return; }
#endif
#endif

/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

/*
 * Microsoft extension: 
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#pragma pop_macro("new")

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\minmax.h ===
/***
*minmax.h - familiar min & max macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines min and max macros.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MINMAX
#define _INC_MINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\setjmpex.h ===
/***
*setjmpex.h - definitions/declarations for extended setjmp/longjmp routines
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file causes _setjmpex to be called which will enable safe
*       setjmp/longjmp that work correctly with try/except/finally.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMPEX
#define _INC_SETJMPEX

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#define setjmp  _setjmp
#define longjmp _longjmpex

#else

#ifdef setjmp
#undef setjmp
#endif
#define setjmp _setjmpex

#endif

#include <setjmp.h>

#endif  /* _INC_SETJMPEX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* modeflag values for _spawnxx routines */

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#ifdef  _MT
#define _P_OVERLAY      2
#else
extern int _p_overlay;
#define _P_OVERLAY      _p_overlay
#endif  /* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef  _MT
_CRTIMP uintptr_t __cdecl _beginthread (void (__cdecl *) (void *),
        unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP uintptr_t __cdecl _beginthreadex(void *, unsigned,
        unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl abort(void);
_CRTIMP __declspec(noreturn) void __cdecl exit(int);
_CRTIMP __declspec(noreturn) void __cdecl _exit(int);
#else
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
#endif
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

_CRTIMP intptr_t __cdecl _cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl _execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnvpe(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl system(const char *);

#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
intptr_t __cdecl _loaddll(char *);
int __cdecl _unloaddll(intptr_t);
int (__cdecl * __cdecl _getdllprocaddr(intptr_t, char *, intptr_t))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef  _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef  _WINDOWS_       /* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

/* current declarations */
_CRTIMP intptr_t __cdecl cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnvpe(int, const char *, const char * const *,
        const char * const *);

_CRTIMP int __cdecl getpid(void);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SHARE
#define _INC_SHARE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _SH_DENYRW      0x10    /* deny read/write mode */
#define _SH_DENYWR      0x20    /* deny write mode */
#define _SH_DENYRD      0x30    /* deny read mode */
#define _SH_DENYNO      0x40    /* deny none mode */

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif  /* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMP
#define _INC_SETJMP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;

#elif defined(_M_AMD64)

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

/*
 * AMD64 setjmp definitions.
 */

typedef struct __declspec(align(16)) _SETJMP_FLOAT128 {
    unsigned __int64 Part[2];
} SETJMP_FLOAT128;

#define _JBLEN  16
typedef SETJMP_FLOAT128 _JBTYPE;

typedef struct _JUMP_BUFFER {
    unsigned __int64 Frame;
    unsigned __int64 Rbx;
    unsigned __int64 Rsp;
    unsigned __int64 Rbp;
    unsigned __int64 Rsi;
    unsigned __int64 Rdi;
    unsigned __int64 R12;
    unsigned __int64 R13;
    unsigned __int64 R14;
    unsigned __int64 R15;
    unsigned __int64 Rip;
    unsigned __int64 Spare;

    SETJMP_FLOAT128 Xmm6;
    SETJMP_FLOAT128 Xmm7;
    SETJMP_FLOAT128 Xmm8;
    SETJMP_FLOAT128 Xmm9;
    SETJMP_FLOAT128 Xmm10;
    SETJMP_FLOAT128 Xmm11;
    SETJMP_FLOAT128 Xmm12;
    SETJMP_FLOAT128 Xmm13;
    SETJMP_FLOAT128 Xmm14;
    SETJMP_FLOAT128 Xmm15;
} _JUMP_BUFFER;

#elif defined(_M_IA64)

/*
 * Minimum length is 528 bytes
 * Since this is allocated as an array of "SETJMP_FLOAT128", the
 * number of entries required is 33 (16-byte aligned).
 */

/* Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name. */
typedef __declspec(align(16)) struct _SETJMP_FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} SETJMP_FLOAT128;
                                  
#define _JBLEN  33
typedef SETJMP_FLOAT128 _JBTYPE;
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif
/*
 * Define jump buffer layout for IA64 setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {

    /*
     * x86 reserved.
     */

    unsigned long iAReserved[6];

    /*
     * x86 C9.0 compatibility
     */

    unsigned long Registration;  /* point to the UnwindData field. */
    unsigned long TryLevel;      /* ignored by setjmp */
    unsigned long Cookie;        /* set to "VC20" by setjmp */
    unsigned long UnwindFunc;    /* set to EM longjmp() by setjmp */

    /*
     * First dword is zero to indicate it's an exception registration
     * record prepared by EM setjmp function.
     * Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
     * EM setjmp.
     * Third dword is set to the setjmp site memory stack frame pointer.
     * Fourth dword is set to the setjmp site backing store frame pointer.
     */

    unsigned long UnwindData[6];

    /*
     * floating point status register,
     * and preserved floating point registers fs0 - fs19
     */

    SETJMP_FLOAT128 FltS0;
    SETJMP_FLOAT128 FltS1;
    SETJMP_FLOAT128 FltS2;
    SETJMP_FLOAT128 FltS3;
    SETJMP_FLOAT128 FltS4;
    SETJMP_FLOAT128 FltS5;
    SETJMP_FLOAT128 FltS6;
    SETJMP_FLOAT128 FltS7;
    SETJMP_FLOAT128 FltS8;
    SETJMP_FLOAT128 FltS9;
    SETJMP_FLOAT128 FltS10;
    SETJMP_FLOAT128 FltS11;
    SETJMP_FLOAT128 FltS12;
    SETJMP_FLOAT128 FltS13;
    SETJMP_FLOAT128 FltS14;
    SETJMP_FLOAT128 FltS15;
    SETJMP_FLOAT128 FltS16;
    SETJMP_FLOAT128 FltS17;
    SETJMP_FLOAT128 FltS18;
    SETJMP_FLOAT128 FltS19;

    __int64 FPSR;

    /*
     * return link and preserved branch registers bs0 - bs4
     */

    __int64 StIIP;     /* continuation address */
    __int64 BrS0;
    __int64 BrS1;
    __int64 BrS2;
    __int64 BrS3;
    __int64 BrS4;

    /*
     * preserved general registers s0 - s3, sp, nats
     */

    __int64 IntS0;
    __int64 IntS1;
    __int64 IntS2;
    __int64 IntS3;

    /*
     * bsp, pfs, unat, lc
     */

    __int64 RsBSP;
    __int64 RsPFS;     /* previous frame marker (cfm of setjmp's caller) */
    __int64 ApUNAT;    /* User Nat collection register (preserved) */
    __int64 ApLC;      /* loop counter */

    __int64 IntSp;     /* memory stack pointer */
    __int64 IntNats;   /* Nat bits of preserved integer regs s0 - s3 */
    __int64 Preds;     /* predicates */

} _JUMP_BUFFER;
#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl longjmp(jmp_buf, int);
#else
_CRTIMP void __cdecl longjmp(jmp_buf, int);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\stdexcpt.h ===
/***
*stdexcpt.h - User include file for standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file is the previous location of the standard exception class
*       definitions, now found in the standard header <exception>.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus

#include <exception>

#endif  /* __cplusplus */
#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */


/* Define the implementation dependent size types */

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#ifdef  _WIN64
typedef __int64             ptrdiff_t;
#else
typedef _W64 int            ptrdiff_t;
#endif
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define offsetof macro */

#ifdef  _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif


#ifdef  _MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern uintptr_t __cdecl __threadhandle(void);
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\signal.h ===
/***
*signal.h - defines signal values and routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the signal values and declares the signal functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif

#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT          2       /* interrupt */
#define SIGILL          4       /* illegal instruction - invalid function image */
#define SIGFPE          8       /* floating point exception */
#define SIGSEGV         11      /* segment violation */
#define SIGTERM         15      /* Software termination signal from kill */
#define SIGBREAK        21      /* Ctrl-Break sequence */
#define SIGABRT         22      /* abnormal termination triggered by abort call */


/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0           /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1           /* ignore signal */
#define SIG_SGE (void (__cdecl *)(int))3           /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4           /* acknowledge */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1          /* signal error value */


/* pointer to exception information pointers structure */

#if     defined(_MT) || defined(_DLL)
extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs  (*__pxcptinfoptrs())
#else   /* ndef _MT && ndef _DLL */
extern void * _pxcptinfoptrs;
#endif  /* _MT || _DLL */


/* Function prototypes */

_CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int);
_CRTIMP int __cdecl raise(int);


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines ANSI-style macros for accessing arguments
*       of functions which take a variable number of arguments.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDARG
#define _INC_STDARG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifdef  __cplusplus
#define _ADDRESSOF(v)   ( &reinterpret_cast<const char &>(v) )
#else
#define _ADDRESSOF(v)   ( &(v) )
#endif

#if     defined(_M_CEE)

extern void __cdecl __va_start(va_list*, ...);
extern void * __cdecl __va_arg(va_list*, ...);
extern void __cdecl __va_end(va_list*);

#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), sizeof(v), \
                                __builtin_alignof(v), _ADDRESSOF(v)) )
#define va_arg(ap,t)    ( *(t *)__va_arg(&ap, sizeof(t), \
                                __builtin_alignof(t), (t *)0) )
#define va_end(ap)      ( __va_end(&ap) )

#elif   defined(_M_IX86)

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_IA64)

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#ifdef  __cplusplus
extern void __cdecl __va_start(va_list*, ...);
#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), \
                          _ADDRESSOF(v)) )
#else
#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v) )
#endif

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)


extern void __cdecl __va_start(va_list *, ...);

#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDIO
#define _INC_STDIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif


/* Buffered I/O macros */

#define BUFSIZ  512


/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 20

#define EOF     (-1)


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* Directory where temporary files may be created. */

#ifdef  _POSIX_
#define _P_tmpdir   "/"
#define _wP_tmpdir  L"/"
#else
#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"
#endif

/* L_tmpnam = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 */
#define L_tmpnam sizeof(_P_tmpdir)+12


#ifdef  _POSIX_
#define L_ctermid   9
#define L_cuserid   32
#endif


/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         32767


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED
#undef _FPOSOFF

#if     defined (_POSIX_)
typedef long fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else   /* _POSIX_ */

#if     !__STDC__ && _INTEGRAL_MAX_BITS >= 64
typedef __int64 fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else
typedef struct fpos_t {
        unsigned int lopart;
        int          hipart;
        } fpos_t;
#define _FPOSOFF(fp) ((long)(fp).lopart)
#endif
#endif  /* _POSIX_ */

#define _FPOS_T_DEFINED
#endif


#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])


#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOFBF          0x0000
#define _IOLBF          0x0040
#define _IONBF          0x0004

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080
#ifdef  _POSIX_
#define _IOAPPEND       0x0200
#endif


/* Function prototypes */

#ifndef _STDIO_DEFINED

_CRTIMP int __cdecl _filbuf(FILE *);
_CRTIMP int __cdecl _flsbuf(int, FILE *);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *);
#else
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *, int);
#endif

_CRTIMP void __cdecl clearerr(FILE *);
_CRTIMP int __cdecl fclose(FILE *);
_CRTIMP int __cdecl _fcloseall(void);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl fdopen(int, const char *);
#else
_CRTIMP FILE * __cdecl _fdopen(int, const char *);
#endif

_CRTIMP int __cdecl feof(FILE *);
_CRTIMP int __cdecl ferror(FILE *);
_CRTIMP int __cdecl fflush(FILE *);
_CRTIMP int __cdecl fgetc(FILE *);
_CRTIMP int __cdecl _fgetchar(void);
_CRTIMP int __cdecl fgetpos(FILE *, fpos_t *);
_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef  _POSIX_
_CRTIMP int __cdecl fileno(FILE *);
#else
_CRTIMP int __cdecl _fileno(FILE *);
#endif

_CRTIMP int __cdecl _flushall(void);
_CRTIMP FILE * __cdecl fopen(const char *, const char *);
_CRTIMP int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP int __cdecl fputc(int, FILE *);
_CRTIMP int __cdecl _fputchar(int);
_CRTIMP int __cdecl fputs(const char *, FILE *);
_CRTIMP size_t __cdecl fread(void *, size_t, size_t, FILE *);
_CRTIMP FILE * __cdecl freopen(const char *, const char *, FILE *);
_CRTIMP int __cdecl fscanf(FILE *, const char *, ...);
_CRTIMP int __cdecl fsetpos(FILE *, const fpos_t *);
_CRTIMP int __cdecl fseek(FILE *, long, int);
_CRTIMP long __cdecl ftell(FILE *);
_CRTIMP size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP int __cdecl getc(FILE *);
_CRTIMP int __cdecl getchar(void);
_CRTIMP int __cdecl _getmaxstdio(void);
_CRTIMP char * __cdecl gets(char *);
_CRTIMP int __cdecl _getw(FILE *);
_CRTIMP void __cdecl perror(const char *);
_CRTIMP int __cdecl _pclose(FILE *);
_CRTIMP FILE * __cdecl _popen(const char *, const char *);
_CRTIMP int __cdecl printf(const char *, ...);
_CRTIMP int __cdecl putc(int, FILE *);
_CRTIMP int __cdecl putchar(int);
_CRTIMP int __cdecl puts(const char *);
_CRTIMP int __cdecl _putw(int, FILE *);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP void __cdecl rewind(FILE *);
_CRTIMP int __cdecl _rmtmp(void);
_CRTIMP int __cdecl scanf(const char *, ...);
_CRTIMP void __cdecl setbuf(FILE *, char *);
_CRTIMP int __cdecl _setmaxstdio(int);
_CRTIMP int __cdecl setvbuf(FILE *, char *, int, size_t);
_CRTIMP int __cdecl _snprintf(char *, size_t, const char *, ...);
_CRTIMP int __cdecl sprintf(char *, const char *, ...);
_CRTIMP int __cdecl _scprintf(const char *, ...);
_CRTIMP int __cdecl sscanf(const char *, const char *, ...);
_CRTIMP int __cdecl _snscanf(const char *, size_t, const char *, ...);
_CRTIMP char * __cdecl _tempnam(const char *, const char *);
_CRTIMP FILE * __cdecl tmpfile(void);
_CRTIMP char * __cdecl tmpnam(char *);
_CRTIMP int __cdecl ungetc(int, FILE *);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl vfprintf(FILE *, const char *, va_list);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
_CRTIMP int __cdecl vsprintf(char *, const char *, va_list);
_CRTIMP int __cdecl _vscprintf(const char *, va_list);

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()              fgetwc(stdin)
#define putwchar(_c)            fputwc((_c),stdout)
#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */

#define _STDIO_DEFINED
#endif  /* _STDIO_DEFINED */


/* Macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 \
                ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
                ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()         getc(stdin)
#define putchar(_c)       putc((_c),stdout)



#ifdef  _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif



#if     !__STDC__ && !defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

_CRTIMP int __cdecl fcloseall(void);
_CRTIMP FILE * __cdecl fdopen(int, const char *);
_CRTIMP int __cdecl fgetchar(void);
_CRTIMP int __cdecl fileno(FILE *);
_CRTIMP int __cdecl flushall(void);
_CRTIMP int __cdecl fputchar(int);
_CRTIMP int __cdecl getw(FILE *);
_CRTIMP int __cdecl putw(int, FILE *);
_CRTIMP int __cdecl rmtmp(void);
_CRTIMP char * __cdecl tempnam(const char *, const char *);
_CRTIMP int __cdecl unlink(const char *);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for commonly
*       used library functions which either don't fit somewhere else, or,
*       cannot be declared in the normal place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDLIB
#define _INC_STDLIB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTNOALIAS, _CRTRESTRICT */

#if     _MSC_FULL_VER >= 14002050

#ifndef _CRTNOALIAS
#define _CRTNOALIAS __declspec(noalias)
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT __declspec(restrict)
#endif  /* _CRTRESTRICT */

#else

#ifndef _CRTNOALIAS
#define _CRTNOALIAS
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT
#endif  /* _CRTRESTRICT */

#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if     !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif


/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX
#ifdef _MT
#define MB_CUR_MAX ___mb_cur_max_func()
#else
#define MB_CUR_MAX __mb_cur_max
#endif
_CRTIMP extern int __mb_cur_max;
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Minimum and maximum macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/*
 * Argument values for _set_error_mode().
 */
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

#if     defined(_M_IX86)
/*
 * Typedefs and argument values for _set_security_error_handler()
 */
#define _SECERR_BUFFER_OVERRUN 1        /* void* arg ignored */
typedef void (__cdecl * _secerr_handler_func)(int, void *);
#endif

/* External variable declarations */

#if     defined(_MT) || defined(_DLL)
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;               /* XENIX style error number */
_CRTIMP extern unsigned long _doserrno; /* OS system error value */
#endif  /* _MT || _DLL */


_CRTIMP extern char * _sys_errlist[];   /* perror error message table */
_CRTIMP extern int _sys_nerr;           /* # of entries in sys_errlist table */


_CRTIMP extern int __argc;          /* count of cmd line args */
_CRTIMP extern char ** __argv;      /* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */

#ifdef  _POSIX_
extern char ** environ;             /* pointer to environment table */
#else
_CRTIMP extern char ** _environ;    /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif  /* _POSIX_ */

_CRTIMP extern char * _pgmptr;      /* points to the module (EXE) name */
_CRTIMP extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */

_CRTIMP extern int _fmode;          /* default file translation mode */
_CRTIMP extern int _fileinfo;       /* open file info mode (for spawn) */


/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osplatform;
_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;


/* function prototypes */

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl abort(void);
_CRTIMP __declspec(noreturn) void   __cdecl exit(int);
#else
_CRTIMP void   __cdecl abort(void);
_CRTIMP void   __cdecl exit(int);
#endif

        int    __cdecl abs(int);
        __int64    __cdecl _abs64(__int64);
        int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
        unsigned short __cdecl _byteswap_ushort(unsigned short);
        unsigned long  __cdecl _byteswap_ulong (unsigned long);
        unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP _CRTNOALIAS void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _i64toa(__int64, char *, int);
_CRTIMP char * __cdecl _ui64toa(unsigned __int64, char *, int);
_CRTIMP __int64 __cdecl _atoi64(const char *);
_CRTIMP __int64 __cdecl _strtoi64(const char *, char **, int);
_CRTIMP unsigned __int64 __cdecl _strtoui64(const char *, char **, int);
#endif
        long __cdecl labs(long);
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl realloc(void *, size_t);
_CRTIMP int    __cdecl _set_error_mode(int);
#if     defined(_M_IX86)
_CRTIMP _secerr_handler_func
               __cdecl _set_security_error_handler(_secerr_handler_func);
#endif
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
_CRTIMP int    __cdecl system(const char *);
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);


#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif


#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl _exit(int);
#else
_CRTIMP void   __cdecl _exit(int);
#endif
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
        _onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned __int64 __cdecl _rotl64(unsigned __int64, int);
        unsigned int __cdecl _rotr(unsigned int, int);
        unsigned __int64 __cdecl _rotr64(unsigned __int64, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRTIMP void __cdecl _seterrormode(int);
_CRTIMP void __cdecl _beep(unsigned, unsigned);
_CRTIMP void __cdecl _sleep(unsigned long);
/* --------- The preceding functions are OBSOLETE --------- */

#endif  /* _POSIX_ */


#if     !__STDC__
/* --------- The declarations below should not be in stdlib.h --------- */
/* --------- and will be removed in a future release. Include --------- */
/* --------- ctype.h to obtain these declarations.            --------- */
#ifndef tolower     /* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif  /* tolower */
#ifndef toupper     /* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif  /* toupper */
/* --------- The declarations above will be removed.          --------- */
#endif


#if     !__STDC__

#ifndef _POSIX_

/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
        onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif  /* _POSIX_ */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Definitions for generic international functions, mostly defines
*       which map string/formatted-io/ctype functions to char, wchar_t, or
*       MBCS versions.  To be used for compatibility between single-byte,
*       multi-byte and Unicode text models.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_TCHAR
#define _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


#define _ftcscat    _tcscat
#define _ftcschr    _tcschr
#define _ftcscpy    _tcscpy
#define _ftcscspn   _tcscspn
#define _ftcslen    _tcslen
#define _ftcsncat   _tcsncat
#define _ftcsncpy   _tcsncpy
#define _ftcspbrk   _tcspbrk
#define _ftcsrchr   _tcsrchr
#define _ftcsspn    _tcsspn
#define _ftcsstr    _tcsstr
#define _ftcstok    _tcstok

#define _ftcsdup    _tcsdup
#define _ftcsnset   _tcsnset
#define _ftcsrev    _tcsrev
#define _ftcsset    _tcsset

#define _ftcscmp      _tcscmp
#define _ftcsicmp     _tcsicmp
#define _ftcsnccmp    _tcsnccmp
#define _ftcsncmp     _tcsncmp
#define _ftcsncicmp   _tcsncicmp
#define _ftcsnicmp    _tcsnicmp

#define _ftcscoll     _tcscoll
#define _ftcsicoll    _tcsicoll
#define _ftcsnccoll   _tcsnccoll
#define _ftcsncoll    _tcsncoll
#define _ftcsncicoll  _tcsncicoll
#define _ftcsnicoll   _tcsnicoll

/* Redundant "logical-character" mappings */

#define _ftcsclen   _tcsclen
#define _ftcsnccat  _tcsnccat
#define _ftcsnccpy  _tcsnccpy
#define _ftcsncset  _tcsncset

#define _ftcsdec    _tcsdec
#define _ftcsinc    _tcsinc
#define _ftcsnbcnt  _tcsnbcnt
#define _ftcsnccnt  _tcsnccnt
#define _ftcsnextc  _tcsnextc
#define _ftcsninc   _tcsninc
#define _ftcsspnp   _tcsspnp

#define _ftcslwr    _tcslwr
#define _ftcsupr    _tcsupr

#define _ftclen     _tclen
#define _ftccpy     _tccpy
#define _ftccmp     _tccmp


#ifdef  _UNICODE

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include <wchar.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF       WEOF

#define __T(x)      L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron
#define __targv     __wargv

/* Formatted i/o */

#define _tprintf    wprintf
#define _tcprintf   _cwprintf
#define _ftprintf   fwprintf
#define _stprintf   swprintf
#define _sctprintf  _scwprintf
#define _sntprintf  _snwprintf
#define _vtprintf   vwprintf
#define _vftprintf  vfwprintf
#define _vstprintf  vswprintf
#define _vsctprintf _vscwprintf
#define _vsntprintf _vsnwprintf
#define _tscanf     wscanf
#define _tcscanf    _cwscanf
#define _ftscanf    fwscanf
#define _stscanf    swscanf
#define _sntscanf   _snwscanf


/* Unformatted i/o */

#define _fgettc     fgetwc
#define _fgettchar  _fgetwchar
#define _fgetts     fgetws
#define _fputtc     fputwc
#define _fputtchar  _fputwchar
#define _fputts     fputws
#define _cputts     _cputws
#define _cgetts     _cgetws
#define _gettc      getwc
#define _gettch     _getwch
#define _gettche    _getwche
#define _gettchar   getwchar
#define _getts      _getws
#define _puttc      putwc
#define _puttchar   putwchar
#define _puttch     _putwch
#define _putts      _putws
#define _ungettc    ungetwc
#define _ungettch   _ungetwch


/* String conversion functions */

#define _tcstod     wcstod
#define _tcstol     wcstol
#define _tcstoul    wcstoul
#define _tcstoi64   _wcstoi64
#define _tcstoui64  _wcstoui64
#define _tstof      _wtof
#define _tstol      _wtol
#define _tstoi      _wtoi
#define _tstoi64    _wtoi64

#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol

#define _ttoi64     _wtoi64
#define _i64tot     _i64tow
#define _ui64tot    _ui64tow

/* String functions */

#define _tcscat     wcscat
#define _tcschr     wcschr
#define _tcscpy     wcscpy
#define _tcscspn    wcscspn
#define _tcslen     wcslen
#define _tcsncat    wcsncat
#define _tcsncpy    wcsncpy
#define _tcspbrk    wcspbrk
#define _tcsrchr    wcsrchr
#define _tcsspn     wcsspn
#define _tcsstr     wcsstr
#define _tcstok     wcstok
#define _tcserror   _wcserror
#define __tcserror  __wcserror

#define _tcsdup     _wcsdup
#define _tcsnset    _wcsnset
#define _tcsrev     _wcsrev
#define _tcsset     _wcsset

#define _tcscmp     wcscmp
#define _tcsicmp    _wcsicmp
#define _tcsnccmp   wcsncmp
#define _tcsncmp    wcsncmp
#define _tcsncicmp  _wcsnicmp
#define _tcsnicmp   _wcsnicmp

#define _tcscoll    wcscoll
#define _tcsicoll   _wcsicoll
#define _tcsnccoll  _wcsncoll
#define _tcsncoll   _wcsncoll
#define _tcsncicoll _wcsnicoll
#define _tcsnicoll  _wcsnicoll


/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tctime64   _wctime64
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tutime64   _wutime64
#define _tcsftime   wcsftime


/* Directory functions */

#define _tchdir     _wchdir
#define _tgetcwd    _wgetcwd
#define _tgetdcwd   _wgetdcwd
#define _tmkdir     _wmkdir
#define _trmdir     _wrmdir


/* Environment/Path functions */

#define _tfullpath  _wfullpath
#define _tgetenv    _wgetenv
#define _tmakepath  _wmakepath
#define _tpgmptr    _wpgmptr
#define _tputenv    _wputenv
#define _tsearchenv _wsearchenv
#define _tsplitpath _wsplitpath


/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfreopen   _wfreopen
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam


/* Io functions */

#define _taccess    _waccess
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst _wfindfirst
#define _tfindfirst64   _wfindfirst64
#define _tfindfirsti64  _wfindfirsti64
#define _tfindnext  _wfindnext
#define _tfindnext64    _wfindnext64
#define _tfindnexti64   _wfindnexti64
#define _tmktemp    _wmktemp
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tunlink    _wunlink

#define _tfinddata_t    _wfinddata_t
#define _tfinddata64_t  __wfinddata64_t
#define _tfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _tstat      _wstat
#define _tstat64    _wstat64
#define _tstati64   _wstati64


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen    wcslen
#define _tcsnccat   wcsncat
#define _tcsnccpy   wcsncpy
#define _tcsncset   _wcsnset

#define _tcsdec     _wcsdec
#define _tcsinc     _wcsinc
#define _tcsnbcnt   _wcsncnt
#define _tcsnccnt   _wcsncnt
#define _tcsnextc   _wcsnextc
#define _tcsninc    _wcsninc
#define _tcsspnp    _wcsspnp

#define _tcslwr     _wcslwr
#define _tcsupr     _wcsupr
#define _tcsxfrm    wcsxfrm


#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const wchar_t *_cpc) { _cpc; return (1); }
__inline void __cdecl _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif  /* __STDC__ */


/* ctype functions */

#define _istalnum   iswalnum
#define _istalpha   iswalpha
#define _istascii   iswascii
#define _istcntrl   iswcntrl
#define _istdigit   iswdigit
#define _istgraph   iswgraph
#define _istlower   iswlower
#define _istprint   iswprint
#define _istpunct   iswpunct
#define _istspace   iswspace
#define _istupper   iswupper
#define _istxdigit  iswxdigit

#define _totupper   towupper
#define _totlower   towlower

#define _istlegal(_c)   (1)
#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)


#if     __STDC__ || defined(_NO_INLINING)
#define _wcsdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)((_cpc1)>=(_cpc2) ? NULL : ((_cpc2)-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#else   /* ndef _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <string.h>

#ifdef  __cplusplus
extern "C" {
#endif


#define _TEOF       EOF

#define __T(x)      x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif
#define __targv     __argv


/* Formatted i/o */

#define _tprintf    printf
#define _tcprintf   _cprintf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sctprintf  _scprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsctprintf _vscprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _tcscanf    _cscanf
#define _ftscanf    fscanf
#define _stscanf    sscanf
#define _sntscanf   _snscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _cputts     _cputs
#define _gettc      getc
#define _gettch     _getch
#define _gettche    _getche
#define _gettchar   getchar
#define _getts      gets
#define _cgetts     _cgets
#define _puttc      putc
#define _puttchar   putchar
#define _puttch     _putch
#define _putts      puts
#define _ungettc    ungetc
#define _ungettch   _ungetch


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul
#define _tstof      atof
#define _tstol      atol
#define _tstoi      atoi
#define _tstoi64    _atoi64

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol

#define _ttoi64     _atoi64
#define _tcstoi64   _strtoi64
#define _tcstoui64  _strtoui64
#define _i64tot     _i64toa
#define _ui64tot    _ui64toa

/* String functions */

/* Note that _mbscat, _mbscpy and _mbsdup are functionally equivalent to 
   strcat, strcpy and strdup, respectively. */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcsdup     _strdup

#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcserror   strerror
#define __tcserror  _strerror


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tctime64   _ctime64
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tutime64   _utime64
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tpgmptr    _pgmptr
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindfirst64   _findfirst64
#define _tfindfirsti64  _findfirsti64
#define _tfindnext  _findnext
#define _tfindnext64    _findnext64
#define _tfindnexti64   _findnexti64
#define _tmktemp    _mktemp

#ifdef  _POSIX_
#define _topen      open
#define _taccess    access
#else
#define _topen      _open
#define _taccess    _access
#endif

#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t
#define _tfinddata64_t  __finddata64_t
#define _tfinddatai64_t _finddatai64_t


/* ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit


/* Stat functions */

#define _tstat      _stat
#define _tstat64    _stat64
#define _tstati64   _stati64


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef  _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <mbstring.h>

#ifdef  __cplusplus
extern "C" {
#endif


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


#ifdef  _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _tcschr     _mbschr
#define _tcscspn    _mbscspn
#define _tcsncat    _mbsnbcat
#define _tcsncpy    _mbsnbcpy
#define _tcspbrk    _mbspbrk
#define _tcsrchr    _mbsrchr
#define _tcsspn     _mbsspn
#define _tcsstr     _mbsstr
#define _tcstok     _mbstok

#define _tcsnset    _mbsnbset
#define _tcsrev     _mbsrev
#define _tcsset     _mbsset

#define _tcscmp     _mbscmp
#define _tcsicmp    _mbsicmp
#define _tcsnccmp   _mbsncmp
#define _tcsncmp    _mbsnbcmp
#define _tcsncicmp  _mbsnicmp
#define _tcsnicmp   _mbsnbicmp

#define _tcscoll    _mbscoll
#define _tcsicoll   _mbsicoll
#define _tcsnccoll  _mbsncoll
#define _tcsncoll   _mbsnbcoll
#define _tcsncicoll _mbsnicoll
#define _tcsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _tcsclen    _mbslen
#define _tcsnccat   _mbsncat
#define _tcsnccpy   _mbsncpy
#define _tcsncset   _mbsnset


/* MBCS-specific mappings */

#define _tcsdec     _mbsdec
#define _tcsinc     _mbsinc
#define _tcsnbcnt   _mbsnbcnt
#define _tcsnccnt   _mbsnccnt
#define _tcsnextc   _mbsnextc
#define _tcsninc    _mbsninc
#define _tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcsupr     _mbsupr

#define _tclen      _mbclen
#define _tccpy      _mbccpy

#define _tccmp(_cpuc1,_cpuc2)   _tcsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     __STDC__ || defined(_NO_INLINING)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _tcschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _tcscspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcspbrk(const char *, const char *);
_CRTIMP char * __cdecl _tcsrchr(const char *, int);
_CRTIMP size_t __cdecl _tcsspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsstr(const char *, const char *);
_CRTIMP char * __cdecl _tcstok(char *, const char *);

_CRTIMP char * __cdecl _tcsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _tcsrev(char *);
_CRTIMP char * __cdecl _tcsset(char *, unsigned int);

_CRTIMP int __cdecl _tcscmp(const char *, const char *);
_CRTIMP int __cdecl _tcsicmp(const char *, const char *);
_CRTIMP int __cdecl _tcsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _tcscoll(const char *, const char *);
_CRTIMP int __cdecl _tcsicoll(const char *, const char *);
_CRTIMP int __cdecl _tcsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _tcsclen(const char *);
_CRTIMP char * __cdecl _tcsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _tcsdec(const char *, const char *);
_CRTIMP char * __cdecl _tcsinc(const char *);
_CRTIMP size_t __cdecl _tcsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _tcsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _tcsnextc (const char *);
_CRTIMP char * __cdecl _tcsninc(const char *, size_t);
_CRTIMP char * __cdecl _tcsspnp(const char *, const char *);

_CRTIMP char * __cdecl _tcslwr(char *);
_CRTIMP char * __cdecl _tcsupr(char *);

_CRTIMP size_t __cdecl _tclen(const char *);
_CRTIMP void __cdecl _tccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _tcscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _tcsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _tcsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _tcsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _tcscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _tcsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _tcsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _tcsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _tcsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _tcsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _tcsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _tcsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) {_n=((_UI)*(_PUC)_s1)<<8; _s1++;} _n+=(_UI)*(_PUC)_s1; return(_n);}


#endif  /* __STDC__ */

#endif  /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum   _ismbcalnum
#define _istalpha   _ismbcalpha
#define _istdigit   _ismbcdigit
#define _istgraph   _ismbcgraph
#define _istlegal   _ismbclegal
#define _istlower   _ismbclower
#define _istprint   _ismbcprint
#define _istpunct   _ismbcpunct
#define _istspace   _ismbcspace
#define _istupper   _ismbcupper

#define _totupper   _mbctoupper
#define _totlower   _mbctolower

#define _istlead    _ismbblead
#define _istleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* String functions */

#define _tcschr     strchr
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset

#define _tcscmp     strcmp
#define _tcsicmp    _stricmp
#define _tcsnccmp   strncmp
#define _tcsncmp    strncmp
#define _tcsncicmp  _strnicmp
#define _tcsnicmp   _strnicmp

#define _tcscoll    strcoll
#define _tcsicoll   _stricoll
#define _tcsnccoll  _strncoll
#define _tcsncoll   _strncoll
#define _tcsncicoll _strnicoll
#define _tcsnicoll  _strnicoll


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsncset   _strnset


/* MBCS-specific functions */

#define _tcsdec     _strdec
#define _tcsinc     _strinc
#define _tcsnbcnt   _strncnt
#define _tcsnccnt   _strncnt
#define _tcsnextc   _strnextc
#define _tcsninc    _strninc
#define _tcsspnp    _strspnp

#define _tcslwr     _strlwr
#define _tcsupr     _strupr
#define _tcsxfrm    strxfrm

#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)

#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const char *_cpc) { _cpc; return (1); }
__inline void __cdecl _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     __STDC__ || defined(_NO_INLINING)
#define _strdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(const unsigned char *)(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)((_cpc1)>=(_cpc2) ? NULL : (_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*(const unsigned char *)_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STRING
#define _INC_STRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Function prototypes */

        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);

#if     defined(_M_IA64)
        void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif


_CRTIMP char *  __cdecl strchr(const char *, int);
_CRTIMP int     __cdecl _strcmpi(const char *, const char *);
_CRTIMP int     __cdecl _stricmp(const char *, const char *);
_CRTIMP int     __cdecl strcoll(const char *, const char *);
_CRTIMP int     __cdecl _stricoll(const char *, const char *);
_CRTIMP int     __cdecl _strncoll(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicoll(const char *, const char *, size_t);
_CRTIMP size_t  __cdecl strcspn(const char *, const char *);
_CRTIMP char *  __cdecl _strdup(const char *);
_CRTIMP char *  __cdecl _strerror(const char *);
_CRTIMP char *  __cdecl strerror(int);
_CRTIMP char *  __cdecl _strlwr(char *);
_CRTIMP char *  __cdecl strncat(char *, const char *, size_t);
_CRTIMP int     __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char *  __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char *  __cdecl _strnset(char *, int, size_t);
_CRTIMP char *  __cdecl strpbrk(const char *, const char *);
_CRTIMP char *  __cdecl strrchr(const char *, int);
_CRTIMP char *  __cdecl _strrev(char *);
_CRTIMP size_t  __cdecl strspn(const char *, const char *);
_CRTIMP char *  __cdecl strstr(const char *, const char *);
_CRTIMP char *  __cdecl strtok(char *, const char *);
_CRTIMP char *  __cdecl _strupr(char *);
_CRTIMP size_t  __cdecl strxfrm (char *, const char *, size_t);


#if     !__STDC__

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif  /* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#ifdef _DLL
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines XENIX style macros for accessing arguments of a
*       function which takes a variable number of arguments.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_VARARGS
#define _INC_VARARGS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if     __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED

typedef char *va_list;

#define _VA_LIST_DEFINED
#endif


#if     defined(_M_CEE)

#error varargs.h not supported when targetting _M_CEE (use stdarg.h)

#elif   defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#elif defined(_M_IA64)

#ifndef _VA_LIST
#define _VA_LIST char*
#endif
typedef _VA_LIST va_list;

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define va_dcl __int64  va_alist;

#define va_start(ap)    ( ap = (va_list)&va_alist )

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)

extern void __cdecl __va_start(va_list *, ...);

#define va_dcl          va_list va_alist;
#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structure returned by the localtime and gmtime routines and
*       used by asctime.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIME
#define _INC_TIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define the implementation defined time type */

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif


/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

/* non-zero if daylight savings time is used */
_CRTIMP extern int _daylight;

/* offset for Daylight Saving Time */
_CRTIMP extern long _dstbias;

/* difference in seconds between GMT and local time */
_CRTIMP extern long _timezone;

/* standard/daylight savings time zone names */
_CRTIMP extern char * _tzname[2];


/* Function prototypes */

_CRTIMP char * __cdecl asctime(const struct tm *);
_CRTIMP char * __cdecl ctime(const time_t *);
_CRTIMP clock_t __cdecl clock(void);
_CRTIMP double __cdecl difftime(time_t, time_t);
_CRTIMP struct tm * __cdecl gmtime(const time_t *);
_CRTIMP struct tm * __cdecl localtime(const time_t *);
_CRTIMP time_t __cdecl mktime(struct tm *);
_CRTIMP time_t __cdecl _mkgmtime(struct tm *);
_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,
        const struct tm *);
_CRTIMP char * __cdecl _strdate(char *);
_CRTIMP char * __cdecl _strtime(char *);
_CRTIMP time_t __cdecl time(time_t *);

#ifdef  _POSIX_
_CRTIMP void __cdecl tzset(void);
#else
_CRTIMP void __cdecl _tzset(void);
#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _ctime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _gmtime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _localtime64(const __time64_t *);
_CRTIMP __time64_t __cdecl _mktime64(struct tm *);
_CRTIMP __time64_t __cdecl _mkgmtime64(struct tm *);
_CRTIMP __time64_t __cdecl _time64(__time64_t *);
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
unsigned __cdecl _getsystime(struct tm *);
unsigned __cdecl _setsystime(struct tm *, unsigned);
/* --------- The preceding functions are OBSOLETE --------- */


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in wchar.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif


#if     !__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

_CRTIMP extern int daylight;
_CRTIMP extern long timezone;
_CRTIMP extern char * tzname[2];

_CRTIMP void __cdecl tzset(void);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\typeinfo.h ===
/***
*typeinfo.h - Defines the type_info structure and exceptions used for RTTI
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef __cplusplus
#error This header requires a C++ compiler ...
#endif

#ifndef _INC_TYPEINFO
#define _INC_TYPEINFO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

class type_info {
public:
    _CRTIMP virtual ~type_info();
    _CRTIMP int operator==(const type_info& rhs) const;
    _CRTIMP int operator!=(const type_info& rhs) const;
    _CRTIMP int before(const type_info& rhs) const;
    _CRTIMP const char* name() const;
    _CRTIMP const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};


// This include must occur below the definition of class type_info
#include <stdexcpt.h>

class _CRTIMP bad_cast : public exception {
public:
    bad_cast(const char * _Message = "bad cast");
    bad_cast(const bad_cast &);
    virtual ~bad_cast();
};

class _CRTIMP bad_typeid : public exception {
public:
    bad_typeid(const char * _Message = "bad typeid");
    bad_typeid(const bad_typeid &);
    virtual ~bad_typeid();
};

class _CRTIMP __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * _Message);
    __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object();
};

#ifdef  __RTTI_OLDNAMES
// Some synonyms for folks using older standard
typedef type_info Type_info;
typedef bad_cast Bad_cast;
typedef bad_typeid Bad_typeid;
#endif  // __RTTI_OLDNAMES


#endif  // _INC_TYPEINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\wcstr.h ===
/***
* wcstr.h - declarations for wide character string manipulation functions
*
*       Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [OBSOLETE][UNICODE/ISO]
*
*	WARNING: OBSOLETE FILE: use wchar.h/stdlib.h instead!!!
*	This file provided only for short-term compatibility.  It will
*	disappear in the near future after a brief transitional period.
*
****/

#ifndef _INC_WCSTR

#include <wchar.h>
#define wcswcs wcsstr

#define _wcscmpi _wcsicmp
#if !__STDC__
#define wcscmpi	_wcsicmp
#endif

/* from stdlib.h */
int    __cdecl wctomb(char *, wchar_t);
size_t __cdecl wcstombs(char*, const wchar_t *, size_t);

#define _INC_WCSTR
#endif  /* _INC_WCSTR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#ifndef _YVALS
#define _YVALS
#include <use_ansi.h>

/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _CRTIMP */

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

 #pragma warning(disable: 4018 4114 4146 4244 4245)
 #pragma warning(disable: 4663 4664 4665)
 #pragma warning(disable: 4237 4284 4290 4514)
		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		};
  #define _STD_USING
 #else
  #define _STD			::
  #define _STD_BEGIN
  #define _STD_END
 #endif /* __cplusplus */
_STD_BEGIN
		/* TYPE bool */
 #if defined(__cplusplus)
typedef bool _Bool;
 #endif /* __cplusplus */
		/* INTEGER PROPERTIES */
#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36
		/* STDIO PROPERTIES */
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)	((long)(fp))
#endif /* _FPOS_T_DEFINED */

		/* NAMING PROPERTIES */
 #if defined(__cplusplus)
  #define _C_LIB_DECL extern "C" {
  #define _END_C_LIB_DECL }
 #else
  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
 #endif /* __cplusplus */
#define _CDECL
		// CLASS _Lockit
 #if defined(__cplusplus)
class _CRTIMP _Lockit
	{	// lock while object in existence
public:
  #ifdef _MT
   #define _LOCKIT(x)	lockit x
	_Lockit();
	~_Lockit();
  #else
   #define _LOCKIT(x)
	_Lockit()
		{}
	~_Lockit()
		{}
  #endif /* _MT */
	};
 #endif /* __cplusplus */
		/* MISCELLANEOUS MACROS */
#define _L(c)	L##c
#define _Mbstinit(x)	mbstate_t x = {0}
#define _MAX	_cpp_max
#define _MIN	_cpp_min
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YVALS */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\iostreams\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes' paramterized manipulators.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
        SMANIP(T)(ios& (*f)(ios&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
        friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:        \
        ios& (* _fp)(ios&,T); \
        T _tp; \
};      \
class SAPP(T) { \
public: \
        SAPP(T)( ios& (*f)(ios&,T)) : _fp(f) {} \
        SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:        \
        ios& (* _fp)(ios&,T); \
};      \
class IMANIP(T) { \
public: \
        IMANIP(T)(istream& (*f)(istream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        istream& (* _fp)(istream&,T); \
        T _tp;  \
};      \
class IAPP(T) { \
public: \
        IAPP(T)( istream& (*f)(istream&,T)) : _fp(f) {} \
        IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:        \
        istream& (* _fp)(istream&,T); \
};      \
class OMANIP(T) { \
public: \
        OMANIP(T)(ostream& (*f)(ostream&,T), T t) : _fp(f), _tp(t) {} \
        friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        ostream& (* _fp)(ostream&,T); \
        T _tp; \
};      \
class OAPP(T) { \
public: \
        OAPP(T)(ostream& (*f)(ostream&,T)) : _fp(f) {}  \
        OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:        \
        ostream& (* _fp)(ostream&,T); \
};      \
\
class IOMANIP(T) { \
public: \
        IOMANIP(T)(iostream& (*f)(iostream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
        friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        iostream& (* _fp)(iostream&,T); \
        T _tp; \
};      \
class IOAPP(T) {        \
public: \
        IOAPP(T)( iostream& (*f)(iostream&,T)) : _fp(f) {}      \
        IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }        \
private:        \
        iostream& (* _fp)(iostream&,T); \
}; \

        
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)     resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)      setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)     setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)      setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)      setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOMANIP

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif


#ifndef _INC_WCHAR
#define _INC_WCHAR



#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP */
#ifndef _CRTIMP
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#define WCHAR_MIN       0
#define WCHAR_MAX       ((wchar_t)-1)

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};

struct __wfinddata64_t {
        unsigned attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
#ifndef __PCTYPE_FUNC
#ifdef _MT
#define __PCTYPE_FUNC   __pctype_func()
#else
#define __PCTYPE_FUNC  _pctype
#endif  /* _MT */
#endif  /* __PCTYPE_FUNC */
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#ifndef _CTYPE_DISABLE_MACROS
#define isleadbyte(_c)  ( __PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#endif  /* _CTYPE_DISABLE_MACROS */

#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

#ifndef _CTYPE_DISABLE_MACROS
inline int __cdecl isleadbyte(int _C)
        {return (__PCTYPE_FUNC[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */


#ifndef _POSIX_

/* define structure for returning status information */

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif
#define _INO_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef unsigned int _dev_t;        /* device code */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long _off_t;                /* file offset value */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif
#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif

#endif  /* !_POSIX_ */


#ifndef _WCONIO_DEFINED

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif

#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);
_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);
_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#ifndef __cplusplus
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else   /* __cplusplus */
inline wint_t __cdecl getwchar()
        {return (fgetwc(&_iob[0])); }   /* stdin */
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, &_iob[1])); }       /* stdout */
#endif  /* __cplusplus */

#define getwc(_stm)     fgetwc(_stm)
#define putwc(_c,_stm)  fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif  /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

#ifdef  __cplusplus
        #define _WConst_return  const
#else
        #define _WConst_return
#endif

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP _WConst_return wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#ifdef  __cplusplus
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wcschr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcschr((const wchar_t *)_S, _C)); }
inline wchar_t *wcspbrk(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_S, _P)); }
inline wchar_t *wcsrchr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_S, _C)); }
inline wchar_t *wcsstr(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcsstr((const wchar_t *)_S, _P)); }
}

extern "C" {
#endif  /* __cplusplus */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */

_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif



typedef int mbstate_t;
typedef wchar_t _Wint_t;

_CRTIMP wint_t __cdecl btowc(int);
_CRTIMP size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
_CRTIMP size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
_CRTIMP size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

_CRTIMP size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
_CRTIMP size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
_CRTIMP int __cdecl wctob(wint_t);

#ifdef  __cplusplus

/* memcpy and memmove are defined just for use in wmemcpy and wmemmove */
#if     defined(_M_IA64)
void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif
void *  __cdecl memcpy(void *, const void *, size_t);

inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *_P)
        {return (_P == NULL || *_P == 0); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\iostreams\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the filebuf and fstream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static  const int       openprot;       // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int       sh_none;        // exclusive mode no sharing
static  const int       sh_read;        // allow read sharing
static  const int       sh_write;       // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int       binary;
static  const int       text;

                        filebuf();
                        filebuf(filedesc);
                        filebuf(filedesc, char *, int);
                        ~filebuf();

        filebuf*        attach(filedesc);
        filedesc        fd() const { return (x_fd==-1) ? EOF : x_fd; }
        int             is_open() const { return (x_fd!=-1); }
        filebuf*        open(const char *, int, int = filebuf::openprot);
        filebuf*        close();
        int             setmode(int = filebuf::text);

virtual int             overflow(int=EOF);
virtual int             underflow();

virtual streambuf*      setbuf(char *, int);
virtual streampos       seekoff(streamoff, ios::seek_dir, int);
// virtual      streampos       seekpos(streampos, int);
virtual int             sync();

private:
        filedesc        x_fd;
        int             x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
        ifstream();
        ifstream(const char *, int =ios::in, int = filebuf::openprot);
        ifstream(filedesc);
        ifstream(filedesc, char *, int);
        ~ifstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::in, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
        ofstream();
        ofstream(const char *, int =ios::out, int = filebuf::openprot);
        ofstream(filedesc);
        ofstream(filedesc, char *, int);
        ~ofstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::out, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
class _CRTIMP fstream : public iostream {
public:
        fstream();
        fstream(const char *, int, int = filebuf::openprot);
        fstream(filedesc);
        fstream(filedesc, char *, int);
        ~fstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_FSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\iostreams\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ios class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#ifdef  _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
    void * LockSemaphore;
    unsigned long Reserved;
} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
_CRTIMP void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif  /* _MT */

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
                     eofbit  = 0x01,
                     failbit = 0x02,
                     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
                     out       = 0x02,
                     ate       = 0x04,
                     app       = 0x08,
                     trunc     = 0x10,
                     nocreate  = 0x20,
                     noreplace = 0x40,
                     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
            left       = 0x0002,
            right      = 0x0004,
            internal   = 0x0008,
            dec        = 0x0010,
            oct        = 0x0020,
            hex        = 0x0040,
            showbase   = 0x0080,
            showpoint  = 0x0100,
            uppercase  = 0x0200,
            showpos    = 0x0400,
            scientific = 0x0800,
            fixed      = 0x1000,
            unitbuf    = 0x2000,
            stdio      = 0x4000
                                 };

    static const long basefield;        // dec | oct | hex
    static const long adjustfield;      // left | right | internal
    static const long floatfield;       // scientific | fixed

    ios(streambuf*);                    // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef  _MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);                    // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;                   // not used
    int     ospecial;                   // not used
    int     isfx_special;               // not used
    int     osfx_special;               // not used
    int     x_delbuf;                   // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();        // not used

#ifdef  _MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;         // make sure sync_with done only once
#ifdef  _MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;              // used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;                        // enable locking flag
    _CRT_CRITICAL_SECTION x_lock;       // used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef  _MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOS

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\crt\iostreams\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


typedef long streamoff, streampos;

#include <ios.h>                // Define ios.

#include <streamb.h>            // Define streambuf.

#include <istream.h>            // Define istream.

#include <ostream.h>            // Define ostream.

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
        iostream(streambuf*);
        virtual ~iostream();
protected:
        iostream();
        iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
        iostream(ios&);
        iostream(istream&);
        iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
        Iostream_init();
        Iostream_init(ios &, int =0);   // treat as private
        ~Iostream_init();
};

